- en: Creating Object Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象资源
- en: In the previous chapter, we got our clear screen working and created the Vulkan
    instance. We also created the logical device, the swapchain, the render targets,
    and the views, as well as the draw command buffer, to record and submit commands
    to the GPU. Using it, we were able to have a purple clear screen. We haven't drawn
    any geometry yet, but we are now ready to do so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使清除屏幕功能正常工作并创建了 Vulkan 实例。我们还创建了逻辑设备、交换链、渲染目标和视图，以及绘制命令缓冲区，以记录和提交命令到
    GPU。使用它，我们能够得到一个紫色的清除屏幕。我们还没有绘制任何几何形状，但现在我们已准备好这样做。
- en: In this chapter, we will get most of the things that we need ready to render
    the geometries. We have to create vertex, index, and uniform buffers. The vertex,
    index, and uniform buffers will have information regarding the vertex attributes,
    such as position, color, normal and texture coordinates; index information will
    have the indices of the vertices we want to draw, and uniform buffers will have
    information such as a novel view projection matrix.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将准备好渲染几何形状所需的大部分内容。我们必须创建顶点、索引和统一缓冲区。顶点、索引和统一缓冲区将包含有关顶点属性的信息，例如位置、颜色、法线和纹理坐标；索引信息将包含我们想要绘制的顶点的索引，统一缓冲区将包含如新的视图投影矩阵等信息。
- en: We will need to create a descriptor set and layout, which will specify to which
    shader stage the uniform buffers are bound.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个描述符集和布局，这将指定统一缓冲区绑定到哪个着色器阶段。
- en: We also have to generate the shaders that will be used to draw the geometry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须生成用于绘制几何形状的着色器。
- en: To create both the object buffers and descriptor sets and layouts, we will create
    new classes so that they are compartmentalized and we can understand how they
    are related. Before we hop on the object buffer class, we will add the `Mesh`
    class that we created in the OpenGL project, and we will use the same class and
    add minor changes to it. The `Mesh` class has information regarding the vertex
    and index information for the different geometry shapes we want to draw.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建对象缓冲区和描述符集以及布局，我们将创建新的类，以便它们被分离开来，我们可以理解它们是如何相关的。在我们跳到对象缓冲区类之前，我们将添加在 OpenGL
    项目中创建的 `Mesh` 类，并且我们将使用相同的类并对它进行一些小的修改。`Mesh` 类包含有关我们想要绘制的不同几何形状的顶点和索引信息。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Updating the `Mesh` class for Vulkan
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `Mesh` 类以支持 Vulkan
- en: Creating the `ObjectBuffers` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `ObjectBuffers` 类
- en: Creating the `Descriptor` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `Descriptor` 类
- en: Creating the SPIR-V shader binary
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SPIR-V 着色器二进制文件
- en: Updating the Mesh class for Vulkan
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 Mesh 类以支持 Vulkan
- en: 'In the `Mesh.h` file, we just have to add a few lines of code to specify `InputBindingDescription`
    and `InputAttributeDescription`. In `InputBindingDesciption`, we specify the binding
    location, the stride of the data itself, and the input rate, which specifies whether the
    data is per vertex or per instance. In the `Mesh.h` file in the OpenGL project,
    we will just add functions to the `Vertex` struct:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Mesh.h` 文件中，我们只需添加几行代码来指定 `InputBindingDescription` 和 `InputAttributeDescription`。在
    `InputBindingDesciption` 中，我们指定绑定位置、数据本身的步长以及输入速率，它指定数据是按顶点还是按实例。在 OpenGL 项目的
    `Mesh.h` 文件中，我们只需向 `Vertex` 结构体添加函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, in the `Vertex` struct, add the function to retrieve `AttributeDesciption`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Vertex`结构体中，添加一个用于检索`AttributeDescription`的函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the function, `VertexInputBindingDescriptor` specifies that the binding is
    at the 0^(th) index, the stride is equal to the size of the `Vertex` struct itself,
    and the input rate is `VK_VERTEX_INPUT_RATE_VERTEX`, which is per vertex. The
    function just returns the created binding description.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `VertexInputBindingDescriptor` 中，指定绑定位于第 0 个索引，步长等于 `Vertex` 结构体本身的大小，输入速率是
    `VK_VERTEX_INPUT_RATE_VERTEX`，即按顶点。该函数仅返回创建的绑定描述。
- en: 'Since we have four attributes in the vertex struct, we have to create an attribute
    descriptor for each one. Add the following function to the `Vertex` struct as
    well, which returns an array of four input attribute descriptors. For each attribute
    descriptor, we have to specify the binding location, which is `0` as specified
    in the binding description, the layout location for each attribute, the format
    of the data type, and the offset from the start of the `Vertex` struct:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在顶点结构体中有四个属性，我们必须为每个属性创建一个属性描述符。将以下函数添加到 `Vertex` 结构体中，该函数返回一个包含四个输入属性描述符的数组。对于每个属性描述符，我们必须指定绑定位置，即绑定描述中指定的
    `0`，每个属性的布局位置，数据类型的格式，以及从 `Vertex` 结构体开始的偏移量：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will also create a new struct in the `Mesh.h` file to organize the uniform
    data information. So, create a new struct called `UniformBufferObject`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 `Mesh.h` 文件中创建一个新的结构体来组织统一数据信息。因此，创建一个名为 `UniformBufferObject` 的新结构体：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the top of the `Mesh.h` file, we will also include two `define` statements
    to tell `GLM` to use radians instead of degrees, and to use the normalized depth
    value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Mesh.h` 文件顶部，我们还将包含两个 `define` 语句来告诉 `GLM` 使用弧度而不是度数，并使用归一化深度值：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That is all for `Mesh.h`. The `Mesh.cpp` file doesn't get modified at all.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Mesh.h` 文件来说，这就结束了。`Mesh.cpp` 文件完全没有被修改。
- en: Creating the ObjectBuffers class
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `ObjectBuffers` 类
- en: 'To create object-related buffers, such as vertex, index, and uniform, we will
    create a new class called `ObjectBuffers`. In the `ObjectBuffers.h` file, we will
    add the required `include` statements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建与对象相关的缓冲区，例如顶点、索引和统一缓冲区，我们将创建一个新的类，称为 `ObjectBuffers`。在 `ObjectBuffers.h`
    文件中，我们将添加所需的 `include` 语句：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will create the class itself. In the public section, we will add the
    constructor and the destructor and add the required data types for creating vertex,
    index, and uniform buffers. We add a vector of the data vertex to set the vertex
    information of the geometry, create a `VkBuffer` instance called `vertexBuffer`
    to store the vertex buffer, and create a `VkDeviceMemory` instance called `vertexBufferMemory`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建类本身。在公共部分，我们将添加构造函数和析构函数，并添加创建顶点、索引和统一缓冲区所需的数据类型。我们添加一个数据顶点的向量来设置几何体的顶点信息，创建一个名为
    `vertexBuffer` 的 `VkBuffer` 实例来存储顶点缓冲区，并创建一个名为 `vertexBufferMemory` 的 `VkDeviceMemory`
    实例：
- en: '`VkBuffer`: This is the handle to the object buffer itself.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VkBuffer`：这是对象缓冲区的句柄。'
- en: '`VkDeviceMemory`: Vulkan operates on memory data in the device''s memory through
    the `DeviceMemory` object.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VkDeviceMemory`：Vulkan 通过 `DeviceMemory` 对象在设备的内存中操作内存数据。'
- en: Similarly, we create a vector to store indices, and create an `indexBuffer`
    and an `indexBufferMemory` object, just as we did for vertex.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们创建一个向量来存储索引，并创建一个 `indexBuffer` 和 `indexBufferMemory` 对象，就像我们为顶点所做的那样。
- en: For the uniform buffer, we only create `uniformBuffer` and `uniformBuffer` memory
    as a vector is not required.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统一缓冲区，我们只创建 `uniformBuffer` 和 `uniformBuffer` 内存，因为不需要向量。
- en: We add a `createVertexIndexUniformBuffers` function that takes in a `Mesh` type,
    and the vertices and indices will be set based on it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `createVertexIndexUniformBuffers` 函数，它接受一个 `Mesh` 类型，并且顶点和索引将根据它设置。
- en: We also add a destroy function to destroy the Vulkan object we created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个销毁函数来销毁我们创建的 Vulkan 对象。
- en: 'In the private section, we add three functions, which `createVertexIndexUniformBuffers`
    will call to create the buffers. That is all for the `ObjectBuffers.h` file. So,
    the `ObjectBuffers` class should be like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在私有部分，我们添加了三个函数，`createVertexIndexUniformBuffers` 将会调用这些函数来创建缓冲区。这就是 `ObjectBuffers.h`
    文件的全部内容。因此，`ObjectBuffers` 类应该如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s move on to the `ObjectBuffers.cpp` file. In this file, we include
    the headers and create the constructor and destructor:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续转到 `ObjectBuffers.cpp` 文件。在这个文件中，我们包含头文件并创建构造函数和析构函数：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Tools.h` is included as we will be adding some more functionality to it that
    we will use. Next, we will create the `createVertexIndexUniformBuffers` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tools.h` 被包含进来，因为我们将会向其中添加一些我们将要使用的功能。接下来，我们将创建 `createVertexIndexUniformBuffers`
    函数：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to the OpenGL project, we will add a `switch` statement to set the vertex
    and index data depending on the mesh type. Then we call the `createVertexBuffer`,
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenGL 项目类似，我们将添加一个 `switch` 语句来根据网格类型设置顶点和索引数据。然后我们调用 `createVertexBuffer`，
- en: '`createIndexBuffer`, and `createUniformBuffers` functions to set the respective
    buffers. We will create the `createVertexBuffer` function first.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`createIndexBuffer` 和 `createUniformBuffers` 函数来设置相应的缓冲区。我们首先创建 `createVertexBuffer`
    函数。'
- en: To create the vertex buffer, it is better if we create the buffer on the device
    that is on the **GPU** itself. Now, the **GPU** has two types of memories: **HOST
    VISIBLE** and **DEVICE LOCAL**. **HOST VISIBLE** is a part of the GPU memory that
    the CPU has access to. This memory is not very large, so it is used for storing up
    to 250 MB of data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建顶点缓冲区，最好在**GPU**本身上的设备上创建缓冲区。现在，**GPU**有两种类型的内存：**HOST VISIBLE**和**DEVICE
    LOCAL**。**HOST VISIBLE**是CPU可以访问的GPU内存的一部分。这种内存不是很大，因此用于存储最多250 MB的数据。
- en: For larger chunks of data, such as vertex and index data, it is better to use
    the **DEVICE LOCAL** memory, which the CPU doesn't have access to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的数据块，例如顶点和索引数据，最好使用**DEVICE LOCAL**内存，CPU无法访问这部分内存。
- en: 'So, how do you transfer data to the `DEVICE LOCAL` memory? Well, we first have
    to copy the data to the **HOST VISIBLE** section on the **GPU**, and then copy
    it to the **DEVICE LOCAL** memory. So, we first create what is called a staging
    buffer, copy the vertex data into it, and then copy the staging buffer to the
    actual vertex buffer:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何将数据传输到`DEVICE LOCAL`内存呢？首先，我们必须将数据复制到**GPU**上的**HOST VISIBLE**部分，然后将其复制到**DEVICE
    LOCAL**内存。因此，我们首先创建一个称为阶段缓冲区的东西，将顶点数据复制进去，然后将阶段缓冲区复制到实际的顶点缓冲区：
- en: '![](img/cc52a322-ee49-4ab3-b470-b047522a29f1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc52a322-ee49-4ab3-b470-b047522a29f1.png)'
- en: '(Source: [https://www.youtube.com/watch?v=rXSdDE7NWmA](https://www.youtube.com/watch?v=rXSdDE7NWmA))'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[https://www.youtube.com/watch?v=rXSdDE7NWmA](https://www.youtube.com/watch?v=rXSdDE7NWmA)）
- en: 'Let''s add functionality into the `VkTool` file to create the different kinds
    of buffers. With this, we can create both the staging buffer and vertex buffer
    itself. So, in the `VkTools.h` file in the `vkTools` namespace, add a new function
    called `createBuffer`. This function takes in five parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`VkTool`文件中添加创建不同类型缓冲区的功能。这样，我们就可以创建阶段缓冲区和顶点缓冲区本身。因此，在`VkTools.h`文件中的`vkTools`命名空间中，添加一个名为`createBuffer`的新函数。此函数接受五个参数：
- en: The first is `VkDeviceSize`, which is the size of the data for which the buffer
    is to be created.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是`VkDeviceSize`，这是要创建的缓冲区数据的大小。
- en: The second is the `usage` flag, which tells us what the buffer is going to be
    used for.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二项是`usage`标志，它告诉我们缓冲区将要用于什么。
- en: The third is the memory properties where we want to create the buffer; this
    is where we will specify whether we want it in the HOST VISIBLE section or the
    DEVICE LOCAL area.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三点是内存属性，这是我们想要创建缓冲区的地方；这里我们将指定我们希望它在HOST VISIBLE部分还是DEVICE LOCAL区域。
- en: The fourth is the buffer itself.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四点是缓冲区本身。
- en: 'The fifth is the buffer memory to bind the buffer to the following:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五点是缓冲区内存，用于将缓冲区绑定到以下内容：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `VKTools.cpp` file, we add the functionality for creating the buffer
    and binding it to `bufferMemory`. In the namespace, add the new function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VKTools.cpp`文件中，我们添加了创建缓冲区并将其绑定到`bufferMemory`的功能。在命名空间中添加新的函数：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before binding the buffer, we create the buffer itself. Hence, we populate
    the `VkBufferCreateInfo` struct as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定缓冲区之前，我们首先创建缓冲区本身。因此，我们按照以下方式填充`VkBufferCreateInfo`结构体：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The struct takes the usual type first, and then we set the buffer size and usage.
    We also need to specify the buffer sharing mode, because a buffer can be shared
    between queues, such as graphics and compute, or could be exclusive to one queue.
    So, here we specify that the buffer is exclusive to the current queue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体首先采用通常的类型，然后我们设置缓冲区大小和用途。我们还需要指定缓冲区共享模式，因为缓冲区可以在队列之间共享，例如图形和计算，或者可能仅限于一个队列。因此，在这里我们指定缓冲区仅限于当前队列。
- en: Then, the buffer is created by calling `vkCreateBuffer` and passing in `logicalDevice`
    and `bufferInfo`. Next, to bind the buffer, we have to get the suitable memory
    type for our specific use of the buffer. So, first we have to get the memory requirements
    for the kind of buffer we are creating. The requisite memory requirement is received
    by calling the `vkGetBUfferMemoryRequirements` function, which takes in the logical
    device, the buffer, and the memory requirements get stored in a variable type
    called `VkMemoryRequirements`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过调用`vkCreateBuffer`并传入`logicalDevice`和`bufferInfo`来创建缓冲区。接下来，为了绑定缓冲区，我们必须获取适合我们特定缓冲区用途的合适内存类型。因此，首先我们必须获取我们正在创建的缓冲区类型的内存需求。必需的内存需求是通过调用`vkGetBufferMemoryRequirements`函数接收的，该函数接受逻辑设备、缓冲区和内存需求存储在一个名为`VkMemoryRequirements`的变量类型中。
- en: 'We get the memory requirements as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式获取内存需求：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To bind memory, we have to populate the `VkMemoryAllocateInfo` struct. It requires
    the allocation size and the memory index of the type of memory. Each GPU has a different
    memory type index, with a different heap index and memory type. These are the
    corresponding values for 1080Ti:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定内存，我们必须填充 `VkMemoryAllocateInfo` 结构体。它需要分配大小和所需内存类型的内存索引。每个 GPU 都有不同的内存类型索引，具有不同的堆索引和内存类型。以下是
    1080Ti 的对应值：
- en: '![](img/48567b6b-285e-4469-8643-0b026dd39363.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48567b6b-285e-4469-8643-0b026dd39363.png)'
- en: 'We will now add a new function in `VkTools` to get the correct kind of memory
    index for our buffer usage. So, add a new function in `VkTool.h` under the `vkTools`
    namespace, called `findMemoryTypeIndex`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 `VkTools` 中添加一个新函数来获取适合我们缓冲区使用的正确类型的内存索引。因此，在 `VkTool.h` 中的 `vkTools`
    命名空间下添加一个新函数，称为 `findMemoryTypeIndex`：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It takes two parameters, which are the memory type bits available and the memory
    properties that we need. Add the implementation for the `findMemoryTypeIndex`
    function to the `VkTools.cpp` file. Under the namespace, add the following function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个参数，即可用的内存类型位和所需的内存属性。将 `findMemoryTypeIndex` 函数的实现添加到 `VkTools.cpp` 文件中。在命名空间下，添加以下函数：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function gets the device's memory properties using the `vkGetPhysicalDeviceMemoryProperties`
    function, and populates the memory properties of the physical device.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `vkGetPhysicalDeviceMemoryProperties` 函数获取设备的内存属性，并填充物理设备的内存属性。
- en: 'The memory properties get information regarding the memory heap and memory
    type for each index. From all the available indices, we choose what is required
    for our purposes and return the values. Once the function has been created, we
    can go back to binding the buffer. So, continuing with our `createBuffer` function,
    add the following to it in order to bind the buffer to the memory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内存属性获取每个索引的内存堆和内存类型的信息。从所有可用索引中，我们选择我们所需的内容并返回值。一旦函数创建完成，我们就可以回到绑定缓冲区。因此，继续我们的
    `createBuffer` 函数，向其中添加以下内容以绑定缓冲区到内存：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After all that, we can go back to `ObjectBuffers` to actually create the `createVertexBuffers`
    function. So, create the function as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们可以回到 `ObjectBuffers` 实际创建 `createVertexBuffers` 函数。因此，创建函数如下：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In it, we will create the staging buffer first, copy the vertex data into it,
    and then copy the staging buffer into the vertex buffer. In the function, we first
    get the total buffer size, which is the number of vertices and the size of the
    data stored per vertex:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们首先创建阶段缓冲区，将顶点数据复制到其中，然后将阶段缓冲区复制到顶点缓冲区。在函数中，我们首先获取总缓冲区大小，这是顶点数和每个顶点存储的数据大小：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we create the staging buffer and `stagingBufferMemory` to bind the staging
    buffer to it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建阶段缓冲区和 `stagingBufferMemory` 以将阶段缓冲区绑定到它：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And then we call the newly created `createBuffer` in `vkTools` to create the
    buffer:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用新创建的 `createBuffer` 在 `vkTools` 中创建缓冲区：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In it, we pass in the size, usage, memory type we want, and the buffer and buffer
    memory. `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` indicates that the buffer is going
    to be used as part of a source transfer command when data is transferred.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们传入我们想要的尺寸、使用方式和内存类型，以及缓冲区和缓冲区内存。`VK_BUFFER_USAGE_TRANSFER_SRC_BIT` 表示该缓冲区将在数据传输时作为源传输命令的一部分使用。
- en: '`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` specifies that we want this to be allocated
    in the host-visible (CPU) memory space on the GPU.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` 表示我们希望它在 GPU 上的主机可见（CPU）内存空间中分配。'
- en: '`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` means that CPU cache management is not
    done by us, but by the system. This will make sure the mapped memory matches the
    allocated memory. Next, we use `vkMapMemory` to get a host pointer to the staging
    buffer and create a void pointer called data. Then, call `vkMapMemory` to get
    the pointer to the mapped memory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` 表示 CPU 缓存管理不是由我们完成，而是由系统完成。这将确保映射内存与分配的内存匹配。接下来，我们使用
    `vkMapMemory` 获取阶段缓冲区的宿主指针并创建一个 void 指针称为 data。然后调用 `vkMapMemory` 获取映射内存的指针：'
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`VkMapMemory` takes the logical device, the staging buffer binding, we specify
    0 for the offset, and pass the buffer size. There are no special flags, so we
    pass in `0` and get the pointer to the mapped memory. We use `memcpy` to copy
    the vertex data to the data pointer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`VkMapMemory` 接收逻辑设备、阶段缓冲区绑定，我们指定 0 作为偏移量，并传递缓冲区大小。没有特殊标志，因此我们传递 `0` 并获取映射内存的指针。我们使用
    `memcpy` 将顶点数据复制到数据指针：'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We unmap the staging memory once host access to it is no longer required:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要主机对它的访问时，我们取消映射阶段内存：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that the data is stored in the staging buffer, let''s next create the vertex
    buffer and bind it to `vertexBufferMemory`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已存储在阶段缓冲区中，接下来创建顶点缓冲区并将其绑定到`vertexBufferMemory`：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We use the `createBuffer` function to create the vertex buffer. We pass in the
    buffer size. For the buffer usage, we specify that it is used as the destination
    of the transfer command when we transfer the staging buffer to it, and it will
    be used as the vertex buffer. For the memory property, we want this to be created
    in `DEVICE_LOCAL` for the best performance. Pass the vertex buffer and vertex
    buffer memory to bind the buffer to the memory. Now, we have to copy the staging
    buffer to the vertex buffer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`createBuffer`函数来创建顶点缓冲区。我们传入缓冲区大小。对于缓冲区用途，我们指定当我们将阶段缓冲区传输到它时，它用作传输命令的目标，并且它将用作顶点缓冲区。对于内存属性，我们希望它在`DEVICE_LOCAL`中创建以获得最佳性能。传递顶点缓冲区和顶点缓冲区内存以绑定缓冲区到内存。现在，我们必须将阶段缓冲区复制到顶点缓冲区。
- en: Copying buffers on the GPU has to be done using transfer queues and command
    buffers. We could get the transfer queue to do the transfer in the same way as we
    retrieved the graphics and presentation queues. The good news is that we don't
    need to, because all graphics and compute queues also support transfer functionality,
    so we will use the graphics queue for it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上复制缓冲区必须使用传输队列和命令缓冲区。我们可以像检索图形和显示队列一样获取传输队列来完成传输。好消息是，我们不需要这样做，因为所有图形和计算队列也支持传输功能，所以我们将使用图形队列来完成。
- en: 'We will create two helper functions in the `vkTools` namespace for creating
    and destroying temporary command buffers. So, in the `VkTools.h` file, add two
    functions in the namespace for the beginning and ending single-time commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`vkTools`命名空间中创建两个辅助函数来创建和销毁临时命令缓冲区。因此，在`VkTools.h`文件中，在命名空间中添加两个函数用于开始和结束单次命令：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Basically, `beginSingleTimeCommands` returns a command buffer for us to use,
    and `endSingleTimeCommands` destroys the command buffer. In the `VkTools.cpp`
    file, under the namespace, add these two functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`beginSingleTimeCommands`为我们返回一个命令缓冲区以供使用，而`endSingleTimeCommands`销毁命令缓冲区。在`VkTools.cpp`文件中，在命名空间下添加这两个函数：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have already looked at how to create and destroy command buffers. If you
    have any questions, you can refer to [Chapter 11](58a38eaf-b67b-4425-b5d6-80efaf4970ad.xhtml),
    *Preparing the Clear Screen*. Next, in the `Vktools.h` file, we will add the functionality
    to copy a buffer. Add a new function under the namespace:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何创建和销毁命令缓冲区。如果您有任何疑问，可以参考第11章，*准备清屏*。接下来，在`Vktools.h`文件中，我们将添加复制缓冲区的功能。在命名空间下添加一个新函数：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `copyBuffer` function takes a source buffer, a destination buffer, and
    the buffer size as input. Now, add this new function to the `VkTools.cpp` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyBuffer`函数接受源缓冲区、目标缓冲区和缓冲区大小作为输入。现在，将此新函数添加到`VkTools.cpp`文件中：'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the function, we first get the queue family indices from the device. We then
    create a new command pool, and then we create a new command buffer using the `beginSingleTimeCommands`
    function. To copy the buffer, we create the `VkBufferCopy` struct. We set the
    source and destination offset to be `0` and set the buffer size.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，我们首先从设备获取队列家族索引。然后我们创建一个新的命令池，然后使用`beginSingleTimeCommands`函数创建一个新的命令缓冲区。为了复制缓冲区，我们创建`VkBufferCopy`结构。我们将源和目标偏移量设置为`0`并设置缓冲区大小。
- en: To actually copy the buffers, we call the `vlCmdCopyBuffer` function, which
    takes in a command buffer, the source command buffer, the destination command
    buffer, the copy region count (which is `1` in this case), and the copy region
    struct. Once the buffers are copied, we call `endSingleTimeCommands` to destroy
    the command buffer and call `vkDestroyCommandPool` to destroy the command pool
    itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际复制缓冲区，我们调用`vlCmdCopyBuffer`函数，它接受一个命令缓冲区、源命令缓冲区、目标命令缓冲区、复制区域数量（在这种情况下为`1`）和复制区域结构。一旦缓冲区被复制，我们调用`endSingleTimeCommands`来销毁命令缓冲区，并调用`vkDestroyCommandPool`来销毁命令池本身。
- en: 'Now, we can go back to the `createVertexBuffers` function in `ObjectsBuffers`
    and copy the staging buffer to the vertex buffer. We also destroy the staging
    buffer and the buffer memory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到`ObjectsBuffers`中的`createVertexBuffers`函数，并将阶段缓冲区复制到顶点缓冲区。我们还会销毁阶段缓冲区和缓冲区内存：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The index buffers are created the same way, using the `createIndexBuffer` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 索引缓冲区的创建方式相同，使用`createIndexBuffer`函数：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Creating `UniformBuffer` is easier, because we will just be using the `HOST_VISIBLE`
    GPU memory, so staging buffers are not required:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`UniformBuffer`比较简单，因为我们只需使用`HOST_VISIBLE` GPU 内存，因此不需要阶段缓冲区：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we destroy the buffers and memories in the `destroy` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`destroy`函数中销毁缓冲区和内存：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating the Descriptor class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建描述符类
- en: Unlike OpenGL, where we had uniform buffers to pass in the model, view, projection,
    and other kinds of data, Vulkan has descriptors. In descriptors, we have to first
    specify the layout of the buffer, as well as the binding location, count, type
    of descriptor, and the shader stage it is associated with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenGL不同，在OpenGL中我们使用统一缓冲区来传递模型、视图、投影和其他类型的数据，而Vulkan使用描述符。在描述符中，我们必须首先指定缓冲区的布局，以及绑定位置、计数、描述符类型以及与之关联的着色器阶段。
- en: Once the descriptor layout is created with the different types of descriptors,
    we have to create a descriptor pool for the number-swapchain image count because
    the uniform buffer will be set for each time per frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用不同类型的描述符创建了描述符布局，我们必须为数字交换链图像计数创建一个描述符池，因为统一缓冲区将每帧设置一次。
- en: After that, we can allocate and populate the descriptor sets for both the frames.
    The allocation of data will be done from the pool.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以为两个帧分配和填充描述符集。数据分配将从池中完成。
- en: 'We will create a new class for creating the descriptor set, layout binding,
    pool, and allocating and populating the descriptor sets. Create a new class called
    `Descriptor`. In the `Descriptor.h` file, add the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类来创建描述符集、布局绑定、池以及分配和填充描述符集。创建一个名为`Descriptor`的新类。在`Descriptor.h`文件中，添加以下代码：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We include the usual `Vulkan.h` and vector. In the public section, we create
    the class with the constructor and the destructor. We also create three variables,
    called `descriptorSetLayout`, `descriptorPool`, and `descriptorSets`, of the `VkDescriptorSetLayout`,
    `VkDescriptorPool`, and `VkDescriptorSet` types for easy access to the set. The
    `createDescriptorLayoutSetPoolAndAllocate` function will call the private `createDescriptorSetLayout`
    and `createDescriptorPoolAndAllocateSets` functions, which will create the layout
    set and then create the descriptor pool and allocate to it. The `populateDescriptorSets`
    function will be called when we set the uniform buffer to populate the sets with
    the data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含常用的`Vulkan.h`和vector。在公共部分，我们使用构造函数和析构函数创建类。我们还创建了三个变量，分别称为`descriptorSetLayout`、`descriptorPool`和`descriptorSets`，它们分别对应于`VkDescriptorSetLayout`、`VkDescriptorPool`和`VkDescriptorSet`类型，以便于访问集合。`createDescriptorLayoutSetPoolAndAllocate`函数将调用私有的`createDescriptorSetLayout`和`createDescriptorPoolAndAllocateSets`函数，这些函数将创建布局集，然后创建描述符池并将其分配。当我们将统一缓冲区设置为填充集合中的数据时，将调用`populateDescriptorSets`函数。
- en: 'We also have a `destroy` function to destroy the Vulkan objects that have been
    created. In the `Descriptor.cpp` file, we will add the implementations of the
    functions. Add the necessary includes first, and then add the constructor, destructor,
    and the `createDescriptorLayoutAndPool` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`destroy`函数来销毁已创建的Vulkan对象。在`Descriptor.cpp`文件中，我们将添加函数的实现。首先添加必要的包含，然后添加构造函数、析构函数和`createDescriptorLayoutAndPool`函数：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `createDescriptorLayoutSetPoolAndAllocate` function calls the `createDescriptorSetLayout`
    and `createDescriptorPoolAndAllocateSets` functions. Let''s now add the `createDescriptorSetLayout`
    function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDescriptorLayoutSetPoolAndAllocate`函数调用`createDescriptorSetLayout`和`createDescriptorPoolAndAllocateSets`函数。现在让我们添加`createDescriptorSetLayout`函数：'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For our project, the layout set will just have one layout binding, which is
    the one struct with the model, view, and projection matrix information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，布局集将只有一个布局绑定，即包含模型、视图和投影矩阵信息的那个结构体。
- en: We have to populate the `VkDescriptorSetLayout` struct and specify the binding
    location index, the count, the type of information we will be passing in, and
    the shader stage to which the uniform buffer will be sent. After creating the
    set layout, we populate `VkDescriptorSetLayoutCreateInfo`, in which we specify
    the binding count and the bindings itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须填充`VkDescriptorSetLayout`结构体，并指定绑定位置索引、计数、我们将传递的信息类型以及统一缓冲区将被发送到的着色器阶段。在创建集合布局后，我们填充`VkDescriptorSetLayoutCreateInfo`，在其中指定绑定计数和绑定本身。
- en: 'Then, we call the `vkCreateDescriptorSetLayout` function to create the descriptor
    set layout by passing in the logical device and the layout creation info. Next,
    we add the `createDescriptorPoolAndAllocateSets` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`vkCreateDescriptorSetLayout`函数，通过传递逻辑设备和布局创建信息来创建描述符集布局。接下来，我们添加`createDescriptorPoolAndAllocateSets`函数：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create the descriptor pool, we have to specify the pool size using `VkDescriptorPoolSize`.
    We create an array of it and call it `poolSizes`. Since, in the layout set, we
    just have the uniform buffer, we set its type and set the count equal to the swap-chain-image
    count. To create the descriptor pool, we have to specify the type, pool-size count,
    and the pool-size data. We also have to set the maxsets, which is the maximum
    number of sets that can be allocated from the pool, which is equal to the swap-chain-image
    count. We create the descriptor pool by calling `vkCreateDescriptorPool` and passing
    in the logical device and the pool-creation info. Next, we have to specify allocation
    parameters for the description sets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建描述符池，我们必须使用`VkDescriptorPoolSize`指定池大小。我们创建一个数组并命名为`poolSizes`。由于在布局集中我们只有统一缓冲区，我们设置其类型并将计数设置为与交换链图像计数相等。要创建描述符池，我们必须指定类型、池大小计数和池大小数据。我们还需要设置`maxsets`，即可以从池中分配的最大集合数，它等于交换链图像计数。我们通过调用`vkCreateDescriptorPool`并传递逻辑设备和池创建信息来创建描述符池。接下来，我们必须指定描述符集的分配参数。
- en: We create a vector of the descriptor set layout. Then, we create the `VkDescriptionAllocationInfo`
    struct to populate it. We pass in the description pool, the descriptor set count
    (which is equal to the swap-chain-images count), and pass in the layout data.
    Then, we allocate the descriptor sets by calling `vkAllocateDescriptorSets` and
    passing in the logical device and the create info struct.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个描述符集布局的向量。然后，我们创建`VkDescriptionAllocationInfo`结构体来填充它。我们传递描述符池、描述符集计数（等于交换链图像计数）和布局数据。然后，通过调用`vkAllocateDescriptorSets`并传递逻辑设备和创建信息结构体来分配描述符集。
- en: 'Finally, we will add the `populateDescriptorSets` function, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加`populateDescriptorSets`函数，如下所示：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function takes in the swapchain image count and the uniform buffer as parameters.
    For both the images of the swapchain, the configuration of the descriptor needs
    to be updated by calling `vkUpdateDescriptorSets`. This function takes in an array
    of `VkWriteDescriptorSet`. Now, `VkWriteDescriptorSet` takes in either a buffer,
    image struct, or `texelBufferView` as a parameter. Since we are going to use the
    uniform buffer, we will have to create it and pass it in. `VkdescriptorBufferInfo`
    takes in a buffer (which will be the uniform buffer we created), takes an offset
    (which is none in this case), and then takes the range (which is the size of the
    buffer itself).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收交换链图像计数和统一缓冲区作为参数。对于交换链的两个图像，需要通过调用`vkUpdateDescriptorSets`来更新描述符的配置。此函数接收一个`VkWriteDescriptorSet`数组。现在，`VkWriteDescriptorSet`接收一个缓冲区、图像结构体或`texelBufferView`作为参数。由于我们将使用统一缓冲区，我们必须创建它并传递它。`VkdescriptorBufferInfo`接收一个缓冲区（将是创建的统一缓冲区），接收一个偏移量（在这种情况下为无），然后接收范围（即缓冲区本身的大小）。
- en: After creating it, we can start specifying `VkWriteDescriptorSet`. This takes
    in the type, `descriptorSet`, and the binding location (which is the 0^(th) index).
    It has no array elements in it, and it takes the descriptor type (which is the
    uniform buffer type); the descriptor count is `1`, and we pass in the buffer info
    struct. For the image info and the texel buffer view, we specify none, as it is
    not being used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，我们可以开始指定`VkWriteDescriptorSet`。这个函数接收类型、`descriptorSet`和绑定位置（即第0个索引）。它没有数组元素，并接收描述符类型（即统一缓冲区类型）；描述符计数为`1`，我们传递缓冲区信息结构体。对于图像信息和纹理缓冲区视图，我们指定为无，因为它没有被使用。
- en: 'We then create an array of `VkWriteDescriptorSet` and add the uniform buffer
    descriptor writes info we created, called `uboDescWrites`, to it. We update the
    descriptor set by calling `vkUpdateDescriptorSets` and pass in the logical device,
    the descriptor writes size, and the data. That''s it for the `populateDescriptorSets`
    function. We finally add the destroy function, which destroys the descriptor pool
    and the descriptor set layout. Add the function as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`VkWriteDescriptorSet`数组，并将我们创建的统一缓冲区描述符写入信息`uboDescWrites`添加到其中。通过调用`vkUpdateDescriptorSets`并传递逻辑设备、描述符写入大小和数据来更新描述符集。这就是`populateDescriptorSets`函数的全部内容。我们最后添加一个销毁函数，该函数销毁描述符池和描述符集布局。添加函数如下：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating the SPIR-V shader binary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SPIR-V 着色器二进制文件
- en: Unlike OpenGL, which takes in GLSL (OpenGL Shading Language) human-readable
    files for shaders, Vulkan takes in shaders in binary or byte code format. All
    shaders, whether vertex, fragment, or compute, have to be in byte code format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenGL 不同，OpenGL 接收可读的 GLSL（OpenGL 着色语言）文件作为着色器，而 Vulkan 接收二进制或字节码格式的着色器。所有着色器，无论是顶点、片段还是计算着色器，都必须是字节码格式。
- en: 'SPIR-V is also good for cross-compilation, making porting shader files a lot
    easier. If you have a Direct3D HLSL shader code, it can be compiled to SPIR-V
    format and can be used in a Vulkan application, making it very easy to port Direct3D
    games to Vulkan. The shader is initially written in GLSL, with some minor changes
    to how we wrote it for OpenGL. A compiler is provided, which compiles the code
    from GLSL to SPIR-V format. The compiler is included with the Vulkan SDK installation.
    The basic vertex-shader GLSL code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SPIR-V 也非常适合交叉编译，这使得移植着色器文件变得容易得多。如果你有 Direct3D HLSL 着色器代码，它可以编译成 SPIR-V 格式，并可以在
    Vulkan 应用程序中使用，这使得将 Direct3D 游戏移植到 Vulkan 变得非常容易。着色器最初是用 GLSL 编写的，我们对 OpenGL 编写它的方式做了一些小的改动。提供了一个编译器，可以将代码从
    GLSL 编译成 SPIR-V 格式。编译器包含在 Vulkan SDK 安装中。基本的顶点着色器 GLSL 代码如下：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The shader should look very familiar, with some minor changes. For example,
    the GLSL version is still specified at the top. In this case, it is `#version
    450`. But we also see new things, such as `#extension GL_ARB_seperate_shader_objects:
    enable`. This specifies the extension that the shader uses. In this case, an old
    extension is needed, which basically lets us use vertex and fragment shaders as
    separate files. Extensions need to be approved by the **Architecture Review Board
    (ARB).**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '着色器看起来应该非常熟悉，有一些小的改动。例如，GLSL 版本仍然在顶部指定。在这种情况下，它是 `#version 450`。但我们还看到了一些新事物，例如
    `#extension GL_ARB_seperate_shader_objects: enable`。这指定了着色器使用的扩展。在这种情况下，需要一个旧的扩展，它基本上允许我们将顶点着色器和片段着色器作为单独的文件使用。扩展需要由**架构评审委员会（ARB）**批准。'
- en: Apart from the inclusion of the extension, you may have noticed that there is
    a location layout specified for all data types. And you may have noticed that
    when creating vertex and uniform buffers, we had to specify the binding index
    for the buffers. In Vulkan, there is no equivalent to `GLgetUniformLocation` to
    get the location index of a uniform buffer. This is because it takes quite a bit
    of system resources to get the location. Instead, we specify and sort of hardcode
    the value of the index. The uniform buffers, as well as  the in and out buffer
    can all be assigned an index of 0  as they are of different data types. Since
    the uniform buffer will be sent as a st ruct with model, view, and projection
    matrices, a similar struct is created in the shader and assigned to the 0^(th)
    index of the uniform layout.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含扩展之外，你可能还注意到为所有数据类型指定了位置布局。你可能还注意到，在创建顶点和统一缓冲区时，我们必须指定缓冲区的绑定索引。在 Vulkan
    中，没有与 `GLgetUniformLocation` 相当的函数来获取统一缓冲区的位置索引。这是因为获取位置需要相当多的系统资源。相反，我们指定并硬编码索引的值。统一缓冲区以及输入和输出缓冲区都可以分配一个索引
    0，因为它们是不同数据类型。由于统一缓冲区将作为包含模型、视图和投影矩阵的结构体发送，所以在着色器中创建了一个类似的结构体，并将其分配给统一布局的 0^(th)
    索引。
- en: All four attributes are also assigned a layout index `0`, `1`, `2`, and `3`,
    as specified in the `Mesh.h` file under the `Vertex` struct when setting the `VkVertexInputAttributeDescription`
    for the four attributes. The out is also assigned a layout location index of `0`,
    and the data type is specified as `vec3`. Then, in the main function of the shader,
    we set the `gl_Position` value by multiplying the local coordinate of the object
    by the model, view, and projection matrix received from the uniform buffer struct.
    Furthermore, `outColor` is set as `inColor` received.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个属性也被分配了一个布局索引 `0`、`1`、`2` 和 `3`，正如在 `Mesh.h` 文件下的 `Vertex` 结构体中设置 `VkVertexInputAttributeDescription`
    为四个属性时所指定的。输出也被分配了一个布局位置索引 `0`，并且数据类型被指定为 `vec3`。然后，在着色器的主函数中，我们通过将对象的局部坐标乘以从统一缓冲区结构体接收到的模型、视图和投影矩阵来设置
    `gl_Position` 值。此外，`outColor` 被设置为接收到的 `inColor`。
- en: 'The fragment shader is as follows: open a `.txt` file, add the shader code
    to it, and name the file `basic.` Also, change the extension to `*.vert` from
    `*.txt`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器如下：打开一个 `.txt` 文件，将着色器代码添加到其中，并将文件命名为 `basic.` 然后，将扩展名从 `*.txt` 改为 `*.vert`：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we specify the GLSL version and the extension to use. There are `in`
    and `out`, both of which have a location layout of `0`. Note that `in` is a `vec3`
    called `fragColor`, which is what we sent out of the vertex shader, and that `outColor`
    is a `vec4`. In the main function of the shader file, we convert `vec3` to `vec4`
    and set the resultant color to `outColor`. Add the fragment shader to a file called
    `basic.frag`. In the `VulkanProject` root directory, create a new folder called
    `shaders` and add the two shader files to it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了 GLSL 版本和要使用的扩展。有 `in` 和 `out`，它们都有一个位置布局为 `0`。请注意，`in` 是一个名为 `fragColor`
    的 `vec3`，这是我们从顶点着色器发送出来的，而 `outColor` 是一个 `vec4`。在着色器文件的 main 函数中，我们将 `vec3` 转换为
    `vec4`，并将结果颜色设置为 `outColor`。将片段着色器添加到名为 `basic.frag` 的文件中。在 `VulkanProject` 根目录下，创建一个名为
    `shaders` 的新文件夹，并将两个着色器文件添加到其中：
- en: '![](img/4fdcc29c-5465-47f9-ae6a-9cf9cb4e2a4a.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fdcc29c-5465-47f9-ae6a-9cf9cb4e2a4a.png)'
- en: 'Create a new folder called `SPIRV`, as this is where we will put the compiled
    SPIRV bytecode file. To compile the `.glsl` files, we will use the `glslValidator.exe`
    file, which was installed when we installed the Vulkan SDK. Now, to compile the
    code, we can use the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `SPIRV` 的新文件夹，因为这是我们放置编译好的 SPIRV 字节码文件的地方。要编译 `.glsl` 文件，我们将使用安装 Vulkan
    SDK 时安装的 `glslValidator.exe` 文件。现在，要编译代码，我们可以使用以下命令：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Hold *Shift* on the keyboard, right-click in the `shaders` folder, and click
    the Open PowerShell window here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按住键盘上的 *Shift* 键，在 `shaders` 文件夹中右键单击，然后点击在此处打开 PowerShell 窗口：
- en: '![](img/7a0d7a83-d6ce-4d54-bf04-4b231e46c0eb.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a0d7a83-d6ce-4d54-bf04-4b231e46c0eb.png)'
- en: 'In PowerShell, type in the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，输入以下命令：
- en: '![](img/955dd04b-e602-4fb5-8d39-d26bec5707d6.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/955dd04b-e602-4fb5-8d39-d26bec5707d6.png)'
- en: 'Make sure the *V* is capitalized and the *o* is lowercase, otherwise, it will
    give compile errors. This will create a new `spirv` file in the folder. Change
    `frag` to `vert` to compile the SPIRV vertex shader:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 *V* 大写，将 *o* 小写，否则将会出现编译错误。这将在文件夹中创建一个新的 `spirv` 文件。将 `frag` 改为 `vert` 以编译
    SPIRV 顶点着色器：
- en: '![](img/bf23acba-9668-4343-ba9e-8b8d4d506b37.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf23acba-9668-4343-ba9e-8b8d4d506b37.png)'
- en: 'This will create the vertex and fragment shader SPIRV binaries in the folder:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在文件夹中创建顶点和片段着色器 SPIRV 二进制文件：
- en: '![](img/90596c8c-2d1a-4622-8dfa-a4c66b908fbb.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90596c8c-2d1a-4622-8dfa-a4c66b908fbb.png)'
- en: Instead of compiling the code manually each time, we can create a `.bat` file
    that can do this for us, and put the compiled SPIRV binaries in the `SPIRV` folder.
    In the `shaders` folder, create a new `.txt` file and name it `glsl_spirv_compiler.bat`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都手动编译代码，我们可以创建一个 `.bat` 文件来自动完成这项工作，并将编译好的 SPIRV 二进制文件放在 `SPIRV` 文件夹中。在
    `shaders` 文件夹中，创建一个新的 `.txt` 文件，并将其命名为 `glsl_spirv_compiler.bat`。
- en: 'In the `.bat` file, add the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.bat` 文件中，添加以下内容：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Save and close the file. Now double-click on the `.bat` file to execute it.
    This will compile the shaders and place the compiled binary in the SPIRV shader
    files:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并关闭文件。现在双击 `.bat` 文件以执行它。这将编译着色器并将编译好的二进制文件放置在 SPIRV 着色器文件中：
- en: '![](img/d4acaddc-c373-4a63-934f-4d751d123877.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4acaddc-c373-4a63-934f-4d751d123877.png)'
- en: You can delete the SPIRV files in the `shaders` folder that we compiled earlier using
    the console command because we will be using the shader files in the `SPIRV` subfolder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用控制台命令删除 `shaders` 文件夹中我们之前编译的 SPIRV 文件，因为我们将会使用 `SPIRV` 子文件夹中的着色器文件。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created all the resources required to render the geometry.
    First of all, we added the `Mesh` class, which has vertex and index information
    for all the mesh types, including triangle, quad, cube, and sphere. Then, we created
    the `ObjectBuffers` class, which was used to store and bind the buffers to the
    GPU memory using the `VkTool` file. We also created a separate descriptor class,
    which has our descriptor set layout and pool. In addition, we created descriptor
    sets. Finally, we created the SPIRV bytecode shader files, which were compiled
    from the GLSL shader.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了渲染几何形状所需的所有资源。首先，我们添加了 `Mesh` 类，它包含了所有网格类型（包括三角形、四边形、立方体和球体）的顶点和索引信息。然后，我们创建了
    `ObjectBuffers` 类，它用于存储并将缓冲区绑定到 GPU 内存，使用的是 `VkTool` 文件。我们还创建了一个单独的描述符类，其中包含我们的描述符集布局和池。此外，我们还创建了描述符集。最后，我们创建了从
    GLSL 着色器编译的 SPIRV 字节码着色器文件。
- en: In the next chapter, we will use the resources we created here to draw our first
    colored geometry.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用这里创建的资源来绘制我们的第一个彩色几何形状。
