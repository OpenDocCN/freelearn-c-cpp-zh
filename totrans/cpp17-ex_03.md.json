["```cpp\nclass Book { \n  public: \n    Book(void); \n    Book(const string& author, const string& title); \n```", "```cpp\n    const string& author(void) const { return m_author; } \n    const string& title(void) const { return m_title; } \n```", "```cpp\n    void read(ifstream& inStream); \n    void write(ofstream& outStream) const; \n```", "```cpp\n    void borrowBook(int customerId); \n    int reserveBook(int customerId); \n    void unreserveBookation(int customerId); \n    void returnBook(); \n```", "```cpp\n    int bookId(void) const { return m_bookId; } \n```", "```cpp\n    bool borrowed(void) const { return m_borrowed; } \n    int customerId(void) const { return m_customerId; } \n```", "```cpp\n    list<int>& reservationList(void) { return m_reservationList; } \n```", "```cpp\n    static int MaxBookId; \n```", "```cpp\n    friend ostream& operator<<(ostream& outStream, \n                               const Book& book); \n```", "```cpp\n    private: \n      bool m_borrowed = false; \n      int m_bookId, m_customerId; \n```", "```cpp\n      string m_author, m_title; \n```", "```cpp\n      list<int> m_reservationList; \n      }; \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <List> \n    #include <String> \n    #include <FStream> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n```", "```cpp\n    int Book::MaxBookId = 0; \n```", "```cpp\n    Book::Book(void) { \n      // Empty. \n    } \n```", "```cpp\n    Book::Book(const string& author, const string& title) \n     :m_bookId(++MaxBookId), \n      m_author(author), \n      m_title(title) { \n      // Empty. \n    } \n```", "```cpp\n    void Book::write(ofstream& outStream) const { \n      outStream.write((char*) &m_bookId, sizeof m_bookId); \n```", "```cpp\n    outStream << m_author << endl; \n    outStream << m_title << endl; \n\n    outStream.write((char*) &m_borrowed, sizeof m_borrowed); \n    outStream.write((char*) &m_customerId, sizeof m_customerId); \n```", "```cpp\n    { int reservationListSize = m_reservationList.size(); \n      outStream.write((char*) &reservationListSize, \n                    sizeof reservationListSize); \n\n      for (int customerId : m_reservationList) { \n        outStream.write((char*) &customerId, sizeof customerId); \n      } \n    } \n    } \n```", "```cpp\n    void Book::read(ifstream& inStream) { \n      inStream.read((char*) &m_bookId, sizeof m_bookId); \n```", "```cpp\n    getline(inStream, m_author);\n    getline(inStream, m_title);\n```", "```cpp\n    inStream.read((char*) &m_borrowed, sizeof m_borrowed);\n    inStream.read((char*) &m_customerId, sizeof m_customerId);\n```", "```cpp\n    { int reservationListSize;\n      inStream.read((char*) &reservationListSize,\n                  sizeof reservationListSize);\n      for (int count = 0; count < reservationListSize; ++count) {\n        int customerId;\n        inStream.read((char*) &customerId, sizeof customerId);\n        m_reservationList.push_back(customerId);\n      }\n    }\n  } \n```", "```cpp\nvoid Book::borrowBook(int customerId) { \n  m_borrowed = true; \n  m_customerId = customerId; \n} \n```", "```cpp\n    int Book::reserveBook(int customerId) { \n      m_reservationList.push_back(customerId); \n      return m_reservationList.size(); \n    } \n```", "```cpp\n    void Book::returnBook() { \n      m_borrowed = false; \n    } \n```", "```cpp\n    void Book::unreserveBookation(int customerId) { \n      m_reservationList.remove(customerId); \n    } \n```", "```cpp\n    ostream& operator<<(ostream& outStream, const Book& book) { \n      outStream << \"\"\" << book.m_title << \"\" by \" << book.m_author; \n```", "```cpp\n  if (book.m_borrowed) { \n    outStream << endl << \"  Borrowed by: \" \n              << Library::s_customerMap[book.m_customerId].name() \n              << \".\"; \n  } \n\n  if (!book.m_reservationList.empty()) { \n    outStream << endl << \"  Reserved by: \"; \n\n    bool first = true; \n    for (int customerId : book.m_reservationList) { \n      outStream << (first ? \"\" : \",\") \n                << Library::s_customerMap[customerId].name(); \n      first = false; \n    } \n\n    outStream << \".\"; \n  } \n\n  return outStream; \n} \n```", "```cpp\nclass Customer { \n  public: \n    Customer(void); \n    Customer(const string& name, const string& address); \n\n    void read(ifstream& inStream); \n    void write(ofstream& outStream) const; \n\n    void borrowBook(int bookId); \n    void reserveBook(int bookId); \n    void returnBook(int bookId); \n    void unreserveBook(int bookId); \n```", "```cpp\n    bool hasBorrowed(void) const { return !m_loanSet.empty(); } \n\n    const string& name(void) const {return m_name;} \n    const string& address(void) const {return m_address;} \n    int id(void) const {return m_customerId;} \n```", "```cpp\n    static int MaxCustomerId; \n    friend ostream& operator<<(ostream& outStream, \n                               const Customer& customer); \n```", "```cpp\n    private: \n      int m_customerId; \n      string m_name, m_address; \n      set<int> m_loanSet, m_reservationSet; \n  }; \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <List> \n    #include <String> \n    #include <FStream> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n```", "```cpp\n    int Customer::MaxCustomerId; \n```", "```cpp\n    Customer::Customer(void) { \n      // Empty. \n    } \n```", "```cpp\n    Customer::Customer(const string& name, const string& address) \n     :m_customerId(++MaxCustomerId), \n      m_name(name), \n      m_address(address) { \n      // Empty. \n    } \n```", "```cpp\n    void Customer::read(ifstream& inStream) { \n     inStream.read((char*) &m_customerId, sizeof m_customerId); \n```", "```cpp\n    getline(inStream, m_name); \n    getline(inStream, m_address); \n\n    { int loanSetSize; \n      inStream.read((char*) &loanSetSize, sizeof loanSetSize); \n\n      for (int count = 0; count < loanSetSize; ++count) { \n        int bookId; \n        inStream.read((char*) &bookId, sizeof bookId); \n        m_loanSet.insert(bookId); \n      } \n    } \n\n    { int reservationListSize; \n      inStream.read((char*) &reservationListSize, \n                  sizeof reservationListSize); \n\n      for (int count = 0; count < reservationListSize; ++count) { \n        int bookId; \n        inStream.read((char*) &bookId, sizeof bookId); \n        m_loanSet.insert(bookId); \n      } \n    } \n  } \n```", "```cpp\n    void Customer::write(ofstream& outStream) const { \n      outStream.write((char*) &m_customerId, sizeof m_customerId); \n      outStream << m_name << endl; \n      outStream << m_address << endl; \n```", "```cpp\n    { int loanSetSize = m_loanSet.size(); \n      outStream.write((char*) &loanSetSize, sizeof loanSetSize); \n\n      for (int bookId : m_loanSet) { \n        outStream.write((char*) &bookId, sizeof bookId); \n      } \n    } \n\n    { int reservationListSize = m_reservationSet.size(); \n      outStream.write((char*) &reservationListSize, \n                    sizeof reservationListSize); \n\n      for (int bookId : m_reservationSet) { \n        outStream.write((char*) &bookId, sizeof bookId); \n      } \n    } \n  } \n```", "```cpp\n    void Customer::borrowBook(int bookId) { \n      m_loanSet.insert(bookId); \n    } \n```", "```cpp\n    void Customer::reserveBook(int bookId) { \n      m_reservationSet.insert(bookId); \n    } \n```", "```cpp\n    void Customer::returnBook(int bookId) { \n      m_loanSet.erase(bookId); \n    } \n\n    void Customer::unreserveBook(int bookId) { \n      m_reservationSet.erase(bookId); \n    } \n```", "```cpp\n    ostream& operator<<(ostream& outStream, const Customer& customer){ \n      outStream << customer.m_customerId << \". \" << customer.m_name \n                << \", \" << customer.m_address << \".\"; \n\n      if (!customer.m_loanSet.empty()) { \n        outStream << endl << \"  Borrowed books: \"; \n\n        bool first = true; \n        for (int bookId : customer.m_loanSet) { \n          outStream << (first ? \"\" : \",\") \n                    << Library::s_bookMap[bookId].author(); \n          first = false; \n        } \n     } \n\n      if (!customer.m_reservationSet.empty()) { \n        outStream << endl << \"  Reserved books: \"; \n\n        bool first = true; \n        for (int bookId : customer.m_reservationSet) { \n          outStream << (first ? \"\" : \",\") \n                    << Library::s_bookMap[bookId].title(); \n          first = false; \n        } \n      } \n\n      return outStream; \n    }   \n```", "```cpp\nclass Library { \n  public: \n    Library(); \n\n  private: \n    static string s_binaryPath; \n```", "```cpp\n    bool lookupBook(const string& author, const string& title, \n                    Book* bookPtr = nullptr); \n```", "```cpp\n    bool lookupCustomer(const string& name, const string& address, \n                        Customer* customerPtr = nullptr); \n```", "```cpp\n    void addBook(void); \n    void deleteBook(void); \n    void listBooks(void); \n    void addCustomer(void); \n    void deleteCustomer(void); \n    void listCustomers(void); \n    void borrowBook(void); \n    void reserveBook(void); \n    void returnBook(void); \n```", "```cpp\n    void load();  \n    void save(); \n```", "```cpp\n  public: \n    static map<int,Book> s_bookMap; \n    static map<int,Customer> s_customerMap; \n}; \n```", "```cpp\n#include <Set> \n#include <Map> \n#include <List> \n#include <String> \n#include <FStream> \n#include <IOStream> \n#include <Algorithm> \nusing namespace std; \n\n#include \"Book.h\" \n#include \"Customer.h\" \n#include \"Library.h\" \n\nmap<int,Book> Library::s_bookMap; \nmap<int,Customer> Library::s_customerMap; \n```", "```cpp\nstring Library::s_binaryPath(\"Library.bin\"); \n```", "```cpp\nLibrary::Library(void) { \n```", "```cpp\n  load(); \n```", "```cpp\n  bool quit = false; \n  while (!quit) { \n    cout << \"1\\. Add Book\" << endl \n         << \"2\\. Delete Book\" << endl \n         << \"3\\. List Books\" << endl \n         << \"4\\. Add Customer\" << endl \n         << \"5\\. Delete Customer\" << endl \n         << \"6\\. List Customers\" << endl \n         << \"7\\. Borrow Book\" << endl \n         << \"8\\. Reserve Book\" << endl \n         << \"9\\. Return Book\" << endl \n         << \"0\\. Quit\" << endl \n         << \": \"; \n```", "```cpp\n    int choice; \n    cin >> choice; \n```", "```cpp\n    switch (choice) { \n      case 1: \n        addBook(); \n        break; \n\n      case 2: \n        deleteBook(); \n        break; \n\n      case 3: \n        listBooks(); \n        break; \n\n      case 4: \n        addCustomer(); \n        break; \n\n      case 5: \n        deleteCustomer(); \n        break; \n\n      case 6: \n        listCustomers(); \n        break; \n\n      case 7: \n        borrowBook(); \n        break; \n\n      case 8: \n        reserveBook(); \n        break; \n\n      case 9: \n        returnBook(); \n        break; \n\n      case 0: \n        quit = true; \n        break; \n    } \n\n    cout << endl; \n  } \n```", "```cpp\n      save(); \n    } \n```", "```cpp\n    bool Library::lookupBook(const string& author, \n        const string& title, Book* bookPtr /* = nullptr*/) { \n      for (const pair<int,Book>& entry : s_bookMap) { \n        const Book& book = entry.second; \n```", "```cpp\n    if ((book.author() == author) && (book.title() == title)) { \n      if (bookPtr != nullptr) { \n        *bookPtr = book; \n      } \n\n      return true; \n    } \n  } \n\n  return false; \n} \n```", "```cpp\n    bool Library::lookupCustomer(const string& name, \n       const string& address, Customer* customerPtr /*=nullptr*/){ \n      for (const pair<int,Customer>& entry : s_customerMap) { \n        const Customer& customer = entry.second; \n```", "```cpp\n    if ((customer.name() == name) && \n        (customer.address() == address)) { \n      if (customerPtr != nullptr) { \n        *customerPtr = customer; \n      } \n\n      return true; \n    } \n  } \n\n  return false; \n} \n```", "```cpp\n    void Library::addBook(void) { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n  if (lookupBook(author, title)) { \n    cout << endl << \"The book \"\" <<  title << \"\" by \" \n         << author << \" already exists.\" << endl; \n    return; \n  } \n```", "```cpp\n  Book book(author, title); \n  s_bookMap[book.bookId()] = book; \n  cout << endl << \"Added: \" << book << endl; \n} \n```", "```cpp\n    void Library::deleteBook() { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n  Book book; \n  if (!lookupBook(author, title, &book)) { \n    cout << endl << \"There is no book \"\" << title << \"\" by \" \n         << \"author \" << author << \".\" << endl; \n    return; \n  } \n```", "```cpp\n    for (pair<int,Customer> entry : s_customerMap) { \n      Customer& customer = entry.second; \n      customer.returnBook(book.bookId()); \n      customer.unreserveBook(book.bookId()); \n      s_customerMap[customer.id()] = customer; \n    } \n```", "```cpp\n    s_bookMap.erase(book.bookId()); \n    cout << endl << \"Deleted.\" << endl; \n  } \n```", "```cpp\n    void Library::listBooks(void) { \n      if (s_bookMap.empty()) { \n        cout << \"No books.\" << endl; \n        return; \n      } \n\n      for (const pair<int,Book>& entry : s_bookMap) { \n        const Book& book = entry.second; \n        cout << book << endl; \n      } \n    } \n```", "```cpp\n    void Library::addCustomer(void) { \n      string name; \n      cout << \"Name: \"; \n      cin >> name; \n\n      string address; \n      cout << \"Address: \"; \n      cin >> address; \n```", "```cpp\n    if (lookupCustomer(name, address)) { \n      cout << endl << \"A customer with name \" << name \n           << \" and address \" << address << \" already exists.\" \n           << endl; \n      return; \n    } \n```", "```cpp\n    Customer customer(name, address); \n    s_customerMap[customer.id()] = customer; \n    cout << endl << \"Added.\" << endl; \n  } \n```", "```cpp\n    void Library::deleteCustomer(void) { \n      string name; \n      cout << \"Name: \"; \n      cin >> name; \n\n      string address; \n      cout << \"Address: \"; \n      cin >> address; \n\n      Customer customer; \n      if (!lookupCustomer(name, address, &customer)) { \n        cout << endl << \"There is no customer with name \" << name \n             << \" and address \" << address << \".\" << endl; \n        return; \n      } \n```", "```cpp\n  if (customer.hasBorrowed()) { \n    cout << \"Customer \" << name << \" has borrowed at least \" \n         << \"one book and cannot be deleted.\" << endl; \n    return; \n  } \n```", "```cpp\n  for (pair<int,Book> entry : s_bookMap) { \n    Book& book = entry.second; \n    book.unreserveBookation(customer.id()); \n    s_bookMap[book.bookId()] = book; \n  } \n\n  cout << endl << \"Deleted.\" << endl; \n  s_customerMap.erase(customer.id()); \n} \n```", "```cpp\n    void Library::listCustomers(void) { \n      if (s_customerMap.empty()) { \n        cout << \"No customers.\" << endl; \n        return; \n      } \n\n      for (const pair<int,Customer>& entry : s_customerMap) { \n        const Customer& customer = entry.second; \n        cout << customer << endl; \n      } \n    } \n```", "```cpp\n    void Library::borrowBook(void) { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n    Book book; \n    if (!lookupBook(author, title, &book)) { \n      cout << endl << \"There is no book \"\" << title << \"\" by \" \n           << \"author \" << author << \".\" << endl; \n      return; \n    } \n```", "```cpp\n    if (book.borrowed()) { \n      cout << endl << \"The book \"\" << title << \"\" by \" << author \n           << \" has already been borrowed.\" << endl; \n      return; \n    } \n```", "```cpp\n  string name; \n  cout << \"Customer name: \"; \n  cin >> name; \n\n  string address; \n  cout << \"Adddress: \"; \n  cin >> address; \n```", "```cpp\n    Customer customer; \n    if (!lookupCustomer(name, address, &customer)) { \n      cout << endl << \"There is no customer with name \" << name \n           << \" and address \" << address << \".\" << endl; \n      return; \n    } \n```", "```cpp\n    book.borrowBook(customer.id()); \n    customer.borrowBook(book.bookId()); \n```", "```cpp\n    s_bookMap[book.bookId()] = book; \n    s_customerMap[customer.id()] = customer; \n    cout << endl << \"Borrowed.\" << endl; \n  } \n```", "```cpp\n    void Library::reserveBook(void) { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n  Book book; \n  if (!lookupBook(author, title, &book)) { \n    cout << endl << \"There is no book \"\" << title << \"\" by \" \n         << \"author \" << author << \".\" << endl; \n    return; \n  } \n```", "```cpp\n  if (!book.borrowed()) { \n    cout << endl << \"The book with author \" << author \n         << \" and title \"\" << title << \"\" has not been \" \n         << \"borrowed. Please borrow the book instead.\" << endl; \n    return; \n  } \n```", "```cpp\n  string name; \n  cout << \"Customer name: \"; \n  cin >> name; \n\n  string address; \n  cout << \"Address: \"; \n  cin >> address; \n```", "```cpp\n  Customer customer; \n  if (!lookupCustomer(name, address, &customer)) { \n    cout << endl << \"No customer with name \" << name \n         << \" and address \" << address << \" exists.\" << endl; \n    return; \n  } \n```", "```cpp\n    if (book.customerId() == customer.id()) { \n      cout << endl << \"The book has already been borrowed by \" \n           << name << \".\" << endl; \n      return; \n    } \n```", "```cpp\n    customer.reserveBook(book.bookId()); \n    int position = book.reserveBook(customer.id()); \n```", "```cpp\n    s_bookMap[book.bookId()] = book; \n    s_customerMap[customer.id()] = customer; \n```", "```cpp\n    cout << endl << position << \"nd reserve.\" << endl; \n  } \n```", "```cpp\n    void Library::returnBook(void) { \n      string author; \n      cout << \"Author: \"; \n      cin >> author; \n\n      string title; \n      cout << \"Title: \"; \n      cin >> title; \n```", "```cpp\n    Book book; \n    if (!lookupBook(author, title, &book)) { \n      cout << endl << \"No book \"\" << title \n           << \"\" by \" << author << \" exists.\" << endl; \n      return; \n    } \n```", "```cpp\n    if (!book.borrowed()) { \n      cout << endl << \"The book \"\" << title \n           << \"\" by \" << author \n           << \"\" has not been borrowed.\" << endl; \n      return; \n    } \n```", "```cpp\n    book.returnBook(); \n    cout << endl << \"Returned.\" << endl; \n\n    Customer customer = s_customerMap[book.customerId()]; \n    customer.returnBook(book.bookId()); \n    s_customerMap[customer.id()] = customer; \n```", "```cpp\n    list<int>& reservationList = book.reservationList(); \n\n    if (!reservationList.empty()) { \n      int newCustomerId = reservationList.front(); \n      reservationList.erase(reservationList.begin()); \n      book.borrowBook(newCustomerId); \n\n      Customer newCustomer = s_customerMap[newCustomerId]; \n      newCustomer.borrowBook(book.bookId()); \n\n      s_customerMap[newCustomerId] = newCustomer; \n      cout << endl << \"Borrowed by \" << newCustomer.name() << endl; \n    } \n\n    s_bookMap[book.bookId()] = book; \n  } \n```", "```cpp\nvoid Library::save() { \n  ofstream outStream(s_binaryPath); \n```", "```cpp\n  if (outStream) { \n    int numberOfBooks = s_bookMap.size(); \n    outStream.write((char*) &numberOfBooks, sizeof numberOfBooks); \n\n    for (const pair<int,Book>& entry : s_bookMap) { \n      const Book& book = entry.second; \n      book.write(outStream); \n    } \n```", "```cpp\n    int numberOfCustomers = s_customerMap.size(); \n    outStream.write((char*) &numberOfCustomers, \n                    sizeof numberOfCustomers); \n\n    for (const pair<int,Customer>& entry : s_customerMap) { \n      const Customer& customer = entry.second; \n      customer.write(outStream); \n    } \n  } \n} \n```", "```cpp\nvoid Library::load() { \n  ifstream inStream(s_binaryPath); \n```", "```cpp\n  if (inStream) { \n    int numberOfBooks; \n    inStream.read((char*) &numberOfBooks, sizeof numberOfBooks); \n```", "```cpp\n    for (int count = 0; count < numberOfBooks; ++count) { \n      Book book; \n      book.read(inStream); \n      s_bookMap[book.bookId()] = book; \n      Book::MaxBookId = max(Book::MaxBookId, book.bookId()); \n    } \n```", "```cpp\n    int numberOfCustomers; \n    inStream.read((char*) &numberOfCustomers, \n                  sizeof numberOfCustomers); \n```", "```cpp\n    for (int count = 0; count < numberOfCustomers; ++count) { \n      Customer customer; \n      customer.read(inStream); \n      s_customerMap[customer.id()] = customer; \n      Customer::MaxCustomerId = \n        max(Customer::MaxCustomerId, customer.id()); \n    } \n  } \n} \n```", "```cpp\n    #include <Set> \n    #include <Map> \n    #include <List> \n    #include <String> \n    #include <FStream> \n    #include <IOStream> \n    using namespace std; \n\n    #include \"Book.h\" \n    #include \"Customer.h\" \n    #include \"Library.h\" \n\n    void main(void) { \n      Library(); \n    } \n```"]