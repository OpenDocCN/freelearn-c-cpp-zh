["```cpp\n    #pragma once\n\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/Vector.h\"\n\n    class Particle{\n    };\n    ```", "```cpp\n    ci::Vec2f position, prevPosition;\n    ci::Vec2f forces;\n    float radius;\n    float mass;\n    float drag;\n    ```", "```cpp\n    class Particle{\n    public:\n\n    Particle( const ci::Vec2f& position, float radius, \n    float mass, float drag );\n\n    void update();\n    void draw();\n\n    ci::Vec2f position, prevPosition;\n    ci::Vec2f forces;\n    float radius;\n    float mass;\n    float drag;\n    };\n    ```", "```cpp\n    #include \"Particle.h\"\n    ```", "```cpp\n    Particle::Particle( const ci::Vec2f& position, float radius, float mass, float drag ){\n      this->position = position;\n      this->radius = radius;\n      this->mass = mass;\n      this->drag = drag;\n      prevPosition = position;\n      forces = ci::Vec2f::zero();\n    }\n    ```", "```cpp\n    ci::Vec2f temp = position;\n    ```", "```cpp\n    ci::Vec2f vel = ( position – prevPosition ) * drag;\n    ```", "```cpp\n    position += vel + forces / mass;\n    ```", "```cpp\n    void Particle::update(){\n        ci::Vec2f temp = position;\n        ci::Vec2f vel = ( position - prevPosition ) * drag;\n        position += vel + forces / mass;\n        prevPosition = temp;\n        forces = ci::Vec2f::zero();\n    }\n    ```", "```cpp\n    void Particle::draw(){\n        ci::gl::drawSolidCircle( position, radius );\n    }\n    ```", "```cpp\n    #pragma once\n\n    #include \"Particle.h\"\n    #include <vector>\n\n    classParticleSystem{\n    public:\n\n    };\n    ```", "```cpp\n    Class ParticleSystem{\n    public:\n      ~ParticleSystem();\n\n      void update();\n      void draw();\n\n      void addParticle( Particle *particle );\n      void destroyParticle( Particle *particle );\n\n        std::vector<Particle*> particles;\n\n    };\n    ```", "```cpp\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    ParticleSystem::~ParticleSystem(){\n      for( std::vector<Particle*>::iterator it = particles.begin(); it!= particles.end(); ++it ){\n      delete *it;\n        }\n      particles.clear();\n    }\n    ```", "```cpp\n    void ParticleSystem::update(){\n      for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ){\n            (*it)->update();\n        }\n    }\n    ```", "```cpp\n    void ParticleSystem::draw(){\n      for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ){\n            (*it)->draw();\n        }\n    }\n    ```", "```cpp\n    void ParticleSystem::addParticle( Particle *particle ){\n      particles.push_back( particle );\n    }\n    ```", "```cpp\n    void ParticleSystem::destroyParticle( Particle *particle ){\n      std::vector<Particle*>::iterator it = std::find( particles.begin(), particles.end(), particle );\n      delete *it;\n      particles.erase( it );\n    }\n    ```", "```cpp\n    #include \"ParticleSystem.h\"\n    #include \"cinder/Rand.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    ```", "```cpp\n    int numParticle = 100;\n      for( int i=0; i<numParticle; i++ ){\n      float x = ci::randFloat( 0.0f, getWindowWidth() );\n      float y = ci::randFloat( 0.0f, getWindowHeight() );\n      float radius = ci::randFloat( 5.0f, 15.0f );\n      float mass = radius;radius;\n      float drag = 0.95f;\n            Particle *particle = new Particle\n            ( Vec2f( x, y ), radius, mass, drag );\n            mParticleSystem.addParticle( particle );\n    }\n    ```", "```cpp\n    void MyApp::update(){\n      mParticleSystem.update();\n    }\n    ```", "```cpp\n    void ParticlesApp::draw()\n    {\n      gl::clear( Color( 0, 0, 0 ) ); \n      gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n      mParticleSystem.draw();\n    }\n    ```", "```cpp\nci::Vec2f vel = ( position – prevPosition ) * drag;\n```", "```cpp\nclass Particle{\npublic:\n\n    Particle( const ci::Vec3f& position, \n    float radius, float mass, float drag );\n\n    void update();\n    void draw();\n\n    ci::Vec3f position, prevPosition;\n    ci::Vec3f forces;\n    float radius;\n    float mass;\n    float drag;\n};\n```", "```cpp\nvoid Particle::draw(){\n  ci::gl::drawSphere( position, radius );\n} \n```", "```cpp\n    Vec2f attrPosition;\n    float attrFactor, repulsionFactor, repulsionRadius;\n    ```", "```cpp\n    attrPosition = getWindowCenter();\n    attrFactor = 0.05f;\n    repulsionRadius = 100.f;\n    repulsionFactor = -5.f;\n    ```", "```cpp\n    void MainApp::mouseMove(MouseEvent event)\n    {\n      attrPosition.x = event.getPos().x;\n      attrPosition.y = event.getPos().y;\n    }\n\n    void MainApp::mouseDown(MouseEvent event)\n    {\n    for( std::vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n      Vec2f repulsionForce = (*it)->position - event.getPos();\n      repulsionForce = repulsionForce.normalized() * math<float>::max(0.f, repulsionRadius - repulsionForce.length());\n              (*it)->forces += repulsionForce;\n          }\n    }\n    ```", "```cpp\n    for( std::vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n      Vec2f attrForce = attrPosition - (*it)->position;\n      attrForce *= attrFactor;\n        (*it)->forces += attrForce;\n    }\n    ```", "```cpp\n    #include \"cinder/Perlin.h\"\n    ```", "```cpp\n    float    mFrequency;\n    Perlin    mPerlin;\n    ```", "```cpp\n    mFrequency = 0.01f;\n    mPerlin = Perlin();\n    ```", "```cpp\n    int numParticle = 300;\n    float radius = 1.f;\n    float mass = Rand::randFloat(1.f, 5.f);\n    ```", "```cpp\n    Vec2f oscilationVec;\n    oscilationVec.x = sin(getElapsedSeconds()*0.6f)*0.2f;\n    oscilationVec.y = sin(getElapsedSeconds()*0.2f)*0.1f;\n    std::vector<Particle*>::iterator it;\n    for(it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n      Vec2f windForce = mPerlin.dfBm( (*it)->position * mFrequency );\n        (*it)->forces += windForce * 0.1f;\n        (*it)->forces += oscilationVec;\n    }\n    ```", "```cpp\n    int numParticle = 50;\n    float radius = 5.f;\n    float mass = 1.f;\n    ```", "```cpp\n    void flock(std::vector<Particle*>& particles);\n    ci::Vec2f steer(ci::Vec2f target, bool slowdown);\n    void borders(float width, float height);\n    ci::Vec2f separate(std::vector<Particle*>& particles);\n    ci::Vec2f align(std::vector<Particle*>& particles);\n    ci::Vec2f cohesion(std::vector<Particle*>& particles);\n\n    float maxspeed;\n    float maxforce;\n    ci::Vec2f vel;\n    ```", "```cpp\n    this->maxspeed = 3.f;\n    this->maxforce = 0.05f;\n    ```", "```cpp\n    void Particle::flock(std::vector<Particle*>& particles) {\n      ci::Vec2f acc;\n      acc += separate(particles) * 1.5f;\n      acc += align(particles) * 1.0f;\n      acc += cohesion(particles) * 1.0f;\n      vel += acc;\n      vel.limit(maxspeed);\n    }\n\n    ci::Vec2f Particle::steer(ci::Vec2f target, bool slowdown) {\n    ci::Vec2f steer;\n    ci::Vec2f desired = target - position;\n    float d = desired.length();\n    if (d >0) {\n      desired.normalize();\n      if ((slowdown) && (d <100.0)) desired *= (maxspeed*(d/100.0));\n      else desired *= maxspeed;\n      steer = desired - vel;\n      steer.limit(maxforce);\n        }\n    else {\n      steer = ci::Vec2f::zero();\n        }\n      return steer;\n    }\n\n    void Particle::borders(float width, float height) {\n      if (position.x< -radius) position.x = width+radius;\n      if (position.y< -radius) position.y = height+radius;\n      if (position.x>width+radius) position.x = -radius;\n      if (position.y>height+radius) position.y = -radius;\n    }\n    ```", "```cpp\n    ci::Vec2f Particle::separate(std::vector<Particle*>& particles) {\n    ci::Vec2f resultVec = ci::Vec2f::zero();\n    float targetSeparation = 30.f;\n    int count = 0;\n    for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ) {\n      ci::Vec2f diffVec = position - (*it)->position;\n      if( diffVec.length() >0&&diffVec.length() <targetSeparation ) {\n        resultVec += diffVec.normalized() / diffVec.length();\n        count++;\n            }\n        }\n\n    if (count >0) {\n      resultVec /= (float)count;\n        }\n\n    if (resultVec.length() >0) {\n      resultVec.normalize();\n      resultVec *= maxspeed;\n      resultVec -= vel;\n      resultVec.limit(maxforce);\n        }\n\n    return resultVec;\n    }\n    ```", "```cpp\n    ci::Vec2f Particle::align(std::vector<Particle*>& particles) {\n    ci::Vec2f resultVec = ci::Vec2f::zero();\n    float neighborDist = 50.f;\n    int count = 0;\n    for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ) {\n    ci::Vec2f diffVec = position - (*it)->position;\n    if( diffVec.length() >0 && diffVec.length() <neighborDist ) {\n    resultVec += (*it)->vel;\n    count++;\n            }\n        }\n\n    if (count >0) {\n      resultVec /= (float)count;\n    }\n\n      if (resultVec.length() >0) {\n      resultVec.normalize();\n      resultVec *= maxspeed;\n      resultVec -= vel;\n      resultVec.limit(maxforce);\n        }\n\n      return resultVec;\n    }\n    ```", "```cpp\n    ci::Vec2f Particle::cohesion(std::vector<Particle*>& particles) {\n    ci::Vec2f resultVec = ci::Vec2f::zero();\n    float neighborDist = 50.f;\n    int count = 0;\n    for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ) {\n      float d = position.distance( (*it)->position );\n      if( d >0 && d <neighborDist ) {\n        resultVec += (*it)->position;\n        count++;\n            }\n        }\n\n    if (count >0) {\n      resultVec /= (float)count;\n      return steer(resultVec, false);\n        }\n\n      return resultVec;\n    }\n    ```", "```cpp\n    void Particle::update(){\n      ci::Vec2f temp = position;\n      position += vel + forces / mass;\n      prevPosition = temp;\n      forces = ci::Vec2f::zero();\n    }\n    ```", "```cpp\n    void Particle::draw(){\n      ci::gl::color(1.f, 1.f, 1.f);\n      ci::gl::drawSolidCircle( position, radius );\n      ci::gl::color(1.f, 0.f, 0.f);\n      ci::gl::drawLine(position,\n      position+( position - prevPosition).normalized()*(radius+5.f) );\n    }\n    ```", "```cpp\n    void ParticleSystem::update(){\n      for( std::vector<Particle*>::iterator it = particles.begin(); it!= particles.end(); ++it ){\n            (*it)->flock(particles);\n            (*it)->update();\n            (*it)->borders(640.f, 480.f);\n        }\n    }\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    int mNumParticles;\n    ```", "```cpp\n    mNumParticles = 256;\n    for( int i=0; i<mNumParticles; i++ ){\n      float x = ci::randFloat( 0.0f, getWindowWidth() );\n      float y = ci::randFloat( 0.0f, getWindowHeight() );\n      float radius = ci::randFloat( 5.0f, 15.0f );\n      float mass = radius;\n      float drag = 0.9f;\n            Particle *particle = new Particle\n            ( Vec2f( x, y ), radius, mass, drag );\n    mParticleSystem.addParticle( particle );\n    }\n    ```", "```cpp\n    void MyApp::update(){\n    mParticleSystem.update();\n    }\n    ```", "```cpp\n    void MyApp::draw()\n    {\n      gl::clear( Color( 0, 0, 0 ) ); \n    gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n    mParticleSystem.draw();\n    }\n    ```", "```cpp\n    #include \"cinder/audio/Io.h\"\n    #include \"cinder/audio/FftProcessor.h\"\n    #include \"cinder/audio/PcmBuffer.h\"\n    #include \"cinder/audio/Output.h\"\n    ```", "```cpp\n    Audio::TrackRef mAudio;\n    ```", "```cpp\n    fs::path audioPath = getOpenFilePath();\n    if( audioPath.empty() == false ){\n      mAudio = audio::Output::addTrack( audio::load( audioPath.string()   ) );\n    }\n    ```", "```cpp\n    if( mAudio ){\n      mAudio->enablePcmBuffering( true );\n      mAudio->setLooping( true );\n      mAudio->play();\n    }\n    ```", "```cpp\n    Vec2f center = getWindowCenter();\n    for( vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){\n            Particle *particle = *it;\n            Vec2f force = \n            ( center - particle->position ) * 0.1f;\n    particle->forces += force;\n        }\n    ```", "```cpp\n    std::shared_ptr<float>fft;\n    if( mAudio ){\n      audio::PcmBuffer32fRef pcmBuffer = mAudio->getPcmBuffer();\n    if( pcmBuffer ){\n        fft = audio::calculateFft( pcmBuffer->getChannelData( audio::CHANNEL_FRONT_LEFT ), mNumParticles );\n      }\n        }\n    ```", "```cpp\n    if( fft ){\n    float *values = fft.get();\n    for( int i=0; i<mParticleSystem.particles.size()-1; i++ ){\n    for( int j=i+1; j<mParticleSystem.particles.size(); j++ ){\n      Particle *particleA = \n      mParticleSystem.particles[i];\n      Particle *particleB = \n      mParticleSystem.particles[j];\n      Vec2f delta = particleA->position - \n      particleB->position;\n      float distanceSquared = delta.lengthSquared();\n      particleA->forces += ( delta / distanceSquared ) * particleB->mass * values[j] * 0.5f;\n      particleB->forces -= ( delta / distanceSquared ) * particleA->mass * values[i] * 0.5f;\n    ```", "```cpp\n    ci::Vec2f anchor;\n    ```", "```cpp\n    anchor = position;\n    ```", "```cpp\n    float maxAlignSpeed;\n    ```", "```cpp\n    mMouseDown = false;\n    repulsionFactor = -1.f;\n    maxAlignSpeed = 10.f;\n\n    mImage = loadImage( loadAsset(\"image.png\") );\n    mImageOutput = Surface8u(mImage.getWidth(), mImage.getHeight(), false);\n\n    ip::grayscale(mImage, &mImage);\n    ip::edgeDetectSobel(mImage, &mImageOutput);\n\n    Surface8u::Iter pixelIter = mImageOutput.getIter(Area(1,1,mImageOutput.getWidth()-1,mImageOutput.getHeight()-1));\n\n    while( pixelIter.line() ) {\n        while( pixelIter.pixel() ) {\n            if(pixelIter.getPos().x < mImageOutput.getWidth()\n              && pixelIter.getPos().y < \n              mImageOutput.getHeight()\n              && pixelIter.r() > 99) {\n                float radius = 1.5f;\n                float mass = Rand::randFloat(10.f, 20.f);\n                float drag = 0.9f;\n                Particle *particle = new Particle( \n                pixelIter.getPos(), radius, mass, drag );\n                mParticleSystem.addParticle( particle );\n            }\n        }\n    }\n    ```", "```cpp\n    void MainApp::update() {\n      for( std::vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n\n        if(mMouseDown) {\n          Vec2f repulsionForce = (*it)->position - getMousePos();\n          repulsionForce = repulsionForce.normalized() * math<float>::max(0.f, 100.f - repulsionForce.length());\n                      (*it)->forces += repulsionForce;\n            }\n\n        Vec2f alignForce = (*it)->anchor - (*it)->position;\n        alignForce.limit(maxAlignSpeed);\n            (*it)->forces += alignForce;\n        }\n\n      mParticleSystem.update();\n    }\n    ```", "```cpp\n    void Particle::draw(){\n      glBegin(GL_POINTS);\n      glVertex2f(position);\n      glEnd();\n    }\n    ```", "```cpp\n    ci::Vec3f anchor;\n    ```", "```cpp\n    anchor = position;\n    ```", "```cpp\n    #include \"cinder/TriMesh.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n\n    float repulsionFactor;\n    float maxAlignSpeed;\n\n    CameraPersp  mCam;\n    MayaCamUI       mMayaCam;\n\n    TriMesh  mMesh;\n    Vec3f    mRepPosition;\n    ```", "```cpp\n    repulsionFactor = -1.f;\n    maxAlignSpeed = 10.f;\n    mRepPosition = Vec3f::zero();\n\n    mMesh.read( loadAsset(\"ducky.msh\") );\n\n    mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);\n    mCam.setEyePoint(Vec3f(7.f,7.f,7.f));\n    mCam.setCenterOfInterestPoint(Vec3f::zero());\n    mMayaCam.setCurrentCam(mCam);\n    ```", "```cpp\n    for(vector<Vec3f>::iterator it = mMesh.getVertices().begin(); it != mMesh.getVertices().end(); ++it) {\n      float mass = Rand::randFloat(2.f, 15.f);\n      float drag = 0.95f;\n      Particle *particle = new Particle\n      ( (*it), 0.f, mass, drag );\n      mParticleSystem.addParticle( particle );\n    }\n    ```", "```cpp\n    void MainApp::resize( ResizeEvent event ){\n        mCam = mMayaCam.getCamera();\n        mCam.setAspectRatio(getWindowAspectRatio());\n        mMayaCam.setCurrentCam(mCam);\n    }\n\n    void MainApp::mouseDown(MouseEvent event){\n        mMayaCam.mouseDown( event.getPos() );\n    }\n\n    void MainApp::mouseDrag( MouseEvent event ){\n      mMayaCam.mouseDrag( event.getPos(), event.isLeftDown(), \n      event.isMiddleDown(), event.isRightDown() );\n    }\n    ```", "```cpp\n    void MainApp::update() {\n\n    mRepPosition.x = cos(getElapsedSeconds()) * 3.f;\n    mRepPosition.y = sin(getElapsedSeconds()*2.f) * 3.f;\n    mRepPosition.z = cos(getElapsedSeconds()*1.5f) * 3.f;\n\n    for( std::vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {\n\n      Vec3f repulsionForce = (*it)->position - mRepPosition;\n      repulsionForce = repulsionForce.normalized() * math<float>::max(0.f, 3.f - repulsionForce.length());\n      (*it)->forces += repulsionForce;\n\n      Vec3f alignForce = (*it)->anchor - (*it)->position;\n      alignForce.limit(maxAlignSpeed);\n            (*it)->forces += alignForce;\n        }\n\n      mParticleSystem.update();\n    }\n\n    void MainApp::draw()\n    {\n      gl::enableDepthRead();\n      gl::enableDepthWrite();\n      gl::clear( Color::black() );\n      gl::setViewport(getWindowBounds());\n      gl::setMatrices(mMayaCam.getCamera());\n\n      gl::color(Color(1.f,0.f,0.f));\n      gl::drawSphere(mRepPosition, 0.25f);\n\n      gl::color(Color::white());\n      mParticleSystem.draw();\n    }\n    ```", "```cpp\n    void Particle::draw(){\n      glBegin(GL_POINTS);\n      glVertex2f(position);\n      glEnd();\n    }\n    ```", "```cpp\n    #pragma once\n    #include \"Particle.h\"\n    #include \"cinder/gl/gl.h\"\n    ```", "```cpp\n    class Spring{\n\n    };\n    ```", "```cpp\n    class Spring{\n    public:\n      Particle *particleA;\n      Particle *particleB;\n      float strength, rest;\n    };\n    ```", "```cpp\n    class Spring{\n    public:\n\n        Spring( Particle *particleA, Particle *particleB, \n        float rest, float strength );\n\n        void update();\n        void draw();\n\n        Particle *particleA;\n        Particle *particleB;\n        float strength, rest;\n\n    };\n    ```", "```cpp\n    Spring::Spring( Particle *particleA, Particle *particleB, float rest, float strength ){\n      this->particleA = particleA;\n      this->particleB = particleB;\n      this->rest = rest;\n      this->strength = strength;\n    }\n    ```", "```cpp\n    void Spring::update(){\n        ci::Vec2f delta = particleA->position - particleB->position;\n        float length = delta.length();\n        float invMassA = 1.0f / particleA->mass;\n        float invMassB = 1.0f / particleB->mass;\n        float normDist = ( length - rest ) / ( length * ( invMassA + invMassB ) ) * strength;\n        particleA->position -= delta * normDist * invMassA;\n        particleB->position += delta * normDist * invMassB;\n    }\n    ```", "```cpp\n    void Spring::draw(){\n        ci::gl::drawLine\n        ( particleA->position, particleB->position );\n    }\n    ```", "```cpp\n    #include \"Spring.h\"\n    ```", "```cpp\n    std::vector<Spring*> springs;\n    ```", "```cpp\n    classParticleSystem{\n    public:\n\n        ~ParticleSystem();\n\n        void update();\n        void draw();\n\n        void addParticle( Particle *particle );\n        void destroyParticle( Particle *particle );\n        void addSpring( Spring *spring );\n        void destroySpring( Spring *spring );\n\n        std::vector<Particle*> particles;\n        std::vector<Spring*> springs;\n\n    };\n    ```", "```cpp\n    void ParticleSystem::addSpring( Spring *spring ){\n      springs.push_back( spring );\n    }\n    ```", "```cpp\n    void ParticleSystem::destroySpring( Spring *spring ){\n      std::vector<Spring*>::iterator it = std::find( springs.begin(), springs.end(), spring );\n      delete *it;\n      springs.erase( it );\n    }\n    ```", "```cpp\n    void ParticleSystem::update(){\n      for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ){\n            (*it)->update();\n        }\n        for( std::vector<Spring*>::iterator it = \n        springs.begin(); it != springs.end(); ++it ){\n            (*it)->update();\n        }\n    }\n    ```", "```cpp\n    void ParticleSystem::draw(){\n        for( std::vector<Particle*>::iterator it = particles.begin(); it != particles.end(); ++it ){\n            (*it)->draw();\n        }\n        for( std::vector<Spring*>::iterator it = \n        springs.begin(); it != springs.end(); ++it ){\n            (*it)->draw();\n        }\n    }\n    ```", "```cpp\n    #include \"ParticleSystem.h\"\n    ```", "```cpp\n    ParticleSystem mParticleSystem;\n    ```", "```cpp\n    for( int i=0; i<100; i++ ){\n            float x = randFloat( getWindowWidth() );\n            float y = randFloat( getWindowHeight() );\n            float radius = randFloat( 5.0f, 15.0f );\n            float mass = radius;\n            float drag = 0.9f;\n            Particle *particle = \n            new Particle( Vec2f( x, y ), radius, mass, drag );\n            mParticleSystem.addParticle( particle );\n        }\n    ```", "```cpp\n    void MyApp::update(){\n      mParticleSystem.update();\n    }\n    ```", "```cpp\n    void MyApp::draw(){\n      gl::clear( Color( 0, 0, 0 ) );\n      gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n      mParticleSystem.draw();\n    }\n    ```", "```cpp\n      void mouseDown( MouseEvent event );\n    ```", "```cpp\n    Particle *particleA = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];\n    ```", "```cpp\n    Particle *particleB = particleA;\n    while( particleB == particleA ){\n      particleB = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];\n        }\n    ```", "```cpp\n    void SpringsApp::mouseDown( MouseEvent event )\n    {\n        Particle *particleA = mParticleSystem.particles[ \n        randInt( mParticleSystem.particles.size() ) ];\n        Particle *particleB = particleA;\n        while( particleB == particleA ){\n      particleB = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];\n        }\n        float rest = randFloat( 100.0f, 200.0f );\n        float strength = 1.0f;\n        Spring *spring = new Spring\n        ( particleA, particleB, rest, strength );\n        mParticleSystem.addSpring( spring );\n\n    }\n    ```", "```cpp\nvoid Spring::update(){\n    ci::Vec3f delta = particleA->position - particleB->position;\n    float length = delta.length();\n    float invMassA = 1.0f / particleA->mass;\n    float invMassB = 1.0f / particleB->mass;\n    float normDist = ( length - rest ) / ( length * ( invMassA + invMassB ) ) * strength;\n    particleA->position -= delta * normDist * invMassA;\n    particleB->position += delta * normDist * invMassB;\n}\n```"]