- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Managing Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理资源
- en: In the previous chapter, we recapped the communication mechanisms between Lua
    and C++. In this chapter, we will learn more about managing resources. Resources
    can be anything an object uses, such as memory, files, or network sockets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们回顾了Lua和C++之间的通信机制。在本章中，我们将学习更多关于管理资源的内容。资源可以是对象使用的任何东西，例如内存、文件或网络套接字。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Customizing Lua memory allocation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Lua内存分配
- en: Delegating C++ object memory allocation to Lua
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将C++对象内存分配委托给Lua
- en: What is RAII?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RAII？
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the source code for *Chapter 9* as a base to develop the examples
    in this chapter. Make sure you can access the source code for this book: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第9章的源代码作为基础来开发本章的示例。请确保你可以访问本书的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10)。
- en: Customizing Lua memory allocation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Lua内存分配
- en: 'In the Lua runtime, memory is allocated, reallocated, or deallocated in the
    heap in the following situations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lua运行时，以下情况下在堆中分配、重新分配或释放内存：
- en: '**Memory is allocated**: This happens when an object is created. Lua needs
    to allocate a piece of memory to hold it.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分配**：当创建对象时会发生这种情况。Lua需要分配一块内存来存储它。'
- en: '**Memory is reallocated**: This happens when the size of an object needs to
    be changed – for example, adding entries to a table when the table has no more
    pre-allocated space.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存重新分配**：当需要更改对象大小时会发生这种情况，例如，当表格没有更多预分配空间时，向表格中添加条目。'
- en: '**Memory is deallocated**: This happens during garbage collection when the
    object is no longer needed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存释放**：在垃圾回收期间，当对象不再需要时发生。'
- en: 'In most situations, you do not need to be concerned about this. But sometimes,
    it is helpful to get an insight into, or customize, the Lua memory allocation.
    Here are some examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要关心这个问题。但有时，了解或自定义Lua内存分配是有帮助的。以下是一些示例：
- en: You need to analyze the memory footprint of your Lua objects to find optimization
    opportunities.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要分析Lua对象的内存占用情况，以找到优化机会。
- en: You need to customize where the memory is allocated. For example, to increase
    runtime efficiency, you may have a memory pool and you can simply have Lua use
    it without allocating new memory regions in the heap every time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要自定义内存的分配位置。例如，为了提高运行时效率，你可能有一个内存池，你可以简单地让Lua使用它，而不需要在堆中每次都分配新的内存区域。
- en: In this section, we will see how we can customize Lua’s memory allocation by
    providing a memory allocation function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何通过提供内存分配函数来自定义Lua的内存分配。
- en: What is the Lua memory allocation function?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lua内存分配函数是什么？
- en: Lua provides a simple way to customize memory allocation. When you create a
    Lua state, you can provide a memory allocation function so that whenever Lua needs
    to manage memory, it calls the function you provided.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Lua提供了一种简单的方式来自定义内存分配。当你创建Lua状态时，你可以提供一个内存分配函数，这样每当Lua需要管理内存时，它就会调用你提供的函数。
- en: 'The memory allocation function is defined as the following type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配函数定义为以下类型：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function returns a pointer to the newly allocated memory, or `NULL` if
    the call is to deallocate a piece of memory. Its arguments are explained as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回指向新分配内存的指针，或者如果调用用于释放一块内存，则返回`NULL`。其参数解释如下：
- en: '`ud` is the pointer to user-defined data for the Lua state. You can use the
    same memory allocation function with many Lua states. In such cases, you can use
    `ud` to identify each Lua state. Lua treats this transparently.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ud`是Lua状态的用户定义数据的指针。你可以使用相同的内存分配函数与多个Lua状态一起使用。在这种情况下，你可以使用`ud`来识别每个Lua状态。Lua对此是透明的。'
- en: '`ptr` is the pointer to the memory to be reallocated or deallocated. If it
    is `NULL`, the call to the memory allocator is to allocate a new piece of memory.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`是要重新分配或释放的内存的指针。如果它是`NULL`，则调用内存分配器的目的是分配一个新的内存块。'
- en: '`osize` is the original size for a previously allocated memory pointed by `ptr`.
    If `ptr` is `NULL`, `osize` has a special meaning – the type of the Lua object
    that is being allocated for, which can be `LUA_TSTRING`, `LUA_TTABLE`, and so
    on.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osize`是由`ptr`指向的先前分配的内存的原始大小。如果`ptr`是`NULL`，则`osize`具有特殊含义——正在分配的Lua对象的类型，可以是`LUA_TSTRING`、`LUA_TTABLE`等。'
- en: '`nsize` is the size for the memory to be allocated or reallocated. If `nsize`
    is `0`, the memory is to be deallocated.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsize` 是要分配或重新分配的内存大小。如果 `nsize` 为 `0`，则表示要释放内存。'
- en: 'To register your memory allocation function, you can use `lua_newstate` to
    create the Lua state, which is declared as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册你的内存分配函数，你可以使用 `lua_newstate` 来创建 Lua 状态，其声明如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this, you provide both the memory allocation function and the user data
    for the Lua state to be created. Note that you can provide `NULL` to `ud`, and
    this user data is a C++ side object, not the Lua user data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你为要创建的 Lua 状态提供了内存分配函数和用户数据。请注意，你可以向 `ud` 提供空指针，并且这个用户数据是 C++ 端的对象，而不是
    Lua 用户数据。
- en: Next, we’ll implement a memory allocation function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个内存分配函数。
- en: Implementing a memory allocation function
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现内存分配函数
- en: We will extend `LuaExecutor` to practice implementing a memory allocation function.
    When we create an executor, we want to pass a flag to indicate whether we should
    use our own memory allocation function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展 `LuaExecutor` 来练习实现内存分配函数。当我们创建执行器时，我们想要传递一个标志来指示是否应该使用我们自己的内存分配函数。
- en: 'You can start this work based on the source code for *Chapter 9*. In `LuaExecutor.h`,
    change the constructor, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以基于 *第 9 章* 的源代码开始这项工作。在 `LuaExecutor.h` 中修改构造函数，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We added another Boolean argument named `overrideAllocator` for the constructor.
    We also provided a default value as `false` because in most cases, we do not need
    to override the Lua memory allocator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为构造函数添加了另一个布尔参数 `overrideAllocator`。我们还提供了一个默认值 `false`，因为在大多数情况下，我们不需要覆盖
    Lua 内存分配器。
- en: 'In `LuaExecutor.cc`, implement our memory allocation function in a new anonymous
    namespace, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.cc` 中，在一个新的匿名命名空间中实现我们的内存分配函数，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`luaAlloc` relies on the standard `realloc` and `free` C functions to allocate,
    reallocate, and deallocate memory. This is exactly what the default Lua allocator
    does. But we also log the arguments and the return value to get more insight into
    the memory usage.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaAlloc` 依赖于标准的 `realloc` 和 `free` C 函数来分配、重新分配和释放内存。这正是默认 Lua 分配器所做的事情。但我们也记录了参数和返回值，以便更深入地了解内存使用情况。'
- en: 'To use `luaAlloc`, in `LuaExecutor.cc`, modify the constructor, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `luaAlloc`，在 `LuaExecutor.cc` 中修改构造函数，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we check if `overrideAllocator` is `true`. If it is, we use our memory
    allocation function by calling `lua_newstate`. If it is not, we use the default
    allocator by calling `luaL_newstate`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查 `overrideAllocator` 是否为 `true`。如果是，我们通过调用 `lua_newstate` 使用我们的内存分配函数。如果不是，我们通过调用
    `luaL_newstate` 使用默认分配器。
- en: Now, let’s test our allocator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的分配器。
- en: Testing it out
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: 'Rewrite `main.cpp`, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写 `main.cpp`，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test code creates a Lua executor, registers the `Destinations` module, and
    executes `script.lua`. This is similar to what we did in the previous chapters.
    The only thing to note is that we are setting `overrideAllocator` to `true` when
    creating the `LuaExecutor` instance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码创建了一个 Lua 执行器，注册了 `Destinations` 模块，并执行了 `script.lua`。这与我们在前面的章节中所做的是相似的。唯一需要注意的是，我们在创建
    `LuaExecutor` 实例时将 `overrideAllocator` 设置为 `true`。
- en: 'Rewrite `script.lua`, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写 `script.lua`，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The script creates an object of the `Destinations` type and tests its member
    functions. This, again, is similar to what we did in the previous chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本创建了一个 `Destinations` 类型的对象并测试了其成员函数。这又与我们在前面的章节中所做的是相似的。
- en: We also print out markers to mark when the script starts and finishes execution.
    This helps us locate things of interest because the customized memory allocation
    function will be quite verbose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印出标记来标记脚本开始和结束执行的时间。这有助于我们定位感兴趣的事物，因为自定义的内存分配函数将会非常详细。
- en: 'Compile and execute the project. You should get an output similar to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行项目。你应该得到一个类似于以下输出的结果：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two lines highlighted here are the allocation and deallocation of the object
    at the `0x14e706170` address. You will also see a lot of unrelated memory allocation
    outputs because Lua will also use the customized memory allocation function to
    manage the memory of its internal states.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里突出显示的两行是 `0x14e706170` 地址处的对象分配和释放。你还会看到很多无关的内存分配输出，因为 Lua 也会使用自定义的内存分配函数来管理其内部状态的内存。
- en: Although this customized memory allocation function is not very complex, you
    can extend what you have learned to change how memory is managed. This is useful
    for runtime optimization or resource-restricted systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个定制的内存分配函数并不复杂，但你可以将所学内容扩展以改变内存管理的方式。这对于运行时优化或资源受限的系统很有用。
- en: In the next section, we will explore a higher-level scenario – *how to make
    Lua allocate memory for* *C++ objects*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个更高级的场景——*如何让 Lua 为 *C++ 对象* 分配内存。
- en: Delegating C++ object memory allocation to Lua
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 C++ 对象的内存分配委托给 Lua
- en: 'So far, we have been creating C++ objects in C++ and making Lua store its pointer
    in userdata. This was done in `LuaModuleExporter::luaNew`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在 C++ 中创建 C++ 对象，并让 Lua 在 userdata 中存储其指针。这是在 `LuaModuleExporter::luaNew`
    中完成的，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the Lua userdata only stores a pointer. As you may recall, Lua
    userdata can represent a much larger piece of memory, so you might be wondering
    if we can store the whole C++ object in userdata, instead of just the pointer.
    Yes, we can. Let’s learn how to do it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Lua userdata 只存储一个指针。如您所回忆的，Lua userdata 可以表示更大的内存块，所以你可能想知道我们是否可以将整个
    C++ 对象存储在 userdata 中，而不仅仅是指针。是的，我们可以。让我们学习如何做到这一点。
- en: Using C++ placement new
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C++ placement new
- en: 'In C++, the most common way to create an object is to call `new T()`. This
    does two things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，创建对象最常见的方式是调用 `new T()`。这做两件事：
- en: It creates a piece of memory to hold an object of the `T` type.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为 `T` 类型的对象创建一块内存。
- en: It calls a constructor of the `T` type. In our example, we are calling the default
    constructor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `T` 类型的构造函数。在我们的例子中，我们调用默认构造函数。
- en: 'Similarly, the most common way to destroy an object is to call `delete obj`.
    It also does two things:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，销毁对象最常见的方式是调用 `delete obj`。它也做两件事：
- en: It calls the destructor of the `T` type. Here, `obj` is an object of the `T`
    type.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `T` 类型的析构函数。在这里，`obj` 是 `T` 类型的对象。
- en: Frees the memory that holds `obj`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放持有 `obj` 的内存。
- en: C++ also provides another *new expression* that only constructs an object by
    calling a constructor. It does not allocate memory for the object. Instead, you
    tell C++ where to place the object. This *new expression* is called **placement
    new**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 还提供了一个只通过调用构造函数来创建对象的 *new 表达式*。它不会为对象分配内存。相反，你告诉 C++ 将对象放在哪里。这个 *new 表达式*
    被称为 **placement new**。
- en: 'To use *placement new*, we need to provide the address to a piece of memory
    that has already been allocated. We can use it in the following way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *placement new*，我们需要提供一个已分配内存的地址。我们可以用以下方式使用它：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to provide the address to the memory location between the `new` keyword
    and the constructor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `new` 关键字和构造函数之间提供内存位置的地址。
- en: Now that we have found a way to decouple C++ memory allocation and object construction,
    let’s extend our C++ module exporter to support delegating memory management to
    Lua.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了一种方法来解耦 C++ 内存分配和对象构造，让我们扩展我们的 C++ 模块导出器以支持将内存管理委托给 Lua。
- en: Extending LuaModuleDef
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 LuaModuleDef
- en: 'We have implemented a C++ module exporting system in this book. It has two
    parts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中实现了一个 C++ 模块导出系统。它有两个部分：
- en: '`LuaModuleExporter` abstracts the module registration and implements the Lua
    finalizer for the module'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LuaModuleExporter` 抽象了模块注册并实现了模块的 Lua 终结器。'
- en: '`LuaModuleDef` defines the module name, exported functions, and object construction
    and destruction'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LuaModuleDef` 定义了模块名称、导出函数以及对象的构造和销毁。'
- en: First, we will add the capability to use pre-allocated memory in `LuaModuleDef`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `LuaModuleDef` 添加使用预分配内存的能力。
- en: 'In `LuaModule.h`, add a new member variable named `isManagingMemory`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaModule.h` 中，添加一个名为 `isManagingMemory` 的新成员变量，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When `isManagingMemory` is `true`, we indicate that the `LuaModuleDef` instance
    is managing memory allocation and deallocation. When `isManagingMemory` is `false`,
    we indicate that `LuaModuleDef` is not managing memory. In the latter case, `LuaModuleExporter`
    should make Lua manage memory, which we will implement after we have extended
    `LuaModuleDef`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `isManagingMemory` 为 `true` 时，我们表示 `LuaModuleDef` 实例正在管理内存分配和释放。当 `isManagingMemory`
    为 `false` 时，我们表示 `LuaModuleDef` 不管理内存。在后一种情况下，`LuaModuleExporter` 应该让 Lua 管理内存，这将在我们扩展
    `LuaModuleDef` 之后实现。
- en: 'With the new flag added, modify `createInstance`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新标志后，修改 `createInstance`，如下所示：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added a new argument – `void *addr`. When the `LuaModuleDef` instance is
    managing memory, it allocates the memory with the normal *new operator*. When
    the instance is not managing memory, it uses the *placement new expression*, where
    `addr` is the address where the object should be constructed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新参数 - `void *addr`。当 `LuaModuleDef` 实例管理内存时，它使用正常的 *new 操作符* 分配内存。当实例不管理内存时，它使用
    *放置新表达式*，其中 `addr` 是对象应该构造的地址。
- en: This implementation is the default implementation for `createInstance`. You
    can override it and call a non-default constructor when you create `LuaModuleDef`
    instances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `createInstance` 的默认实现。当你创建 `LuaModuleDef` 实例时，你可以覆盖它并调用非默认构造函数。
- en: 'Next, we need to modify `destroyInstance` to support `isManagingMemory` as
    well. Change its default implementation, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改 `destroyInstance` 以支持 `isManagingMemory`。更改其默认实现，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the `LuaModuleDef` instance is not managing memory, we simply call the
    object’s destructor, `obj->~T()`, to destroy it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `LuaModuleDef` 实例不管理内存时，我们只需调用对象的析构函数，`obj->~T()`，来销毁它。
- en: Placement delete?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 放置删除？
- en: If you are wondering whether there is a *placement delete* to match the *placement
    new*, the answer is no. To destroy an object without deallocating its memory,
    you can simply call its destructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道是否有与 *放置新* 匹配的 *放置删除*，答案是 no。要销毁对象而不释放其内存，你可以简单地调用其析构函数。
- en: With `LuaModuleDef` ready to support two ways of memory management, next, we
    will extend `LuaModuleExporter`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `LuaModuleDef` 准备支持两种内存管理方式，接下来，我们将扩展 `LuaModuleExporter`。
- en: Extending LuaModuleExporter
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 LuaModuleExporter
- en: 'Before we add support to delegate memory management for C++ objects to Lua,
    we will highlight the major architectural difference:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为 C++ 对象将内存管理委托给 Lua 支持之前，我们将强调主要架构差异：
- en: When C++ allocates the object’s memory, as we have done in this book till now,
    the Lua userdata holds a pointer to the address of the memory allocated
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 C++ 分配对象的内存时，就像我们在这本书中一直做的那样，Lua userdata 持有分配的内存地址的指针
- en: When Lua allocates the object’s memory as userdata, the userdata holds the actual
    C++ object
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Lua 分配对象的内存作为 userdata 时，userdata 持有实际的 C++ 对象
- en: Let’s start to extend `LuaModuleExporter`. We need to modify both `luaNew` and
    `luaDelete` so that they work with `LuaModuleDef::isManagingMemory`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始扩展 `LuaModuleExporter`。我们需要修改 `luaNew` 和 `luaDelete`，以便它们能与 `LuaModuleDef::isManagingMemory`
    一起工作。
- en: 'In `LuaModuleExporter.hpp`, change `luaNew`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaModuleExporter.hpp` 中，修改 `luaNew`，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function is broken down into four blocks, separated by new lines. These
    blocks are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被分解为四个块，由新行分隔。这些块如下：
- en: The first two lines of code get the `LuaModuleExporter` instance and the `LuaModuleDef`
    instance. You can revisit *Chapter 8* to understand how `getExporter` works if
    you need to.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的前两行获取 `LuaModuleExporter` 实例和 `LuaModuleDef` 实例。如果你需要了解 `getExporter` 的工作原理，可以回顾
    *第 8 章*。
- en: The `if` clause creates the C++ module object and the Lua userdata. When `luaModuleDef.isManagingMemory`
    is `true`, the code that’s executed is the same as that in *Chapter 8*. When it
    is `false`, the code creates a userdata with a size of `sizeof(T)` to hold the
    actual `T` instance. Note that, in this case, the type of the userdata is `T*`,
    and its address is passed to `luaModuleDef.createInstance` to use with the *placement
    new*.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 子句创建 C++ 模块对象和 Lua userdata。当 `luaModuleDef.isManagingMemory` 为 `true`
    时，执行的代码与 *第 8 章* 中的相同。当它是 `false` 时，代码创建一个大小为 `sizeof(T)` 的 userdata 来持有实际的 `T`
    实例。请注意，在这种情况下，userdata 的类型是 `T*`，其地址传递给 `luaModuleDef.createInstance` 以用于 *放置新*。'
- en: It copies the userdata to the bottom of the stack via `lua_copy(L, -1, 1)` and
    clears everything but the bottom of the stack via `lua_settop`(`L, 1`). The object
    construction is delegated to `LuaModuleDef` to clear the stack of temporary items
    in case `LuaModuleDef` has pushed any. These two lines of code are an improved
    version compared to the code in *Chapter 8* to cover more cases and the different
    ways of object creation.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过 `lua_copy(L, -1, 1)` 将 userdata 复制到栈底，并通过 `lua_settop`(`L, 1`) 清除栈上除底部以外的所有内容。对象构造委托给
    `LuaModuleDef` 以清除栈上的临时项，以防 `LuaModuleDef` 推送了任何项。与 *第 8 章* 中的代码相比，这两行代码是一个改进版本，可以覆盖更多情况以及不同的对象创建方式。
- en: The omitted code in the rest of the function is unchanged.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数其余部分省略的代码保持不变。
- en: 'Finally, to complete the feature, modify `LuaModuleExporter::luaDelete`, as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成这个特性，修改 `LuaModuleExporter::luaDelete`，如下所示：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to change how to get the C++ module instance in the finalizer. The difference
    comes from whether the userdata is holding the actual object or a pointer to the
    object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改在终结器中获取 C++ 模块实例的方式。差异在于 userdata 是否持有实际对象或对象的指针。
- en: Next, let’s test whether the mechanism to have Lua allocate the C++ object memory
    works.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试 Lua 分配 C++ 对象内存的机制是否工作。
- en: Testing with the Destinations.cc module
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Destinations.cc` 模块进行测试
- en: 'We only need to tweak the code in `Destinations.cc` a little bit to support
    both memory allocation scenarios. Change `getObj`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要稍微调整 `Destinations.cc` 中的代码，以支持两种内存分配场景。修改 `getObj`，如下所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The change we’ve made here is similar to what we did to `LuaModuleExporter::luaDelete`
    so that it supports the different content the Lua userdata holds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的更改与我们之前对 `LuaModuleExporter::luaDelete` 所做的更改类似，以便它支持 Lua userdata 所持有的不同内容。
- en: 'To choose to have Lua allocate the memory, change `DestinationsLuaModuleDef::def`,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择让 Lua 分配内存，更改 `DestinationsLuaModuleDef::def`，如下所示：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we set `LuaModuleDef::isManagingMemory` to `false`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `LuaModuleDef::isManagingMemory` 设置为 `false`。
- en: 'Compile and execute the project. You should see the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行项目。你应该看到以下输出：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you set `LuaModuleDef::isManagingMemory` to `true`, it should also work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `LuaModuleDef::isManagingMemory` 设置为 `true`，它也应该可以工作。
- en: Who should manage the memory for C++ objects?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 谁应该管理 C++ 对象的内存？
- en: You can have either C++ or Lua manage the memory allocation for C++ objects.
    Managing memory in C++ can provide better control in complex projects. Managing
    memory in Lua can get rid of the double-pointer indirection. There are also psychological
    considerations. For some people coming from the C++ world, having Lua allocate
    C++ objects, especially when Lua is only one of the libraries used in the project,
    may seem to violate resource ownership. For some people coming from the Lua or
    C world, making Lua do more may be easier to accept. However, in a real-world
    project, these details will be hidden. As seen in this section, if you have an
    abstraction, it is easy to change from one way to another.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择让 C++ 或 Lua 管理 C++ 对象的内存分配。在复杂项目中管理内存可以提供更好的控制。在 Lua 中管理内存可以消除双重指针间接引用。还有心理上的考虑。对于一些来自
    C++ 世界的人来说，让 Lua 分配 C++ 对象，尤其是当 Lua 只是项目中使用的库之一时，可能会感觉违反了资源所有权。对于一些来自 Lua 或 C
    世界的人来说，让 Lua 做更多的事情可能更容易接受。然而，在现实世界的项目中，这些细节将被隐藏。正如本节所示，如果你有一个抽象，它很容易从一种方式转换为另一种方式。
- en: Next, I would like to introduce you to the RAII resource management idiom.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想向您介绍 RAII 资源管理惯用语。
- en: What is RAII?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 RAII？
- en: This chapter is all about resource management. A resource can be a piece of
    memory, an opened file, or a network socket. Although in this chapter we have
    only used memory management as examples, the principles for all resources are
    the same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于资源管理。资源可以是一块内存、一个打开的文件或一个网络套接字。尽管在本章中我们只使用了内存管理作为示例，但所有资源的原理都是相同的。
- en: Of course, all acquired resources need to be released. In C++, the destructor
    is a good place to release resources. When working with Lua, the Lua finalizer
    is a good trigger to release resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有获取的资源都需要释放。在 C++ 中，析构函数是一个释放资源的好地方。当与 Lua 一起工作时，Lua 终结器是一个释放资源的好触发器。
- en: '**Resource Acquisition is Initialization**, or **RAII**, is a useful resource
    management idiom. This means object creation and acquiring the resources the object
    needs should be an atomic operation – everything should succeed, or the partially
    acquired resources should be released before raising an error.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**，或 **RAII**，是一个有用的资源管理惯用语。这意味着对象的创建和获取对象所需的资源应该是一个原子操作——一切都应该成功，或者部分获取的资源应该在引发错误之前释放。'
- en: By using this technique, the resources are also linked with the object’s life
    cycle. This ensures that all resources are guaranteed to be available during the
    life cycle of the object. This will prevent complex failure scenarios. For example,
    say a job has been half done and resources were spent but it could not be finished
    due to a certain new resource not being available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种技术，资源也与对象的生存周期相关联。这确保了在对象的整个生存周期内所有资源都可用。这将防止复杂的故障场景。例如，假设一项工作已经完成了一半，资源已经消耗，但由于某种新的资源不可用，它无法完成。
- en: When designing a C++ class, you can make sure all resources are acquired in
    the constructor and released in the destructor. When integrating with Lua, make
    sure you provide a finalizer and destroy the object from the finalizer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计C++类时，你可以确保所有资源都在构造函数中获取，并在析构函数中释放。当与Lua集成时，确保你提供最终化器，并从最终化器中销毁对象。
- en: The finalizer will be called during one of Lua’s garbage collection cycles.
    You should not assume when Lua does this as it is not portable across different
    platforms and Lua versions. If you are memory-constrained, you can trigger a garbage
    collection cycle manually by calling `lua_gc` from C++ or `collectgarbage` from
    Lua.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化器将在Lua的垃圾回收周期之一中被调用。你不应该假设Lua何时这样做，因为这在不同平台和Lua版本之间是不可移植的。如果你内存受限，你可以通过从C++中调用`lua_gc`或从Lua中调用`collectgarbage`来手动触发垃圾回收周期。
- en: Garbage collection is only for memory
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收仅用于内存
- en: Remember that garbage collection is only for memory. If you have a simple class
    that does not use other resources, it may be tempting to not provide a Lua finalizer.
    But if later the class is changed to rely on a non-memory resource, chances are
    that adding a finalizer is not part of the change. Then, you find out later that
    the resource is leaked from a weird bug report.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，垃圾回收仅用于内存。如果你有一个不使用其他资源的简单类，你可能不想提供Lua最终化器。但如果后来类被修改为依赖于非内存资源，那么添加最终化器可能不是更改的一部分。然后，你会在以后的某个时候发现资源从奇怪的错误报告中泄露出来。
- en: RAII is also useful in multithreaded programming to acquire a shared resource.
    We will see an example of this in the next chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RAII在多线程编程中获取共享资源时也非常有用。我们将在下一章中看到一个例子。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned more about resource management. We learned how to
    provide a customized memory allocation function to Lua. We also learned how to
    hold the actual C++ object in a Lua userdata. Finally, we familiarized ourselves
    with the RAII resource management technique.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地了解了资源管理。我们学习了如何为Lua提供一个定制的内存分配函数。我们还学习了如何在Lua userdata中持有实际的C++对象。最后，我们熟悉了RAII资源管理技术。
- en: In the next chapter, we will explore multithreading when integrating Lua into
    C++.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将Lua集成到C++时的多线程。
