- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we recapped the communication mechanisms between Lua
    and C++. In this chapter, we will learn more about managing resources. Resources
    can be anything an object uses, such as memory, files, or network sockets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Lua memory allocation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegating C++ object memory allocation to Lua
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is RAII?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the source code for *Chapter 9* as a base to develop the examples
    in this chapter. Make sure you can access the source code for this book: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Lua memory allocation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Lua runtime, memory is allocated, reallocated, or deallocated in the
    heap in the following situations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory is allocated**: This happens when an object is created. Lua needs
    to allocate a piece of memory to hold it.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory is reallocated**: This happens when the size of an object needs to
    be changed – for example, adding entries to a table when the table has no more
    pre-allocated space.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory is deallocated**: This happens during garbage collection when the
    object is no longer needed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In most situations, you do not need to be concerned about this. But sometimes,
    it is helpful to get an insight into, or customize, the Lua memory allocation.
    Here are some examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: You need to analyze the memory footprint of your Lua objects to find optimization
    opportunities.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to customize where the memory is allocated. For example, to increase
    runtime efficiency, you may have a memory pool and you can simply have Lua use
    it without allocating new memory regions in the heap every time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will see how we can customize Lua’s memory allocation by
    providing a memory allocation function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: What is the Lua memory allocation function?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lua provides a simple way to customize memory allocation. When you create a
    Lua state, you can provide a memory allocation function so that whenever Lua needs
    to manage memory, it calls the function you provided.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory allocation function is defined as the following type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function returns a pointer to the newly allocated memory, or `NULL` if
    the call is to deallocate a piece of memory. Its arguments are explained as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`ud` is the pointer to user-defined data for the Lua state. You can use the
    same memory allocation function with many Lua states. In such cases, you can use
    `ud` to identify each Lua state. Lua treats this transparently.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptr` is the pointer to the memory to be reallocated or deallocated. If it
    is `NULL`, the call to the memory allocator is to allocate a new piece of memory.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`osize` is the original size for a previously allocated memory pointed by `ptr`.
    If `ptr` is `NULL`, `osize` has a special meaning – the type of the Lua object
    that is being allocated for, which can be `LUA_TSTRING`, `LUA_TTABLE`, and so
    on.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nsize` is the size for the memory to be allocated or reallocated. If `nsize`
    is `0`, the memory is to be deallocated.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To register your memory allocation function, you can use `lua_newstate` to
    create the Lua state, which is declared as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this, you provide both the memory allocation function and the user data
    for the Lua state to be created. Note that you can provide `NULL` to `ud`, and
    this user data is a C++ side object, not the Lua user data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll implement a memory allocation function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a memory allocation function
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will extend `LuaExecutor` to practice implementing a memory allocation function.
    When we create an executor, we want to pass a flag to indicate whether we should
    use our own memory allocation function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start this work based on the source code for *Chapter 9*. In `LuaExecutor.h`,
    change the constructor, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We added another Boolean argument named `overrideAllocator` for the constructor.
    We also provided a default value as `false` because in most cases, we do not need
    to override the Lua memory allocator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.cc`, implement our memory allocation function in a new anonymous
    namespace, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`luaAlloc` relies on the standard `realloc` and `free` C functions to allocate,
    reallocate, and deallocate memory. This is exactly what the default Lua allocator
    does. But we also log the arguments and the return value to get more insight into
    the memory usage.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `luaAlloc`, in `LuaExecutor.cc`, modify the constructor, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we check if `overrideAllocator` is `true`. If it is, we use our memory
    allocation function by calling `lua_newstate`. If it is not, we use the default
    allocator by calling `luaL_newstate`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s test our allocator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rewrite `main.cpp`, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test code creates a Lua executor, registers the `Destinations` module, and
    executes `script.lua`. This is similar to what we did in the previous chapters.
    The only thing to note is that we are setting `overrideAllocator` to `true` when
    creating the `LuaExecutor` instance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewrite `script.lua`, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The script creates an object of the `Destinations` type and tests its member
    functions. This, again, is similar to what we did in the previous chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We also print out markers to mark when the script starts and finishes execution.
    This helps us locate things of interest because the customized memory allocation
    function will be quite verbose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and execute the project. You should get an output similar to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two lines highlighted here are the allocation and deallocation of the object
    at the `0x14e706170` address. You will also see a lot of unrelated memory allocation
    outputs because Lua will also use the customized memory allocation function to
    manage the memory of its internal states.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Although this customized memory allocation function is not very complex, you
    can extend what you have learned to change how memory is managed. This is useful
    for runtime optimization or resource-restricted systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个定制的内存分配函数并不复杂，但你可以将所学内容扩展以改变内存管理的方式。这对于运行时优化或资源受限的系统很有用。
- en: In the next section, we will explore a higher-level scenario – *how to make
    Lua allocate memory for* *C++ objects*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个更高级的场景——*如何让 Lua 为 *C++ 对象* 分配内存。
- en: Delegating C++ object memory allocation to Lua
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 C++ 对象的内存分配委托给 Lua
- en: 'So far, we have been creating C++ objects in C++ and making Lua store its pointer
    in userdata. This was done in `LuaModuleExporter::luaNew`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在 C++ 中创建 C++ 对象，并让 Lua 在 userdata 中存储其指针。这是在 `LuaModuleExporter::luaNew`
    中完成的，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the Lua userdata only stores a pointer. As you may recall, Lua
    userdata can represent a much larger piece of memory, so you might be wondering
    if we can store the whole C++ object in userdata, instead of just the pointer.
    Yes, we can. Let’s learn how to do it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Lua userdata 只存储一个指针。如您所回忆的，Lua userdata 可以表示更大的内存块，所以你可能想知道我们是否可以将整个
    C++ 对象存储在 userdata 中，而不仅仅是指针。是的，我们可以。让我们学习如何做到这一点。
- en: Using C++ placement new
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C++ placement new
- en: 'In C++, the most common way to create an object is to call `new T()`. This
    does two things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，创建对象最常见的方式是调用 `new T()`。这做两件事：
- en: It creates a piece of memory to hold an object of the `T` type.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为 `T` 类型的对象创建一块内存。
- en: It calls a constructor of the `T` type. In our example, we are calling the default
    constructor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `T` 类型的构造函数。在我们的例子中，我们调用默认构造函数。
- en: 'Similarly, the most common way to destroy an object is to call `delete obj`.
    It also does two things:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，销毁对象最常见的方式是调用 `delete obj`。它也做两件事：
- en: It calls the destructor of the `T` type. Here, `obj` is an object of the `T`
    type.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 `T` 类型的析构函数。在这里，`obj` 是 `T` 类型的对象。
- en: Frees the memory that holds `obj`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放持有 `obj` 的内存。
- en: C++ also provides another *new expression* that only constructs an object by
    calling a constructor. It does not allocate memory for the object. Instead, you
    tell C++ where to place the object. This *new expression* is called **placement
    new**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 还提供了一个只通过调用构造函数来创建对象的 *new 表达式*。它不会为对象分配内存。相反，你告诉 C++ 将对象放在哪里。这个 *new 表达式*
    被称为 **placement new**。
- en: 'To use *placement new*, we need to provide the address to a piece of memory
    that has already been allocated. We can use it in the following way:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *placement new*，我们需要提供一个已分配内存的地址。我们可以用以下方式使用它：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to provide the address to the memory location between the `new` keyword
    and the constructor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `new` 关键字和构造函数之间提供内存位置的地址。
- en: Now that we have found a way to decouple C++ memory allocation and object construction,
    let’s extend our C++ module exporter to support delegating memory management to
    Lua.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了一种方法来解耦 C++ 内存分配和对象构造，让我们扩展我们的 C++ 模块导出器以支持将内存管理委托给 Lua。
- en: Extending LuaModuleDef
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 LuaModuleDef
- en: 'We have implemented a C++ module exporting system in this book. It has two
    parts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中实现了一个 C++ 模块导出系统。它有两个部分：
- en: '`LuaModuleExporter` abstracts the module registration and implements the Lua
    finalizer for the module'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LuaModuleExporter` 抽象了模块注册并实现了模块的 Lua 终结器。'
- en: '`LuaModuleDef` defines the module name, exported functions, and object construction
    and destruction'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LuaModuleDef` 定义了模块名称、导出函数以及对象的构造和销毁。'
- en: First, we will add the capability to use pre-allocated memory in `LuaModuleDef`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `LuaModuleDef` 添加使用预分配内存的能力。
- en: 'In `LuaModule.h`, add a new member variable named `isManagingMemory`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaModule.h` 中，添加一个名为 `isManagingMemory` 的新成员变量，如下所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When `isManagingMemory` is `true`, we indicate that the `LuaModuleDef` instance
    is managing memory allocation and deallocation. When `isManagingMemory` is `false`,
    we indicate that `LuaModuleDef` is not managing memory. In the latter case, `LuaModuleExporter`
    should make Lua manage memory, which we will implement after we have extended
    `LuaModuleDef`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `isManagingMemory` 为 `true` 时，我们表示 `LuaModuleDef` 实例正在管理内存分配和释放。当 `isManagingMemory`
    为 `false` 时，我们表示 `LuaModuleDef` 不管理内存。在后一种情况下，`LuaModuleExporter` 应该让 Lua 管理内存，这将在我们扩展
    `LuaModuleDef` 之后实现。
- en: 'With the new flag added, modify `createInstance`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新标志后，修改 `createInstance`，如下所示：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added a new argument – `void *addr`. When the `LuaModuleDef` instance is
    managing memory, it allocates the memory with the normal *new operator*. When
    the instance is not managing memory, it uses the *placement new expression*, where
    `addr` is the address where the object should be constructed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is the default implementation for `createInstance`. You
    can override it and call a non-default constructor when you create `LuaModuleDef`
    instances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify `destroyInstance` to support `isManagingMemory` as
    well. Change its default implementation, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the `LuaModuleDef` instance is not managing memory, we simply call the
    object’s destructor, `obj->~T()`, to destroy it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Placement delete?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering whether there is a *placement delete* to match the *placement
    new*, the answer is no. To destroy an object without deallocating its memory,
    you can simply call its destructor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: With `LuaModuleDef` ready to support two ways of memory management, next, we
    will extend `LuaModuleExporter`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Extending LuaModuleExporter
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we add support to delegate memory management for C++ objects to Lua,
    we will highlight the major architectural difference:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: When C++ allocates the object’s memory, as we have done in this book till now,
    the Lua userdata holds a pointer to the address of the memory allocated
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Lua allocates the object’s memory as userdata, the userdata holds the actual
    C++ object
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start to extend `LuaModuleExporter`. We need to modify both `luaNew` and
    `luaDelete` so that they work with `LuaModuleDef::isManagingMemory`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaModuleExporter.hpp`, change `luaNew`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function is broken down into four blocks, separated by new lines. These
    blocks are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines of code get the `LuaModuleExporter` instance and the `LuaModuleDef`
    instance. You can revisit *Chapter 8* to understand how `getExporter` works if
    you need to.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` clause creates the C++ module object and the Lua userdata. When `luaModuleDef.isManagingMemory`
    is `true`, the code that’s executed is the same as that in *Chapter 8*. When it
    is `false`, the code creates a userdata with a size of `sizeof(T)` to hold the
    actual `T` instance. Note that, in this case, the type of the userdata is `T*`,
    and its address is passed to `luaModuleDef.createInstance` to use with the *placement
    new*.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It copies the userdata to the bottom of the stack via `lua_copy(L, -1, 1)` and
    clears everything but the bottom of the stack via `lua_settop`(`L, 1`). The object
    construction is delegated to `LuaModuleDef` to clear the stack of temporary items
    in case `LuaModuleDef` has pushed any. These two lines of code are an improved
    version compared to the code in *Chapter 8* to cover more cases and the different
    ways of object creation.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The omitted code in the rest of the function is unchanged.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, to complete the feature, modify `LuaModuleExporter::luaDelete`, as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to change how to get the C++ module instance in the finalizer. The difference
    comes from whether the userdata is holding the actual object or a pointer to the
    object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s test whether the mechanism to have Lua allocate the C++ object memory
    works.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the Destinations.cc module
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We only need to tweak the code in `Destinations.cc` a little bit to support
    both memory allocation scenarios. Change `getObj`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The change we’ve made here is similar to what we did to `LuaModuleExporter::luaDelete`
    so that it supports the different content the Lua userdata holds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To choose to have Lua allocate the memory, change `DestinationsLuaModuleDef::def`,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we set `LuaModuleDef::isManagingMemory` to `false`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and execute the project. You should see the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you set `LuaModuleDef::isManagingMemory` to `true`, it should also work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Who should manage the memory for C++ objects?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You can have either C++ or Lua manage the memory allocation for C++ objects.
    Managing memory in C++ can provide better control in complex projects. Managing
    memory in Lua can get rid of the double-pointer indirection. There are also psychological
    considerations. For some people coming from the C++ world, having Lua allocate
    C++ objects, especially when Lua is only one of the libraries used in the project,
    may seem to violate resource ownership. For some people coming from the Lua or
    C world, making Lua do more may be easier to accept. However, in a real-world
    project, these details will be hidden. As seen in this section, if you have an
    abstraction, it is easy to change from one way to another.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Next, I would like to introduce you to the RAII resource management idiom.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: What is RAII?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about resource management. A resource can be a piece of
    memory, an opened file, or a network socket. Although in this chapter we have
    only used memory management as examples, the principles for all resources are
    the same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all acquired resources need to be released. In C++, the destructor
    is a good place to release resources. When working with Lua, the Lua finalizer
    is a good trigger to release resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Acquisition is Initialization**, or **RAII**, is a useful resource
    management idiom. This means object creation and acquiring the resources the object
    needs should be an atomic operation – everything should succeed, or the partially
    acquired resources should be released before raising an error.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: By using this technique, the resources are also linked with the object’s life
    cycle. This ensures that all resources are guaranteed to be available during the
    life cycle of the object. This will prevent complex failure scenarios. For example,
    say a job has been half done and resources were spent but it could not be finished
    due to a certain new resource not being available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: When designing a C++ class, you can make sure all resources are acquired in
    the constructor and released in the destructor. When integrating with Lua, make
    sure you provide a finalizer and destroy the object from the finalizer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计C++类时，你可以确保所有资源都在构造函数中获取，并在析构函数中释放。当与Lua集成时，确保你提供最终化器，并从最终化器中销毁对象。
- en: The finalizer will be called during one of Lua’s garbage collection cycles.
    You should not assume when Lua does this as it is not portable across different
    platforms and Lua versions. If you are memory-constrained, you can trigger a garbage
    collection cycle manually by calling `lua_gc` from C++ or `collectgarbage` from
    Lua.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化器将在Lua的垃圾回收周期之一中被调用。你不应该假设Lua何时这样做，因为这在不同平台和Lua版本之间是不可移植的。如果你内存受限，你可以通过从C++中调用`lua_gc`或从Lua中调用`collectgarbage`来手动触发垃圾回收周期。
- en: Garbage collection is only for memory
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收仅用于内存
- en: Remember that garbage collection is only for memory. If you have a simple class
    that does not use other resources, it may be tempting to not provide a Lua finalizer.
    But if later the class is changed to rely on a non-memory resource, chances are
    that adding a finalizer is not part of the change. Then, you find out later that
    the resource is leaked from a weird bug report.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，垃圾回收仅用于内存。如果你有一个不使用其他资源的简单类，你可能不想提供Lua最终化器。但如果后来类被修改为依赖于非内存资源，那么添加最终化器可能不是更改的一部分。然后，你会在以后的某个时候发现资源从奇怪的错误报告中泄露出来。
- en: RAII is also useful in multithreaded programming to acquire a shared resource.
    We will see an example of this in the next chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RAII在多线程编程中获取共享资源时也非常有用。我们将在下一章中看到一个例子。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned more about resource management. We learned how to
    provide a customized memory allocation function to Lua. We also learned how to
    hold the actual C++ object in a Lua userdata. Finally, we familiarized ourselves
    with the RAII resource management technique.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地了解了资源管理。我们学习了如何为Lua提供一个定制的内存分配函数。我们还学习了如何在Lua userdata中持有实际的C++对象。最后，我们熟悉了RAII资源管理技术。
- en: In the next chapter, we will explore multithreading when integrating Lua into
    C++.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将Lua集成到C++时的多线程。
