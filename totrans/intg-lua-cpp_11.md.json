["```cpp\nvoid threadFunc(...) {}\nstd::thread t(threadFunc, ...);\n```", "```cpp\n#include \"LuaExecutor.h\"\n#include \"LoggingLuaExecutorListener.h\"\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\nauto listener = std::make_unique\n  <LoggingLuaExecutorListener>();\nstd::mutex coutMutex;\n```", "```cpp\nvoid threadFunc(int threadNo, int a, int b, int c)\n{\n    auto lua = std::make_unique<LuaExecutor>(*listener);\n    lua->execute(\"function add_params(a, b, c) return a + b\n        + c end\");\n    auto result = lua->call(\"add_params\",\n        LuaNumber::make(a), LuaNumber::make(b),\n        LuaNumber::make(c));\n    std::lock_guard<std::mutex> lock(coutMutex);\n    std::cout << \"[Thread \" << threadNo << \"] \"\n              << a << \"+\" << b << \"+\" << c << \"=\"\n              << std::get<LuaNumber>(result).value\n              << std::endl;\n}\n```", "```cpp\nint main()\n{\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 5; i++)\n    {\n        int a = i * 3 + 1;\n        threads.emplace_back(threadFunc, i + 1,\n            a, a + 1, a + 2);\n    }\n    for (auto &t : threads)\n    {\n        t.join();\n    }\n    return 0;\n}\n```", "```cpp\nChapter11 % ./executable\n[Thread 2] 4+5+6=15\n[Thread 3] 7+8+9=24\n[Thread 5] 13+14+15=42\n[Thread 1] 1+2+3=6\n[Thread 4] 10+11+12=33\n```", "```cpp\nfunction create_square_seq_coroutine(n)\n    return coroutine.create(function ()\n        for i = 1, n do\n            coroutine.yield(i * i)\n        end\n    end)\nend\n```", "```cpp\nChapter11 % ../lua/src/lua\nLua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio\n> dofile(\"script.lua\")\n> co = create_square_seq_coroutine(3)\n> coroutine.resume(co)\ntrue    1\n> coroutine.resume(co)\ntrue    4\n> coroutine.resume(co)\ntrue    9\n> coroutine.resume(co)\ntrue\n> coroutine.resume(co)\nfalse   cannot resume dead coroutine\n```", "```cpp\nfunction square_seq(n)\n    local co = create_square_seq_coroutine(n)\n    return function()\n        local code, value = coroutine.resume(co)\n        return value\n    end\nend\n```", "```cpp\nChapter11 % ../lua/src/lua\nLua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio\n> dofile(\"script.lua\")\n> for v in square_seq(3) do print(v) end\n1\n4\n9\n```", "```cpp\nint lua_resume (lua_State *L, lua_State *from, int narg,\n                int *nresults);\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    LuaValue resume(const std::string &function);\n};\n```", "```cpp\ninline LuaValue\nLuaExecutor::resume(const std::string &function)\n{\n    lua_State *thd = lua_newthread(L);\n    int type = lua_getglobal(thd, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    int nresults = 0;\n    const int status = lua_resume(thd, L, 0, &nresults);\n    if (status != LUA_OK && status != LUA_YIELD)\n    {\n        lua_pop(thd, 1);\n        return LuaNil::make();\n    }\n    if (nresults == 0)\n    {\n        return LuaNil::make();\n    }\n    const int value = lua_tointeger(thd, -1);\n    lua_pop(thd, nresults);\n    lua_pop(L, 1);\n    return LuaNumber::make(value);\n}\n```", "```cpp\nfunction squares()\n    for i = 2, 3 do\n        coroutine.yield(i * i)\n    end\nend\n```", "```cpp\n#include \"LuaExecutor.h\"\n#include \"LoggingLuaExecutorListener.h\"\n#include <iostream>\nint main()\n{\n    auto listener = std::make_unique<\n        LoggingLuaExecutorListener>();\n    auto lua = std::make_unique<LuaExecutor>(*listener);\n    lua->executeFile(\"script.lua\");\n    auto result = lua->resume(\"squares\");\n    if (getLuaType(result) == LuaType::number)\n    {\n    std::cout << \"Coroutine yields \"\n              << std::get<LuaNumber>(result).value\n              << std::endl;\n    }\n    return 0;\n}\n```", "```cpp\nCoroutine yields 4\n```"]