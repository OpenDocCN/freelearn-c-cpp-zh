<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor152"/>4</h1>
<h1 id="_idParaDest-64"><a id="_idTextAnchor153"/>Swap – from Simple to Subtle</h1>
<p>We begin our exploration of basic C++ idioms with a very simple, even humble, operation—<code>std::swap</code>, to do just that. Rest assured that C++ manages to turn even something as basic as a swap into a complex issue with subtle nuances.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>How is <code>swap</code> used by the standard C++ library?</li>
<li>What are the applications of swap?</li>
<li>How can we write exception-safe code using swap?</li>
<li>How can we implement swap for our own types correctly?</li>
<li>How can we correctly swap variables of an arbitrary type?</li>
</ul>
<h1 id="_idParaDest-65"><a id="_idTextAnchor154"/>Technical requirements</h1>
<p>Here is a link to all the example code of this chapter: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04</a></p>
<p>This is a link to the C++ Core Guidelines: <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md</a></p>
<p>This is a link for the C++ <strong class="bold">Guidelines Support Library</strong> (<strong class="bold">GSL</strong>): <a href="https://github.com/Microsoft/GSL">https://github.com/Microsoft/GSL</a></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor155"/><a id="_idTextAnchor156"/><a id="_idTextAnchor157"/>Swap and the standard template library</h1>
<p>The swap operation<a id="_idIndexMarker176"/> is widely<a id="_idIndexMarker177"/> used in the C++ standard library. All <code>std::swap</code>. There are also uses of swap in STL algorithms. The standard library is also a template for implementing custom features that resemble standard ones.</p>
<p>Therefore, we’ll begin our study of the swap operation with a look at the functionalit<a id="_idTextAnchor158"/>y provided by the standard<a id="_idTextAnchor159"/>.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor160"/>Swap and STL containers</h2>
<p>Conceptually, swap is equivalent to the following operation:</p>
<pre class="source-code">
template &lt;typename T&gt; void swap(T&amp; x, T&amp; y) { T tmp(x);
  x = y;
  y = tmp;
}</pre>
<p>After the <code>swap()</code> is called, the contents of the <code>x</code> and <code>y</code> objects are swapped. This, however, is probably the worst possible way to actually implement swap. The first and most obvious problem with this implementation is that it copies both objects unnecessarily (it actually does three copy operations). The execution time of this operation is proportional to the size of the <code>T</code> type. For an STL container, the size would refer to the size of the actual container, not to the type of the element:</p>
<pre class="source-code">
void swap(std::vector&lt;int&gt;&amp; x, std::vector&lt;int&gt;&amp; y) {
  std::vector&lt;int&gt; tmp(x);
  x = y;
  y = tmp;
}</pre>
<p>Note that this code compiles, and, in most cases, even does the right thing. However, it copies every element of the vector several times. The second problem is that it temporarily allocates resources—for example, during the swap, we create a third vector that uses as much memory as one of the vectors being swapped. This allocation seems unnecessary, given that, in the final state, we have exactly as much data as we started with; only the names we use to access this data have been changed. The last problem with naive implementation is revealed when we consider what happens if, for example, the memory allocation we just mentioned fails<a id="_idTextAnchor161"/>.</p>
<p>The entire swap operation, which should have been as simple and foolproof as exchanging the names used to access vector elements, instead fails with a memory allocation failure.</p>
<p>But that’s not the only way it can fail—the copy constructor and the assignment operator can both throw exceptions.</p>
<p>All STL containers, including <code>std::vector</code>, provide a guarantee that they can be swapped in constant time. The way this is accomplished is rather straightforward if you consider that the STL container objects themselves contain only pointers to the data, plus some state, such as object size. To swap these containers, we need only to swap the pointers (and the rest of the state, of course)—the elements of the container remain exactly where they always were, in dynamically allocated memory, and do not need to be copied or even accessed. The implementation of the swap needs only to swap the pointers, the sizes, and other state variables (in a real STL implementation, a container class, such as a vector, does not directly consist of data members of built-in types, such as pointers, but has one or more class data members that, in turn, are made from pointers and other built-in types).</p>
<p>Since any <a id="_idIndexMarker178"/>pointers <a id="_idIndexMarker179"/>or other vector data members are not publicly accessible, the swap has to be implemented as a member function of the container, or be declared a friend. The STL takes the former approach—all STL containers have a <code>swap()</code> member function that swaps the object with another object of the same type (see examples <code>01a</code> and <code>01b</code>).</p>
<p>The implementation of this by swapping pointers takes care, indirectly, of the two other problems we mentioned. First of all, because only the data members of the containers are swapped, there is no memory allocation. Secondly, copying pointers and other built-in types cannot throw an exception, and so the entire swap operation does not throw (and cannot otherwise fail).</p>
<p>The simple and consistent picture we have described so far is only mostly true. The first complication, and by far the simpler one, applies only to containers that are parameterized not just on the element type, but also on a callable object of some sort. For example, the <code>std::map</code> container accepts the optional comparison function for comparing the elements of the map, which, by default, is <code>std::less</code>. Such callable objects have to be stored with the container. Since they are invoked very often, it is highly desirable, for performance reasons, to keep them in the same memory allocation as the container object itself, and indeed they are made data members of the container class.</p>
<p>However, that optimization comes with a price—swapping two containers now requires exchanging the compare functions; that is, the actual objects, not the pointers to them. The comparison objects are implemented by the client of the library, so there is no guarantee that swapping them is possible, let alone that it will not throw an excepti<a id="_idTextAnchor162"/>on.</p>
<p>Therefore, for <code>std::map</code>, the standard provides the following guarantee—in order for the map to be swappable, the callable objects must also be swappable. Furthermore, swapping two maps does not throw an exception, unless swapping comparison objects may throw, in which case, any exception thrown by that swap is propagated from the <code>std::map</code> swap.</p>
<p>This consideration does not apply to containers, such as <code>std::vector</code>, that do not use any callable objects, and swapping these containers still does not throw an exception (as far as we know up to now).</p>
<p>The other <a id="_idIndexMarker180"/>complication<a id="_idIndexMarker181"/> in the otherwise consistent and natural behavior of the swap is due to the allocators, and that is a hard one to resolve. Consider the problem—the two swapped containers must, necessarily, have allocators of the same type, but not necessarily the same allocator object. Each container has its elements allocated by its own allocator, and they must be deallocated by the same allocator. After the swap, the first container owns the elements from the second one and must eventually deallocate them. This can only be done (correctly) using the allocator of the first container; therefore, the allocators must also be exchanged.</p>
<p>C++ standards prior to <code>allocator_type</code> allocator class, there is a <code>trait</code> class that defines, among other things, the <code>std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> trait property, and if this value is <code>true</code>, then the allocators are exchanged using an unqualified call to a non-member swap; that is, simply a <code>swap(allocator1, allocator2)</code> call (see the next section to learn what that call actually does). If this value is not <code>true</code>, then the allocators are not swapped at all, and both container objects must use the same allocator. If that is not <code>true</code> either, then we are back to undefined behavior. <code>swap()</code> member functions of STL containers to be conditionally <code>noexcept()</code>, with the same limitations.</p>
<p>The requirement that swapping two containers cannot throw an exception, at least as long as the allocators are not involved and the container does not use callable objects or uses non-throwing ones, ends up imposing a rather subtle limitation on the implementation of the container—it prevents the use of local buffer optimi<a id="_idTextAnchor163"/>zation.</p>
<p>We will talk about this optimization in great detail in <a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic">Chapter 10</em></a>, <em class="italic">Local</em> <em class="italic">Buffer Optimization</em>, but in a nutshell, the idea is to avoid dynamic memory allocation for containers of very few elements, such as short strings, by defining a buffer inside the container class itself. This <a id="_idIndexMarker184"/>optimization, however, is generally incompatible with the notion of a<a id="_idIndexMarker185"/> non-throwing swap, since the elements inside the container object can no longer be exchanged <a id="_idTextAnchor164"/>by merely swapping pointers, but have to be copied between the co<a id="_idTextAnchor165"/>ntainers.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor166"/>Non-member swap</h2>
<p>The standard also<a id="_idIndexMarker186"/> provides a template <code>std::swap()</code> function. Prior to C++11, it was declared in the <code>&lt;algorithm&gt;</code> header; in C++11, it was moved to <code>&lt;utility&gt;</code>. The declaration of the function is as follows:</p>
<pre class="source-code">
template &lt;typename T&gt;
  void swap (T&amp; a, T&amp; b);
template &lt;typename T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]);    // Since C++11</pre>
<p>The overload for arrays was added in C++11. In C++20, both versions are additionally declared <code>constexpr</code>. For STL containers, <code>std::swap()</code> calls the member function <code>swap()</code>. As we will see in the following section, the behavior of <code>swap()</code> can be customized for other types as well, but without any special efforts, the default implementation is used. This implementation does a swap using a temporary object. Before C++11, the temporary object was copy-constructed, and the swap was done with two assignments, just as we did in the preceding section. The type has to be copyable (both copy-constructible and copy-assignable), otherwise <code>std::swap()</code> will not compile (see examples <code>02a</code> and <code>02b</code>). In C++11, <code>std::swap()</code> has been redefined to use move construction and move assignment (see example <code>02c</code>). As usual, if the class is copyable, but does not have move operations declared at all, then the copy constructor and assignment are used. Note that if the class has copy operations declared and move operations declared as deleted, there is no automatic fallback to copying—that class is a non-movable type and <code>std::swap()</code> will not compile for it (see example <code>02d</code>).</p>
<p>Since copying an object can, in general, throw an exception, swapping two objects for which a custom swap behavior is not provided can throw an exception as well. Move operations do not usually throw exceptions, and in C++11, if the object has a move constructor and an assignment operator and neither throws an exception, <code>std::swap()</code> also provides a no-throw guarantee. That behavior has been formalized in C++17 with a conditional <code>noexcept()</code> spec<a id="_idTextAnchor167"/><a id="_idTextAnchor168"/><a id="_idTextAnchor169"/>ification.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor170"/>Swapping like the standard</h2>
<p>From the <a id="_idIndexMarker187"/>preceding review of how the<a id="_idIndexMarker188"/> standard library handles a swap, we can deduce the following guidelines:</p>
<ul>
<li>Classes that support swap should implement <code>swap()</code> member functions that perform the operation in constant time</li>
<li>A free-standing <code>swap()</code> non-member function should also be provided for all types that can be swapped</li>
<li>Swapping two objects should not throw exceptions or otherwise fail</li>
</ul>
<p>The latter guideline is less strict, and it is not always possible to follow it. In general, if the type has move operations that do not throw an exception, a non-throwing swap implementation is also possible. Note also that many exception-safety guarantees, and in particular those provided by the standard library, require that move and swa<a id="_idTextAnchor171"/>p operations do not throw a<a id="_idTextAnchor172"/>n exception.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor173"/>When and why to use swap</h1>
<p>What is so important<a id="_idIndexMarker189"/> about the swap functionality that it deserves its own chapter? For that matter, why even use swap, and not continue to refer to an object by its original name?</p>
<p>Mostly, it has to do with exception safety, which is also why we keep me<a id="_idTextAnchor174"/>ntioning when swap can and cannot throw <a id="_idTextAnchor175"/>an exception.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor176"/>Swap and exception safety</h2>
<p>The most important<a id="_idIndexMarker190"/> application of swap in C++ has to do with writing exception-safe code, or, more generally, error-safe code. Here is the problem, in a nutshell—in an exception-safe program, throwing an exception should never leave the program in an undefined state.</p>
<p>More generally, an error condition should never leave the program in an undefined state. Note that the error does not need to be handled by means of an exception—for example, returning an error code from a function should also be handled without creating undefined behavior. In particular, if an operation causes an error, the resources already consumed by the operation in progress should be released. Often, an even stronger guarantee is desired—every operation either succeeds or is entirely rolled back.</p>
<p>Let’s consider an example where we will apply a transform to all elements of a vector, and store the results in a new vector:</p>
<pre class="source-code">
// Example 03a
class C;            // Our element type
C transmogrify(C x) {    // Some operation on C
  return C(...);
}
void transmogrify(const std::vector&lt;C&gt;&amp; in,
                  std::vector&lt;C&gt;&amp; out) {
  out.resize(0);
  out.reserve(in.size());
  for (const auto&amp; x : in) {
    out.push_back(transmogrify(x));
  }
}</pre>
<p>Here, we return the vector via an output parameter. Let us assume that it is a requirement to use an already existing vector for output and we are not doing it for performance reasons. In all recent versions of C++, returning a vector by value is quite fast: the compiler will either apply the return-value optimization and elide the copy completely (copy elision is not guaranteed but likely) or replace copy by move (also fast, guaranteed). The vector is made empty at first, and grows to the same size as the input vector. Any data the <code>out</code> vector may have had is gone. Note the <code>reserve()</code> call that is used to avoid repeated deallocations of the growing vector.</p>
<p>This code works fine as long as there are no errors, that is, no exceptions are thrown. But this is not guaranteed. First of all, <code>reserve()</code> does a memory allocation, which may fail. If this <a id="_idIndexMarker191"/>happens, the <code>transmogrify()</code> function will exit via the exception, and the output vector will be empty since the <code>resize(0)</code> call has already been executed. The initial content of the output vector is lost, and nothing is written to replace it. Secondly, any iteration of the loop over the elements of the vector may throw an exception. An exception could be thrown by the copy constructor of the new element of the output vector, or by the transformation itself. Either way, the loop is interrupted. STL guarantees that the output vector is not left in an undefined state even if the copy constructor inside the <code>push_back()</code> call fails—the new element is not <em class="italic">partially </em>created, and the vector size is not increased.</p>
<p>However, the elements already stored will remain in the output vector (and any elements that were there originally are gone). This may not be what we intended—it is not unreasonable to request that the <code>transmogrify()</code> operation either succeeds and applies the transform to the entire vector, or fails and changes nothing.</p>
<p>The key to such exception-safe implementation is the swap:</p>
<pre class="source-code">
// Example 03b
void transmogrify(const std::vector&lt;C&gt;&amp; in,
                  std::vector&lt;C&gt;&amp; out) {
  std::vector&lt;C&gt; tmp;
  tmp.reserve(in.size());
  for (const C&amp; x : in) {
    tmp.push_back(transmogrify(x));
  }
  out.swap(tmp);    // Mu<a id="_idTextAnchor177"/>st not throw!
}</pre>
<p>In this example, we have changed the code to operate on a temporary vector during the entire transformation. Note that, in a typical case of an output vector that is empty on input, this does not increase the amount of memory in use. If the output vector has some data in it, both the new data and the old data exist in memory until the end of the function. This is necessary to provide a guarantee that the old data will not be deleted unless the new data can be fully computed. If desired, this guarantee can be traded for lower overall memory use, and the output vector can be emptied at the beginning of the function (on the other hand, any caller who wants to make such a trade-off can just empty the vector before calling <code>transmogrify()</code>).</p>
<p>If an exception is<a id="_idIndexMarker192"/> thrown at any time during the execution of the <code>transmogrify()</code> function, right up until the last line, then the temporary vector is deleted, as would be any local variable allocated on the stack (see <a href="B19262_05.xhtml#_idTextAnchor199"><em class="italic">Chapter 5</em></a>, <em class="italic">A Comprehensive Look at RAII</em>, later in this book). The last line is the key to exception safety—it swaps the content of the output vector with that of the temporary one. If that line can throw an exception, then our entire work is for nothing—the swap has failed, and the output vector is left in an undefined state since we do not know how much of the swap had succeeded before the exception was thrown. But if the swap does not throw an exception, as in the case for <code>std::vector</code>, then, as long as the control reached the last line, the entire <code>transmogrify()</code> operation has succeeded, and the result will be returned to the caller. What happens to the old content of the output vector? It is now owned by the temporary vector, which is about to be deleted, implicitly, on the next line (the closing brace). Assuming the destructor of <code>C</code> follows the C++ guidelines and does not throw an exception (to do otherwise would be to invite the dreaded specter of undefined behavior), our entire function has been made exception-safe.</p>
<p>This idiom is sometimes<a id="_idIndexMarker193"/> known as <strong class="bold">copy-and-swap</strong> and is, perhaps, the easiest way to implement an operation with commit-or-rollback semantics, or a strong exception-safety guarantee. The key to<a id="_idIndexMarker194"/> the idiom is the ability to swap objects c<a id="_idTextAnchor178"/>heaply and without except<a id="_idTextAnchor179"/>ions being thrown.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor180"/>Other common swap idioms</h2>
<p>There are a few <a id="_idIndexMarker195"/>more commonly used techniques that rely on swap, although none are as critically important as the use of swap for exception safety.</p>
<p>Let’s start with a very simple way to reset a container, or any other swappable object, to its default-constructed state:</p>
<pre class="source-code">
// Example 04
class C {
    public:
    void swap(C&amp; rhs) noexcept {
        … swap data members …
    }
};
C c = ....;    // Object with stuff in it
{
  C tmp;
  c.swap(tmp);    // c is now default-constructed
}            // Old c is now gone</pre>
<p>Note that this code explicitly creates a default-constructed (<em class="italic">empty</em>) object just to swap with it, and uses an extra scope (a pair of curly braces) to ensure that that object is deleted as soon as possible. We can do better by using a temporary object, without a name, to swap with:</p>
<pre class="source-code">
C c = ....;    // Object with stuff in it
C().swap(c);    // Temporary is created and deleted</pre>
<p>The temporary object here is created and deleted within the same line of code and takes the old content of the object <code>c</code> with it. Note that the order of what is swapped with what is very important—the <code>swap()</code> member function is called on the temporary object. An attempt to do the reverse will not compile:</p>
<pre class="source-code">
C c = ....;    // Object with stuff in it
c.swap(C());    // Close but does not compile</pre>
<p>This is because the <code>swap()</code> member function takes its argument by a <code>C&amp;</code> non-const reference, and non-const references cannot be bound to temporary objects (more generally, to <code>r</code>-values). Note that, for the same reason, the <code>swap()</code> non-member function cannot be used to swap an object with a temporary object either, so if the class does not have a <code>swap()</code> member function, then an explicitly named object must be created.</p>
<p>A more general form of this idiom is used to apply transforms to the original object without changing its name in the program. Let’s suppose that we have a vector in our program to which we <a id="_idIndexMarker196"/>want to apply the preceding <code>transmogrify()</code> function; however, we do not want to create a new vector. Instead, we want to continue using the original vector (or at least its variable name) in the program, but with the new data in it. This idiom is an elegant way to achieve the desired result:</p>
<pre class="source-code">
// Example 05
std::vector&lt;C&gt; vec;
...                     // Write data into the vector
{
  std::vector&lt;C&gt; tmp;
  transmogrify(vec, tmp);    // tmp is the result
  swap(vec, tmp);        // Now vec is the result!
}                    // and now old vec is destroyed
...                    // Keep usin<a id="_idTextAnchor181"/>g vec, with new data</pre>
<p>Note that if <code>transmogrify()</code> can throw an exception, we have to use the entire scope, including swap, as a <code>try</code> block to achieve exception safety:</p>
<pre class="source-code">
std::vector&lt;C&gt; vec;
...                     // Write data into the vector
try {
  std::vector&lt;C&gt; tmp;
  transmogrify(vec, tmp);    // throws an exception
  swap(vec, tmp);        // we never get here
} catch (...) {}            // vec is unchanged
...                     // Keep using vec, with old data</pre>
<p>This pattern can be repeated as many times as needed, replacing the content of the object without introducing new names into the program. Contrast it with the more traditional, C-like way that does not use swap:</p>
<pre class="source-code">
std::vector&lt;C&gt; vec;
...    // Write data into the vector std::vector&lt;C&gt; vec1;
transmogrify(vec, vec1);    // Must use vec1 from now on!
std::vector&lt;C&gt; vec2;
transmogrify(vec1, vec2);     // Must use vec2 from now on!</pre>
<p>Note that the old names, <code>vec</code> and <code>vec1</code>, are still accessible after the new data is computed. It would be an easy mistake to use <code>vec</code> in the following code when <code>vec1</code> should be used instead. With<a id="_idIndexMarker197"/> the previously demonstrated swap technique, the pr<a id="_idTextAnchor182"/>ogram is not polluted wit<a id="_idTextAnchor183"/>h new variable names.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor184"/>How to implement and use swap correctly</h2>
<p>We have seen<a id="_idIndexMarker198"/> how the swap functionality is implemented by the standard library, and what the expectations are for a swap implementation. Let’s now see ho<a id="_idTextAnchor185"/>w to correctly support sw<a id="_idTextAnchor186"/>ap for your own types.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor187"/>Implementing swap</h2>
<p>We have seen that all STL<a id="_idIndexMarker199"/> containers, and many other standard library types (for example, <code>std::thread</code>), provide a <code>swap()</code> member function. While not required, it is the easiest way to implement swap that needs access to the private data of the class, as well as the only way to swap an object with a temporary object of the same type. The proper way to declare the <code>swap()</code> member function is like this:</p>
<pre class="source-code">
class C {
  public:
  void swap(C&amp; rhs) noexcept;
};</pre>
<p>Of course, the <code>noexcept</code> specification should only be included if a no-throw guarantee can indeed be given; in some cases, it may need to be conditional, based on properties of other types. The function may also be declared <code>con<a id="_idTextAnchor188"/>stexpr</code>, if appropriate.</p>
<p>How should the swap be implemented? There are several ways. For many classes, we can simply swap the data members, one at a time. This delegates the problem of swapping the objects to their contained types, which, if they follow the pattern, will eventually end up swapping the built-in types that everything is made of. If you know that your data member has a <code>swap()</code> member function, then you can call that. Otherwise, you have to call the non-member swap. This is likely to call an instantiation of the <code>std::swap()</code> template, but you should not invoke it by that name for reasons that will be explained in the next section.</p>
<p>Instead, you should bring the name into the containing scope, and call <code>swap()</code> without the <code>std::</code> qualifier:</p>
<pre class="source-code">
//Example 06a
#include &lt;utility&gt;    // &lt;algorithm&gt; before C++11
...
class C {
  public:
  void swap(C&amp; rhs) noexcept {
    using std::swap;    // Brings in std::swap into this scope
    v_.swap(rhs.v_);
    swap(i_, rhs.i_);    // Calls std::swap
  }
  ...
  private:
  std::vector&lt;int&gt; v_;
  int i_;
};</pre>
<p>A particular implementation idiom that is very swap-friendly is <a id="_idIndexMarker200"/>the so-called <code>.C</code> file. The <em class="italic">pointer to implementation</em> data member is often called <code>p_impl</code> or <code>pimpl</code>, hence the name of<a id="_idIndexMarker202"/> the idiom. Swapping a pimpl-implemented class is as easy as swapping the two pointers:</p>
<pre class="source-code">
// Example 06b
// In the header C.h:
class C_impl;        // Forward declaration
class C {
  public:
  void swap(C&amp; rhs) noexcept {
    swap(pimpl_, rhs.pimpl_);
  }
  void f(...);        // Declaration only
  ...
  <a id="_idTextAnchor189"/>private:
  C_impl* pimpl_;
};
// In the C file:
class C_impl {
  ... real implementation ...
};
void C::f(...) {
  pimpl_-&gt;f(...);    // Actual implementation of C::f()
}</pre>
<p>This takes care of the member function <code>swap()</code>. But what if someone calls a non-member <code>swap()</code> function on our custom types? As written, that call will invoke the default implementation of <code>std::swap()</code>, if it’s visible (for example, due to a <code>using</code> <code>std::swap</code> declaration), that is, the <a id="_idIndexMarker203"/>one that uses the copy or move operations:</p>
<pre class="source-code">
// Example 07a
class C {
  public:
  void swap(C&amp; rhs) noexcept;
};
...
C c1(...), c2(...);
swap(c1, c2);    // Either does not compile
             // or calls std::swap</pre>
<p>Even though we have a <code>swap()</code> member function, <code>std::swap</code> does not use it. It is evident that we must also support a non-member <code>swap()</code> function. We can easily declare one, right after the class declaration. However, we should also consider what happens if the class is declared not in the global scope, but in a namespace:</p>
<pre class="source-code">
// Example07b
namespace N {
  class C {
    public:
    void swap(C&amp; rhs) noexcept;
  };
  void swap(C&amp; lhs, C&amp; rhs) noexcept { lhs.swap(rhs); }
}
...
N::C c1(...), c2(...);
swap(c1, c2);    // Calls non-member N::swap()</pre>
<p>The unqualified call to <code>swap()</code> calls the <code>swap()</code> non-member function inside the <code>N</code> namespace, which in turn calls the member function <code>swap()</code> on one of the arguments (the convention adopted by the standard library is to call <code>lhs.swap()</code>). Note, however, that we did not invoke <code>N::swap()</code>, only <code>swap()</code>. Outside of the <code>N</code> namespace and without a <code>using</code> <code>namespace</code> <code>N;</code> specification, an unqualified call would not normally resolve to a function inside a namespace. However, in this case, it does, due to a feature in the standard<a id="_idIndexMarker204"/> called the <strong class="bold">Argument-Dependent Lookup </strong>(<strong class="bold">ADL</strong>), also known<a id="_idIndexMarker205"/> as the <strong class="bold">Koenig lookup</strong>. The ADL adds to the overload resolution all functions declared in the scopes where the arguments of the function are declared.</p>
<p>In our case, the <a id="_idIndexMarker206"/>compiler sees the <code>c1</code> and <code>c2</code> arguments of the <code>swap(...)</code> function and recognizes their type as <code>N::C</code>, even before it figures out what the <code>swap</code> name refers to. Since the arguments are in the <code>N</code> namespace, all functions declared in that namespace are added to the overload resolution, and thus, the <code>N::swap</code> function becomes visible.</p>
<p>If the type has a <code>swap()</code> member function, then the easiest way to implement the non-member <code>swap()</code> function is to call that. However, such a member function is not required; if the decision was made to not support a <code>swap()</code> member function, then the <code>swap()</code> non-member has to have access to the private data of the class. It would have to be declared a <code>friend</code> function:</p>
<pre class="source-code">
// Example 07c
class C {
  friend void swap(C&amp; rhs) noexcept;
};
void swap(C&amp; lhs, C&amp; rhs) noexcept {
  ... swap data members of C ...
}</pre>
<p>It is also possible to define the implementation of the <code>swap()</code> function inline, without a separate definition:</p>
<pre class="source-code">
// Example 07d
class C {
  friend void swap(C&amp; lhs, C&amp; rhs) noexcept {
    ... swap data members of C ...
  }
};</pre>
<p>This is particularly handy when we have a class template, instead of a single class. We consider this pattern in more detail later, in <a href="B19262_11.xhtml#_idTextAnchor509"><em class="italic">Chapter </em><em class="italic">11</em></a>, <em class="italic">ScopeGuard</em>.</p>
<p>One often forgotten implementation detail is the self-swap—<code>swap(x, x)</code>, or, in the case of a member function call, <code>x.swap(x)</code>. Is it well-defined, but what does it do? The answer appears to be that it is, or should be, well-defined in both C++03 and C++11 (and later), but ends <a id="_idIndexMarker207"/>up doing nothing; that is, it does not change the object (although not necessarily at zero cost). A user-defined swap implementation should either be implicitly safe for self-swap or should explicitly test for it. If the swap is implemented in terms of copy or move assignments, it is important to note that the copy assignment is required by the standard to be safe against self-assignments, while the move assignment may change the object, but must leave it in a valid state, called a <strong class="bold">moved-from</strong> state (in<a id="_idIndexMarker208"/> this state, we can still assign something else to the object).</p>
<p>We should also note that similarly named STL functions <code>std::iter_swap</code> and <code>std::swap_ranges</code> are, in fact, algorithms that use <code>swap()</code> – possibly <code>std::swap</code> – to swap values pointed to by iterators or by entire ranges of iterators. They are also an example of how to correctly invoke <code>swap()</code> functions, not just in STL but everywhere in your code<a id="_idTextAnchor190"/><a id="_idTextAnchor191"/><a id="_idTextAnchor192"/>, as shown in the next section.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor193"/>Using swap correctly</h2>
<p>Up until now, we <a id="_idIndexMarker209"/>have switched between calling a <code>swap()</code> member function, a <code>swap()</code> non-member function, and the explicitly qualified <code>std::swap()</code> operation, without any pattern or reason. We should now bring some discipline to this matter.</p>
<p>First of all, it is always safe and appropriate to call the <code>swap()</code> member function as long as you know that it exists. The latter qualification usually comes up when writing template code—when dealing with concrete types, you typically know what interface they provide. This leaves us with just one question—when calling the <code>swap()</code> non-member function, should we use the <code>std::</code> prefix?</p>
<p>Consider what happens if we do, as shown here:</p>
<pre class="source-code">
// Example 08
namespace N {
  class C {
    public:
    void swap(C&amp; rhs) noexcept;
  };
  void swap(C&amp; lhs, C&amp; rhs) noexcept { lhs.swap(rhs); }
}
...
N::C c1(...), c2(...);
std::swap(c1, c2);    // Calls std::swap()
swap(c1, c2);        // Calls N::swap()</pre>
<p>Note that the argument-dependent lookup does not apply to qualified names, which is why the call to <code>std::swap()</code> still calls the instantiation of the template swap from the <code>&lt;utility&gt;</code> header file of the STL. For this reason, it is recommended never to call <code>std::swap()</code> explicitly, but to bring that overload into the current scope with a <code>using</code> declaration, then call the unqualified <code>swap</code>:</p>
<pre class="source-code">
using std::swap;    // Makes std::swap() available
swap(c1, c2);    // Calls N::swap() if provided
             // Otherwise, calls std::swap()</pre>
<p>This is exactly what STL algorithms do. For example, <code>std::iter_swap</code> is usually implemented something like this:</p>
<pre class="source-code">
template &lt;typename Iter1, typename Iter2&gt;
void iter_swap(Iter1 a, ITer2 b) {
  using std::swap;
  swap(*a, *b);
}</pre>
<p>Unfortunately, the fully qualified invocation of <code>std::swap()</code> is often found in many programs. To protect yourself against such code and to ensure that your custom swap implementation is called no matter what, you can instantiate the <code>std::swap()</code> template for your <a id="_idIndexMarker210"/>own type:</p>
<pre class="source-code">
// Example 09
namespace std {
void swap(N::C&amp; lhs, N::C&amp; rh<a id="_idTextAnchor194"/>s) noexcept {
  lhs.swap(rhs); }
}</pre>
<p>Generally, declaring your own functions or classes for the reserved <code>std::</code> namespace is not allowed by the standard. However, the standard makes an exception for explicit instantiations of certain template functions (<code>std::swap()</code> being among them). With such specialization in place, a call to <code>std::swap()</code> will invoke that instantiation, which forwards it to our custom swap implementation. Note that it is not sufficient to instantiate the <code>std::swap()</code> template, because such instantiations do not participate in the argument-dependent lookup. If the other non-member swap function is not provided, we have the reverse problem:</p>
<pre class="source-code">
using std::swap;        // Makes std::swap() available
std::swap(c1, c2);    // Calls our std::swap() overload
swap(c1, c2);        // Calls default std::swap()</pre>
<p>Now, the non-qualified call ends up calling the instantiation of the default <code>std::swap()</code> operation—the one with the move constructors and assignments. In order to ensure that every call to swap is correctly handled, both a non-member <code>swap()</code> function and the explicit <code>std::swap()</code> instantiation should be implemented (of course, they can, and should, all forward to the same implementation). Finally, note that the standard allows us to extend the <code>std::</code> namespace with template instantiations, but not with additional template overloads. Therefore, if, instead of a single type, we have a class template, we cannot specialize <code>std::swap</code> for it; such code will, in all likelihood, compile, but the standard does not guarantee that the desired overload will be selected (technically, the standard invokes the undefined behavior and guarantees nothing at all). For<a id="_idIndexMarker211"/> that reason alone, calling <code>st<a id="_idTextAnchor195"/>d::swap</code> directly should be avoided.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor196"/>Summary</h1>
<p>The swap functionality in C++ is used to implement several important patterns. The most critical one is the copy-and-swap implementation of exception-safe transactions. All standard library containers, and most other STL objects, provide the swap member function that is fast and, when possible, does not throw exceptions. User-defined types that need to support swap should follow the same pattern. Note, however, that implementing a non-throwing swap function usually requires an extra indirection and goes against several optimization patterns. In addition to the member function swap, we have reviewed the use and implementation of the non-member swap. Given that <code>std::swap</code> is always available, and can be called on any copyable or movable objects, the programmer should take care to implement a non-member swap function too if a better way to swap exists for a given type (in particular, any type with a member function swap should also provide a non-member function overload that calls that member function).</p>
<p>Finally, while the preferred invocation of the non-member swap is without the <code>std::</code> prefix, the alternative use, although ill-advised, is common enough that an implicit instantiation of the <code>std::swap</code> template should be considered.</p>
<p>The next chapter takes us on a tour of one of the most popular, and powerful, C++ idioms<a id="_idTextAnchor197"/>—the C++ way of managing resources.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor198"/>Questions</h1>
<ol>
<li>What does swap do?</li>
<li>How is swap used in exception-safe programs?</li>
<li>Why should a swap function be non-throwing?</li>
<li>Should a member or a non-member implementation of swap be preferred?</li>
<li>How do standard library objects implement swap?</li>
<li>Why should the non-member swap function be called without the <code>std::</code> qualifier?</li>
</ol>
</div>
</body></html>