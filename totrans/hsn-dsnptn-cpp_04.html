<html><head></head><body>
<div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-63"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-64"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.2.1">Swap – from Simple to Subtle</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We begin our exploration of basic C++ idioms with a very simple, even humble, operation—</span><strong class="bold"><span class="koboSpan" id="kobo.4.1">swap</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The notion of swap refers to two objects exchanging places—after the swap, the first object keeps its name, but otherwise looks like the second object used to, and vice versa. </span><span class="koboSpan" id="kobo.5.3">This operation is so fundamental to C++ classes that the standard provides a template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">std::swap</span></strong><span class="koboSpan" id="kobo.7.1">, to do just that. </span><span class="koboSpan" id="kobo.7.2">Rest assured that C++ manages to turn even something as basic as a swap into a complex issue with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">subtle nuances.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The following topics are covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">How is </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">swap</span></strong><span class="koboSpan" id="kobo.13.1"> used by the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">C++ library?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">What are the applications </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">of swap?</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">How can we write exception-safe code </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using swap?</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How can we implement swap for our own </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">types correctly?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">How can we correctly swap variables of an </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">arbitrary type?</span></span></li>
</ul>
<h1 id="_idParaDest-65"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">Here is a link to all the example code of this </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">chapter: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04</span></span></a></p>
<p><span class="koboSpan" id="kobo.27.1">This is a link to the C++ Core </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Guidelines: </span></span><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md</span></span></a></p>
<p><span class="koboSpan" id="kobo.30.1">This is a link for the C++ </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Guidelines Support Library</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.33.1">GSL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">): </span></span><a href="https://github.com/Microsoft/GSL"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https:/</span></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">/github.com/Microsoft/GSL</span></span></a></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor155"/><a id="_idTextAnchor156"/><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.37.1">Swap and the standard template library</span></h1>
<p><span class="koboSpan" id="kobo.38.1">The swap operation</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.39.1"> is widely</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.40.1"> used in the C++ standard library. </span><span class="koboSpan" id="kobo.40.2">All </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Standard Template Library</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.43.1">STL</span></strong><span class="koboSpan" id="kobo.44.1">) containers provide swap functionality, and there is a non-member function template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">std::swap</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">There are also uses of swap in STL algorithms. </span><span class="koboSpan" id="kobo.46.3">The standard library is also a template for implementing custom features that resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">standard ones.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Therefore, we’ll begin our study of the swap operation with a look at the functionalit</span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.49.1">y provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the standard</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.52.1">Swap and STL containers</span></h2>
<p><span class="koboSpan" id="kobo.53.1">Conceptually, swap is equivalent to the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">following operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
template &lt;typename T&gt; void swap(T&amp; x, T&amp; y) { T tmp(x);
  x = y;
  y = tmp;
}</span></pre>
<p><span class="koboSpan" id="kobo.56.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">swap()</span></strong><span class="koboSpan" id="kobo.58.1"> is called, the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">x</span></strong><span class="koboSpan" id="kobo.60.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">y</span></strong><span class="koboSpan" id="kobo.62.1"> objects are swapped. </span><span class="koboSpan" id="kobo.62.2">This, however, is probably the worst possible way to actually implement swap. </span><span class="koboSpan" id="kobo.62.3">The first and most obvious problem with this implementation is that it copies both objects unnecessarily (it actually does three copy operations). </span><span class="koboSpan" id="kobo.62.4">The execution time of this operation is proportional to the size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">T</span></strong><span class="koboSpan" id="kobo.64.1"> type. </span><span class="koboSpan" id="kobo.64.2">For an STL container, the size would refer to the size of the actual container, not to the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">the element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
void swap(std::vector&lt;int&gt;&amp; x, std::vector&lt;int&gt;&amp; y) {
  std::vector&lt;int&gt; tmp(x);
  x = y;
  y = tmp;
}</span></pre>
<p><span class="koboSpan" id="kobo.67.1">Note that this code compiles, and, in most cases, even does the right thing. </span><span class="koboSpan" id="kobo.67.2">However, it copies every element of the vector several times. </span><span class="koboSpan" id="kobo.67.3">The second problem is that it temporarily allocates resources—for example, during the swap, we create a third vector that uses as much memory as one of the vectors being swapped. </span><span class="koboSpan" id="kobo.67.4">This allocation seems unnecessary, given that, in the final state, we have exactly as much data as we started with; only the names we use to access this data have been changed. </span><span class="koboSpan" id="kobo.67.5">The last problem with naive implementation is revealed when we consider what happens if, for example, the memory allocation we just </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">mentioned fails</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.69.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The entire swap operation, which should have been as simple and foolproof as exchanging the names used to access vector elements, instead fails with a memory </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">allocation failure.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">But that’s not the only way it can fail—the copy constructor and the assignment operator can both </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">throw exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">All STL containers, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">std::vector</span></strong><span class="koboSpan" id="kobo.76.1">, provide a guarantee that they can be swapped in constant time. </span><span class="koboSpan" id="kobo.76.2">The way this is accomplished is rather straightforward if you consider that the STL container objects themselves contain only pointers to the data, plus some state, such as object size. </span><span class="koboSpan" id="kobo.76.3">To swap these containers, we need only to swap the pointers (and the rest of the state, of course)—the elements of the container remain exactly where they always were, in dynamically allocated memory, and do not need to be copied or even accessed. </span><span class="koboSpan" id="kobo.76.4">The implementation of the swap needs only to swap the pointers, the sizes, and other state variables (in a real STL implementation, a container class, such as a vector, does not directly consist of data members of built-in types, such as pointers, but has one or more class data members that, in turn, are made from pointers and other </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">built-in types).</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Since any </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.79.1">pointers </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.80.1">or other vector data members are not publicly accessible, the swap has to be implemented as a member function of the container, or be declared a friend. </span><span class="koboSpan" id="kobo.80.2">The STL takes the former approach—all STL containers have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">swap()</span></strong><span class="koboSpan" id="kobo.82.1"> member function that swaps the object with another object of the same type (see examples </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">01a</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.84.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">01b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">The implementation of this by swapping pointers takes care, indirectly, of the two other problems we mentioned. </span><span class="koboSpan" id="kobo.87.2">First of all, because only the data members of the containers are swapped, there is no memory allocation. </span><span class="koboSpan" id="kobo.87.3">Secondly, copying pointers and other built-in types cannot throw an exception, and so the entire swap operation does not throw (and cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">otherwise fail).</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The simple and consistent picture we have described so far is only mostly true. </span><span class="koboSpan" id="kobo.89.2">The first complication, and by far the simpler one, applies only to containers that are parameterized not just on the element type, but also on a callable object of some sort. </span><span class="koboSpan" id="kobo.89.3">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">std::map</span></strong><span class="koboSpan" id="kobo.91.1"> container accepts the optional comparison function for comparing the elements of the map, which, by default, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">std::less</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">Such callable objects have to be stored with the container. </span><span class="koboSpan" id="kobo.93.3">Since they are invoked very often, it is highly desirable, for performance reasons, to keep them in the same memory allocation as the container object itself, and indeed they are made data members of the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">container class.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">However, that optimization comes with a price—swapping two containers now requires exchanging the compare functions; that is, the actual objects, not the pointers to them. </span><span class="koboSpan" id="kobo.95.2">The comparison objects are implemented by the client of the library, so there is no guarantee that swapping them is possible, let alone that it will not throw </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">an excepti</span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.97.1">on.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Therefore, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">std::map</span></strong><span class="koboSpan" id="kobo.100.1">, the standard provides the following guarantee—in order for the map to be swappable, the callable objects must also be swappable. </span><span class="koboSpan" id="kobo.100.2">Furthermore, swapping two maps does not throw an exception, unless swapping comparison objects may throw, in which case, any exception thrown by that swap is propagated from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">std::map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.102.1"> swap.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">This consideration does not apply to containers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">std::vector</span></strong><span class="koboSpan" id="kobo.105.1">, that do not use any callable objects, and swapping these containers still does not throw an exception (as far as we know up </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">to now).</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">The other </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.108.1">complication</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.109.1"> in the otherwise consistent and natural behavior of the swap is due to the allocators, and that is a hard one to resolve. </span><span class="koboSpan" id="kobo.109.2">Consider the problem—the two swapped containers must, necessarily, have allocators of the same type, but not necessarily the same allocator object. </span><span class="koboSpan" id="kobo.109.3">Each container has its elements allocated by its own allocator, and they must be deallocated by the same allocator. </span><span class="koboSpan" id="kobo.109.4">After the swap, the first container owns the elements from the second one and must eventually deallocate them. </span><span class="koboSpan" id="kobo.109.5">This can only be done (correctly) using the allocator of the first container; therefore, the allocators must also </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">be exchanged.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">C++ standards prior to </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">C++11</span></strong><span class="koboSpan" id="kobo.113.1"> ignore the </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.114.1">problem entirely, and decree that any two allocator objects of the same type must be able to deallocate each other’s memory. </span><span class="koboSpan" id="kobo.114.2">If it’s true, then we do not have to swap allocators at all. </span><span class="koboSpan" id="kobo.114.3">If it is not true, then we have already violated the standard and are in undefined behavior territory. </span><span class="koboSpan" id="kobo.114.4">C++11 allows allocators to have a non-trivial state, which must, therefore, be swapped too. </span><span class="koboSpan" id="kobo.114.5">But the allocator objects do not have to be swappable. </span><span class="koboSpan" id="kobo.114.6">The standard addresses the problem in the following way—if, for any </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">allocator_type</span></strong><span class="koboSpan" id="kobo.116.1"> allocator class, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">trait</span></strong><span class="koboSpan" id="kobo.118.1"> class that defines, among other things, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</span></strong><span class="koboSpan" id="kobo.120.1"> trait property, and if this value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">true</span></strong><span class="koboSpan" id="kobo.122.1">, then the allocators are exchanged using an unqualified call to a non-member swap; that is, simply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">swap(allocator1, allocator2)</span></strong><span class="koboSpan" id="kobo.124.1"> call (see the next section to learn what that call actually does). </span><span class="koboSpan" id="kobo.124.2">If this value is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">true</span></strong><span class="koboSpan" id="kobo.126.1">, then the allocators are not swapped at all, and both container objects must use the same allocator. </span><span class="koboSpan" id="kobo.126.2">If that is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">true</span></strong><span class="koboSpan" id="kobo.128.1"> either, then we are back to undefined behavior. </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">C++17</span></strong><span class="koboSpan" id="kobo.130.1"> puts</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.131.1"> a more formal veneer on this by declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">swap()</span></strong><span class="koboSpan" id="kobo.133.1"> member functions of STL containers to be conditionally </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">noexcept()</span></strong><span class="koboSpan" id="kobo.135.1">, with the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">same limitations.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">The requirement that swapping two containers cannot throw an exception, at least as long as the allocators are not involved and the container does not use callable objects or uses non-throwing ones, ends up imposing a rather subtle limitation on the implementation of the container—it prevents the use of local </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">buffer optimi</span><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.139.1">zation.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">We will talk about this optimization in great detail in </span><a href="B19262_10.xhtml#_idTextAnchor453"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.142.1">, </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Local</span></em> <em class="italic"><span class="koboSpan" id="kobo.144.1">Buffer Optimization</span></em><span class="koboSpan" id="kobo.145.1">, but in a nutshell, the idea is to avoid dynamic memory allocation for containers of very few elements, such as short strings, by defining a buffer inside the container class itself. </span><span class="koboSpan" id="kobo.145.2">This </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.146.1">optimization, however, is generally incompatible with the notion of a</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.147.1"> non-throwing swap, since the elements inside the container object can no longer be exchanged </span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.148.1">by merely swapping pointers, but have to be copied between </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the co</span><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.150.1">ntainers.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.151.1">Non-member swap</span></h2>
<p><span class="koboSpan" id="kobo.152.1">The standard also</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.153.1"> provides a template </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">std::swap()</span></strong><span class="koboSpan" id="kobo.155.1"> function. </span><span class="koboSpan" id="kobo.155.2">Prior to C++11, it was declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">&lt;algorithm&gt;</span></strong><span class="koboSpan" id="kobo.157.1"> header; in C++11, it was moved to </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">&lt;utility&gt;</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">The declaration of the function is </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
template &lt;typename T&gt;
  void swap (T&amp; a, T&amp; b);
template &lt;typename T, size_t N&gt;
  void swap(T (&amp;a)[N], T (&amp;b)[N]);    // Since C++11</span></pre>
<p><span class="koboSpan" id="kobo.162.1">The overload for arrays was added in C++11. </span><span class="koboSpan" id="kobo.162.2">In C++20, both versions are additionally declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">constexpr</span></strong><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">For STL containers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">std::swap()</span></strong><span class="koboSpan" id="kobo.166.1"> calls the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">swap()</span></strong><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">As we will see in the following section, the behavior of </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">swap()</span></strong><span class="koboSpan" id="kobo.170.1"> can be customized for other types as well, but without any special efforts, the default implementation is used. </span><span class="koboSpan" id="kobo.170.2">This implementation does a swap using a temporary object. </span><span class="koboSpan" id="kobo.170.3">Before C++11, the temporary object was copy-constructed, and the swap was done with two assignments, just as we did in the preceding section. </span><span class="koboSpan" id="kobo.170.4">The type has to be copyable (both copy-constructible and copy-assignable), otherwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">std::swap()</span></strong><span class="koboSpan" id="kobo.172.1"> will not compile (see examples </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">02a</span></strong><span class="koboSpan" id="kobo.174.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">02b</span></strong><span class="koboSpan" id="kobo.176.1">). </span><span class="koboSpan" id="kobo.176.2">In C++11, </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">std::swap()</span></strong><span class="koboSpan" id="kobo.178.1"> has been redefined to use move construction and move assignment (see example </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">02c</span></strong><span class="koboSpan" id="kobo.180.1">). </span><span class="koboSpan" id="kobo.180.2">As usual, if the class is copyable, but does not have move operations declared at all, then the copy constructor and assignment are used. </span><span class="koboSpan" id="kobo.180.3">Note that if the class has copy operations declared and move operations declared as deleted, there is no automatic fallback to copying—that class is a non-movable type and </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">std::swap()</span></strong><span class="koboSpan" id="kobo.182.1"> will not compile for it (see </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">example </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">02d</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Since copying an object can, in general, throw an exception, swapping two objects for which a custom swap behavior is not provided can throw an exception as well. </span><span class="koboSpan" id="kobo.186.2">Move operations do not usually throw exceptions, and in C++11, if the object has a move constructor and an assignment operator and neither throws an exception, </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">std::swap()</span></strong><span class="koboSpan" id="kobo.188.1"> also provides a no-throw guarantee. </span><span class="koboSpan" id="kobo.188.2">That behavior has been formalized in C++17 with a conditional </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">noexcept()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1"> spec</span><a id="_idTextAnchor167"/><a id="_idTextAnchor168"/><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.191.1">ification.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.192.1">Swapping like the standard</span></h2>
<p><span class="koboSpan" id="kobo.193.1">From the </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.194.1">preceding review of how the</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.195.1"> standard library handles a swap, we can deduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">following guidelines:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.197.1">Classes that support swap should implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">swap()</span></strong><span class="koboSpan" id="kobo.199.1"> member functions that perform the operation in </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">constant time</span></span></li>
<li><span class="koboSpan" id="kobo.201.1">A free-standing </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">swap()</span></strong><span class="koboSpan" id="kobo.203.1"> non-member function should also be provided for all types that can </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">be swapped</span></span></li>
<li><span class="koboSpan" id="kobo.205.1">Swapping two objects should not throw exceptions or </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">otherwise fail</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.207.1">The latter guideline is less strict, and it is not always possible to follow it. </span><span class="koboSpan" id="kobo.207.2">In general, if the type has move operations that do not throw an exception, a non-throwing swap implementation is also possible. </span><span class="koboSpan" id="kobo.207.3">Note also that many exception-safety guarantees, and in particular those provided by the standard library, require that move and swa</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.208.1">p operations do not throw </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">a</span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.210.1">n exception.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.211.1">When and why to use swap</span></h1>
<p><span class="koboSpan" id="kobo.212.1">What is so important</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.213.1"> about the swap functionality that it deserves its own chapter? </span><span class="koboSpan" id="kobo.213.2">For that matter, why even use swap, and not continue to refer to an object by its </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">original name?</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Mostly, it has to do with exception safety, which is also why we keep me</span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.216.1">ntioning when swap can and cannot throw </span><a id="_idTextAnchor175"/><span class="No-Break"><span class="koboSpan" id="kobo.217.1">an exception.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.218.1">Swap and exception safety</span></h2>
<p><span class="koboSpan" id="kobo.219.1">The most important</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.220.1"> application of swap in C++ has to do with writing exception-safe code, or, more generally, error-safe code. </span><span class="koboSpan" id="kobo.220.2">Here is the problem, in a nutshell—in an exception-safe program, throwing an exception should never leave the program in an </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">undefined state.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">More generally, an error condition should never leave the program in an undefined state. </span><span class="koboSpan" id="kobo.222.2">Note that the error does not need to be handled by means of an exception—for example, returning an error code from a function should also be handled without creating undefined behavior. </span><span class="koboSpan" id="kobo.222.3">In particular, if an operation causes an error, the resources already consumed by the operation in progress should be released. </span><span class="koboSpan" id="kobo.222.4">Often, an even stronger guarantee is desired—every operation either succeeds or is entirely </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">rolled back.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Let’s consider an example where we will apply a transform to all elements of a vector, and store the results in a </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">new vector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
// Example 03a
class C;            // Our element type
C transmogrify(C x) {    // Some operation on C
  return C(...);
}
void transmogrify(const std::vector&lt;C&gt;&amp; in,
                  std::vector&lt;C&gt;&amp; out) {
  out.resize(0);
  out.reserve(in.size());
  for (const auto&amp; x : in) {
    out.push_back(transmogrify(x));
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.227.1">Here, we return the vector via an output parameter. </span><span class="koboSpan" id="kobo.227.2">Let us assume that it is a requirement to use an already existing vector for output and we are not doing it for performance reasons. </span><span class="koboSpan" id="kobo.227.3">In all recent versions of C++, returning a vector by value is quite fast: the compiler will either apply the return-value optimization and elide the copy completely (copy elision is not guaranteed but likely) or replace copy by move (also fast, guaranteed). </span><span class="koboSpan" id="kobo.227.4">The vector is made empty at first, and grows to the same size as the input vector. </span><span class="koboSpan" id="kobo.227.5">Any data the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">out</span></strong><span class="koboSpan" id="kobo.229.1"> vector may have had is gone. </span><span class="koboSpan" id="kobo.229.2">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">reserve()</span></strong><span class="koboSpan" id="kobo.231.1"> call that is used to avoid repeated deallocations of the </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">growing vector.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">This code works fine as long as there are no errors, that is, no exceptions are thrown. </span><span class="koboSpan" id="kobo.233.2">But this is not guaranteed. </span><span class="koboSpan" id="kobo.233.3">First of all, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">reserve()</span></strong><span class="koboSpan" id="kobo.235.1"> does a memory allocation, which may fail. </span><span class="koboSpan" id="kobo.235.2">If this </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.236.1">happens, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.238.1"> function will exit via the exception, and the output vector will be empty since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">resize(0)</span></strong><span class="koboSpan" id="kobo.240.1"> call has already been executed. </span><span class="koboSpan" id="kobo.240.2">The initial content of the output vector is lost, and nothing is written to replace it. </span><span class="koboSpan" id="kobo.240.3">Secondly, any iteration of the loop over the elements of the vector may throw an exception. </span><span class="koboSpan" id="kobo.240.4">An exception could be thrown by the copy constructor of the new element of the output vector, or by the transformation itself. </span><span class="koboSpan" id="kobo.240.5">Either way, the loop is interrupted. </span><span class="koboSpan" id="kobo.240.6">STL guarantees that the output vector is not left in an undefined state even if the copy constructor inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">push_back()</span></strong><span class="koboSpan" id="kobo.242.1"> call fails—the new element is not </span><em class="italic"><span class="koboSpan" id="kobo.243.1">partially </span></em><span class="koboSpan" id="kobo.244.1">created, and the vector size is </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">not increased.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">However, the elements already stored will remain in the output vector (and any elements that were there originally are gone). </span><span class="koboSpan" id="kobo.246.2">This may not be what we intended—it is not unreasonable to request that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.248.1"> operation either succeeds and applies the transform to the entire vector, or fails and </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">changes nothing.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">The key to such exception-safe implementation is </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">the swap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
// Example 03b
void transmogrify(const std::vector&lt;C&gt;&amp; in,
                  std::vector&lt;C&gt;&amp; out) {
  std::vector&lt;C&gt; tmp;
  tmp.reserve(in.size());
  for (const C&amp; x : in) {
    tmp.push_back(transmogrify(x));
  }
  out.swap(tmp);    // Mu</span><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.253.1">st not throw!
</span><span class="koboSpan" id="kobo.253.2">}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">In this example, we have changed the code to operate on a temporary vector during the entire transformation. </span><span class="koboSpan" id="kobo.254.2">Note that, in a typical case of an output vector that is empty on input, this does not increase the amount of memory in use. </span><span class="koboSpan" id="kobo.254.3">If the output vector has some data in it, both the new data and the old data exist in memory until the end of the function. </span><span class="koboSpan" id="kobo.254.4">This is necessary to provide a guarantee that the old data will not be deleted unless the new data can be fully computed. </span><span class="koboSpan" id="kobo.254.5">If desired, this guarantee can be traded for lower overall memory use, and the output vector can be emptied at the beginning of the function (on the other hand, any caller who wants to make such a trade-off can just empty the vector before </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">transmogrify()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">If an exception is</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.259.1"> thrown at any time during the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.261.1"> function, right up until the last line, then the temporary vector is deleted, as would be any local variable allocated on the stack (see </span><a href="B19262_05.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.262.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.263.1">, </span><em class="italic"><span class="koboSpan" id="kobo.264.1">A Comprehensive Look at RAII</span></em><span class="koboSpan" id="kobo.265.1">, later in this book). </span><span class="koboSpan" id="kobo.265.2">The last line is the key to exception safety—it swaps the content of the output vector with that of the temporary one. </span><span class="koboSpan" id="kobo.265.3">If that line can throw an exception, then our entire work is for nothing—the swap has failed, and the output vector is left in an undefined state since we do not know how much of the swap had succeeded before the exception was thrown. </span><span class="koboSpan" id="kobo.265.4">But if the swap does not throw an exception, as in the case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">std::vector</span></strong><span class="koboSpan" id="kobo.267.1">, then, as long as the control reached the last line, the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.269.1"> operation has succeeded, and the result will be returned to the caller. </span><span class="koboSpan" id="kobo.269.2">What happens to the old content of the output vector? </span><span class="koboSpan" id="kobo.269.3">It is now owned by the temporary vector, which is about to be deleted, implicitly, on the next line (the closing brace). </span><span class="koboSpan" id="kobo.269.4">Assuming the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">C</span></strong><span class="koboSpan" id="kobo.271.1"> follows the C++ guidelines and does not throw an exception (to do otherwise would be to invite the dreaded specter of undefined behavior), our entire function has been </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">made exception-safe.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">This idiom is sometimes</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.274.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">copy-and-swap</span></strong><span class="koboSpan" id="kobo.276.1"> and is, perhaps, the easiest way to implement an operation with commit-or-rollback semantics, or a strong exception-safety guarantee. </span><span class="koboSpan" id="kobo.276.2">The key to</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.277.1"> the idiom is the ability to swap objects c</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.278.1">heaply and without except</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.279.1">ions </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">being thrown.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.281.1">Other common swap idioms</span></h2>
<p><span class="koboSpan" id="kobo.282.1">There are a few </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.283.1">more commonly used techniques that rely on swap, although none are as critically important as the use of swap for </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">exception safety.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Let’s start with a very simple way to reset a container, or any other swappable object, to its </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">default-constructed state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
// Example 04
class C {
    public:
    void swap(C&amp; rhs) noexcept {
        … swap data members …
    }
};
C c = ....;    // Object with stuff in it
{
  C tmp;
  c.swap(tmp);    // c is now default-constructed
}            // Old c is now gone</span></pre>
<p><span class="koboSpan" id="kobo.288.1">Note that this code explicitly creates a default-constructed (</span><em class="italic"><span class="koboSpan" id="kobo.289.1">empty</span></em><span class="koboSpan" id="kobo.290.1">) object just to swap with it, and uses an extra scope (a pair of curly braces) to ensure that that object is deleted as soon as possible. </span><span class="koboSpan" id="kobo.290.2">We can do better by using a temporary object, without a name, to </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">swap with:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
C c = ....;    // Object with stuff in it
C().swap(c);    // Temporary is created and deleted</span></pre>
<p><span class="koboSpan" id="kobo.293.1">The temporary object here is created and deleted within the same line of code and takes the old content of the object </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">c</span></strong><span class="koboSpan" id="kobo.295.1"> with it. </span><span class="koboSpan" id="kobo.295.2">Note that the order of what is swapped with what is very important—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">swap()</span></strong><span class="koboSpan" id="kobo.297.1"> member function is called on the temporary object. </span><span class="koboSpan" id="kobo.297.2">An attempt to do the reverse will </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
C c = ....;    // Object with stuff in it
c.swap(C());    // Close but does not compile</span></pre>
<p><span class="koboSpan" id="kobo.300.1">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">swap()</span></strong><span class="koboSpan" id="kobo.302.1"> member function takes its argument by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">C&amp;</span></strong><span class="koboSpan" id="kobo.304.1"> non-const reference, and non-const references cannot be bound to temporary objects (more generally, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">r</span></strong><span class="koboSpan" id="kobo.306.1">-values). </span><span class="koboSpan" id="kobo.306.2">Note that, for the same reason, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">swap()</span></strong><span class="koboSpan" id="kobo.308.1"> non-member function cannot be used to swap an object with a temporary object either, so if the class does not have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">swap()</span></strong><span class="koboSpan" id="kobo.310.1"> member function, then an explicitly named object must </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">be created.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">A more general form of this idiom is used to apply transforms to the original object without changing its name in the program. </span><span class="koboSpan" id="kobo.312.2">Let’s suppose that we have a vector in our program to which we </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.313.1">want to apply the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.315.1"> function; however, we do not want to create a new vector. </span><span class="koboSpan" id="kobo.315.2">Instead, we want to continue using the original vector (or at least its variable name) in the program, but with the new data in it. </span><span class="koboSpan" id="kobo.315.3">This idiom is an elegant way to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">desired result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
// Example 05
std::vector&lt;C&gt; vec;
...                     // Write data into the vector
{
  std::vector&lt;C&gt; tmp;
  transmogrify(vec, tmp);    // tmp is the result
  swap(vec, tmp);        // Now vec is the result!
</span><span class="koboSpan" id="kobo.317.2">}                    // and now old vec is destroyed
...                    // Keep usin</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.318.1">g vec, with new data</span></pre>
<p><span class="koboSpan" id="kobo.319.1">Note that if </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">transmogrify()</span></strong><span class="koboSpan" id="kobo.321.1"> can throw an exception, we have to use the entire scope, including swap, as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">try</span></strong><span class="koboSpan" id="kobo.323.1"> block to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">exception safety:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
std::vector&lt;C&gt; vec;
...                     // Write data into the vector
try {
  std::vector&lt;C&gt; tmp;
  transmogrify(vec, tmp);    // throws an exception
  swap(vec, tmp);        // we never get here
} catch (...) {}            // vec is unchanged
...                     // Keep using vec, with old data</span></pre>
<p><span class="koboSpan" id="kobo.326.1">This pattern can be repeated as many times as needed, replacing the content of the object without introducing new names into the program. </span><span class="koboSpan" id="kobo.326.2">Contrast it with the more traditional, C-like way that does not </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">use swap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
std::vector&lt;C&gt; vec;
...    // Write data into the vector std::vector&lt;C&gt; vec1;
transmogrify(vec, vec1);    // Must use vec1 from now on!
</span><span class="koboSpan" id="kobo.328.2">std::vector&lt;C&gt; vec2;
transmogrify(vec1, vec2);     // Must use vec2 from now on!</span></pre>
<p><span class="koboSpan" id="kobo.329.1">Note that the old names, </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">vec</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">vec1</span></strong><span class="koboSpan" id="kobo.333.1">, are still accessible after the new data is computed. </span><span class="koboSpan" id="kobo.333.2">It would be an easy mistake to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">vec</span></strong><span class="koboSpan" id="kobo.335.1"> in the following code when </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">vec1</span></strong><span class="koboSpan" id="kobo.337.1"> should be used instead. </span><span class="koboSpan" id="kobo.337.2">With</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.338.1"> the previously demonstrated swap technique, the pr</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.339.1">ogram is not polluted wit</span><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.340.1">h new </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">variable names.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.342.1">How to implement and use swap correctly</span></h2>
<p><span class="koboSpan" id="kobo.343.1">We have seen</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.344.1"> how the swap functionality is implemented by the standard library, and what the expectations are for a swap implementation. </span><span class="koboSpan" id="kobo.344.2">Let’s now see ho</span><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.345.1">w to correctly support sw</span><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.346.1">ap for your </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">own types.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.348.1">Implementing swap</span></h2>
<p><span class="koboSpan" id="kobo.349.1">We have seen that all STL</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.350.1"> containers, and many other standard library types (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">std::thread</span></strong><span class="koboSpan" id="kobo.352.1">), provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">swap()</span></strong><span class="koboSpan" id="kobo.354.1"> member function. </span><span class="koboSpan" id="kobo.354.2">While not required, it is the easiest way to implement swap that needs access to the private data of the class, as well as the only way to swap an object with a temporary object of the same type. </span><span class="koboSpan" id="kobo.354.3">The proper way to declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">swap()</span></strong><span class="koboSpan" id="kobo.356.1"> member function is </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
class C {
  public:
  void swap(C&amp; rhs) noexcept;
};</span></pre>
<p><span class="koboSpan" id="kobo.359.1">Of course, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">noexcept</span></strong><span class="koboSpan" id="kobo.361.1"> specification should only be included if a no-throw guarantee can indeed be given; in some cases, it may need to be conditional, based on properties of other types. </span><span class="koboSpan" id="kobo.361.2">The function may also be declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">con</span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.363.1">stexpr</span></strong><span class="koboSpan" id="kobo.364.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">if appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">How should the swap be implemented? </span><span class="koboSpan" id="kobo.366.2">There are several ways. </span><span class="koboSpan" id="kobo.366.3">For many classes, we can simply swap the data members, one at a time. </span><span class="koboSpan" id="kobo.366.4">This delegates the problem of swapping the objects to their contained types, which, if they follow the pattern, will eventually end up swapping the built-in types that everything is made of. </span><span class="koboSpan" id="kobo.366.5">If you know that your data member has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">swap()</span></strong><span class="koboSpan" id="kobo.368.1"> member function, then you can call that. </span><span class="koboSpan" id="kobo.368.2">Otherwise, you have to call the non-member swap. </span><span class="koboSpan" id="kobo.368.3">This is likely to call an instantiation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">std::swap()</span></strong><span class="koboSpan" id="kobo.370.1"> template, but you should not invoke it by that name for reasons that will be explained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Instead, you should bring the name into the containing scope, and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">swap()</span></strong><span class="koboSpan" id="kobo.374.1"> without the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">std::</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1"> qualifier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
//Example 06a
#include &lt;utility&gt;    // &lt;algorithm&gt; before C++11
...
</span><span class="koboSpan" id="kobo.377.2">class C {
  public:
  void swap(C&amp; rhs) noexcept {
    using std::swap;    // Brings in std::swap into this scope
    v_.swap(rhs.v_);
    swap(i_, rhs.i_);    // Calls std::swap
  }
  ...
</span><span class="koboSpan" id="kobo.377.3">  private:
  std::vector&lt;int&gt; v_;
  int i_;
};</span></pre>
<p><span class="koboSpan" id="kobo.378.1">A particular implementation idiom that is very swap-friendly is </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.379.1">the so-called </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">pimpl</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.381.1">idiom</span></strong><span class="koboSpan" id="kobo.382.1">, also known as </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.383.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">handle-body idiom</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">It is primarily used to minimize compilation dependencies and avoid exposing the implementation of the class in the header file. </span><span class="koboSpan" id="kobo.385.3">In this idiom, the entire declaration of a class in the header file consists of all the necessary public member functions, plus a single pointer that points to the actual implementation. </span><span class="koboSpan" id="kobo.385.4">The implementation and the body of the member functions are all in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">.C</span></strong><span class="koboSpan" id="kobo.387.1"> file. </span><span class="koboSpan" id="kobo.387.2">The </span><em class="italic"><span class="koboSpan" id="kobo.388.1">pointer to implementation</span></em><span class="koboSpan" id="kobo.389.1"> data member is often called </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">p_impl</span></strong><span class="koboSpan" id="kobo.391.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">pimpl</span></strong><span class="koboSpan" id="kobo.393.1">, hence the name of</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.394.1"> the idiom. </span><span class="koboSpan" id="kobo.394.2">Swapping a pimpl-implemented class is as easy as swapping the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">two pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
// Example 06b
// In the header C.h:
class C_impl;        // Forward declaration
class C {
  public:
  void swap(C&amp; rhs) noexcept {
    swap(pimpl_, rhs.pimpl_);
  }
  void f(...);        // Declaration only
  ...
</span><span class="koboSpan" id="kobo.396.2">  </span><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.397.1">private:
  C_impl* pimpl_;
};
// In the C file:
class C_impl {
  ... </span><span class="koboSpan" id="kobo.397.2">real implementation ...
</span><span class="koboSpan" id="kobo.397.3">};
void C::f(...) {
  pimpl_-&gt;f(...);    // Actual implementation of C::f()
}</span></pre>
<p><span class="koboSpan" id="kobo.398.1">This takes care of the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">swap()</span></strong><span class="koboSpan" id="kobo.400.1">. </span><span class="koboSpan" id="kobo.400.2">But what if someone calls a non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">swap()</span></strong><span class="koboSpan" id="kobo.402.1"> function on our custom types? </span><span class="koboSpan" id="kobo.402.2">As written, that call will invoke the default implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">std::swap()</span></strong><span class="koboSpan" id="kobo.404.1">, if it’s visible (for example, due to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">using</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.406.1">std::swap</span></strong><span class="koboSpan" id="kobo.407.1"> declaration), that is, the </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.408.1">one that uses the copy or </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">move operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
// Example 07a
class C {
  public:
  void swap(C&amp; rhs) noexcept;
};
...
</span><span class="koboSpan" id="kobo.410.2">C c1(...), c2(...);
swap(c1, c2);    // Either does not compile
             // or calls std::swap</span></pre>
<p><span class="koboSpan" id="kobo.411.1">Even though we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">swap()</span></strong><span class="koboSpan" id="kobo.413.1"> member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">std::swap</span></strong><span class="koboSpan" id="kobo.415.1"> does not use it. </span><span class="koboSpan" id="kobo.415.2">It is evident that we must also support a non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">swap()</span></strong><span class="koboSpan" id="kobo.417.1"> function. </span><span class="koboSpan" id="kobo.417.2">We can easily declare one, right after the class declaration. </span><span class="koboSpan" id="kobo.417.3">However, we should also consider what happens if the class is declared not in the global scope, but in </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">a namespace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
// Example07b
namespace N {
  class C {
    public:
    void swap(C&amp; rhs) noexcept;
  };
  void swap(C&amp; lhs, C&amp; rhs) noexcept { lhs.swap(rhs); }
}
...
</span><span class="koboSpan" id="kobo.419.2">N::C c1(...), c2(...);
swap(c1, c2);    // Calls non-member N::swap()</span></pre>
<p><span class="koboSpan" id="kobo.420.1">The unqualified call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">swap()</span></strong><span class="koboSpan" id="kobo.422.1"> calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">swap()</span></strong><span class="koboSpan" id="kobo.424.1"> non-member function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">N</span></strong><span class="koboSpan" id="kobo.426.1"> namespace, which in turn calls the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">swap()</span></strong><span class="koboSpan" id="kobo.428.1"> on one of the arguments (the convention adopted by the standard library is to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">lhs.swap()</span></strong><span class="koboSpan" id="kobo.430.1">). </span><span class="koboSpan" id="kobo.430.2">Note, however, that we did not invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">N::swap()</span></strong><span class="koboSpan" id="kobo.432.1">, only </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">swap()</span></strong><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">Outside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">N</span></strong><span class="koboSpan" id="kobo.436.1"> namespace and without a </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">using</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.438.1">namespace</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.439.1">N;</span></strong><span class="koboSpan" id="kobo.440.1"> specification, an unqualified call would not normally resolve to a function inside a namespace. </span><span class="koboSpan" id="kobo.440.2">However, in this case, it does, due to a feature in the standard</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.441.1"> called the </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">Argument-Dependent Lookup </span></strong><span class="koboSpan" id="kobo.443.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.444.1">ADL</span></strong><span class="koboSpan" id="kobo.445.1">), also known</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.446.1"> as the </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">Koenig lookup</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">The ADL adds to the overload resolution all functions declared in the scopes where the arguments of the function </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">are declared.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">In our case, the </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.451.1">compiler sees the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">c1</span></strong><span class="koboSpan" id="kobo.453.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">c2</span></strong><span class="koboSpan" id="kobo.455.1"> arguments of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">swap(...)</span></strong><span class="koboSpan" id="kobo.457.1"> function and recognizes their type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">N::C</span></strong><span class="koboSpan" id="kobo.459.1">, even before it figures out what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">swap</span></strong><span class="koboSpan" id="kobo.461.1"> name refers to. </span><span class="koboSpan" id="kobo.461.2">Since the arguments are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">N</span></strong><span class="koboSpan" id="kobo.463.1"> namespace, all functions declared in that namespace are added to the overload resolution, and thus, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">N::swap</span></strong><span class="koboSpan" id="kobo.465.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">becomes visible.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">If the type has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">swap()</span></strong><span class="koboSpan" id="kobo.469.1"> member function, then the easiest way to implement the non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">swap()</span></strong><span class="koboSpan" id="kobo.471.1"> function is to call that. </span><span class="koboSpan" id="kobo.471.2">However, such a member function is not required; if the decision was made to not support a </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">swap()</span></strong><span class="koboSpan" id="kobo.473.1"> member function, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">swap()</span></strong><span class="koboSpan" id="kobo.475.1"> non-member has to have access to the private data of the class. </span><span class="koboSpan" id="kobo.475.2">It would have to be declared a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">friend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.478.1">
// Example 07c
class C {
  friend void swap(C&amp; rhs) noexcept;
};
void swap(C&amp; lhs, C&amp; rhs) noexcept {
  ... </span><span class="koboSpan" id="kobo.478.2">swap data members of C ...
</span><span class="koboSpan" id="kobo.478.3">}</span></pre>
<p><span class="koboSpan" id="kobo.479.1">It is also possible to define the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">swap()</span></strong><span class="koboSpan" id="kobo.481.1"> function inline, without a </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">separate definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
// Example 07d
class C {
  friend void swap(C&amp; lhs, C&amp; rhs) noexcept {
    ... </span><span class="koboSpan" id="kobo.483.2">swap data members of C ...
</span><span class="koboSpan" id="kobo.483.3">  }
};</span></pre>
<p><span class="koboSpan" id="kobo.484.1">This is particularly handy when we have a class template, instead of a single class. </span><span class="koboSpan" id="kobo.484.2">We consider this pattern in more detail later, in </span><a href="B19262_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.485.1">Chapter </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.486.1">11</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.487.1">, </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.488.1">ScopeGuard</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">One often forgotten implementation detail is the self-swap—</span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">swap(x, x)</span></strong><span class="koboSpan" id="kobo.492.1">, or, in the case of a member function call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">x.swap(x)</span></strong><span class="koboSpan" id="kobo.494.1">. </span><span class="koboSpan" id="kobo.494.2">Is it well-defined, but what does it do? </span><span class="koboSpan" id="kobo.494.3">The answer appears to be that it is, or should be, well-defined in both C++03 and C++11 (and later), but ends </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.495.1">up doing nothing; that is, it does not change the object (although not necessarily at zero cost). </span><span class="koboSpan" id="kobo.495.2">A user-defined swap implementation should either be implicitly safe for self-swap or should explicitly test for it. </span><span class="koboSpan" id="kobo.495.3">If the swap is implemented in terms of copy or move assignments, it is important to note that the copy assignment is required by the standard to be safe against self-assignments, while the move assignment may change the object, but must leave it in a valid state, called a </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">moved-from</span></strong><span class="koboSpan" id="kobo.497.1"> state (in</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.498.1"> this state, we can still assign something else to </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the object).</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">We should also note that similarly named STL functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">std::iter_swap</span></strong><span class="koboSpan" id="kobo.502.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">std::swap_ranges</span></strong><span class="koboSpan" id="kobo.504.1"> are, in fact, algorithms that use </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">swap()</span></strong><span class="koboSpan" id="kobo.506.1"> – possibly </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">std::swap</span></strong><span class="koboSpan" id="kobo.508.1"> – to swap values pointed to by iterators or by entire ranges of iterators. </span><span class="koboSpan" id="kobo.508.2">They are also an example of how to correctly invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">swap()</span></strong><span class="koboSpan" id="kobo.510.1"> functions, not just in STL but everywhere in your code</span><a id="_idTextAnchor190"/><a id="_idTextAnchor191"/><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.511.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">next section.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.513.1">Using swap correctly</span></h2>
<p><span class="koboSpan" id="kobo.514.1">Up until now, we </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.515.1">have switched between calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">swap()</span></strong><span class="koboSpan" id="kobo.517.1"> member function, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">swap()</span></strong><span class="koboSpan" id="kobo.519.1"> non-member function, and the explicitly qualified </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">std::swap()</span></strong><span class="koboSpan" id="kobo.521.1"> operation, without any pattern or reason. </span><span class="koboSpan" id="kobo.521.2">We should now bring some discipline to </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">this matter.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">First of all, it is always safe and appropriate to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">swap()</span></strong><span class="koboSpan" id="kobo.525.1"> member function as long as you know that it exists. </span><span class="koboSpan" id="kobo.525.2">The latter qualification usually comes up when writing template code—when dealing with concrete types, you typically know what interface they provide. </span><span class="koboSpan" id="kobo.525.3">This leaves us with just one question—when calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">swap()</span></strong><span class="koboSpan" id="kobo.527.1"> non-member function, should we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">std::</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1"> prefix?</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Consider what happens if we do, as </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
// Example 08
namespace N {
  class C {
    public:
    void swap(C&amp; rhs) noexcept;
  };
  void swap(C&amp; lhs, C&amp; rhs) noexcept { lhs.swap(rhs); }
}
...
</span><span class="koboSpan" id="kobo.532.2">N::C c1(...), c2(...);
std::swap(c1, c2);    // Calls std::swap()
swap(c1, c2);        // Calls N::swap()</span></pre>
<p><span class="koboSpan" id="kobo.533.1">Note that the argument-dependent lookup does not apply to qualified names, which is why the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">std::swap()</span></strong><span class="koboSpan" id="kobo.535.1"> still calls the instantiation of the template swap from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">&lt;utility&gt;</span></strong><span class="koboSpan" id="kobo.537.1"> header file of the STL. </span><span class="koboSpan" id="kobo.537.2">For this reason, it is recommended never to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">std::swap()</span></strong><span class="koboSpan" id="kobo.539.1"> explicitly, but to bring that overload into the current scope with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">using</span></strong><span class="koboSpan" id="kobo.541.1"> declaration, then call the </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">unqualified </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">swap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
using std::swap;    // Makes std::swap() available
swap(c1, c2);    // Calls N::swap() if provided
             // Otherwise, calls std::swap()</span></pre>
<p><span class="koboSpan" id="kobo.546.1">This is exactly what STL algorithms do. </span><span class="koboSpan" id="kobo.546.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">std::iter_swap</span></strong><span class="koboSpan" id="kobo.548.1"> is usually implemented something </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
template &lt;typename Iter1, typename Iter2&gt;
void iter_swap(Iter1 a, ITer2 b) {
  using std::swap;
  swap(*a, *b);
}</span></pre>
<p><span class="koboSpan" id="kobo.551.1">Unfortunately, the fully qualified invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">std::swap()</span></strong><span class="koboSpan" id="kobo.553.1"> is often found in many programs. </span><span class="koboSpan" id="kobo.553.2">To protect yourself against such code and to ensure that your custom swap implementation is called no matter what, you can instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">std::swap()</span></strong><span class="koboSpan" id="kobo.555.1"> template for your </span><a id="_idIndexMarker210"/><span class="No-Break"><span class="koboSpan" id="kobo.556.1">own type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
// Example 09
namespace std {
void swap(N::C&amp; lhs, N::C&amp; rh</span><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.558.1">s) noexcept {
  lhs.swap(rhs); }
}</span></pre>
<p><span class="koboSpan" id="kobo.559.1">Generally, declaring your own functions or classes for the reserved </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">std::</span></strong><span class="koboSpan" id="kobo.561.1"> namespace is not allowed by the standard. </span><span class="koboSpan" id="kobo.561.2">However, the standard makes an exception for explicit instantiations of certain template functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">std::swap()</span></strong><span class="koboSpan" id="kobo.563.1"> being among them). </span><span class="koboSpan" id="kobo.563.2">With such specialization in place, a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">std::swap()</span></strong><span class="koboSpan" id="kobo.565.1"> will invoke that instantiation, which forwards it to our custom swap implementation. </span><span class="koboSpan" id="kobo.565.2">Note that it is not sufficient to instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">std::swap()</span></strong><span class="koboSpan" id="kobo.567.1"> template, because such instantiations do not participate in the argument-dependent lookup. </span><span class="koboSpan" id="kobo.567.2">If the other non-member swap function is not provided, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">reverse problem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
using std::swap;        // Makes std::swap() available
std::swap(c1, c2);    // Calls our std::swap() overload
swap(c1, c2);        // Calls default std::swap()</span></pre>
<p><span class="koboSpan" id="kobo.570.1">Now, the non-qualified call ends up calling the instantiation of the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">std::swap()</span></strong><span class="koboSpan" id="kobo.572.1"> operation—the one with the move constructors and assignments. </span><span class="koboSpan" id="kobo.572.2">In order to ensure that every call to swap is correctly handled, both a non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">swap()</span></strong><span class="koboSpan" id="kobo.574.1"> function and the explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">std::swap()</span></strong><span class="koboSpan" id="kobo.576.1"> instantiation should be implemented (of course, they can, and should, all forward to the same implementation). </span><span class="koboSpan" id="kobo.576.2">Finally, note that the standard allows us to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">std::</span></strong><span class="koboSpan" id="kobo.578.1"> namespace with template instantiations, but not with additional template overloads. </span><span class="koboSpan" id="kobo.578.2">Therefore, if, instead of a single type, we have a class template, we cannot specialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">std::swap</span></strong><span class="koboSpan" id="kobo.580.1"> for it; such code will, in all likelihood, compile, but the standard does not guarantee that the desired overload will be selected (technically, the standard invokes the undefined behavior and guarantees nothing at all). </span><span class="koboSpan" id="kobo.580.2">For</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.581.1"> that reason alone, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">st</span><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.583.1">d::swap</span></strong><span class="koboSpan" id="kobo.584.1"> directly should </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">be avoided.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.586.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.587.1">The swap functionality in C++ is used to implement several important patterns. </span><span class="koboSpan" id="kobo.587.2">The most critical one is the copy-and-swap implementation of exception-safe transactions. </span><span class="koboSpan" id="kobo.587.3">All standard library containers, and most other STL objects, provide the swap member function that is fast and, when possible, does not throw exceptions. </span><span class="koboSpan" id="kobo.587.4">User-defined types that need to support swap should follow the same pattern. </span><span class="koboSpan" id="kobo.587.5">Note, however, that implementing a non-throwing swap function usually requires an extra indirection and goes against several optimization patterns. </span><span class="koboSpan" id="kobo.587.6">In addition to the member function swap, we have reviewed the use and implementation of the non-member swap. </span><span class="koboSpan" id="kobo.587.7">Given that </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">std::swap</span></strong><span class="koboSpan" id="kobo.589.1"> is always available, and can be called on any copyable or movable objects, the programmer should take care to implement a non-member swap function too if a better way to swap exists for a given type (in particular, any type with a member function swap should also provide a non-member function overload that calls that </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">member function).</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Finally, while the preferred invocation of the non-member swap is without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">std::</span></strong><span class="koboSpan" id="kobo.593.1"> prefix, the alternative use, although ill-advised, is common enough that an implicit instantiation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">std::swap</span></strong><span class="koboSpan" id="kobo.595.1"> template should </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">be considered.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">The next chapter takes us on a tour of one of the most popular, and powerful, C++ idioms</span><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.598.1">—the C++ way of </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">managing resources.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.600.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.601.1">What does </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">swap do?</span></span></li>
<li><span class="koboSpan" id="kobo.603.1">How is swap used in </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">exception-safe programs?</span></span></li>
<li><span class="koboSpan" id="kobo.605.1">Why should a swap function </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">be non-throwing?</span></span></li>
<li><span class="koboSpan" id="kobo.607.1">Should a member or a non-member implementation of swap </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">be preferred?</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">How do standard library objects </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">implement swap?</span></span></li>
<li><span class="koboSpan" id="kobo.611.1">Why should the non-member swap function be called without the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">std::</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1"> qualifier?</span></span></li>
</ol>
</div>
</body></html>