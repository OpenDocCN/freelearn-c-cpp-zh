["```cpp\nvector<int> numbers {1, 2, 3};\nnumbers.push_back(4);\nassert(numbers == vector<int> {1, 2, 3, 4});\n```", "```cpp\nimmutable_vector<int> numbers {1, 2, 3};\nimmutable_vector<int> moreNumbers = numbers.push_back(4);\nassert(numbers == immutable_vector<int> {1, 2, 3});\nassert(moreNumbers == immutable_vector<int> {1, 2, 3, 4});\n```", "```cpp\n#include <functional>\nauto add = [](const int first, const int second){ return first + second; };\nauto increment = std::bind(add, std::placeholders::_1, 1);\nTEST_CASE(\"add\"){\n        CHECK_EQ(10, add(4, 6));\n}\nTEST_CASE(\"increment\"){\n        CHECK_EQ(10, increment(9));\n}\n```", "```cpp\ntemplate <class F, class G>\nauto compose(F f, G g){\n  return [=](auto value){return f(g(value));};\n}\n```", "```cpp\ndouble computePriceImperative(const int taxPercentage, const int serviceFee, const double price, const int discount){\nreturn (price - discount + serviceFee) * (1 + (static_cast<double>(taxPercentage) / 100));\n}\nTEST_CASE(\"compute price imperative\"){\n        int taxPercentage = 18;\n        int serviceFee = 10;\n        double price = 100;\n        int discount = 10;\n                                   double result = computePriceImperative(taxPercentage, serviceFee, price, discount);\n        CHECK_EQ(118, result);\n}\n```", "```cpp\nauto discountPrice = [](const double price, const int discount){return price - discount;};\nauto addServiceFee = [](const double price, const int serviceFee){ return price + serviceFee; };\nauto applyTax = [](const double price, const int taxPercentage){ return price * (1 + static_cast<double>(taxPercentage)/100); };\nauto computePriceLambda = [](const int taxPercentage, const int serviceFee, const double price, const int discount){\nreturn applyTax(addServiceFee(discountPrice(price, discount), serviceFee), taxPercentage);\n};\nTEST_CASE(\"compute price with lambda\"){\nint taxPercentage = 18;\nint serviceFee = 10;\ndouble price = 100;\nint discount = 10;\ndouble result = computePriceLambda(taxPercentage, serviceFee, price, discount);\nCHECK_EQ(118, result);\n}\n```", "```cpp\nauto computePriceFunctional(const int taxPercentage, const int serviceFee, const double price, const int discount){\nusing std::bind;\nusing std::placeholders::_1;\nauto discountLambda = bind(discountPrice, _1, discount);\nauto serviceFeeLambda = bind(addServiceFee, _1, serviceFee);\nauto applyTaxLambda = bind(applyTax, _1, taxPercentage);\nreturn compose( applyTaxLambda, compose(serviceFeeLambda, discountLambda));\n}\nTEST_CASE(\"compute price functional\"){\nint taxPercentage = 18;\nint serviceFee = 10;\ndouble price = 100;\nint discount = 10;\nauto computePriceLambda = computePriceFunctional(taxPercentage, serviceFee, price, discount);\ndouble result = computePriceLambda(price);\nCHECK_EQ(118, result);\n}\n```", "```cpp\ntemplate <class F, class G>\n  constexpr auto compose(F f, G g){\n    return [=](auto value){return f(g(value));};\n  }\nconstexpr auto discountPriceCompile = [](const double price,   const int discount){return price - discount;};\n  constexpr auto addServiceFeeCompile = [](const double price,   const int serviceFee){ return price + serviceFee; };\n  constexpr auto applyTaxCompile = [](const double price, cons  t int taxPercentage){ return price * (1 + static_cast<double  >(taxPercentage)/100); };\n  template<int taxPercentage, int serviceFee, double price, in  t discount>\n  constexpr auto computePriceFunctionalCompile() {\n          using std::bind;\n          using std::placeholders::_1;\n          constexpr auto discountLambda = bind(discountPrice,   _1, discount);\n          constexpr auto serviceFeeLambda = bind(addServiceFee  , _1, serviceFee);\n          constexpr auto applyTaxLambda = bind(applyTax, _1, t  axPercentage);\n          return compose( applyTaxLambda, compose(serviceFeeLa  mbda, discountLambda));\n  }\nTEST_CASE(\"compute price functional compile\"){\n        constexpr int taxPercentage = 18;\n        constexpr int serviceFee = 10;\n        constexpr double price = 100;\n        constexpr int discount = 10;\n        constexpr auto computePriceLambda = computePriceFunctionalCompile<taxPercentage, serviceFee, price, discount>();\n        double result = computePriceLambda(price);\n        CHECK_EQ(118, result);\n}\n```", "```cpp\nint factorial(const int number){\n    if(number == 0) return 1;\n    return number * factorial(number – 1);\n}\n```", "```cpp\ntemplate<int number>\nstruct Factorial {\nenum { value = number * Factorial<number – 1>::value};\n};\ntemplate<>\nstruct Factorial<0>{\nenum {value = 1};\n};\n```", "```cpp\nconstexpr int factorial(const int number) {\nreturn (number == 0) ? 1 : (number * factorial(number - 1));\n}\n```", "```cpp\nclass Hour{\nprivate:\nint theValue = 0;\nvoid setValue(int candidateValue) {\nif(candidateValue >= 0 && candidateValue <= 23){\ntheValue = candidateValue;\n}\nelse{\nthrow std::out_of_range(\"Value out of range\");\n}\n}\npublic:\nHour(int theValue){\nsetValue(theValue);\n}\nint value() const {\nreturn theValue;\n}\n};\nTEST_CASE(\"Valid hour\"){\nHour hour(10);\nCHECK_EQ(10, hour.value());\n}\nTEST_CASE(\"Invalid hour\"){\nCHECK_THROWS(Hour(30));\n}\n```", "```cpp\ntemplate <int Min, int Max>\nclass RangedInteger{\nprivate:\nint theValue;\nconstexpr RangedInteger(int theValue) : theValue(theValue) {}\npublic:\ntemplate <int CandidateValue>\nstatic constexpr RangedInteger make() {\nstatic_assert(CandidateValue >= Min && CandidateValue <= Max, \"Value out of range.\");\nreturn CandidateValue;\n}\nconstexpr int value() const {\nreturn theValue;\n}\n};\nusing Hour = RangedInteger<0, 23>;\n```", "```cpp\nTEST_CASE(\"Valid hour\"){\nconstexpr Hour h = Hour::make<10>();\nCHECK_EQ(10, h.value());\n}\n```", "```cpp\nTEST_CASE(\"Invalid hour\"){\nconstexpr Hour h2 = Hour::make<30>();\n}\nHour.h: In instantiation of 'static constexpr RangedInteger<Min, Max> RangedInteger<Min, Max>::make() [with int CandidateValue = 30; int Min = 0; int Max = 23]':\nHour.h:11:87: error: static assertion failed: Value out of range.\n   11 |                                 static_assert(CandidateValue >= Min && CandidateValue <= Max, \"Value out of range.\");\n      |                ~~~~~~~~~~~~~~~^~~~~~\nHour.h:11:87: note: '(30 <= 23)' evaluates to false\n```", "```cpp\nauto identity(auto value){ return value;}\nTEST_CASE(\"Identity\"){\nCHECK_EQ(1, identity(1));\nCHECK_EQ(\"asdfasdf\", identity(\"asdfasdf\"));\nCHECK_EQ(vector{1, 2, 3}, identity(vector{1, 2, 3}));\n}\n```", "```cpp\nbool isStringPalindrome(std::string value){\nstd::vector<char> characters(value.begin(), value.end());\nstd::vector<char> reversedCharacters;\nstd::reverse_copy(characters.begin(), characters.end(), std::back_insert_iterator(reversedCharacters));\nreturn characters == reversedCharacters;\n}\nTEST_CASE(\"Palindrome\"){\nCHECK(isStringPalindrome(\"asddsa\"));\nCHECK(isStringPalindrome(\"12321\"));\nCHECK_FALSE(isStringPalindrome(\"123123\"));\nCHECK_FALSE(isStringPalindrome(\"asd\"));\n}\n```", "```cpp\nbool isPalindrome(auto value){\nauto tokens = value | std::views::all;\nauto reversedTokens = value | std::views::reverse;\nreturn std::equal(tokens.begin(), tokens.end(), reversedTokens.begin());\n};\nenum Token{\nX, Y\n};\nTEST_CASE(\"Extreme polymorphic palindrome\"){\nCHECK(isPalindrome(string(\"asddsa\")));\nCHECK(isPalindrome(vector<string>{\"asd\", \"dsa\", \"dsa\", \"asd\"}));\nCHECK(isPalindrome(vector<Token>{Token::X, Token::Y, Token::Y, Token::X}));\n}\n```", "```cpp\nIn file included from testPalindrome.cpp:3:\nPalindrome.h: In instantiation of 'bool isPalindrome(auto:21)\n[with auto:21 = int]':\ntestPalindrome.cpp:30:2:   required from here\nPalindrome.h:14:29: error: no match for 'operator|' (operand t\nypes are 'int' and 'const std::ranges::views::_All')\n   14 |         auto tokens = value | std::views::all;\n      |                       ~~~~~~^~~~~~~~~~~~~~~~~\n```"]