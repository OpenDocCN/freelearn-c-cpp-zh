- en: '*Chapter 15*: Advanced OOP – Inheritance and Polymorphism'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：高级OOP – 继承和多态'
- en: 'In this chapter, we will further extend our knowledge of OOP by looking at
    the slightly more advanced concepts of **inheritance** and **polymorphism**. We
    will then be able to use this new knowledge to implement the star characters of
    our game, Thomas and Bob. Here is what we will cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过查看稍微高级一些的概念**继承**和**多态**来进一步扩展我们对面向对象编程（OOP）的知识。然后我们将能够使用这些新知识来实现游戏中的星级角色，托马斯和鲍勃。以下是本章我们将涵盖的内容：
- en: Learn how to extend and modify a class using inheritance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用继承扩展和修改一个类
- en: Treat an object of a class as if it is more than one type of class by using
    polymorphism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用多态，将一个类的对象视为多种类型的类
- en: Learn about abstract classes and how designing classes that are never instantiated
    can actually be useful
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解抽象类以及设计永远不会实例化的类实际上是有用的
- en: Build an abstract `PlayableCharacter` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个抽象的`PlayableCharacter`类
- en: Put inheritance to work with the `Thomas` and `Bob` classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Thomas`和`Bob`类实现继承
- en: Add Thomas and Bob to the game project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将托马斯和鲍勃添加到游戏项目中
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We have already seen how we can use other people's hard work by instantiating
    objects from the classes of the SFML library. But this whole OOP thing goes even
    further than that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过从SFML库的类中实例化对象来利用他人的辛勤工作。但这个面向对象编程（OOP）的事情甚至比这还要深入。
- en: What if there is a class that has loads of useful functionality in it, but is
    not quite what we want? In this situation, we can **inherit** from the other class.
    Just like it sounds, **inheritance** means we can harness all the features and
    benefits of other people's classes, including the encapsulation, while further
    refining or extending the code specifically to our situation. In this project,
    we will inherit from and extend some SFML classes; we will also do so with our
    own classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类中包含大量有用的功能，但并不完全符合我们的需求，那会怎样？在这种情况下，我们可以从其他类中**继承**。正如其名，**继承**意味着我们可以利用其他人的类的所有功能和好处，包括封装，同时进一步细化或扩展代码以适应我们的特定情况。在这个项目中，我们将从SFML类中继承和扩展；我们也将使用我们自己的类这样做。
- en: Let's look at some code that uses inheritance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用继承的代码。
- en: Extending a class
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展一个类
- en: With all this in mind, let's look at an example class and see how we can extend
    it, just to see the syntax and as a first step.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们看看一个示例类，看看我们如何扩展它，只是为了看看语法，作为第一步。
- en: 'First, we define a class to inherit from. This is no different from how we
    created any of our other classes. Take a look at this hypothetical `Soldier` class
    declaration:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个要继承的类。这与我们创建其他任何类的方式没有区别。看看这个假设的`Soldier`类声明：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code, we define a `Soldier` class. It has four private variables:
    `m_Health`, `m_Armour`, `m_Range`, and `m_ShotPower`. It has also four public
    functions: `setHealth`, `setArmour, setRange`, and `setShotPower`. We don''t need
    to see the definitions of these functions; they will simply initialize the appropriate
    variable that their name makes obvious.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们定义了一个`Soldier`类。它有四个私有变量：`m_Health`、`m_Armour`、`m_Range`和`m_ShotPower`。它还有四个公共函数：`setHealth`、`setArmour`、`setRange`和`setShotPower`。我们不需要看到这些函数的定义；它们将简单地初始化它们名称所暗示的适当变量。
- en: We can also imagine that a fully implemented `Soldier` class would be much more
    in-depth than this. It would probably have functions such as `shoot`, `goProne`,
    and so on. If we implemented a `Soldier` class in an SFML project, it would likely
    have a `Sprite` object, as well as an `update` and a `getPostion` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以想象，一个完全实现的`Soldier`类会比这个更深入。它可能包含诸如`shoot`、`goProne`等函数。如果我们在一个SFML项目中实现`Soldier`类，它可能有一个`Sprite`对象，以及`update`和`getPostion`函数。
- en: 'The simple scenario that we''ve presented here is suitable if we wish to learn
    about inheritance. Now, let''s look at something new: inheriting from the `Soldier`
    class. Look at the following code, especially the highlighted part:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提出的简单场景，如果我们想了解继承，是合适的。现在，让我们看看一些新的内容：从`Soldier`类继承。看看下面的代码，特别是高亮部分：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By adding `: public Soldier` to the `Sniper` class declaration, `Sniper` inherits
    from `Soldier`. But what does this mean, exactly? `Sniper` `Soldier`. It has all
    the variables and functions of `Soldier`. Inheritance is even more than this,
    however.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在`Sniper`类声明中添加`: public Soldier`，`Sniper`从`Soldier`继承。但这究竟意味着什么呢？`Sniper`
    `Soldier`。它拥有`Soldier`的所有变量和函数。然而，继承不仅仅是这样。'
- en: Also note that, in the previous code, we declare a `Sniper` constructor. This
    constructor is unique to `Sniper`. We have not only inherited from `Soldier`;
    we have `Soldier`. All the functionality (definitions) of the `Soldier` class
    would be handled by the `Soldier` class, but the definition of the `Sniper` constructor
    must be handled by the `Sniper` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在之前的代码中，我们声明了一个 `Sniper` 构造函数。这个构造函数是 `Sniper` 独有的。我们不仅继承了 `Soldier`，我们还拥有
    `Soldier`。`Soldier` 类的所有功能（定义）将由 `Soldier` 类处理，但 `Sniper` 构造函数的定义必须由 `Sniper`
    类处理。
- en: 'Here is what the hypothetical `Sniper` constructor definition might look like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是假设的 `Sniper` 构造函数定义可能的样子：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We could go ahead and write a bunch of other classes that are extensions of
    the `Soldier` class, perhaps `Commando` and `Infantryman`. Each would have the
    exact same variables and functions, but each could also have a unique constructor
    that initializes those variables appropriate to the specific type of `Soldier`.
    `Commando` might have very high `m_Health` and `m_ShotPower` but really puny `m_Range`.
    `Infantryman` might be in between `Commando` and `Sniper` with mediocre values
    for each variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写其他一些扩展 `Soldier` 类的类，比如 `Commando` 和 `Infantryman`。每个类都会有完全相同的变量和函数，但每个类也可以有一个独特的构造函数，初始化那些适合特定类型
    `Soldier` 的变量。`Commando` 可能具有非常高的 `m_Health` 和 `m_ShotPower`，但 `m_Range` 非常小。`Infantryman`
    可能介于 `Commando` 和 `Sniper` 之间，每个变量的值都处于中等水平。
- en: As if OOP wasn't useful enough already, we can now model real-world objects,
    including their hierarchies. We can achieve this by sub-classing/extending/inheriting
    from other classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像面向对象编程（OOP）本身已经足够有用一样，我们现在可以模拟现实世界中的对象，包括它们的层次结构。我们可以通过子类化/扩展/从其他类继承来实现这一点。
- en: The terminology we might like to learn here is that the class that is extended
    from is the **super-class**, and the class that inherits from the super-class
    is the **sub-class**. We can also say **parent** and **child** class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想在这里学习的一个术语是，从其扩展的类是 **super-class**，从超级类继承的类是 **sub-class**。我们也可以说 **parent**
    和 **child** 类。
- en: Tip
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You might find yourself asking this question about inheritance: why? The reason
    is something like this: we can write common code once; in the parent class, we
    can update that common code and all the classes that inherit from it are also
    updated. Furthermore, a sub-class only gets to use public and **protected** instance
    variables and functions. So, designed properly, this also enhances the goals of
    encapsulation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对继承提出这个问题：为什么？原因可能如下：我们可以一次编写通用的代码；在父类中，我们可以更新这些通用代码，并且从它继承的所有类也会得到更新。此外，子类只能使用公共和
    **protected** 实例变量和函数。所以，如果设计得当，这也增强了封装的目标。
- en: 'Did you say protected? Yes. There is an access specifier for class variables
    and functions called `protected` specifier:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你说的是 `protected` 吗？是的。有一个用于类变量和函数的访问修饰符叫做 `protected` 修饰符：
- en: '`Public` variables and functions can be accessed and used by anyone with an
    instance of the class.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Public` 变量和函数可以被任何拥有该类实例的人访问和使用。'
- en: '`Private` variables and functions can only accessed/used by the internal code
    of the class, and not directly from an instance. This is good for encapsulation
    and when we need to access/change private variables, since we can provide public
    getter and setter functions (such as `getSprite`). If we extend a class that has
    `private` variables and functions, that child class **cannot** directly access
    the private data of its parent.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Private` 变量和函数只能由类的内部代码访问/使用，不能直接从实例中访问。这对于封装和当我们需要访问/更改私有变量时是有好处的，因为我们可以提供公共的获取器和设置器函数（例如
    `getSprite`）。如果我们扩展一个具有 `private` 变量和函数的类，那么这个子类**不能**直接访问其父类的私有数据。'
- en: '`Protected` variables and functions are almost the same as private. They cannot
    be accessed/used directly by an instance of the class. However, they **can** be
    used directly by any class that extends the class they are declared in. So, it
    is like they are private, except to child classes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protected` 变量和函数几乎与私有相同。它们不能被类的实例直接访问/使用。然而，它们**可以**被声明在其中的任何扩展类的实例直接使用。所以，它们就像私有一样，除了对子类。'
- en: To fully understand what protected variables and functions are and how they
    can be useful, let's look at another topic first. Then, we will see them in action.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解 `protected` 变量和函数是什么以及它们如何有用，我们先看看另一个话题。然后，我们将看到它们在实际中的应用。
- en: Polymorphism
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: '**Polymorphism** allows us to write code that is less dependent on the types
    we are trying to manipulate. This can make our code clearer and more efficient.
    Polymorphism means many forms. If the objects that we code can be more than one
    type of thing, then we can take advantage of this.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性**使我们能够编写不那么依赖于我们试图操作的类型的代码。这可以使我们的代码更清晰、更高效。多态性意味着多种形式。如果我们编写的对象可以代表多种类型的事物，那么我们可以利用这一点。'
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'But what does polymorphism mean to us? Boiled down to its simplest definition,
    polymorphism means the following: any sub-class can be used as part of the code
    that uses the super-class. This means we can write code that is simpler and easier
    to understand and also easier to modify or change. Also, we can write code for
    the super-class and rely on the fact that no matter how many times it is sub-classed,
    within certain parameters, the code will still work.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但多态性对我们来说意味着什么？简化到最简单的定义，多态性意味着以下内容：任何子类都可以作为使用超类的代码的一部分。这意味着我们可以编写更简单、更容易理解、也更容易修改或更改的代码。此外，我们可以为超类编写代码，并依赖于这样一个事实：无论它被子类化多少次，在一定的参数范围内，代码仍然可以工作。
- en: Let's discuss an example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个例子。
- en: Suppose we want to use polymorphism to help write a zoo management game where
    we must feed and tend to the needs of animals. We will probably want to have a
    function such as `feed`. We will also probably want to pass an instance of the
    animal to be fed into the `feed` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用多态性来帮助编写一个动物园管理游戏，在这个游戏中我们必须喂养和照顾动物的需求。我们可能需要一个像`feed`这样的函数。我们也可能想将待喂养的动物的实例传递给`feed`函数。
- en: A zoo, of course, has lots of animals, such as Lion, Elephant, and Three-toed
    Sloth. With our new knowledge of C++ inheritance, it makes sense to code an `Animal`
    class and have all the different types of animal inherit from it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，动物园有很多动物，比如狮子、大象和三趾树懒。根据我们对C++继承的新知识，编写一个`Animal`类并让所有不同类型的动物从它继承下来是有意义的。
- en: 'If we want to write a function (`feed`) that we can pass `Lion`, `Elephant`,
    and `ThreeToedSloth` into as a parameter, it might seem like we need to write
    a `feed` function for each type of `Animal`. However, we can write polymorphic
    functions with polymorphic return types and arguments. Take a look at the following
    definition of the hypothetical feed function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个函数（`feed`），我们可以将`Lion`、`Elephant`和`ThreeToedSloth`作为参数传递，这似乎意味着我们需要为每种`Animal`类型编写一个`feed`函数。然而，我们可以编写具有多态返回类型和参数的多态函数。看看以下假设的`feed`函数的定义：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding function has an `Animal` reference as a parameter, meaning that
    any object that is built from a class that extends `Animal` can be passed into
    it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数有一个`Animal`引用作为参数，这意味着任何从扩展`Animal`的类中构建的对象都可以传递给它。
- en: This means you can write code today and make another subclass in a week, month,
    or year, and the very same functions and data structures will still work. Also,
    we can enforce a set of rules upon our subclasses regarding what they can and
    cannot do, as well as how they do it. So, good design in one stage can influence
    it at other stages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你今天可以编写代码，然后在下周、下个月或下一年创建另一个子类，而相同的函数和数据结构仍然可以工作。此外，我们可以在子类上强制实施一套规则，关于它们可以做什么以及如何做，以及它们如何实现。因此，一个阶段的好设计可以在其他阶段产生影响。
- en: But will we ever really want to instantiate an actual Animal?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的会想要实例化一个实际的Animal吗？
- en: Abstract classes – virtual and pure virtual functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类 - 虚函数和纯虚函数
- en: An **abstract class** is a class that cannot be instantiated and therefore cannot
    be made into an object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**抽象类**是一个不能实例化的类，因此不能被制作成对象。
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some terminology we might like to learn about here is *concrete* class. A **concrete
    class** is any class that isn't abstract. In other words, all the classes we have
    written so far have been concrete classes and can be instantiated into usable
    objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想在这里了解的一些术语是*具体*类。一个**具体类**是任何非抽象类。换句话说，我们迄今为止编写的所有类都一直是具体类，并且可以被实例化为可用的对象。
- en: So, it's code that will never be used, then? But that's like paying an architect
    to design your home and then never building it!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那这是代码永远不会被使用吗？但那就像支付建筑师设计你的房子然后从不建造它一样！
- en: If we, or the designer of a class, wants to force its users to inherit it before
    using their class, they can make a class **abstract**. If this happens, we cannot
    make an object from it; therefore, we must inherit from it first and make an object
    from the sub-class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们，或者一个类的设计者，想要强制用户在使用他们的类之前继承它，他们可以使一个类成为**抽象类**。如果这样做了，我们就不能从这个类中创建一个对象；因此，我们必须首先从它继承，然后从子类创建一个对象。
- en: To do so, we can make a function **pure virtual** and not provide any definition.
    Then, that function must be **overridden** (**rewritten**) in any class that inherits
    from it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以定义一个**纯虚函数**而不提供任何定义。然后，这个函数必须在继承自它的任何类中被**重写**（**重新定义**）。
- en: 'Let''s look at an example; it will help. We can make a class abstract by adding
    a pure virtual function such as the abstract `Animal` class, which can only perform
    the generic action of `makeNoise`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子；它会有所帮助。我们可以通过添加一个纯虚函数，例如抽象的`Animal`类，它只能执行通用的`makeNoise`动作，来使一个类成为抽象类：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we add the C++ keyword `virtual,` before, and `= 0` after the
    function declaration. Now, any class that extends/inherits from `Animal` must
    override the `makeNoise` function. This might make sense since different types
    of animal make very different types of noise. We could have assumed that anybody
    who extends the `Animal` class is smart enough to notice that the `Animal` class
    cannot make a noise and that they will need to handle it, but what if they don't
    notice? The point is that by making a pure virtual function, we guarantee that
    they will, because they must.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在函数声明之前添加了C++关键字`virtual`，并在其后添加了`= 0`。现在，任何扩展/继承自`Animal`的类都必须重写`makeNoise`函数。这可能是合理的，因为不同类型的动物会发出非常不同的声音。我们可能假设扩展`Animal`类的任何人足够聪明，会注意到`Animal`类不能发出声音，并且他们将需要处理它，但如果没有注意到怎么办？重点是，通过定义一个纯虚函数，我们确保他们会，因为他们必须。
- en: Abstract classes are also useful because, sometimes, we want a class that can
    be used as a polymorphic type, but we need to guarantee it can never be used as
    an object. For example, `Animal` doesn't really make sense on its own. We don't
    talk about animals; we talk about types of animals. We don't say, "Ooh, look at
    that lovely, fluffy, white animal!", or, "Yesterday we went to the pet shop and
    got an animal and an animal bed." It's just too, well, abstract.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类也很有用，因为有时我们想要一个可以作为多态类型的类，但我们又需要保证它永远不能作为一个对象使用。例如，`Animal`本身并没有什么意义。我们不谈论动物；我们谈论动物的种类。我们不说，“哇，看那只可爱、蓬松、白色的动物！”或者，“昨天我们去宠物店买了一只动物和一张动物床。”这太抽象了。
- en: So, an abstract class is kind of like a `Worker` class, for example, and extend
    it to make `Miner`, `Steelworker`, `OfficeWorker`, and, of course, `Programmer`.
    But what exactly does a plain `Worker` do? Why would we ever want to instantiate
    one?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个抽象类就像一个`Worker`类，例如，我们可以扩展它来创建`Miner`、`Steelworker`、`OfficeWorker`，当然还有`Programmer`。但一个普通的`Worker`到底做什么呢？我们为什么想要实例化一个呢？
- en: The answer is we wouldn't want to instantiate one, but we might want to use
    it as a polymorphic type so that we can pass multiple `Worker` sub-classes between
    functions and have data structures that can hold all types of workers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可能不想实例化一个，但我们可能想将其用作多态类型，这样我们就可以在函数之间传递多个`Worker`子类，并且有可以存储所有类型工人的数据结构。
- en: All pure virtual functions must be overridden by any class that extends the
    parent class that contains the pure virtual function. This means that the abstract
    class can provide some of the common functionality that would be available in
    all its subclasses. For example, the `Worker` class might have the `m_AnnualSalary`,
    `m_Productivity`, and `m_Age` member variables. It might also have the `getPayCheck`
    function, which is not pure virtual and is the same in all the sub-classes, but
    a `doWork` function, which is pure virtual and must be overridden, because all
    the different types of `Worker` will `doWork` very differently.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有纯虚函数都必须由包含纯虚函数的父类扩展的任何类重写。这意味着抽象类可以提供一些在所有子类中都可用的公共功能。例如，`Worker`类可能有`m_AnnualSalary`、`m_Productivity`和`m_Age`成员变量。它也可能有一个`getPayCheck`函数，这不是纯虚函数，在所有子类中都是相同的，但有一个`doWork`函数，这是纯虚函数，必须被重写，因为所有不同类型的`Worker`将会有不同的`doWork`方式。
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By the way, `= 0` off to the end. In the current game project, we will use a
    pure virtual function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`= 0`一直到最后。在当前的游戏项目中，我们将使用纯虚函数。
- en: If any of this virtual, pure virtual, or abstract stuff is unclear, using it
    is probably the best way to understand it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何关于虚拟、纯虚或抽象的内容不清楚，使用它们可能是理解它们最好的方式。
- en: Building the PlayableCharacter class
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 PlayableCharacter 类
- en: Now that we know the basics of inheritance, polymorphism, and pure virtual functions,
    we will put them to use. We will build a `PlayableCharacter` class that has most
    of the functionality that any character from our game is going to need. It will
    have one pure virtual function, known as `handleInput`. The `handleInput` function
    will need to be quite different in the sub-classes, so this makes sense.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了继承、多态和纯虚函数的基础，我们将把它们应用到实践中。我们将构建一个具有我们游戏中任何角色所需的大部分功能的 `PlayableCharacter`
    类。它将有一个纯虚函数，称为 `handleInput`。`handleInput` 函数在子类中需要相当不同，所以这样做是有意义的。
- en: As `PlayableCharacter` will have a pure virtual function, it will be an abstract
    class and no objects of it will be possible. We will then build the `Thomas` and
    `Bob` classes, which will inherit from `PlayableCharacter`, implement the definition
    of the pure virtual function, and allow us to instantiate `Bob` and `Thomas` objects
    in our game. It will not be possible to instantiate a `PlayableCharacter` instance
    directly, but we wouldn't want to because it is too abstract anyway.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PlayableCharacter` 将有一个纯虚函数，它将是一个抽象类，并且不可能有它的对象。然后我们将构建 `Thomas` 和 `Bob`
    类，这些类将继承自 `PlayableCharacter`，实现纯虚函数的定义，并允许我们在游戏中实例化 `Bob` 和 `Thomas` 对象。不可能直接实例化一个
    `PlayableCharacter` 实例，但我们不希望这样做，因为无论如何它都太抽象了。
- en: Coding PlayableCharacter.h
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 PlayableCharacter.h
- en: As usual when creating a class, we will start off with the header file that
    will contain the member variable and function declarations. What is new is that,
    in this class, we will declare some **protected** member variables. Remember that
    protected variables can be used as if they were public in classes that inherit
    from the class with the protected variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如创建类时的常规做法，我们将从包含成员变量和函数声明的头文件开始。新的地方在于，在这个类中，我们将声明一些 **protected** 成员变量。记住，受保护的变量可以在继承自具有受保护变量的类的类中使用，就像它们是公共的。
- en: Right-click `PlayableCharacter.h`. Finally, click the `PlayableCharacter` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `PlayableCharacter.h`。最后，点击 `PlayableCharacter` 类。
- en: We will add and discuss the contents of the `PlayableCharacter.h` file in three
    sections. First will be the `protected` section, followed by `private`, and then
    `public`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个部分中添加和讨论 `PlayableCharacter.h` 文件的内容。首先是 `protected` 部分，然后是 `private`，最后是
    `public`。
- en: 'Add the following code to the `PlayableCharacter.h` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `PlayableCharacter.h` 文件中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing to notice in the code we just wrote is that all the variables
    are `protected`. This means that when we inherit from the class, all the variables
    we just wrote will be accessible to those classes that extend it. We will extend
    this class with the `Thomas` and `Bob` classes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚编写的代码中，首先要注意的是所有变量都是 `protected`。这意味着当我们从该类继承时，我们刚刚编写的所有变量都将对扩展它的那些类可访问。我们将使用
    `Thomas` 和 `Bob` 类来扩展这个类。
- en: Tip
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The terms *inherit from* and *extend* are virtually synonymous in most contexts
    in this book. Sometimes, one seems more appropriate than the other, however.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大多数上下文中，术语 *继承自* 和 *扩展* 几乎是同义的。然而，有时一个似乎比另一个更合适。
- en: Apart from the `protected` access specification, there is nothing new or complicated
    about the previous code. It is worth paying attention to some of the details,
    however. If we do, it will be easy to understand how the class works as we progress.
    So, let's run through those `protected` variables, one at a time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `protected` 访问指定之外，之前的代码没有什么是新的或复杂的。然而，值得注意一些细节。如果我们这样做，随着我们前进，将很容易理解类的工作方式。所以，让我们逐个查看这些
    `protected` 变量。
- en: We have our somewhat predictable `Sprite`, `m_Sprite`. We have a `float` variable
    called `m_JumpDuration`, which will hold a value representing the time that the
    character is able to jump for. The greater the value, the further/higher the character
    will be able to jump.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们相对可预测的 `Sprite`，`m_Sprite`。我们有一个名为 `m_JumpDuration` 的 `float` 变量，它将保存一个表示角色能够跳跃的时间的值。该值越大，角色能够跳得越远/越高。
- en: Next, we have a Boolean `m_IsJumping`, which is `true` when the character is
    jumping and `false` otherwise. This will be useful for making sure that the character
    can't jump while in mid-air.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个布尔值 `m_IsJumping`，当角色在跳跃时为 `true`，否则为 `false`。这将确保角色在空中时不能跳跃。
- en: The `m_IsFalling` variable has a similar use to `m_IsJumping`. It will be used
    to know when a character is falling.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_IsFalling` 变量与 `m_IsJumping` 有类似的作用。它将用来知道角色何时在坠落。'
- en: Next, we have two Booleans that will be true if the character's left or right
    keyboard buttons are currently being pressed. These are relatively dependent upon
    the character (*A* and *D* for Thomas, and the *Left* and *Right* arrow keys for
    Bob, respectively). How we respond to these Booleans will be seen in the `Thomas`
    and `Bob` classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个布尔值，如果角色的左右键盘按钮当前被按下，它们将是 `true`。这些相对依赖于角色（托马斯的 *A* 和 *D*，鲍勃的 *Left*
    和 *Right* 光标键）。我们将如何响应这些布尔值将在 `Thomas` 和 `Bob` 类中看到。
- en: The  `m_TimeThisJump` float variable is updated each frame that `m_IsJumping`
    is `true`. We can then find out when `m_JumpDuration` has been reached.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_TimeThisJump` 浮点变量在 `m_IsJumping` 为 `true` 的每帧更新。然后我们可以找出何时达到 `m_JumpDuration`。'
- en: The final `protected` variable is the `m_JustJumped` Boolean. This will be `true`
    if a jump was initiated in the current frame. It will be used so that we know
    when to play a jump sound effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个 `protected` 变量是 `m_JustJumped` 布尔值。如果当前帧中启动了跳跃，它将是 `true`。它将被用来知道何时播放跳跃音效。
- en: 'Next, add the following `private` variables to the `PlayableCharacter.h` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下 `private` 变量添加到 `PlayableCharacter.h` 文件中：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we have some interesting `private` variables. Remember
    that these variables will only be directly accessible to the code in the `PlayableCharacter`
    class. The `Thomas` and `Bob` classes will not be able to access them directly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们有一些有趣的 `private` 变量。请记住，这些变量将只直接对 `PlayableCharacter` 类中的代码可访问。`Thomas`
    和 `Bob` 类将无法直接访问它们。
- en: The `m_Gravity` variable will hold the number of pixels per second that the
    character will fall. The `m_Speed` variable will hold the number of pixels per
    second that the character can move left or right.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_Gravity` 变量将保存角色每秒下落的像素数。`m_Speed` 变量将保存角色每秒可以向左或向右移动的像素数。'
- en: The `Vector2f`, `m_Position` variable is the position in the world (not the
    screen) where the center of the character is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2f`，`m_Position` 变量是世界中（而非屏幕上）角色中心的位置。'
- en: The next four `FloatRect` objects are important to discuss. When we did collision
    detection in the *Zombie Arena* game, we simply checked to see if two `FloatRect`
    objects intersected. Each `FloatRect` object represented an entire character,
    a pickup, or a bullet. For the non-rectangular shaped objects (zombies and the
    player), this was a little bit inaccurate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个 `FloatRect` 对象非常重要，需要讨论。在我们进行 *Zombie Arena* 游戏中的碰撞检测时，我们只是简单地检查两个 `FloatRect`
    对象是否相交。每个 `FloatRect` 对象代表一个完整的角色、一个拾取物或一颗子弹。对于非矩形形状的对象（僵尸和玩家），这有点不准确。
- en: In this game, we will need to be more precise. The `m_Feet`, `m_Head`, `m_Right`,
     `m_Left`, and `FloatRect` objects will hold the coordinates of the different
    parts of a character's body. These coordinates will be updated each frame.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们需要更加精确。`m_Feet`、`m_Head`、`m_Right`、`m_Left` 和 `FloatRect` 对象将保存角色身体不同部分的坐标。这些坐标将每帧更新。
- en: Through these coordinates, we will be able to tell exactly when a character
    lands on a platform, bumps their head during a jump, or rubs shoulders with a
    tile to their side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些坐标，我们能够精确地判断一个角色何时落在平台上，在跳跃中撞到头，或者与旁边的砖块摩擦肩膀。
- en: Lastly, we have a `Texture`. The `Texture` is `private` as it is not used directly
    by the `Thomas` or `Bob` classes. However, as we saw, the `Sprite` is `protected`
    because it is used directly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个 `Texture`。`Texture` 是 `private` 的，因为它不是由 `Thomas` 或 `Bob` 类直接使用的。然而，正如我们所见，`Sprite`
    是 `protected` 的，因为它被直接使用。
- en: 'Now, add all the `public` functions to the `PlayableCharacter.h` file. Then,
    we will discuss them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有 `public` 函数添加到 `PlayableCharacter.h` 文件中。然后，我们将讨论它们：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s talk about each of the function declarations that we just added. This
    will make coding their definitions easier to follow:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们刚刚添加的每个函数声明。这将使编写它们的定义更容易理解：
- en: The `spawn` function receives a `Vector2f` called `startPosition` and a `float`
    value called `gravity`. As the names suggest, `startPosition` will be the coordinates
    in the level that the character will start, and `gravity` will be the number of
    pixels per second at which the character will fall.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn` 函数接收一个名为 `startPosition` 的 `Vector2f` 和一个名为 `gravity` 的 `float` 值。正如其名称所暗示的，`startPosition`
    将是角色在关卡中开始的位置坐标，而 `gravity` 将是角色下落的每秒像素数。'
- en: '`bool virtual handleInput() = 0` is, of course our pure virtual function. Since
    `PlayableCharacter` has this function, any class that extends it, if we want to
    instantiate it, must provide a definition for this function. Therefore, when we
    write all the function definitions for `PlayableCharacter` in a minute, we will
    not provide a definition for `handleInput`. There will need to be definitions
    in both the `Thomas` and `Bob` classes.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool virtual handleInput() = 0`当然是我们纯虚函数。由于`PlayableCharacter`有这个函数，任何扩展它的类，如果我们想实例化它，都必须为这个函数提供定义。因此，当我们在一分钟内编写`PlayableCharacter`的所有函数定义时，我们不会为`handleInput`提供定义。`Thomas`和`Bob`类中都需要有定义。'
- en: The `getPosition` function returns a `FloatRect` object that represents the
    position of the whole character.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPosition`函数返回一个`FloatRect`对象，表示整个角色的位置。'
- en: The `getFeet()` function, as well as `getHead`, `getRight`, and `getLeft`, return
    a `FloatRect` object that represents the location of a specific part of the character's
    body. This is just what we need for detailed collision detection.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFeet`函数，以及`getHead`、`getRight`和`getLeft`，返回一个`FloatRect`对象，表示角色身体特定部分的位置。这正是我们进行详细碰撞检测所需要的。'
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite` to the calling
    code.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSprite`函数像往常一样，返回`m_Sprite`的副本给调用代码。'
- en: The `stopFalling`, `stopRight`, `stopLeft`, and `stopJump` functions receive
    a single `float` value that the function will use to reposition the character
    and stop it walking or jumping through a solid tile.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopFalling`、`stopRight`、`stopLeft`和`stopJump`函数接收一个单个的`float`值，该值将被函数用来重新定位角色并停止它穿过固体地砖行走或跳跃。'
- en: The `getCenter` function returns a `Vector2f` object to the calling code to
    let it know exactly where the center of the character is. This value is held in
    `m_Position`. As we will see later, it is used by the `Engine` class to center
    the appropriate `View` around the appropriate character.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCenter`函数返回一个`Vector2f`对象给调用代码，让它知道角色的确切中心位置。这个值存储在`m_Position`中。正如我们稍后将会看到的，它被`Engine`类用来围绕适当的角色中心化适当的`View`。'
- en: We have seen the `update` function many times before and, as usual, it takes
    a `float` parameter, which is the fraction of a second the current frame has taken.
    This `update` function will need to do more work than previous `update` functions
    (from our other projects), however. It will need to handle jumping as well as
    updating the `FloatRect` objects that represent the head, feet, and left- and
    right-hand sides of the character.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前已经多次看到`update`函数，并且像往常一样，它接受一个`float`参数，即当前帧所花费的秒数的分数。然而，这个`update`函数需要比我们其他项目中的`update`函数（from
    our other projects）做更多的工作。它需要处理跳跃以及更新表示角色头部、脚部和左右手的`FloatRect`对象。
- en: Now, we can write the definitions for all the functions, except, of course,
    `handleInput`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写所有函数的定义，当然，除了`handleInput`函数。
- en: Coding PlayableCharacter.cpp
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`PlayableCharacter.cpp`
- en: Right-click `PlayableCharacter.cpp`. Finally, click the `.cpp` file for the
    `PlayableCharacter` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`PlayableCharacter.cpp`。最后，点击`PlayableCharacter`类的`.cpp`文件。
- en: 'We will break up the code and discuss it in several chunks. First, add the
    include directives and the definition of the `spawn` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把代码分成几个部分来讨论。首先，添加包含指令和`spawn`函数的定义：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `spawn` function initializes `m_Position` with the passed-in position, and
    also initializes `m_Gravity`. The final line of code moves `m_Sprite` to its starting
    position.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`函数使用传入的位置初始化`m_Position`，并初始化`m_Gravity`。代码的最后一行将`m_Sprite`移动到其起始位置。'
- en: 'Next, add the definition for the `update` function immediately after the previous
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在之前的代码之后立即添加`update`函数的定义：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two parts of the code check whether `m_RightPressed` or `m_LeftPressed`
    is `true`. If either of them is, then `m_Position` is changed using the same formula
    as the previous project (elapsed time multiplied by speed).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前两部分检查`m_RightPressed`或`m_LeftPressed`是否为`true`。如果其中任何一个为真，则使用与上一个项目相同的公式（经过时间乘以速度）更改`m_Position`。
- en: 'Next, we see whether the character is currently executing a jump. We know this
    from `if(m_IsJumping)`. If this `if` statement is `true`, these are the steps
    the code takes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到角色是否正在执行跳跃。我们可以从`if(m_IsJumping)`中知道这一点。如果这个`if`语句为真，代码将采取以下步骤：
- en: Updates `m_TimeThisJump` with `elapsedTime`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`elapsedTime`更新`m_TimeThisJump`。
- en: Checks if `m_TimeThisJump` is still less than `m_JumpDuration`. If it is, it
    changes the y coordinate of `m_Position` by 2x gravity, multiplied by the elapsed
    time.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `m_TimeThisJump` 是否仍然小于 `m_JumpDuration`。如果是，它将 `m_Position` 的 y 坐标通过 2 倍重力乘以经过的时间来改变。
- en: In the `else` clause that executes when `m_TimeThisJump` is not lower than `m_JumpDuration`,
    `m_Falling` is set to `true`. The effect of doing this will be seen next. Also,
    `m_Jumping` is set to `false`. This prevents the code we have just been discussing
    from executing, because `if(m_IsJumping)` is now false.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `m_TimeThisJump` 不低于 `m_JumpDuration` 时，`else` 子句会执行，将 `m_Falling` 设置为 `true`。这样做的影响将在下面看到。同时，`m_Jumping`
    被设置为 `false`。这防止了我们刚刚讨论的代码执行，因为 `if(m_IsJumping)` 现在是 `false`。
- en: The `if(m_IsFalling)` block moves `m_Position` down each frame. It is moved
    using the current value of `m_Gravity` and the elapsed time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(m_IsFalling)` 块在每一帧将 `m_Position` 向下移动。它是使用当前的 `m_Gravity` 值和经过的时间来移动的。'
- en: 'The code that follows (most of the remaining code) updates the "body parts"
    of the character, relative to the current position of the sprite as a whole. Take
    a look at the following diagram to see how the code calculates the position of
    the virtual head, feet, and left- and right-hand sides of the character:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码（剩余的大部分代码）更新角色的“身体部分”，相对于整个精灵的当前位置。请查看以下图表，以了解代码如何计算角色的虚拟头部、脚部和左右两侧的位置：
- en: '![](img/B14278_15_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_15_01.jpg)'
- en: The final line of code uses the `setPosition` function to move the sprite to
    its correct location after all the possibilities of the `update` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码使用 `setPosition` 函数在所有 `update` 函数的可能性之后将精灵移动到其正确的位置。
- en: 'Now, add the definitions for the `getPosition`, `getCenter`, `getFeet`, `getHead`,
    `getLeft`, `getRight`, and `getSprite` functions, immediately after the previous
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在之前的代码之后立即添加 `getPosition`、`getCenter`、`getFeet`、`getHead`、`getLeft`、`getRight`
    和 `getSprite` 函数的定义：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getPosition` function returns a `FloatRect` that wraps the entire sprite,
    while `getCenter` returns a `Vector2f` that contains the center of the sprite.
    Notice that we divide the height and width of the sprite by 2 in order to dynamically
    arrive at this result. This is because Thomas and Bob will be of different heights.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosition` 函数返回一个包裹整个精灵的 `FloatRect`，而 `getCenter` 返回一个包含精灵中心的 `Vector2f`。请注意，我们通过将精灵的高度和宽度除以
    2 来动态地得到这个结果。这是因为托马斯和鲍勃的身高会有所不同。'
- en: The `getFeet`, `getHead`, `getLeft`, and `getRight` functions return the `FloatRect`
    objects that represent the body parts of the character that we update each frame
    in the `update` function. We will write the collision detection code that uses
    these functions in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFeet`、`getHead`、`getLeft` 和 `getRight` 函数返回代表我们在 `update` 函数中每帧更新的角色身体部分的
    `FloatRect` 对象。我们将在下一章编写使用这些函数的碰撞检测代码。'
- en: The `getSprite` function, as usual, returns a copy of `m_Sprite`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSprite` 函数，像往常一样，返回 `m_Sprite` 的副本。'
- en: 'Finally, for the `PlayableCharacter` class, add the definitions for the `stopFalling`,
    `stopRight`, `stopLeft`, and `stopJump` functions. Do so immediately after the
    previous code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `PlayableCharacter` 类，在之前的代码之后立即添加 `stopFalling`、`stopRight`、`stopLeft`
    和 `stopJump` 函数的定义。这样做：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each of the previous functions receives a value as a parameter that is used
    to reposition either the top, bottom, left, or right of the sprite. Exactly what
    these values are and how they are obtained will be something for the next chapter.
    Each of the previous functions also repositions the sprite.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 之前每个函数都接收一个作为参数的值，用于重新定位精灵的顶部、底部、左侧或右侧。这些值具体是什么以及如何获得将是下一章的内容。之前每个函数也会重新定位精灵。
- en: The final function is the `stopJump` function, which will also be used in collision
    detection. It sets the necessary values for `m_IsJumping` and `m_IsFalling` to
    end a jump.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数是 `stopJump` 函数，它也将用于碰撞检测。它设置必要的 `m_IsJumping` 和 `m_IsFalling` 值以结束跳跃。
- en: Building the Thomas and Bob classes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建托马斯和鲍勃类
- en: Now, we get to use inheritance for real. We will build a class for Thomas and
    a class for Bob. They will both inherit from the `PlayableCharacter` class we
    just coded. They will then have all the functionality of the `PlayableCharacter`
    class, including direct access to its `protected` variables. We will also add
    the definition for the pure virtual function, `handleInput`. You will notice that
    the `handleInput` functions for `Thomas` and `Bob` will be different.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们真正开始使用继承。我们将为托马斯和鲍勃各创建一个类。它们都将从我们刚刚编写的`PlayableCharacter`类继承。它们将拥有`PlayableCharacter`类的所有功能，包括直接访问其`protected`变量。我们还将添加纯虚函数`handleInput`的定义。你会注意到，`Thomas`和`Bob`的`handleInput`函数将是不同的。
- en: Coding Thomas.h
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Thomas.h`
- en: Right-click `Thomas.h`. Finally, click the `Thomas` class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Thomas.h`。最后，点击`Thomas`类。
- en: 'Add the following code to the `Thomas.h` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Thomas.h`类中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code is very short and sweet. We can see that we have a constructor
    and that we are going to implement the pure virtual `handleInput` function. So,
    let's do that now.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常简短且清晰。我们可以看到我们有一个构造函数，并且将要实现纯虚函数`handleInput`。所以，我们现在就来做这件事。
- en: Coding Thomas.cpp
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Thomas.cpp`
- en: Right-click `Thomas.cpp`. Finally, click the `.cpp` file for the `Thomas` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Thomas.cpp`。最后，点击`Thomas`类的`.cpp`文件。
- en: 'Add the `Thomas` constructor to the `Thomas.cpp` file, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Thomas`构造函数添加到`Thomas.cpp`文件中，如下所示：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All we need to do is load the `thomas.png` graphic and set the duration of a
    jump (`m_JumpDuration`) to .`45` (nearly half a second).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是加载`thomas.png`图形，并将跳跃的持续时间(`m_JumpDuration`)设置为`.45`（几乎半秒）。
- en: 'Add the definition of the `handleInput` function as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下定义`handleInput`函数：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code should look quite familiar to you. We are using the SFML `isKeyPressed`
    function to see whether any of the *W*, *A*, or *D* keys are being pressed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对你来说应该很熟悉。我们正在使用SFML的`isKeyPressed`函数来检查*W*、*A*或*D*键是否被按下。
- en: When *W* is pressed, the player is attempting to jump. The code then uses the
    `if(!m_IsJumping && !m_IsFalling)` code to check that the character is not already
    jumping and that it is not falling either. When these tests are both true, `m_IsJumping`
    is set to `true`, `m_TimeThisJump` is set to 0, and `m_JustJumped` is set to `true`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下*W*键时，玩家正在尝试跳跃。然后代码使用`if(!m_IsJumping && !m_IsFalling)`来检查角色是否尚未跳跃，并且也没有在掉落。当这两个测试都为真时，`m_IsJumping`被设置为`true`，`m_TimeThisJump`被设置为0，`m_JustJumped`也被设置为`true`。
- en: When the previous two tests don't evaluate to `true`, the `else` clause is executed
    and `m_Jumping` is set to `false`, and `m_IsFalling` is set to true.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当前两个测试不评估为`true`时，执行`else`子句，并将`m_Jumping`设置为`false`，将`m_IsFalling`设置为`true`。
- en: Handling how the *A* and *D* keys are being pressed is as simple as setting
    `m_LeftPressed` and/or `m_RightPressed` to `true` or `false`. The `update` function
    will now be able to handle moving the character.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 处理*A*和*D*键的按下就像设置`m_LeftPressed`和/或`m_RightPressed`为`true`或`false`一样简单。`update`函数现在将能够处理角色的移动。
- en: The last line of code in the function returns the value of `m_JustJumped`. This
    will let the calling code know if it needs to play a jumping sound effect.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一行代码返回`m_JustJumped`的值。这将让调用代码知道是否需要播放跳跃音效。
- en: We will now code the `Bob` class. It is nearly identical to the `Thomas` class,
    except it has different jumping abilities and a different `Texture`, and uses
    different keys on the keyboard.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写`Bob`类。它与`Thomas`类几乎相同，除了它有不同的跳跃能力和不同的`Texture`，并且使用不同的键盘键。
- en: Coding Bob.h
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Bob.h`
- en: The `Bob` class is identical in structure to the `Thomas` class. It inherits
    from `PlayableCharacter`, it has a constructor, and it provides the definition
    of the `handleInput` function. The difference compared to `Thomas` is that we
    initialize some of Bob's member variables differently and we handle input (in
    the `handleInput` function) differently as well. Let's code the class and look
    at the details.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bob`类在结构上与`Thomas`类相同。它从`PlayableCharacter`继承，有一个构造函数，并提供了`handleInput`函数的定义。与`Thomas`相比的不同之处在于我们以不同的方式初始化Bob的一些成员变量，并且在`handleInput`函数中处理输入的方式也不同。让我们编写这个类并查看细节。'
- en: Right-click `Bob.h`. Finally, click the `Bob` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Bob.h`。最后，点击`Bob`类。
- en: 'Add the following code to the `Bob.h` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Bob.h`文件中：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code is identical to the `Thomas.h` file apart from the class name
    and therefore the constructor name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与`Thomas.h`文件相同，除了类名和因此构造函数名不同。
- en: Coding Bob.cpp
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Bob.cpp`
- en: Right-click `Bob.cpp`. Finally, click the `.cpp` file for the `Bob` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Bob.cpp`。最后，点击`Bob`类的`.cpp`文件。
- en: 'Add the following code for the `Bob` constructor to the `Bob.cpp` file. Notice
    that the texture is different (`bob.png`) and that `m_JumpDuration` is initialized
    to a significantly smaller value. Bob is now his own unique self:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Bob.cpp`文件的`Bob`构造函数中。注意纹理是不同的（`bob.png`），并且`m_JumpDuration`被初始化为一个显著较小的值。现在Bob是他自己的独特个体：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `handleInput` code immediately after the `Bob` constructor:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bob`构造函数之后立即添加`handleInput`代码：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the code is nearly identical to the code in the `handleInput` function
    of the `Thomas` class. The only difference is that we respond to different keys
    (the *Left* arrow key and *Right* arrow key for left and right movement, respectively,
    and the *Up* arrow key for jumping).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码几乎与`Thomas`类中的`handleInput`函数中的代码相同。唯一的区别是我们响应不同的键（分别用*左*箭头键和*右*箭头键来控制左右移动，以及用*上*箭头键来进行跳跃）。
- en: Now that we have a `PlayableCharacter` class that has been extended by the `Bob`
    and `Thomas` classes, we can add a `Bob` and a `Thomas` instance to the game.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`PlayableCharacter`类，它被`Bob`和`Thomas`类扩展，我们可以向游戏中添加一个`Bob`和`Thomas`实例。
- en: Updating the game engine to use Thomas and Bob
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将游戏引擎更新为使用Thomas和Bob
- en: In order to be able to run the game and see our new characters, we have to declare
    instances of them, call their `spawn` functions, update them each frame, and draw
    them each frame. Let's do that now.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行游戏并看到我们新的角色，我们必须声明它们的实例，调用它们的`spawn`函数，每帧更新它们，并每帧绘制它们。现在让我们这样做。
- en: Updating Engine.h to add an instance of Bob and Thomas
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Engine.h以添加Bob和Thomas的实例
- en: 'Open up the `Engine.h` file and add the following highlighted lines of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件并添加以下高亮显示的代码行：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we have an instance of both `Thomas` and `Bob` that are derived from `PlayableCharacter`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`Thomas`和`Bob`的实例，它们都是`PlayableCharacter`的派生类。
- en: Updating the input function to control Thomas and Bob
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新输入函数以控制Thomas和Bob
- en: 'Now, we will add the ability to control the two characters. This code will
    go in the input part of the code. Of course, for this project, we have a dedicated
    `input` function. Open `Input.cpp` and add the following highlighted code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加控制两个角色的能力。这段代码将放在代码的输入部分。当然，对于这个项目，我们有一个专门的`input`函数。打开`Input.cpp`并添加以下高亮显示的代码：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note how simple the previous code is: all the functionality is contained within
    the `Thomas` and `Bob` classes. All the code must do is add an include directive
    for each of the `Thomas` and `Bob` classes. Then, within the `input` function,
    the code just calls the pure virtual `handleInput` functions on `m_Thomas` and
    `m_Bob`. The reason we wrap each of the calls in an `if` statement is that they
    return `true` or `false` based on whether a new jump has just been successfully
    initiated. We will handle playing the jump sound effects in [*Chapter 17*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340),
    *Sound Spatialization and the HUD*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的代码是多么简单：所有功能都包含在`Thomas`和`Bob`类中。所有代码必须做的只是为每个`Thomas`和`Bob`类添加一个包含指令。然后，在`input`函数中，代码只是调用`m_Thomas`和`m_Bob`上的纯虚`handleInput`函数。我们之所以在每个调用中包裹一个`if`语句，是因为它们根据是否刚刚成功启动了一个新的跳跃而返回`true`或`false`。我们将在[*第17章*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340)中处理播放跳跃音效，*声音空间化和HUD*。
- en: Updating the update function to spawn and update the PlayableCharacter instances
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新更新函数以生成和更新可玩角色实例
- en: This is broken into two parts. First, we need to spawn Bob and Thomas at the
    start of a new level, and second, we need to update them (by calling their `update`
    functions) each frame.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这分为两个部分。首先，我们需要在新关卡开始时生成Bob和Thomas，其次，我们需要每帧更新它们（通过调用它们的`update`函数）。
- en: Spawning Thomas and Bob
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成Thomas和Bob
- en: 'We need to call the `spawn` functions of our `Thomas` and `Bob` objects in
    a few different places as the project progresses. Most obviously, we need to spawn
    the two characters when a new level begins. In the next chapter, as the number
    of tasks we need to perform at the beginning of a level increases, we will write
    a `loadLevel` function. For now, let''s just call `spawn` on `m_Thomas` and `m_Bob`
    in the `update` function, as highlighted in the following code. Add the following
    code, but keep in mind that it will eventually be deleted and replaced:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的进展，我们需要在几个不同的地方调用我们的`Thomas`和`Bob`对象的`spawn`函数。最明显的是，当新关卡开始时，我们需要生成两个角色。在下一章中，随着我们需要在关卡开始时执行的任务数量增加，我们将编写一个`loadLevel`函数。现在，让我们在`update`函数中调用`m_Thomas`和`m_Bob`的`spawn`，如以下代码所示。添加以下代码，但请注意，它最终将被删除并替换：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code simply calls `spawn` and passes in a location in the game
    world, along with the gravity. The code is wrapped in an `if` statement that checks
    whether a new level is required. The spawning code will be moved to a dedicated
    `loadLevel` function, but the `if` condition will be part of the finished project.
    Also, `m_TimeRemaining` is set to an arbitrary 10 seconds for now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码简单地调用`spawn`并传入游戏世界中的一个位置，以及重力。代码被包裹在一个`if`语句中，该语句检查是否需要新的关卡。生成代码将被移动到一个专门的`loadLevel`函数中，但`if`条件将是最终项目的一部分。此外，`m_TimeRemaining`目前被设置为任意10秒。
- en: Now, we can update the instances each frame of the game loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新游戏循环中每一帧的实例。
- en: Updating Thomas and Bob each frame
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每帧更新托马斯和鲍勃
- en: Next, we will update Thomas and Bob. All we need to do is call their `update`
    functions and pass in the time this frame has taken.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新托马斯和鲍勃。我们只需要调用它们的`update`函数，并传入这一帧所花费的时间。
- en: 'Add the following highlighted code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that the characters can move, we need to update the appropriate `View` objects
    to center around the characters and make them the center of attention. Of course,
    until we have some objects in our game world, the sensation of actual movement
    will not be achieved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角色可以移动了，我们需要更新适当的`View`对象，使它们围绕角色中心，并成为关注的焦点。当然，在我们游戏世界中没有一些对象之前，实际的移动感是无法实现的。
- en: 'Add the following highlighted code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous code handles the two possible situations. First, the `if(mSplitScreen)`
    condition positions the left-hand view around `m_Thomas` and the right-hand view
    around `m_Bob`. The `else` clause that executes when the game is in full screen
    mode tests to see if `m_Character1` is `true`. If it is, then the full screen
    view (`m_MainView`) is centered around Thomas, otherwise it is centered around
    Bob. You probably remember that the player can use the *E* key to toggle split-screen
    mode and the *Q* key to toggle between Bob and Thomas in full screen mode. We
    coded this in the `input` function of the `Engine` class, back in [*Chapter 12*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272),
    *Layering Views and Implementing the HUD*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码处理了两种可能的情况。首先，`if(mSplitScreen)`条件将左侧视图定位在`m_Thomas`周围，右侧视图定位在`m_Bob`周围。当游戏处于全屏模式时，执行的`else`子句检查`m_Character1`是否为`true`。如果是，则全屏视图(`m_MainView`)将围绕托马斯居中，否则将围绕鲍勃居中。你可能记得，玩家可以使用*E*键切换分屏模式，使用*Q*键在全屏模式下在鲍勃和托马斯之间切换。我们在`Engine`类的`input`函数中实现了这一点，在[*第12章*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272)中，*分层视图和实现HUD*。
- en: Now, we can draw the graphics for Thomas and Bob to the screen.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将托马斯和鲍勃的图形绘制到屏幕上。
- en: Drawing Bob and Thomas
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制鲍勃和托马斯
- en: 'Make sure the `Draw.cpp` file is open and add the following highlighted code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保打开`Draw.cpp`文件并添加以下高亮代码：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that we draw both Thomas and Bob for full screen, the left, and the right.
    Also, notice the very subtle difference in the way that we draw the characters
    in split-screen mode. When drawing the left-hand side of the screen, we switch
    the order the characters are drawn and draw Thomas after Bob. So, Thomas will
    always be "on top" on the left and Bob will always be on top on the right. This
    is because the player controlling Thomas is catered for on the left and Bob the
    right, respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们以全屏、左侧和右侧的方式绘制托马斯和鲍勃。还要注意我们在分屏模式下绘制角色的细微差别。当绘制屏幕的左侧时，我们改变绘制角色的顺序，并在鲍勃之后绘制托马斯。因此，托马斯将始终在左侧“位于上方”，鲍勃将始终在右侧“位于上方”。这是因为控制托马斯的玩家在左侧，而鲍勃在右侧。我们可能在`Engine`类的`input`函数中编码了这一点，在[*第12章*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272)中，*分层视图和实现HUD*。
- en: 'You can now run the game and see Thomas and Bob in the center of the screen,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，看到托马斯和鲍勃位于屏幕中心，如下所示：
- en: '![](img/B14278_15_01b.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_15_01b.jpg)'
- en: If you press the *Q* key to switch focus from Thomas to Bob, you will see the
    `View` make the slight adjustment. If you move either of the characters left or
    right (Thomas with *A* and *D*, and Bob with the arrow keys) you will see them
    move relative to each other.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下*Q*键将焦点从托马斯切换到鲍勃，你会看到`视图`进行轻微调整。如果你将任意一个角色向左或向右移动（托马斯使用*A*和*D*键，鲍勃使用箭头键），你会看到它们相对于彼此移动。
- en: 'Try pressing the *E* key to toggle between full screen and split-screen. Then,
    try moving both characters again to see the effect. In the following screenshot,
    you can see that Thomas is always centered in the left-hand window and Bob is
    always centered in the right-hand window:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按下*E*键在全屏和分屏之间切换。然后，再次尝试移动两个角色以查看效果。在下面的屏幕截图，你可以看到托马斯始终位于左侧窗口的中心，鲍勃始终位于右侧窗口的中心：
- en: '![](img/B14278_15_02.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_15_02.jpg)'
- en: If you leave the game running long enough, the characters will respawn in their
    original positions every 10 seconds. This is the beginning of the functionality
    we will need for the finished game. This behavior is caused by `m_TimeRemaining`
    going below 0 and then setting the `m_NewLevelRequired` variable to `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让游戏运行足够长的时间，角色将在每10秒后在其原始位置重生。这是我们为完成的游戏所需功能的开端。这种行为是由`m_TimeRemaining`低于0然后设置`m_NewLevelRequired`变量为`true`引起的。
- en: Also note that we can't see the full effect of movement until we draw the details
    of the level. In fact, although it can't be seen, both characters are continuously
    falling at 300 pixels per second. Since the camera is centering around them every
    frame and there are no other objects in the game world, we cannot see this downward
    movement.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，直到我们绘制出关卡细节，我们才能看到移动的完整效果。实际上，尽管看不见，两个角色都以每秒300像素的速度持续下落。由于摄像机每帧都围绕它们居中，且游戏世界中没有其他对象，所以我们看不到这种向下移动。
- en: 'If you want to see this for yourself, just change the call to `m_Bob.spawn`,
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自看看，只需将`m_Bob.spawn`的调用更改如下：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that Bob has no gravitational effect, Thomas will visibly fall away from
    him. This is shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鲍勃没有重力影响，托马斯将明显从他身边落下。这在上面的屏幕截图中显示：
- en: '![](img/B14278_15_03.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_15_03.jpg)'
- en: We will add some playable levels to interact with in the next chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加一些可玩关卡以供交互。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about some new C++ concepts, such as inheritance,
    which allows us to extend a class and gain all its functionality. We also learned
    that we can declare variables as protected and that this will give the child class
    access to them, but they will still be encapsulated (hidden) from all other code.
    We also used pure virtual functions, which make a class abstract, meaning that
    the class cannot be instantiated and must therefore be inherited from/extended.
    We were also introduced to the concept of polymorphism, but will need to wait
    until the next chapter to use it in our game.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于C++的一些新概念，例如继承，这允许我们扩展一个类并获取其所有功能。我们还了解到我们可以声明变量为受保护的，这将使子类能够访问它们，但它们仍然对所有其他代码隐藏（封装）。我们还使用了纯虚函数，这使得类成为抽象的，意味着该类不能被实例化，因此必须从它继承或扩展。我们还介绍了多态的概念，但需要等到下一章才能在我们的游戏中使用它。
- en: In the next chapter, we will add some major functionality to the game. By the
    end of the next chapter, Thomas and Bob will be walking, jumping, and falling.
    They will even be able to jump on each other's heads, as well as exploring some
    level designs that have been loaded from a text file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向游戏中添加一些主要功能。到下一章结束时，托马斯和鲍勃将能够行走、跳跃和下落。他们甚至能够跳到彼此的头上，以及探索从文本文件中加载的一些关卡设计。
- en: FAQ
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) We learned about Polymorphism, but why didn't I notice anything polymorphic
    in the game code so far?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我们学习了多态，但为什么我没有在游戏代码中注意到任何多态的东西呢？
- en: A) We will see polymorphism in action in the next chapter when we write a function
    that takes `PlayerCharacter` as a parameter. We will see how we can pass both
    Bob and Thomas to this new function. It will work the same with both of them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: A) 在下一章中，当我们编写一个以`PlayerCharacter`为参数的函数时，我们将看到多态的实际应用。我们将看到如何将鲍勃和托马斯传递给这个新函数。对两者都适用。
