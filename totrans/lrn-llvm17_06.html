<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor068"/>4</h1>&#13;
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Basics of IR Code Generation</h1>&#13;
			<p>Having created a decorated <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) for your programming language, the next task is to generate<a id="_idIndexMarker211"/> the LLVM IR code from it. LLVM IR code resembles a three-address code with a human-readable representation. Therefore, we need a systematic approach to translate language concepts such as control structures into the lower level of LLVM IR.</p>&#13;
			<p>In this chapter, you will learn about the basics of LLVM IR and how to generate IR for control flow structures<a id="_idIndexMarker212"/> from the AST. You will also learn how to generate LLVM IR for expressions in <strong class="bold">static single assignment</strong> (<strong class="bold">SSA</strong>) form using a modern algorithm. Finally, you will learn how to emit assembler text and object code.</p>&#13;
			<p>This chapter will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Generating IR from the AST</li>&#13;
				<li>Using AST numbering to generate IR code in SSA form</li>&#13;
				<li>Setting up the module and the driver</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to create a code generator for your programming language and how to integrate it into your compiler.</p>&#13;
			<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Generating IR from the AST</h1>&#13;
			<p>The LLVM code generator<a id="_idIndexMarker213"/> takes a module in LLVM IR as input and turns<a id="_idIndexMarker214"/> it into object code or assembly text. We need to transform the AST representation into IR. To implement an IR code generator, we will look at a simple example first and then develop the classes needed for the code generator. The complete implementation will be divided into three classes:</p>&#13;
			<ul>&#13;
				<li><code>CodeGenerator</code></li>&#13;
				<li><code>CGModule</code></li>&#13;
				<li><code>CGProcedure</code></li>&#13;
			</ul>&#13;
			<p>The <code>CodeGenerator</code> class is the general interface used by the compiler driver. The <code>CGModule</code> and <code>CGProcedure</code> classes hold the state required<a id="_idIndexMarker215"/> for generating the IR code for a compilation<a id="_idIndexMarker216"/> unit and a single function.</p>&#13;
			<p>We’ll begin by looking at the Clang-generated IR.</p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Understanding the IR code</h2>&#13;
			<p>Before generating the IR code, it’s good to know the main elements<a id="_idIndexMarker217"/> of the IR language. In <a href="B19561_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">The Structure of a Compiler</em>, we had a brief look at IR. An easy way to get more knowledge of IR is to study the output from <code>clang</code>. For example, save this C source code, which implements the Euclidean algorithm for calculating the greatest common divisor of two numbers, as <code>gcd.c</code>:</p>&#13;
			<pre class="source-code">&#13;
unsigned gcd(unsigned a, unsigned b) {&#13;
  if (b == 0)&#13;
    return a;&#13;
  while (b != 0) {&#13;
    unsigned t = a % b;&#13;
    a = b;&#13;
    b = t;&#13;
  }&#13;
  return a;&#13;
}</pre>			<p>Then, you can create the <code>gcd.ll</code> IR file by using <code>clang</code> and the following command:</p>&#13;
			<pre class="console">&#13;
$ clang --target=aarch64-linux-gnu -O1 -S -emit-llvm gcd.c</pre>			<p>The IR code is not target-independent, even if it often looks like it is. The preceding command compiles the source file for an ARM 64-bit CPU on Linux. The <code>-S</code> option instructs <code>clang</code> to output an assembly file, and with the additional specification of <code>-emit-llvm</code>, an IR file is created. The optimization level, <code>-O1</code>, is used to get an easily readable IR code. Clang has many more options, all of which are documented<a id="_idIndexMarker218"/> in the command-line argument reference at <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">https://clang.llvm.org/docs/ClangCommandLineReference.html</a>. Let’s have a look at the generated file and understand how the C source maps to the LLVM IR.</p>&#13;
			<p>A C file is translated into a <code>i</code>, followed by the number of bits. For example, the 64-bit integer type is written as <code>i64</code>. The most basic float types are <code>float</code> and <code>double</code>, denoting the 32-bit and 64-bit IEEE floating-point types. It is also possible to create aggregate types such as vectors, arrays, and structures.</p>&#13;
			<p>Here is what the LLVM IR<a id="_idIndexMarker221"/> looks like. At the top of the file, some basic properties are established:</p>&#13;
			<pre class="source-code">&#13;
; ModuleID = 'gcd.c'&#13;
source_filename = "gcd.c"&#13;
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"&#13;
target triple = "aarch64-unknown-linux-gnu"</pre>			<p>The first line is a comment informing you about which module identifier was used. In the following line, the filename of the source file is named. With <code>clang</code>, both are the same.</p>&#13;
			<p>The <code>target datalayout</code> string establishes some basic properties. The different parts are separated by <code>-</code>. The following information is included:</p>&#13;
			<ul>&#13;
				<li> A small <code>e</code> means that bytes in memory are stored using the little-endian schema. To specify a big endian, you must use a big <code>E</code>.</li>&#13;
				<li><code>M:</code> specifies the name mangling that’s applied to symbols. Here, <code>m:e</code> means that ELF name mangling is used.</li>&#13;
				<li>The entries in <code>iN:A:P</code> form, such as<code>i8:8:32</code>, specify the alignment of data, given in bits. The first number is the alignment required by the ABI, and the second number is the preferred alignment. For bytes (<code>i8</code>), the ABI alignment is 1 byte (<code>8</code>) and the preferred alignment is 4 bytes (<code>32</code>).</li>&#13;
				<li><code>n</code> specifies which native register sizes are available. <code>n32:64</code> means that 32-bit and 64-bit wide integers are natively supported.</li>&#13;
				<li><code>S</code> specifies the alignment of the stack, again in bits. <code>S128</code> means that the stack maintains a 16-byte alignment.</li>&#13;
			</ul>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The provided target data layout must match what the backend expects. Its purpose is to communicate the captured information to the target-independent optimization passes. For example, an optimization pass can query the data layout to get the size and alignment of a pointer. However, changing the size of a pointer in the data layout does not change the code generation in the backend.</p>&#13;
			<p class="callout">A lot more information is provided<a id="_idIndexMarker222"/> with the target data layout. You can find more information in the reference manual at <a href="https://llvm.org/docs/LangRef.html#data-layout">https://llvm.org/docs/LangRef.html#data-layout</a>.</p>&#13;
			<p>Last, the <code>target triple</code> string specifies the architecture<a id="_idIndexMarker223"/> we are compiling for. This reflects the information we gave on the command line. The triple is a configuration string that usually consists of the CPU architecture, the vendor, and the operating system. More information about the environment is often added. For example, the <code>x86_64-pc-win32</code> triple is used for a Windows system running on a 64-bit X86 CPU. <code>x86_64</code> is the CPU architecture, <code>pc</code> is a generic vendor, and <code>win32</code> is the operating system. The parts are connected by a hyphen. A Linux system running on an ARMv8 CPU uses <code>aarch64-unknown-linux-gnu</code> as its triple. <code>aarch64</code> is the CPU architecture, while the operating system is <code>linux</code> running a <code>gnu</code> environment. There is no real vendor for a Linux-based system, so this part is <code>unknown</code>. Parts that are not known or unimportant for a specific purpose are often omitted: the <code>aarch64-linux-gnu</code> triple describes the same Linux system.</p>&#13;
			<p>Next, the <code>gcd</code> function is defined in the IR file:</p>&#13;
			<pre class="source-code">&#13;
define i32 @gcd(i32 %a, i32 %b) {</pre>			<p>This resembles the function signature in the C file. The <code>unsigned</code> data type is translated into the 32-bit integer type, <code>i32</code>. The function name is prefixed with <code>@</code>, and the parameter names are prefixed with <code>%</code>. The body of the function is enclosed in curly braces. The code of the body follows:</p>&#13;
			<pre class="source-code">&#13;
entry:&#13;
  %cmp = icmp eq i32 %b, 0&#13;
  br i1 %cmp, label %return, label %while.body</pre>			<p>The IR code is organized into so-called <code>entry</code>. The code in the block is simple: the first instruction compares the <code>%b</code> parameter against <code>0</code>. The second instruction branches to the <code>return</code> label if the condition is <code>true</code> and to the <code>while.body</code> label if the condition is <code>false</code>.</p>&#13;
			<p>Another characteristic of the IR code is that it is in a <code>%cmp</code>. This register is then used, but it is never written again. Optimizations such as constant propagation and common-sub-expression elimination work very well with the SSA form and all modern compilers are using it.</p>&#13;
			<p class="callout-heading">SSA</p>&#13;
			<p class="callout">The SSA form was developed<a id="_idIndexMarker227"/> in the late 1980s. Since then, it has been widely used in compilers because it simplifies data flow analysis and optimizations. For example, the identification of common sub-expressions inside a loop becomes much easier if the IR is in SSA form. A basic property of SSA is that it establishes <code>def-use</code> and <code>use-def</code> chains: for a single definition, you know of all uses (<code>def-use</code>), and for each use, you know the unique definition (<code>use-def</code>). This knowledge is used a lot, such as in constant propagation: if a definition is determined to be a constant, then all uses of this value can be easily replaced with that constant value.</p>&#13;
			<p class="callout">To construct the SSA form, the algorithm from Cytron et al. (1989) is very popular, and it is also used in the LLVM implementation. Other algorithms have been developed too. An early observation is that these algorithms become simpler if the source language does not have a <code>goto</code> statement.</p>&#13;
			<p class="callout">An in-depth treatment<a id="_idIndexMarker228"/> of SSA can be found in the book <em class="italic">SSA-based Compiler Design</em>, by F. Rastello and F. B. Tichadou, Springer 2022.</p>&#13;
			<p>The next basic block<a id="_idIndexMarker229"/> is the body of the <code>while</code> loop:</p>&#13;
			<pre class="source-code">&#13;
while.body:&#13;
  %b.loop = phi i32 [ %rem, %while.body ],&#13;
                       [ %b, %entry ]&#13;
  %a.loop = phi i32 [ %b.loop, %while.body ],&#13;
                       [ %a, %entry ]&#13;
  %rem = urem i32 %a.loop, %b.loop&#13;
  %cmp1 = icmp eq i32 %rem, 0&#13;
  br i1 %cmp1, label %return, label %while.body</pre>			<p>Inside the loop of <code>gcd</code>, the <code>a</code> and <code>b</code> parameters are assigned new values. If a register can be only written once, then this is not possible. The solution is to use the special <code>phi</code> instruction. The <code>phi</code> instruction has a list of basic blocks and values as parameters. A basic block presents the incoming edge from that basic block, and the value is the value from that basic block. At runtime, the <code>phi</code> instruction compares the label of the previously executed basic block with the labels in the parameter list.</p>&#13;
			<p>The value of the instruction is the value that’s associated with the label. For the first <code>phi</code> instruction, the value is the <code>%rem</code> register if the previously executed basic block was <code>while.body</code>. The value is <code>%b</code> if <code>entry</code> was the previously executed basic block. The values are the ones at the start of the basic block. The <code>%b.loop</code> register gets a value from the first <code>phi</code> instruction. The same register is used in the parameter list of the second <code>phi</code> instruction, but the value is assumed to be the one before it is changed through the first <code>phi</code> instruction.</p>&#13;
			<p>After the loop’s body, the return value must be chosen:</p>&#13;
			<pre class="source-code">&#13;
return:&#13;
  %retval = phi i32 [ %a, %entry ],&#13;
                    [ %b.loop, %while.body ]&#13;
  ret i32 %retval&#13;
}</pre>			<p>Again, a <code>phi</code> instruction is used to select the desired value. The <code>ret</code> instruction not only ends this basic block but also denotes the end of this function at runtime. It has the return value as a parameter.</p>&#13;
			<p>There are some restrictions on the use of <code>phi</code> instructions. They must be the first instructions of a basic block. The first basic block is special: it has no previously executed block. Therefore, it cannot begin with a <code>phi</code> instruction.</p>&#13;
			<p class="callout-heading">LLVM IR reference</p>&#13;
			<p class="callout">We’ve only touched<a id="_idIndexMarker230"/> the very basics of the LLVM IR. Please visit the LLVM Language Reference Manual at <a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a> to look up all the details.</p>&#13;
			<p>The IR code<a id="_idIndexMarker231"/> itself looks a lot like a mix of C and assembly language. Despite this familiar style, it is not clear how we can easily generate the IR code from an AST. The <code>phi</code> instruction in particular looks difficult to generate. But don’t be scared – in the next section, we’ll implement a simple algorithm to just do that!</p>&#13;
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Learning about the load-and-store approach</h2>&#13;
			<p>All local optimizations in LLVM<a id="_idIndexMarker232"/> are based on the SSA form shown here. For global variables, memory references are used. The IR language knows load and store instructions, which are used to fetch and store those values. You can use this for local variables too. These instructions do not belong to the SSA form, and LLVM knows how to convert them into the required SSA form. Therefore, you can allocate memory slots for each local variable and use load and store instructions to change their value. All you need to remember is the pointer to the memory slot where a variable is stored. The <code>clang</code> compiler uses this approach.</p>&#13;
			<p>Let’s look at the IR code for load and store. Compile <code>gcd.c</code> again, but this time without enabling optimization:</p>&#13;
			<pre class="console">&#13;
$ clang --target=aarch64-linux-gnu -S -emit-llvm gcd.c</pre>			<p>The <code>gcd</code> function now looks different. This is the first basic block:</p>&#13;
			<pre class="source-code">&#13;
define i32 @gcd(i32, i32) {&#13;
  %3 = alloca i32, align 4&#13;
  %4 = alloca i32, align 4&#13;
  %5 = alloca i32, align 4&#13;
  %6 = alloca i32, align 4&#13;
  store i32 %0, ptr %4, align 4&#13;
  store i32 %1, ptr %5, align 4&#13;
  %7 = load i32, ptr %5, align 4&#13;
  %8 = icmp eq i32 %7, 0&#13;
  br i1 %8, label %9, label %11</pre>			<p>The IR code now relies on the automatic numbering of registers and labels. The names of the parameters are not specified. Implicitly, they are <code>%0</code> and <code>%1</code>. The basic block has no label, so <code>2</code> is assigned. The first few instructions allocate memory for the four 32-bit values. After that, the <code>%0</code> and <code>%1</code> parameters are stored in the memory slots pointed to by registers <code>%4</code> and <code>%5</code>. To compare <code>%1</code> to <code>0</code>, the value is explicitly loaded from the memory slot. With this approach, you do not need to use the <code>phi</code> instruction! Instead, you load a value from a memory slot, perform a calculation on it, and store the new value back in the memory slot. The next time you read the memory slot, you get the last computed value. All the other basic blocks for the <code>gcd</code> function follow this pattern.</p>&#13;
			<p>The advantage of using load and store instructions in this way is that it is fairly easy to generate the IR code. The disadvantage is that you generate a lot of IR instructions that LLVM will remove with the <code>mem2reg</code> pass in the very first optimization step, after converting the basic block into SSA<a id="_idIndexMarker233"/> form. Therefore, we generate the IR code in SSA form directly.</p>&#13;
			<p>We’ll start developing IR code generation by mapping the control flow to basic blocks.</p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Mapping the control flow to basic blocks</h2>&#13;
			<p>The conceptual idea<a id="_idIndexMarker234"/> of a basic block is that it is a <em class="italic">linear sequence of instructions</em> that are executed<a id="_idIndexMarker235"/> in that order. A basic block has exactly one entry at the beginning, and it ends with a terminator instruction, which is an instruction that transfers the control flow<a id="_idIndexMarker236"/> to another basic block, such as a branch instruction, a switch instruction, or a return instruction. See <a href="https://llvm.org/docs/LangRef.html#terminator-instructions">https://llvm.org/docs/LangRef.html#terminator-instructions</a> for a complete list of terminator instructions. A basic block can begin with <code>phi</code> instructions, but inside a basic block, neither <code>phi</code> nor branch instructions are allowed. In other words, you can only enter a basic block at the first<a id="_idIndexMarker237"/> instruction, and you can only leave a basic block at the last instruction, which is the terminator<a id="_idIndexMarker238"/> instruction. It is not possible to branch to an instruction inside a basic block or to branch to another basic block from the middle of a basic block. Please note that a simple function call with the <code>call</code> instruction can occur inside a basic block. Each basic block has exactly one label, marking the first instruction of the basic<a id="_idIndexMarker239"/> block. Labels are the targets of branch instructions. You can view branches as directed edges between two basic blocks, resulting in the <strong class="bold">control flow graph</strong> (<strong class="bold">CFG</strong>). A basic block can have <strong class="bold">predecessors</strong> and <strong class="bold">successors</strong>. The first basic block of a function<a id="_idIndexMarker240"/> is special in the sense<a id="_idIndexMarker241"/> that no predecessors are allowed.</p>&#13;
			<p>As a consequence of these restrictions, control statements of the source language, such as <code>WHILE</code> and <code>IF</code>, produce several basic blocks. Let’s look at the <code>WHILE</code> statement. The condition of the <code>WHILE</code> statement controls if the loop body or the next statement is executed. The condition must be generated in a basic block of its own because there are two predecessors:</p>&#13;
			<ul>&#13;
				<li>The basic block resulting from the statement before <code>WHILE</code></li>&#13;
				<li>The branch from the end of the loop body back to the condition</li>&#13;
			</ul>&#13;
			<p>There are also two successors:</p>&#13;
			<ul>&#13;
				<li>The beginning of the loop body</li>&#13;
				<li>The basic block resulting from the statement following <code>WHILE</code></li>&#13;
			</ul>&#13;
			<p>The loop body itself has at least one basic block:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B19561_04_1.jpg" alt="Figure 4.1 – The basic blocks of a WHILE statement" width="643" height="785"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The basic blocks of a WHILE statement</p>&#13;
			<p>The IR code generation follows this structure. We store a pointer to the current basic block in the <code>CGProcedure</code> class and use<a id="_idIndexMarker242"/> an instance of <code>llvm::IRBuilder&lt;&gt;</code> to insert instructions into the basic<a id="_idIndexMarker243"/> block. First, we create the basic blocks:</p>&#13;
			<pre class="source-code">&#13;
void emitStmt(WhileStatement *Stmt) {&#13;
  llvm::BasicBlock *WhileCondBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "while.cond", Fn);&#13;
  llvm::BasicBlock *WhileBodyBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "while.body", Fn);&#13;
  llvm::BasicBlock *AfterWhileBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "after.while", Fn);</pre>			<p>The <code>Fn</code> variable denotes the current function and <code>getLLVMCtx()</code> returns the LLVM context. Both are set later. We end the current basic block with a branch to the basic block, which will hold the condition:</p>&#13;
			<pre class="source-code">&#13;
  Builder.CreateBr(WhileCondBB);</pre>			<p>The basic block for the condition becomes the new current basic block. We generate the condition and end the block with a conditional branch:</p>&#13;
			<pre class="source-code">&#13;
  setCurr(WhileCondBB);&#13;
  llvm::Value *Cond = emitExpr(Stmt-&gt;getCond());&#13;
  Builder.CreateCondBr(Cond, WhileBodyBB, AfterWhileBB);</pre>			<p>Next, we generate the loop body. Finally, we add a branch back to the basic block of the condition:</p>&#13;
			<pre class="source-code">&#13;
  setCurr(WhileBodyBB);&#13;
  emit(Stmt-&gt;getWhileStmts());&#13;
  Builder.CreateBr(WhileCondBB);</pre>			<p>With that, we have generated the <code>WHILE</code> statement. Now that we’ve generated the <code>WhileCondBB</code> and <code>Curr</code> blocks, we can seal them:</p>&#13;
			<pre class="source-code">&#13;
  sealBlock(WhileCondBB);&#13;
  sealBlock(Curr);</pre>			<p>The empty basic block<a id="_idIndexMarker244"/> for statements following <code>WHILE</code> becomes the new current<a id="_idIndexMarker245"/> basic block:</p>&#13;
			<pre class="source-code">&#13;
  setCurr(AfterWhileBB);&#13;
}</pre>			<p>Following this schema, you can create an <code>emit()</code> method for each statement of the source language.</p>&#13;
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Using AST numbering to generate IR code in SSA form</h1>&#13;
			<p>To generate IR code in SSA form<a id="_idIndexMarker246"/> from the AST, we<a id="_idIndexMarker247"/> can use an approach called <strong class="bold">AST numbering</strong>. The basic idea is that for each basic<a id="_idIndexMarker248"/> block, we store the current value of local variables written in this basic block.</p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The implementation is based on the paper <em class="italic">Simple and Efficient Construction of Static Single Assignment Form</em>, by Braun et al., International Conference on CompilerConstruction 2013 (CC 2013), Springer (see http://individual.utoronto.ca/dfr/ece467/braun13.pdf). In its presented form, it only works for IR code that has a structured controlled flow. The paper also describes the necessary extensions if you need to support arbitrary control flow – for example, a <code>goto</code> statement.</p>&#13;
			<p>Although it is simple, we will still need several steps. We will introduce the required data structure first, and after that, we will learn how to read and write values local to a basic block. Then, we will handle values<a id="_idIndexMarker249"/> that are used in several basic<a id="_idIndexMarker250"/> blocks and conclude by optimizing the created <code>phi</code> instructions.</p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Defining the data structure to hold values</h2>&#13;
			<p>We use the <code>BasicBlockDef</code> struct to hold<a id="_idIndexMarker251"/> the information<a id="_idIndexMarker252"/> for a single block:</p>&#13;
			<pre class="source-code">&#13;
struct BasicBlockDef {&#13;
  llvm::DenseMap&lt;Decl *, llvm::TrackingVH&lt;llvm::Value&gt;&gt; Defs;&#13;
  // ...&#13;
};</pre>			<p>The <code>llvm::Value</code> LLVN class represents a value in SSA form. The <code>Value</code> class acts like a label on the result of a computation. It is created once, usually through an IR instruction, and then used. Various changes can occur during optimizations. For example, if the optimizer detects that the <code>%1</code> and <code>%2</code> values are always the same, then it can replace the use of <code>%2</code> with <code>%1</code>. This changes the label but not the computation.</p>&#13;
			<p>To be aware of such changes, we cannot use the <code>Value</code> class directly. Instead, we need a value handle. There are value handles with different functionality. To track replacement, we can use the <code>llvm::TrackingVH&lt;&gt;</code> class. As a result, the <code>Defs</code> member maps a declaration of the AST (a variable or a formal parameter) to its current value. Now, we need to store this information<a id="_idIndexMarker253"/> for each basic<a id="_idIndexMarker254"/> block:</p>&#13;
			<pre class="source-code">&#13;
llvm::DenseMap&lt;llvm::BasicBlock *, BasicBlockDef&gt; CurrentDef;</pre>			<p>With this data structure, we are now able to handle local values.</p>&#13;
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>Reading and writing values local to a basic block</h2>&#13;
			<p>To store the current<a id="_idIndexMarker255"/> value of a local variable<a id="_idIndexMarker256"/> in a basic block, we will create <a id="_idIndexMarker257"/>an entry<a id="_idIndexMarker258"/> in the maps:</p>&#13;
			<pre class="source-code">&#13;
void writeLocalVariable(llvm::BasicBlock *BB, Decl *Decl,&#13;
                        llvm::Value *Val) {&#13;
  CurrentDef[BB].Defs[Decl] = Val;&#13;
}</pre>			<p>The lookup of a variable’s value is a bit more complicated because the value might not be in the basic block. In this case, we need to extend the search to the predecessors using a possible recursive search:</p>&#13;
			<pre class="source-code">&#13;
llvm::Value *&#13;
readLocalVariable(llvm::BasicBlock *BB, Decl *Decl) {&#13;
  auto Val = CurrentDef[BB].Defs.find(Decl);&#13;
  if (Val != CurrentDef[BB].Defs.end())&#13;
    return Val-&gt;second;&#13;
  return readLocalVariableRecursive(BB, Decl);&#13;
}</pre>			<p>The real work is searching the predecessors, which we’ll implement in the next section.</p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>Searching the predecessor blocks for a value</h2>&#13;
			<p>If the current basic block we are looking<a id="_idIndexMarker259"/> at has only one predecessor, then we search<a id="_idIndexMarker260"/> there for the value of the variable. If the basic block has several predecessors, then we need to search for the value in all these blocks and combine the results. To illustrate this situation, you can look at the basic block with the condition of a <code>WHILE</code> statement from the previous section.</p>&#13;
			<p>This basic block has two predecessors – the one resulting from the statement before the <code>WHILE</code> statement and the one resulting from the branch for the end of the body of the <code>WHILE</code> loop. A variable that’s used in the condition should have some initial value and will most likely be changed in the body of the loop. So, we need to collect these definitions and create a <code>phi</code> instruction from it. The basic blocks that are created from the <code>WHILE</code> statement contain a cycle.</p>&#13;
			<p>Because we recursively search the predecessor blocks, we must break this cycle. To do so, we can use a simple trick: we can insert an empty <code>phi</code> instruction and record this as the current value of the variable. If we see this basic block again in our search, then we’ll see that the variable has a value that we can use. The search stops at this point. Once we’ve collected all the values, we must update the <code>phi</code> instruction.</p>&#13;
			<p>However, we will still face a problem. At the time of the lookup, not all predecessors of a basic block may be known. How can this happen? Look at the creation of the basic blocks for the <code>WHILE</code> statement. The IR for the condition of the loop is generated first. However, the branch from the end of the body that goes back to the basic block, which contains the condition, can only be added after the IR for the body is generated. This is because this basic block is not known earlier. If we need to read the value of a variable in the condition, then we are stuck, because not all predecessors are known.</p>&#13;
			<p>To solve this situation, we must do a little more:</p>&#13;
			<ol>&#13;
				<li>First, we must attach a <code>Sealed</code> flag to the basic block.</li>&#13;
				<li>Then, we must define a basic block as sealed if we know all the predecessors of the basic block. If the basic block is not sealed and we need to look up the value of the variable not yet defined in this basic block, then we must insert an empty <code>phi</code> instruction and use it as the value.</li>&#13;
				<li>We also need to remember this instruction. If the block is later sealed, then we need to update the instruction with the real values. To implement this, we must add two more members to <code>struct BasicBlockDef</code>: the <code>IncompletePhis</code> map, which records the <code>phi</code> instructions we need later to update, and the <code>Sealed</code> flag, which indicates if the basic block is sealed:<pre class="source-code">&#13;
llvm::DenseMap&lt;llvm::PHINode *, Decl *&gt; IncompletePhis;&#13;
unsigned Sealed : 1;</pre></li>				<li>Then, the method<a id="_idIndexMarker261"/> can be implemented, as discussed<a id="_idIndexMarker262"/> at the beginning of this section:<pre class="source-code">&#13;
llvm::Value *CGProcedure::readLocalVariableRecursive(&#13;
    llvm::BasicBlock *BB, Decl *Decl) {&#13;
  llvm::Value *Val = nullptr;&#13;
  if (!CurrentDef[BB].Sealed) {&#13;
    llvm::PHINode *Phi = addEmptyPhi(BB, Decl);&#13;
    CurrentDef[BB].IncompletePhis[Phi] = Decl;&#13;
    Val = Phi;&#13;
  } else if (auto *PredBB = BB-&gt;getSinglePredecessor()) {&#13;
    Val = readLocalVariable(PredBB, Decl);&#13;
  } else {&#13;
    llvm::PHINode *Phi = addEmptyPhi(BB, Decl);&#13;
    writeLocalVariable(BB, Decl, Phi);&#13;
    Val = addPhiOperands(BB, Decl, Phi);&#13;
  }&#13;
  writeLocalVariable(BB, Decl, Val);&#13;
  return Val;&#13;
}</pre></li>				<li>The <code>addEmptyPhi()</code> method inserts an empty <code>phi</code> instruction at the beginning of the basic block:<pre class="source-code">&#13;
llvm::PHINode *&#13;
CGProcedure::addEmptyPhi(llvm::BasicBlock *BB,&#13;
                         Decl *Decl) {&#13;
  return BB-&gt;empty()&#13;
             ? llvm::PHINode::Create(mapType(Decl), 0,&#13;
                                     "", BB)&#13;
             : llvm::PHINode::Create(mapType(Decl), 0,&#13;
                                     "", &amp;BB-&gt;front());&#13;
}</pre></li>				<li>To add the missing operands<a id="_idIndexMarker263"/> to the <code>phi</code> instruction, first, we must search<a id="_idIndexMarker264"/> all the predecessors of the basic block and add the operand pair value and basic block to the <code>phi</code> instruction. Then, we must try to optimize the instruction:<pre class="source-code">&#13;
llvm::Value *&#13;
CGProcedure::addPhiOperands(llvm::BasicBlock *BB,&#13;
                            Decl *Decl,&#13;
                            llvm::PHINode *Phi) {&#13;
  for (auto *PredBB : llvm::predecessors(BB))&#13;
    Phi-&gt;addIncoming(readLocalVariable(PredBB, Decl),&#13;
                     PredBB);&#13;
  return optimizePhi(Phi);&#13;
}</pre></li>			</ol>&#13;
			<p>This algorithm can generate<a id="_idIndexMarker265"/> unneeded <code>phi</code> instructions. One approach<a id="_idIndexMarker266"/> to optimize these will be implemented in the next section.</p>&#13;
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Optimizing the generated phi instructions</h2>&#13;
			<p>How can we optimize a <code>phi</code> instruction<a id="_idIndexMarker267"/> and why should we do it? Although the SSA form is advantageous for many optimizations, the <code>phi</code> instruction is often not interpreted by the algorithms and thus hinders the optimization in general. Therefore, the fewer <code>phi</code> instructions we generate, the better. Let’s take a closer look:</p>&#13;
			<ol>&#13;
				<li>If the instruction has only one operand or all operands have the same value, then we replace the instruction with this value. If the instruction has no operand, then we replace the instruction with the special <code>Undef</code> value. Only if the instruction has two or more distinct operands do we have to keep the instruction:<pre class="source-code">&#13;
llvm::Value *&#13;
CGProcedure::optimizePhi(llvm::PHINode *Phi) {&#13;
  llvm::Value *Same = nullptr;&#13;
  for (llvm::Value *V : Phi-&gt;incoming_values()) {&#13;
    if (V == Same || V == Phi)&#13;
      continue;&#13;
    if (Same &amp;&amp; V != Same)&#13;
      return Phi;&#13;
    Same = V;&#13;
  }&#13;
  if (Same == nullptr)&#13;
    Same = llvm::UndefValue::get(Phi-&gt;getType());</pre></li>				<li>Removing a <code>phi</code> instruction<a id="_idIndexMarker268"/> may lead to optimization opportunities in other <code>phi</code> instructions. Fortunately, LLVM keeps track of the users and the use of values (which is the <code>use-def</code> chain mentioned in the definition of SSA). We must search for all uses of the value in other <code>phi</code> instructions and try to optimize these instructions too:<pre class="source-code">&#13;
  llvm::SmallVector&lt;llvm::PHINode *, 8&gt; CandidatePhis;&#13;
  for (llvm::Use &amp;U : Phi-&gt;uses()) {&#13;
    if (auto *P =&#13;
            llvm::dyn_cast&lt;llvm::PHINode&gt;(U.getUser()))&#13;
      if (P != Phi)&#13;
        CandidatePhis.push_back(P);&#13;
  }&#13;
  Phi-&gt;replaceAllUsesWith(Same);&#13;
  Phi-&gt;eraseFromParent();&#13;
  for (auto *P : CandidatePhis)&#13;
    optimizePhi(P);&#13;
  return Same;&#13;
}</pre></li>			</ol>&#13;
			<p>If we want, we can improve this algorithm even further. Instead of always iterating the list of values for each <code>phi</code> instruction, we can pick and remember two distinct values. Then, in the <code>optimizePhi</code> function, we can check if these two values are still in the list of the <code>phi</code> instruction. If that is the case, then we know that there is nothing to optimize. But even without this optimization, this algorithm runs very fast, so we are not going to implement this now.</p>&#13;
			<p>We are almost done. The only thing<a id="_idIndexMarker269"/> we haven’t done is implement the operation to seal a basic block. We will do this in the next section.</p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Sealing a block</h2>&#13;
			<p>As soon as we know that all the predecessors of a block<a id="_idIndexMarker270"/> are known, we can seal the block. If the source language contains only structured statements such as <code>tinylang</code>, then it is easy to determine where a block can be sealed. Take another look at the basic blocks that are generated for the <code>WHILE</code> statement.</p>&#13;
			<p>The basic block that contains the condition can be sealed after the branch from the end of the body is added because this was the last missing predecessor. To seal a block, we can simply add the missing operands to the incomplete <code>phi</code> instructions and set the flag:</p>&#13;
			<pre class="source-code">&#13;
void CGProcedure::sealBlock(llvm::BasicBlock *BB) {&#13;
  for (auto PhiDecl : CurrentDef[BB].IncompletePhis) {&#13;
    addPhiOperands(BB, PhiDecl.second, PhiDecl.first);&#13;
  }&#13;
  CurrentDef[BB].IncompletePhis.clear();&#13;
  CurrentDef[BB].Sealed = true;&#13;
}</pre>			<p>With these methods, we are now ready to generate the IR code for expressions.</p>&#13;
			<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>Creating the IR code for expressions</h2>&#13;
			<p>In general, you translate<a id="_idIndexMarker271"/> expressions, as shown in <a href="B19561_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">The Structure of a Compiler</em>. The only interesting<a id="_idIndexMarker272"/> part is how to access variables. The previous section treated local variables, but there are other kinds of variables we can consider. Let’s discuss what we need to do:</p>&#13;
			<ul>&#13;
				<li>For a local variable of the procedure, we use the <code>readLocalVariable()</code> and <code>writeLocalVariable()</code> methods from the previous section.</li>&#13;
				<li>For a local variable in an enclosing procedure, we need a pointer to the frame of the enclosing procedure. This will be handled later in this chapter.</li>&#13;
				<li>For a global variable, we generate load and store instructions.</li>&#13;
				<li>For a formal parameter, we have to differentiate between passing by value and passing by reference (the <code>VAR</code> parameter in <code>tinylang</code>). A parameter that’s passed by value is treated as a local variable, and a parameter passed by reference is treated as a global variable.</li>&#13;
			</ul>&#13;
			<p>Putting it all together, we get the following code<a id="_idIndexMarker273"/> for reading a variable or formal<a id="_idIndexMarker274"/> parameter:</p>&#13;
			<pre class="source-code">&#13;
llvm::Value *CGProcedure::readVariable(llvm::BasicBlock *BB,&#13;
                                       Decl *D) {&#13;
  if (auto *V = llvm::dyn_cast&lt;VariableDeclaration&gt;(D)) {&#13;
    if (V-&gt;getEnclosingDecl() == Proc)&#13;
      return readLocalVariable(BB, D);&#13;
    else if (V-&gt;getEnclosingDecl() ==&#13;
             CGM.getModuleDeclaration()) {&#13;
      return Builder.CreateLoad(mapType(D),&#13;
                                CGM.getGlobal(D));&#13;
    } else&#13;
      llvm::report_fatal_error(&#13;
          "Nested procedures not yet supported");&#13;
  } else if (auto *FP =&#13;
                 llvm::dyn_cast&lt;FormalParameterDeclaration&gt;(&#13;
                     D)) {&#13;
    if (FP-&gt;isVar()) {&#13;
      return Builder.CreateLoad(mapType(FP, false),&#13;
                                FormalParams[FP]);&#13;
    } else&#13;
      return readLocalVariable(BB, D);&#13;
  } else&#13;
    llvm::report_fatal_error("Unsupported declaration");&#13;
}</pre>			<p>Writing to a variable or formal parameter is symmetrical – we just need to exchange the method to read with<a id="_idIndexMarker275"/> the one to write and use a <code>store</code> instruction<a id="_idIndexMarker276"/> instead of a <code>load</code> instruction.</p>&#13;
			<p>Next, these functions are applied while generating the IR code for the functions.</p>&#13;
			<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Emitting the IR code for a function</h2>&#13;
			<p>Most of the IR code<a id="_idIndexMarker277"/> will live in a function. A function in IR code resembles<a id="_idIndexMarker278"/> a function in C. It specifies in the name, the types of parameters, the return value, and other attributes. To call a function in a different compilation unit, you need to declare the function. This is similar to a prototype in C. If you add basic blocks to the function, then you define the function. We will do all this in the next few sections, but first, we will discuss the visibility of symbol names.</p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Controlling visibility with linkage and name mangling</h2>&#13;
			<p>Functions (and also global variables) have a linkage<a id="_idIndexMarker279"/> style attached. With the<a id="_idIndexMarker280"/> linkage style, we define the visibility<a id="_idIndexMarker281"/> of a symbol name and what should happen<a id="_idIndexMarker282"/> if more than one symbol has the same name. The most basic linkage styles are <code>private</code> and <code>external</code>. A symbol with <code>private</code> linkage is only visible in the current compilation unit, while a symbol with <code>external</code> linkage is globally available.</p>&#13;
			<p>For a language without a proper module concept, such as C, this is adequate. With modules, we need to do more. Let’s assume<a id="_idIndexMarker283"/> that we have a module called <code>Square</code> that provides<a id="_idIndexMarker284"/> a <code>Root()</code> function<a id="_idIndexMarker285"/> and a <code>Cube</code> module, which also provides a <code>Root()</code> function. If the functions<a id="_idIndexMarker286"/> are private, then there is no problem. The function gets the name <code>Root</code> and private linkage. The situation is different if the function is exported so that it can be called from other modules. Using the function name alone is not enough, because this name is not unique.</p>&#13;
			<p>The solution is to tweak the name to make it globally unique. This is called name <code>Square.Root</code> as the name looks like an obvious solution, but it may lead to problems with assemblers as the dot may have a special meaning. Instead of using a delimiter between the name components, we can get a similar effect by prefixing the name components with their length: <code>6Square4Root</code>. This is no legal identifier for LLVM, but we can fix this by prefixing the whole name with <code>_t</code> (with <code>t</code> for <code>tinylang</code>): <code>_t6Square4Root</code>. In this way, we can create unique names for exported symbols:</p>&#13;
			<pre class="source-code">&#13;
std::string CGModule::mangleName(Decl *D) {&#13;
  std::string Mangled("_t");&#13;
  llvm::SmallVector&lt;llvm::StringRef, 4&gt; List;&#13;
  for (; D; D = D-&gt;getEnclosingDecl())&#13;
    List.push_back(D-&gt;getName());&#13;
  while (!List.empty()) {&#13;
    llvm::StringRef Name = List.pop_back_val();&#13;
    Mangled.append(&#13;
        llvm::Twine(Name.size()).concat(Name).str());&#13;
  }&#13;
  return Mangled;&#13;
}</pre>			<p>If your source language supports type overloading, then you need to extend this scheme with type names. For example, to distinguish between the <code>int root(int)</code> and <code>double root(double)</code> C++ functions, the type of the parameter and the return value must be added to the function name.</p>&#13;
			<p>You also need to think about the length of the generated name since some linkers place restrictions on the length. With nested namespaces and classes in C++, the mangled names can be rather long. There, C++ defines<a id="_idIndexMarker288"/> a compression<a id="_idIndexMarker289"/> scheme to avoid<a id="_idIndexMarker290"/> repeating name components<a id="_idIndexMarker291"/> over and over again.</p>&#13;
			<p>Next, we’ll look at how to treat parameters.</p>&#13;
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Converting a type from an AST description into LLVM types</h2>&#13;
			<p>The parameters of a function<a id="_idIndexMarker292"/> also need some consideration. First, we need<a id="_idIndexMarker293"/> to map the types of the source language to an LLVM type. As <code>tinylang</code> currently has only two types, this is easy:</p>&#13;
			<pre class="source-code">&#13;
llvm::Type *CGModule::convertType(TypeDeclaration *Ty) {&#13;
  if (Ty-&gt;getName() == "INTEGER")&#13;
    return Int64Ty;&#13;
  if (Ty-&gt;getName() == "BOOLEAN")&#13;
    return Int1Ty;&#13;
  llvm::report_fatal_error("Unsupported type");&#13;
}</pre>			<p><code>Int64Ty</code>, <code>Int1Ty</code>, and <code>VoidTy</code> are class members that hold the type representation of the <code>i64</code>, <code>i1</code>, and <code>void</code> LLVM types.</p>&#13;
			<p>For a formal parameter passed by reference, this is not enough. The LLVM type of this parameter is a pointer. However, when we want to use the value of the formal parameter, we need to know the underlying type. This is controlled by the <code>HonorReference</code> flag, which has a default value of <code>true</code>. We generalize the function and take<a id="_idIndexMarker294"/> the formal parameter<a id="_idIndexMarker295"/> into account:</p>&#13;
			<pre class="source-code">&#13;
llvm::Type *CGProcedure::mapType(Decl *Decl,&#13;
                                 bool HonorReference) {&#13;
  if (auto *FP = llvm::dyn_cast&lt;FormalParameterDeclaration&gt;(&#13;
          Decl)) {&#13;
    if (FP-&gt;isVar() &amp;&amp; HonorReference)&#13;
      return llvm::PointerType::get(CGM.getLLVMCtx(),&#13;
                                    /*AddressSpace=*/0);&#13;
    return CGM.convertType(FP-&gt;getType());&#13;
  }&#13;
  if (auto *V = llvm::dyn_cast&lt;VariableDeclaration&gt;(Decl))&#13;
    return CGM.convertType(V-&gt;getType());&#13;
  return CGM.convertType(llvm::cast&lt;TypeDeclaration&gt;(Decl));&#13;
}</pre>			<p>With these helpers at hand, we can create the LLVM IR function.</p>&#13;
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Creating the LLVM IR function</h2>&#13;
			<p>To emit a function in LLVM IR, a function<a id="_idIndexMarker296"/> type is needed, which is similar to a prototype in C. Creating the function type involves mapping the types and then calling the factory method to create the function type:</p>&#13;
			<pre class="source-code">&#13;
llvm::FunctionType *CGProcedure::createFunctionType(&#13;
    ProcedureDeclaration *Proc) {&#13;
  llvm::Type *ResultTy = CGM.VoidTy;&#13;
  if (Proc-&gt;getRetType()) {&#13;
    ResultTy = mapType(Proc-&gt;getRetType());&#13;
  }&#13;
  auto FormalParams = Proc-&gt;getFormalParams();&#13;
  llvm::SmallVector&lt;llvm::Type *, 8&gt; ParamTypes;&#13;
  for (auto FP : FormalParams) {&#13;
    llvm::Type *Ty = mapType(FP);&#13;
    ParamTypes.push_back(Ty);&#13;
  }&#13;
  return llvm::FunctionType::get(ResultTy, ParamTypes,&#13;
                                 /*IsVarArgs=*/false);&#13;
}</pre>			<p>Based on the function type, we also create<a id="_idIndexMarker297"/> the LLVM function. This associates the function type with the linkage and the mangled name:</p>&#13;
			<pre class="source-code">&#13;
llvm::Function *&#13;
CGProcedure::createFunction(ProcedureDeclaration *Proc,&#13;
                            llvm::FunctionType *FTy) {&#13;
  llvm::Function *Fn = llvm::Function::Create(&#13;
      Fty, llvm::GlobalValue::ExternalLinkage,&#13;
      CGM.mangleName(Proc), CGM.getModule());</pre>			<p>The <code>getModule()</code> method returns the current LLVM module, which we’ll set up a bit later.</p>&#13;
			<p>With the function created, we can add some more information about it:</p>&#13;
			<ul>&#13;
				<li>First, we can give the parameter’s names. This makes the IR more readable.</li>&#13;
				<li>Second, we can add attributes to the function and to the parameters to specify some characteristics. As an example, we will do this for parameters passed by reference.</li>&#13;
			</ul>&#13;
			<p>At the LLVM level, these parameters are pointers. But from the source language design, these are very restricted pointers. Analogous to references in C++, we always need to specify a variable for a <code>VAR</code> parameter. So, by design, we know that this pointer will never be null and that it is always dereferenceable, meaning that we can read the value that’s being pointed to without risking<a id="_idIndexMarker298"/> a general protection fault. Also, by design, this pointer cannot be passed around – in particular, there are no copies of the pointer that outlive the call to the function. Therefore, the pointer is said to not be captured.</p>&#13;
			<p>The <code>llvm::AttributeBuilder</code> class is used to build the set of attributes for a formal parameter. To get the storage size of a parameter type, we can simply query the data layout object:</p>&#13;
			<pre class="source-code">&#13;
  for (auto [Idx, Arg] : llvm::enumerate(Fn-&gt;args())) {&#13;
    FormalParameterDeclaration *FP =&#13;
        Proc-&gt;getFormalParams()[Idx];&#13;
    if (FP-&gt;isVar()) {&#13;
      llvm::AttrBuilder Attr(CGM.getLLVMCtx());&#13;
      llvm::TypeSize Sz =&#13;
          CGM.getModule()-&gt;getDataLayout().getTypeStoreSize(&#13;
              CGM.convertType(FP-&gt;getType()));&#13;
      Attr.addDereferenceableAttr(Sz);&#13;
      Attr.addAttribute(llvm::Attribute::NoCapture);&#13;
      Arg.addAttrs(Attr);&#13;
    }&#13;
    Arg.setName(FP-&gt;getName());&#13;
  }&#13;
  return Fn;&#13;
}</pre>			<p>With that, we have created the IR function. In the next section, we’ll add the basic blocks of the function<a id="_idIndexMarker299"/> body to the function.</p>&#13;
			<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Emitting the function body</h2>&#13;
			<p>We are almost done with emitting<a id="_idIndexMarker300"/> the IR code for a function! We only need to put the pieces together to emit a function, including its body:</p>&#13;
			<ol>&#13;
				<li>Given a procedure declaration from <code>tinylang</code>, first, we will create the function type and the function:<pre class="source-code">&#13;
void CGProcedure::run(ProcedureDeclaration *Proc) {&#13;
  this-&gt;Proc = Proc;&#13;
  Fty = createFunctionType(Proc);&#13;
  Fn = createFunction(Proc, Fty);</pre></li>				<li>Next, we will create the first basic block<a id="_idIndexMarker301"/> of the function and make it the current one:<pre class="source-code">&#13;
  llvm::BasicBlock *BB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "entry", Fn);&#13;
  setCurr(BB);</pre></li>				<li>Then, we must step through all formal parameters. To handle VAR parameters correctly, we need to initialize the <code>FormalParams</code> member (used in <code>readVariable()</code>). In contrast to local variables, formal parameters have a value in the first basic block, so we must make these values known:<pre class="source-code">&#13;
  for (auto [Idx, Arg] : llvm::enumerate(Fn-&gt;args())) {&#13;
    FormalParameterDeclaration *FP =&#13;
        Proc-&gt;getFormalParams()[Idx];&#13;
    FormalParams[FP] = &amp;Arg;&#13;
    writeLocalVariable(Curr, FP, &amp;Arg);&#13;
  }</pre></li>				<li>After this setup, we can call the <code>emit()</code> method to start generating the IR code for statements:<pre class="source-code">&#13;
  auto Block = Proc-&gt;getStmts();&#13;
  emit(Proc-&gt;getStmts());</pre></li>				<li>The last block after generating the IR code may not be sealed yet, so we must call <code>sealBlock()</code> now. A procedure in <code>tinylang</code> may have an implicit return, so we must also check if the last basic block has a proper terminator, and add one if not:<pre class="source-code">&#13;
  if (!Curr-&gt;getTerminator()) {&#13;
    Builder.CreateRetVoid();&#13;
  }&#13;
  sealBlock(Curr);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we’ve finished generating<a id="_idIndexMarker302"/> IR code for functions. However, we still need to create the LLVM module, which holds all the IR code together. We’ll do this in the next section.</p>&#13;
			<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Setting up the module and the driver</h1>&#13;
			<p>We collect all the functions and global variables<a id="_idIndexMarker303"/> of a compilation unit in an LLVM<a id="_idIndexMarker304"/> module. To ease the IR generation process, we can wrap all the functions from the previous sections into a code generator class. To get a working compiler, we also need to define the target architecture for which we want to generate code, and also add the passes that emit the code. We will implement this in this and the next few chapters, starting with the code generator.</p>&#13;
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Wrapping all in the code generator</h2>&#13;
			<p>The IR module is the brace around all elements<a id="_idIndexMarker305"/> we generate for a compilation unit. At the global level, we iterate through the declarations at the module level, create global variables, and call the code generation for procedures. A global variable in <code>tinylang</code> is mapped to an instance of the <code>llvm::GobalValue</code> class. This mapping is saved in <code>Globals</code> and made available to the code generation for procedures:</p>&#13;
			<pre class="source-code">&#13;
void CGModule::run(ModuleDeclaration *Mod) {&#13;
  for (auto *Decl : Mod-&gt;getDecls()) {&#13;
    if (auto *Var =&#13;
            llvm::dyn_cast&lt;VariableDeclaration&gt;(Decl)) {&#13;
      // Create global variables&#13;
      auto *V = new llvm::GlobalVariable(&#13;
          *M, convertType(Var-&gt;getType()),&#13;
          /*isConstant=*/false,&#13;
          llvm::GlobalValue::PrivateLinkage, nullptr,&#13;
          mangleName(Var));&#13;
      Globals[Var] = V;&#13;
    } else if (auto *Proc =&#13;
                   llvm::dyn_cast&lt;ProcedureDeclaration&gt;(&#13;
                       Decl)) {&#13;
      CGProcedure CGP(*this);&#13;
      CGP.run(Proc);&#13;
    }&#13;
  }&#13;
}</pre>			<p>The module also holds the <code>LLVMContext</code> class and caches the most commonly used LLVM types. The latter ones need<a id="_idIndexMarker306"/> to be initialized, for example, for the 64-bit integer type:</p>&#13;
			<pre class="source-code">&#13;
Int64Ty = llvm::Type::getInt64Ty(getLLVMCtx());</pre>			<p>The <code>CodeGenerator</code> class initializes the LLVM IR module and calls the code generation for the module. Most importantly, this class must know for which target architecture we’d like to generate code. This information is passed in the <code>llvm::TargetMachine</code> class, which is set up in the driver:</p>&#13;
			<pre class="source-code">&#13;
std::unique_ptr&lt;llvm::Module&gt;&#13;
CodeGenerator::run(ModuleDeclaration *Mod,&#13;
                   std::string FileName) {&#13;
  std::unique_ptr&lt;llvm::Module&gt; M =&#13;
      std::make_unique&lt;llvm::Module&gt;(FileName, Ctx);&#13;
  M-&gt;setTargetTriple(TM-&gt;getTargetTriple().getTriple());&#13;
  M-&gt;setDataLayout(TM-&gt;createDataLayout());&#13;
  CGModule CGM(M.get());&#13;
  CGM.run(Mod);&#13;
  return M;&#13;
}</pre>			<p>For ease of use, we must also introduce a factory method for the code generator:</p>&#13;
			<pre class="source-code">&#13;
CodeGenerator *&#13;
CodeGenerator::create(llvm::LLVMContext &amp;Ctx,&#13;
                      llvm::TargetMachine *TM) {&#13;
  return new CodeGenerator(Ctx, TM);&#13;
}</pre>			<p>The <code>CodeGenerator</code> class provides a small interface<a id="_idIndexMarker307"/> to create IR code, which is ideal for use in the compiler driver. Before we integrate it, we need to implement the support for machine code generation.</p>&#13;
			<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Initializing the target machine class</h2>&#13;
			<p>Now, only the target machine<a id="_idIndexMarker308"/> is missing. With the target machine, we define the CPU architecture we’d like to generate code for. For each CPU, there are features available that can be used to influence the code generation process. For example, a newer CPU of a CPU architecture family can support vector instructions. With features, we can toggle the use of vector instructions on or off. To support setting all these options from the command line, LLVM provides some supporting code. In the <code>Driver</code> class, we can add the following <code>include</code> variable:</p>&#13;
			<pre class="source-code">&#13;
#include "llvm/CodeGen/CommandFlags.h"</pre>			<p>This <code>include</code> variable adds common command-line options to our compiler driver. Many LLVM tools also use these command-line options, which have the benefit of providing a common interface to the user. Only the option to specify a target triple is missing. As this is very useful, we’ll add this ourselves:</p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;std::string&gt; MTriple(&#13;
    "mtriple",&#13;
    llvm::cl::desc("Override target triple for module"));</pre>			<p>Let’s create the target machine:</p>&#13;
			<ol>&#13;
				<li>To display error<a id="_idIndexMarker309"/> messages, the name of the application must be passed to the function:<pre class="source-code">&#13;
llvm::TargetMachine *&#13;
createTargetMachine(const char *Argv0) {</pre></li>				<li>First, we must collect all the information provided by the command line. These are options for the code generator – that is, the name of the CPU and possible features that should be activated or deactivated, and the triple of the target:<pre class="source-code">&#13;
  llvm::Triple Triple = llvm::Triple(&#13;
      !MTriple.empty()&#13;
          ? llvm::Triple::normalize(MTriple)&#13;
          : llvm::sys::getDefaultTargetTriple());&#13;
  llvm::TargetOptions TargetOptions =&#13;
      codegen::InitTargetOptionsFromCodeGenFlags(Triple);&#13;
  std::string CPUStr = codegen::getCPUStr();&#13;
  std::string FeatureStr = codegen::getFeaturesStr();</pre></li>				<li>Then, we must look up the target<a id="_idIndexMarker310"/> in the target registry. If an error occurs, then we will display the error message and bail out. A possible error would be an unsupported triple specified by the user:<pre class="source-code">&#13;
  std::string Error;&#13;
  const llvm::Target *Target =&#13;
      llvm::TargetRegistry::lookupTarget(&#13;
          codegen::getMArch(), Triple, Error);&#13;
  if (!Target) {&#13;
    llvm::WithColor::error(llvm::errs(), Argv0) &lt;&lt; Error;&#13;
    return nullptr;&#13;
  }</pre></li>				<li>With the help of the <code>Target</code> class, we can configure the target machine using all the known options requested by the user:<pre class="source-code">&#13;
  llvm::TargetMachine *TM = Target-&gt;createTargetMachine(&#13;
      Triple.getTriple(), CPUStr, FeatureStr,&#13;
      TargetOptions, std::optional&lt;llvm::Reloc::Model&gt;(&#13;
          codegen::getRelocModel()));&#13;
  return TM;&#13;
}</pre></li>			</ol>&#13;
			<p>With the target machine instance, we can generate IR code that targets a CPU architecture of our choice. What is missing is the translation to assembly text or the generation of object<a id="_idIndexMarker311"/> code files. We’ll add this support in the next section.</p>&#13;
			<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/>Emitting assembler text and object code</h2>&#13;
			<p>In LLVM, the IR code<a id="_idIndexMarker312"/> is run through a pipeline of passes. Each pass performs a single task, such as removing<a id="_idIndexMarker313"/> dead code. We’ll learn more about passes in <a href="B19561_07.xhtml#_idTextAnchor117"><em class="italic">Chapter 7</em></a>, <em class="italic">Optimizing IR</em>. Outputting assembler code or an object file is implemented as a pass too. Let’s add basic support for it!</p>&#13;
			<p>We need to include even more LLVM header files. First, we need the <code>llvm::legacy::PassManager</code> class to hold the passes to emit code to a file. We also want to be able to output LLVM IR code, so we also need a pass to emit this. Finally, we’ll use the <code>llvm:: ToolOutputFile</code> class for the file operations:</p>&#13;
			<pre class="source-code">&#13;
#include "llvm/IR/IRPrintingPasses.h"&#13;
#include "llvm/IR/LegacyPassManager.h"&#13;
#include "llvm/MC/TargetRegistry.h"&#13;
#include "llvm/Pass.h"&#13;
#include "llvm/Support/ToolOutputFile.h"</pre>			<p>Another command-line option for outputting LLVM IR is also needed:</p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;bool&gt; EmitLLVM(&#13;
    "emit-llvm",&#13;
    llvm::cl::desc("Emit IR code instead of assembler"),&#13;
    llvm::cl::init(false));</pre>			<p>Finally, we want to be able to give the output file a name:</p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;std::string&gt;&#13;
    OutputFilename("o",&#13;
                   llvm::cl::desc("Output filename"),&#13;
                   llvm::cl::value_desc("filename"));</pre>			<p>The first task in the new <code>emit()</code> method is to deal with the name of the output file if it’s not given by the user on the command line. If the input is read from <code>stdin</code>, indicated by the use of the minus symbol, <code>-</code>, then we output the result to <code>stdout</code>. The <code>ToolOutputFile</code> class knows how to handle the special filename, <code>-</code>:</p>&#13;
			<pre class="source-code">&#13;
bool emit(StringRef Argv0, llvm::Module *M,&#13;
          llvm::TargetMachine *TM,&#13;
          StringRef InputFilename) {&#13;
  CodeGenFileType FileType = codegen::getFileType();&#13;
  if (OutputFilename.empty()) {&#13;
    if (InputFilename == "-") {&#13;
      OutputFilename = "-";&#13;
    }</pre>			<p>Otherwise, we drop a possible extension<a id="_idIndexMarker314"/> of the input filename and append <code>.ll</code>, <code>.s</code>, or <code>.o</code> as an extension, depending<a id="_idIndexMarker315"/> on the command-line options given by the user. The <code>FileType</code> option is defined in the <code>llvm/CodeGen/CommandFlags.inc</code> header file, which we included earlier. This option doesn’t support emitting IR code, so we’ve added the new<code>–emit-llvm</code> option, which only takes effect if it’s used together with the assembly file type:</p>&#13;
			<pre class="source-code">&#13;
    else {&#13;
      if (InputFilename.endswith(".mod"))&#13;
        OutputFilename =&#13;
            InputFilename.drop_back(4).str();&#13;
      else&#13;
        OutputFilename = InputFilename.str();&#13;
      switch (FileType) {&#13;
      case CGFT_AssemblyFile:&#13;
        OutputFilename.append(EmitLLVM ? ".ll" : ".s");&#13;
        break;&#13;
      case CGFT_ObjectFile:&#13;
        OutputFilename.append(".o");&#13;
        break;&#13;
      case CGFT_Null:&#13;
        OutputFilename.append(".null");&#13;
        break;&#13;
      }&#13;
    }&#13;
  }</pre>			<p>Some platforms distinguish<a id="_idIndexMarker316"/> between text and binary files, so we have to provide <a id="_idIndexMarker317"/>the right open flags when opening the output file:</p>&#13;
			<pre class="source-code">&#13;
  std::error_code EC;&#13;
  sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;&#13;
  if (FileType == CGFT_AssemblyFile)&#13;
    OpenFlags |= sys::fs::OF_TextWithCRLF;&#13;
  auto Out = std::make_unique&lt;llvm::ToolOutputFile&gt;(&#13;
      OutputFilename, EC, OpenFlags);&#13;
  if (EC) {&#13;
    WithColor::error(llvm::errs(), Argv0)&#13;
        &lt;&lt; EC.message() &lt;&lt; '\n';&#13;
    return false;&#13;
  }</pre>			<p>Now, we can add the required passes to <code>PassManager</code>. The <code>TargetMachine</code> class has a utility method that adds the requested classes. Therefore, we only need to check if the user requests to output the LLVM IR code:</p>&#13;
			<pre class="source-code">&#13;
  legacy::PassManager PM;&#13;
  if (FileType == CGFT_AssemblyFile &amp;&amp; EmitLLVM) {&#13;
    PM.add(createPrintModulePass(Out-&gt;os()));&#13;
  } else {&#13;
    if (TM-&gt;addPassesToEmitFile(PM, Out-&gt;os(), nullptr,&#13;
                                FileType)) {&#13;
      WithColor::error(llvm::errs(), Argv0)&#13;
          &lt;&lt; "No support for file type\n";&#13;
      return false;&#13;
    }&#13;
  }</pre>			<p>With all this preparation done, emitting the file boils down to a single function call:</p>&#13;
			<pre class="source-code">&#13;
  PM.run(*M);</pre>			<p>The <code>ToolOutputFile</code> class automatically deletes<a id="_idIndexMarker318"/> the file if we do not explicitly request<a id="_idIndexMarker319"/> that we want to keep it. This makes error handling easier as there are potentially many places where we need to handle errors and only one place is reached if everything goes well. We successfully emitted the code, so we want to keep the file:</p>&#13;
			<pre class="source-code">&#13;
  Out-&gt;keep();</pre>			<p>Finally, we must report success to the caller:</p>&#13;
			<pre class="source-code">&#13;
  return true;&#13;
}</pre>			<p>Calling the <code>emit()</code> method with <code>llvm::Module</code>, which we created with a call to the <code>CodeGenerator</code> class, emits the code as requested.</p>&#13;
			<p>Suppose you have the greatest common divisor algorithm in <code>tinylang</code> stored in the <code>Gcd.mod</code> file:</p>&#13;
			<pre class="source-code">&#13;
MODULE Gcd;&#13;
PROCEDURE GCD(a, b: INTEGER) : INTEGER;&#13;
VAR t: INTEGER;&#13;
BEGIN&#13;
  IF b = 0 THEN&#13;
    RETURN a;&#13;
  END;&#13;
  WHILE b # 0 DO&#13;
    t := a MOD b;&#13;
    a := b;&#13;
    b := t;&#13;
  END;&#13;
  RETURN a;&#13;
END GCD;&#13;
END Gcd.</pre>			<p>To translate this to the <code>Gcd.o</code> object file, type the following:</p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=obj Gcd.mod</pre>			<p>If you’d like to inspect<a id="_idIndexMarker320"/> the generated IR code directly on the screen, type<a id="_idIndexMarker321"/> the following:</p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=asm --emit-llvm -o - Gcd.mod</pre>			<p>With the current state of the implementation, it is not possible to create a complete program in <code>tinylang</code>. However, you can use a small C program called <code>callgcd.c</code> to test the generated object file. Note the use of the mangled name to call the <code>GCD</code> function:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdio.h&gt;&#13;
extern long _t3Gcd3GCD(long, long);&#13;
int main(int argc, char *argv[]) {&#13;
  printf(„gcd(25, 20) = %ld\n", _t3Gcd3GCD(25, 20));&#13;
  printf(„gcd(3, 5) = %ld\n", _t3Gcd3GCD(3, 5));&#13;
  printf(„gcd(21, 28) = %ld\n", _t3Gcd3GCD(21, 28));&#13;
  return 0;&#13;
}</pre>			<p>To compile and run the whole application with <code>clang</code>, type the following:</p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=obj Gcd.mod&#13;
$ clang callgcd.c Gcd.o -o gcd&#13;
$ gcd</pre>			<p>Let’s celebrate! At this point, we have created<a id="_idIndexMarker322"/> a complete compiler by reading the source language<a id="_idIndexMarker323"/> up and emitting assembler code or an object file.</p>&#13;
			<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to implement a code generator for LLVM IR code. Basic blocks are important data structures that hold all the instructions and express branches. You learned how to create basic blocks for the control statements of the source language and how to add instructions to a basic block. You applied a modern algorithm to handle local variables in functions, leading to less IR code. The goal of a compiler is to generate assembler text or an object file for the input, so you also added a simple compilation pipeline. With this knowledge, you will be able to generate LLVM IR code and assembler text or object code for your language compiler.</p>&#13;
			<p>In the next chapter, you’ll learn how to deal with aggregate data structures and how to ensure that function calls comply with the rules of your platform.</p>&#13;
		</div>&#13;
	</div></body></html>