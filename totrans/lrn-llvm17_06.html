<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer014">&#13;
			<h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor068"/>4</h1>&#13;
			<h1 id="_idParaDest-67"><a id="_idTextAnchor069"/>Basics of IR Code Generation</h1>&#13;
			<p>Having created a decorated <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) for your programming language, the next task is to generate<a id="_idIndexMarker211"/> the LLVM IR code from it. LLVM IR code resembles a three-address code with a human-readable representation. Therefore, we need a systematic approach to translate language concepts such as control structures into the lower level of <span class="No-Break">LLVM IR.</span></p>&#13;
			<p>In this chapter, you will learn about the basics of LLVM IR and how to generate IR for control flow structures<a id="_idIndexMarker212"/> from the AST. You will also learn how to generate LLVM IR for expressions in <strong class="bold">static single assignment</strong> (<strong class="bold">SSA</strong>) form using a modern algorithm. Finally, you will learn how to emit assembler text and <span class="No-Break">object code.</span></p>&#13;
			<p>This chapter will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Generating IR from <span class="No-Break">the AST</span></li>&#13;
				<li>Using AST numbering to generate IR code in <span class="No-Break">SSA form</span></li>&#13;
				<li>Setting up the module and <span class="No-Break">the driver</span></li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to create a code generator for your programming language and how to integrate it into <span class="No-Break">your compiler.</span></p>&#13;
			<h1 id="_idParaDest-68"><a id="_idTextAnchor070"/>Generating IR from the AST</h1>&#13;
			<p>The LLVM code generator<a id="_idIndexMarker213"/> takes a module in LLVM IR as input and turns<a id="_idIndexMarker214"/> it into object code or assembly text. We need to transform the AST representation into IR. To implement an IR code generator, we will look at a simple example first and then develop the classes needed for the code generator. The complete implementation will be divided into <span class="No-Break">three classes:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break"><strong class="source-inline">CodeGenerator</strong></span></li>&#13;
				<li><span class="No-Break"><strong class="source-inline">CGModule</strong></span></li>&#13;
				<li><span class="No-Break"><strong class="source-inline">CGProcedure</strong></span></li>&#13;
			</ul>&#13;
			<p>The <strong class="source-inline">CodeGenerator</strong> class is the general interface used by the compiler driver. The <strong class="source-inline">CGModule</strong> and <strong class="source-inline">CGProcedure</strong> classes hold the state required<a id="_idIndexMarker215"/> for generating the IR code for a compilation<a id="_idIndexMarker216"/> unit and a <span class="No-Break">single function.</span></p>&#13;
			<p>We’ll begin by looking at the <span class="No-Break">Clang-generated IR.</span></p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Understanding the IR code</h2>&#13;
			<p>Before generating the IR code, it’s good to know the main elements<a id="_idIndexMarker217"/> of the IR language. In <a href="B19561_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">The Structure of a Compiler</em>, we had a brief look at IR. An easy way to get more knowledge of IR is to study the output from <strong class="source-inline">clang</strong>. For example, save this C source code, which implements the Euclidean algorithm for calculating the greatest common divisor of two numbers, <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">gcd.c</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
unsigned gcd(unsigned a, unsigned b) {&#13;
  if (b == 0)&#13;
    return a;&#13;
  while (b != 0) {&#13;
    unsigned t = a % b;&#13;
    a = b;&#13;
    b = t;&#13;
  }&#13;
  return a;&#13;
}</pre>			<p>Then, you can create the <strong class="source-inline">gcd.ll</strong> IR file by using <strong class="source-inline">clang</strong> and the <span class="No-Break">following command:</span></p>&#13;
			<pre class="console">&#13;
$ clang --target=aarch64-linux-gnu -O1 -S -emit-llvm gcd.c</pre>			<p>The IR code is not target-independent, even if it often looks like it is. The preceding command compiles the source file for an ARM 64-bit CPU on Linux. The <strong class="source-inline">-S</strong> option instructs <strong class="source-inline">clang</strong> to output an assembly file, and with the additional specification of <strong class="source-inline">-emit-llvm</strong>, an IR file is created. The optimization level, <strong class="source-inline">-O1</strong>, is used to get an easily readable IR code. Clang has many more options, all of which are documented<a id="_idIndexMarker218"/> in the command-line argument reference at <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">https://clang.llvm.org/docs/ClangCommandLineReference.html</a>. Let’s have a look at the generated file and understand how the C source maps to the <span class="No-Break">LLVM IR.</span></p>&#13;
			<p>A C file is translated into a <strong class="bold">module</strong>, which holds the functions and the data<a id="_idIndexMarker219"/> objects. A function has at least one <strong class="bold">basic block</strong>, and a basic block contains instructions. This hierarchical structure<a id="_idIndexMarker220"/> is also reflected in the C++ API. All data elements are typed. Integer types are represented by the letter <strong class="source-inline">i</strong>, followed by the number of bits. For example, the 64-bit integer type is written as <strong class="source-inline">i64</strong>. The most basic float types are <strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>, denoting the 32-bit and 64-bit IEEE floating-point types. It is also possible to create aggregate types such as vectors, arrays, <span class="No-Break">and structures.</span></p>&#13;
			<p>Here is what the LLVM IR<a id="_idIndexMarker221"/> looks like. At the top of the file, some basic properties <span class="No-Break">are established:</span></p>&#13;
			<pre class="source-code">&#13;
; ModuleID = 'gcd.c'&#13;
source_filename = "gcd.c"&#13;
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"&#13;
target triple = "aarch64-unknown-linux-gnu"</pre>			<p>The first line is a comment informing you about which module identifier was used. In the following line, the filename of the source file is named. With <strong class="source-inline">clang</strong>, both are <span class="No-Break">the same.</span></p>&#13;
			<p>The <strong class="source-inline">target datalayout</strong> string establishes some basic properties. The different parts are separated by <strong class="source-inline">-</strong>. The following information <span class="No-Break">is included:</span></p>&#13;
			<ul>&#13;
				<li> A small <strong class="source-inline">e</strong> means that bytes in memory are stored using the little-endian schema. To specify a big endian, you must use a <span class="No-Break">big </span><span class="No-Break"><strong class="source-inline">E</strong></span><span class="No-Break">.</span></li>&#13;
				<li><strong class="source-inline">M:</strong> specifies the name mangling that’s applied to symbols. Here, <strong class="source-inline">m:e</strong> means that ELF name mangling <span class="No-Break">is used.</span></li>&#13;
				<li>The entries in <strong class="source-inline">iN:A:P</strong> form, such as<strong class="source-inline">i8:8:32</strong>, specify the alignment of data, given in bits. The first number is the alignment required by the ABI, and the second number is the preferred alignment. For bytes (<strong class="source-inline">i8</strong>), the ABI alignment is 1 byte (<strong class="source-inline">8</strong>) and the preferred alignment is 4 <span class="No-Break">bytes (</span><span class="No-Break"><strong class="source-inline">32</strong></span><span class="No-Break">).</span></li>&#13;
				<li><strong class="source-inline">n</strong> specifies which native register sizes are available. <strong class="source-inline">n32:64</strong> means that 32-bit and 64-bit wide integers are <span class="No-Break">natively supported.</span></li>&#13;
				<li><strong class="source-inline">S</strong> specifies the alignment of the stack, again in bits. <strong class="source-inline">S128</strong> means that the stack maintains a <span class="No-Break">16-byte alignment.</span></li>&#13;
			</ul>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The provided target data layout must match what the backend expects. Its purpose is to communicate the captured information to the target-independent optimization passes. For example, an optimization pass can query the data layout to get the size and alignment of a pointer. However, changing the size of a pointer in the data layout does not change the code generation in <span class="No-Break">the backend.</span></p>&#13;
			<p class="callout">A lot more information is provided<a id="_idIndexMarker222"/> with the target data layout. You can find more information in the reference manual <span class="No-Break">at </span><a href="https://llvm.org/docs/LangRef.html#data-layout"><span class="No-Break">https://llvm.org/docs/LangRef.html#data-layout</span></a><span class="No-Break">.</span></p>&#13;
			<p>Last, the <strong class="source-inline">target triple</strong> string specifies the architecture<a id="_idIndexMarker223"/> we are compiling for. This reflects the information we gave on the command line. The triple is a configuration string that usually consists of the CPU architecture, the vendor, and the operating system. More information about the environment is often added. For example, the <strong class="source-inline">x86_64-pc-win32</strong> triple is used for a Windows system running on a 64-bit X86 CPU. <strong class="source-inline">x86_64</strong> is the CPU architecture, <strong class="source-inline">pc</strong> is a generic vendor, and <strong class="source-inline">win32</strong> is the operating system. The parts are connected by a hyphen. A Linux system running on an ARMv8 CPU uses <strong class="source-inline">aarch64-unknown-linux-gnu</strong> as its triple. <strong class="source-inline">aarch64</strong> is the CPU architecture, while the operating system is <strong class="source-inline">linux</strong> running a <strong class="source-inline">gnu</strong> environment. There is no real vendor for a Linux-based system, so this part is <strong class="source-inline">unknown</strong>. Parts that are not known or unimportant for a specific purpose are often omitted: the <strong class="source-inline">aarch64-linux-gnu</strong> triple describes the same <span class="No-Break">Linux system.</span></p>&#13;
			<p>Next, the <strong class="source-inline">gcd</strong> function is defined in the <span class="No-Break">IR file:</span></p>&#13;
			<pre class="source-code">&#13;
define i32 @gcd(i32 %a, i32 %b) {</pre>			<p>This resembles the function signature in the C file. The <strong class="source-inline">unsigned</strong> data type is translated into the 32-bit integer type, <strong class="source-inline">i32</strong>. The function name is prefixed with <strong class="source-inline">@</strong>, and the parameter names are prefixed with <strong class="source-inline">%</strong>. The body of the function is enclosed in curly braces. The code of the <span class="No-Break">body follows:</span></p>&#13;
			<pre class="source-code">&#13;
entry:&#13;
  %cmp = icmp eq i32 %b, 0&#13;
  br i1 %cmp, label %return, label %while.body</pre>			<p>The IR code is organized into so-called <strong class="bold">basic blocks</strong>. A well-formed basic block is a linear sequence of instructions, which begins<a id="_idIndexMarker224"/> with an optional label and ends with a terminator instruction. So, each basic block<a id="_idIndexMarker225"/> has one entry point and one exit point. LLVM allows malformed basic blocks at construction time. The label of the first basic block is <strong class="source-inline">entry</strong>. The code in the block is simple: the first instruction compares the <strong class="source-inline">%b</strong> parameter against <strong class="source-inline">0</strong>. The second instruction branches to the <strong class="source-inline">return</strong> label if the condition is <strong class="source-inline">true</strong> and to the <strong class="source-inline">while.body</strong> label if the condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Another characteristic of the IR code is that it is in a <strong class="bold">static single assignment</strong> (<strong class="bold">SSA</strong>) form. The code uses an unlimited number of virtual<a id="_idIndexMarker226"/> registers, but each register is only written once. The result of the comparison is assigned to the named virtual register, <strong class="source-inline">%cmp</strong>. This register is then used, but it is never written again. Optimizations such as constant propagation and common-sub-expression elimination work very well with the SSA form and all modern compilers are <span class="No-Break">using it.</span></p>&#13;
			<p class="callout-heading">SSA</p>&#13;
			<p class="callout">The SSA form was developed<a id="_idIndexMarker227"/> in the late 1980s. Since then, it has been widely used in compilers because it simplifies data flow analysis and optimizations. For example, the identification of common sub-expressions inside a loop becomes much easier if the IR is in SSA form. A basic property of SSA is that it establishes <strong class="source-inline">def-use</strong> and <strong class="source-inline">use-def</strong> chains: for a single definition, you know of all uses (<strong class="source-inline">def-use</strong>), and for each use, you know the unique definition (<strong class="source-inline">use-def</strong>). This knowledge is used a lot, such as in constant propagation: if a definition is determined to be a constant, then all uses of this value can be easily replaced with that <span class="No-Break">constant value.</span></p>&#13;
			<p class="callout">To construct the SSA form, the algorithm from Cytron et al. (1989) is very popular, and it is also used in the LLVM implementation. Other algorithms have been developed too. An early observation is that these algorithms become simpler if the source language does not have a <span class="No-Break"><strong class="source-inline">goto</strong></span><span class="No-Break"> statement.</span></p>&#13;
			<p class="callout">An in-depth treatment<a id="_idIndexMarker228"/> of SSA can be found in the book <em class="italic">SSA-based Compiler Design</em>, by F. Rastello and F. B. Tichadou, <span class="No-Break">Springer 2022.</span></p>&#13;
			<p>The next basic block<a id="_idIndexMarker229"/> is the body of the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span></p>&#13;
			<pre class="source-code">&#13;
while.body:&#13;
  %b.loop = phi i32 [ %rem, %while.body ],&#13;
                       [ %b, %entry ]&#13;
  %a.loop = phi i32 [ %b.loop, %while.body ],&#13;
                       [ %a, %entry ]&#13;
  %rem = urem i32 %a.loop, %b.loop&#13;
  %cmp1 = icmp eq i32 %rem, 0&#13;
  br i1 %cmp1, label %return, label %while.body</pre>			<p>Inside the loop of <strong class="source-inline">gcd</strong>, the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> parameters are assigned new values. If a register can be only written once, then this is not possible. The solution is to use the special <strong class="source-inline">phi</strong> instruction. The <strong class="source-inline">phi</strong> instruction has a list of basic blocks and values as parameters. A basic block presents the incoming edge from that basic block, and the value is the value from that basic block. At runtime, the <strong class="source-inline">phi</strong> instruction compares the label of the previously executed basic block with the labels in the <span class="No-Break">parameter list.</span></p>&#13;
			<p>The value of the instruction is the value that’s associated with the label. For the first <strong class="source-inline">phi</strong> instruction, the value is the <strong class="source-inline">%rem</strong> register if the previously executed basic block was <strong class="source-inline">while.body</strong>. The value is <strong class="source-inline">%b</strong> if <strong class="source-inline">entry</strong> was the previously executed basic block. The values are the ones at the start of the basic block. The <strong class="source-inline">%b.loop</strong> register gets a value from the first <strong class="source-inline">phi</strong> instruction. The same register is used in the parameter list of the second <strong class="source-inline">phi</strong> instruction, but the value is assumed to be the one before it is changed through the first <span class="No-Break"><strong class="source-inline">phi</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p>After the loop’s body, the return value must <span class="No-Break">be chosen:</span></p>&#13;
			<pre class="source-code">&#13;
return:&#13;
  %retval = phi i32 [ %a, %entry ],&#13;
                    [ %b.loop, %while.body ]&#13;
  ret i32 %retval&#13;
}</pre>			<p>Again, a <strong class="source-inline">phi</strong> instruction is used to select the desired value. The <strong class="source-inline">ret</strong> instruction not only ends this basic block but also denotes the end of this function at runtime. It has the return value as <span class="No-Break">a parameter.</span></p>&#13;
			<p>There are some restrictions on the use of <strong class="source-inline">phi</strong> instructions. They must be the first instructions of a basic block. The first basic block is special: it has no previously executed block. Therefore, it cannot begin with a <span class="No-Break"><strong class="source-inline">phi</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p class="callout-heading">LLVM IR reference</p>&#13;
			<p class="callout">We’ve only touched<a id="_idIndexMarker230"/> the very basics of the LLVM IR. Please visit the LLVM Language Reference Manual at <a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a> to look up all <span class="No-Break">the details.</span></p>&#13;
			<p>The IR code<a id="_idIndexMarker231"/> itself looks a lot like a mix of C and assembly language. Despite this familiar style, it is not clear how we can easily generate the IR code from an AST. The <strong class="source-inline">phi</strong> instruction in particular looks difficult to generate. But don’t be scared – in the next section, we’ll implement a simple algorithm to just <span class="No-Break">do that!</span></p>&#13;
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Learning about the load-and-store approach</h2>&#13;
			<p>All local optimizations in LLVM<a id="_idIndexMarker232"/> are based on the SSA form shown here. For global variables, memory references are used. The IR language knows load and store instructions, which are used to fetch and store those values. You can use this for local variables too. These instructions do not belong to the SSA form, and LLVM knows how to convert them into the required SSA form. Therefore, you can allocate memory slots for each local variable and use load and store instructions to change their value. All you need to remember is the pointer to the memory slot where a variable is stored. The <strong class="source-inline">clang</strong> compiler uses <span class="No-Break">this approach.</span></p>&#13;
			<p>Let’s look at the IR code for load and store. Compile <strong class="source-inline">gcd.c</strong> again, but this time without <span class="No-Break">enabling optimization:</span></p>&#13;
			<pre class="console">&#13;
$ clang --target=aarch64-linux-gnu -S -emit-llvm gcd.c</pre>			<p>The <strong class="source-inline">gcd</strong> function now looks different. This is the first <span class="No-Break">basic block:</span></p>&#13;
			<pre class="source-code">&#13;
define i32 @gcd(i32, i32) {&#13;
  %3 = alloca i32, align 4&#13;
  %4 = alloca i32, align 4&#13;
  %5 = alloca i32, align 4&#13;
  %6 = alloca i32, align 4&#13;
  store i32 %0, ptr %4, align 4&#13;
  store i32 %1, ptr %5, align 4&#13;
  %7 = load i32, ptr %5, align 4&#13;
  %8 = icmp eq i32 %7, 0&#13;
  br i1 %8, label %9, label %11</pre>			<p>The IR code now relies on the automatic numbering of registers and labels. The names of the parameters are not specified. Implicitly, they are <strong class="source-inline">%0</strong> and <strong class="source-inline">%1</strong>. The basic block has no label, so <strong class="source-inline">2</strong> is assigned. The first few instructions allocate memory for the four 32-bit values. After that, the <strong class="source-inline">%0</strong> and <strong class="source-inline">%1</strong> parameters are stored in the memory slots pointed to by registers <strong class="source-inline">%4</strong> and <strong class="source-inline">%5</strong>. To compare <strong class="source-inline">%1</strong> to <strong class="source-inline">0</strong>, the value is explicitly loaded from the memory slot. With this approach, you do not need to use the <strong class="source-inline">phi</strong> instruction! Instead, you load a value from a memory slot, perform a calculation on it, and store the new value back in the memory slot. The next time you read the memory slot, you get the last computed value. All the other basic blocks for the <strong class="source-inline">gcd</strong> function follow <span class="No-Break">this pattern.</span></p>&#13;
			<p>The advantage of using load and store instructions in this way is that it is fairly easy to generate the IR code. The disadvantage is that you generate a lot of IR instructions that LLVM will remove with the <strong class="source-inline">mem2reg</strong> pass in the very first optimization step, after converting the basic block into SSA<a id="_idIndexMarker233"/> form. Therefore, we generate the IR code in SSA <span class="No-Break">form directly.</span></p>&#13;
			<p>We’ll start developing IR code generation by mapping the control flow to <span class="No-Break">basic blocks.</span></p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Mapping the control flow to basic blocks</h2>&#13;
			<p>The conceptual idea<a id="_idIndexMarker234"/> of a basic block is that it is a <em class="italic">linear sequence of instructions</em> that are executed<a id="_idIndexMarker235"/> in that order. A basic block has exactly one entry at the beginning, and it ends with a terminator instruction, which is an instruction that transfers the control flow<a id="_idIndexMarker236"/> to another basic block, such as a branch instruction, a switch instruction, or a return instruction. See <a href="https://llvm.org/docs/LangRef.html#terminator-instructions">https://llvm.org/docs/LangRef.html#terminator-instructions</a> for a complete list of terminator instructions. A basic block can begin with <strong class="source-inline">phi</strong> instructions, but inside a basic block, neither <strong class="source-inline">phi</strong> nor branch instructions are allowed. In other words, you can only enter a basic block at the first<a id="_idIndexMarker237"/> instruction, and you can only leave a basic block at the last instruction, which is the terminator<a id="_idIndexMarker238"/> instruction. It is not possible to branch to an instruction inside a basic block or to branch to another basic block from the middle of a basic block. Please note that a simple function call with the <strong class="source-inline">call</strong> instruction can occur inside a basic block. Each basic block has exactly one label, marking the first instruction of the basic<a id="_idIndexMarker239"/> block. Labels are the targets of branch instructions. You can view branches as directed edges between two basic blocks, resulting in the <strong class="bold">control flow graph</strong> (<strong class="bold">CFG</strong>). A basic block can have <strong class="bold">predecessors</strong> and <strong class="bold">successors</strong>. The first basic block of a function<a id="_idIndexMarker240"/> is special in the sense<a id="_idIndexMarker241"/> that no predecessors <span class="No-Break">are allowed.</span></p>&#13;
			<p>As a consequence of these restrictions, control statements of the source language, such as <strong class="source-inline">WHILE</strong> and <strong class="source-inline">IF</strong>, produce several basic blocks. Let’s look at the <strong class="source-inline">WHILE</strong> statement. The condition of the <strong class="source-inline">WHILE</strong> statement controls if the loop body or the next statement is executed. The condition must be generated in a basic block of its own because there are <span class="No-Break">two predecessors:</span></p>&#13;
			<ul>&#13;
				<li>The basic block resulting from the statement <span class="No-Break">before </span><span class="No-Break"><strong class="source-inline">WHILE</strong></span></li>&#13;
				<li>The branch from the end of the loop body back to <span class="No-Break">the condition</span></li>&#13;
			</ul>&#13;
			<p>There are also <span class="No-Break">two successors:</span></p>&#13;
			<ul>&#13;
				<li>The beginning of the <span class="No-Break">loop body</span></li>&#13;
				<li>The basic block resulting from the statement <span class="No-Break">following </span><span class="No-Break"><strong class="source-inline">WHILE</strong></span></li>&#13;
			</ul>&#13;
			<p>The loop body itself has at least one <span class="No-Break">basic block:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer013" class="IMG---Figure">&#13;
					<img src="Images/B19561_04_1.jpg" alt="Figure 4.1 – The basic blocks of a WHILE statement" width="643" height="785"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The basic blocks of a WHILE statement</p>&#13;
			<p>The IR code generation follows this structure. We store a pointer to the current basic block in the <strong class="source-inline">CGProcedure</strong> class and use<a id="_idIndexMarker242"/> an instance of <strong class="source-inline">llvm::IRBuilder&lt;&gt;</strong> to insert instructions into the basic<a id="_idIndexMarker243"/> block. First, we create the <span class="No-Break">basic blocks:</span></p>&#13;
			<pre class="source-code">&#13;
void emitStmt(WhileStatement *Stmt) {&#13;
  llvm::BasicBlock *WhileCondBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "while.cond", Fn);&#13;
  llvm::BasicBlock *WhileBodyBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "while.body", Fn);&#13;
  llvm::BasicBlock *AfterWhileBB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "after.while", Fn);</pre>			<p>The <strong class="source-inline">Fn</strong> variable denotes the current function and <strong class="source-inline">getLLVMCtx()</strong> returns the LLVM context. Both are set later. We end the current basic block with a branch to the basic block, which will hold <span class="No-Break">the condition:</span></p>&#13;
			<pre class="source-code">&#13;
  Builder.CreateBr(WhileCondBB);</pre>			<p>The basic block for the condition becomes the new current basic block. We generate the condition and end the block with a <span class="No-Break">conditional branch:</span></p>&#13;
			<pre class="source-code">&#13;
  setCurr(WhileCondBB);&#13;
  llvm::Value *Cond = emitExpr(Stmt-&gt;getCond());&#13;
  Builder.CreateCondBr(Cond, WhileBodyBB, AfterWhileBB);</pre>			<p>Next, we generate the loop body. Finally, we add a branch back to the basic block of <span class="No-Break">the condition:</span></p>&#13;
			<pre class="source-code">&#13;
  setCurr(WhileBodyBB);&#13;
  emit(Stmt-&gt;getWhileStmts());&#13;
  Builder.CreateBr(WhileCondBB);</pre>			<p>With that, we have generated the <strong class="source-inline">WHILE</strong> statement. Now that we’ve generated the <strong class="source-inline">WhileCondBB</strong> and <strong class="source-inline">Curr</strong> blocks, we can <span class="No-Break">seal them:</span></p>&#13;
			<pre class="source-code">&#13;
  sealBlock(WhileCondBB);&#13;
  sealBlock(Curr);</pre>			<p>The empty basic block<a id="_idIndexMarker244"/> for statements following <strong class="source-inline">WHILE</strong> becomes the new current<a id="_idIndexMarker245"/> <span class="No-Break">basic block:</span></p>&#13;
			<pre class="source-code">&#13;
  setCurr(AfterWhileBB);&#13;
}</pre>			<p>Following this schema, you can create an <strong class="source-inline">emit()</strong> method for each statement of the <span class="No-Break">source language.</span></p>&#13;
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Using AST numbering to generate IR code in SSA form</h1>&#13;
			<p>To generate IR code in SSA form<a id="_idIndexMarker246"/> from the AST, we<a id="_idIndexMarker247"/> can use an approach called <strong class="bold">AST numbering</strong>. The basic idea is that for each basic<a id="_idIndexMarker248"/> block, we store the current value of local variables written in this <span class="No-Break">basic block.</span></p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The implementation is based on the paper <em class="italic">Simple and Efficient Construction of Static Single Assignment Form</em>, by Braun et al., International Conference on CompilerConstruction 2013 (CC 2013), Springer (see http://individual.utoronto.ca/dfr/ece467/braun13.pdf). In its presented form, it only works for IR code that has a structured controlled flow. The paper also describes the necessary extensions if you need to support arbitrary control flow – for example, a <span class="No-Break"><strong class="source-inline">goto</strong></span><span class="No-Break"> statement.</span></p>&#13;
			<p>Although it is simple, we will still need several steps. We will introduce the required data structure first, and after that, we will learn how to read and write values local to a basic block. Then, we will handle values<a id="_idIndexMarker249"/> that are used in several basic<a id="_idIndexMarker250"/> blocks and conclude by optimizing the created <span class="No-Break"><strong class="source-inline">phi</strong></span><span class="No-Break"> instructions.</span></p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Defining the data structure to hold values</h2>&#13;
			<p>We use the <strong class="source-inline">BasicBlockDef</strong> struct to hold<a id="_idIndexMarker251"/> the information<a id="_idIndexMarker252"/> for a <span class="No-Break">single block:</span></p>&#13;
			<pre class="source-code">&#13;
struct BasicBlockDef {&#13;
  llvm::DenseMap&lt;Decl *, llvm::TrackingVH&lt;llvm::Value&gt;&gt; Defs;&#13;
  // ...&#13;
};</pre>			<p>The <strong class="source-inline">llvm::Value</strong> LLVN class represents a value in SSA form. The <strong class="source-inline">Value</strong> class acts like a label on the result of a computation. It is created once, usually through an IR instruction, and then used. Various changes can occur during optimizations. For example, if the optimizer detects that the <strong class="source-inline">%1</strong> and <strong class="source-inline">%2</strong> values are always the same, then it can replace the use of <strong class="source-inline">%2</strong> with <strong class="source-inline">%1</strong>. This changes the label but not <span class="No-Break">the computation.</span></p>&#13;
			<p>To be aware of such changes, we cannot use the <strong class="source-inline">Value</strong> class directly. Instead, we need a value handle. There are value handles with different functionality. To track replacement, we can use the <strong class="source-inline">llvm::TrackingVH&lt;&gt;</strong> class. As a result, the <strong class="source-inline">Defs</strong> member maps a declaration of the AST (a variable or a formal parameter) to its current value. Now, we need to store this information<a id="_idIndexMarker253"/> for each <span class="No-Break">basic</span><span class="No-Break"><a id="_idIndexMarker254"/></span><span class="No-Break"> block:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DenseMap&lt;llvm::BasicBlock *, BasicBlockDef&gt; CurrentDef;</pre>			<p>With this data structure, we are now able to handle <span class="No-Break">local values.</span></p>&#13;
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>Reading and writing values local to a basic block</h2>&#13;
			<p>To store the current<a id="_idIndexMarker255"/> value of a local variable<a id="_idIndexMarker256"/> in a basic block, we will create <a id="_idIndexMarker257"/>an entry<a id="_idIndexMarker258"/> in <span class="No-Break">the maps:</span></p>&#13;
			<pre class="source-code">&#13;
void writeLocalVariable(llvm::BasicBlock *BB, Decl *Decl,&#13;
                        llvm::Value *Val) {&#13;
  CurrentDef[BB].Defs[Decl] = Val;&#13;
}</pre>			<p>The lookup of a variable’s value is a bit more complicated because the value might not be in the basic block. In this case, we need to extend the search to the predecessors using a possible <span class="No-Break">recursive search:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Value *&#13;
readLocalVariable(llvm::BasicBlock *BB, Decl *Decl) {&#13;
  auto Val = CurrentDef[BB].Defs.find(Decl);&#13;
  if (Val != CurrentDef[BB].Defs.end())&#13;
    return Val-&gt;second;&#13;
  return readLocalVariableRecursive(BB, Decl);&#13;
}</pre>			<p>The real work is searching the predecessors, which we’ll implement in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>Searching the predecessor blocks for a value</h2>&#13;
			<p>If the current basic block we are looking<a id="_idIndexMarker259"/> at has only one predecessor, then we search<a id="_idIndexMarker260"/> there for the value of the variable. If the basic block has several predecessors, then we need to search for the value in all these blocks and combine the results. To illustrate this situation, you can look at the basic block with the condition of a <strong class="source-inline">WHILE</strong> statement from the <span class="No-Break">previous section.</span></p>&#13;
			<p>This basic block has two predecessors – the one resulting from the statement before the <strong class="source-inline">WHILE</strong> statement and the one resulting from the branch for the end of the body of the <strong class="source-inline">WHILE</strong> loop. A variable that’s used in the condition should have some initial value and will most likely be changed in the body of the loop. So, we need to collect these definitions and create a <strong class="source-inline">phi</strong> instruction from it. The basic blocks that are created from the <strong class="source-inline">WHILE</strong> statement contain <span class="No-Break">a cycle.</span></p>&#13;
			<p>Because we recursively search the predecessor blocks, we must break this cycle. To do so, we can use a simple trick: we can insert an empty <strong class="source-inline">phi</strong> instruction and record this as the current value of the variable. If we see this basic block again in our search, then we’ll see that the variable has a value that we can use. The search stops at this point. Once we’ve collected all the values, we must update the <span class="No-Break"><strong class="source-inline">phi</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p>However, we will still face a problem. At the time of the lookup, not all predecessors of a basic block may be known. How can this happen? Look at the creation of the basic blocks for the <strong class="source-inline">WHILE</strong> statement. The IR for the condition of the loop is generated first. However, the branch from the end of the body that goes back to the basic block, which contains the condition, can only be added after the IR for the body is generated. This is because this basic block is not known earlier. If we need to read the value of a variable in the condition, then we are stuck, because not all predecessors <span class="No-Break">are known.</span></p>&#13;
			<p>To solve this situation, we must do a <span class="No-Break">little more:</span></p>&#13;
			<ol>&#13;
				<li>First, we must attach a <strong class="source-inline">Sealed</strong> flag to the <span class="No-Break">basic block.</span></li>&#13;
				<li>Then, we must define a basic block as sealed if we know all the predecessors of the basic block. If the basic block is not sealed and we need to look up the value of the variable not yet defined in this basic block, then we must insert an empty <strong class="source-inline">phi</strong> instruction and use it as <span class="No-Break">the value.</span></li>&#13;
				<li>We also need to remember this instruction. If the block is later sealed, then we need to update the instruction with the real values. To implement this, we must add two more members to <strong class="source-inline">struct BasicBlockDef</strong>: the <strong class="source-inline">IncompletePhis</strong> map, which records the <strong class="source-inline">phi</strong> instructions we need later to update, and the <strong class="source-inline">Sealed</strong> flag, which indicates if the basic block <span class="No-Break">is sealed:</span><pre class="source-code">&#13;
llvm::DenseMap&lt;llvm::PHINode *, Decl *&gt; IncompletePhis;&#13;
unsigned Sealed : 1;</pre></li>				<li>Then, the method<a id="_idIndexMarker261"/> can be implemented, as discussed<a id="_idIndexMarker262"/> at the beginning of <span class="No-Break">this section:</span><pre class="source-code">&#13;
llvm::Value *CGProcedure::readLocalVariableRecursive(&#13;
    llvm::BasicBlock *BB, Decl *Decl) {&#13;
  llvm::Value *Val = nullptr;&#13;
  if (!CurrentDef[BB].Sealed) {&#13;
    llvm::PHINode *Phi = addEmptyPhi(BB, Decl);&#13;
    CurrentDef[BB].IncompletePhis[Phi] = Decl;&#13;
    Val = Phi;&#13;
  } else if (auto *PredBB = BB-&gt;getSinglePredecessor()) {&#13;
    Val = readLocalVariable(PredBB, Decl);&#13;
  } else {&#13;
    llvm::PHINode *Phi = addEmptyPhi(BB, Decl);&#13;
    writeLocalVariable(BB, Decl, Phi);&#13;
    Val = addPhiOperands(BB, Decl, Phi);&#13;
  }&#13;
  writeLocalVariable(BB, Decl, Val);&#13;
  return Val;&#13;
}</pre></li>				<li>The <strong class="source-inline">addEmptyPhi()</strong> method inserts an empty <strong class="source-inline">phi</strong> instruction at the beginning of the <span class="No-Break">basic block:</span><pre class="source-code">&#13;
llvm::PHINode *&#13;
CGProcedure::addEmptyPhi(llvm::BasicBlock *BB,&#13;
                         Decl *Decl) {&#13;
  return BB-&gt;empty()&#13;
             ? llvm::PHINode::Create(mapType(Decl), 0,&#13;
                                     "", BB)&#13;
             : llvm::PHINode::Create(mapType(Decl), 0,&#13;
                                     "", &amp;BB-&gt;front());&#13;
}</pre></li>				<li>To add the missing operands<a id="_idIndexMarker263"/> to the <strong class="source-inline">phi</strong> instruction, first, we must search<a id="_idIndexMarker264"/> all the predecessors of the basic block and add the operand pair value and basic block to the <strong class="source-inline">phi</strong> instruction. Then, we must try to optimize <span class="No-Break">the instruction:</span><pre class="source-code">&#13;
llvm::Value *&#13;
CGProcedure::addPhiOperands(llvm::BasicBlock *BB,&#13;
                            Decl *Decl,&#13;
                            llvm::PHINode *Phi) {&#13;
  for (auto *PredBB : llvm::predecessors(BB))&#13;
    Phi-&gt;addIncoming(readLocalVariable(PredBB, Decl),&#13;
                     PredBB);&#13;
  return optimizePhi(Phi);&#13;
}</pre></li>			</ol>&#13;
			<p>This algorithm can generate<a id="_idIndexMarker265"/> unneeded <strong class="source-inline">phi</strong> instructions. One approach<a id="_idIndexMarker266"/> to optimize these will be implemented in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Optimizing the generated phi instructions</h2>&#13;
			<p>How can we optimize a <strong class="source-inline">phi</strong> instruction<a id="_idIndexMarker267"/> and why should we do it? Although the SSA form is advantageous for many optimizations, the <strong class="source-inline">phi</strong> instruction is often not interpreted by the algorithms and thus hinders the optimization in general. Therefore, the fewer <strong class="source-inline">phi</strong> instructions we generate, the better. Let’s take a <span class="No-Break">closer look:</span></p>&#13;
			<ol>&#13;
				<li>If the instruction has only one operand or all operands have the same value, then we replace the instruction with this value. If the instruction has no operand, then we replace the instruction with the special <strong class="source-inline">Undef</strong> value. Only if the instruction has two or more distinct operands do we have to keep <span class="No-Break">the instruction:</span><pre class="source-code">&#13;
llvm::Value *&#13;
CGProcedure::optimizePhi(llvm::PHINode *Phi) {&#13;
  llvm::Value *Same = nullptr;&#13;
  for (llvm::Value *V : Phi-&gt;incoming_values()) {&#13;
    if (V == Same || V == Phi)&#13;
      continue;&#13;
    if (Same &amp;&amp; V != Same)&#13;
      return Phi;&#13;
    Same = V;&#13;
  }&#13;
  if (Same == nullptr)&#13;
    Same = llvm::UndefValue::get(Phi-&gt;getType());</pre></li>				<li>Removing a <strong class="source-inline">phi</strong> instruction<a id="_idIndexMarker268"/> may lead to optimization opportunities in other <strong class="source-inline">phi</strong> instructions. Fortunately, LLVM keeps track of the users and the use of values (which is the <strong class="source-inline">use-def</strong> chain mentioned in the definition of SSA). We must search for all uses of the value in other <strong class="source-inline">phi</strong> instructions and try to optimize these <span class="No-Break">instructions too:</span><pre class="source-code">&#13;
  llvm::SmallVector&lt;llvm::PHINode *, 8&gt; CandidatePhis;&#13;
  for (llvm::Use &amp;U : Phi-&gt;uses()) {&#13;
    if (auto *P =&#13;
            llvm::dyn_cast&lt;llvm::PHINode&gt;(U.getUser()))&#13;
      if (P != Phi)&#13;
        CandidatePhis.push_back(P);&#13;
  }&#13;
  Phi-&gt;replaceAllUsesWith(Same);&#13;
  Phi-&gt;eraseFromParent();&#13;
  for (auto *P : CandidatePhis)&#13;
    optimizePhi(P);&#13;
  return Same;&#13;
}</pre></li>			</ol>&#13;
			<p>If we want, we can improve this algorithm even further. Instead of always iterating the list of values for each <strong class="source-inline">phi</strong> instruction, we can pick and remember two distinct values. Then, in the <strong class="source-inline">optimizePhi</strong> function, we can check if these two values are still in the list of the <strong class="source-inline">phi</strong> instruction. If that is the case, then we know that there is nothing to optimize. But even without this optimization, this algorithm runs very fast, so we are not going to implement <span class="No-Break">this now.</span></p>&#13;
			<p>We are almost done. The only thing<a id="_idIndexMarker269"/> we haven’t done is implement the operation to seal a basic block. We will do this in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Sealing a block</h2>&#13;
			<p>As soon as we know that all the predecessors of a block<a id="_idIndexMarker270"/> are known, we can seal the block. If the source language contains only structured statements such as <strong class="source-inline">tinylang</strong>, then it is easy to determine where a block can be sealed. Take another look at the basic blocks that are generated for the <span class="No-Break"><strong class="source-inline">WHILE</strong></span><span class="No-Break"> statement.</span></p>&#13;
			<p>The basic block that contains the condition can be sealed after the branch from the end of the body is added because this was the last missing predecessor. To seal a block, we can simply add the missing operands to the incomplete <strong class="source-inline">phi</strong> instructions and set <span class="No-Break">the flag:</span></p>&#13;
			<pre class="source-code">&#13;
void CGProcedure::sealBlock(llvm::BasicBlock *BB) {&#13;
  for (auto PhiDecl : CurrentDef[BB].IncompletePhis) {&#13;
    addPhiOperands(BB, PhiDecl.second, PhiDecl.first);&#13;
  }&#13;
  CurrentDef[BB].IncompletePhis.clear();&#13;
  CurrentDef[BB].Sealed = true;&#13;
}</pre>			<p>With these methods, we are now ready to generate the IR code <span class="No-Break">for expressions.</span></p>&#13;
			<h2 id="_idParaDest-78"><a id="_idTextAnchor080"/>Creating the IR code for expressions</h2>&#13;
			<p>In general, you translate<a id="_idIndexMarker271"/> expressions, as shown in <a href="B19561_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">The Structure of a Compiler</em>. The only interesting<a id="_idIndexMarker272"/> part is how to access variables. The previous section treated local variables, but there are other kinds of variables we can consider. Let’s discuss what we need <span class="No-Break">to do:</span></p>&#13;
			<ul>&#13;
				<li>For a local variable of the procedure, we use the <strong class="source-inline">readLocalVariable()</strong> and <strong class="source-inline">writeLocalVariable()</strong> methods from the <span class="No-Break">previous section.</span></li>&#13;
				<li>For a local variable in an enclosing procedure, we need a pointer to the frame of the enclosing procedure. This will be handled later in <span class="No-Break">this chapter.</span></li>&#13;
				<li>For a global variable, we generate load and <span class="No-Break">store instructions.</span></li>&#13;
				<li>For a formal parameter, we have to differentiate between passing by value and passing by reference (the <strong class="source-inline">VAR</strong> parameter in <strong class="source-inline">tinylang</strong>). A parameter that’s passed by value is treated as a local variable, and a parameter passed by reference is treated as a <span class="No-Break">global variable.</span></li>&#13;
			</ul>&#13;
			<p>Putting it all together, we get the following code<a id="_idIndexMarker273"/> for reading a variable or <span class="No-Break">formal</span><span class="No-Break"><a id="_idIndexMarker274"/></span><span class="No-Break"> parameter:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Value *CGProcedure::readVariable(llvm::BasicBlock *BB,&#13;
                                       Decl *D) {&#13;
  if (auto *V = llvm::dyn_cast&lt;VariableDeclaration&gt;(D)) {&#13;
    if (V-&gt;getEnclosingDecl() == Proc)&#13;
      return readLocalVariable(BB, D);&#13;
    else if (V-&gt;getEnclosingDecl() ==&#13;
             CGM.getModuleDeclaration()) {&#13;
      return Builder.CreateLoad(mapType(D),&#13;
                                CGM.getGlobal(D));&#13;
    } else&#13;
      llvm::report_fatal_error(&#13;
          "Nested procedures not yet supported");&#13;
  } else if (auto *FP =&#13;
                 llvm::dyn_cast&lt;FormalParameterDeclaration&gt;(&#13;
                     D)) {&#13;
    if (FP-&gt;isVar()) {&#13;
      return Builder.CreateLoad(mapType(FP, false),&#13;
                                FormalParams[FP]);&#13;
    } else&#13;
      return readLocalVariable(BB, D);&#13;
  } else&#13;
    llvm::report_fatal_error("Unsupported declaration");&#13;
}</pre>			<p>Writing to a variable or formal parameter is symmetrical – we just need to exchange the method to read with<a id="_idIndexMarker275"/> the one to write and use a <strong class="source-inline">store</strong> instruction<a id="_idIndexMarker276"/> instead of a <span class="No-Break"><strong class="source-inline">load</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p>Next, these functions are applied while generating the IR code for <span class="No-Break">the functions.</span></p>&#13;
			<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Emitting the IR code for a function</h2>&#13;
			<p>Most of the IR code<a id="_idIndexMarker277"/> will live in a function. A function in IR code resembles<a id="_idIndexMarker278"/> a function in C. It specifies in the name, the types of parameters, the return value, and other attributes. To call a function in a different compilation unit, you need to declare the function. This is similar to a prototype in C. If you add basic blocks to the function, then you define the function. We will do all this in the next few sections, but first, we will discuss the visibility of <span class="No-Break">symbol names.</span></p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Controlling visibility with linkage and name mangling</h2>&#13;
			<p>Functions (and also global variables) have a linkage<a id="_idIndexMarker279"/> style attached. With the<a id="_idIndexMarker280"/> linkage style, we define the visibility<a id="_idIndexMarker281"/> of a symbol name and what should happen<a id="_idIndexMarker282"/> if more than one symbol has the same name. The most basic linkage styles are <strong class="source-inline">private</strong> and <strong class="source-inline">external</strong>. A symbol with <strong class="source-inline">private</strong> linkage is only visible in the current compilation unit, while a symbol with <strong class="source-inline">external</strong> linkage is <span class="No-Break">globally available.</span></p>&#13;
			<p>For a language without a proper module concept, such as C, this is adequate. With modules, we need to do more. Let’s assume<a id="_idIndexMarker283"/> that we have a module called <strong class="source-inline">Square</strong> that provides<a id="_idIndexMarker284"/> a <strong class="source-inline">Root()</strong> function<a id="_idIndexMarker285"/> and a <strong class="source-inline">Cube</strong> module, which also provides a <strong class="source-inline">Root()</strong> function. If the functions<a id="_idIndexMarker286"/> are private, then there is no problem. The function gets the name <strong class="source-inline">Root</strong> and private linkage. The situation is different if the function is exported so that it can be called from other modules. Using the function name alone is not enough, because this name is <span class="No-Break">not unique.</span></p>&#13;
			<p>The solution is to tweak the name to make it globally unique. This is called name <strong class="bold">mangling</strong>. How this is done depends on the requirements <a id="_idIndexMarker287"/>and characteristics of the language. In our case, the base idea is to use a combination of the module and the function name to create a globally unique name. Using <strong class="source-inline">Square.Root</strong> as the name looks like an obvious solution, but it may lead to problems with assemblers as the dot may have a special meaning. Instead of using a delimiter between the name components, we can get a similar effect by prefixing the name components with their length: <strong class="source-inline">6Square4Root</strong>. This is no legal identifier for LLVM, but we can fix this by prefixing the whole name with <strong class="source-inline">_t</strong> (with <strong class="source-inline">t</strong> for <strong class="source-inline">tinylang</strong>): <strong class="source-inline">_t6Square4Root</strong>. In this way, we can create unique names for <span class="No-Break">exported symbols:</span></p>&#13;
			<pre class="source-code">&#13;
std::string CGModule::mangleName(Decl *D) {&#13;
  std::string Mangled("_t");&#13;
  llvm::SmallVector&lt;llvm::StringRef, 4&gt; List;&#13;
  for (; D; D = D-&gt;getEnclosingDecl())&#13;
    List.push_back(D-&gt;getName());&#13;
  while (!List.empty()) {&#13;
    llvm::StringRef Name = List.pop_back_val();&#13;
    Mangled.append(&#13;
        llvm::Twine(Name.size()).concat(Name).str());&#13;
  }&#13;
  return Mangled;&#13;
}</pre>			<p>If your source language supports type overloading, then you need to extend this scheme with type names. For example, to distinguish between the <strong class="source-inline">int root(int)</strong> and <strong class="source-inline">double root(double)</strong> C++ functions, the type of the parameter and the return value must be added to the <span class="No-Break">function name.</span></p>&#13;
			<p>You also need to think about the length of the generated name since some linkers place restrictions on the length. With nested namespaces and classes in C++, the mangled names can be rather long. There, C++ defines<a id="_idIndexMarker288"/> a compression<a id="_idIndexMarker289"/> scheme to avoid<a id="_idIndexMarker290"/> repeating name components<a id="_idIndexMarker291"/> over and <span class="No-Break">over again.</span></p>&#13;
			<p>Next, we’ll look at how to <span class="No-Break">treat parameters.</span></p>&#13;
			<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Converting a type from an AST description into LLVM types</h2>&#13;
			<p>The parameters of a function<a id="_idIndexMarker292"/> also need some consideration. First, we need<a id="_idIndexMarker293"/> to map the types of the source language to an LLVM type. As <strong class="source-inline">tinylang</strong> currently has only two types, this <span class="No-Break">is easy:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Type *CGModule::convertType(TypeDeclaration *Ty) {&#13;
  if (Ty-&gt;getName() == "INTEGER")&#13;
    return Int64Ty;&#13;
  if (Ty-&gt;getName() == "BOOLEAN")&#13;
    return Int1Ty;&#13;
  llvm::report_fatal_error("Unsupported type");&#13;
}</pre>			<p><strong class="source-inline">Int64Ty</strong>, <strong class="source-inline">Int1Ty</strong>, and <strong class="source-inline">VoidTy</strong> are class members that hold the type representation of the <strong class="source-inline">i64</strong>, <strong class="source-inline">i1</strong>, and <strong class="source-inline">void</strong> <span class="No-Break">LLVM types.</span></p>&#13;
			<p>For a formal parameter passed by reference, this is not enough. The LLVM type of this parameter is a pointer. However, when we want to use the value of the formal parameter, we need to know the underlying type. This is controlled by the <strong class="source-inline">HonorReference</strong> flag, which has a default value of <strong class="source-inline">true</strong>. We generalize the function and take<a id="_idIndexMarker294"/> the formal parameter<a id="_idIndexMarker295"/> <span class="No-Break">into account:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Type *CGProcedure::mapType(Decl *Decl,&#13;
                                 bool HonorReference) {&#13;
  if (auto *FP = llvm::dyn_cast&lt;FormalParameterDeclaration&gt;(&#13;
          Decl)) {&#13;
    if (FP-&gt;isVar() &amp;&amp; HonorReference)&#13;
      return llvm::PointerType::get(CGM.getLLVMCtx(),&#13;
                                    /*AddressSpace=*/0);&#13;
    return CGM.convertType(FP-&gt;getType());&#13;
  }&#13;
  if (auto *V = llvm::dyn_cast&lt;VariableDeclaration&gt;(Decl))&#13;
    return CGM.convertType(V-&gt;getType());&#13;
  return CGM.convertType(llvm::cast&lt;TypeDeclaration&gt;(Decl));&#13;
}</pre>			<p>With these helpers at hand, we can create the LLVM <span class="No-Break">IR function.</span></p>&#13;
			<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Creating the LLVM IR function</h2>&#13;
			<p>To emit a function in LLVM IR, a function<a id="_idIndexMarker296"/> type is needed, which is similar to a prototype in C. Creating the function type involves mapping the types and then calling the factory method to create the <span class="No-Break">function type:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::FunctionType *CGProcedure::createFunctionType(&#13;
    ProcedureDeclaration *Proc) {&#13;
  llvm::Type *ResultTy = CGM.VoidTy;&#13;
  if (Proc-&gt;getRetType()) {&#13;
    ResultTy = mapType(Proc-&gt;getRetType());&#13;
  }&#13;
  auto FormalParams = Proc-&gt;getFormalParams();&#13;
  llvm::SmallVector&lt;llvm::Type *, 8&gt; ParamTypes;&#13;
  for (auto FP : FormalParams) {&#13;
    llvm::Type *Ty = mapType(FP);&#13;
    ParamTypes.push_back(Ty);&#13;
  }&#13;
  return llvm::FunctionType::get(ResultTy, ParamTypes,&#13;
                                 /*IsVarArgs=*/false);&#13;
}</pre>			<p>Based on the function type, we also create<a id="_idIndexMarker297"/> the LLVM function. This associates the function type with the linkage and the <span class="No-Break">mangled name:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Function *&#13;
CGProcedure::createFunction(ProcedureDeclaration *Proc,&#13;
                            llvm::FunctionType *FTy) {&#13;
  llvm::Function *Fn = llvm::Function::Create(&#13;
      Fty, llvm::GlobalValue::ExternalLinkage,&#13;
      CGM.mangleName(Proc), CGM.getModule());</pre>			<p>The <strong class="source-inline">getModule()</strong> method returns the current LLVM module, which we’ll set up a <span class="No-Break">bit later.</span></p>&#13;
			<p>With the function created, we can add some more information <span class="No-Break">about it:</span></p>&#13;
			<ul>&#13;
				<li>First, we can give the parameter’s names. This makes the IR <span class="No-Break">more readable.</span></li>&#13;
				<li>Second, we can add attributes to the function and to the parameters to specify some characteristics. As an example, we will do this for parameters passed <span class="No-Break">by reference.</span></li>&#13;
			</ul>&#13;
			<p>At the LLVM level, these parameters are pointers. But from the source language design, these are very restricted pointers. Analogous to references in C++, we always need to specify a variable for a <strong class="source-inline">VAR</strong> parameter. So, by design, we know that this pointer will never be null and that it is always dereferenceable, meaning that we can read the value that’s being pointed to without risking<a id="_idIndexMarker298"/> a general protection fault. Also, by design, this pointer cannot be passed around – in particular, there are no copies of the pointer that outlive the call to the function. Therefore, the pointer is said to not <span class="No-Break">be captured.</span></p>&#13;
			<p>The <strong class="source-inline">llvm::AttributeBuilder</strong> class is used to build the set of attributes for a formal parameter. To get the storage size of a parameter type, we can simply query the data <span class="No-Break">layout object:</span></p>&#13;
			<pre class="source-code">&#13;
  for (auto [Idx, Arg] : llvm::enumerate(Fn-&gt;args())) {&#13;
    FormalParameterDeclaration *FP =&#13;
        Proc-&gt;getFormalParams()[Idx];&#13;
    if (FP-&gt;isVar()) {&#13;
      llvm::AttrBuilder Attr(CGM.getLLVMCtx());&#13;
      llvm::TypeSize Sz =&#13;
          CGM.getModule()-&gt;getDataLayout().getTypeStoreSize(&#13;
              CGM.convertType(FP-&gt;getType()));&#13;
      Attr.addDereferenceableAttr(Sz);&#13;
      Attr.addAttribute(llvm::Attribute::NoCapture);&#13;
      Arg.addAttrs(Attr);&#13;
    }&#13;
    Arg.setName(FP-&gt;getName());&#13;
  }&#13;
  return Fn;&#13;
}</pre>			<p>With that, we have created the IR function. In the next section, we’ll add the basic blocks of the function<a id="_idIndexMarker299"/> body to <span class="No-Break">the function.</span></p>&#13;
			<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Emitting the function body</h2>&#13;
			<p>We are almost done with emitting<a id="_idIndexMarker300"/> the IR code for a function! We only need to put the pieces together to emit a function, including <span class="No-Break">its body:</span></p>&#13;
			<ol>&#13;
				<li>Given a procedure declaration from <strong class="source-inline">tinylang</strong>, first, we will create the function type and <span class="No-Break">the function:</span><pre class="source-code">&#13;
void CGProcedure::run(ProcedureDeclaration *Proc) {&#13;
  this-&gt;Proc = Proc;&#13;
  Fty = createFunctionType(Proc);&#13;
  Fn = createFunction(Proc, Fty);</pre></li>				<li>Next, we will create the first basic block<a id="_idIndexMarker301"/> of the function and make it the <span class="No-Break">current one:</span><pre class="source-code">&#13;
  llvm::BasicBlock *BB = llvm::BasicBlock::Create(&#13;
      CGM.getLLVMCtx(), "entry", Fn);&#13;
  setCurr(BB);</pre></li>				<li>Then, we must step through all formal parameters. To handle VAR parameters correctly, we need to initialize the <strong class="source-inline">FormalParams</strong> member (used in <strong class="source-inline">readVariable()</strong>). In contrast to local variables, formal parameters have a value in the first basic block, so we must make these <span class="No-Break">values known:</span><pre class="source-code">&#13;
  for (auto [Idx, Arg] : llvm::enumerate(Fn-&gt;args())) {&#13;
    FormalParameterDeclaration *FP =&#13;
        Proc-&gt;getFormalParams()[Idx];&#13;
    FormalParams[FP] = &amp;Arg;&#13;
    writeLocalVariable(Curr, FP, &amp;Arg);&#13;
  }</pre></li>				<li>After this setup, we can call the <strong class="source-inline">emit()</strong> method to start generating the IR code <span class="No-Break">for statements:</span><pre class="source-code">&#13;
  auto Block = Proc-&gt;getStmts();&#13;
  emit(Proc-&gt;getStmts());</pre></li>				<li>The last block after generating the IR code may not be sealed yet, so we must call <strong class="source-inline">sealBlock()</strong> now. A procedure in <strong class="source-inline">tinylang</strong> may have an implicit return, so we must also check if the last basic block has a proper terminator, and add one <span class="No-Break">if not:</span><pre class="source-code">&#13;
  if (!Curr-&gt;getTerminator()) {&#13;
    Builder.CreateRetVoid();&#13;
  }&#13;
  sealBlock(Curr);&#13;
}</pre></li>			</ol>&#13;
			<p>With that, we’ve finished generating<a id="_idIndexMarker302"/> IR code for functions. However, we still need to create the LLVM module, which holds all the IR code together. We’ll do this in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-84"><a id="_idTextAnchor086"/>Setting up the module and the driver</h1>&#13;
			<p>We collect all the functions and global variables<a id="_idIndexMarker303"/> of a compilation unit in an LLVM<a id="_idIndexMarker304"/> module. To ease the IR generation process, we can wrap all the functions from the previous sections into a code generator class. To get a working compiler, we also need to define the target architecture for which we want to generate code, and also add the passes that emit the code. We will implement this in this and the next few chapters, starting with the <span class="No-Break">code generator.</span></p>&#13;
			<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Wrapping all in the code generator</h2>&#13;
			<p>The IR module is the brace around all elements<a id="_idIndexMarker305"/> we generate for a compilation unit. At the global level, we iterate through the declarations at the module level, create global variables, and call the code generation for procedures. A global variable in <strong class="source-inline">tinylang</strong> is mapped to an instance of the <strong class="source-inline">llvm::GobalValue</strong> class. This mapping is saved in <strong class="source-inline">Globals</strong> and made available to the code generation <span class="No-Break">for procedures:</span></p>&#13;
			<pre class="source-code">&#13;
void CGModule::run(ModuleDeclaration *Mod) {&#13;
  for (auto *Decl : Mod-&gt;getDecls()) {&#13;
    if (auto *Var =&#13;
            llvm::dyn_cast&lt;VariableDeclaration&gt;(Decl)) {&#13;
      // Create global variables&#13;
      auto *V = new llvm::GlobalVariable(&#13;
          *M, convertType(Var-&gt;getType()),&#13;
          /*isConstant=*/false,&#13;
          llvm::GlobalValue::PrivateLinkage, nullptr,&#13;
          mangleName(Var));&#13;
      Globals[Var] = V;&#13;
    } else if (auto *Proc =&#13;
                   llvm::dyn_cast&lt;ProcedureDeclaration&gt;(&#13;
                       Decl)) {&#13;
      CGProcedure CGP(*this);&#13;
      CGP.run(Proc);&#13;
    }&#13;
  }&#13;
}</pre>			<p>The module also holds the <strong class="source-inline">LLVMContext</strong> class and caches the most commonly used LLVM types. The latter ones need<a id="_idIndexMarker306"/> to be initialized, for example, for the 64-bit <span class="No-Break">integer type:</span></p>&#13;
			<pre class="source-code">&#13;
Int64Ty = llvm::Type::getInt64Ty(getLLVMCtx());</pre>			<p>The <strong class="source-inline">CodeGenerator</strong> class initializes the LLVM IR module and calls the code generation for the module. Most importantly, this class must know for which target architecture we’d like to generate code. This information is passed in the <strong class="source-inline">llvm::TargetMachine</strong> class, which is set up in <span class="No-Break">the driver:</span></p>&#13;
			<pre class="source-code">&#13;
std::unique_ptr&lt;llvm::Module&gt;&#13;
CodeGenerator::run(ModuleDeclaration *Mod,&#13;
                   std::string FileName) {&#13;
  std::unique_ptr&lt;llvm::Module&gt; M =&#13;
      std::make_unique&lt;llvm::Module&gt;(FileName, Ctx);&#13;
  M-&gt;setTargetTriple(TM-&gt;getTargetTriple().getTriple());&#13;
  M-&gt;setDataLayout(TM-&gt;createDataLayout());&#13;
  CGModule CGM(M.get());&#13;
  CGM.run(Mod);&#13;
  return M;&#13;
}</pre>			<p>For ease of use, we must also introduce a factory method for the <span class="No-Break">code generator:</span></p>&#13;
			<pre class="source-code">&#13;
CodeGenerator *&#13;
CodeGenerator::create(llvm::LLVMContext &amp;Ctx,&#13;
                      llvm::TargetMachine *TM) {&#13;
  return new CodeGenerator(Ctx, TM);&#13;
}</pre>			<p>The <strong class="source-inline">CodeGenerator</strong> class provides a small interface<a id="_idIndexMarker307"/> to create IR code, which is ideal for use in the compiler driver. Before we integrate it, we need to implement the support for machine <span class="No-Break">code generation.</span></p>&#13;
			<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Initializing the target machine class</h2>&#13;
			<p>Now, only the target machine<a id="_idIndexMarker308"/> is missing. With the target machine, we define the CPU architecture we’d like to generate code for. For each CPU, there are features available that can be used to influence the code generation process. For example, a newer CPU of a CPU architecture family can support vector instructions. With features, we can toggle the use of vector instructions on or off. To support setting all these options from the command line, LLVM provides some supporting code. In the <strong class="source-inline">Driver</strong> class, we can add the following <span class="No-Break"><strong class="source-inline">include</strong></span><span class="No-Break"> variable:</span></p>&#13;
			<pre class="source-code">&#13;
#include "llvm/CodeGen/CommandFlags.h"</pre>			<p>This <strong class="source-inline">include</strong> variable adds common command-line options to our compiler driver. Many LLVM tools also use these command-line options, which have the benefit of providing a common interface to the user. Only the option to specify a target triple is missing. As this is very useful, we’ll add <span class="No-Break">this ourselves:</span></p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;std::string&gt; MTriple(&#13;
    "mtriple",&#13;
    llvm::cl::desc("Override target triple for module"));</pre>			<p>Let’s create the <span class="No-Break">target machine:</span></p>&#13;
			<ol>&#13;
				<li>To display error<a id="_idIndexMarker309"/> messages, the name of the application must be passed to <span class="No-Break">the function:</span><pre class="source-code">&#13;
llvm::TargetMachine *&#13;
createTargetMachine(const char *Argv0) {</pre></li>				<li>First, we must collect all the information provided by the command line. These are options for the code generator – that is, the name of the CPU and possible features that should be activated or deactivated, and the triple of <span class="No-Break">the target:</span><pre class="source-code">&#13;
  llvm::Triple Triple = llvm::Triple(&#13;
      !MTriple.empty()&#13;
          ? llvm::Triple::normalize(MTriple)&#13;
          : llvm::sys::getDefaultTargetTriple());&#13;
  llvm::TargetOptions TargetOptions =&#13;
      codegen::InitTargetOptionsFromCodeGenFlags(Triple);&#13;
  std::string CPUStr = codegen::getCPUStr();&#13;
  std::string FeatureStr = codegen::getFeaturesStr();</pre></li>				<li>Then, we must look up the target<a id="_idIndexMarker310"/> in the target registry. If an error occurs, then we will display the error message and bail out. A possible error would be an unsupported triple specified by <span class="No-Break">the user:</span><pre class="source-code">&#13;
  std::string Error;&#13;
  const llvm::Target *Target =&#13;
      llvm::TargetRegistry::lookupTarget(&#13;
          codegen::getMArch(), Triple, Error);&#13;
  if (!Target) {&#13;
    llvm::WithColor::error(llvm::errs(), Argv0) &lt;&lt; Error;&#13;
    return nullptr;&#13;
  }</pre></li>				<li>With the help of the <strong class="source-inline">Target</strong> class, we can configure the target machine using all the known options requested by <span class="No-Break">the user:</span><pre class="source-code">&#13;
  llvm::TargetMachine *TM = Target-&gt;createTargetMachine(&#13;
      Triple.getTriple(), CPUStr, FeatureStr,&#13;
      TargetOptions, std::optional&lt;llvm::Reloc::Model&gt;(&#13;
          codegen::getRelocModel()));&#13;
  return TM;&#13;
}</pre></li>			</ol>&#13;
			<p>With the target machine instance, we can generate IR code that targets a CPU architecture of our choice. What is missing is the translation to assembly text or the generation of object<a id="_idIndexMarker311"/> code files. We’ll add this support in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/>Emitting assembler text and object code</h2>&#13;
			<p>In LLVM, the IR code<a id="_idIndexMarker312"/> is run through a pipeline of passes. Each pass performs a single task, such as removing<a id="_idIndexMarker313"/> dead code. We’ll learn more about passes in <a href="B19561_07.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Optimizing IR</em>. Outputting assembler code or an object file is implemented as a pass too. Let’s add basic support <span class="No-Break">for it!</span></p>&#13;
			<p>We need to include even more LLVM header files. First, we need the <strong class="source-inline">llvm::legacy::PassManager</strong> class to hold the passes to emit code to a file. We also want to be able to output LLVM IR code, so we also need a pass to emit this. Finally, we’ll use the <strong class="source-inline">llvm:: ToolOutputFile</strong> class for the <span class="No-Break">file operations:</span></p>&#13;
			<pre class="source-code">&#13;
#include "llvm/IR/IRPrintingPasses.h"&#13;
#include "llvm/IR/LegacyPassManager.h"&#13;
#include "llvm/MC/TargetRegistry.h"&#13;
#include "llvm/Pass.h"&#13;
#include "llvm/Support/ToolOutputFile.h"</pre>			<p>Another command-line option for outputting LLVM IR is <span class="No-Break">also needed:</span></p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;bool&gt; EmitLLVM(&#13;
    "emit-llvm",&#13;
    llvm::cl::desc("Emit IR code instead of assembler"),&#13;
    llvm::cl::init(false));</pre>			<p>Finally, we want to be able to give the output file <span class="No-Break">a name:</span></p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;std::string&gt;&#13;
    OutputFilename("o",&#13;
                   llvm::cl::desc("Output filename"),&#13;
                   llvm::cl::value_desc("filename"));</pre>			<p>The first task in the new <strong class="source-inline">emit()</strong> method is to deal with the name of the output file if it’s not given by the user on the command line. If the input is read from <strong class="source-inline">stdin</strong>, indicated by the use of the minus symbol, <strong class="source-inline">-</strong>, then we output the result to <strong class="source-inline">stdout</strong>. The <strong class="source-inline">ToolOutputFile</strong> class knows how to handle the special <span class="No-Break">filename, </span><span class="No-Break"><strong class="source-inline">-</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
bool emit(StringRef Argv0, llvm::Module *M,&#13;
          llvm::TargetMachine *TM,&#13;
          StringRef InputFilename) {&#13;
  CodeGenFileType FileType = codegen::getFileType();&#13;
  if (OutputFilename.empty()) {&#13;
    if (InputFilename == "-") {&#13;
      OutputFilename = "-";&#13;
    }</pre>			<p>Otherwise, we drop a possible extension<a id="_idIndexMarker314"/> of the input filename and append <strong class="source-inline">.ll</strong>, <strong class="source-inline">.s</strong>, or <strong class="source-inline">.o</strong> as an extension, depending<a id="_idIndexMarker315"/> on the command-line options given by the user. The <strong class="source-inline">FileType</strong> option is defined in the <strong class="source-inline">llvm/CodeGen/CommandFlags.inc</strong> header file, which we included earlier. This option doesn’t support emitting IR code, so we’ve added the new<strong class="source-inline">–emit-llvm</strong> option, which only takes effect if it’s used together with the assembly <span class="No-Break">file type:</span></p>&#13;
			<pre class="source-code">&#13;
    else {&#13;
      if (InputFilename.endswith(".mod"))&#13;
        OutputFilename =&#13;
            InputFilename.drop_back(4).str();&#13;
      else&#13;
        OutputFilename = InputFilename.str();&#13;
      switch (FileType) {&#13;
      case CGFT_AssemblyFile:&#13;
        OutputFilename.append(EmitLLVM ? ".ll" : ".s");&#13;
        break;&#13;
      case CGFT_ObjectFile:&#13;
        OutputFilename.append(".o");&#13;
        break;&#13;
      case CGFT_Null:&#13;
        OutputFilename.append(".null");&#13;
        break;&#13;
      }&#13;
    }&#13;
  }</pre>			<p>Some platforms distinguish<a id="_idIndexMarker316"/> between text and binary files, so we have to provide <a id="_idIndexMarker317"/>the right open flags when opening the <span class="No-Break">output file:</span></p>&#13;
			<pre class="source-code">&#13;
  std::error_code EC;&#13;
  sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;&#13;
  if (FileType == CGFT_AssemblyFile)&#13;
    OpenFlags |= sys::fs::OF_TextWithCRLF;&#13;
  auto Out = std::make_unique&lt;llvm::ToolOutputFile&gt;(&#13;
      OutputFilename, EC, OpenFlags);&#13;
  if (EC) {&#13;
    WithColor::error(llvm::errs(), Argv0)&#13;
        &lt;&lt; EC.message() &lt;&lt; '\n';&#13;
    return false;&#13;
  }</pre>			<p>Now, we can add the required passes to <strong class="source-inline">PassManager</strong>. The <strong class="source-inline">TargetMachine</strong> class has a utility method that adds the requested classes. Therefore, we only need to check if the user requests to output the LLVM <span class="No-Break">IR code:</span></p>&#13;
			<pre class="source-code">&#13;
  legacy::PassManager PM;&#13;
  if (FileType == CGFT_AssemblyFile &amp;&amp; EmitLLVM) {&#13;
    PM.add(createPrintModulePass(Out-&gt;os()));&#13;
  } else {&#13;
    if (TM-&gt;addPassesToEmitFile(PM, Out-&gt;os(), nullptr,&#13;
                                FileType)) {&#13;
      WithColor::error(llvm::errs(), Argv0)&#13;
          &lt;&lt; "No support for file type\n";&#13;
      return false;&#13;
    }&#13;
  }</pre>			<p>With all this preparation done, emitting the file boils down to a single <span class="No-Break">function call:</span></p>&#13;
			<pre class="source-code">&#13;
  PM.run(*M);</pre>			<p>The <strong class="source-inline">ToolOutputFile</strong> class automatically deletes<a id="_idIndexMarker318"/> the file if we do not explicitly request<a id="_idIndexMarker319"/> that we want to keep it. This makes error handling easier as there are potentially many places where we need to handle errors and only one place is reached if everything goes well. We successfully emitted the code, so we want to keep <span class="No-Break">the file:</span></p>&#13;
			<pre class="source-code">&#13;
  Out-&gt;keep();</pre>			<p>Finally, we must report success to <span class="No-Break">the caller:</span></p>&#13;
			<pre class="source-code">&#13;
  return true;&#13;
}</pre>			<p>Calling the <strong class="source-inline">emit()</strong> method with <strong class="source-inline">llvm::Module</strong>, which we created with a call to the <strong class="source-inline">CodeGenerator</strong> class, emits the code <span class="No-Break">as requested.</span></p>&#13;
			<p>Suppose you have the greatest common divisor algorithm in <strong class="source-inline">tinylang</strong> stored in the <span class="No-Break"><strong class="source-inline">Gcd.mod</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
MODULE Gcd;&#13;
PROCEDURE GCD(a, b: INTEGER) : INTEGER;&#13;
VAR t: INTEGER;&#13;
BEGIN&#13;
  IF b = 0 THEN&#13;
    RETURN a;&#13;
  END;&#13;
  WHILE b # 0 DO&#13;
    t := a MOD b;&#13;
    a := b;&#13;
    b := t;&#13;
  END;&#13;
  RETURN a;&#13;
END GCD;&#13;
END Gcd.</pre>			<p>To translate this to the <strong class="source-inline">Gcd.o</strong> object file, type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=obj Gcd.mod</pre>			<p>If you’d like to inspect<a id="_idIndexMarker320"/> the generated IR code directly on the screen, type<a id="_idIndexMarker321"/> <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=asm --emit-llvm -o - Gcd.mod</pre>			<p>With the current state of the implementation, it is not possible to create a complete program in <strong class="source-inline">tinylang</strong>. However, you can use a small C program called <strong class="source-inline">callgcd.c</strong> to test the generated object file. Note the use of the mangled name to call the <span class="No-Break"><strong class="source-inline">GCD</strong></span><span class="No-Break"> function:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdio.h&gt;&#13;
extern long _t3Gcd3GCD(long, long);&#13;
int main(int argc, char *argv[]) {&#13;
  printf(„gcd(25, 20) = %ld\n", _t3Gcd3GCD(25, 20));&#13;
  printf(„gcd(3, 5) = %ld\n", _t3Gcd3GCD(3, 5));&#13;
  printf(„gcd(21, 28) = %ld\n", _t3Gcd3GCD(21, 28));&#13;
  return 0;&#13;
}</pre>			<p>To compile and run the whole application with <strong class="source-inline">clang</strong>, type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ tinylang --filetype=obj Gcd.mod&#13;
$ clang callgcd.c Gcd.o -o gcd&#13;
$ gcd</pre>			<p>Let’s celebrate! At this point, we have created<a id="_idIndexMarker322"/> a complete compiler by reading the source language<a id="_idIndexMarker323"/> up and emitting assembler code or an <span class="No-Break">object file.</span></p>&#13;
			<h1 id="_idParaDest-88"><a id="_idTextAnchor090"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to implement a code generator for LLVM IR code. Basic blocks are important data structures that hold all the instructions and express branches. You learned how to create basic blocks for the control statements of the source language and how to add instructions to a basic block. You applied a modern algorithm to handle local variables in functions, leading to less IR code. The goal of a compiler is to generate assembler text or an object file for the input, so you also added a simple compilation pipeline. With this knowledge, you will be able to generate LLVM IR code and assembler text or object code for your <span class="No-Break">language compiler.</span></p>&#13;
			<p>In the next chapter, you’ll learn how to deal with aggregate data structures and how to ensure that function calls comply with the rules of <span class="No-Break">your platform.</span></p>&#13;
		</div>&#13;
	</div></body></html>