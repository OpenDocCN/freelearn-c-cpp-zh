["```cpp\nPlayer::Player(QGraphicsItem *parent)\n    : QGraphicsPixmapItem(parent)\n    , m_direction(0)\n{\n    QPixmap pixmap(\":/elephant\");\n    setPixmap(pixmap);\n    setOffset(-pixmap.width() / 2, -pixmap.height() / 2);\n}\n```", "```cpp\nint Player::direction() const {\n    return m_direction;\n}\n\nvoid Player::setDirection(int direction)\n{\n    m_direction = direction;\n    if (m_direction != 0) {\n        QTransform transform;\n        if (m_direction < 0) {\n            transform.scale(-1, 1);\n        }\n        setTransform(transform);\n    }\n}\n```", "```cpp\nm_timer.setInterval(30);\nconnect(&m_timer, &QTimer::timeout, \n        this, &MyScene::movePlayer); \n```", "```cpp\nvoid MyScene::keyPressEvent(QKeyEvent *event)\n{\n    if (event->isAutoRepeat()) {\n        return;\n    }\n    switch (event->key()) {\n    case Qt::Key_Right:\n        addHorizontalInput(1);\n        break;\n    case Qt::Key_Left:\n        addHorizontalInput(-1);\n        break;\n    //...\n    }\n}\nvoid MyScene::addHorizontalInput(int input)\n{\n    m_horizontalInput += input;\n    m_player->setDirection(qBound(-1, m_horizontalInput, 1));\n    checkTimer();\n}\n```", "```cpp\nvoid MyScene::checkTimer()\n{\n    if (m_player->direction() == 0) {\n        m_timer.stop();\n    } else if (!m_timer.isActive()) {\n        m_timer.start();\n    }\n}\n```", "```cpp\nconst int direction = m_player->direction();\nif (0 == direction) {\n    return;\n}\n```", "```cpp\nconst int dx = direction * m_velocity;\nqreal newX = qBound(m_minX, m_currentX + dx, m_maxX);\nif (newX == m_currentX) {\n    return;\n}\nm_currentX = newX;\n```", "```cpp\nconst int shiftBorder = 150;\nconst int rightShiftBorder = width() - shiftBorder;\n\nconst int visiblePlayerPos = m_currentX - m_worldShift;\nconst int newWorldShiftRight = visiblePlayerPos - rightShiftBorder;\nif (newWorldShiftRight > 0) {\n    m_worldShift += newWorldShiftRight;\n}\nconst int newWorldShiftLeft = shiftBorder - visiblePlayerPos;\nif (newWorldShiftLeft > 0) {\n    m_worldShift -= newWorldShiftLeft;\n}\nconst int maxWorldShift = m_fieldWidth - qRound(width());\nm_worldShift = qBound(0, m_worldShift, maxWorldShift);\nm_player->setX(m_currentX - m_worldShift);\n```", "```cpp\nqreal ratio = qreal(m_worldShift) / maxWorldShift;\napplyParallax(ratio, m_sky);\napplyParallax(ratio, m_grass);\napplyParallax(ratio, m_trees);\n```", "```cpp\nvoid MyScene::applyParallax(qreal ratio, QGraphicsItem* item) {\n    item->setX(-ratio * (item->boundingRect().width() - width()));\n}\n```", "```cpp\npublic:\n    //...\n    qreal jumpFactor() const;\n    void setJumpFactor(const qreal &jumpFactor);\nsignals:\n    void jumpFactorChanged(qreal);\n```", "```cpp\nQ_PROPERTY(qreal jumpFactor\n           READ jumpFactor\n           WRITE setjumpFactor\n           NOTIFY jumpFactorChanged)\n```", "```cpp\nvoid MyScene::setjumpFactor(const qreal &pos) {\n    if (pos == m_jumpFactor) {\n        return;\n    }\n    m_jumpFactor = pos;\n    emit jumpFactorChanged(m_jumpFactor);\n} \n```", "```cpp\nm_jumpAnimation = new QPropertyAnimation(this);\nm_jumpAnimation->setTargetObject(this);\nm_jumpAnimation->setPropertyName(\"jumpFactor\");\nm_jumpAnimation->setStartValue(0);\nm_jumpAnimation->setKeyValueAt(0.5, 1);\nm_jumpAnimation->setEndValue(0);\nm_jumpAnimation->setDuration(800);\nm_jumpAnimation->setEasingCurve(QEasingCurve::OutInQuad); \n```", "```cpp\nvoid MyScene::jump()\n{\n    if (QAbstractAnimation::Stopped == m_jumpAnimation->state()) {\n        m_jumpAnimation->start();\n    }\n}\n```", "```cpp\ncase Qt::Key_Space:\n    jump();\n    break; \n```", "```cpp\nvoid MyScene::setJumpFactor(const qreal &jumpFactor)\n{\n    //...\n    qreal groundY = (m_groundLevel - m_player->boundingRect().height()  \n                                                                 / 2);\n    qreal y = groundY - m_jumpAnimation->currentValue().toReal() * \n                                                      m_jumpHeight;\n    m_player->setY(y);\n    //...\n}\n```", "```cpp\nclass Player : public QObject, public QGraphicsPixmapItem {\n    Q_OBJECT\n//...\n};\n```", "```cpp\nclass Coin : public QObject, public QGraphicsEllipseItem\n{\n    Q_OBJECT\n    Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity)\n    Q_PROPERTY(QRectF rect READ rect WRITE setRect)\n//...\n};\n```", "```cpp\nvoid Coin::explode()\n{\n    if (m_explosion) {\n        return;\n    }\n    m_explosion = true;\n    //...\n}\n```", "```cpp\nQPropertyAnimation *fadeAnimation = \n    new QPropertyAnimation(this, \"opacity\");\n//...\nQPropertyAnimation *scaleAnimation = new QPropertyAnimation(this, \"rect\");\n//...\nQParallelAnimationGroup *group = new QParallelAnimationGroup(this);\ngroup->addAnimation(scaleAnimation);\ngroup->addAnimation(fadeAnimation);\nconnect(group, &QParallelAnimationGroup::finished,\n        this,  &Coin::deleteLater);\ngroup->start(); \n```", "```cpp\nQSequentialAnimationGroup *group = new QSequentialAnimationGroup(this);\ngroup->addAnimation(scaleAnimation);\ngroup->addAnimation(fadeAnimation);\ngroup->start();\n```", "```cpp\nQT += core gui widgets gamepad\n```", "```cpp\nQList<int> gamepadIds = QGamepadManager::instance()->connectedGamepads();\nif (!gamepadIds.isEmpty()) {\n    QGamepad *gamepad = new QGamepad(gamepadIds[0], this);\n    connect(gamepad, &QGamepad::axisLeftXChanged,\n            this, &MyScene::axisLeftXChanged);\n    connect(gamepad, &QGamepad::axisLeftYChanged,\n            this, &MyScene::axisLeftYChanged);\n}\n```", "```cpp\nvoid MyScene::axisLeftXChanged(double value)\n{\n    int direction;\n    if (value > 0) {\n        direction = 1;\n    } else if (value < 0) {\n        direction = -1;\n    } else {\n        direction = 0;\n    }\n    m_player->setDirection(direction);\n    checkTimer();\n}\n\nvoid MyScene::axisLeftYChanged(double value)\n{\n    if (value < -0.25) {\n        jump();\n    }\n}\n```", "```cpp\nvoid MyScene::checkColliding()\n{\n    for(QGraphicsItem* item: collidingItems(m_player)) {\n        if (Coin *c = qgraphicsitem_cast<Coin*>(item)) {\n            c->explode();\n        }\n    }\n}\n```", "```cpp\nQPainterPath BackgroundItem::shape() const {\n  return QPainterPath();\n} \n```", "```cpp\nvoid MyScene::initPlayField()\n{\n    setSceneRect(0, 0, 500, 340);\n    m_sky = new BackgroundItem(QPixmap(\":/sky\"));\n    addItem(m_sky);\n    BackgroundItem *ground = new BackgroundItem(QPixmap(\":/ground\"));\n    addItem(ground);\n    ground->setPos(0, m_groundLevel);\n    m_trees = new BackgroundItem(QPixmap(\":/trees\"));\n    m_trees->setPos(0, m_groundLevel - m_trees->boundingRect().height());\n    addItem(m_trees);\n    m_grass = new BackgroundItem(QPixmap(\":/grass\"));\n    m_grass->setPos(0,m_groundLevel - m_grass->boundingRect().height());\n    addItem(m_grass);\n    m_player = new Player();\n    m_minX = m_player->boundingRect().width() * 0.5;\n    m_maxX = m_fieldWidth - m_player->boundingRect().width() * 0.5;\n    m_player->setPos(m_minX, m_groundLevel - m_player->boundingRect().height() / 2);\n    m_currentX = m_minX;\n    addItem(m_player);\n    //...\n}\n```", "```cpp\nm_coins = new QGraphicsRectItem(0, 0, m_fieldWidth, m_jumpHeight);\nm_coins->setPen(Qt::NoPen);\nm_coins->setPos(0, m_groundLevel - m_jumpHeight);\nconst int xRange = (m_maxX - m_minX) * 0.94;\nfor (int i = 0; i < 25; ++i) {\n    Coin *c = new Coin(m_coins);\n    c->setPos(m_minX + qrand() % xRange, qrand() % m_jumpHeight);\n}\naddItem(m_coins);\n```", "```cpp\napplyParallax(ratio, m_coins);\n```", "```cpp\nQTimeLine *timeLine = new QTimeLine(5000, this);\ntimeLine->setFrameRange(0, 10); \n```"]