<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-65"><a id="_idTextAnchor064"/>4</h1>
<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Implementing a Frame Graph</h1>
<p>In this chapter, we are <a id="_idIndexMarker180"/>introducing <strong class="bold">frame graphs</strong>, a new system to control the rendering steps for a given frame. As the name implies, we are going to organize the steps (passes) required to render a frame in a <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>). This will <a id="_idIndexMarker181"/>allow us to determine the order of execution of each pass and which passes can be executed in parallel.</p>
<p>Having a graph also provides us with many other benefits, such as the following:</p>
<ul>
<li>It allows us to automate the creation and management of render passes and frame buffers, as each pass defines the input resources it will read from and which resources it will write to.</li>
<li>It helps us reduce the memory required for a frame with a technique called <strong class="bold">memory aliasing</strong>. We can <a id="_idIndexMarker182"/>determine how long a resource will be in use by analyzing the graph. After the resource is no longer needed, we can reuse its memory for a new resource.</li>
<li>Finally, we’ll be able to let the graph manage the insertion of memory barriers and layout transitions during its execution. Each input and output resource defines how it will be used (texture versus attachment, for instance), and we can infer its next layout with this information.</li>
</ul>
<p>In summary, in this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Understanding the structure of a frame graph and the details of our implementations</li>
<li>Implementing a topological sort to make sure the passes execute in the right order</li>
<li>Using the graph to drive rendering and automate resource management and layout transitions</li>
</ul>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following URL: <a href="https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter4">https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter4</a>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Understanding frame graphs</h1>
<p>So far, the rendering in the Raptor Engine has consisted of one pass only. While this approach has <a id="_idIndexMarker183"/>served us well for the topics we have covered, it won’t scale for some of the later chapters. More importantly, it wouldn’t be representative of how modern rendering engines organize their work. Some games and engines implement hundreds of passes, and having to manually manage them can become tedious and error-prone.</p>
<p>Thus, we decided this was a good time in the book to introduce a frame graph. In this section, we are going to present the structure of our graph and the main interfaces to manipulate it in the code.</p>
<p>Let’s start with the basic concepts of a graph.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Building a graph</h2>
<p>Before we <a id="_idIndexMarker184"/>present our solution and implementation for the frame graph, we would like to provide some of the building blocks that we are going to use throughout the chapter. If you’re familiar with frame graphs, or graphs in general, feel free to skim through this section.</p>
<p>A graph is defined by two elements: <strong class="bold">nodes</strong> (or vertices) and <strong class="bold">edges</strong>. Each node can be connected to one or more nodes, and each connection is defined by an edge.</p>
<div><div><img alt="Figure 4.1 – An edge from node A to B" height="110" src="img/B18395_04_01.jpg" width="504"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – An edge from node A to B</p>
<p>In the introduction of this chapter, we mentioned that a frame graph is a DAG. It’s important that our frame graph has these properties as otherwise, we wouldn’t be able to execute it:</p>
<ul>
<li><strong class="bold">Directed</strong>: This means <a id="_idIndexMarker185"/>that the edges have a direction. If, for instance, we define an edge to go from node <em class="italic">A</em> to node <em class="italic">B</em>, we can’t use the same edge to go from <em class="italic">B</em> to <em class="italic">A</em>. We would need a different edge to go from <em class="italic">B</em> to <em class="italic">A</em>.</li>
</ul>
<div><div><img alt="Figure 4.2 – Connecting A to B and B to A in a directed graph" height="107" src="img/B18395_04_02.jpg" width="502"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Connecting A to B and B to A in a directed graph</p>
<ul>
<li><strong class="bold">Acyclic</strong>: This <a id="_idIndexMarker186"/>means that there can’t be any cycles in the graph. A cycle is introduced when we can go back to a given node after following the path from one of its children. If this happens, our frame graph will enter an infinite loop.</li>
</ul>
<div><div><img alt="Figure 4.3 – An example of a graph containing a cycle" height="350" src="img/B18395_04_03.jpg" width="512"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – An example of a graph containing a cycle</p>
<p>In the case of a frame graph, each node represents a rendering pass: depth prepass, g-buffer, lighting, and so on. We don’t define the edges explicitly. Instead, each node will define a number of outputs and, if needed, a number of inputs. An edge is then implied when the <a id="_idIndexMarker187"/>output of a given pass is used as input in another pass.</p>
<div><div><img alt="Figure 4.4 – An example of a full frame graph" height="366" src="img/B18395_04_04.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – An example of a full frame graph</p>
<p>These two concepts, nodes and edges, are all that is needed to understand a frame graph. Next, we are going to present how we decided to encode this data structure.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>A data-driven approach</h2>
<p>Some engines only provide a code interface to build a frame graph, while others let developers <a id="_idIndexMarker188"/>specify the graph in a human-readable format – JSON for example – so that making changes to the graph doesn’t necessarily require code changes.</p>
<p>After some <a id="_idIndexMarker189"/>consideration, we have decided to define our graph in JSON and implement a parser to instantiate the classes required. There are a few reasons we opted for this approach:</p>
<ul>
<li>It allows us to make some changes to the graph without having to recompile the code. If, for instance, we want to change the size or format of a render target, all we have to do is make the change in the JSON definition of the graph and rerun the program.</li>
<li>We can also reorganize the graph and remove some of its nodes without making changes to the code.</li>
<li>It’s easier to understand the flow of the graph. Depending on the implementation, the definition of the graph in code could be spread across different code locations or even different files. This makes it harder to determine the graph structure.</li>
<li>It’s easier for non-technical contributors to make changes. The graph definition could also be done through a visual tool and translated into JSON. The same approach wouldn’t be feasible if the graph definition was done purely in code.</li>
</ul>
<p>We can <a id="_idIndexMarker190"/>now have a look at a node in our frame graph:</p>
<pre class="source-code">
{
    "inputs":
    [
        {
            "type": "attachment",
            "name": "depth"
        }
    ],
    "name": "gbuffer_pass",
    "outputs":
    [
        {
            "type": "attachment",
            "name": "gbuffer_colour",
            "format": "VK_FORMAT_B8G8R8A8_UNORM",
            "resolution": [ 1280, 800 ],
            "op": "VK_ATTACHMENT_LOAD_OP_CLEAR"
        },
        {
            "type": "attachment",
            "name": "gbuffer_normals",
            "format": "VK_FORMAT_R16G16B16A16_SFLOAT",
            "resolution": [ 1280, 800 ],
            "op": "VK_ATTACHMENT_LOAD_OP_CLEAR"
        },
        ...
    ]
}</pre>
<p>A node is defined by three variables:</p>
<ul>
<li><code>name</code>: This helps <a id="_idIndexMarker191"/>us identify the node during execution, and it also gives us a meaningful name for other elements, for instance, the render pass associated with this node.</li>
<li><code>inputs</code>: This lists <a id="_idIndexMarker192"/>the inputs for this node. These are resources that have been produced by another node. Note that it would be an error to define an input that has not been produced by another node in the graph. The only exceptions are external resources, which are managed outside the render graph, and the user will have to provide them to the graph at runtime.</li>
<li><code>outputs</code>: These <a id="_idIndexMarker193"/>are the resources produced by a given node.</li>
</ul>
<p>We have defined four different types of resources depending on their use:</p>
<ul>
<li><code>attachment</code>: The list <a id="_idIndexMarker194"/>of attachments is used to determine the render pass and framebuffer composition of a given node. As you noticed in the previous example, attachments can be defined both for inputs and outputs. This is needed to continue working on a resource in multiple nodes. After we run a depth prepass, for instance, we want to load the depth data <a id="_idIndexMarker195"/>and use it during the g-buffer pass to avoid shading pixels for objects that are hidden behind other objects.</li>
<li><code>texture</code>: This type is used to distinguish images from attachments. An attachment <a id="_idIndexMarker196"/>has to be part of the definition of the render pass and framebuffer for a node, while a texture is read during the pass and is part of a shader data definition.</li>
</ul>
<p>This distinction is also important to determine which images need to be transitioned to a different layout and require an image barrier. We’ll cover this in more detail later in the chapter.</p>
<p>We don’t need to specify the size and format of the texture here, as we had already done so when we first defined the resource as an output.</p>
<ul>
<li><code>buffer</code>: This type <a id="_idIndexMarker197"/>represents a storage buffer that we can write to or read from. As with textures, we will need to insert memory barriers to ensure the writes from a previous pass are completed before accessing the buffer data in another pass.</li>
<li><code>reference</code>: This type <a id="_idIndexMarker198"/>is used exclusively to ensure the right edges between nodes are computed without creating a new resource.</li>
</ul>
<p>All types are <a id="_idIndexMarker199"/>quite intuitive, but we feel that the reference type deserves an example to better understand why we need this type:</p>
<pre class="source-code">
{
    "inputs":
    [
        {
            "type": "attachment",
            "name": "lighting"
        },
        {
            "type": "attachment",
            "name": "depth"
        }
    ],
    "name": "transparent_pass",
    "outputs":
    [
        {
            "type": "reference",
            "name": "lighting"
        }
    ]
}</pre>
<p>In this case, lighting is an input resource of the <code>attachment</code> type. When processing the graph, we will correctly link the node that produced the lighting resource to this node. However, we also <a id="_idIndexMarker200"/>need to make sure that the next node that makes use of the lighting resource creates a connection to this node, as otherwise, the node ordering would be incorrect.</p>
<p>For this reason, we add a reference to the lighting resource in the output of the transparent pass. We can’t use the <code>attachment</code> type here as otherwise, we would double count the lighting resource in the creation of the render pass and framebuffer.</p>
<p>Now that you have a good understanding of the frame graph structure, it’s time to look at some code!</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Implementing the frame graph</h2>
<p>In this section, we are going to define the data structures that are going to be used throughout <a id="_idIndexMarker201"/>the chapter, namely resources and nodes. Next, we are going to parse the JSON definition of the graph to create resources and nodes that will be used for subsequent steps.</p>
<p>Let’s start with the definition of our data structures.</p>
<h3>Resources</h3>
<p><strong class="bold">Resources</strong> define an <a id="_idIndexMarker202"/>input or an output of a node. They determine <a id="_idIndexMarker203"/>the use of the resource for a given node and, as we will explain later, they are used to define edges between the frame graph nodes. A resource is structured as follows:</p>
<pre class="source-code">
struct FrameGraphResource {
    FrameGraphResourceType type;
    FrameGraphResourceInfo resource_info;
    FrameGraphNodeHandle producer;
    FrameGraphResourceHandle output_handle;
    i32 ref_count = 0;
    const char* name = nullptr;
};</pre>
<p>A resource can be either an input or an output of a node. It’s worth going through each field in the following list:</p>
<ul>
<li><code>type</code>: Defines <a id="_idIndexMarker204"/>whether we are dealing with an image or a buffer.</li>
<li><code>resource_info</code>: Contains <a id="_idIndexMarker205"/>the details about the resource (such as size, format, and so on) based on <code>type</code>.</li>
<li><code>producer</code>: Stores a <a id="_idIndexMarker206"/>reference to the node that outputs a resource. This will be used to determine the edges of the graph.</li>
<li><code>output_handle</code>: Stores <a id="_idIndexMarker207"/>the parent resource. It will become clearer later why we need this field.</li>
<li><code>ref_count</code>: Will be <a id="_idIndexMarker208"/>used when computing which resources can be aliased. Aliasing is a technique that allows multiple resources to share the same memory. We will provide more details on how this works later in this chapter.</li>
<li><code>name</code>: Contains <a id="_idIndexMarker209"/>the name of the resource as defined in JSON. This is useful for debugging and also to retrieve the resource by name.</li>
</ul>
<p>Next, we are <a id="_idIndexMarker210"/>going to look at a graph node:</p>
<pre class="source-code">
struct FrameGraphNode {
    RenderPassHandle render_pass;
    FramebufferHandle framebuffer;
    FrameGraphRenderPass* graph_render_pass;
    Array&lt;FrameGraphResourceHandle&gt; inputs;
    Array&lt;FrameGraphResourceHandle&gt; outputs;
    Array&lt;FrameGraphNodeHandle&gt; edges;
    const char* name = nullptr;
};</pre>
<p>A node stores the list of inputs it will use during execution and the outputs it will produce. Each input and output is a different instance of <code>FrameGraphResource</code>. The <code>output_handle</code> field is used to link an input to its output resource. We need separate resources because their type might differ; an image might be used as an output attachment and then used as an input texture. This is an important detail that will be used to automate memory barrier placement.</p>
<p>A node also <a id="_idIndexMarker211"/>stores a list of the nodes it is connected to, its name, the framebuffer, and the render pass created according to the definition of its inputs and outputs. Like resources, a node also stores its name as defined on JSON.</p>
<p>Finally, a node contains a pointer to the rendering implementation. We’ll discuss later how we link a node to its rendering pass.</p>
<p>These are the main data structures used to define our frame graph. We have also created a <code>FrameGraphBuilder</code> helper class that will be used by the <code>FrameGraph</code> class. The <code>FrameGraphBuilder</code> helper class contains the functionality to create nodes and resources.</p>
<p>Let’s see how these building blocks are used to define our frame graph!</p>
<h3>Parsing the graph</h3>
<p>Now that <a id="_idIndexMarker212"/>we have defined the data structures that make our graph, we need to parse the JSON definition of the graph to fill those structures and create our frame graph definition. Here are the steps that need to be executed to parse the frame graph:</p>
<ol>
<li>We start by initializing a <code>FrameGraphBuilder</code> and <code>FrameGraph</code> class:<pre class="source-code">
FrameGraphBuilder frame_graph_builder;</pre><pre class="source-code">
frame_graph_builder.init( &amp;gpu );</pre><pre class="source-code">
FrameGraph frame_graph;</pre><pre class="source-code">
frame_graph.init( &amp;frame_graph_builder );</pre></li>
<li>Next, we call the <code>parse</code> method to read the JSON definition of the graph and create the resources and nodes for it:<pre class="source-code">
frame_graph.parse( frame_graph_path,</pre><pre class="source-code">
                   &amp;scratch_allocator );</pre></li>
<li>Once we have our graph definition, we have our compile step:<pre class="source-code">
frame_graph.compile();</pre></li>
</ol>
<p>This step is <a id="_idIndexMarker213"/>where the magic happens. We analyze the graph to compute the edges between nodes, create the framebuffer and render passes for each class, and determine which resources can be aliased. We are going to explain each of these steps in detail in the next section.</p>
<ol>
<li value="4">Once we have compiled our graph, we need to register our rendering passes:<pre class="source-code">
frame_graph-&gt;builder-&gt;register_render_pass(</pre><pre class="source-code">
    "depth_pre_pass", &amp;depth_pre_pass );</pre><pre class="source-code">
frame_graph-&gt;builder-&gt;register_render_pass(</pre><pre class="source-code">
    "gbuffer_pass", &amp;gbuffer_pass );</pre><pre class="source-code">
frame_graph-&gt;builder-&gt;register_render_pass(</pre><pre class="source-code">
    "lighting_pass", &amp;light_pass );</pre><pre class="source-code">
frame_graph-&gt;builder-&gt;register_render_pass(</pre><pre class="source-code">
    "transparent_pass", &amp;transparent_pass );</pre><pre class="source-code">
frame_graph-&gt;builder-&gt;register_render_pass(</pre><pre class="source-code">
    "depth_of_field_pass", &amp;dof_pass );</pre></li>
</ol>
<p>This allows us to test different implementations for each pass by simply swapping which class we register for a given pass. It’s even possible to swap these passes at runtime.</p>
<ol>
<li value="5">Finally, we are <a id="_idIndexMarker214"/>ready to render our scene:<pre class="source-code">
frame_graph-&gt;render( gpu_commands, scene );</pre></li>
</ol>
<p>We are now going to look at the <code>compile</code> and <code>render</code> methods in detail.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Implementing topological sort</h2>
<p>As we mentioned in the preceding section, the most interesting aspects of the frame graph <a id="_idIndexMarker215"/>implementation are inside the <code>compile</code> method. We have abbreviated some of the code for clarity in the following sections.</p>
<p>Please refer <a id="_idIndexMarker216"/>to the GitHub link mentioned in the <em class="italic">Technical requirements</em> section of the chapter for the full implementation.</p>
<p>Here is a breakdown of the algorithm that we use to compute the edges between nodes:</p>
<ol>
<li value="1">The first step we perform is to create the edges between nodes:<pre class="source-code">
for ( u32 r = 0; r &lt; node-&gt;inputs.size; ++r ) {</pre><pre class="source-code">
    FrameGraphResource* resource = frame_graph-&gt;</pre><pre class="source-code">
        get_resource( node-&gt;inputs[ r ].index );</pre><pre class="source-code">
    u32 output_index = frame_graph-&gt;find_resource(</pre><pre class="source-code">
        hash_calculate( resource-&gt;name ) );</pre><pre class="source-code">
    FrameGraphResource* output_resource = frame_graph</pre><pre class="source-code">
        -&gt;get_resource( output_index );</pre></li>
</ol>
<p>We accomplish this by iterating through each input and retrieving the corresponding output resource. Note that internally, the graph stores the outputs in a map keyed by name.</p>
<ol>
<li value="2">Next, we save the details of the output in the input resource. This way we have direct <a id="_idIndexMarker217"/>access to this data in the input as well:<pre class="source-code">
    resource-&gt;producer = output_resource-&gt;producer;</pre><pre class="source-code">
    resource-&gt;resource_info = output_resource-&gt;</pre><pre class="source-code">
                              resource_info;</pre><pre class="source-code">
    resource-&gt;output_handle = output_resource-&gt;</pre><pre class="source-code">
                              output_handle;</pre></li>
<li>Finally, we <a id="_idIndexMarker218"/>create an edge between the node that produces this input and the node we are currently processing:<pre class="source-code">
    FrameGraphNode* parent_node = ( FrameGraphNode*)</pre><pre class="source-code">
                                    frame_graph-&gt;</pre><pre class="source-code">
                                    get_node(</pre><pre class="source-code">
                                    resource-&gt;</pre><pre class="source-code">
                                    producer.index );</pre><pre class="source-code">
    parent_node-&gt;edges.push( frame_graph-&gt;nodes[</pre><pre class="source-code">
                             node_index ] );</pre><pre class="source-code">
}</pre></li>
</ol>
<p>At the end of this loop, each node will contain the list of nodes it is connected to. While we currently don’t do this, at this stage, it would be possible to remove nodes that have no edges from the graph.</p>
<p>Now that we have computed the connection between nodes, we can sort them in topological order. At the end of this step, we will obtain the list of nodes ordered to ensure that nodes that produce an output come before the nodes that make use of that output.</p>
<p>Here is <a id="_idIndexMarker219"/>a breakdown of the sorting algorithm <a id="_idIndexMarker220"/>where we have highlighted the most relevant sections of the code:</p>
<ol>
<li value="1">The <code>sorted_node</code> array will contain the sorted nodes in reverse order:<pre class="source-code">
Array&lt;FrameGraphNodeHandle&gt; sorted_nodes;</pre><pre class="source-code">
sorted_nodes.init( &amp;local_allocator, nodes.size );</pre></li>
<li>The <code>visited</code> array will be used to mark which nodes we have already processed. We need to keep track of this information to avoid infinite loops:<pre class="source-code">
Array&lt;u8&gt; visited;</pre><pre class="source-code">
visited.init( &amp;local_allocator, nodes.size, nodes.size</pre><pre class="source-code">
);</pre><pre class="source-code">
memset( visited.data, 0, sizeof( bool ) * nodes.size );</pre></li>
<li>Finally, the <code>stack</code> array is used to keep track of which nodes we still have to process. We need this data structure as our implementation doesn’t make use of recursion:<pre class="source-code">
Array&lt;FrameGraphNodeHandle&gt; stack;</pre><pre class="source-code">
stack.init( &amp;local_allocator, nodes.size );</pre></li>
<li>The graph <a id="_idIndexMarker221"/>is traversed by using <strong class="bold">depth-first search</strong> (<strong class="bold">DFS</strong>). The code that follows performs exactly this task:<pre class="source-code">
for ( u32 n = 0; n &lt; nodes.size; ++n ) {</pre><pre class="source-code">
    stack.push( nodes[ n ] );</pre></li>
<li>We iterate through each node and add it to the stack. We do this to ensure we process all the nodes in the graph:<pre class="source-code">
    while ( stack.size &gt; 0 ) {</pre><pre class="source-code">
        FrameGraphNodeHandle node_handle =</pre><pre class="source-code">
            stack.back();</pre></li>
<li>We then <a id="_idIndexMarker222"/>have a second loop that will be active until we have processed all nodes that are connected to the node we just added to the stack:<pre class="source-code">
        if (visited[ node_handle.index ] == 2) {</pre><pre class="source-code">
            stack.pop();</pre><pre class="source-code">
            continue;</pre><pre class="source-code">
        }</pre></li>
</ol>
<p>If a node has already been visited and added to the list of sorted nodes, we simply remove it from the stack and continue processing other nodes. Traditional graph processing implementations don’t have this step.</p>
<p>We had to add it as a node might produce multiple outputs. These outputs, in turn, might link to multiple nodes, and we don’t want to add the producing node multiple times to the sorted node list.</p>
<ol>
<li value="7">If the node we are currently processing has already been visited and we got to it in the stack, it means we processed all of its children, and it can be added to the list of sorted nodes. As mentioned in the following code, we also mark it as added so that we won’t add it multiple times to the list:<pre class="source-code">
        if ( visited[ node_handle.index ]  == 1) {</pre><pre class="source-code">
            visited[ node_handle.index ] = 2; // added</pre><pre class="source-code">
            sorted_nodes.push( node_handle );</pre><pre class="source-code">
            stack.pop();</pre><pre class="source-code">
            continue;</pre><pre class="source-code">
        }</pre></li>
<li>When we first get to a node, we mark it as <code>visited</code>. As mentioned in the following code block, this is needed to make sure we don’t process the same node multiple times:<pre class="source-code">
        visited[ node_handle.index ] = 1; // visited</pre></li>
<li>If the <a id="_idIndexMarker223"/>node we are processing has no edges, we continue to iterate:<pre class="source-code">
        FrameGraphNode* node = ( FrameGraphNode* )</pre><pre class="source-code">
                                 builder-&gt;node_cache.</pre><pre class="source-code">
                                 nodes.access_resource</pre><pre class="source-code">
                                 ( node_handle.index</pre><pre class="source-code">
                                );</pre><pre class="source-code">
        // Leaf node</pre><pre class="source-code">
        if ( node-&gt;edges.size == 0 ) {</pre><pre class="source-code">
            continue;</pre><pre class="source-code">
        }</pre></li>
<li>On the other hand, if the node is connected to other nodes, we add them to the stack for processing and then iterate again. If this is the first time you’ve seen an iterative implementation of graph traversal, it might not be immediately clear how it <a id="_idIndexMarker224"/>relates to the recursive implementation. We suggest going through the code a few times until you understand it; it’s a powerful technique that will come in handy at times!<pre class="source-code">
        for ( u32 r = 0; r &lt; node-&gt;edges.size; ++r ) {</pre><pre class="source-code">
            FrameGraphNodeHandle child_handle =</pre><pre class="source-code">
                node-&gt;edges[ r ];</pre><pre class="source-code">
            if ( !visited[ child_handle.index ] ) {</pre><pre class="source-code">
                stack.push( child_handle );</pre><pre class="source-code">
            }</pre><pre class="source-code">
        }</pre></li>
<li>The final step is to iterate through the sorted nodes array and add them to the graph nodes in reverse order:<pre class="source-code">
for ( i32 i = sorted_nodes.size - 1; i &gt;= 0; --i ) {</pre><pre class="source-code">
    nodes.push( sorted_nodes[ i ] );</pre><pre class="source-code">
}</pre></li>
</ol>
<p>We have now completed the topological sorting of the graph! With the nodes sorted, we can now proceed to analyze the graph to identify which resources can be aliased.</p>
<h3>Computing resource aliasing</h3>
<p>Large <a id="_idIndexMarker225"/>frame graphs must deal with hundreds of nodes and resources. The lifetime of these resources might not span the full graph, and this gives us an opportunity to reuse memory for resources that are no longer needed. This <a id="_idIndexMarker226"/>technique is called <strong class="bold">memory aliasing</strong>, as multiple resources can point to the same memory allocation.</p>
<div><div><img alt="Figure 4.5 – An example of resource lifetime across the frame" height="576" src="img/B18395_04_05.jpg" width="1098"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – An example of resource lifetime across the frame</p>
<p>In this example, we can see that the <code>gbuffer_colour</code> resource is not needed for the full frame, and its memory can be reused, for instance, for the <code>final</code> resource.</p>
<p>We first <a id="_idIndexMarker227"/>need to determine the first and last nodes that use a given resource. Once we have the information, we can determine whether a given node can reuse existing memory for its resources. The code that follows implements this technique.</p>
<p>We start by allocating a few helper arrays:</p>
<pre class="source-code">
sizet resource_count = builder-&gt;resource_cache.resources.
                       used_indices;
Array&lt;FrameGraphNodeHandle&gt; allocations;
allocations.init( &amp;local_allocator, resource_count,
                  resource_count );
for ( u32 i = 0; i &lt; resource_count; ++i) {
    allocations[ i ].index = k_invalid_index;
}
Array&lt;FrameGraphNodeHandle&gt; deallocations;
deallocations.init( &amp;local_allocator, resource_count,
                    resource_count );
for ( u32 i = 0; i &lt; resource_count; ++i) {
    deallocations[ i ].index = k_invalid_index;
}
Array&lt;TextureHandle&gt; free_list;
free_list.init( &amp;local_allocator, resource_count );</pre>
<p>They are not strictly needed by the algorithm, but they are helpful for debugging and ensuring <a id="_idIndexMarker228"/>our implementation doesn’t have a bug. The <code>allocations</code> array will track on which node a given resource was allocated.</p>
<p>Similarly, the <code>deallocations</code> array contains the node at which a given resource can be deallocated. Finally, <code>free_list</code> will contain the resources that have been freed and can be reused.</p>
<p>Next, we are going to look at the algorithm that tracks the allocations and deallocations of resources:</p>
<pre class="source-code">
for ( u32 i = 0; i &lt; nodes.size; ++i ) {
    FrameGraphNode* node = ( FrameGraphNode* )builder-&gt;
                             node_cache.nodes.access
                             _resource( nodes[ i ].index );
    for ( u32 j = 0; j &lt; node-&gt;inputs.size; ++j ) {
        FrameGraphResource* input_resource =
            builder-&gt;resource_cache.resources.get(
                node-&gt;inputs[ j ].index );
        FrameGraphResource* resource =
            builder-&gt;resource_cache.resources.get(
                input_resource-&gt;output_handle.index );
        resource-&gt;ref_count++;
    }
}</pre>
<p>First, we loop through all the input resources and increase their reference count each time they <a id="_idIndexMarker229"/>are used as input. We also mark which node allocates the resource in the <code>allocations</code> array:</p>
<pre class="source-code">
for ( u32 i = 0; i &lt; nodes.size; ++i ) {
    FrameGraphNode* node = builder-&gt;get_node(
                           nodes[ i ].index );
    for ( u32 j = 0; j &lt; node-&gt;outputs.size; ++j ) {
        u32 resource_index = node-&gt;outputs[ j ].index;
        FrameGraphResource* resource =
            builder-&gt;resource_cache.resources.get(
                resource_index );</pre>
<p>The next step is to iterate through all the nodes and their outputs. The code that follows is responsible for performing the memory allocations:</p>
<pre class="source-code">
if ( !resource-&gt;resource_info.external &amp;&amp; 
  allocations[ resource_index ].index == 
  k_invalid_index ) { 
      allocations[ resource_index ] = nodes[ i ]; 
if ( resource-&gt;type == 
  FrameGraphResourceType_Attachment ) { 
     FrameGraphResourceInfo&amp; info = 
        resource-&gt;resource_info; 
                if ( free_list.size &gt; 0 ) {
                    TextureHandle alias_texture =
                        free_list.back();
                    free_list.pop();
                    TextureCreation texture_creation{ };
                    TextureHandle handle =
                        builder-&gt;device-&gt;create_texture(
                            texture_creation );
                    info.texture.texture = handle;
                } else {
                    TextureCreation texture_creation{ };
                    TextureHandle handle =
                        builder-&gt;device-&gt;create_texture(
                            texture_creation );
                    info.texture.texture = handle;
                }
            }
         }
    }</pre>
<p>For each <a id="_idIndexMarker230"/>output resource, we first check whether there are any available resources that can be reused. If so, we pass the free resource to the <code>TextureCreation</code> structure. Internally, <code>GpuDevice</code> will use the memory from this resource and bind it to the newly created resource. If no free resources are available, we proceed by creating a new resource.</p>
<p>The last part of the loop takes care of determining which resources can be freed and added to the free list:</p>
<pre class="source-code">
    for ( u32 j = 0; j &lt; node-&gt;inputs.size; ++j ) {
        FrameGraphResource* input_resource =
            builder-&gt;resource_cache.resources.get(
                node-&gt;inputs[ j ].index );
        u32 resource_index = input_resource-&gt;
                             output_handle.index;
        FrameGraphResource* resource =
            builder-&gt;resource_cache.resources.get(
                resource_index );
        resource-&gt;ref_count--;
if ( !resource-&gt;resource_info.external &amp;&amp; 
  resource-&gt;ref_count == 0 ) { 
     deallocations[ resource_index ] = nodes[ i ]; 
if ( resource-&gt;type == 
  FrameGraphResourceType_Attachment || 
  resource-&gt;type == 
  FrameGraphResourceType_Texture ) { 
     free_list.push( resource-&gt;resource_info. 
     texture.texture ); 
            }
         }
    }
}</pre>
<p>We iterate <a id="_idIndexMarker231"/>over the inputs one final time and decrease the reference count of each resource. If the reference count reaches <code>0</code>, it means this is the last node that uses the resource. We save the node in the <code>deallocations</code> array and add the resource to the free list, ready to be used for the next node we are going to process.</p>
<p>This concludes the implementation of the graph analysis. The resources we have created <a id="_idIndexMarker232"/>are used to create the <code>framebuffer</code> object, at which point the graph is ready for rendering!</p>
<p>We are going to cover the execution of the graph in the next section.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Driving rendering with the frame graph</h2>
<p>After the graph has been analyzed, we have all the details we need for rendering. The following <a id="_idIndexMarker233"/>code is responsible for executing each node and ensuring all the resources are in the correct state for use by that node:</p>
<pre class="source-code">
for ( u32 n = 0; n &lt; nodes.size; ++n ) {
    FrameGraphNode*node = builder-&gt;get_node( nodes
                          [ n ].index );
    gpu_commands-&gt;clear( 0.3, 0.3, 0.3, 1 );
    gpu_commands-&gt;clear_depth_stencil( 1.0f, 0 );
for ( u32 i = 0; i &lt; node-&gt;inputs.size; ++i ) { 
   FrameGraphResource* resource = 
   builder-&gt;get_resource( node-&gt;inputs[ i ].index 
   );
if ( resource-&gt;type == 
  FrameGraphResourceType_Texture ) { 
     Texture* texture = 
     gpu_commands-&gt;device-&gt;access_texture( 
     resource-&gt;resource_info.texture.texture 
     ); 
util_add_image_barrier( gpu_commands-&gt; 
    vk_command_buffer, texture-&gt;vk_image, 
    RESOURCE_STATE_RENDER_TARGET, 
    RESOURCE_STATE_PIXEL_SHADER_RESOURCE, 
    0, 1, resource-&gt;resource_info. 
    texture.format == 
    VK_FORMAT_D32_SFLOAT ); 
        } else if ( resource-&gt;type ==
                    FrameGraphResourceType_Attachment ) {
            Texture*texture = gpu_commands-&gt;device-&gt;
                              access_texture( resource-&gt;
                              resource_info.texture.texture
                              ); }
    }</pre>
<p>We first iterate through all the inputs of a node. If the resource is a texture, we insert a barrier to <a id="_idIndexMarker234"/>transition that resource from an attachment layout (for use in a render pass) to a shader stage layout (for use in a fragment shader).</p>
<p>This step is important to make sure any previous writes have completed before we access this resource for reading:</p>
<pre class="source-code">
    for ( u32 o = 0; o &lt; node-&gt;outputs.size; ++o ) {
        FrameGraphResource* resource =
            builder-&gt;resource_cache.resources.get(
                node-&gt;outputs[ o ].index );
        if ( resource-&gt;type ==
             FrameGraphResourceType_Attachment ) {
            Texture* texture =
                gpu_commands-&gt;device-&gt;access_texture(
                    resource-&gt;resource_info.texture.texture
                );
            width = texture-&gt;width;
            height = texture-&gt;height;
        if ( texture-&gt;vk_format == VK_FORMAT_D32_SFLOAT ) {
            util_add_image_barrier(
            gpu_commands-&gt;vk_command_buffer,
            texture-&gt;vk_image, RESOURCE_STATE_UNDEFINED,
            RESOURCE_STATE_DEPTH_WRITE, 0, 1, resource-&gt;
            resource_info.texture.format ==
            VK_FORMAT_D32_SFLOAT );
            } else {
                 util_add_image_barrier( gpu_commands-&gt;
                 vk_command_buffer, texture-&gt;vk_image,
                 RESOURCE_STATE_UNDEFINED,
                 RESOURCE_STATE_RENDER_TARGET, 0, 1,
                 resource-&gt;resource_info.texture.format ==
                 VK_FORMAT_D32_SFLOAT );
            }
        }
    }</pre>
<p>Next, we iterate over the outputs of the node. Once again, we need to make sure the resource is in the correct state to be used as an attachment in the render pass. After this step, our resources are ready for rendering.</p>
<p>The render <a id="_idIndexMarker235"/>targets of each node could all have different resolutions. The following code ensures that our scissor and viewport sizes are correct:</p>
<pre class="source-code">
    Rect2DInt scissor{ 0, 0,( u16 )width, ( u16 )height };
    gpu_commands-&gt;set_scissor( &amp;scissor );
    Viewport viewport{ };
    viewport.rect = { 0, 0, ( u16 )width, ( u16 )height };
    viewport.min_depth = 0.0f;
    viewport.max_depth = 1.0f;
    gpu_commands-&gt;set_viewport( &amp;viewport );</pre>
<p>Once the viewport and scissor are set correctly, we call the <code>pre_render</code> method on each node. This allows each node to perform any operations that must happen outside a render pass. For instance, the render pass for the depth-of-field effect takes the input texture and computes the MIP maps for that resource:</p>
<pre class="source-code">
    node-&gt;graph_render_pass-&gt;pre_render( gpu_commands,
                                         render_scene );</pre>
<p>Finally, we bind the render pass for this node, call the <code>render</code> method of the rendering pass that we registered for this node, and end the loop by ending the render pass:</p>
<pre class="source-code">
    gpu_commands-&gt;bind_pass( node-&gt;render_pass, node-&gt;
                             framebuffer, false );
    node-&gt;graph_render_pass-&gt;render( gpu_commands,
                                     render_scene );
    gpu_commands-&gt;end_current_render_pass();
}</pre>
<p>This concludes the code overview for this chapter! We have covered a lot of ground; this is a good time for a brief recap: we started with the definition of the main data structures used by our frame graph implementation. Next, we explained how the graph is parsed to compute the edges between nodes by using inputs and outputs.</p>
<p>Once this <a id="_idIndexMarker236"/>step is completed, we can sort the nodes in topological order to ensure they are executed in the correct order. We then create the resources needed to execute the graph and make use of memory aliasing to optimize memory usage. Finally, we iterate over each node for rendering, making sure that all resources are in the correct state for that node.</p>
<p>There are some features that we haven’t implemented and that could improve the functionality and robustness of our frame graph. For example, we should ensure there are no loops in the graph and that an input isn’t being produced by the same node it’s being used in.</p>
<p>For the memory aliasing implementation, we use a greedy approach and simply pick the first free resource that can accommodate a new resource. This can lead to fragmentation and suboptimal use of memory.</p>
<p>We encourage you to experiment with the code and improve on it!</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Summary</h1>
<p>In this chapter, we implemented a frame graph to improve the management of rendering passes and make it easier to expand our rendering pipeline in future chapters. We started by covering the basic concepts, nodes and edges, that define a graph.</p>
<p>Next, we gave an overview of the structure of our graph and how it’s encoded in JSON format. We also mentioned why we went for this approach as opposed to defining the graph fully in code.</p>
<p>In the last part, we detailed how the graph is processed and made ready for execution. We gave an overview of the main data structures used for the graph, and covered how the graph is parsed to create nodes and resources, and how edges are computed. Next, we explained the topological sorting of nodes, which ensures they are executed in the correct order. We followed that with the memory allocation strategy, which allows us to reuse memory from resources that are no longer needed at given nodes. Finally, we provided an overview of the rendering loop and how we ensure that resources are in the correct state for rendering.</p>
<p>In the next chapter, we are going to take advantage of the techniques we have developed in the last two chapters. We are going to leverage multithreading and our frame graph implementation to demonstrate how to use compute and graphics pipelines in parallel for cloth simulation.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Further reading</h1>
<p>Our implementation has been heavily inspired by the implementation of a frame graph in the Frostbite engine, and we recommend watching this presentation: <a href="https://www.gdcvault.com/play/1024045/FrameGraph-Extensible-Rendering-Architecture-in">https://www.gdcvault.com/play/1024045/FrameGraph-Extensible-Rendering-Architecture-in</a>.</p>
<p>Many other engines implement a frame graph to organize and optimize their rendering pipeline. We encourage you to look at other implementations and find the solution that best fits your needs!</p>
</div>
</div></body></html>