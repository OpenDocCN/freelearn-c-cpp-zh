<html><head></head><body>
        

                            
                    <h1 class="header-title">Repeating Method Invocation Using Recursive Algorithm</h1>
                
            
            
                
<p>In the last chapter, you learned about immutable states that make us not deal with the side effect. In this chapter, let's take a look at the concept of recursion. As a programmer in object-oriented programming, we usually use iteration to repeat the process instead of recursion. However, recursion gives more benefit than iteration. For instance, some problems (mathematics, especially) are solved easily using recursion, and, fortunately, all algorithms can be defined recursively. That makes it much, much easier to visualize and prove. To get to know more about the recursion, the following topics will be discussed in this chapter:</p>
<ul>
<li>Differentiating the iteration and recursion invocation</li>
<li>Recurring the immutable function</li>
<li>Finding a better way in recursion using tail recursion</li>
<li>Enumerating three kinds of recursion--functional, procedural, and backtracking recursion</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Repeating the function invocation recursively</h1>
                
            
            
                
<p>As a programmer, especially in object-oriented programming, we usually use the iteration technique to repeat our process. For now, we will discuss the recursion method to repeat our process and use it in the functional approach. Basically, recursion and iteration perform the same task, which is to solve a complicated task piece by piece then combine the results. However, they have a difference. The iteration process emphasizes that we should keep repeating the process until the task is done, whereas recursion emphasizes that need to break the task up into smaller pieces until we can solve the task, then combine the result. We can use the iteration process when we need to run a certain process until the limit is reached or read a stream until it reaches <kbd>eof()</kbd>. Also, recursion can give the best value when we use it, for instance, on the calculation of a factorial.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing the iteration procedure to repeat the process</h1>
                
            
            
                
<p>We will start with the iteration process. As we discussed earlier, the calculation of a factorial will be better if it's designed using the recursion approach. However, it's possible as well to design it with the iteration approach. Here, we will have a <kbd>factorial_iteration_do_while.cpp</kbd> code that we can use to calculate the factorial. We will have a function named <kbd>factorial ()</kbd> that passes a single parameter that will calculate the factorial value we pass in the argument. The code should look like this:</p>
<pre class="mce-root">
    /* factorial_iteration_do_while.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function containing<br/>    // do-while loop iteration<br/><br/>    int factorial (int n)<br/>    {<br/>      int result = 1;<br/>      int i = 1;<br/><br/>      // Running iteration using do-while loop<br/>      do<br/>       {<br/>         result *= i;<br/>       }<br/>       while(++i &lt;= n);<br/><br/>       return result;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[factorial_iteration_do_while.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking factorial() function nine times<br/>      for(int i = 1; i &lt; 10; ++i)<br/>      {<br/>        cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorial(i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    } 
</pre>
<p>As we can see in the preceding code, we depend on the value of <kbd>n</kbd>, which we pass to the <kbd>factorial()</kbd> function, in determining how many iterations will occur. Every time the iteration performs, the <kbd>result</kbd> variable will be multiplied by the counter <kbd>i</kbd>. At the end, the <kbd>result</kbd> variable will hold the last result by combining the iteration's result value. The output we should get on the screen is as follows:</p>
<div><img class=" image-border" src="img/444549f8-8a38-48bb-b1e5-2be38e9f7bee.png"/></div>
<p>Another technique in an iteration is using another iteration procedure. We can refactor the preceding code to use the <kbd>for</kbd> loop in the <kbd>factorial()</kbd> function. The following is the <kbd>factorial_iteration_for.cpp</kbd> code that is refactored from our preceding <kbd>factorial_iteration_do_while.cpp</kbd> code:</p>
<pre>
    /* factorial_iteration_do_while.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function containing<br/>    // for loop iteration<br/>    int factorial (int n)<br/>    {<br/>      int result = 1;<br/><br/>      <strong>// Running iteration using for loop</strong><br/><strong>      for(int i = 1; i &lt;= n; ++i)</strong><br/><strong>      {</strong><br/><strong>        result *= i;</strong><br/><strong>      }</strong><br/><br/>      return result;<br/>     }<br/><br/>     auto main() -&gt; int<br/>     {<br/>      cout &lt;&lt; "[factorial_iteration_for.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking factorial() function nine times<br/>      for(int i = 1; i &lt; 10; ++i)<br/>       {<br/>         cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorial(i) &lt;&lt; endl;<br/>       }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, we replace the <kbd>do-while</kbd> loop with the <kbd>for</kbd> loop. However, the behavior of the program will be exactly the same, since it will also multiply the current result with the <kbd>i</kbd> counter each time the iteration performs. At the end of this iteration, we will obtain the final result from this multiplication process. The screen should display the following output:</p>
<div><img class=" image-border" src="img/c604f1cb-6277-4b29-a074-4bbf92bd02bc.png"/></div>
<p>Now that we have successfully performed iteration to gain the factorial purpose, either use the <kbd>do-while</kbd> or <kbd>for</kbd> loop.</p>
<p>It looks too trivial when we try to refactor the <kbd>do-while</kbd> loop into the <kbd>for</kbd> loop. As we may know, <kbd>for</kbd> loops allow us to run through the loop when we know how many times we'd like it to run through the problem, while the <kbd>do-while</kbd> loops give us more flexibility in what we put in it and when it will stop, for instance <kbd>while(i &gt; 0)</kbd> or use a Boolean value such as <kbd>while(true)</kbd>. However, based on the preceding example, we now can say that we can switch the <kbd>for</kbd> loop or the <kbd>do-while</kbd> loop into recursion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing the recursion procedure to repeat the process</h1>
                
            
            
                
<p>We discussed earlier that recursion gives better performance in functional programming. We also developed the <kbd>factorial()</kbd> function in the iteration approach. Now, let's refactor our previous code into <kbd>factorial_recursion.cpp</kbd>, which will use the recursion approach rather than the iteration one. The code will perform the same task comparing our previous code. However, we will modify the <kbd>factorial()</kbd> function to call itself at the end of the function. The code is written as follows:</p>
<pre>
    /* factorial_recursion.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    int factorial(int n)<br/>    {<br/>      // Running recursion here<br/>      if (n == 0)<br/>        return 1;<br/>      else<br/>        return n * factorial (n - 1);<br/>    }<br/> <br/>    auto main() -&gt; int<br/>    {<br/>       cout &lt;&lt; "[factorial_recursion.cpp]" &lt;&lt; endl;<br/><br/>      for(int i = 1; i &lt; 10; ++i)<br/>      {<br/>        cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorial(i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, the <kbd>factorial()</kbd> function in the preceding code calls itself until <kbd>n</kbd> is <kbd>0</kbd>. Each time the function calls itself, it decrements the <kbd>n</kbd> parameter. The function will return <kbd>1</kbd> soon after the passed parameter is <kbd>0</kbd>. We will also get the same output compared to our two previous code blocks, as shown in the following screenshot:</p>
<div><img class=" image-border" src="img/b9c6c1c3-250a-4a02-961f-1ae358de0e60.png"/></div>
<p>Although recursion gives us the simplicity required to easily maintain code, we have to be aware of the parameter we pass to the recursion function. For instance, in the <kbd>factorial()</kbd> function in the <kbd>factorial_recursion.cpp</kbd> code, if we pass the negative number to the <kbd>n &lt; 0</kbd> function, we will get the infinity loop, and it can crash our device.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recurring the immutable function</h1>
                
            
            
                
<p>As we discussed in the previous chapter, we need to loop the immutable function recursively. Let's suppose we have the <kbd>fibonacci()</kbd> function that is immutable. We then need to refactor it to be a recursive function. The <kbd>fibonacci_iteration.cpp</kbd> code implements the <kbd>fibonacci()</kbd> function in the iteration way. The code is written as follows:</p>
<pre>
    /* fibonacci_iteration.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function for generating<br/>    // Fibonacci sequence using iteration<br/>    int fibonacci(int n)<br/>    {<br/>      if (n == 0)<br/>        return 0;<br/><br/>      int previous = 0;<br/>      int current = 1;<br/><br/>      for (int i = 1; i &lt; n; ++i)<br/>      {<br/>        int next = previous + current;<br/>        previous = current;<br/>        current = next;<br/>      }<br/><br/>      return current;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[fibonacci_iteration.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking fibonacci() function ten times<br/>      for(int i = 0; i &lt; 10; ++i)<br/>       {<br/>         cout &lt;&lt; fibonacci(i) &lt;&lt; " ";<br/>       }<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, the <kbd>fibonacci()</kbd> function is immutable since it will return the same value each time it gets the exact same <kbd>n</kbd> input. The output should look like the following screenshot:</p>
<div><img class=" image-border" src="img/bb62a358-6e52-44fb-9628-d55839169d48.png"/></div>
<p>If we need to refactor it to be a recursive function, we can use the following <kbd>fibonacci_recursion.cpp</kbd> code:</p>
<pre>
    /* fibonacci_recursion.cpp */<br/>    #include &lt;iostream&gt;<br/>   <br/>    using namespace std;<br/><br/>    // Function for generating<br/>    // Fibonacci sequence using recursion<br/>    int fibonacci(int n)<br/>    {<br/>      if(n &lt;= 1)<br/>        return n;<br/><br/>      return fibonacci(n-1) + fibonacci(n-2);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[fibonacci_recursion.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking fibonacci() function ten times<br/>      for(int i = 0; i &lt; 10; ++i)<br/>      {<br/>        cout &lt;&lt; fibonacci(i) &lt;&lt; " ";<br/>      }<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, the preceding code has the recursion approach since it calls the function itself at the end of the function. Now that we have the recursion <kbd>fibonacci()</kbd> function, it will give the following output on the console:</p>
<div><img class=" image-border" src="img/cb853f00-201a-493a-b561-5eed14833299.png"/></div>
<p>Now, compared to the <kbd>fibonacci_iteration.cpp</kbd> code, the <kbd>fibonacci_recursion.cpp</kbd> code shows the exact same output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting closer to tail recursion</h1>
                
            
            
                
<p>A tail recursion happens when the recursive call is executed at the end by the function. It's considered better than the non-tail recursion code we developed previously because the compiler can optimize the code better. Since the recursive call is the last statement that is executed by the function, there is nothing more to do in this function. The result is that the compiler does not need to save the current function's stack frame. Let's see the following <kbd>tail_recursion.cpp</kbd> code implementing tail recursion:</p>
<pre>
    /* tail_recursion.cpp */<br/>    #include &lt;iostream&gt;<br/> <br/>    using namespace std;<br/><br/>    void displayNumber(long long n)<br/>    {<br/>      // Displaying the current n value<br/>      cout &lt;&lt; n &lt;&lt; endl;<br/>    <br/>      // The last executed statement <br/>      // is the recursive call<br/>      displayNumber(n + 1);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[tail_recursion.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking the displayNumber() function<br/>      // containing tail recursion<br/>      displayNumber(0);<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, the <kbd>displayNumber()</kbd> function is a tail recursive call function since it calls itself at the end of the process. Indeed, if we run the preceding <kbd>tail_recursion.cpp</kbd> code, the program will not end since it will increase the value of <kbd>n</kbd> in the <kbd>displayNumber()</kbd> function. The program may be crashed when the value of <kbd>n</kbd> has reached the maximum value of the <kbd>long long</kbd> data type. However, the program will not have the stack issued (stack overflowed) since the tail recursion doesn't store a value in the stack.</p>
<p>Also, we can refactor the preceding <kbd>displayNumber()</kbd> function in the <kbd>tail_recursion.cpp</kbd> code to use the <kbd>goto</kbd> keyword instead of calling the function over and over. The refactored code can be seen in the following <kbd>tail_recursion_goto.cpp</kbd> code:</p>
<pre>
    /* tail_recursion_goto.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void displayNumber(long long n)<br/>    {<br/><strong>      loop:</strong><br/>        // Displaying the current n value<br/>        cout &lt;&lt; n &lt;&lt; endl;<br/><br/>       <strong>// Update parameters of recursive call</strong><br/><strong>       // and replace recursive call with goto</strong><br/><strong>       n++;</strong><br/><strong>       goto loop;</strong><br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[tail_recursion_goto.cpp]" &lt;&lt; endl;<br/><br/>      // Invoking the displayNumber() function<br/>      // containing tail recursion<br/>      displayNumber(0);<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we can remove the last call in the <kbd>displayNumber()</kbd> function with the <kbd>goto</kbd> keyword. This is how the compiler optimizes the tail recursion by performing a tail-call elimination that will replace the last call with the <kbd>goto</kbd> keyword. We will also see that no stack is needed in the <kbd>displayNumber()</kbd> function.</p>
<p>Don't forget to compile the code containing a tail recursion with the optimization option provided by the compiler. Since we use GCC, always enable optimization level 2 (<kbd>-O2</kbd>) to gain the optimized code. The effect of not compiling with optimizations enabled, is that our two preceding programs (<kbd>tail_recursion.cpp</kbd> and <kbd>tail_recursion_goto.cpp</kbd>) will crash with the stack overflowed issue. For more information about the optimizations option in GCC, check out <a href="https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Optimize-Options.html">https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Optimize-Options.html</a>.</p>
<p>Now, let's create a useful tail recursion call. In the previous section, we have successfully refactored our iteration function into a recursive one. The <kbd>factorial()</kbd> function now has become a recursive function and calls itself at the end of the function. However, it is not tail recursion, although the function calls itself at the end of the function. If we look closer, the value returned by <kbd>factorial(n-1)</kbd> is used in <kbd>factorial(n)</kbd>, so the call to <kbd>factorial(n-1)</kbd> is not the last thing done by <kbd>factorial(n)</kbd>.</p>
<p>We can create our <kbd>factorial_recursion.cpp</kbd> code to become the tail recursion function. We will develop the following <kbd>factorial_recursion_tail.cpp</kbd> code, modify the <kbd>factorial()</kbd> function, and add a new function named <kbd>factorialTail()</kbd>. The code is written as follows:</p>
<pre>
    /* factorial_recursion_tail.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/><strong>    // Function for calculating factorial</strong><br/><strong>    // tail recursion</strong><br/><strong>    int factorialTail(int n, int i)</strong><br/><strong>    {</strong><br/><strong>      if (n == 0)</strong><br/><strong>        return i;</strong><br/> <br/><strong>      return factorialTail(n - 1, n * i);</strong><br/><strong>    }<br/></strong><br/><strong>    // The caller of tail recursion function</strong><br/><strong>    int factorial(int n)</strong><br/><strong>    {</strong><br/><strong>      return factorialTail(n, 1);</strong><br/><strong>    }</strong><br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[factorial_recursion_tail.cpp]" &lt;&lt; endl;<br/>    <br/>      // Invoking fibonacci() function ten times<br/>      for(int i = 1; i &lt; 10; ++i)<br/>      {<br/>        cout &lt;&lt; i &lt;&lt; "! = " &lt;&lt; factorial(i) &lt;&lt; endl;<br/>      }<br/><br/>     return 0;<br/>    }
</pre>
<p>As we can see, we have moved the <kbd>factorial()</kbd> function in the <kbd>factorial_recursion.cpp</kbd> code to the <kbd>factorialTail()</kbd> function that requires two arguments in the <kbd>factorial_recursion_tail.cpp</kbd> code. As the result, after we invoke <kbd>factorial(i)</kbd>, it will then invoke the <kbd>factorialTail()</kbd> function. At the end of this function, the <kbd>factorialTail()</kbd> function is the only function that is invoked. The following image is the output of the <kbd>factorial_recursion_tail.cpp</kbd> code, which is exactly the same as the <kbd>factorial_recursion.cpp</kbd> code. It also proves that we have successfully refactored the <kbd>factorial_recursion.cpp</kbd> code into tail recursion.</p>
<div><img class=" image-border" src="img/de6f4d4b-d59c-40cc-8ed7-f041a58a3d1b.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting acquainted with functional, procedural, and backtracking recursion</h1>
                
            
            
                
<p>So now that we have understood a little about recursion, the recursion function will call itself from inside its body. The recursion will be stopped only when it has reached a certain value. There are three types of recursion that we will discuss right away--<strong>functional recursion</strong>, <strong>procedural recursion</strong>, and <strong>backtracking recursion</strong>; however, these three types of recursion may not be standard terms. Functional recursion is a recursion process that returns some value. Procedural recursion is a recursion process that doesn't return a value, yet performs the action in each recursion it takes. Backtracking recursion is a recursion process to break down the task into a small set of subtasks that can be cancelled if they don't work. Let's consider these recursion types in the following discussion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expecting results from functional recursion</h1>
                
            
            
                
<p>In functional recursion, the process tries to solve the problem by combining the results from the subproblems recursively. The result we combine comes from the return value of subproblems. Let's suppose we have a problem to calculate a number to a power, for instance, <kbd>2</kbd> power <kbd>2</kbd> is <kbd>4</kbd> (<kbd>2<sup>2</sup> = 4</kbd>). By using iteration, we can build a code like the following <kbd>exponential_iteration.cpp</kbd> code. We have a function named <kbd>power()</kbd> that will be passed by two arguments--<kbd>base</kbd> and <kbd>exp</kbd>. The notation will be <kbd>base<sup>exp</sup></kbd> and the code looks like this:</p>
<pre>
    /* exponential_iteration.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Calculating the power of number<br/>    // using iteration<br/>    int power(int base, int exp)<br/>    {<br/>      int result = 1;<br/> <br/>      for(int i = 0; i &lt; exp; ++i)<br/>       {<br/>         result *= base;<br/>       }<br/><br/>       return(result);<br/>    } <br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[exponential_iteration.cpp]" &lt;&lt; endl;<br/> <br/>      // Invoking power() function six times<br/>      for(int i = 0; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "power (2, " &lt;&lt; i &lt;&lt; ") = ";<br/>        cout &lt;&lt; power(2, i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we use the iteration version first, before we go to the recursive one, since we usually use the iteration most on a daily basis. We combine the <kbd>result</kbd> value in each iteration by multiplying it by the <kbd>base</kbd> value. If we run the preceding code, we will get the following output on the console:</p>
<div><img class=" image-border" src="img/84a5e00c-542f-40cc-b398-d5124ddb94e3.png"/></div>
<p>Now, let's refactor our preceding code to the recursive version. We will have the <kbd>exponential_recursion.cpp</kbd> code that will have the same <kbd>power()</kbd> function signature. However, we will not use the <kbd>for</kbd> loop instead of the recursion that the function calls itself at the end of the function. The code should be written as follows:</p>
<pre>
    /* exponential_recursion.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Calculating the power of number<br/>    // using recursion<br/>    int power(int base, int exp)<br/>    {<br/>      if(exp == 0)<br/>        return 1;<br/>      else<br/>        return base * power(base, exp - 1);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[exponential_recursion.cpp]" &lt;&lt; endl;<br/> <br/>      // Invoking power() function six times<br/>      for(int i = 0; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "power (2, " &lt;&lt; i &lt;&lt; ") = ";<br/>        cout &lt;&lt; power(2, i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we discussed earlier that functional recursion returns value, the <kbd>power()</kbd> function is a functional recursion since it returns the <kbd>int</kbd> value. We will get the final result from the value returned by each subfunction. As a result, we will get the following output on the console:</p>
<div><img class=" image-border" src="img/2488e227-b4d4-4275-98c4-a499df6d85de.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running a task recursively in procedural recursion</h1>
                
            
            
                
<p>So, we have a functional recursion that expects the return value from the function. Sometimes, we don't need the return value since we run the task from inside the function. To achieve that purpose, we can use procedural recursion. Let's suppose we want to permute a short string to find all possible arrangements of it. Instead of returning the value, we just need to print the result every time the recursion is performed.</p>
<p>We have the following <kbd>permutation.cpp</kbd> code to demonstrate this task. It has the <kbd>permute()</kbd> function that will be invoked once, then it will invoke the <kbd>doPermute()</kbd> function recursively. The code should be written as follows:</p>
<pre>
    /* permutation.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Calculation the permutation<br/>    // of the given string<br/>    void doPermute(<br/>      const string &amp;chosen,<br/>      const string &amp;remaining)<br/>      {<br/>       if(remaining == "")<br/>       {<br/>          cout &lt;&lt; chosen &lt;&lt; endl;<br/>       }<br/>       else<br/>       {<br/>         for(uint32_t u = 0; u &lt; remaining.length(); ++u)<br/>         {<br/>            doPermute(<br/>              chosen + remaining[u],<br/>              remaining.substr(0, u)<br/>              + remaining.substr(u + 1));<br/>         }<br/>       }<br/>    }     <br/><br/>    // The caller of doPermute() function<br/>    void permute(<br/>      const string &amp;s)<br/>    {<br/>      doPermute("", s);<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[permutation.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing str variable<br/>      // then ask user to fill in<br/>      string str;<br/>      cout &lt;&lt; "Permutation of a string" &lt;&lt; endl;<br/>      cout &lt;&lt; "Enter a string: ";<br/>      getline(cin, str);<br/><br/>      // Finding the possibility of the permutation<br/>      // by calling permute() function<br/>      cout &lt;&lt; endl &lt;&lt; "The possibility permutation of ";<br/>      cout &lt;&lt; str &lt;&lt; endl;<br/>      permute(str);<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we ask the user to input a string, then the code will find the possibility of this permutation using the <kbd>permute()</kbd> function. It will start with the empty string in <kbd>doPermute()</kbd> since the given string from the user is possible also. The output on the console should be as follows:</p>
<div><img class=" image-border" src="img/7b9a4176-1af8-412e-a860-110982c72225.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Backtracking recursion</h1>
                
            
            
                
<p>As we discussed earlier, we can undo the process if the subtask doesn't work. Let's try with a labyrinth where we have to find the way from the starting point to the finishing point. Let's suppose we have to find the way from <kbd>S</kbd> to <kbd>F</kbd> as in the following labyrinth:</p>
<pre>
    # # # # # # # #<br/>    # S           #<br/>    # # #   # # # #<br/>    #   #   # # # #<br/>    #             #<br/>    #   # # # # # #<br/>    #           F #<br/>    # # # # # # # #
</pre>
<p>To solve this problem, we have to decide the route we need, to find the finishing point. However, we will assume that each choice is good until we prove it's not. The recursion will return a Boolean value to mark whether it's the right way or not. If we choose the wrong way, the call stack unwinds and it will undo the choice. First, we will draw the <kbd>labyrinth</kbd> in our code. In the following code, there will be the <kbd>createLabyrinth()</kbd> and <kbd>displayLabyrinth()</kbd> functions. The code looks like this:</p>
<pre>
    /* labyrinth.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;vector&gt;<br/><br/>    using namespace std;<br/><br/>    vector&lt;vector&lt;char&gt;&gt; createLabyrinth()<br/>    {<br/>      // Initializing the multidimensional vector<br/>      // labyrinth <br/>      // # is a wall<br/>      // S is the starting point<br/>      // E is the finishing point<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth = <br/>      {<br/>        {'#', '#', '#', '#', '#', '#', '#', '#'},<br/>        {'#', 'S', ' ', ' ', ' ', ' ', ' ', '#'},<br/>        {'#', '#', '#', ' ', '#', '#', '#', '#'},<br/>        {'#', ' ', '#', ' ', '#', '#', '#', '#'},<br/>        {'#', ' ', ' ', ' ', ' ', ' ', ' ', '#'},<br/>        {'#', ' ', '#', '#', '#', '#', '#', '#'},<br/>        {'#', ' ', ' ', ' ', ' ', ' ', 'F', '#'},<br/>        {'#', '#', '#', '#', '#', '#', '#', '#'}<br/>     };<br/><br/>     return labyrinth;<br/>    }<br/> <br/>    void displayLabyrinth(vector&lt;vector&lt;char&gt;&gt; labyrinth)<br/>    {<br/>      cout &lt;&lt; endl;<br/>      cout &lt;&lt; "====================" &lt;&lt; endl;<br/>      cout &lt;&lt; "The Labyrinth" &lt;&lt; endl;<br/>      cout &lt;&lt; "====================" &lt;&lt; endl;<br/><br/>      // Displaying all characters in labyrinth vector<br/>      for (int i = 0; i &lt; rows; i++)<br/>      {<br/>        for (int j = 0; j &lt; cols; j++)<br/>        {<br/>            cout &lt;&lt; labyrinth[i][j] &lt;&lt; " ";<br/>        }<br/>        cout &lt;&lt; endl;<br/>      }<br/>      cout &lt;&lt; "====================" &lt;&lt; endl &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth = createLabyrinth();<br/>      displayLabyrinth(labyrinth);<br/><br/>      string line;<br/>      cout &lt;&lt; endl &lt;&lt; "Press enter to continue..." &lt;&lt; endl;<br/>      getline(cin, line);<br/> <br/>      return 0;<br/>    }
</pre>
<p>As we can see, there's no recursion in the preceding code. The <kbd>createLabyrinth()</kbd> function just creates a two-dimensional array that contains the pattern of the <kbd>labyrinth</kbd>, whereas <kbd>displayLabyrinth()</kbd> just shows the array to console. We will see the following output on the console if we run the preceding code:</p>
<div><img class=" image-border" src="img/9e5caa72-94f1-4458-9bf4-e723d64e3fa7.png"/></div>
<p>From the preceding screenshot, we can see there are two points there--<kbd>S</kbd> is the starting point and <kbd>F</kbd> is the finishing point. The code has to find the way to reach <kbd>F</kbd> from <kbd>S</kbd>. The expected route should be as follows:</p>
<div><img class=" image-border" src="img/bb949478-e271-4a23-96c1-fdc57ad1d0cf.png"/></div>
<p>The white arrow on the preceding screenshot is a path we expected to reach <kbd>F</kbd> from <kbd>S</kbd>. Now, let's develop the code to solve this labyrinth problem. We will create a function named <kbd>navigate</kbd> to find the possible route by figuring out these three states:</p>
<ul>
<li>If we find <kbd>F</kbd> in the [<em>x</em>,<em>y</em>] position, for instance <kbd>labyrinth[2][4]</kbd>, we have solved the problem then just return <kbd>true</kbd> as the return value.</li>
<li>If the [<em>x</em>,<em>y</em>] position is <kbd>#</kbd>, it means that we face the wall and have to revisit the other [<em>x</em>,<em>y</em>] position.</li>
<li>Otherwise, we print <kbd>*</kbd> on that position to mark that we have visited it.</li>
</ul>
<p>After we have analyzed the three states, we will start with the recursive cases as follows:</p>
<ul>
<li>The path seeker will go upward if it can navigate to <kbd>row - 1</kbd>, and it's greater than or equal to <kbd>0</kbd> (<kbd>row - 1 &gt;= 0 &amp;&amp; navigate(labyrinth, row - 1, col)</kbd>)</li>
<li>The path seeker will go downward if it can navigate to <kbd>row + 1</kbd>, and it's smaller than <kbd>8</kbd> (<kbd>row + 1 &lt; 8 &amp;&amp; navigate(labyrinth, row + 1, col)</kbd>)</li>
<li>The path seeker will go to the left if it can navigate to <kbd>col - 1</kbd>, and it's greater than or equal to <kbd>0</kbd> (<kbd>col - 1 &gt;= 0 &amp;&amp; navigate(labyrinth, row, col - 1)</kbd>)</li>
<li>The path seeker will go to the right if it can navigate to <kbd>col + 1</kbd>, and it's smaller than <kbd>8</kbd> ( <kbd>col + 1 &lt; 8 &amp;&amp; navigate(labyrinth, row, col + 1)</kbd> )</li>
</ul>
<p>We will have the <kbd>navigate()</kbd> function as follows:</p>
<pre>
    bool navigate(<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth,<br/>      int row,<br/>      int col)<br/>    {<br/>      // Displaying labyrinth<br/>      displayLabyrinth(labyrinth);<br/><br/>      cout &lt;&lt; "Checking cell (";<br/>      cout &lt;&lt; row &lt;&lt; "," &lt;&lt; col &lt;&lt; ")" &lt;&lt; endl;<br/><br/>      // Pause 1 millisecond<br/>      // before navigating<br/>      sleep(1);<br/><br/>      if (labyrinth[row][col] == 'F')<br/>      {<br/>        cout &lt;&lt; "Yeayy.. ";<br/>        cout &lt;&lt; "Found the finish flag ";<br/>        cout &lt;&lt; "at point (" &lt;&lt; row &lt;&lt; ",";<br/>        cout &lt;&lt; col &lt;&lt; ")" &lt;&lt; endl;<br/>        return (true);<br/>      }<br/>      else if (<br/>        labyrinth[row][col] == '#' ||<br/>        labyrinth[row][col] == '*')<br/>      {<br/>        return (false);<br/>      }<br/>      else if (labyrinth[row][col] == ' ')<br/>      {<br/>        labyrinth[row][col] = '*';<br/>      }<br/>  <br/>      if ((row + 1 &lt; rows) &amp;&amp;<br/>        navigate(labyrinth, row + 1, col))<br/>        return (true);<br/><br/>      if ((col + 1 &lt; cols) &amp;&amp;<br/>        navigate(labyrinth, row, col + 1))<br/>        return (true);<br/><br/>      if ((row - 1 &gt;= 0) &amp;&amp;<br/>        navigate(labyrinth, row - 1, col))<br/>        return (true);<br/><br/>      if ((col - 1 &gt;= 0) &amp;&amp;<br/>        navigate(labyrinth, row, col - 1))<br/>        return (true);<br/><br/>        return (false);<br/>    }
</pre>
<p>We now have the <kbd>navigate()</kbd> function to find out the correct path to find <kbd>F</kbd>. However, before we run the <kbd>navigate()</kbd> function, we have to ensure that <kbd>S</kbd> is there. We then have to develop the helper function named <kbd>isLabyrinthSolvable()</kbd>. It will loop through the labyrinth array and will inform whether <kbd>S</kbd> is there or not. The following code snippet is the implementation of the <kbd>isLabyrinthSolvable()</kbd> function:</p>
<pre>
    bool isLabyrinthSolvable(<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth)<br/>    {<br/>      int start_row = -1;<br/>      int start_col = -1;<br/>      for (int i = 0; i &lt; rows; i++)<br/>      {<br/>        for (int j = 0; j &lt; cols; j++)<br/>        {<br/>            if (labyrinth[i][j] == 'S')<br/>            {<br/>                start_row = i;<br/>                start_col = j;<br/>                break;<br/>            }<br/>        }<br/>      }<br/><br/>      if (start_row == -1 || start_col == -1)<br/>      {<br/>        cout &lt;&lt; "No valid starting point found!" &lt;&lt; endl;<br/>        return (false);<br/>      }<br/><br/>      cout &lt;&lt; "Starting at point (" &lt;&lt; start_row &lt;&lt; ",";<br/>      cout &lt;&lt; start_col &lt;&lt; ")" &lt;&lt; endl;<br/><br/>      return navigate(labyrinth, start_row, start_col);<br/>    }
</pre>
<p>As we can see in the preceding code snippet, we mention the <kbd>rows</kbd> and <kbd>cols</kbd> variables. We will initialize them as global variables, as we can see in the following code snippet:</p>
<pre>
    const int rows = 8;<br/>    const int cols = 8;
</pre>
<p>Now, let's take a look at the following code if we insert the <kbd>navigate()</kbd> and <kbd>isLabyrinthSolvable()</kbd> functions to the <kbd>labyrinth.cpp</kbd> code:</p>
<pre>
    /* labyrinth.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;vector&gt;<br/><strong>    #include &lt;unistd.h&gt;</strong><br/><br/>    using namespace std;<br/><br/><strong>    const int rows = 8;</strong><br/><strong>    const int cols = 8;</strong><br/><br/>    vector&lt;vector&lt;char&gt;&gt; createLabyrinth()<br/>    {<br/>      // Initializing the multidimensional vector<br/>      // labyrinth<br/>      // # is a wall<br/>      // S is the starting point<br/>      // E is the finishing point<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth =<br/>      {<br/>        {'#', '#', '#', '#', '#', '#', '#', '#'},<br/>        {'#', 'S', ' ', ' ', ' ', ' ', ' ', '#'},<br/>        {'#', '#', '#', ' ', '#', '#', '#', '#'},<br/>        {'#', ' ', '#', ' ', '#', '#', '#', '#'},<br/>        {'#', ' ', ' ', ' ', ' ', ' ', ' ', '#'},<br/>        {'#', ' ', '#', '#', '#', '#', '#', '#'},<br/>        {'#', ' ', ' ', ' ', ' ', ' ', 'F', '#'},<br/>        {'#', '#', '#', '#', '#', '#', '#', '#'}<br/>       };<br/><br/>     return labyrinth;<br/>    }<br/><br/>    void displayLabyrinth(<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth)<br/>    {<br/>      cout &lt;&lt; endl;<br/>      cout &lt;&lt; "====================" &lt;&lt; endl;<br/>      cout &lt;&lt; "The Labyrinth" &lt;&lt; endl;<br/>      cout &lt;&lt; "====================" &lt;&lt; endl;<br/>      // Displaying all characters in labyrinth vector<br/>      for (int i = 0; i &lt; rows; i++)<br/>      {<br/>        for (int j = 0; j &lt; cols; j++)<br/>        {<br/>            cout &lt;&lt; labyrinth[i][j] &lt;&lt; " ";<br/>        }<br/>        cout &lt;&lt; endl;<br/>       }<br/>      cout &lt;&lt; "====================" &lt;&lt; endl &lt;&lt; endl;<br/>    }<br/><br/><strong>    bool navigate(</strong><br/><strong>      vector&lt;vector&lt;char&gt;&gt; labyrinth,</strong><br/><strong>      int row,</strong><br/><strong>      int col)</strong><br/><strong>    {</strong><br/><strong>      // Displaying labyrinth</strong><br/><strong>      displayLabyrinth(labyrinth);</strong><br/><br/><strong>      cout &lt;&lt; "Checking cell (";</strong><br/><strong>      cout &lt;&lt; row &lt;&lt; "," &lt;&lt; col &lt;&lt; ")" &lt;&lt; endl;</strong><br/><br/><strong>      // Pause 1 millisecond</strong><br/><strong>      // before navigating</strong><br/><strong>      sleep(1);</strong><br/><br/><strong>      if (labyrinth[row][col] == 'F')</strong><br/><strong>      {</strong><br/><strong>        cout &lt;&lt; "Yeayy.. ";</strong><br/><strong>        cout &lt;&lt; "Found the finish flag ";<br/>        cout &lt;&lt; "at point (" &lt;&lt; row &lt;&lt; ",";</strong><br/><strong>        cout &lt;&lt; col &lt;&lt; ")" &lt;&lt; endl;</strong><br/><strong>        return (true);</strong><br/><strong>      }</strong><br/><strong>      else if (</strong><br/><strong>        labyrinth[row][col] == '#' ||</strong><br/><strong>        labyrinth[row][col] == '*')</strong><br/><strong>       {</strong><br/><strong>         return (false);</strong><br/><strong>       }</strong><br/><strong>      else if (labyrinth[row][col] == ' ')</strong><br/><strong>      {</strong><br/><strong>        labyrinth[row][col] = '*';</strong><br/><strong>      }</strong><br/><br/><strong>      if ((row + 1 &lt; rows) &amp;&amp;</strong><br/><strong>        navigate(labyrinth, row + 1, col))</strong><br/><strong>        return (true);<br/></strong><br/><strong>      if ((col + 1 &lt; cols) &amp;&amp;</strong><br/><strong>        navigate(labyrinth, row, col + 1))</strong><br/><strong>        return (true);<br/></strong><br/><strong>     if ((row - 1 &gt;= 0) &amp;&amp;</strong><br/><strong>        navigate(labyrinth, row - 1, col))</strong><br/><strong>        return (true);<br/></strong><br/><strong>     if ((col - 1 &gt;= 0) &amp;&amp;</strong><br/><strong>        navigate(labyrinth, row, col - 1))</strong><br/><strong>        return (true);<br/></strong><br/><strong>        return (false);</strong><br/><strong>    }<br/></strong><br/><strong>    bool isLabyrinthSolvable(</strong><br/><strong>      vector&lt;vector&lt;char&gt;&gt; labyrinth)</strong><br/><strong>    {</strong><br/><strong>     int start_row = -1;</strong><br/><strong>     int start_col = -1;</strong><br/><strong>     for (int i = 0; i &lt; rows; i++)</strong><br/><strong>     {</strong><br/><strong>        for (int j = 0; j &lt; cols; j++)</strong><br/><strong>        {</strong><br/><strong>            if (labyrinth[i][j] == 'S')</strong><br/><strong>            {</strong><br/><strong>                start_row = i;</strong><br/><strong>                start_col = j;</strong><br/><strong>                break;</strong><br/><strong>             }</strong><br/><strong>         }</strong><br/><strong>     }</strong><br/><br/><strong>     if (start_row == -1 || start_col == -1)</strong><br/><strong>     {</strong><br/><strong>        cerr &lt;&lt; "No valid starting point found!" &lt;&lt; endl;</strong><br/><strong>        return (false);</strong><br/><strong>     }</strong><br/><br/><strong>     cout &lt;&lt; "Starting at point (" &lt;&lt; start_row &lt;&lt; ",";</strong><br/><strong>     cout &lt;&lt; start_col &lt;&lt; ")" &lt;&lt; endl;</strong><br/><br/><strong>     return navigate(labyrinth, start_row, start_col);</strong><br/><strong>    }</strong><br/><br/>    auto main() -&gt; int<br/>    {<br/>      vector&lt;vector&lt;char&gt;&gt; labyrinth = createLabyrinth();<br/>      displayLabyrinth(labyrinth);<br/><br/>      string line;<br/>      cout &lt;&lt; endl &lt;&lt; "Press enter to continue..." &lt;&lt; endl;<br/>      getline(cin, line);<br/><br/><strong>      if (isLabyrinthSolvable(labyrinth))</strong><br/><strong>        cout &lt;&lt; "Labyrinth solved!" &lt;&lt; endl;</strong><br/><strong>      else</strong><br/><strong>        cout &lt;&lt; "Labyrinth could not be solved!" &lt;&lt; endl;</strong><br/><br/>     return 0;<br/>    }
</pre>
<p>As we can see in the preceding quote, in the <kbd>main()</kbd> function, we first run the <kbd>isLabyrinthSolvable()</kbd> function, which, in turn, invokes the <kbd>navigate()</kbd> function. The <kbd>navigate()</kbd> function will then go through the labyrinth to find out the correct path. The following is the output of the code:</p>
<div><img class=" image-border" src="img/529db26b-9492-4c16-bfba-ea14a2a6061d.png"/></div>
<p>However, if we trace how the program solves the labyrinth, it faces the wrong route when it finds the finish flag, as we can see in the following screenshot:</p>
<div><img class=" image-border" src="img/be30241d-2365-4325-907c-8761c1460abd.png"/></div>
<p>As we can see, there is a white square in the preceding screenshot. It's the wrong choice when it is looking for the correct path. Once it meets an obstacle, it goes back and finds the other ways. It will also undo the choice it has made. Let's see the following screenshot that shows us when the recursion finds another route and undoes the previous choice:</p>
<div><img class=" image-border" src="img/b6bd29c3-e866-4819-8eaf-eb23403b3dc4.png"/></div>
<p>In the preceding screenshot, we can see that the recursion tries another route and the previously failed route has disappeared since the backtrack recursion undoes the route. The recursion now has the correct path, and it can just continue until it finds the finish flag. As a result, we now have successfully developed the backtracking recursion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has given us the technique for repeating the function invocation by using iteration and recursion. However, since recursion is more functional than iteration, we emphasized our discussion on recursion instead of iteration. We started with the difference between iteration and recursion. We then continued the discussion about refactoring the immutable function to become a recursive immutable function.</p>
<p>After we learned about the recursion, we found other better recursion techniques. We also discussed tail recursion to get this improved technique. Lastly, we enumerated three kinds of recursion--functional, procedural, and backtracking recursion. We usually use functional recursion when we expect the return value for the recursion. Otherwise, we use procedural recursion. And, if we need to break down the problem and undo the recursion performance when it doesn't work, we can use backtracking recursion to solve the problem.</p>
<p>In the next chapter, we will discuss lazy evaluation to make the code run faster. This will make the code become efficient since it will make sure that unnecessary code won't be executed.</p>


            

            
        
    </body></html>