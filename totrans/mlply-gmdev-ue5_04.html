<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-85"><a id="_idTextAnchor086"/>4</h1>
<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/>Setting Up Your First Multiplayer Environment</h1>
<p>Setting up a full networked game in UE5 can be an intimidating task. It requires knowledge of networking, coding, and the engine itself, all of which can be overwhelming for even experienced developers. But with the right guidance and some elbow grease, it is possible to create an engaging multiplayer experience in no time (well, sort of...)!</p>
<p>To prevent multiple issues with rethinking and modifications, the first step should be gaining a clear understanding of the project’s topic. This avoids confusion from the onset and enables a smoother workflow. After that, you will need to create an Unreal project and get things set up properly. This includes creating your <strong class="bold">Gameplay Framework</strong> (<strong class="bold">GF</strong>) classes <a id="_idIndexMarker193"/>so that you have access to all the necessary features needed for development, as well as configuring your project settings to use such classes.</p>
<p>By the end of this chapter, you will have a solid understanding of programming in UE with C++ and will have laid the foundation for your multiplayer game.</p>
<p>Through the next sections, I will present you with the following topics:</p>
<ul>
<li>Introducing Unreal Shadows – Legacy of the Lichlord</li>
<li>Understanding C++ in Unreal Engine</li>
<li>Starting your Unreal multiplayer project</li>
<li>Adding the player classes</li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/>Technical requirements</h1>
<p>To follow along with this chapter, you should have set up Visual Studio (or JetBrains Rider) with all Unreal dependencies, as explained in <a href="B18203_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Multiplayer </em><em class="italic">Game Development</em>.</p>
<p>You’ll be using some starter content available in this book’s companion repository located at <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>Through this link, locate the section for this chapter and download the following <code>.zip</code> file: <code>Unreal Shadows – Starter Content</code>. If you somehow get lost during the progress of this chapter, in the repository, you will also find the up-to-date project files here: <code>Unreal Shadows – </code><code>Chapter </code><code>04</code><code> End</code>.</p>
<p>Also, to fully understand this chapter, it is necessary to have some basic knowledge about C++ programming while I guide you through the key characteristics of the main peculiarities of the UE framework.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Introducing Unreal Shadows – Legacy of the Lichlord</h1>
<p>Consider the following passage from a (never published) fantasy book called <em class="italic">Unreal Shadows – Legacy of </em><em class="italic">the Lichlord</em>:</p>
<p><em class="italic">“The air was thick with the stench of decay as the three thieves made their way into the Lichlord’s dungeon. Their mission was clear: infiltrate the fortress, find the king’s knight, and bring him back alive. Anything they could find lying around was theirs to </em><em class="italic">take home.</em></p>
<p><em class="italic">As they crept through the shadowy corridors, they all knew that they were not alone: dozens of undead minions lurked around every corner, their greenish eyes </em><em class="italic">staring blankly.</em></p>
<p><em class="italic">The guild had faced their fair share of dangerous foes before, but never had they encountered such a formidable army of the undead. Quietly, they slipped past the corridors, careful not to attract any attention. The last thing they needed was to draw the entire horde down </em><em class="italic">upon them.”</em></p>
<p>Congratulations – you have just been hired to create the video game adaptation of this best-selling book! And what’s more, it will be a multiplayer game!</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Explaining the project brief</h2>
<p>The game you’ll be <a id="_idIndexMarker194"/>developing will be a <strong class="bold">third-person shooter</strong> that will use the <strong class="bold">hide and seek</strong> gameplay twist, as introduced in <a href="B18203_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Multiplayer Game Development</em>. This means that this will be a stealth game where players will survive only by moving quietly and carefully.</p>
<p>In this multiplayer game, each participant will play the role of a member of the Guild of Thieves, a secret organization of rogues and thieves, infiltrating the realm of an undead wizard. The main aim will be to rescue non-player characters that are kept (hopefully alive!) in the dungeon prisons. Additionally, players will collect treasures and equipment from past and less lucky adventurers.</p>
<p>Each character will have the ability to do the following:</p>
<ul>
<li>Move around by walking or running</li>
<li>Handle a weapon</li>
<li>Get power-ups</li>
<li>Equip new weapons</li>
<li>Increase skills by means of experience points</li>
</ul>
<p>The primary focus of this game will be on stealthy movement, as the undead army will prove too strong for the character to engage in direct combat. As a result, movement (especially running) and wielding weapons will create noise, making the previously unaware enemies instantly alert to the player’s presence.</p>
<p>Enemies will be represented by the Lichlord minions, a horde of undead skeletons that will wander around the level unaware of the player characters.</p>
<p>Excessive noise from the characters or falling into traps will alert nearby enemies, making it nearly impossible to complete the game. Regrettably for the player characters, gaining experience points will only be made possible by defeating enemies, adding further engagement to the overall experience!</p>
<p class="callout-heading">Note</p>
<p class="callout">As this book is about multiplayer game programming rather than game design, balancing game mechanics will not be a primary focus of gameplay; instead, the focus will be on making things function effectively.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Starting the project</h2>
<p>We want<a id="_idIndexMarker195"/> the game to be visually appealing, but I’m guessing that most of you might not have a 3D modeling background (I don’t have one!). That’s why we will be using some amazing assets by Kay Lousberg (<a href="https://kaylousberg.com/">https://kaylousberg.com/</a>) that are freely available for personal and commercial purposes.</p>
<p><em class="italic">Figure 4</em><em class="italic">.1</em> shows one of the packs we will be using:</p>
<div><div><img alt="Figure 4.1 – The KayKit Dungeon Pack" src="img/Figure_04.1_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The KayKit Dungeon Pack</p>
<p>You will start by creating a brand-new project starting from the <strong class="bold">Blank</strong> template available in UE5 and then you will add some assets from the aforementioned kits; however, to avoid the tedious task of importing them correctly, I have already packaged them for you.</p>
<p>The project files, along with the code for each chapter, can be found on this book’s companion project page located here: <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>Having established what you will be working on, it is now time to gain an understanding of how C++ is used within UE5. The following section will provide a brief introduction to the primary features offered by the engine framework.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor092"/>Understanding C++ in Unreal Engine</h1>
<p>If you share my love for <a id="_idIndexMarker196"/>game development and programming, you’ll likely find that writing C++ code in UE5 is quite fun and actually not too hard to get started with. Epic Games made a great job of adding features that make C++ easy to use for (almost) everyone.</p>
<p>Although it is possible to write standard C++ code in UE5, to achieve better performance with your games, it is advisable to use the engine’s most common features such as the built-in Reflection System and memory management.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>Blueprints and C++</h2>
<p>As you may already know, UE provides two methods for programming your game logic: Blueprint Visual Scripting and C++.</p>
<p><strong class="bold">Blueprints Visual Scripting</strong> makes it easier for developers who don’t have extensive <a id="_idIndexMarker197"/>coding experience to create complex game <a id="_idIndexMarker198"/>mechanics without writing any code. On the other hand, <strong class="bold">C++</strong> is an <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) language that requires more technical knowledge but offers much greater control over the game engine than Blueprints does.</p>
<p>It should be noted that C++ and Blueprints are strictly connected, as Blueprints provide a visual representation of the underlying C++ code and adhere to its principles, including inheritance and polymorphism. While Blueprints do not demand advanced coding skills, they do follow the same principles as the programming language in terms of data types, pointers, references, and other rules.</p>
<p>Both languages can be used together in UE5 projects and most of the time, what you can achieve with C++ can equally be done in Blueprints; however, C++ excels in customizing core features of UE or creating plugins that extend its functionality even further beyond what’s available out of the box.</p>
<p>Although both Blueprint Visual Scripting and C++ offer powerful toolsets when working with UE projects, C++ provides lower-level access by way of object-oriented coding techniques – that’s why it is very important to have a strong knowledge of it once you start developing multiplayer games.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>Understanding C++ classes</h2>
<p>An Unreal Engine C++ class is, well, a regular C++ class!</p>
<p>If you have <a id="_idIndexMarker199"/>already a good knowledge of OOP in C++, you<a id="_idIndexMarker200"/> will feel at home here: the process of creating a new UE C++ class begins by first defining what type of object it will represent, such as an Actor or a Component. Once the type has been defined, variables and methods are declared in the header file (<code>.h</code>) and code logic is implemented in the source file (<code>.cpp</code>).</p>
<p>While the source file behaves like a regular C++ file of its kind, the header file will let you declare additional information for variables and functions that will be used by Blueprints inheriting from your class. Additionally, it will ease the pain of managing memory at runtime (I will get back to this in a while).</p>
<p>With the release of UE5, Epic Games introduced an amazing inspection tool called <code>BP_BasePickup</code> created during the last chapter.</p>
<div><div><img alt="Figure 4.2 – The C++ Header Preview tool in action" src="img/Figure_04.2_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The C++ Header Preview tool in action</p>
<p>In UE, there are three main class types that you’ll be deriving from during development:</p>
<ul>
<li>A <strong class="bold">UObject</strong> is the<a id="_idIndexMarker202"/> base class of UE and provides most of the main features available in UE, such as <strong class="bold">garbage collection</strong> (<strong class="bold">GC</strong>) (yes, UE provides it!), networking support, reflection of properties and methods, and so on. An <strong class="bold">AActor</strong> is a<a id="_idIndexMarker203"/> UObject that can be added to a game level either from the Editor or at runtime: in this second case, we say that the Actor has been <em class="italic">spawned</em>. In a multiplayer environment, an AActor is the base type that can be replicated during networking and it will provide information for any Component that will need synchronization.</li>
<li>A <strong class="bold">UActorComponent</strong> is the <a id="_idIndexMarker204"/>basic class for defining Components that will be attached to an Actor or to another Component belonging to the Actor itself.</li>
</ul>
<p>Additionally, you’ll be using these entities:</p>
<ul>
<li>A <strong class="bold">UStruct</strong> is used to<a id="_idIndexMarker205"/> create plain data structures and does not extend from any particular class</li>
<li>A <strong class="bold">UEnum</strong> is used<a id="_idIndexMarker206"/> to represent enumerations of elements</li>
</ul>
<p>As a final note, throughout this book, you will notice that class names start with some letters that will not be visible once the class is used in the Editor. UE makes use of prefixes to point out the class type. The main prefixes used are as follows:</p>
<ul>
<li><code>UObject</code> (for instance, components)</li>
<li><code>AActor</code>) and that can be added to a level</li>
<li><code>FColor</code> structure</li>
<li><code>TArray</code> or <code>TMap</code></li>
<li><strong class="bold">I</strong> is used for interfaces</li>
<li><strong class="bold">E</strong> is used for enums</li>
<li><code>bool</code> or <code>uint8</code> (which may be used instead of <code>bool</code>)</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Please keep in mind that most of these prefixes are mandatory; if you try to name a class deriving from Actor without the <code>A</code> prefix, you will get an error. UE will hide the prefix once in the Editor. This rule applies only to C++ classes; Blueprints can be named without such prefixes.</p>
<p>Now that you are familiar with the main types available in UE, it’s time to explore the main features of a class header in order to understand its core functionalities.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Anatomy of a UE C++ header</h2>
<p>The C++ header <a id="_idIndexMarker207"/>of an Actor in UE5 will look like the <a id="_idIndexMarker208"/>following piece of code:</p>
<pre class="source-code">
#include "Engine/StaticMEshActor.h"
#include "APickup.generated.h"
UCLASS(Blueprintable, BlueprintType)
class APickup : public AStaticMeshActor
{
  GENERATED_BODY()
public:
  APickup();
  UPROPERTY(BlueprintReadOnly, VisibleAnywhere, Category="Default")
  TObjectPtr&lt;class USphereComponent&gt; Trigger;
  UPROPERTY(BlueprintReadWrite, EditAnywhere, Category="Default")
  int32 Points;
  UFUNCTION(BlueprintCallable)
  void Reactivate();
};</pre>
<p>As you can see, there are a lot of things going on here.</p>
<p>First of <a id="_idIndexMarker209"/>all, you will notice a <code>#include "APickup.generated.h"</code> declaration. This mandatory line of code is autogenerated by<a id="_idIndexMarker210"/> the <code>include</code> file declared in your header or the compiler will throw an error.</p>
<p class="callout-heading">Note</p>
<p class="callout">The UHT is a custom parsing and code generation tool that supports the UObject system in Unreal Engine. The UHT is used to parse C++ headers for Unreal and generate the boilerplate code required for the engine to work with the user-created classes.</p>
<p>The class constructor (in this case, <code>APickup()</code>) is used to set default values for properties as you may do with a regular C++ class; what’s more, you will be using it to create and add Components to the Actor itself.</p>
<p>Next, you will find some declarations, such as <code>UCLASS()</code>, <code>GENERATED_BODY()</code>, <code>UPROPERTY()</code>, and <code>UFUNCTION()</code>, that are used by UE and each has a precise function. If you are wondering about the meaning of the attributes called <code>BlueprintReadOnly</code>, <code>VisibleAnywhere</code>, and similar, don’t be afraid! I’ll be explaining their meaning in <a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a </em><em class="italic">Multiplayer Environment</em>.</p>
<p>In the next subsection, I’ll show you the exact meaning of each of them.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>The Unreal Engine Reflection System</h2>
<p>The term <strong class="bold">Reflection</strong> specifies<a id="_idIndexMarker211"/> the capability <a id="_idIndexMarker212"/>that allows a program to inspect its own structure at runtime. This feature is immensely valuable and serves as one of the core technologies employed by UE, supporting a variety of systems such as detail panels in the Editor, serialization, garbage collection, network replication, and communication between Blueprint and C++.</p>
<p>As there is no native support for Reflection in C++, Epic Games has developed its own system for gathering, examining, and altering data related to C++ classes, structs, and so on in UE.</p>
<p>In order to use Reflection, you will need to annotate any type or property that you want to make visible to the system by marking them with annotations such as <code>UCLASS()</code>, <code>UFUNCTION()</code>, or <code>UPROPERTIES()</code>.</p>
<p>To enable such annotations, you’ll be using the <code>#include "APickup.generated.h"</code> declaration I introduced in the last subsection (this declaration is autogenerated when you create a class with the Unreal Class Wizard, so you won’t have to worry about it).</p>
<p>The following list provides the fundamental markup elements accessible within the Reflection System:</p>
<ul>
<li><code>UCLASS()</code>: Used to generate reflection data for a class that needs to derive from <code>UObject</code></li>
<li><code>USTRUCT()</code>: Used to generate reflection data for a struct</li>
<li><code>GENERATED_BODY()</code>: This markup will be replaced with all the needed boilerplate code for the type</li>
<li><code>UPROPERTY()</code>: Used to tell the engine that the associated member variable will have some additional features, such as Blueprint accessibility or replication across the network (and this will mean a lot to you later on!)</li>
<li><code>UFUNCTION()</code>: Allows, among other things, to call this function from an extending Blueprint Class or override the function from the Blueprint itself</li>
</ul>
<p>The Reflection System is also used by the garbage collector so you don’t have to worry about memory management, as you will see in the next subsection.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Memory management and garbage collection</h2>
<p>With thousands (sometimes tens of thousands!) of active objects in a game level, GC is<a id="_idIndexMarker213"/> an essential part<a id="_idIndexMarker214"/> of programming. It’s like the janitor of your running code – it helps keep everything tidy <a id="_idIndexMarker215"/>and organized by automatically collecting and disposing of objects that are no longer needed. It’s a great way to make sure your program runs smoothly without any memory leaks or performance issues, so you can focus on creating awesome features instead.</p>
<p>C++ does not natively implement GC, so UE implements its own system: you will just need to ensure that valid references to the objects are maintained. In order to enable GC for your classes, you need to assure that they inherit from <code>UObject</code>; then the system will keep a list of <a id="_idIndexMarker216"/>objects (also called <strong class="bold">root</strong>) that should not be garbage-collected. As long as an object is listed in the root, it will be preserved from deletion; once it is removed from this list, it will be deleted from memory the next time the garbage collector is called (i.e., at certain intervals).</p>
<p class="callout-heading">Note</p>
<p class="callout">Actors are only destroyed at the level’s shutdown unless you call the <code>Destroy()</code> method on them: in this case, they will be immediately removed from the game and deleted by the garbage collector when activated.</p>
<p>In this section, I have introduced you to the main features that distinguish an Unreal Engine project from a regular C++ one. In the next section, you will begin to apply this knowledge by creating an empty project and extending the main Unreal GF classes.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/>Starting your Unreal multiplayer project</h1>
<p>In this section, you are<a id="_idIndexMarker217"/> finally going to start developing the multiplayer project (I know you are eager to begin it!). You’ll be creating an Unreal C++ blank project and adding the already packaged assets I will provide you. Then, you’ll be creating the GF classes needed to manage a multiplayer session. So, let’s get started.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Creating your project file</h2>
<p>Let’s start by <a id="_idIndexMarker218"/>creating a blank project:</p>
<ol>
<li>Open the Epic Games Launcher and launch the Unreal Editor.</li>
<li>From the <strong class="bold">Games</strong> section, select the <strong class="bold">Blank</strong> template.</li>
<li>In <strong class="bold">Project Defaults</strong>, select <strong class="bold">C++</strong> as the project type.</li>
<li>Make sure the <strong class="bold">Starter Content</strong> field is unselected as you won’t be using it.</li>
<li>Give the project a meaningful name (for example, <code>UnrealShadows_LOTL</code>).</li>
<li>Click the <strong class="bold">Create</strong> button.</li>
<li>Once the UE project has been created, get the <code>UnrealShadows-StarterContent.zip</code> file you downloaded at the beginning of this chapter and unzip it in your computer.</li>
<li>Navigate to your project <code>Content</code> folder located at <code>[Your Project Path]</code> | <code>UnrealShadows_LOTL</code> | <code>Content</code>.</li>
<li>Copy the content of the unzipped file (<code>_ExternalActors_</code>, <code>Blueprints</code>, <code>KayKit</code>, and <code>Maps</code> folders) into the <code>Content</code> folder to add all the needed assets to your project.</li>
</ol>
<p>Once you have copied the files, they should appear in the UE Editor and be available in your project. If the files do not pop up in the Content Browser, simply close the Editor and open it again to let UE update the <code>Content</code> folder.</p>
<p>You will notice that I have already added two levels (<code>Maps</code> folder: these levels will be used during the book and have been created for ease of development. You are free to create your own maps or add additional assets. which can be located at <strong class="bold">Content</strong> | <strong class="bold">KayKit</strong> | <strong class="bold">Dungeon Elements</strong>.</p>
<p>Just to check that everything went as expected, open the <code>Level_01</code> map and you should see the level shown in <em class="italic">Figure 4</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 4.3 – The Level 01 map" src="img/Image96388.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The Level 01 map</p>
<p>It’s time to add some <a id="_idIndexMarker219"/>of the main classes used in any UE5 project, the ones that extend the GF elements.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Creating the project game instance</h2>
<p>As you <a id="_idIndexMarker220"/>probably already know, in UE5, a <strong class="bold">GameInstance</strong> is a <a id="_idIndexMarker221"/>class responsible for managing high-level data that needs to persist across level changes or game sessions. It is essentially a globally accessible UObject that can store any data you want to keep across the entire game, such as the player score, and other information that needs to be shared across different levels or game sessions.</p>
<p>A class extending a GameInstance can be created as a Blueprint Class or in C++ and is instantiated when the game is started and is only destroyed when the game is shut down.</p>
<p class="callout-heading">Important note</p>
<p class="callout">As with most C++ Unreal Engine projects, you will be working with a mix of C++ classes and Blueprints. C++ classes are located in the <strong class="bold">All | C++ classes | UnrealShadows_LOTL</strong> folder and can only be added there (or in a subfolder). If you can’t find this folder, you have probably created a Blueprint-only project. Don’t despair, once the first C++ has been created (more on this in a minute), the Unreal Engine Editor will take care of it, transforming your Blueprint-only project into a C++ one and everything will be in place!</p>
<p>To create <a id="_idIndexMarker222"/>your project GameInstance, follow<a id="_idIndexMarker223"/> these steps:</p>
<ol>
<li>On the main menu, select <strong class="bold">Tools</strong> | <strong class="bold">New </strong><strong class="bold">C++ Class...</strong>.</li>
<li>The <code>game instance</code>.</li>
<li>Select the <strong class="bold">GameInstance</strong> class, as shown in <em class="italic">Figure 4</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 4.4 – The class creation wizard" src="img/Figure_04.4_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The class creation wizard</p>
<ol>
<li value="4">Click <strong class="bold">Next</strong> to access the <strong class="bold">NAME YOUR NEW GAME </strong><strong class="bold">INSTANCE</strong> panel.</li>
<li>In the <code>US_GameInstance</code>. You can leave the other fields as they are so that the panel looks like <em class="italic">Figure 4</em><em class="italic">.5</em>:</li>
</ol>
<div><div><img alt="Figure 4.5 – Naming your class" src="img/Figure_04.5_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Naming your class</p>
<ol>
<li value="6">Click<a id="_idIndexMarker224"/> the <strong class="bold">Create Class</strong> button <a id="_idIndexMarker225"/>to generate your class files.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">I’ll be using the <code>US_</code> prefix for most of the classes in the project extending the main GF elements: this is just a shorthand for UnrealShadows and will let us see that these files are from our project.</p>
<p>Once the creation process has ended, you will get two new files: <code>US_GameInstance.h</code> and <code>US_GameInstance.cpp</code>. Congratulations – you have just created your first Unreal C++ class!</p>
<p>Opening the header file, you will see the following code:</p>
<pre class="source-code">
// Fill out your copyright notice in the Description page of Project Settings.
#pragma once
#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "US_GameInstance.generated.h"
/**
 *
*/
UCLASS()
class UNREALSHADOWS_LOTL_API UUSGameInstance : public UGameInstance
{
  GENERATED_BODY()
};</pre>
<p>The source <a id="_idIndexMarker226"/>file will be empty, apart from the<a id="_idIndexMarker227"/> header <code>#</code><code>include</code> declaration:</p>
<pre class="source-code">
// Fill out your copyright notice in the Description page of Project Settings.
#include "US_GameInstance.h"</pre>
<p>As you can see, this class extends the base <code>GameInstance</code> class (i.e., <code>UGameInstance</code>) and it currently does nothing apart from the macro declarations that were introduced in the previous section. However, as the project progresses, new features such as data collection or online services management will be added to it.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you named your project with a name other than mine (i.e., <code>UnrealShadows_LOTL</code>), you will get a different API export name in your class declaration; as you can see from the previous code, mine is <code>UNREALSHADOWS_LOTL_API</code>. Please keep this in mind throughout the book, as my code will reference this name and you may get a compilation error. To fix this, you should change the <code>UNREALSHADOWS_LOTL_API</code> text with <code>YOUR_PROJECT_NAME</code> (in all caps), with the <code>_API</code> suffix.</p>
<p>This <a id="_idIndexMarker228"/>game instance needs to be added to the <a id="_idIndexMarker229"/>project settings so it will be the one instantiated at runtime. To do so, follow these steps:</p>
<ol>
<li>From the main menu, open <strong class="bold">Project Settings</strong>. Then click on the <strong class="bold">Project</strong> |<strong class="bold"> Maps &amp; </strong><strong class="bold">Modes</strong> section.</li>
<li>In the <strong class="bold">Game Instance Class</strong> drop-down menu, select <strong class="bold">UG_GameInstance</strong>, as depicted in <em class="italic">Figure 4</em><em class="italic">.6</em>:</li>
</ol>
<div><div><img alt="Figure 4.6 – The game instance assigned to the project" src="img/Figure_04.6_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The game instance assigned to the project</p>
<p>Now that we have a game instance assigned to the project, it’s time to create a Game Mode for the menu and lobby levels.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Creating the Game Mode and the Game State</h2>
<p>In UE, a <strong class="bold">Game Mode</strong> is a<a id="_idIndexMarker230"/> class that <a id="_idIndexMarker231"/>controls the game rules, such as how a player joins the game, how to transition between levels, and other game-specific settings. The Game Mode is typically paired with<a id="_idIndexMarker232"/> a <strong class="bold">Game State</strong> class, which<a id="_idIndexMarker233"/> manages the current state of the game, such as the score, time remaining, and other important information. Together, the Game Mode and Game State classes allow developers to create complex and customized game mechanics in UE.</p>
<p>If you <a id="_idIndexMarker234"/>check your <code>C++ Classes</code> folder, you will notice that there is already a Game Mode named <code>UnrealShadowsLOTLGameModeBase</code> (the name may differ slightly if you named your project differently from mine). This is an autogenerated class extending <code>AGameModeBase</code> from the GF.</p>
<p>You won’t be using this because<a id="_idIndexMarker235"/> you need to create a class from <code>AGameMode</code>; this class extends <code>AGameModeBase</code> by adding some features that will enhance the multiplayer system, such as game rules and win/lose conditions. To extend the Game Mode with your own settings, follow these steps:</p>
<ol>
<li>Create a new C++ class just like you did for the game instance in the previous sections.</li>
<li>From the <strong class="bold">All Classes</strong> section, select <strong class="bold">GameMode</strong> and click <strong class="bold">Next</strong>.</li>
<li>Name your class <code>US_GameMode</code> and click the <strong class="bold">CreateClass</strong> button.</li>
<li>Once the class has been created, it’s time to set it as the default Game Mode for all your levels. To do this, open <strong class="bold">Project Settings</strong> and select the <strong class="bold">Maps &amp; </strong><strong class="bold">Modes</strong> section.</li>
<li>Then, click on the <strong class="bold">Default GameMode</strong> drop-down menu and select <strong class="bold">US_GameMode</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.7</em>:</li>
</ol>
<div><div><img alt="Figure 4.7 – The default game mode" src="img/Figure_04.7_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The default game mode</p>
<ol>
<li value="6">Close the <strong class="bold">Project </strong><strong class="bold">Settings</strong> window.</li>
</ol>
<p>Now that the<a id="_idIndexMarker236"/> Game Mode has been defined, it’s time to create a Game State:</p>
<ol>
<li>Create another C++ class that will extend from <code>GameState</code> (from the <strong class="bold">All </strong><strong class="bold">Classes</strong> section).</li>
<li>After clicking <code>US_GameState</code> and click the <strong class="bold">CreateClass</strong> button.</li>
<li>Now, declare <code>US_GameMode</code> files by double-clicking on the corresponding icon in the <code>C++ Classes</code> folder of the Unreal Editor. This will open the header and source files inside your IDE.</li>
<li>Declare a constructor inside <code>US_GameMode.h</code> by adding these two lines of code:<pre class="source-code">
public:</pre><pre class="source-code">
   AUS_GameMode();</pre></li>
<li>Implement the constructor inside <code>US_GameMode.cpp</code> by adding this piece of code:<pre class="source-code">
#include "US_GameState.h"</pre><pre class="source-code">
AUS_GameMode::AUS_GameMode()</pre><pre class="source-code">
{</pre><pre class="source-code">
   GameStateClass = AUS_GameState::StaticClass();</pre><pre class="source-code">
}</pre></li>
</ol>
<p>The previous code essentially declares the Game State class for <code>US_GameMode</code> to be the previously created <code>US_GameState</code>. Keep in mind that this declaration can be performed also in child Blueprints; this will enable class switching through a drop-down menu in the Editor. Ultimately, this is a matter of personal taste as you may be more code-oriented and prefer the code solution or you may want to take advantage of the impressive interplay between native code and the Editor.</p>
<p>In this section, you<a id="_idIndexMarker238"/> have created the main<a id="_idIndexMarker239"/> classes that will be used by the system to handle a multiplayer session. At the moment, these are just empty containers waiting for some game logic to be added; be patient, we still have so many chapters to fill this void!</p>
<p>In the next section, you’ll be creating the classes needed to handle the character input and presence in the game.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/>Adding the player classes</h1>
<p>You<a id="_idIndexMarker240"/> are now ready to create some more <a id="_idIndexMarker241"/>main classes used by almost any UE game: those dedicated to managing the input from the player and showing the character in-game, along with its state.</p>
<p>The <strong class="bold">Player Controller</strong> is<a id="_idIndexMarker242"/> responsible for managing input from the player’s input devices (such as keyboard and mouse), and for sending commands to the player’s character so it will perform the corresponding actions. The Player Controller class is typically used to control<a id="_idIndexMarker243"/> a <strong class="bold">Pawn</strong> class or <a id="_idIndexMarker244"/>a <strong class="bold">Character</strong> class that represents the player in a game.</p>
<p>Finally, the <strong class="bold">Player State</strong> is a<a id="_idIndexMarker245"/> class that holds information about a player’s game state, such as experience points, score, and other relevant data. It exists on both the server and clients to ensure that all players have access to the same information.</p>
<p>Let’s create these three classes:</p>
<ol>
<li>Create a C++ class extending <code>PlayerController</code> and name it <code>US_PlayerController</code>.</li>
<li>Create another C++ class extending <code>Character</code> and name it <code>US_Character</code>.</li>
<li>Finally, create a C++ class extending <code>PlayerState</code> and call it <code>US_PlayerState</code>.</li>
</ol>
<p>These three <a id="_idIndexMarker246"/>classes should be added to the Game Mode, the same way the Game State was added, but to get a bit more flexibility to our <code>Character</code> class, you’ll be creating a Blueprint from it. To get a Blueprint out of a newly created C++ class, you need to compile the<a id="_idIndexMarker247"/> project.</p>
<p>You are now going to compile your source code for the first time to check that everything has been properly set.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Compiling your source code</h2>
<p>Compiling in<a id="_idIndexMarker248"/> an Unreal Engine project refers to the process of converting human-readable code written in C++ and Blueprint into executable code that the computer can understand and run – this is an essential step in the development process. UE provides tools to streamline the compiling process and improve the development experience.</p>
<p>In<a id="_idIndexMarker249"/> Unreal Engine, you can leverage <strong class="bold">Live Coding</strong>, a feature that enables your application’s C++ code to be rebuilt and its binaries patched while the UE engine is running.</p>
<p>With Live Coding, you can modify C++ classes, compile them, and observe the changes taking effect while the Editor is running – all without interrupting the play-testing sessions or work in progress. This feature boasts enormous advantages for iterative development, especially when using C++ runtime logic such as gameplay code or frontend user interactions.</p>
<p>Live coding is enabled by default, and you can initiate a Live Coding build by pressing <em class="italic">Ctrl</em> +<em class="italic">Alt</em> + <em class="italic">F11</em> on your keyboard when utilizing your IDE or Unreal Engine.</p>
<p>Alternatively, to start the compilation process with Live Coding disabled, you can click the <strong class="bold">Compile</strong> button at the bottom right of the Unreal Engine Editor, as depicted in <em class="italic">Figure 4</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 4.8 – The Compile button" src="img/Figure_04.8_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The Compile button</p>
<p>Once the source code has been compiled, you should get a success message. Otherwise, you will get the usual errors or warnings from a failed compilation; in this case, it is essential to ensure<a id="_idIndexMarker250"/> that your code is written correctly and free from errors.</p>
<p>Once your project has been successfully compiled, it’s time to create a Blueprint out of your <code>Character</code> class.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/>Creating the Character Blueprint Class</h2>
<p>As you’ll be working <a id="_idIndexMarker251"/>on some <a id="_idIndexMarker252"/>customization for your character later on, it’s essential to have the extra flexibility provided by a Blueprint Class.</p>
<p>As you have successfully compiled your code, you may expect that the classes you created will now be ready to be available in the Blueprint creation wizard. This is a correct assumption and you are going to test it right now. Let’s do so:</p>
<ol>
<li>Navigate to the <code>Content</code> | <code>Blueprints</code> folder.</li>
<li>Create a Blueprint Class that will inherit from <code>US_Character</code> and name it <code>BP_Character</code>.</li>
<li>Save and close the Blueprint: you are not going to do anything yet on it.</li>
</ol>
<p>This new Blueprint should be added to the Game Mode as the default Pawn to be used during a game session. Unfortunately, a Blueprint Class cannot be directly referenced in a C++ class. This means you’ll have to find it through a method called <code>FClassFinder</code> available in the <code>ConstructorHelpers</code> utility class.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Adding the Player classes to the Game Mode</h2>
<p>You are <a id="_idIndexMarker253"/>now going to declare the newly created classes to the Game Mode. Let’s open again the <code>US_GameMode.cpp</code> file and add some code logic. In the <code>declarations</code> section, add the following block of code:</p>
<pre class="source-code">
#include "US_PlayerController.h"
#include "US_PlayerState.h"
#include "US_Character.h"
#include "UObject/ConstructorHelpers.h"</pre>
<p>This will declare all the GF classes you will be declaring, and the <code>ConstructorHelpers</code> utility class.</p>
<p>Then, before the closing bracket of the constructor, add the following block of code:</p>
<pre class="source-code">
PlayerStateClass = AUS_PlayerState::StaticClass();
PlayerControllerClass = AUS_PlayerController::StaticClass();
static ConstructorHelpers::FClassFinder&lt;APawn&gt; PlayerPawnBPClass(TEXT("/Game/Blueprints/BP_Character"));
if (PlayerPawnBPClass.Class != nullptr)
{
   DefaultPawnClass = PlayerPawnBPClass.Class;
}</pre>
<p>As you can see, the first two lines of code declare <code>PlayerStateClass</code> and <code>PlayerControllerClass</code> in a similar way as you did in the previous section for <code>GameStateClass</code>.</p>
<p>Meanwhile, retrieving a Blueprint reference (i.e., <code>PlayerPawnBPClass</code>) from a C++ class works differently from how it works for a regular C++ class: you need to hardcode a path to your project. This may be not an ideal solution because files can be moved around or deleted but, well... it works!</p>
<p>Just keep in mind that my file path (i.e., <code>"/Game/Blueprints/BP_Character"</code>) may be slightly different from yours, depending on your folder organization.</p>
<p>Now that the Game Mode class has been modified, click the <strong class="bold">Compile</strong> button in the Unreal Editor.</p>
<p>Once you get a successful result, it’s time to look at the Game Mode instance to check that everything is correct. To do this, follow these steps:</p>
<ol>
<li>Open the <strong class="bold">Project Settings</strong> | <strong class="bold">Maps &amp; </strong><strong class="bold">Modes</strong> section.</li>
<li>Locate the <strong class="bold">Selected GameMode</strong> field and expand it by clicking the small arrow next to it.</li>
<li>Check that <a id="_idIndexMarker254"/>the GF classes we have created are all correctly allocated, as shown in <em class="italic">Figure 4</em><em class="italic">.9</em>:</li>
</ol>
<div><div><img alt="Figure 4.9 – The updated default Game Mode" src="img/Figure_04.9_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The updated default Game Mode</p>
<p>In this last section, you have completed the Game Mode setup by adding all the GF classes you’ll be expanding in the next chapters.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Summary</h1>
<p>In this chapter, you were briefed about the project you’ll be developing through the rest of the book: a multiplayer stealth game involving thieves, secret treasures, and a ton of undead minions. The road is still long, but the Lichlord must be stopped!</p>
<p>After that, you were introduced to the main topics of the Unreal Engine C++ “dialect.” There are a lot of additional features involved and many more will be discovered throughout the rest of the book. One of the most exciting things is that, if things are set up properly, you won’t have to worry about memory management: Unreal Engine flawlessly handles it. What’s more, by adding decorations to your classes, variables, and functions, you can expose them to the Blueprint system, letting your project be more flexible and accessible to non-code-oriented developers.</p>
<p>Lastly, you created the main classes that will be used by your game and that extend those offered by the GF. Starting from the persistent GameInstance, you went to the Game Mode, and then to all the player-oriented elements. You now have a solid base to start developing your multiplayer project.</p>
<p>In the next chapter, I will guide you through the creation of the player character by presenting how to manage it in a multiplayer environment.</p>
</div>
</body></html>