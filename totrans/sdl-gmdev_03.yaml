- en: Chapter 3. Working with Game Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 与游戏对象协作
- en: 'All games have objects, for example, players, enemies, **non-player character**
    (**NPC**), traps, bullets, and doors. Keeping track of all these objects and how
    they interact with each other is a big task and one that we would like to make
    as simple as possible. Our game could become unwieldy and difficult to update
    if we do not have a solid implementation. So what can we do to make our task easier?
    We can start by really trying to leverage the power of **object-oriented programming**
    (**OOP**). We will cover the following in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏都有对象，例如，玩家、敌人、**非玩家角色**（NPC）、陷阱、子弹和门。跟踪所有这些对象以及它们如何相互作用是一项庞大的任务，我们希望尽可能简化这项任务。如果我们没有坚实的实现，我们的游戏可能会变得难以控制且难以更新。那么我们如何使我们的任务更容易呢？我们可以从真正尝试利用面向对象编程（OOP）的强大功能开始。在本章中，我们将涵盖以下内容：
- en: Using inheritance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承
- en: Implementing polymorphism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多态
- en: Using abstract base classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象基类
- en: Effective inheritance design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的继承设计
- en: Using inheritance
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承
- en: The first powerful feature of OOP we will look at is inheritance. This feature
    can help us enormously when developing our reusable framework. Through the use
    of inheritance, we can share common functionality between similar classes and
    also create subtypes from existing types. We will not go into too much detail
    about inheritance itself but instead we will start to think about how we will
    apply it to our framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个面向对象编程（OOP）的强大特性是继承。这个特性在开发可重用的框架时能给我们带来巨大的帮助。通过使用继承，我们可以在相似类之间共享通用功能，并从现有类型中创建子类型。我们不会深入探讨继承本身，而是开始思考如何将其应用到我们的框架中。
- en: 'As mentioned earlier, all games have objects of various types. In most cases,
    these objects will have a lot of the same data and require a lot of the same basic
    functions. Let''s look at some examples of this common functionality:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有游戏都有各种类型的对象。在大多数情况下，这些对象将拥有大量相同的数据和需要大量相同的基本功能。让我们看看一些这种常见功能性的例子：
- en: Almost all of our objects will be drawn to the screen, thus requiring a `draw`
    function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎我们所有的对象都将被绘制到屏幕上，因此需要`draw`函数
- en: If our objects are to be drawn, they will need a location to draw to, that is,
    x and y position variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的对象需要被绘制，它们将需要一个绘制位置，即x和y位置变量
- en: We don't want static objects all the time, so we will need an `update` function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不总是需要静态对象，所以我们需要一个`update`函数
- en: Objects will be responsible for cleaning up after themselves; a function that
    deals with this will be important
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象将负责清理自己的事务；处理这个问题的函数将非常重要
- en: 'This is a good starting point for our first game object class, so let''s go
    ahead and create it. Add a new class to the project called `GameObject` and we
    can begin:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个游戏对象类的一个很好的起点，所以让我们继续并创建它。向项目中添加一个新的类名为`GameObject`，然后我们可以开始：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The public, protected, and private keywords are very important. Public functions
    and data are accessible from anywhere. Protected status restricts access to only
    those classes derived from it. Private members are only available to that class,
    not even its derived classes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 公共（public）、受保护（protected）和私有（private）关键字非常重要。公共函数和数据可以从任何地方访问。受保护状态仅允许从其派生的类访问。私有成员仅对该类可用，甚至其派生类也无法访问。
- en: 'So, there we have our first game object class. Now let''s inherit from it and
    create a class called `Player`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了第一个游戏对象类。现在让我们从它继承并创建一个名为`Player`的类：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What we have achieved is the ability to reuse the code and data that we originally
    had in `GameObject` and apply it to our new `Player` class. As you can see, a
    derived class can override the functionality of a parent class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现的能力是重用我们在`GameObject`中原本拥有的代码和数据，并将其应用到我们新的`Player`类中。正如你所看到的，派生类可以覆盖父类的功能：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or it can even use the functionality of the parent class, while also having
    its own additional functionality on top:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它甚至可以使用父类的功能，同时在其之上拥有自己的附加功能：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we call the `draw` function from `GameObject` and then define some player-specific
    functionality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`GameObject`中的`draw`函数，然后定义一些玩家特定的功能。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `::` operator is called the scope resolution operator and it is used to
    identify the specific place that some data or function resides.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`::`运算符被称为作用域解析运算符，它用于标识某些数据或函数的具体位置。'
- en: 'Okay, so far our classes do not do much, so let''s add some of our SDL functionality.
    We will add some drawing code to the `GameObject` class and then reuse it within
    our `Player` class. First we will update our `GameObject` header file with some
    new values and functions to allow us to use our existing SDL code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，我们的类没有做太多，所以让我们添加一些SDL功能。我们将在`GameObject`类中添加一些绘图代码，然后在`Player`类中重用它。首先，我们将更新`GameObject`头文件，添加一些新的值和函数，以便我们可以使用现有的SDL代码：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now have some new member variables that will be set in the new `load` function.
    We are also passing in the `SDL_Renderer` object we want to use in our `draw`
    function. Let''s define these functions in an implementation file and create `GameObject.cpp`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些新的成员变量，它们将在新的`load`函数中设置。我们还在`draw`函数中传递了我们要使用的`SDL_Renderer`对象。让我们在一个实现文件中定义这些函数并创建`GameObject.cpp`：
- en: 'First define our new `load` function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义我们的新`load`函数：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here we are setting all of the values we declared in the header file. We will
    just use a start value of `1` for our `m_currentRow` and `m_currentFrame` values.
    Now we can create our `draw` function that will make use of these values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们设置了在头文件中声明的所有值。现在我们可以创建我们的`draw`函数，它将使用这些值：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We grab the texture we want from `TextureManager` using `m_textureID` and draw
    it according to our set values. Finally we can just put something in our `update`
    function that we can override in the `Player` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`m_textureID`从`TextureManager`获取我们想要的纹理，并根据我们设置的值绘制它。最后，我们可以在`update`函数中添加一些内容，这些内容可以在`Player`类中重写：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `GameObject` class is complete for now. We can now alter the `Player` header
    file to reflect our changes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GameObject`类现在已经完成。我们现在可以修改`Player`头文件以反映我们的更改：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now move on to defining these functions in an implementation file. Create
    `Player.cpp` and we''ll walk through the functions. First we will start with the
    `load` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续在实现文件中定义这些函数。创建`Player.cpp`，我们将遍历这些函数。首先，我们将从`load`函数开始：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we can use our `GameObject::load` function. And the same applies to our
    `draw` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以使用我们的`GameObject::load`函数。同样也适用于我们的`draw`函数：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And let''s override the `update` function with something different; let''s
    animate this one and move it in the opposite direction:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用不同的方式重写`update`函数；让我们让这个对象动画化并朝相反方向移动：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are all set; we can create these objects in the `Game` header file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了；我们可以在`Game`头文件中创建这些对象：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then load them in the `init` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`init`函数中加载它们：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They will then need to be added to the `render` and `update` functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要将它们添加到`render`和`update`函数中：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have one more thing to add to make this run correctly. We need to cap our
    frame rate slightly; if we do not, then our objects will move far too fast. We
    will go into more detail about this in a later chapter, but for now we can just
    put a delay in our main loop. So, back in `main.cpp`, we can add this line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序正确运行，我们还需要添加一个东西。我们需要稍微限制帧率；如果不这样做，那么我们的对象会移动得太快。我们将在后面的章节中详细介绍这一点，但现在我们可以在主循环中添加一个延迟。所以，回到`main.cpp`，我们可以添加这一行：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now build and run to see our two separate objects:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行以查看我们的两个独立对象：
- en: '![Using inheritance](img/6821OT_03_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用继承](img/6821OT_03_01.jpg)'
- en: Our `Player` class was extremely easy to write, as we had already written some
    of the code in our `GameObject` class, along with the needed variables. You may
    have noticed, however, that we were copying code into a lot of places in the `Game`
    class. It requires a lot of steps to create and add a new object to the game.
    This is not ideal, as it would be easy to miss a step and also it will get extremely
    hard to manage and maintain when a game goes beyond having two or three different
    objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Player`类编写起来非常简单，因为我们已经在`GameObject`类中编写了一些代码，以及所需的变量。然而，你可能已经注意到，我们在`Game`类中的很多地方都复制了代码。创建和添加新对象到游戏需要很多步骤。这并不理想，因为很容易遗漏一个步骤，而且当游戏对象超过两个或三个不同对象时，管理和维护会变得极其困难。
- en: What we really want is for our `Game` class not to need to care about different
    types; then we could loop through all of our game objects in one go, with separate
    loops for each of their functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是让`Game`类不需要关心不同类型；然后我们可以一次性遍历所有游戏对象，并为它们的每个函数分别使用循环。
- en: Implementing polymorphism
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多态
- en: This leads us to our next OOP feature, polymorphism. What polymorphism allows
    us to do is to refer to an object through a pointer to its parent or base class.
    This may not seem powerful at first, but what this will allow us to do is essentially
    have our `Game` class need only to store a list of pointers to one type and any
    derived types can also be added to this list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们的下一个面向对象编程特性，多态。多态允许我们通过其父类或基类的指针来引用对象。一开始这可能看起来并不强大，但这将允许我们做到的是，我们的`Game`类只需要存储一个指向一种类型的指针列表，任何派生类型也可以添加到这个列表中。
- en: 'Let us take our `GameObject` and `Player` classes as examples, with an added
    derived class, `Enemy`. In our `Game` class we have an array of `GameObject*`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`GameObject`和`Player`类为例，加上一个派生类`Enemy`。在我们的`Game`类中，我们有一个`GameObject*`数组：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then declare four new objects, all of which are `GameObject*`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明四个新对象，它们都是`GameObject*`：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our `Game::init` function we can then create instances of the objects using
    their individual types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Game::init`函数中，我们可以创建对象的实例，使用它们的单独类型：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now they can be pushed into the array of `GameObject*`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它们可以被推入`GameObject*`数组中：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Game::draw` function can now look something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game::draw`函数现在可能看起来像这样：'
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we are looping through all of our objects and calling the `draw`
    function. The loop does not care that some of our objects are actually `Player`
    or `Enemy`; it handles them in the same manner. We are accessing them through
    a pointer to their base class. So, to add a new type, it simply needs to be derived
    from `GameObject`, and the `Game` class can handle it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在遍历所有对象并调用`draw`函数。循环并不关心我们的某些对象实际上是`Player`或`Enemy`；它以相同的方式处理它们。我们通过它们基类的指针访问它们。因此，要添加新类型，它只需从`GameObject`派生即可，`Game`类可以处理它。
- en: 'So let''s implement this for real in our framework. First we need a base class;
    we will stick with `GameObject`. We will have to make some changes to the class
    so that we can use it as a base class:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的框架中真正实现这一点。首先，我们需要一个基类；我们将坚持使用`GameObject`。我们将不得不对这个类做一些修改，以便我们可以将其用作基类：
- en: '[PRE21]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that we have now prefixed our functions with the virtual keyword. The
    virtual keyword means that when calling this function through a pointer, it uses
    the definition from the type of the object itself, not the type of its pointer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在已经用虚拟关键字前缀了我们的函数。虚拟关键字意味着当通过指针调用此函数时，它使用对象本身的类型定义，而不是其指针的类型：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In other words, this function would always call the `draw` function contained
    in `GameObject`, neither `Player` nor `Enemy`. We would never have the overridden
    behavior that we want. The virtual keyword would ensure that the `Player` and
    `Enemy` draw functions are called.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个函数总是会调用`GameObject`中包含的`draw`函数，无论是`Player`还是`Enemy`。我们永远不会得到我们想要的覆盖行为。虚拟关键字将确保调用`Player`和`Enemy`的`draw`函数。
- en: 'Now we have a base class, so let''s go ahead and try it out in our `Game` class.
    We will start by declaring the objects in the `Game` header file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基类，所以让我们在我们的`Game`类中实际尝试一下。我们首先在`Game`头文件中声明对象：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now declare along with our `GameObject*` array:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明与我们的`GameObject*`数组一起：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now create and load the objects in the `init` function, then push them into
    the array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`init`函数中创建和加载对象，然后将它们推入数组中：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So far, so good; we can now create a loop that will draw our objects and another
    that will update them. Now let''s look at the `render` and `update` functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；我们现在可以创建一个循环来绘制我们的对象，另一个循环来更新它们。现在让我们看看`render`和`update`函数：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, this is a lot tidier and also much easier to manage. Let us
    derive one more class from `GameObject` just so that we nail this concept down.
    Create a new class called `Enemy`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这要整洁得多，也更容易管理。让我们再从`GameObject`派生一个类，以便我们更深入地理解这个概念。创建一个名为`Enemy`的新类：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will define the functions of this class the same as `Player` with only the
    `update` function as an exception:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义这个类的函数与`Player`相同，只有`update`函数是一个例外：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s add it to the game. First, we declare it as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其添加到游戏中。首先，我们这样声明：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then create, load, and add to the array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建、加载并将它们添加到数组中：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have just added a new type and it was extremely quick and simple. Run the
    game to see our three objects, each with their own different behavior.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了一个新类型，而且非常快速简单。运行游戏，看看我们的三个对象，每个对象都有它们自己的不同行为。
- en: '![Implementing polymorphism](img/6821OT_03_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![实现多态](img/6821OT_03_02.jpg)'
- en: We have covered a lot here and have a really nice system for handling our game
    objects, yet we still have an issue. There is nothing stopping us from deriving
    a class without the `update` or `draw` functions that we are using here, or even
    declaring a different function and putting the `update` code in there. It is unlikely
    that we, as the developers, would make this mistake, but others using the framework
    may. What we would like is the ability to force our derived classes to have their
    own implementation of a function we decide upon, creating something of a blueprint
    that we want all of our game objects to follow. We can achieve this through the
    use of an abstract base class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里已经涵盖了大量的内容，并有一个处理游戏对象的非常不错的系统，但我们仍然有一个问题。没有任何东西阻止我们派生一个没有我们在这里使用的`update`或`draw`函数的类，甚至可以声明一个不同的函数并将`update`代码放在那里。作为开发者，我们不太可能犯这样的错误，但其他人使用框架时可能会。我们希望的是能够强制我们的派生类实现我们决定的一个函数，创建一个我们希望所有游戏对象都遵循的蓝图。我们可以通过使用抽象基类来实现这一点。
- en: Using abstract base classes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象基类
- en: If we are to implement our design correctly, then we have to be certain that
    all of our derived classes have a declaration and definition for each of the functions
    we want to access through the base class pointer. We can ensure this by making
    `GameObject` an abstract base class. An abstract base class cannot be initialized
    itself; its purpose is to dictate the design of derived classes. This gives us
    reusability as we know that any object we derive from `GameObject` will immediately
    work in the overall scheme of the game.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要正确实现我们的设计，那么我们必须确保所有派生类都有我们希望通过基类指针访问的每个函数的声明和定义。我们可以通过将`GameObject`设为抽象基类来确保这一点。抽象基类本身不能被初始化；它的目的是规定派生类的设计。这使我们能够重用，因为我们知道从`GameObject`派生的任何对象都将立即在游戏的整体方案中工作。
- en: An abstract base class is a class that contains at least one pure virtual function.
    A pure virtual function is a function that has no definition and must be implemented
    in any derived classes. We can make a function pure virtual by suffixing it with
    `=0`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类是一个包含至少一个纯虚函数的类。纯虚函数是一个没有定义且必须在任何派生类中实现的函数。我们可以通过在函数后添加`=0`来使其成为纯虚函数。
- en: Should we always use inheritance?
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们是否应该总是使用继承？
- en: Inheritance and polymorphism are both very useful and really show off the power
    of object-oriented programming. However, in some circumstances, inheritance can
    cause more problems than it solves, and therefore, we should bear in mind a few
    rules of thumb when deciding whether or not to use it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和多态都非常有用，并且真正展示了面向对象编程的强大之处。然而，在某些情况下，继承可能会造成比解决的问题更多的问题，因此，在决定是否使用它时，我们应该牢记一些经验法则。
- en: Could the same thing be achieved with a simpler solution?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否可以用更简单的解决方案达到同样的效果？
- en: Let's say we want to make a more powerful `Enemy` object; it will have the same
    behavior a regular `Enemy` object will have but with more health. One possible
    solution would be to derive a new class `PowerEnemy` from `Enemy` and give it
    double health. In this solution the new class will seem extremely sparse; it will
    use the functionality from `Enemy` but with one different value. An easier solution
    would be to have a way to set the health of an `Enemy` class, whether through
    an accessor or in the constructor. Inheritance isn't needed at all.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个更强大的`Enemy`对象；它将具有与普通`Enemy`对象相同的行为，但拥有更多的生命值。一个可能的解决方案是从`Enemy`派生一个新的类`PowerEnemy`并给它双倍的生命值。在这个解决方案中，新类看起来会非常稀疏；它将使用`Enemy`的功能，但有一个不同的值。一个更简单的解决方案是提供一种方法来设置`Enemy`类的生命值，无论是通过访问器还是构造函数。在这种情况下，继承根本不是必需的。
- en: Derived classes should model the "is a" relationship
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生类应该模拟“是”关系
- en: When deriving a class, it is a good idea for it to model the "is a" relationship.
    This means that the derived class should also be of the same type as the parent
    class. For example, deriving a `Player2` class from `Player` would fit the model,
    as `Player2` "is a" `Player`. But let's say, for example, we have a `Jetpack`
    class and we derive `Player` from this class to give it access to all the functionality
    that a `Jetpack` class has. This would not model the "is a" relationship, as a
    `Player` class is not a `Jetpack` class. It makes a lot more sense to say a `Player`
    class has a `Jetpack` class, and therefore, a `Player` class should have a member
    variable of type `Jetpack` with no inheritance; this is known as containment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生一个类时，让它模拟“是一个”关系是一个好主意。这意味着派生类也应该与父类具有相同的类型。例如，从 `Player` 类派生一个 `Player2`
    类是符合模型的，因为 `Player2` “是一个” `Player`。但是，假设我们有一个 `Jetpack` 类，并且从该类派生 `Player` 类以使其能够访问
    `Jetpack` 类的所有功能。这不会模拟“是一个”关系，因为 `Player` 类不是 `Jetpack` 类。更合理的是说 `Player` 类有一个
    `Jetpack` 类，因此 `Player` 类应该有一个类型为 `Jetpack` 的成员变量，没有继承；这被称为包含。
- en: Possible performance penalties
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的性能惩罚
- en: On platforms such as PC and Mac, the performance penalties of using inheritance
    and virtual functions are negligible. However, if you are developing for less
    powerful devices such as handheld consoles, phones, or embedded systems, this
    is something that you should take into account. If your core loop involves calling
    a virtual function many times per second, the performance penalties can add up.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PC 和 Mac 等平台上，使用继承和虚函数的性能惩罚是可以忽略不计的。然而，如果你正在为功能较弱的设备，如手持式游戏机、手机或嵌入式系统开发，这将是你需要考虑的事情。如果你的核心循环每秒多次调用虚函数，性能惩罚可能会累积。
- en: Putting it all together
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起
- en: 'We can now put all of this knowledge together and implement as much as we can
    into our framework, with reusability in mind. We have quite a bit of work to do,
    so let''s start with our abstract base class, `GameObject`. We are going to strip
    out anything SDL-specific so that we can reuse this class in other SDL projects
    if needed. Here is our stripped down `GameObject` abstract base class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有这些知识结合起来，尽可能地将它们应用到我们的框架中，同时考虑到可重用性。我们有很多工作要做，所以让我们从我们的抽象基类 `GameObject`
    开始。我们将移除所有与 SDL 相关的内容，以便在需要时可以在其他 SDL 项目中重用这个类。以下是我们的简化版 `GameObject` 抽象基类：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The pure virtual functions have been created, forcing any derived classes to
    also declare and implement them. There is also now no `load` function; the reason
    for this is that we don't want to have to create a new `load` function for each
    new project. We can be pretty sure that we will need different values when loading
    our objects for different games. The approach we will take here is to create a
    new class called `LoaderParams` and pass that into the constructor of our objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了纯虚函数，迫使任何派生类也必须声明和实现它们。现在也没有了 `load` 函数；这样做的原因是我们不希望为每个新项目都创建一个新的 `load`
    函数。我们可以相当肯定，在加载不同游戏的对象时，我们将需要不同的值。我们将采取的方法是创建一个新的类 `LoaderParams` 并将其传递到对象的构造函数中。
- en: '`LoaderParams` is simply a class that takes values into its constructor and
    sets them as member variables that can then be accessed to set the initial values
    of an object. While it may just seem that we are moving the parameters from the
    `load` function to somewhere else, it is a lot easier to just create a new `LoaderParams`
    class than to track down and alter the `load` function of all of our objects.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoaderParams` 是一个简单的类，它接受构造函数中的值并将它们设置为成员变量，然后可以访问这些变量来设置对象的初始值。虽然这看起来我们只是将参数从
    `load` 函数移动到其他地方，但创建一个新的 `LoaderParams` 类比追踪和修改所有对象的 `load` 函数要容易得多。'
- en: 'So here is our `LoaderParams` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们的 `LoaderParams` 类：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This class holds any values we need when creating our object exactly the same
    way as our `load` function used to do.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在创建对象时持有我们需要的任何值，其方式与我们的 `load` 函数曾经做的一样。
- en: 'We have also removed the `SDL_Renderer` parameter from the `draw` function.
    We will instead make our `Game` class a singleton, such as `TextureManager`. So,
    we can add the following to our `Game` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从 `draw` 函数中移除了 `SDL_Renderer` 参数。我们将使 `Game` 类成为一个单例，例如 `TextureManager`。因此，我们可以将以下内容添加到我们的
    `Game` 类中：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `Game.cpp`, we have to define our static instance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Game.cpp` 文件中，我们必须定义我们的静态实例：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s also create a function in the header file that will return our `SDL_Renderer`
    object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在头文件中创建一个函数，该函数将返回我们的 `SDL_Renderer` 对象：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that `Game` is a singleton, we are going to use it differently in our `main.cpp`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`Game`是一个单例，我们将在`main.cpp`文件中以不同的方式使用它：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now when we want to access the `m_pRenderer` value from `Game`, we can use
    the `getRenderer` function. Now that `GameObject` is essentially empty, how do
    we achieve the code-sharing we originally had? We are going to derive a new generic
    class from `GameObject` and call it `SDLGameObject`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要从`Game`访问`m_pRenderer`值时，我们可以使用`getRenderer`函数。由于`GameObject`基本上是空的，我们如何实现我们最初所期望的代码共享？我们将从一个新的通用类`GameObject`派生出一个新类，并将其命名为`SDLGameObject`：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this class we can create our reusable SDL code. First, we can use our
    new `LoaderParams` class to set our member variables:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类，我们可以创建可重用的SDL代码。首先，我们可以使用我们新的`LoaderParams`类来设置我们的成员变量：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also use the same `draw` function as before, making use of our singleton
    `Game` class to get the renderer we want:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用之前相同的`draw`函数，利用我们的单例`Game`类来获取我们想要的渲染器：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Player` and `Enemy` can now inherit from `SDLGameObject`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`和`Enemy`现在可以继承自`SDLGameObject`：'
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Player` class can be defined like so (the `Enemy` class is very similar):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`类的定义可以如下所示（`Enemy`类非常相似）：'
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that everything is in place, we can go ahead and create the objects in
    our `Game` class and see everything in action. We won''t add the objects to the
    header file this time; we will use a shortcut and build our objects in one line
    in the `init` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，我们可以继续创建`Game`类中的对象，并观察一切的实际运行情况。这次我们不会将对象添加到头文件中；我们将使用一个快捷方式，在`init`函数中一行内构建我们的对象：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Build the project. We now have everything in place to allow us to easily reuse
    our `Game` and `GameObject` classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目。我们现在已经准备好了一切，可以轻松地重用我们的`Game`和`GameObject`类。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of complex subjects in this chapter, and the concepts
    and ideas will take some time to sink in. We have covered the ability to easily
    create classes without having to rewrite a lot of similar functionality and the
    use of inheritance and how it allows us to share code between similar classes.
    We looked at polymorphism and how it can make object management a lot cleaner
    and reusable while abstract base classes took our inheritance knowledge up a notch
    by creating the blueprint we want all of our objects to follow. Finally, we put
    all our new knowledge into the context of our framework.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的复杂主题，这些概念和想法需要一些时间才能深入人心。我们介绍了如何轻松创建类，而无需重写大量类似的功能，以及继承的使用方法，它使我们能够在类似类之间共享代码。我们探讨了多态性以及它如何使对象管理变得更加简洁和可重用，而抽象基类则通过创建我们希望所有对象遵循的蓝图，将我们的继承知识提升到一个新的层次。最后，我们将所有新的知识融入到我们的框架中。
