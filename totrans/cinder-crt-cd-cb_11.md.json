["```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/gl/Texture.h\"\n#include \"cinder/Capture.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n        Capture mCamera;\n        gl::Texture mTexture;\n    ```", "```cpp\n        try{\n            mCamera = Capture( 640, 480 );\n            mCamera.start();\n        } catch( ... ){\n            console() << \"Could not initialize the capture\" << endl;\n    ```", "```cpp\n        if( mCamera ){\n            if( mCamera.checkNewFrame() ){\n                mTexture = gl::Texture( mCamera.getSurface() );\n            }\n        }\n    ```", "```cpp\n      gl::clear( Color( 0, 0, 0 ) ); \n        if( mTexture ){\n            gl::draw( mTexture, getWindowBounds() );\n        }\n    ```", "```cpp\nvector<Capture::DeviceRef> devices = Capture::getDevices();\nfor( vector<Capture::DeviceRef>::iterator it = devices.begin(); \n it != devices.end(); ++it ){\n Capture::DeviceRef device = *it;\n console() << \"Found device:\" \n  << device->getName() \n  << \" with ID:\" << device->getUniqueId() << endl;\n}\n```", "```cpp\nvector<Capture::DeviceRef> devices = Capture::getDevices();\nmCapture = Capture( 640, 480 devices[0] );\n```", "```cpp\n    #include \"cinder/gl/gl.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/ImageIo.h\"\n    #include \"cinder/Capture.h\"\n    #include \"cinder/params/Params.h\"\n    #include  \"CinderOpenCV.h\"\n    ```", "```cpp\n    Surface8u   mImage;\n    ```", "```cpp\n    vector<cv::Point2f> mCenters;\n    vector<float> mRadius;\n    ```", "```cpp\n    double mApproxEps;\n    int mCannyThresh;\n\n    ColorA      mPickedColor;\n    cv::Scalar  mColorMin;\n    cv::Scalar  mColorMax;\n    ```", "```cpp\n    Capture     mCapture;\n    gl::Texture mCaptureTex;\n    ```", "```cpp\n    setWindowSize(640, 480);\n\n    try {\n      mCapture = Capture( 640, 480 );\n      mCapture.start();\n    }\n    catch( ... ) {\n      console() <<\"Failed to initialize capture\"<<std::endl;\n    }\n    ```", "```cpp\n    mApproxEps = 1.0;\n    mCannyThresh = 200;\n\n    mPickedColor = Color8u(255, 0, 0);\n    setTrackingHSV();\n\n    // Setup the parameters\n    mParams = params::InterfaceGl( \"Parameters\", Vec2i( 200, 150 ) );\n    mParams.addParam( \"Picked Color\", &mPickedColor, \"readonly=1\" );\n    ```", "```cpp\n    if( mCapture&&mCapture.checkNewFrame() ) {\n      mImage = mCapture.getSurface();\n      mCaptureTex = gl::Texture( mImage );\n\n      cv::Mat inputMat( toOcv( mImage) );\n      cv::resize(inputMat, inputMat, cv::Size(320, 240) );\n\n      cv::Mat inputHSVMat, frameTresh;\n      cv::cvtColor(inputMat, inputHSVMat, CV_BGR2HSV);\n    ```", "```cpp\n      cv::inRange(inputHSVMat, mColorMin, mColorMax, frameTresh);\n\n      cv::medianBlur(frameTresh, frameTresh, 7);\n\n      cv::Mat cannyMat;\n      cv::Canny(frameTresh, cannyMat, mCannyThresh, mCannyThresh*2.f, 3 );\n     vector< std::vector<cv::Point> >  contours;\n     cv::findContours(cannyMat, contours, CV_RETR_LIST, \n      CV_CHAIN_APPROX_SIMPLE);\n     mCenters = vector<cv::Point2f>(contours.size());\n     mRadius = vector<float>(contours.size());\n     for( int i = 0; i < contours.size(); i++ ) {\n      std::vector<cv::Point> approxCurve;\n      cv::approxPolyDP(contours[i], approxCurve, \n       mApproxEps, true);\n      cv::minEnclosingCircle(approxCurve, mCenters[i], \n       mRadius[i]);\n     }\n    ```", "```cpp\n    }\n    ```", "```cpp\n    void MainApp::setTrackingHSV()\n    {\n    void MainApp::setTrackingHSV() {\n     Color8u col = Color( mPickedColor );\n     Vec3f colorHSV = col.get(CM_HSV);\n     colorHSV.x *= 179;\n     colorHSV.y *= 255;\n     colorHSV.z *= 255;\n     mColorMin = cv::Scalar(colorHSV.x-5, colorHSV.y -50, \n      colorHSV.z-50);\n     mColorMax = cv::Scalar(colorHSV.x+5, 255, 255);\n    }\n    ```", "```cpp\n    void MainApp::mouseDown(MouseEvent event) {\n     if( mImage&&mImage.getBounds().contains( event.getPos() ) ) {\n      mPickedColor = mImage.getPixel( event.getPos() );\n      setTrackingHSV();\n     } \n    }\n    ```", "```cpp\n    void MainApp::draw()\n    {\n     gl::clear( Color( 0.1f, 0.1f, 0.1f ) );\n     gl::color(Color::white());\n     if(mCaptureTex) {\n      gl::draw(mCaptureTex);\n      gl::color(Color::white());\n      for( int i = 0; i <mCenters.size(); i++ )\n      {\n       Vec2f center = fromOcv(mCenters[i])*2.f;\n       gl::begin(GL_POINTS);\n       gl::vertex( center );\n       gl::end();\n       gl::drawStrokedCircle(center, mRadius[i]*2.f );\n      }\n     }\n     params::InterfaceGl::draw();\n    }\n    ```", "```cpp\n#include \"cinder/Capture.h\"\n#include \"cinder/gl/Texture.h\"\n#include \"CinderOpenCV.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n        gl::Texture mTexture;\n        Capture mCamera;\n        cv::Mat mPreviousFrame;\n        vector< cv::Point2f > mPreviousFeatures, mFeatures;\n        vector< uint8_t > mFeatureStatuses;\n    ```", "```cpp\n    try{\n            mCamera = Capture( 640, 480 );\n            mCamera.start();\n        } catch( ... ){\n            console() << \"unable to initialize device\" << endl;\n        }\n    ```", "```cpp\n        if( mCamera ){\n            if( mCamera.checkNewFrame() ){\n    ```", "```cpp\n                Surface surface = mCamera.getSurface();\n                mTexture = gl::Texture( surface );\n    ```", "```cpp\n                cv::Mat frame( toOcv( Channel( surface ) ) );\n                if( mPreviousFrame.data != NULL ){\n                    cv::goodFeaturesToTrack( frame, mFeatures, 300, 0.005f, 3.0f );\n                    vector<float> errors;\n                    mPreviousFeatures = mFeatures;\n                    cv::calcOpticalFlowPyrLK( mPreviousFrame, frame, mPreviousFeatures, mFeatures, mFeatureStatuses, errors );\n                }\n    ```", "```cpp\n                mPreviousFrame = frame;\n            }\n        }\n    ```", "```cpp\n      gl::clear( Color( 0, 0, 0 ) ); \n        if( mTexture ){\n            gl::color( Color::white() );\n            gl::draw( mTexture, getWindowBounds() );\n        }\n    ```", "```cpp\n        glColor4f( 1.0f, 0.0f, 0.0f, 1.0f );\n        for( int i=0; i<mFeatures.size(); i++ ){\n            if( (bool)mFeatureStatuses[i] == false ) continue;\n            gl::drawSolidCircle( fromOcv( mFeatures[i] ), 5.0f );\n        }\n    ```", "```cpp\n        for( int i=0; i<mFeatures.size(); i++ ){\n            if( (bool)mFeatureStatuses[i] == false ) continue;\n            Vec2f pt1 = fromOcv( mFeatures[i] );\n            Vec2f pt2 = fromOcv( mPreviousFeatures[i] );\n            gl::drawLine( pt1, pt2 );\n        }\n    ```", "```cpp\n#include \"cinder/Capture.h\"\n#include \"cinder/gl/Texture.h\"\n#include \"cinder/ImageIo.h\"\n```", "```cpp\nusing namespace ci;\nusing namespace ci::app;\nusing namespace std;\n```", "```cpp\n    struct DetectionInfo{\n        vector<cv::Point2f> goodPoints;\n        vector<cv::KeyPoint> keyPoints;\n        cv::Mat image, descriptor;\n        gl::Texture texture;\n    };\n    ```", "```cpp\n    DetectionInfo mObjectInfo, mCameraInfo;\n        cv::Mat mHomography;\n        cv::SurfFeatureDetector mFeatureDetector;\n        cv::SurfDescriptorExtractor mDescriptorExtractor;\n        cv::FlannBasedMatcher mMatcher;\n        vector<cv::Point2f> mCorners;\n    ```", "```cpp\n        try{\n            mCamera = Capture( 640, 480 );\n            mCamera.start();\n        } catch( ... ){\n            console() << \"could not initialize capture\" << endl;\n        }\n    ```", "```cpp\n    mCorners.resize( 4 );\n        Surface objectSurface = loadImage( loadAsset( \"object.jpg\" ) );\n        mObjectInfo.texture = gl::Texture( objectSurface );\n        mObjectInfo.image = toOcv( Channel( objectSurface ) );\n        mFeatureDetector.detect( mObjectInfo.image, mObjectInfo.keyPoints );\n        mDescriptorExtractor.compute( mObjectInfo.image, mObjectInfo.keyPoints, mObjectInfo.descriptor );\n    ```", "```cpp\n        if( mCamera ){\n            if( mCamera.checkNewFrame() ){\n    ```", "```cpp\n    Surface cameraSurface = mCamera.getSurface();\n    mCameraInfo.texture = gl::Texture( cameraSurface );\n    mCameraInfo.image = toOcv( Channel( cameraSurface ) );\n    ```", "```cpp\n    mFeatureDetector.detect( mCameraInfo.image, mCameraInfo.keyPoints);\n    mDescriptorExtractor.compute( mCameraInfo.image, mCameraInfo.keyPoints, mCameraInfo.descriptor );\n    ```", "```cpp\n                vector<cv::DMatch> matches;\n                mMatcher.match( mObjectInfo.descriptor, mCameraInfo.descriptor, matches );\n    ```", "```cpp\n    double minDist = 640.0;\n    for( int i=0; i<mObjectInfo.descriptor.rows; i++ ){\n                    double dist = matches[i].distance;\n                    if( dist < minDist ){\n                        minDist = dist;\n                    }\n                }\n    ```", "```cpp\n    mCameraInfo.goodPoints.clear();\n    for( vector<cv::DMatch>::iterator it = matches.begin(); \n     it != matches.end(); ++it ){\n     if( it->distance < minDist*3.0 ){\n      mObjectInfo.goodPoints.push_back( \n       mObjectInfo.keyPoints[ it->queryIdx ].pt );\n      mCameraInfo.goodPoints.push_back( \n       mCameraInfo.keyPoints[ it->trainIdx ].pt );\n     }\n\n    ```", "```cpp\n    mHomography = cv::findHomography( mObjectInfo.goodPoints, mCameraInfo.goodPoints, CV_RANSAC );\n    ```", "```cpp\n      vector<cv::Point2f> objCorners( 4 );\n      objCorners[0] = cvPoint( 0.0f, 0.0f );\n      objCorners[1] = cvPoint( mObjectInfo.image.cols, 0.0f);\n      objCorners[2] = cvPoint( mObjectInfo.image.cols, \n       mObjectInfo.image.rows );\n      objCorners[3] = cvPoint( 0.0f, mObjectInfo.image.rows);\n      mCorners = vector< cv::Point2f >( 4 );\n      cv::perspectiveTransform( objCorners, mCorners, \n       mHomography );\n     } \n    }\n    ```", "```cpp\n      gl::clear( Color( 0, 0, 0 ) );\n\n        gl::color( Color::white() );\n        if( mCameraInfo.texture ){\n            gl::draw( mCameraInfo.texture, getWindowBounds() );\n        }\n\n        if( mObjectInfo.texture ){\n            gl::draw( mObjectInfo.texture );\n        }\n    ```", "```cpp\n    for( int i=0; i<mObjectInfo.goodPoints.size(); i++ ){\n     gl::drawStrokedCircle( fromOcv( mObjectInfo.goodPoints[ i ] ),\n      5.0f );\n     gl::drawStrokedCircle( fromOcv( mCameraInfo.goodPoints[ i ] ),\n      5.0f );\n     gl::drawLine( fromOcv( mObjectInfo.goodPoints[ i ] ), \n      fromOcv( mCameraInfo.goodPoints[ i ] ) );\n    }\n    ```", "```cpp\n    gl::color( Color( 1.0f, 0.0f, 0.0f ) );\n        gl::begin( GL_LINE_LOOP );\n        for( vector<cv::Point2f>::iterator it = mCorners.begin(); it != mCorners.end(); ++it ){\n            gl::vertex( it->x, it->y );\n        }\n        gl::end();\n    ```", "```cpp\n    $(CINDER_PATH)/blocks/zxing/include\n    ```", "```cpp\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Surface.h\"\n    #include \"cinder/Capture.h\"\n\n    #include <zxing/qrcode/QRCodeReader.h>\n    #include <zxing/common/GlobalHistogramBinarizer.h>\n    #include <zxing/Exception.h>\n    #include <zxing/DecodeHints.h>\n\n    #include \"CinderZXing.h\"\n    ```", "```cpp\n    Capture     mCapture;\n    Surface8u   mCaptureImg;\n    gl::Texture mCaptureTex;\n    bool        mDetected;\n    string      mData;\n    ```", "```cpp\n    setWindowSize(640, 480);\n\n    mDetected = false;\n\n    try {\n        mCapture = Capture( 640, 480 );\n        mCapture.start();\n    }\n    catch( ... ) {\n        console() <<\"Failed to initialize capture\"<< std::endl;\n    }\n    ```", "```cpp\n    if( mCapture && mCapture.checkNewFrame() ) {\n        mCaptureImg = mCapture.getSurface();\n        mCaptureTex = gl::Texture( mCaptureImg );\n\n        mDetected = false;\n\n    try {\n            zxing::Ref<zxing::SurfaceBitmapSource> source(new zxing::SurfaceBitmapSource(mCaptureImg));\n\n            zxing::Ref<zxing::Binarizer> binarizer(NULL);\n            binarizer = new zxing::GlobalHistogramBinarizer(source);\n\n            zxing::Ref<zxing::BinaryBitmap> image(new zxing::BinaryBitmap(binarizer));\n            zxing::qrcode::QRCodeReader reader;\n            zxing::DecodeHints hints(zxing::DecodeHints::BARCODEFORMAT_QR_CODE_HINT);\n\n            zxing::Ref<zxing::Result> result( reader.decode(image, hints) );\n\n            console() <<\"READ(\"<< result->count() <<\") : \"<< result->getText()->getText() << endl;\n\n    if( result->count() ) {\n                mDetected = true;\n                mData = result->getText()->getText();\n            }\n\n        } catch (zxing::Exception& e) {\n            cerr <<\"Error: \"<< e.what() << endl;\n        }\n\n    }\n    ```", "```cpp\n    gl::clear( Color( 0.1f, 0.1f, 0.1f ) );\n\n    gl::color(Color::white());\n\n    if(mCaptureTex) {\n        gl::draw(mCaptureTex);\n\n    }\n\n    if(mDetected) {\n        Vec2f pos = Vec2f( getWindowWidth()*0.5f, getWindowHeight()-100.f );\n        gl::drawStringCentered(mData, pos);\n    }\n    ```", "```cpp\n    #include \"cinder/Rand.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/Utilities.h\"\n\n    #include \"Kinect.h\"\n    #include \"InteractiveObject.h\";\n    ```", "```cpp\n    using namespace KinectSdk;\n    ```", "```cpp\n    class WaveHandGesture {\n    public:\n      enum GestureCheckResult { Fail, Pausing, Suceed };\n\n    private:\n      GestureCheckResult checkStateLeft( const Skeleton & skeleton ) {\n        // hand above elbow\n        if (skeleton.at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT).y > skeleton.at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT).y)\n        {\n          // hand right of elbow\n          if (skeleton.at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT).x > skeleton.at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT).x)\n          {\n            return Suceed;\n          }\n          return Pausing;\n        }\n        return Fail;\n      }\n      GestureCheckResult checkStateRight( const Skeleton & skeleton ) {\n        // hand above elbow\n        if (skeleton.at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT).y > skeleton.at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT).y)\n        {\n          // hand left of elbow\n          if (skeleton.at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT).x < skeleton.at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT).x)\n          {\n            return Suceed;\n          }\n          return Pausing;\n        }\n        return Fail;\n      }\n\n      int currentPhase;\n\n    public:\n      WaveHandGesture() {\n        currentPhase = 0;\n      }\n\n      GestureCheckResult check( const Skeleton & skeleton )\n      {\n        GestureCheckResult res;\n        switch(currentPhase) {\n        case0: // start on left\n        case2: \n          res = checkStateLeft(skeleton);\n          if( res == Suceed ) { currentPhase++; }\n          elseif( res == Fail ) { currentPhase = 0; return Fail; }\n          return Pausing;\n          break;\n        case1: // to the right\n        case3: \n          res = checkStateRight(skeleton);\n          if( res == Suceed ) { currentPhase++; }\n          elseif( res == Fail ) { currentPhase = 0; return Fail; }\n          return Pausing;\n          break;\n        case4: // to the left\n          res = checkStateLeft(skeleton);\n          if( res == Suceed ) { currentPhase = 0; return Suceed; }\n          elseif( res == Fail ) { currentPhase = 0; return Fail; }\n          return Pausing;\n          break;\n        }\n\n        return Fail;\n      }\n    };\n    ```", "```cpp\n    class NuiInteractiveObject: public InteractiveObject {\n    public:\n      NuiInteractiveObject(const Rectf & rect) : InteractiveObject(rect) {\n        mHilight = 0.0f;\n      }\n\n      void update(bool activated, const Vec2f & cursorPos) {\n        if(activated && rect.contains(cursorPos)) {\n          mHilight += 0.08f;\n        } else {\n          mHilight -= 0.005f;\n        }\n        mHilight = math<float>::clamp(mHilight);\n      }\n\n      virtualvoid draw() {\n        gl::color(0.f, 0.f, 1.f, 0.3f+0.7f*mHilight);\n        gl::drawSolidRect(rect);\n      }\n\n      float mHilight;\n    };\n    ```", "```cpp\n    class NuiController {\n    public:\n      NuiController() {}\n\n      void registerObject(NuiInteractiveObject *object) {\n        objects.push_back( object );\n      }\n\n      void unregisterObject(NuiInteractiveObject *object) {\n        vector<NuiInteractiveObject*>::iterator it = find(objects.begin(), objects.end(), object);\n        objects.erase( it );\n      }\n\n      void clear() { objects.clear(); }\n\n      void update(bool activated, const Vec2f & cursorPos) {\n        vector<NuiInteractiveObject*>::iterator it;\n        for(it = objects.begin(); it != objects.end(); ++it) {\n          (*it)->update(activated, cursorPos);\n        }\n      }\n\n      void draw() {\n        vector<NuiInteractiveObject*>::iterator it;\n        for(it = objects.begin(); it != objects.end(); ++it) {\n          (*it)->draw();\n        }\n      }\n\n      vector<NuiInteractiveObject*> objects;\n    };\n    ```", "```cpp\n    KinectSdk::KinectRef          mKinect;\n    vector<KinectSdk::Skeleton>   mSkeletons;\n    gl::Texture                   mVideoTexture;\n    ```", "```cpp\n    Rectf  mPIZ;\n    Vec2f  mCursorPos;\n    ```", "```cpp\n    vector<WaveHandGesture*>    mGestureControllers;\n    bool  mUserActivated;\n    int  mActiveUser;\n    ```", "```cpp\n    NuiController* mNuiController;\n    ```", "```cpp\n    void MainApp::prepareSettings(Settings* settings)\n    {\n      settings->setWindowSize(800, 600);\n    }\n    ```", "```cpp\n    mPIZ = Rectf(0.f,0.f, 0.85f,0.5f);\n    mCursorPos = Vec2f::zero();\n\n    mUserActivated = false;\n    mActiveUser = 0;\n    ```", "```cpp\n    mKinect = Kinect::create();\n    mKinect->enableDepth( false );\n    mKinect->enableVideo( false );\n    mKinect->start();\n\n    for(int i = 0; i <10; i++) {\n        mGestureControllers.push_back( new WaveHandGesture() );\n    }\n    ```", "```cpp\n    mNuiController = new NuiController();\n\n    float cols = 10.f;\n    float rows = 10.f;\n\n    Rectf rect = Rectf(0.f,0.f, getWindowWidth()/cols - 1.f, getWindowHeight()/rows - 1.f);\n\n    or(int ir = 0; ir < rows; ir++) {\n     for(int ic = 0; ic < cols; ic++) {\n      Vec2f offset = (rect.getSize()+Vec2f::one()) \n       * Vec2f(ic,ir);\n      Rectf r = Rectf( offset, offset+rect.getSize() );\n      mNuiController->registerObject( \n       new NuiInteractiveObject® );\n     } \n    }\n    ```", "```cpp\n    if ( mKinect->isCapturing() ) {\n     if ( mKinect->checkNewSkeletons() ) {\n      mSkeletons = mKinect->getSkeletons();\n     }\n     uint32_t i = 0;\n     vector<Skeleton>::const_iterator skeletonIt;\n     for (skeletonIt = mSkeletons.cbegin(); \n       skeletonIt != mSkeletons.cend(); ++skeletonIt, i++ ) {\n    ```", "```cpp\n      if(mUserActivated && i == mActiveUser \n       && skeletonIt->size() != \n       JointName::NUI_SKELETON_POSITION_COUNT ) {\n       mUserActivated = false;\n      }\n    ```", "```cpp\n    if ( skeletonIt->size() == JointName::NUI_SKELETON_POSITION_COUNT && i <10 ) {\n    ```", "```cpp\n    if( !mUserActivated || ( mUserActivated && i != mActiveUser ) ) {\n        WaveHandGesture::GestureCheckResult res;\n        res = mGestureControllers[i]->check( *skeletonIt );\n\n        if( res == WaveHandGesture::Suceed && ( !mUserActivated || i != mActiveUser ) ) {\n            mActiveUser = i;\n\n         float armLen = 0;\n            Vec3f handRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT);\n            Vec3f elbowRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT);\n            Vec3f shoulderRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_SHOULDER_RIGHT);\n\n            armLen += handRight.distance( elbowRight );\n            armLen += elbowRight.distance( shoulderRight );\n\n            mPIZ.x2 = armLen;\n            mPIZ.y2 = mPIZ.getWidth() / getWindowAspectRatio();\n\n            mUserActivated = true;\n        }\n    }\n    ```", "```cpp\n    if(mUserActivated && i == mActiveUser) {\n        Vec3f handPos = skeletonIt->at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT);\n\n        Rectf piz = Rectf(mPIZ);\n        piz.offset( skeletonIt->at(JointName::NUI_SKELETON_POSITION_SPINE).xy() );\n\n        mCursorPos = handPos.xy() - piz.getUpperLeft();\n        mCursorPos /= piz.getSize();\n        mCursorPos.y = (1.f - mCursorPos.y);\n        mCursorPos *= getWindowSize();\n    }\n    ```", "```cpp\n            }\n        }\n    }\n    ```", "```cpp\n    mNuiController->update(mUserActivated, mCursorPos);\n    ```", "```cpp\n    void MainApp::draw()\n    {\n      // Clear window\n      gl::setViewport( getWindowBounds() );\n      gl::clear( Color::white() );\n      gl::setMatricesWindow( getWindowSize() );\n      gl::enableAlphaBlending();\n\n      mNuiController->draw();\n\n      if(mUserActivated) {\n        gl::color(1.f,0.f,0.5f, 1.f);\n        glLineWidth(10.f);\n        gl::drawStrokedCircle(mCursorPos, 25.f);\n      }\n    }\n    ```", "```cpp\n    #include \"cinder/app/AppNative.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/gl/GlslProg.h\"\n    #include \"cinder/TriMesh.h\"\n    #include \"cinder/ImageIo.h\"\n    #include \"cinder/MayaCamUI.h\"\n    #include \"cinder/params/Params.h\"\n    #include \"cinder/Utilities.h\"\n\n    #include \"Kinect.h\"\n    ```", "```cpp\n    using namespace KinectSdk;\n    ```", "```cpp\n    KinectSdk::KinectRef            mKinect;\n    vector<KinectSdk::Skeleton>     mSkeletons;\n    gl::Texture                     mVideoTexture;\n    ```", "```cpp\n    CameraPersp        mCam;\n    Vec3f              mCamEyePoint;\n    float              mCamFov;\n    ```", "```cpp\n    Vec3f    mPositionScale;\n    float    mActivationDist;\n    ```", "```cpp\n    gl::GlslProg  mShader;\n    gl::Texture   mTexture;\n    TriMesh       mMesh;\n    ```", "```cpp\n    setWindowSize(800, 600);\n\n    mCamEyePoint = Vec3f(0.f,0.f,1.f);\n    mCamFov = 33.f;\n\n    mPositionScale = Vec3f(1.f,1.f,-1.f);\n    mActivationDist = 0.6f;\n    ```", "```cpp\n    mMesh.read( loadFile( getAssetPath(\"ducky.msh\") ) );\n\n    gl::Texture::Format format;\n    format.enableMipmapping(true);\n    ImageSourceRef img = loadImage( getAssetPath(\"ducky.png\") );\n    if(img) mTexture = gl::Texture( img, format );\n\n    mShader = gl::GlslProg( loadFile(getAssetPath(\"phong_vert.glsl\")), loadFile(getAssetPath(\"phong_frag.glsl\")) );\n    ```", "```cpp\n    mKinect = Kinect::create();\n    mKinect->enableDepth( false );\n    mKinect->start();\n    ```", "```cpp\n    mParams = params::InterfaceGl( \"parameters\", Vec2i( 200, 500 ) );\n    mParams.addParam(\"Eye Point\", &mCamEyePoint);\n    mParams.addParam(\"Camera FOV\", &mCamFov);\n    mParams.addParam(\"Position Scale\", &mPositionScale);\n    mParams.addParam(\"Activation Distance\", &mActivationDist);\n    ```", "```cpp\n    void MainApp::update()\n    {\n      mCam.setPerspective( mCamFov, getWindowAspectRatio(), 0.1, 10000 );\n      mCam.setEyePoint(mCamEyePoint);\n      mCam.setViewDirection(Vec3f(0.f,0.f, -1.f*mCamEyePoint.z));\n\n      if ( mKinect->isCapturing() ) {\n        if ( mKinect->checkNewVideoFrame() ) {\n          mVideoTexture = gl::Texture( mKinect->getVideo() );\n        }\n        if ( mKinect->checkNewSkeletons() ) {\n          mSkeletons = mKinect->getSkeletons();\n        }\n      }\n    }\n    ```", "```cpp\n    void MainApp::drawObject()\n    {\n\n      mTexture.bind();\n      mShader.bind();\n      mShader.uniform(\"tex0\", 0);\n\n      gl::color( Color::white() );\n      gl::pushModelView();\n      gl::scale(0.05f,0.05f,0.05f);\n      gl::rotate(Vec3f(0.f,-30.f,0.f));\n      gl::draw( mMesh );\n      gl::popModelView();\n\n      mShader.unbind();\n      mTexture.unbind();\n    }\n    ```", "```cpp\n    void MainApp::draw()\n    {\n      gl::setViewport( getWindowBounds() );\n      gl::clear( Colorf( 0.1f, 0.1f, 0.1f ) );\n      gl::setMatricesWindow( getWindowSize() );\n\n      if ( mKinect->isCapturing() && mVideoTexture ) {\n        gl::color( ColorAf::white() );\n        gl::draw( mVideoTexture, getWindowBounds() );\n        draw3DScene();\n      }\n\n      params::InterfaceGl::draw();\n    }\n    ```", "```cpp\n    gl::enableDepthRead();\n    gl::enableDepthWrite();\n\n    Vec3f mLightDirection = Vec3f( 0, 0, -1 );\n    ColorA mColor = ColorA( 0.25f, 0.5f, 1.0f, 1.0f );\n\n    gl::pushMatrices();\n    gl::setMatrices( mCam );\n\n    vector<KinectSdk::Skeleton>::const_iterator skelIt;\n    for ( skelIt = mSkeletons.cbegin(); skelIt != mSkeletons.cend(); ++skelIt ) {\n\n    if ( skelIt->size() == JointName::NUI_SKELETON_POSITION_COUNT ) {\n            KinectSdk::Skeleton skel = *skelIt;\n\n            Vec3f pos, dV;\n    float armLen = 0;\n            Vec3f handRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_HAND_RIGHT);\n            Vec3f elbowRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_ELBOW_RIGHT);\n            Vec3f shoulderRight = skeletonIt->at(JointName::NUI_SKELETON_POSITION_SHOULDER_RIGHT);\n\n            armLen += handRight.distance( elbowRight );\n            armLen += elbowRight.distance( shoulderRight );\n\n            pos = skel[JointName::NUI_SKELETON_POSITION_HAND_RIGHT];\n            dV = pos - skel[JointName::NUI_SKELETON_POSITION_SHOULDER_RIGHT];\n    if( dV.z < -armLen*mActivationDist ) {\n                gl::pushMatrices();\n                gl::translate(pos*mPositionScale);\n                drawObject();\n                gl::popMatrices();\n            }\n        }\n    }\n\n    gl::popMatrices();\n\n    gl::enableDepthRead(false);\n    gl::enableDepthWrite(false);\n    ```", "```cpp\n    void MainApp::shutdown()\n    {\n      mKinect->stop();\n    }\n    ```"]