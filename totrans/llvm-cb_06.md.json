["```cpp\n    int test (int a, int b, int c) {\n            return c/(a+b);\n    }\n```", "```cpp\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n      %add = add nsw i32 %a, %b\n      %div = sdiv i32 %add, %c\n      return i32 %div\n    }\n```", "```cpp\n    $ sudo apt-add-repository ppa:dperry/ppa-graphviz-test\n\n    ```", "```cpp\n    $ sudo apt-get update\n\n    ```", "```cpp\n    $ sudo apt-get install graphviz\n\n    ```", "```cpp\n    $ sudo apt-get remove libcdt4\n    $ sudo apt-get remove libpathplan4\n\n    ```", "```cpp\n    $ sudo apt-get install graphviz\n\n    ```", "```cpp\n    $ cat test.ll\n    define i32 @test(i32 %a, i32 %b, i32 %c) {\n     %add = add nsw i32 %a, %b\n     %div = sdiv i32 %add, %c\n     ret i32 %div\n    }\n\n    ```", "```cpp\n    $ llc -view-dag-combine1-dags test.ll\n\n    ```", "```cpp\n    $ llc -view-legalize-dags test.ll\n\n    ```", "```cpp\n    $ llc -view-dag-combine2-dags test.ll\n\n    ```", "```cpp\n    $ llc -view-isel-dags test.ll\n\n    ```", "```cpp\n    $ llc -view-sched-dags test.ll\n\n    ```", "```cpp\n    $ llc -view-sunit-dags test.ll\n\n    ```", "```cpp\n    $ mkdir llvm_root_directory/lib/Target/SAMPLE\n\n    ```", "```cpp\n    $ cd llvm_root_directory/lib/Target/SAMPLE\n    $ vi SAMPLERegisterInfo.td\n\n    ```", "```cpp\n    class SAMPLEReg<bits<16> Enc, string n> : Register<n> {\n      let HWEncoding = Enc;\n      let Namespace = \"SAMPLE\";\n    }\n\n    foreach i = 0-3 in {\n      def R#i : R<i, \"r\"#i >;\n    }\n\n    def SP  : SAMPLEReg<13, \"sp\">;\n    def LR  : SAMPLEReg<14, \"lr\">;\n\n    def GRRegs : RegisterClass<\"SAMPLE\", [i32], 32,\n      (add R0, R1, R2, R3, SP)>;\n    ```", "```cpp\n    $ vi SAMPLEInstrInfo.td\n\n    ```", "```cpp\n    def ADDrr : InstSAMPLE<(outs GRRegs:$dst),\n              (ins GRRegs:$src1, GRRegs:$src2),\n               \"add $dst, $src1, $src2\",\n               [(set i32:$dst, (add i32:$src1, i32:$src2))]>;\n    ```", "```cpp\nadd r0, r0, r1\n```", "```cpp\nMachineInstr::MachineInstr(MachineFunction &MF, const MCInstrDesc &tid, const DebugLoc dl, bool NoImp)\n  : MCID(&tid), Parent(nullptr), Operands(nullptr), NumOperands(0),\n    Flags(0), AsmPrinterFlags(0),\n    NumMemRefs(0), MemRefs(nullptr), debugLoc(dl) {\n  // Reserve space for the expected number of operands.\n  if (unsigned NumOps = MCID->getNumOperands() +\n    MCID->getNumImplicitDefs() + MCID->getNumImplicitUses()) {\n    CapOperands = OperandCapacity::get(NumOps);\n    Operands = MF.allocateOperandArray(CapOperands);\n  }\n\n  if (!NoImp)\n    addImplicitDefUseOperands(MF);\n}\n```", "```cpp\nvoid MachineInstr::addOperand(MachineFunction &MF, const MachineOperand &Op) {\n  assert(MCID && \"Cannot add operands before providing an instr descriptor\");\n  if (&Op >= Operands && &Op < Operands + NumOperands) {\n    MachineOperand CopyOp(Op);\n    return addOperand(MF, CopyOp);\n  }\n  unsigned OpNo = getNumOperands();\n  bool isImpReg = Op.isReg() && Op.isImplicit();\n  if (!isImpReg && !isInlineAsm()) {\n    while (OpNo && Operands[OpNo-1].isReg() && Operands[OpNo-1].isImplicit()) {\n      --OpNo;\n      assert(!Operands[OpNo].isTied() && \"Cannot move tied operands\");\n    }\n  }\n\n#ifndef NDEBUG\n  bool isMetaDataOp = Op.getType() == MachineOperand::MO_Metadata;\n  assert((isImpReg || Op.isRegMask() || MCID->isVariadic() ||\n          OpNo < MCID->getNumOperands() || isMetaDataOp) &&\n         \"Trying to add an operand to a machine instr that is already done!\");\n#endif\n\n  MachineRegisterInfo *MRI = getRegInfo();\n  OperandCapacity OldCap = CapOperands;\n  MachineOperand *OldOperands = Operands;\n  if (!OldOperands || OldCap.getSize() == getNumOperands()) {\n    CapOperands = OldOperands ? OldCap.getNext() : OldCap.get(1);\n    Operands = MF.allocateOperandArray(CapOperands);\n    if (OpNo)\n      moveOperands(Operands, OldOperands, OpNo, MRI);\n  }\n  if (OpNo != NumOperands)\n    moveOperands(Operands + OpNo + 1, OldOperands + OpNo, NumOperands - OpNo,\n                 MRI);\n  ++NumOperands;\n  if (OldOperands != Operands && OldOperands)\n    MF.deallocateOperandArray(OldCap, OldOperands);\n  MachineOperand *NewMO = new (Operands + OpNo) MachineOperand(Op);\n  NewMO->ParentMI = this;\n  if (NewMO->isReg()) {\n        NewMO->Contents.Reg.Prev = nullptr;\n    NewMO->TiedTo = 0;\n        if (MRI)\n      MRI->addRegOperandToUseList(NewMO);\n        if (!isImpReg) {\n            if (NewMO->isUse()) {\n        int DefIdx = MCID->getOperandConstraint(OpNo, MCOI::TIED_TO);\n        if (DefIdx != -1)\n          tieOperands(DefIdx, OpNo);\n      }\n           if (MCID->getOperandConstraint(OpNo, MCOI::EARLY_CLOBBER) != -1)\n        NewMO->setIsEarlyClobber(true);\n    }\n  }\n}\n```", "```cpp\nvoid MachineInstr::addMemOperand(MachineFunction &MF,\n                                 MachineMemOperand *MO) {\n  mmo_iterator OldMemRefs = MemRefs;\n  unsigned OldNumMemRefs = NumMemRefs;\n  unsigned NewNum = NumMemRefs + 1;\n  mmo_iterator NewMemRefs = MF.allocateMemRefsArray(NewNum);\n  std::copy(OldMemRefs, OldMemRefs + OldNumMemRefs, NewMemRefs);\n  NewMemRefs[NewNum - 1] = MO;\n  setMemRefs(NewMemRefs, NewMemRefs + NewNum);\n}\n```", "```cpp\n    MachineInstr *MI = BuildMI(X86::MOV32ri, 1, DestReg).addImm(42);\n    ```", "```cpp\n    MachineBasicBlock &MBB = BuildMI(MBB, X86::MOV32ri, 1, DestReg).addImm(42);\n    ```", "```cpp\n    MachineBasicBlock::iterator MBBI = \n    BuildMI(MBB, MBBI, X86::MOV32ri, 1, DestReg).addImm(42)\n    ```", "```cpp\n    BuildMI(MBB, X86::JNE, 1).addMBB(&MBB);\n    ```", "```cpp\n    const BasicBlock *getBasicBlock() const { return BB; }\n    ```", "```cpp\n    std::vector<MachineBasicBlock *> Predecessors;\n    std::vector<MachineBasicBlock *> Successors;\n    ```", "```cpp\n      MachineBasicBlock::insert(instr_iterator I, MachineInstr *MI) {\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc()  && \"Cannot insert instruction with bundle flags\");\n\n    if (I != instr_end() && I->isBundledWithPred()) {        MI->setFlag(MachineInstr::BundledPred);              MI->setFlag(MachineInstr::BundledSucc);\n    }\n        return Insts.insert(I, MI);\n    }\n    ```", "```cpp\n    MachineBasicBlock *\n    MachineBasicBlock::SplitCriticalEdge(MachineBasicBlock *Succ, Pass *P) {\n    …\n    …\n    …\n    }\n    ```", "```cpp\n    MachineRegisterInfo *RegInfo;\n    ```", "```cpp\n    MachineFrameInfo *FrameInfo;\n    ```", "```cpp\n    MachineConstantPool *ConstantPool;\n    ```", "```cpp\n    MachineJumpTableInfo *JumpTableInfo;\n    ```", "```cpp\n    typedef ilist<MachineBasicBlock> BasicBlockListType;\n    BasicBlockListType BasicBlocks;\n    ```", "```cpp\n    const Function *getFunction() const { return Fn; }\n    ```", "```cpp\n    MachineInstr *CreateMachineInstr(const MCInstrDesc &MCID,\n    DebugLoc DL,\n    bool NoImp = false);\n    ```", "```cpp\nclass SelectionDAG {\nconst TargetMachine &TM;\nconst TargetLowering &TLI;\nconst TargetSelectionDAGInfo &TSI;\nMachineFunction *MF;\nLLVMContext *Context;\nCodeGenOpt::Level OptLevel;\n\nSDNode EntryNode;\n// Root - The root of the entire DAG.\nSDValue Root;\n\n// AllNodes - A linked list of nodes in the current DAG.\nilist<SDNode> AllNodes;\n\n// NodeAllocatorType - The AllocatorType for allocating SDNodes. We use\n\ntypedef RecyclingAllocator<BumpPtrAllocator, SDNode, sizeof(LargestSDNode),\nAlignOf<MostAlignedSDNode>::Alignment>\nNodeAllocatorType;\n\nBumpPtrAllocator OperandAllocator;\n\nBumpPtrAllocator Allocator;\n\nSDNodeOrdering *Ordering;\n\npublic:\n\nstruct DAGUpdateListener {\n\nDAGUpdateListener *const Next;\n\nSelectionDAG &DAG;\n\nexplicit DAGUpdateListener(SelectionDAG &D)\n: Next(D.UpdateListeners), DAG(D) {\nDAG.UpdateListeners = this;\n}\n\nprivate:\n\nfriend struct DAGUpdateListener;\n\nDAGUpdateListener *UpdateListeners;\n\nvoid init(MachineFunction &mf);\n\n// Function to set root node of SelectionDAG\nconst SDValue &setRoot(SDValue N) {\n  assert((!N.getNode() || N.getValueType() == MVT::Other) &&\n    \"DAG root value is not a chain!\");\n  if (N.getNode())\n    checkForCycles(N.getNode());\n  Root = N;\n  if (N.getNode())\n    checkForCycles(this);\n  return Root;\n}\n\nvoid Combine(CombineLevel Level, AliasAnalysis &AA,\nCodeGenOpt::Level OptLevel);\n\nSDValue getConstant(uint64_t Val, EVT VT, bool isTarget = false);\n\nSDValue getConstantFP(double Val, EVT VT, bool isTarget = false);\n\nSDValue getGlobalAddress(const GlobalValue *GV, DebugLoc DL, EVT VT, int64_t offset = 0, bool isTargetGA = false, \nunsigned char TargetFlags = 0);\n\nSDValue getFrameIndex(int FI, EVT VT, bool isTarget = false);\n\nSDValue getTargetIndex(int Index, EVT VT, int64_t Offset = 0,\nunsigned char TargetFlags = 0);\n\n// Function to return Basic Block corresponding to this MachineBasicBlock\nSDValue getBasicBlock(MachineBasicBlock *MBB);\n\nSDValue getBasicBlock(MachineBasicBlock *MBB, DebugLoc dl);\n\nSDValue getExternalSymbol(const char *Sym, EVT VT);\n\nSDValue getExternalSymbol(const char *Sym, DebugLoc dl, EVT VT);\n\nSDValue getTargetExternalSymbol(const char *Sym, EVT VT,\nunsigned char TargetFlags = 0);\n\n// Return the type of the value this SelectionDAG node corresponds // to\nSDValue getValueType(EVT);\n\nSDValue getRegister(unsigned Reg, EVT VT);\n\nSDValue getRegisterMask(const uint32_t *RegMask);\n\nSDValue getEHLabel(DebugLoc dl, SDValue Root, MCSymbol *Label);\n\nSDValue getBlockAddress(const BlockAddress *BA, EVT VT,\nint64_t Offset = 0, bool isTarget = false,\nunsigned char TargetFlags = 0);\n\nSDValue getSExtOrTrunc(SDValue Op, DebugLoc DL, EVT VT);\n\nSDValue getZExtOrTrunc(SDValue Op, DebugLoc DL, EVT VT);\n\nSDValue getZeroExtendInReg(SDValue Op, DebugLoc DL, EVT SrcTy);\n\nSDValue getNOT(DebugLoc DL, SDValue Val, EVT VT);\n\n// Function to get SelectionDAG node.\nSDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT);\n\nSDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT, SDValue N);\n\nSDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT, SDValue N1, SDValue N2);\n\nSDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT,\nSDValue N1, SDValue N2, SDValue N3);\n\nSDValue getMemcpy(SDValue Chain, DebugLoc dl, SDValue Dst, SDValue Src,SDValue Size, unsigned Align, bool isVol, bool AlwaysInline,\nMachinePointerInfo DstPtrInfo,MachinePointerInfo SrcPtrInfo);\n\nSDValue getAtomic(unsigned Opcode, DebugLoc dl, EVT MemVT, SDValue Chain,\nSDValue Ptr, SDValue Cmp, SDValue Swp,\nMachinePointerInfo PtrInfo, unsigned Alignment,\nAtomicOrdering Ordering,\nSynchronizationScope SynchScope);\n\nSDNode *UpdateNodeOperands(SDNode *N, SDValue Op);\n\nSDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2);\n\nSDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\nSDValue Op3);\n\nSDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT);\n\nSDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT, SDValue Op1);\n\nSDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT,\nSDValue Op1, SDValue Op2);\n\nMachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT);\nMachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT,\nSDValue Op1);\n\nMachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT,\nSDValue Op1, SDValue Op2);\n\nvoid ReplaceAllUsesWith(SDValue From, SDValue Op);\n\nvoid ReplaceAllUsesWith(SDNode *From, SDNode *To);\n\nvoid ReplaceAllUsesWith(SDNode *From, const SDValue *To);\n\nbool isBaseWithConstantOffset(SDValue Op) const;\n\nbool isKnownNeverNaN(SDValue Op) const;\n\nbool isKnownNeverZero(SDValue Op) const;\n\nbool isEqualTo(SDValue A, SDValue B) const;\n\nSDValue UnrollVectorOp(SDNode *N, unsigned ResNE = 0);\n\nbool isConsecutiveLoad(LoadSDNode *LD, LoadSDNode *Base,\n\nunsigned Bytes, int Dist) const;\n\nunsigned InferPtrAlignment(SDValue Ptr) const;\n\nprivate:\n\nbool RemoveNodeFromCSEMaps(SDNode *N);\n\nvoid AddModifiedNodeToCSEMaps(SDNode *N);\n\nSDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op, void *&InsertPos);\n\nSDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op1, SDValue Op2,\nvoid *&InsertPos);\n\nSDNode *FindModifiedNodeSlot(SDNode *N, const SDValue *Ops, unsigned NumOps,void *&InsertPos);\n\nSDNode *UpdadeDebugLocOnMergedSDNode(SDNode *N, DebugLoc loc);\n\nvoid DeleteNodeNotInCSEMaps(SDNode *N);\n\nvoid DeallocateNode(SDNode *N);\n\nunsigned getEVTAlignment(EVT MemoryVT) const;\n\nvoid allnodes_clear();\n\nstd::vector<SDVTList> VTList;\n\nstd::vector<CondCodeSDNode*> CondCodeNodes;\n\nstd::vector<SDNode*> ValueTypeNodes;\n\nstd::map<EVT, SDNode*, EVT::compareRawBits> ExtendedValueTypeNodes;\n\nStringMap<SDNode*> ExternalSymbols;\n\nstd::map<std::pair<std::string, unsigned char>,SDNode*> TargetExternalSymbols;\n};\n```", "```cpp\nnamespace {\nclass SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener {\n\nconst TargetMachine &TM;\n\nconst TargetLowering &TLI;\n\nSelectionDAG &DAG;\n\nSelectionDAG::allnodes_iterator LegalizePosition;\n\n// LegalizedNodes - The set of nodes which have already been legalized.\nSmallPtrSet<SDNode *, 16> LegalizedNodes;\n\npublic:\nexplicit SelectionDAGLegalize(SelectionDAG &DAG);\nvoid LegalizeDAG();\n\nprivate:\n\nvoid LegalizeOp(SDNode *Node);\n\nSDValue OptimizeFloatStore(StoreSDNode *ST);\n\n// Legalize Load operations\nvoid LegalizeLoadOps(SDNode *Node);\n\n// Legalize Store operations\nvoid LegalizeStoreOps(SDNode *Node);\n\n// Main legalize function which operates on Selection DAG node\nvoid SelectionDAGLegalize::LegalizeOp(SDNode *Node) {\n// A target node which is constant need not be legalized further\n  if (Node->getOpcode() == ISD::TargetConstant)\n    return;\n\n  for (unsigned i = 0, e = Node->getNumValues(); i != e; ++i)\n    assert(TLI.getTypeAction(*DAG.getContext(), Node->getValueType(i)) == TargetLowering::TypeLegal && \"Unexpected illegal type!\");\n\n  for (unsigned i = 0, e = Node->getNumOperands(); i != e; ++i)\n    assert((TLI.getTypeAction(*DAG.getContext(),\n    Node->getOperand(i).getValueType()) == TargetLowering::TypeLegal ||\n      Node->getOperand(i).getOpcode() == ISD::TargetConstant) && \"Unexpected illegal type!\");\n\n  TargetLowering::LegalizeAction Action = TargetLowering::Legal;\n  bool SimpleFinishLegalizing = true;\n\n// Legalize based on instruction opcode\n  switch (Node->getOpcode()) {\n    case ISD::INTRINSIC_W_CHAIN:\n    case ISD::INTRINSIC_WO_CHAIN:\n    case ISD::INTRINSIC_VOID:\n    case ISD::STACKSAVE:\n          Action = TLI.getOperationAction(Node->getOpcode(), MVT::Other);\n    break;\n…\n…\n}\n```", "```cpp\n$ cat test.ll\ndefine i64 @test(i64 %a, i64 %b, i64 %c) {\n %add = add nsw i64 %a, %b\n %div = sdiv i64 %add, %c\n ret i64 %div\n}\n\n```", "```cpp\n$ llc -view-dag-combine1-dags test.ll\n\n```", "```cpp\n$ llc -view-dag-combine2-dags test.ll\n\n```", "```cpp\n$ cat test.ll\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n %add = add nsw i32 %a, %b\n %div = sdiv i32 %add, %c\n ret i32 %div\n}\n\n```", "```cpp\n$ llc –view-dag-combine1-dags test.ll\n\n```", "```cpp\n$ llc -view-dag-combine2-dags test.ll\n\n```", "```cpp\nclass DAGCombiner {\nSelectionDAG &DAG;\nconst TargetLowering &TLI;\nCombineLevel Level;\nCodeGenOpt::Level OptLevel;\nbool LegalOperations;\nbool LegalTypes;\n\nSmallPtrSet<SDNode*, 64> WorkListContents;\nSmallVector<SDNode*, 64> WorkListOrder;\n\nAliasAnalysis &AA;\n\n// Add SDnodes users to worklist\nvoid AddUsersToWorkList(SDNode *N) {\n  for (SDNode::use_iterator UI = N->use_begin(),\n        UE = N->use_end(); UI != UE; ++UI)\n    AddToWorkList(*UI);\n}\nSDValue visit(SDNode *N);\n\npublic:\n\nvoid AddToWorkList(SDNode *N) {\n  WorkListContents.insert(N);\n  WorkListOrder.push_back(N);\n}\n\nvoid removeFromWorkList(SDNode *N) {\n  WorkListContents.erase(N);\n}\n\n// SDnode combine operations.\nSDValue CombineTo(SDNode *N, const SDValue *To, unsigned NumTo,\nbool AddTo = true);\n\nSDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true) {\n  return CombineTo(N, &Res, 1, AddTo);\n}\n\nSDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1,\nbool AddTo = true) {\n  SDValue To[] = { Res0, Res1 };\n  return CombineTo(N, To, 2, AddTo);\n}\nvoid CommitTargetLoweringOpt(const TargetLowering::TargetLoweringOpt &TLO);\n\nprivate:\n\nbool SimplifyDemandedBits(SDValue Op) {\n  unsigned BitWidth = Op.getValueType().getScalarType().getSizeInBits();\n  APInt Demanded = APInt::getAllOnesValue(BitWidth);\n  return SimplifyDemandedBits(Op, Demanded);\n}\nbool SimplifyDemandedBits(SDValue Op, const APInt &Demanded);\n\nbool CombineToPreIndexedLoadStore(SDNode *N);\n\nbool CombineToPostIndexedLoadStore(SDNode *N);\n\nvoid ReplaceLoadWithPromotedLoad(SDNode *Load, SDNode *ExtLoad);\n\nSDValue PromoteOperand(SDValue Op, EVT PVT, bool &Replace);\n\nSDValue SExtPromoteOperand(SDValue Op, EVT PVT);\n\nSDValue ZExtPromoteOperand(SDValue Op, EVT PVT);\n\nSDValue PromoteIntBinOp(SDValue Op);\n\nSDValue PromoteIntShiftOp(SDValue Op);\n\nSDValue PromoteExtend(SDValue Op);\n\nbool PromoteLoad(SDValue Op);\n\nvoid ExtendSetCCUses(SmallVector<SDNode*, 4> SetCCs,\nSDValue Trunc, SDValue ExtLoad, DebugLoc DL,\nISD::NodeType ExtType);\n\nSDValue combine(SDNode *N);\n\n// Various visit functions operating on instructions represented\n// by SD node. Similar to instruction combining at IR level.\nSDValue visitTokenFactor(SDNode *N);\n\nSDValue visitMERGE_VALUES(SDNode *N);\n\nSDValue visitADD(SDNode *N);\nSDValue visitSUB(SDNode *N);\nSDValue visitADDC(SDNode *N);\nSDValue visitSUBC(SDNode *N);\nSDValue visitADDE(SDNode *N);\nSDValue visitSUBE(SDNode *N);\nSDValue visitMUL(SDNode *N);\n\npublic:\n\nDAGCombiner(SelectionDAG &D, AliasAnalysis &A, CodeGenOpt::Level OL)\n: DAG(D), TLI(D.getTargetLoweringInfo()), Level(BeforeLegalizeTypes),\n  OptLevel(OL), LegalOperations(false), LegalTypes(false), AA(A) {}\n\n// Selection DAG transformation for following ops\nSDValue DAGCombiner::visitMUL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantSDNode *N0C = dyn_cast<ConstantSDNode>(N0);\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  EVT VT = N0.getValueType();\n  if (VT.isVector()) {\n    SDValue FoldedVOp = SimplifyVBinOp(N);\n    if (FoldedVOp.getNode()) return FoldedVOp;\n  }\n  if (N0.getOpcode() == ISD::UNDEF || N1.getOpcode() == ISD::UNDEF)\n    return DAG.getConstant(0, VT);\n\n  if (N0C && N1C)\n    return DAG.FoldConstantArithmetic(ISD::MUL, VT, N0C, N1C);\n\n  if (N0C && !N1C)\n    return DAG.getNode(ISD::MUL, N->getDebugLoc(), VT, N1, N0);\n\n  if (N1C && N1C->isNullValue())\n    return N1;\n\n  if (N1C && N1C->isAllOnesValue())\n    return DAG.getNode(ISD::SUB, N->getDebugLoc(), VT, DAG.getConstant(0, VT), N0);\n  if (N1C && N1C->getAPIntValue().isPowerOf2())\n    return DAG.getNode(ISD::SHL, N->getDebugLoc(), VT, N0,\n           DAG.getConstant(N1C->getAPIntValue().logBase2(),\n               getShiftAmountTy(N0.getValueType())));\n\n  if (N1C && (-N1C->getAPIntValue()).isPowerOf2()) {\n    unsigned Log2Val = (-N1C->getAPIntValue()).logBase2();\n    return DAG.getNode(ISD::SUB, N->getDebugLoc(), VT, DAG.getConstant(0, VT),\n    DAG.getNode(ISD::SHL, N->getDebugLoc(), VT, N0,\n    DAG.getConstant(Log2Val, getShiftAmountTy(N0.getValueType()))));\n  }\n\n  if (N1C && N0.getOpcode() == ISD::SHL &&\n      isa<ConstantSDNode>(N0.getOperand(1))) {\n    SDValue C3 = DAG.getNode(ISD::SHL, N->getDebugLoc(), VT, N1, N0.getOperand(1));\n    AddToWorkList(C3.getNode());\n    return DAG.getNode(ISD::MUL, N->getDebugLoc(), VT,\n    N0.getOperand(0), C3);\n  }\n\n  if (N0.getOpcode() == ISD::SHL && isa<ConstantSDNode>(N0.getOperand(1)) &&\n      N0.getNode()->hasOneUse()) {\n    Sh = N0; Y = N1;\n  } else if (N1.getOpcode() == ISD::SHL && isa<ConstantSDNode>(N1.getOperand(1)) &&\n            N1.getNode()->hasOneUse()) {\n    Sh = N1; Y = N0;\n  }\n  if (Sh.getNode()) {\n  SDValue Mul = DAG.getNode(ISD::MUL, N->getDebugLoc(), VT, Sh.getOperand(0), Y);\n    return DAG.getNode(ISD::SHL, N->getDebugLoc(), VT,\n    Mul, Sh.getOperand(1));\n    }\n  }\n  if (N1C && N0.getOpcode() == ISD::ADD && N0.getNode()->hasOneUse() &&\n      isa<ConstantSDNode>(N0.getOperand(1)))\n    return DAG.getNode(ISD::ADD, N->getDebugLoc(), VT, DAG.getNode(ISD::MUL, N0.getDebugLoc(),\n    VT, N0.getOperand(0), N1), DAG.getNode(ISD::MUL, N1.getDebugLoc(), VT, N0.getOperand(1), N1));\n\n  SDValue RMUL = ReassociateOps(ISD::MUL, N->getDebugLoc(), N0, N1);\n\n  if (RMUL.getNode() != 0) return RMUL;\n  return SDValue();\n}\n```", "```cpp\nclass SelectionDAGISel : public MachineFunctionPass {\npublic:\nconst TargetMachine &TM;\nconst TargetLowering &TLI;\nconst TargetLibraryInfo *LibInfo;\nFunctionLoweringInfo *FuncInfo;\nMachineFunction *MF;\nMachineRegisterInfo *RegInfo;\nSelectionDAG *CurDAG;\nSelectionDAGBuilder *SDB;\nAliasAnalysis *AA;\nGCFunctionInfo *GFI;\nCodeGenOpt::Level OptLevel;\nstatic char ID;\n\nexplicit SelectionDAGISel(const TargetMachine &tm,\nCodeGenOpt::Level OL = CodeGenOpt::Default);\n\nvirtual ~SelectionDAGISel();\n\nconst TargetLowering &getTargetLowering() { return TLI; }\n\nvirtual void getAnalysisUsage(AnalysisUsage &AU) const;\n\nvirtual bool runOnMachineFunction(MachineFunction &MF);\n\nvirtual void EmitFunctionEntryCode() {}\n\nvirtual void PreprocessISelDAG() {}\n\nvirtual void PostprocessISelDAG() {}\n\nvirtual SDNode *Select(SDNode *N) = 0;\n\nvirtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,\nchar ConstraintCode,\nstd::vector<SDValue> &OutOps) {\n  return true;\n}\n\nvirtual bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const;\n\nstatic bool IsLegalToFold(SDValue N, SDNode *U, SDNode *Root,\nCodeGenOpt::Level OptLevel,\nbool IgnoreChains = false);\n\nenum BuiltinOpcodes {\nOPC_Scope,\nOPC_RecordNode,\nOPC_CheckOpcode,\nOPC_SwitchOpcode,\nOPC_CheckFoldableChainNode,\nOPC_EmitInteger,\nOPC_EmitRegister,\nOPC_EmitRegister2,\nOPC_EmitConvertToTarget,\nOPC_EmitMergeInputChains,\n};\n\nstatic inline int getNumFixedFromVariadicInfo(unsigned Flags) {\n  return ((Flags&OPFL_VariadicInfo) >> 4)-1;\n}\n\nprotected:\n// DAGSize - Size of DAG being instruction selected.\nunsigned DAGSize;\n\nvoid ReplaceUses(SDValue F, SDValue T) {\n  CurDAG->ReplaceAllUsesOfValueWith(F, T);\n}\n\nvoid ReplaceUses(const SDValue *F, const SDValue *T, unsigned Num) {\n  CurDAG->ReplaceAllUsesOfValuesWith(F, T, Num);\n}\n\nvoid ReplaceUses(SDNode *F, SDNode *T) {\n  CurDAG->ReplaceAllUsesWith(F, T);\n}\n\nvoid SelectInlineAsmMemoryOperands(std::vector<SDValue> &Ops);\n\npublic:\nbool CheckAndMask(SDValue LHS, ConstantSDNode *RHS,\nint64_t DesiredMaskS) const;\n\nbool CheckOrMask(SDValue LHS, ConstantSDNode *RHS,\nint64_t DesiredMaskS) const;\n\nvirtual bool CheckPatternPredicate(unsigned PredNo) const {\n  llvm_unreachable(\"Tblgen should generate the implementation of this!\");\n}\n\nvirtual bool CheckNodePredicate(SDNode *N, unsigned PredNo) const {\n  llvm_unreachable(\"Tblgen should generate the implementation of this!\");\n}\n\nprivate:\n\nSDNode *Select_INLINEASM(SDNode *N);\n\nSDNode *Select_UNDEF(SDNode *N);\n\nvoid CannotYetSelect(SDNode *N);\n\nvoid DoInstructionSelection();\n\nSDNode *MorphNode(SDNode *Node, unsigned TargetOpc, SDVTList VTs,\nconst SDValue *Ops, unsigned NumOps, unsigned EmitNodeInfo);\n\nvoid PrepareEHLandingPad();\n\nvoid SelectAllBasicBlocks(const Function &Fn);\n\nbool TryToFoldFastISelLoad(const LoadInst *LI, const Instruction *FoldInst, FastISel *FastIS);\n\nvoid FinishBasicBlock();\n\nvoid SelectBasicBlock(BasicBlock::const_iterator Begin,\nBasicBlock::const_iterator End,\nbool &HadTailCall);\n\nvoid CodeGenAndEmitDAG();\n\nvoid LowerArguments(const BasicBlock *BB);\n\nvoid ComputeLiveOutVRegInfo();\n  ScheduleDAGSDNodes *CreateScheduler();\n};\n```", "```cpp\nSDNode *ResNode = Select(Node);\n```", "```cpp\n$ cat test.ll\ndefine i32 @test(i32 %a, i32 %b, i32 %c) {\n  %add = add nsw i32 %a, %b\n  %div = sdiv i32 %add, %c\n  ret i32 %div\n}\n```", "```cpp\n$ llc –view-isel-dags test.ll\n\n```", "```cpp\n$ llc –view-sched-dags test.ll\n\n```", "```cpp\nclass ScheduleDAG {\npublic:\n  const TargetMachine &TM;              // Target processor\n  const TargetInstrInfo *TII;           // Target instruction\n  const TargetRegisterInfo *TRI;        // Target processor register info\n  MachineFunction &MF;                  // Machine function\n  MachineRegisterInfo &MRI;             // Virtual/real register map\n  std::vector<SUnit> SUnits;            // The scheduling units.\n  SUnit EntrySU;                        // Special node for the region entry.\n  SUnit ExitSU;                         // Special node for the region exit.\n\n  explicit ScheduleDAG(MachineFunction &mf);\n\n  virtual ~ScheduleDAG();\n\n  void clearDAG();\n\nconst MCInstrDesc *getInstrDesc(const SUnit *SU) const {\n  if (SU->isInstr()) return &SU->getInstr()->getDesc();\n    return getNodeDesc(SU->getNode());\n}\n\nvirtual void dumpNode(const SUnit *SU) const = 0;\n\nprivate:\n\nconst MCInstrDesc *getNodeDesc(const SDNode *Node) const;\n};\n\nclass SUnitIterator : public std::iterator<std::forward_iterator_tag,\nSUnit, ptrdiff_t> {\n};\n\ntemplate <> struct GraphTraits<SUnit*> {\n  typedef SUnit NodeType;\n  typedef SUnitIterator ChildIteratorType;\n  static inline NodeType *getEntryNode(SUnit *N) {\n    return N;\n  }\n  static inline ChildIteratorType child_begin(NodeType *N) {\n  return SUnitIterator::begin(N);\n  }\n\nstatic inline ChildIteratorType child_end(NodeType *N) {\n  return SUnitIterator::end(N);\n  }\n};\n\ntemplate <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {\n…};\n\n// Topological sorting of DAG to linear set of instructions\nclass ScheduleDAGTopologicalSort {\n  std::vector<SUnit> &SUnits;\n  SUnit *ExitSU;\n  std::vector<int> Index2Node;\n  std::vector<int> Node2Index;\n  BitVector Visited;\n// DFS to be run on DAG to sort topologically\n  void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);\n\n  void Shift(BitVector& Visited, int LowerBound, int UpperBound);\n\n  void Allocate(int n, int index);\n\npublic:\n\n  ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);\n\n  void InitDAGTopologicalSorting();\n\n  bool IsReachable(const SUnit *SU, const SUnit *TargetSU);\n\n  bool WillCreateCycle(SUnit *SU, SUnit *TargetSU);\n\n  void AddPred(SUnit *Y, SUnit *X);\n\n  void RemovePred(SUnit *M, SUnit *N);\n\n  typedef std::vector<int>::iterator iterator;\n\n  typedef std::vector<int>::const_iterator const_iterator;\n\n  iterator begin() { return Index2Node.begin(); }\n\n  const_iterator begin() const { return Index2Node.begin(); }\n\n  iterator end() { return Index2Node.end();}}\n```"]