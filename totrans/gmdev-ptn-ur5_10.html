<html><head></head><body>
<div id="_idContainer182">
<h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.2.1">Optimization through Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this last chapter, we are going to discuss the last thing we should think about before releasing our games: optimization. </span><span class="koboSpan" id="kobo.3.2">Optimization patterns are </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.4.1">designed to leave our code functioning as it was before but in a faster, more elegant way that impacts our hardware less. </span><span class="koboSpan" id="kobo.4.2">This chapter is quite wordy, but the underlying principles that guide these patterns require a certain understanding of how the hardware resources at our disposal work. </span><span class="koboSpan" id="kobo.4.3">By the end, we will have covered everything from how to help the CPU do its job better to making a system you can plug into any game to make it potentially faster </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The patterns making this possible are </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.8.1">Dirty Flag</span></strong><span class="koboSpan" id="kobo.9.1">, which focuses on reducing the number of times we need to update </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">calculated values.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.11.1">Data Locality</span></strong><span class="koboSpan" id="kobo.12.1">, which concerns optimizing the code layout to work with the way the CPU’s memory works. </span><span class="koboSpan" id="kobo.12.2">As a description, this sounds much more complicated than the reality of </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.14.1">Object Pooling</span></strong><span class="koboSpan" id="kobo.15.1">, where we offset as much of the heavy memory allocation processing to the start of the game, where it can be excused under a loading screen, so as not to impact </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">runtime efficiency.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">So, in this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Using dirty flags to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">unnecessary processing</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">How data locality affects </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">code efficiency</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Object pooling our resources to save </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">time later</span></span></li>
</ul>
<h1 id="_idParaDest-137"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The starting point for this chapter can really be from any project, but we have a branch of the GitHub repository that carries on from where </span><a href="B18297_09.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.28.1"> left off. </span><span class="koboSpan" id="kobo.28.2">This provides a set of systems we can integrate with the Object Pooler we will be building. </span><span class="koboSpan" id="kobo.28.3">You can find this starting point in the </span><a href="B18297_10.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 10</span></em></span></a> <span class="No-Break"><span class="koboSpan" id="kobo.30.1">branch here:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter10</span></span></a></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.32.1">Using dirty flags to reduce unnecessary processing</span></h1>
<p><span class="koboSpan" id="kobo.33.1">Dirty flag </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.34.1">involves updating values only when they are needed. </span><span class="koboSpan" id="kobo.34.2">The best explanation of how it works comes in the context of base-level engine development and the transform hierarchy. </span><span class="koboSpan" id="kobo.34.3">When you set a local location on a transform, you are indicating that you want to be </span><em class="italic"><span class="koboSpan" id="kobo.35.1">x</span></em><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">y</span></em><span class="koboSpan" id="kobo.38.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.39.1">z</span></em><span class="koboSpan" id="kobo.40.1"> units away from the parent’s location. </span><span class="koboSpan" id="kobo.40.2">This is easy enough to update, but in doing this, we are also changing the transform’s world space location. </span><span class="koboSpan" id="kobo.40.3">It is easy to calculate the matrix that will deal with this local-to-world space conversion, then multiply our vector by it; that process doesn’t even cost many resources. </span><span class="koboSpan" id="kobo.40.4">Then, we must remember that this is a hierarchy. </span><span class="koboSpan" id="kobo.40.5">What if we were moving the root of a tree that is hundreds of transforms deep? </span><span class="koboSpan" id="kobo.40.6">Not a great position to be in for multiple reasons, but if the parent of a transform moves, then the child moves with it, and so on, recursively. </span><span class="koboSpan" id="kobo.40.7">This presents a lot of world space value transforms that need to be updated every time any parent in the tree </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">is changed.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">To make the utility of dirty flag easier to quantify, we can consider a hypothetical situation where we have a hierarchy of transforms that is 100 parent-child connections deep. </span><span class="koboSpan" id="kobo.42.2">We want to move each of them like they are a chain with a torque ripple. </span><span class="koboSpan" id="kobo.42.3">Starting at the top of the hierarchy and moving down, at every step, we update the position of the transform at that level to a new local location defined by some periodic function. </span><span class="koboSpan" id="kobo.42.4">With each local update, we also update the local-to-world matrix for every transform lower in the hierarchy as they will have moved in world space, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.44.1">.1</span></em><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">This would require (101-n) matrix updates at each step, which means to move the entire hierarchy of 100 transforms, we will end up with the 100th triangular number, which is 5,050. </span><span class="koboSpan" id="kobo.45.3">I think we can safely say that’s ridiculous and there has to be a better way. </span><span class="koboSpan" id="kobo.45.4">Consider the utility of the work done. </span><span class="koboSpan" id="kobo.45.5">Why are we updating these transforms? </span><span class="koboSpan" id="kobo.45.6">So that something else can read its world space location and get an accurate, up-to-date value. </span><span class="koboSpan" id="kobo.45.7">Have we read the world space location at any point in this algorithm? </span><span class="koboSpan" id="kobo.45.8">No. </span><span class="koboSpan" id="kobo.45.9">The function for setting the local location doesn’t need the world space location. </span><span class="koboSpan" id="kobo.45.10">So, do we need to update the local to world matrices of these objects? </span><span class="koboSpan" id="kobo.45.11">Not until something else needs us to or the end of the frame is reached. </span><span class="koboSpan" id="kobo.45.12">For the best case, that means we could get away with only 100 matrix updates </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.46.1">at the very end. </span><span class="koboSpan" id="kobo.46.2">That is the purpose of the dirty </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">flag pattern.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<span class="koboSpan" id="kobo.48.1"><img alt="Figure 10.1 – Diagram showing a local location change affecting the world space location of its child" src="image/Figure_10.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.49.1">Figure 10.1 – Diagram showing a local location change affecting the world space location of its child</span></p>
<p><span class="koboSpan" id="kobo.50.1">Now, let’s look at the application of </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">dirty flags.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.52.1">Application of dirty flags</span></h2>
<p><span class="koboSpan" id="kobo.53.1">In practice, this whole pattern is </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.54.1">just a Boolean value; when the object is considered </span><em class="italic"><span class="koboSpan" id="kobo.55.1">dirty</span></em><span class="koboSpan" id="kobo.56.1">, the Boolean is one value, and when it is </span><em class="italic"><span class="koboSpan" id="kobo.57.1">clean</span></em><span class="koboSpan" id="kobo.58.1">, it is the other. </span><span class="koboSpan" id="kobo.58.2">Which way around that is doesn’t matter, as long as it’s consistent with the naming. </span><span class="koboSpan" id="kobo.58.3">An object is dirty if it has pending changes that still need to be made to the values it represents. </span><span class="koboSpan" id="kobo.58.4">In our example, we postpone the local-to-world matrix update until something requests the matrix or the end of the frame is reached. </span><span class="koboSpan" id="kobo.58.5">During the time between the change to the local location and the matrix update, the transform is </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">considered dirty.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The mechanics of how this is dealt with then extend beyond the Boolean value. </span><span class="koboSpan" id="kobo.60.2">On raising a dirty flag, that object is added to a relevant static dirty list of objects. </span><span class="koboSpan" id="kobo.60.3">For our transform, that means it, and all the transforms below it in the hierarchy, will be added recursively to a static list of other dirty transforms. </span><span class="koboSpan" id="kobo.60.4">We then have some cleaning function that describes how to go from a dirty state to a clean state. </span><span class="koboSpan" id="kobo.60.5">With the transform, that would be a function that calculates the updated </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">local-to-world matrix.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">That example is only something you’d have to be worried about if you were designing your own engine, but the dirty flag pattern can be applied to great effect anywhere you have a value that may be updated several times before it is needed. </span><span class="koboSpan" id="kobo.62.2">You can find this pattern</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.63.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">Unreal Motion Graphics</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">UMG</span></strong><span class="koboSpan" id="kobo.67.1">) layouts, which have a hierarchical positioning dependency just like transforms, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">destroy</span></strong><span class="koboSpan" id="kobo.69.1"> command, which marks actors for destruction at the end of the frame due to the trickle-down effects of removing them. </span><span class="koboSpan" id="kobo.69.2">There will be cases where you are storing data that needs to be displayed to the UI and the </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.70.1">dirty flag pattern can reduce the number of times you tell the UI to update per frame; it should only happen once at most </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">per frame.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Next, we’ll go deeper, from a one-variable pattern to a guiding principle of optimization that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">apply anywhere.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.74.1">How data locality affects code efficiency</span></h1>
<p><span class="koboSpan" id="kobo.75.1">This is a simple </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.76.1">concept that requires very little to implement. </span><span class="koboSpan" id="kobo.76.2">We all actively think about how variables take up memory. </span><span class="koboSpan" id="kobo.76.3">We tend to forget that instructions also take up memory. </span><span class="koboSpan" id="kobo.76.4">They must be loaded from storage into faster memory, then into the CPU to be executed. </span><span class="koboSpan" id="kobo.76.5">CPUs try to make things run quicker by leveraging the fact that they have very fast, very small storage within them called the cache. </span><span class="koboSpan" id="kobo.76.6">The cache allows the CPU to pre-load instructions ready for execution and store its state in case of temporary context switching. </span><span class="koboSpan" id="kobo.76.7">This pre-loading behavior is necessary for the CPU to run at its most efficient as while there has been a technology race in CPU speeds, that hasn’t been mirrored in the world of RAM. </span><span class="koboSpan" id="kobo.76.8">You might be able to store massive programs entirely in your RAM but the bus speed of the motherboard limits how many instructions can be sent to the CPU per second. </span><span class="koboSpan" id="kobo.76.9">When we reach the bottleneck, it doesn’t matter how fast the CPU cores are at calculating results, as they would spend most of their time idle, waiting for instruction. </span><span class="koboSpan" id="kobo.76.10">Pre-loading provides a mechanism that has the potential to fix this by sending large chunks of instructions to the CPU cache for processing. </span><span class="koboSpan" id="kobo.76.11">We say </span><em class="italic"><span class="koboSpan" id="kobo.77.1">potential to fix</span></em><span class="koboSpan" id="kobo.78.1"> as when pulling instructions from RAM, there is no way of knowing which instructions will be next. </span><span class="koboSpan" id="kobo.78.2">That information is in the instruction daisy chain and can only be accessed once the work is done. </span><span class="koboSpan" id="kobo.78.3">This means that the contents of the CPU cache are entirely dictated by the geography of our </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">system architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">That’s lots of technical terms, so let’s explain it with an analogy. </span><span class="koboSpan" id="kobo.80.2">Imagine working in a factory where your job is to build flatpack furniture. </span><span class="koboSpan" id="kobo.80.3">You’re really fast at your job when you have the materials and can put together each piece lighting fast. </span><span class="koboSpan" id="kobo.80.4">The catch is, you can only see one instruction at a time, and when you need pieces, you must request them from a porter. </span><span class="koboSpan" id="kobo.80.5">These resources, such as panels and screws, are stored in a warehouse miles away. </span><span class="koboSpan" id="kobo.80.6">When you request something, the porter spends a day traveling to and from the warehouse, which means you can only get one instruction completed per day regardless of how fast you work. </span><span class="koboSpan" id="kobo.80.7">Most of your time is spent staring at the wall. </span><span class="koboSpan" id="kobo.80.8">In this example, you are the CPU, executing instructions, and the porter is the data bus, ferrying instructions from RAM to </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">be executed.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">One day, a new manager is brought in who decides to revamp the process. </span><span class="koboSpan" id="kobo.82.2">They change the material request process so that now, when the porter gets the required item, they also get everything else within arm’s reach. </span><span class="koboSpan" id="kobo.82.3">This bundle of screws and panels is then dumped on the ground in your workstation. </span><span class="koboSpan" id="kobo.82.4">In real terms, we call this the CPU cache, a tiny amount of extremely fast memory within the CPU. </span><span class="koboSpan" id="kobo.82.5">The benefit of this is that when you get your next instruction, there is a chance you already have the required materials next to you. </span><span class="koboSpan" id="kobo.82.6">If not, then all the materials need to be taken back and a new bunch collected. </span><span class="koboSpan" id="kobo.82.7">It then stands to reason that if the warehouse is organized so that materials that are often requested together are placed near each other, the porter is more likely to take the correct materials for the next instruction as well. </span><span class="koboSpan" id="kobo.82.8">Nothing needs to change about the porter’s knowledge of the situation or skills, simply proper planning at the start to achieve an </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">efficient outcome.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">As programmers, we</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.85.1"> can be the warehouse manager in that example, making sure that the data a function requires is physically close to that function so that when the CPU request for resources comes in, the cache is more likely to fill with useful data. </span><span class="koboSpan" id="kobo.85.2">When the CPU can execute from the cache, that is called a cache hit. </span><span class="koboSpan" id="kobo.85.3">Likewise, when the data needs to be requested, that is a cache miss. </span><span class="koboSpan" id="kobo.85.4">We want to achieve as many cache hits as possible to reduce the number of times the cache needs to be refilled. </span><span class="koboSpan" id="kobo.85.5">The gains from achieving high levels of cache hits are surprising; sometimes, they can be up to 50 times faster due to organizing </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">data effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">We’re going to have a look at two methods for implementing data locality as a principle but there are doubtless others that, now that you understand the problem, will make more sense as implementations. </span><span class="koboSpan" id="kobo.87.2">Let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">two methods.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.89.1">Hot/cold splitting</span></h2>
<p><span class="koboSpan" id="kobo.90.1">The first technique is </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.91.1">very similar to how the type object pattern from </span><a href="B18297_09.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.93.1"> needed to consider implicit and explicit data, but instead of thinking about what the values are defining, we look at how frequently they are accessed. </span><span class="koboSpan" id="kobo.93.2">The go-to example of this would be an NPC in a game with loot drops. </span><span class="koboSpan" id="kobo.93.3">The NPC’s health is accessed regularly as they heal and take damage over their life cycle, whereas the loot table, which describes what items they drop on, is accessed once at the end of the object’s life. </span><span class="koboSpan" id="kobo.93.4">We can classify the frequently accessed data as hot; this can stay in the object as member variables. </span><span class="koboSpan" id="kobo.93.5">The more single-use data, such as loot tables, is then marked as cold and separated off into a struct, held inside the object as </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">a pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Why do all this? </span><span class="koboSpan" id="kobo.95.2">It has to do with the size of the object when being pulled into the cache. </span><span class="koboSpan" id="kobo.95.3">When the object is pulled in, all data it directly contains makes up the amount of space it takes up in the cache. </span><span class="koboSpan" id="kobo.95.4">That means that all pointers effectively only take up the space of </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">uint64_t</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">The data they point to is not necessarily loaded until it is directly accessed, as it is declared physically elsewhere, hence the pointer. </span><span class="koboSpan" id="kobo.97.3">Without separating our hot and cold data, as we described previously, our class takes up more cache memory than is necessary with data that is unlikely to be needed, increasing the chance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">cache miss.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.99.1">Contiguous arrays</span></h2>
<p><span class="koboSpan" id="kobo.100.1">The second technique is using contiguous arrays</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.101.1"> of data. </span><span class="koboSpan" id="kobo.101.2">We know that there are two types of memory: stack and heap. </span><span class="koboSpan" id="kobo.101.3">Data locality is the main reason why stack memory is considered faster. </span><span class="koboSpan" id="kobo.101.4">Everything in the stack has been defined before the program runs and so it is neatly organized. </span><span class="koboSpan" id="kobo.101.5">Arrays of data are held in the stack and are defined together in one continuous line. </span><span class="koboSpan" id="kobo.101.6">This makes the CPU cache more efficient when looping over these elements as they have been stored physically closer to one another. </span><span class="koboSpan" id="kobo.101.7">This is part of the reason why data-oriented ECS is faster, as discussed back in </span><a href="B18297_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.102.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">However, dynamic collections and pointers are declared in heap memory at runtime. </span><span class="koboSpan" id="kobo.103.3">We sacrifice that benefit of efficiency for the flexibility of defining data at a later point. </span><span class="koboSpan" id="kobo.103.4">Data on the heap uses whatever free space is available and because of this may end up defining multiple objects large distances from each other. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.104.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.105.1">.2</span></em><span class="koboSpan" id="kobo.106.1"> shows visually how storing an array of values instead of an array of pointers can make a difference to what is loaded into the cache. </span><span class="koboSpan" id="kobo.106.2">This is a concept to keep in mind when we implement an object pool later in this chapter. </span><span class="koboSpan" id="kobo.106.3">When we spawn objects, they are held as </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">TObjectPtrs</span></strong><span class="koboSpan" id="kobo.108.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">TArray</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Could this array be made into a standard C++ array? </span><span class="koboSpan" id="kobo.110.3">What dynamic property would we have to sacrifice to do this? </span><span class="koboSpan" id="kobo.110.4">It would likely be dynamic sizing, but do you need that in </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">your context?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 10.2 – Possible layout of an array of pointers versus an array of values in memory" src="image/Figure_10.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 10.2 – Possible layout of an array of pointers versus an array of values in memory</span></p>
<p><span class="koboSpan" id="kobo.114.1">So, is the solution to just use </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.115.1">arrays of data all the time? </span><span class="koboSpan" id="kobo.115.2">Well, no. </span><span class="koboSpan" id="kobo.115.3">There are many situations where pointers and dynamic collections are still necessary within object-oriented programming. </span><span class="koboSpan" id="kobo.115.4">This is more a point to consider their usage, and if you can replace a dynamic collection with a static array, then do so. </span><span class="koboSpan" id="kobo.115.5">This point is especially important to remember in our last pattern of the book coming up next: </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Object Pooling.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.117.1">Object pooling our resources to save time later</span></h1>
<p><span class="koboSpan" id="kobo.118.1">The last pattern we </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.119.1">are discussing in this book is object pooling. </span><span class="koboSpan" id="kobo.119.2">This pattern </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.120.1">aims to tackle one of the core problems with the CPU: allocating and deallocating memory is a slow process. </span><span class="koboSpan" id="kobo.120.2">Every time you spawn a new actor, the space it needs in memory must be reserved in the right subdivisions for each variable and handed back to the game process ready to receive data. </span><span class="koboSpan" id="kobo.120.3">Every time you delete an actor, that memory must be freed from all references and returned to the heap. </span><span class="koboSpan" id="kobo.120.4">For something such as a minigun spawning 3,000 projectiles per minute, that means a lot of allocation of the chunks for memory, which are all the same size. </span><span class="koboSpan" id="kobo.120.5">Object pooling is the practice of predicting this massive cost and offsetting it to a place where the lag it causes is not so noticeable. </span><span class="koboSpan" id="kobo.120.6">This for us means spawning all the projectiles we could possibly need at the start of the game and hiding them. </span><span class="koboSpan" id="kobo.120.7">When one is required, it is taken from the shelf of deactivated projectiles, teleported to the right position, and activated. </span><span class="koboSpan" id="kobo.120.8">Then, to preserve the pool’s integrity, when it would have been destroyed, it is simply deactivated and returned to the shelf with the other pooled items. </span><span class="koboSpan" id="kobo.120.9">Although this pattern does make the one frame when the level has just loaded much worse, as we are spawning all the projectiles at once, we can disguise this under a loading screen. </span><span class="koboSpan" id="kobo.120.10">This offset can dramatically increase the processing speed during hectic gameplay sequences</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.121.1"> when there would have been a lot of spawning and destroying </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.122.1">occurring. </span><span class="koboSpan" id="kobo.122.2">Our pool then stays active until the end of the level when all objects are destroyed together, again under a </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">loading screen.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">With the theory covered, let’s make some </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">object pools.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.126.1">Implementing object pooling</span></h2>
<p><span class="koboSpan" id="kobo.127.1">There are a few ways we could look</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.128.1"> at implementing this and, realistically, if it works to spawn the objects you need in a place where you can access them, then it is the best method for you. </span><span class="koboSpan" id="kobo.128.2">The implementation options are as a world subsystem, level actor component, game mode component, or floating actor in </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the level.</span></span></p>
<h3><span class="koboSpan" id="kobo.130.1">World subsystem</span></h3>
<p><span class="koboSpan" id="kobo.131.1">Subsystems </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.132.1">are Unreal’s effort at </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.133.1">implementing a standardized form of the singleton pattern we covered in </span><a href="B18297_08.xhtml#_idTextAnchor113"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.134.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.135.1"> with limited scope. </span><span class="koboSpan" id="kobo.135.2">This form it takes means that we can make an almost static class that we know will exist for the lifetime of whatever it is attached to. </span><span class="koboSpan" id="kobo.135.3">Subsystems are, however, not well protected with regard to access as anything with reference to their attached object can call functions on them. </span><span class="koboSpan" id="kobo.135.4">This is why they tend to be used for hidden logic behavior systems that run regardless of interaction. </span><span class="koboSpan" id="kobo.135.5">This results in most of the public functions on them being getters to get the state of something they are processing. </span><span class="koboSpan" id="kobo.135.6">There are five levels of subsystem that exist. </span><span class="koboSpan" id="kobo.135.7">Let’s describe them in order of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">decreasing lifetime:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Engine</span></strong><span class="koboSpan" id="kobo.138.1">: Exists </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.139.1">in both the editor and the game for the length of the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">executable running.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Editor</span></strong><span class="koboSpan" id="kobo.142.1">: Runs as an </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.143.1">editor tool and will not build with </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the game.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.145.1">Game instance</span></strong><span class="koboSpan" id="kobo.146.1">: Attached</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.147.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">UGameInstance</span></strong><span class="koboSpan" id="kobo.149.1"> and so exists for the play session while the executable is running. </span><span class="koboSpan" id="kobo.149.2">Only one instance can exist at </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">a time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Local player</span></strong><span class="koboSpan" id="kobo.152.1">: Matches</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.153.1"> the lifetime of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">ULocalPlayer</span></strong><span class="koboSpan" id="kobo.155.1"> it is attached to and moves between levels in the same way. </span><span class="koboSpan" id="kobo.155.2">There is one instance per </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">local player.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">World</span></strong><span class="koboSpan" id="kobo.158.1">: Matches </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.159.1">the lifetime of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">UWorld</span></strong><span class="koboSpan" id="kobo.161.1"> it is attached to. </span><span class="koboSpan" id="kobo.161.2">There is one instance per </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">UWorld</span></strong><span class="koboSpan" id="kobo.163.1"> that is </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">currently loaded.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.165.1">It is important to consider the scope of the system being created and match it to the parent that best describes its lifetime. </span><span class="koboSpan" id="kobo.165.2">For an object pooler, this would be a world subsystem as any objects spawned in a pool will exist within a world so when that world is unloaded, they will be too. </span><span class="koboSpan" id="kobo.165.3">If the system was made as a local player subsystem, this would break references when changing maps and possibly spawn items in menu worlds where they </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">are unnecessary.</span></span></p>
<h3><span class="koboSpan" id="kobo.167.1">LevelScriptActor child</span></h3>
<p><span class="koboSpan" id="kobo.168.1">The</span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1"> ALevelScriptActor</span></strong><span class="koboSpan" id="kobo.170.1"> is what</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.171.1"> people know on the blueprint side as the level blueprint. </span><span class="koboSpan" id="kobo.171.2">It provides a place for level-specific code to execute. </span><span class="koboSpan" id="kobo.171.3">This can be useful for tutorials where the mechanics are built badly in order to introduce them slowly, or for map-based mechanics, such as the “Levolutions” in Battlefield 4, where each map has the ability to completely change if different conditions are met. </span><span class="koboSpan" id="kobo.171.4">What isn’t advertised very well in the Unreal documentation is that we can change the level blueprint in the C++ layer. </span><span class="koboSpan" id="kobo.171.5">Simply create a new C++ child of </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">ALevelScriptActor</span></strong><span class="koboSpan" id="kobo.173.1"> and add your code here. </span><span class="koboSpan" id="kobo.173.2">This new child can be where we set up systems for object pooling as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">ALevelScriptActor</span></strong><span class="koboSpan" id="kobo.175.1"> exists in a hidden state for as long as our world exists and has easy access to anything else within the world outliner for that particular map. </span><span class="koboSpan" id="kobo.175.2">The downside of this is that every new map created in the editor comes with a level blueprint that already inherits from the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">ALevelScriptActor</span></strong><span class="koboSpan" id="kobo.177.1"> class. </span><span class="koboSpan" id="kobo.177.2">This means every new map would have to have its level blueprint manually reparented to your custom C++ type, which could lead to a lot of admin with easily </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">missable steps.</span></span></p>
<h3><span class="koboSpan" id="kobo.179.1">Game mode component</span></h3>
<p><span class="koboSpan" id="kobo.180.1">The game mode</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.181.1"> is a class that is guaranteed to be in every level, so there is the option to make the object pooler an actor component that is attached to it, or consolidate the behavior into the game mode inheritance hierarchy with a custom pooling game mode, which innately has the logic for running an object pool built in. </span><span class="koboSpan" id="kobo.181.2">This approach would require some diligence on the part of the designers as making a new level or prototyping a new game mode would require the component to be added or the correct parent to be selected; but it would make the implementation easy seeing as it is collected in one place and self-contained within an easily </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">accessible system.</span></span></p>
<h3><span class="koboSpan" id="kobo.183.1">Floating actor</span></h3>
<p><span class="koboSpan" id="kobo.184.1">The last method of getting an object </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.185.1">pooler to work is the simplest but least elegant solution: making it into an actor that you spawn into the level. </span><span class="koboSpan" id="kobo.185.2">The benefit of this is you can easily have multiple object pools for different things or segregate your object pools by area if you are dealing using world partition, the system we discussed back in </span><a href="B18297_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">The setup is also simple as all the GUI for setting it up is collected into the details panel for that object pool. </span><span class="koboSpan" id="kobo.187.3">The reason we call this method inelegant is down to how it must be managed. </span><span class="koboSpan" id="kobo.187.4">With there being no central method for referencing it or making sure the required functions have been called, it leaves a lot up to the end user and therefore is </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">error prone.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.189.1">Making an object pool</span></h2>
<p><span class="koboSpan" id="kobo.190.1">Before we start, the object</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.191.1"> pooling pattern is probably the most useful pattern to have in a plugin that we can take between projects. </span><span class="koboSpan" id="kobo.191.2">So, anything we make here should probably be done as part of a new plugin, which we can make within rider using the right-click menu on the game project. </span><span class="koboSpan" id="kobo.191.3">Simply select </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">New Unreal Plugin…</span></strong><span class="koboSpan" id="kobo.193.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Add</span></strong><span class="koboSpan" id="kobo.195.1"> menu, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.196.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.197.1">.3</span></em><span class="koboSpan" id="kobo.198.1">, and call the plugin something sensible, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">ObjectPooler</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">Then, just be sure to add new classes for the object pooler under the new folder this creates in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.201.1">Source</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1"> directory.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<span class="koboSpan" id="kobo.203.1"><img alt="Figure 10.3 – Screenshot of the plugin creation process within Rider" src="image/Figure_10.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.204.1">Figure 10.3 – Screenshot of the plugin creation process within Rider</span></p>
<p><span class="koboSpan" id="kobo.205.1">Our first step is to make</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.206.1"> the struct that will define the attributes of a single type of pool. </span><span class="koboSpan" id="kobo.206.2">The code for this is presented next, but let’s explain some of the key points. </span><span class="koboSpan" id="kobo.206.3">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">BlueprintType</span></strong><span class="koboSpan" id="kobo.208.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">USTRUCT</span></strong><span class="koboSpan" id="kobo.210.1"> block, in combination with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.212.1"> property specifiers, will allow the end user to change the pool behavior in the editor. </span><span class="koboSpan" id="kobo.212.2">There is also the constructor, which must give every property a value as a struct cannot be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">nullptr</span></strong><span class="koboSpan" id="kobo.214.1"> in memory. </span><span class="koboSpan" id="kobo.214.2">Saving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">_ActorName</span></strong><span class="koboSpan" id="kobo.216.1"> variable as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">FString</span></strong><span class="koboSpan" id="kobo.218.1"> is done to make debugging easier, but if you prefer to save it as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">FName</span></strong><span class="koboSpan" id="kobo.220.1">, that works and will save some processing when the pool is </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">warming up:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">PooledObjectData.h struct</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
USTRUCT(BlueprintType)
struct FPooledObjectData
{
    GENERATED_BODY()
    UPROPERTY(EditAnywhere)
    TSubclassOf&lt;AActor&gt; _ActorTemplate;
    UPROPERTY(EditAnywhere)
    int _PoolSize;
    UPROPERTY(EditAnywhere)
    bool _CanGrow;
    UPROPERTY(EditAnywhere)
    FString _ActorName;
    FPooledObjectData()
    {
        _ActorTemplate = nullptr;
        _PoolSize = 1;
        _CanGrow = false;
        _ActorName = "default";
    }
};</span></pre> <p><span class="koboSpan" id="kobo.224.1">Next, we’ll turn our attention</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.225.1"> to the component that will be on every object that came from the pool. </span><span class="koboSpan" id="kobo.225.2">We use an actor component instead of making a new child of </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">AActor</span></strong><span class="koboSpan" id="kobo.227.1"> that must then be inherited from as it provides a clean separation between the object existing and doing what it needs to and the hook that attaches it back to the pool it came from. </span><span class="koboSpan" id="kobo.227.2">With this setup, we can dynamically spawn the component at runtime and attach it to the object when it joins the pool, keeping reference only to the component. </span><span class="koboSpan" id="kobo.227.3">This should make the pool totally class agnostic, improving </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">its versatility.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Elements to note in the following class definition would be the custom initializer function allowing us to set the component up properly (more on that when we get to the object pool side) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">BlueprintCallable</span></strong><span class="koboSpan" id="kobo.231.1"> function used to recycle the actor. </span><span class="koboSpan" id="kobo.231.2">The recycle function is to be used instead of the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Destroy</span></strong><span class="koboSpan" id="kobo.233.1"> on the actor as it will return its owning actor to the pool it came from. </span><span class="koboSpan" id="kobo.233.2">A useful extension you might want to add here would be to save the index of the pool it is supposed to return to. </span><span class="koboSpan" id="kobo.233.3">This will save some string </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">comparisons later:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.235.1">PooledObject.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
class AObjectPool;
UCLASS(ClassGroup=(Utility), meta=(BlueprintSpawnableComponent))
class RTS_AI_API UPooledObject : public UActorComponent
{
    GENERATED_BODY()
public:
    UPROPERTY(VisibleInstanceOnly, BlueprintReadOnly)
    bool _IsActive;
    void Init(AObjectPool* owner);
    UFUNCTION(BlueprintCallable)
    void RecycleSelf();
private:
    TObjectPtr&lt;AObjectPool&gt; _ObjectPool;
    virtual void OnComponentDestroyed(bool bDestroyingHierarchy)
    override;
};</span></pre> <p><span class="koboSpan" id="kobo.237.1">The implementation of these</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.238.1"> functions is then very simple as most of the logic will be run in the pool itself. </span><span class="koboSpan" id="kobo.238.2">The only interesting point of note here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">OnComponentDestroyed</span></strong><span class="koboSpan" id="kobo.240.1"> override. </span><span class="koboSpan" id="kobo.240.2">This function removes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">RecycleSelf</span></strong><span class="koboSpan" id="kobo.242.1"> function as a listener to a delegate on the pooler as a safety in case the pooler functionality is ignored, and the object is deleted </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">in error:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.244.1">PooledObject.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
void UPooledObject::Init(AObjectPool* owner)
{
    _IsActive = false;
    _ObjectPool = owner;
}
void UPooledObject::RecycleSelf()
{
    _ObjectPool-&gt;RecyclePooledObject(this);
}
void UPooledObject::OnComponentDestroyed(
    bool bDestroyingHierarchy)
{
    _ObjectPool-&gt;OnPoolerCleanup.RemoveDynamic(this,
        &amp;UPooledObject::RecycleSelf);
    Super::OnComponentDestroyed(bDestroyingHierarchy);
}</span></pre> <p><span class="koboSpan" id="kobo.246.1">Now for the main event, the </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.247.1">object pool itself. </span><span class="koboSpan" id="kobo.247.2">Breaking down the definition, we start with a new delegate type with no arguments. </span><span class="koboSpan" id="kobo.247.3">This exists as a tether for each of the objects taken from the pool. </span><span class="koboSpan" id="kobo.247.4">If we need to recall them due to a level change, we can broadcast this delegate to recycle all active objects. </span><span class="koboSpan" id="kobo.247.5">We then have the definition of a new struct type. </span><span class="koboSpan" id="kobo.247.6">This only exists as a workaround for the fact that the template collections inside Unreal do not cater to multi-dimensional arrays. </span><span class="koboSpan" id="kobo.247.7">We would like to store an array of pools that in themselves are arrays. </span><span class="koboSpan" id="kobo.247.8">So, to get around this limitation, we define a new struct type that will hold all the objects we consider to be a part of </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">one pool:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">ObjectPool.h excerpt part 1</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FPoolerCleanupSignature);
class UPooledObject;
USTRUCT(BlueprintType)
struct FSingleObjectPool
{
    GENERATED_BODY()
    UPROPERTY(VisibleInstanceOnly, BlueprintReadOnly)
    TArray&lt;TObjectPtr&lt;UPooledObject&gt;&gt; _PooledObjects;
};</span></pre> <p><span class="koboSpan" id="kobo.251.1">Next is the object </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.252.1">pooler class. </span><span class="koboSpan" id="kobo.252.2">An exception to the rule, we don’t mark this as abstract. </span><span class="koboSpan" id="kobo.252.3">The reason for this is this actor just needs to exist. </span><span class="koboSpan" id="kobo.252.4">There is no need for any visual elements and so it can exist entirely on the C++ side, calling back to our separation rules for establishing the fuzzy layer in </span><a href="B18297_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.253.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">The API includes functions for broadcasting the cleanup delegate, getting an object from the pool, and two methods for returning an object to the pool with either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">UPooledObject</span></strong><span class="koboSpan" id="kobo.256.1"> component reference or a straight </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">AActor</span></strong><span class="koboSpan" id="kobo.258.1"> reference. </span><span class="koboSpan" id="kobo.258.2">We’ll go over why there are two later in the definitions. </span><span class="koboSpan" id="kobo.258.3">In the protected section, we need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.260.1"> override, an array of the data about the pools marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.262.1"> for designers to use the tool, and an array of the struct we made earlier to store a reference to every object this pool spawns. </span><span class="koboSpan" id="kobo.262.2">You could make this simpler by having a different object pool per object type, but that creates more actors than is necessary in the scene. </span><span class="koboSpan" id="kobo.262.3">Lastly, there is a private function for regenerating objects that have</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.263.1"> been deleted, leaving holes in </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">the pool:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">ObjectPool.h excerpt part 2</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
UCLASS()
class RTS_AI_API AObjectPool : public AActor
{
    GENERATED_BODY()
public:
    UPROPERTY()
    FPoolerCleanupSignature OnPoolerCleanup;
    UFUNCTION(BlueprintCallable)
    void Broadcast_PoolerCleanup();
    UFUNCTION(BlueprintCallable)
    AActor* GetPooledActor(FString name);
    UFUNCTION(BlueprintCallable)
    void RecyclePooledObject(UPooledObject* poolCompRef);
    UFUNCTION(BlueprintCallable)
    void RecycleActor(AActor* pooledActor);
protected:
    virtual void BeginPlay() override;
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TArray&lt;FPooledObjectData&gt; _PooledObjectData;
    UPROPERTY(VisibleInstanceOnly, BlueprintReadWrite)
    TArray&lt;FSingleObjectPool&gt; _Pools;
private:
    void RegenItem(int poolIndex, int positionIndex);
};</span></pre> <p><span class="koboSpan" id="kobo.267.1">With everything declared, we</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.268.1"> can move on to the definitions of our functions. </span><span class="koboSpan" id="kobo.268.2">To start, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">broadcast</span></strong><span class="koboSpan" id="kobo.270.1"> function, which works as its name suggests, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.272.1"> override for </span><em class="italic"><span class="koboSpan" id="kobo.273.1">warming up</span></em><span class="koboSpan" id="kobo.274.1"> the pool by spawning all the requested objects. </span><span class="koboSpan" id="kobo.274.2">Each pool iterates over the predefined number of times spawning new actors in the world. </span><span class="koboSpan" id="kobo.274.3">The code here names them and crucially adds an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">UPooledObject</span></strong><span class="koboSpan" id="kobo.276.1"> component to them. </span><span class="koboSpan" id="kobo.276.2">Having the pooler add this component dynamically means that the person who developed the actor being pooled didn’t need to know this was going to be added as a pooled class. </span><span class="koboSpan" id="kobo.276.3">This implementation uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">NewObject&lt;&gt;</span></strong><span class="koboSpan" id="kobo.278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">RegisterComponent</span></strong><span class="koboSpan" id="kobo.280.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">AddInstanceComponent</span></strong><span class="koboSpan" id="kobo.282.1"> to create and add the component to the new actor as we are in runtime, and we would like to see the component in the actor details panel for debugging purposes. </span><span class="koboSpan" id="kobo.282.2">The new component needs its initialization function running before we hide it from view, disable its collisio</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.283.1">n, and stop it </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">from executing:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.285.1">ObjectPool.cpp excerpt part 1</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
void AObjectPool::Broadcast_PoolerCleanup() {
    OnPoolerCleanup.Broadcast();
}
void AObjectPool::BeginPlay() {
    Super::BeginPlay();
    FActorSpawnParameters spawnParams;
    for(int poolIndex = 0; poolIndex &lt;
        _PooledObjectData.Num(); poolIndex++)
    {
        FSingleObjectPool currentPool;
        spawnParams.Name =
            FName(_PooledObjectData[poolIndex]._ActorName);
        spawnParams.NameMode =
            FActorSpawnParameters::ESpawnActorNameMode:: Requested;
        spawnParams.SpawnCollisionHandlingOverride =
           ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
        for(int objectIndex = 0; objectIndex &lt;
            _PooledObjectData[poolIndex]._PoolSize;
                objectIndex++)
        {
            AActor* spawnedActor = GetWorld()-&gt;
                SpawnActor(_PooledObjectData[poolIndex].
</span><span class="koboSpan" id="kobo.286.2">                    _ActorTemplate, &amp;FVector::ZeroVector,
                        &amp;FRotator::ZeroRotator,
                            spawnParams);
            UPooledObject* poolComp =
                NewObject&lt;UPooledObject&gt;(spawnedActor);
            poolComp-&gt;RegisterComponent();
            spawnedActor-&gt;AddInstanceComponent(poolComp);
            poolComp-&gt;Init(this);
            currentPool._PooledObjects.Add(poolComp);
            spawnedActor-&gt;SetActorHiddenInGame(true);
            spawnedActor-&gt;SetActorEnableCollision(false);
            spawnedActor-&gt;SetActorTickEnabled(false);
            spawnedActor-&gt;AttachToActor(this,
                FAttachmentTransformRules::
                    SnapToTargetNotIncludingScale);
        }
        _Pools.Add(currentPool);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.287.1">The method for getting an object from the pool has been made with an FString argument to make it as foolproof as possible, but it is advised that you establish an enum type that can be used </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.288.1">to reference the pools as indexes. </span><span class="koboSpan" id="kobo.288.2">In its current form, it goes through a </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">few steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.290.1">Finds the index of the pool that matches the input string, returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">out</span></strong><span class="koboSpan" id="kobo.292.1"> if one </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">isn’t found.</span></span></li>
<li><span class="koboSpan" id="kobo.294.1">Loops through the objects in the found pool to find the next object, which is marked </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">as inactive:</span></span><ol><li class="upper-roman"><span class="koboSpan" id="kobo.296.1">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">nullptr</span></strong><span class="koboSpan" id="kobo.298.1"> is found, then regenerate an object at that position and return it as it will </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">be available.</span></span></li><li class="upper-roman"><span class="koboSpan" id="kobo.300.1">If the end of the list is reached, then check whether the pool is allowed to grow. </span><span class="koboSpan" id="kobo.300.2">If it can, then make and return the new item; otherwise, it would be sensible to output a warning so that the designers know the pool probably </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">needs expanding.</span></span></li></ol></li>
</ol>
<p><span class="koboSpan" id="kobo.302.1">In the following code, the</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.303.1"> section for returning the object, if it is new or existing, is repeated due to the slightly different situations where a new object must have the component added and initialized but then does not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">be deactivated:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.305.1">ObjectPool.cpp excerpt part 2</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
AActor* AObjectPool::GetPooledActor(FString name)
{
    int poolCount = _Pools.Num();
    int currentPool = -1;
    for(int i = 0; i &lt; poolCount; i++)
    {
        if(_PooledObjectData[i]._ActorName == name)
        {
            currentPool = i;
            break;
        }
    }
    if(currentPool == -1) { return nullptr; }
    int pooledObjectCount =
        _Pools[currentPool]._PooledObjects.Num();
    int firstAvailable = -1;
    for(int i = 0; i &lt; pooledObjectCount; i++)
    {
        if(_Pools[currentPool]._PooledObjects[i] !=
            nullptr)
        {
            if(!_Pools[currentPool]._PooledObjects[i]-&gt;
                _IsActive)
            {
                firstAvailable = i;
                break;
            }
        }
        else
        {
            RegenItem(currentPool, i);
            firstAvailable = i;
            break;
        }
    }
    if(firstAvailable &gt;= 0)
    {
        UPooledObject* toReturn =
            _Pools[currentPool]._PooledObjects[firstAvailable];
        toReturn-&gt;_IsActive = true;
        OnPoolerCleanup.AddUniqueDynamic(toReturn,
            &amp;UPooledObject::RecycleSelf);
        AActor* toReturnActor = toReturn-&gt;GetOwner();
        toReturnActor-&gt;SetActorHiddenInGame(false);
        toReturnActor-&gt;SetActorEnableCollision(true);
        toReturnActor-&gt;SetActorTickEnabled(true);
        toReturnActor-&gt;AttachToActor(nullptr,
            FAttachmentTransformRules::
                SnapToTargetNotIncludingScale);
        return toReturnActor;
    }
    if(!_PooledObjectData[currentPool]._CanGrow) { return
        nullptr; }
    FActorSpawnParameters spawnParams;
    spawnParams.Name =
        FName(_PooledObjectData[currentPool]._ActorName);
    spawnParams.NameMode =
        FActorSpawnParameters::ESpawnActorNameMode::
            Requested;
    spawnParams.SpawnCollisionHandlingOverride =
        ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
    AActor* spawnedActor = GetWorld()-&gt;
        SpawnActor(_PooledObjectData[currentPool].
</span><span class="koboSpan" id="kobo.306.2">            _ActorTemplate, &amp;FVector::ZeroVector,
                &amp;FRotator::ZeroRotator, spawnParams);
    UPooledObject* poolComp =
        NewObject&lt;UPooledObject&gt;(spawnedActor);
    poolComp-&gt;RegisterComponent();
    spawnedActor-&gt;AddInstanceComponent(poolComp);
    poolComp-&gt;Init(this);
    _Pools[currentPool]._PooledObjects.Add(poolComp);
    poolComp-&gt;_IsActive = true;
    OnPoolerCleanup.AddUniqueDynamic(poolComp,
        &amp;UPooledObject::RecycleSelf);
    return spawnedActor;
}</span></pre> <p><span class="koboSpan" id="kobo.307.1">The two recycling functions act as a way to do overloading with </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">UFUNCTION</span></strong><span class="koboSpan" id="kobo.309.1">s. </span><span class="koboSpan" id="kobo.309.2">Unreal does not support this standard C++ practice out of the box, and so we must define new functions for each as a workaround. </span><span class="koboSpan" id="kobo.309.3">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">RecycleActor</span></strong><span class="koboSpan" id="kobo.311.1"> function tries to get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">UPooledObject</span></strong><span class="koboSpan" id="kobo.313.1"> component reference from the input actor. </span><span class="koboSpan" id="kobo.313.2">It may be worth adding a summary comment above this function, with triple forward slashes, letting the user know that it may fail and a better method would be to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">UPooledObject</span></strong><span class="koboSpan" id="kobo.315.1"> version. </span><span class="koboSpan" id="kobo.315.2">If it succeeds, it then</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.316.1"> calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">RecyclePooledObject</span></strong><span class="koboSpan" id="kobo.318.1"> function with this new information. </span><span class="koboSpan" id="kobo.318.2">Otherwise, it currently does nothing, but this may be a good place to log out the situation as a warning and maybe have the function return a Boolean value on successful recycling as feedback on the action. </span><span class="koboSpan" id="kobo.318.3">The main recycling function simply returns the object to its initial disabled and hidden state in the pool, resetting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">_IsActive</span></strong><span class="koboSpan" id="kobo.320.1"> flag in the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">pooled component:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.322.1">ObjectPool.cpp excerpt part 3</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
void AObjectPool::RecyclePooledObject(UPooledObject* poolCompRef)
{
    OnPoolerCleanup.RemoveDynamic(poolCompRef,
        &amp;UPooledObject::RecycleSelf);
    poolCompRef-&gt;_IsActive = false;
    AActor* returningActor = poolCompRef-&gt;GetOwner();
    returningActor-&gt;SetActorHiddenInGame(true);
    returningActor-&gt;SetActorEnableCollision(false);
    returningActor-&gt;SetActorTickEnabled(false);
    returningActor-&gt;AttachToActor(this,
        FAttachmentTransformRules::SnapToTargetNotIncludingScale);
}
void AObjectPool::RecycleActor(AActor* pooledActor)
{
    if(UPooledObject* poolCompRef =
        Cast&lt;UPooledObject&gt;(pooledActor-&gt;
            GetComponentByClass(UPooledObject::StaticClass())))
    {
        RecyclePooledObject(poolCompRef);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.324.1">The last function rounding out our object pooler is a function for regenerating items. </span><span class="koboSpan" id="kobo.324.2">This could maybe be separated better to make it more useful, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">GetPooledActor</span></strong><span class="koboSpan" id="kobo.326.1"> function, but as it stands, this follows the standard object generation as in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.328.1"> method, just with a twist. </span><span class="koboSpan" id="kobo.328.2">It uses indexes to add an object to a specific place in the pooled array. </span><span class="koboSpan" id="kobo.328.3">There is a lot of room for improvement with this function to make it more versatile, but </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.329.1">that is left to your </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">implementation’s needs:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.331.1">ObjectPool.cpp excerpt part 4</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
void AObjectPool::RegenItem(int poolIndex, int positionIndex)
{
    FActorSpawnParameters spawnParams;
    spawnParams.Name =
        FName(_PooledObjectData[poolIndex]._ActorName);
    spawnParams.NameMode =
        FActorSpawnParameters::ESpawnActorNameMode::Requested;
    spawnParams.SpawnCollisionHandlingOverride =
        ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
    AActor* spawnedActor = GetWorld()-&gt;
        SpawnActor(_PooledObjectData[poolIndex].
</span><span class="koboSpan" id="kobo.332.2">            _ActorTemplate, &amp;FVector::ZeroVector,
                &amp;FRotator::ZeroRotator, spawnParams);
    UPooledObject* poolComp =
        NewObject&lt;UPooledObject&gt;(spawnedActor);
    poolComp-&gt;RegisterComponent();
    spawnedActor-&gt;AddInstanceComponent(poolComp);
    poolComp-&gt;Init(this);
    _Pools[poolIndex]._PooledObjects.Insert(poolComp,
        positionIndex);
    spawnedActor-&gt;SetActorHiddenInGame(true);
    spawnedActor-&gt;SetActorEnableCollision(false);
    spawnedActor-&gt;SetActorTickEnabled(false);
    spawnedActor-&gt;AttachToActor(this,FAttachmentTransformRules::
    SnapToTargetNotIncludingScale);
}</span></pre> <p><span class="koboSpan" id="kobo.333.1">As stated a few times </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.334.1">previously, this object pooler will do the job, but it is very basic in its utility. </span><span class="koboSpan" id="kobo.334.2">There are many extensions that you could, and probably should, consider, such as having pool groups so that objects are pooled based on the requested groups from the level or making it into a world subsystem that is universal to that world, allowing easy setup via the P</span><strong class="bold"><span class="koboSpan" id="kobo.335.1">roject Settings</span></strong><span class="koboSpan" id="kobo.336.1"> panel. </span><span class="koboSpan" id="kobo.336.2">However, the principle use of it stays the same: to offset the cost of spawning to the start of a level, where it can be hidden under a </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">loading screen.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Using what we have </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.339.1">created in its current form is quite simple. </span><span class="koboSpan" id="kobo.339.2">Simply drag an instance of the object pooler into your world from the Project panel and set up its data variable in the details panel. </span><span class="koboSpan" id="kobo.339.3">Once the game starts, it will spawn all the required objects in and hide them. </span><span class="koboSpan" id="kobo.339.4">To get an object, all you need to do is obtain a reference to the pooler somehow and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">GetPooledObject</span></strong><span class="koboSpan" id="kobo.341.1"> function, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.342.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.343.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 10.4 – Screenshot of the blueprint usage of the object pooler" src="image/Figure_10.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 10.4 – Screenshot of the blueprint usage of the object pooler</span></p>
<p><span class="koboSpan" id="kobo.347.1">With that, we are at the</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.348.1"> end of our journey through object pooling. </span><span class="koboSpan" id="kobo.348.2">If you have been following along, you will not only have an object pooler that you can migrate between projects but also an idea of how you can remake and improve it to suit specific needs as and when required. </span><span class="koboSpan" id="kobo.348.3">Not only this, but the end of this section also brings us to the end of the chapter and the book. </span><span class="koboSpan" id="kobo.348.4">Even though this wasn’t specifically designed as a book to be read in order, from cover to cover, if you have been following this journey from the beginning, then you have a good set of practical skills and templates for how to improve your code in numerous ways. </span><span class="koboSpan" id="kobo.348.5">There will be some more parting words of wisdom after this, but let’s round this chapter content out by saying that it is more important to get something working than to build it exactly correct from the start, which is why the term </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">refactoring exists.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.350.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.351.1">In this last chapter, we have covered three patterns that will boost the efficiency of your game, if implemented correctly. </span><span class="koboSpan" id="kobo.351.2">In game development, optimization should not be something you consider until it becomes a problem. </span><span class="koboSpan" id="kobo.351.3">It is far more important that you get something working first. </span><span class="koboSpan" id="kobo.351.4">Data locality should probably be considered as a first measure as it requires the least refactoring of code. </span><span class="koboSpan" id="kobo.351.5">Likewise, an object pool is something we would always recommend you have in your project, via a plugin, on standby for when you start to spawn a lot of the same object. </span><span class="koboSpan" id="kobo.351.6">The dirty flag pattern is much more situational, though, and is only applicable when an object has lots of edits versus few read actions per second. </span><span class="koboSpan" id="kobo.351.7">Armed with these tools, you should be able to make a dent in the frame rate, destroying the spaghetti mess that all projects become before release. </span><span class="koboSpan" id="kobo.351.8">There are always more ways to optimize code beyond this too – some not quite so obvious – but the key is to remember that all data and all instructions are stored somewhere and actions using them require them to be moved, which </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">takes time.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">You can find the finished project with all the elements from this book completed on GitHub in the same place as the other chapters in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Complete</span></strong><span class="koboSpan" id="kobo.355.1"> branch. </span><span class="koboSpan" id="kobo.355.2">Feel free to create a fork from here and make your own improvements to each of </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">these patterns:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete"><span class="No-Break"><span class="koboSpan" id="kobo.357.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Complete</span></span></a></p>
<p><span class="koboSpan" id="kobo.358.1">A final rule: Good code doesn’t make a game good, but it does make your </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">team better.</span></span></p>
</div>
</body></html>