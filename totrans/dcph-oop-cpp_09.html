<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-167"><a id="_idTextAnchor426"/>9</h1>
<h1 id="_idParaDest-168"><a id="_idTextAnchor427"/>Exploring Multiple Inheritance</h1>
<p>This chapter will continue broadening our knowledge of object-oriented programming in C++. We will begin by examining a controversial OO concept, <strong class="bold">multiple inheritance</strong> (<strong class="bold">MI</strong>), understanding why it is controversial, how it can reasonably be used to support OO designs, as well as when alternative designs may be more appropriate.</p>
<p>Multiple inheritance can be implemented in C++ with <em class="italic">direct language support</em>. In doing so, we will be faced with several OO design issues. We will be asked to critically evaluate an inheritance hierarchy, asking ourselves whether we are using the best design possible to represent a potential set of object relationships. Multiple inheritance can be a powerful OOP tool; using it wisely is paramount. We will learn when to use MI to sensibly extend our hierarchies.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding multiple inheritance mechanics</li>
<li>Examining reasonable uses for multiple inheritance </li>
<li>Creating diamond-shaped hierarchies and exploring issues arising from their usage</li>
<li>Using virtual base classes to resolve diamond-shaped hierarchy duplication</li>
<li>Applying discriminators to evaluate the worthiness of a diamond-shaped hierarchy and MI in a design, as well as considering design alternatives </li>
</ul>
<p>By the end of this chapter, you will understand the OO concept of multiple inheritance, and how to implement this idea in C++. You will understand not only the simple mechanics of MI but the reasons for its usage (mix-in, Is-A or controversially, Has-A). </p>
<p>You will see why MI is controversial in OOP. Having more than one base class can lead to oddly shaped hierarchies, such as diamond-shaped; these types of hierarchies come with potential implementation issues. We will see how C++ incorporates a language feature (virtual base classes) to solve these conundrums, but the solution is not always ideal. </p>
<p>Once we understand the complexities caused by multiple inheritance, we will use OO design metrics, such as discriminators, to evaluate whether a design using MI is the best solution to represent a set of object relationships. We’ll look at alternative designs, and you will then be better equipped to understand not only what multiple inheritance is, but when it’s best utilized. Let us expand our understanding of C++ as a <em class="italic">“you can do anything”</em> OOP language by moving forward with MI.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor428"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter09</code> in a file named <code>Chp9-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3Cbqt7y">https://bit.ly/3Cbqt7y</a>.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor429"/><a id="_idTextAnchor430"/>Understanding multiple inheritance mechanics</h1>
<p>In C++, a class<a id="_idIndexMarker680"/> can have more than one immediate base class. This is known as <strong class="bold">multiple inheritance</strong>, and is a very controversial topic in both OO designs and OOP. Let’s begin with the simple mechanics; we will then move forward to the design issues and programming logistics surrounding MI during the progression of this chapter.</p>
<p>With multiple inheritance, the derived class specifies who each of its immediate ancestors or base classes are, using the base class list in its class definition. </p>
<p>In a similar fashion to single inheritance, the constructors and destructors are invoked all the way up the hierarchy as objects of the derived class type are instantiated and destroyed. Reviewing and expanding upon the subtleties of construction and destruction for MI, we are reminded of the following logistics:</p>
<ul>
<li>The calling sequence for a constructor starts with the derived class, but immediately passes control to a base constructor, and so on up the hierarchy. Once the calling sequence passes control to the top of the hierarchy, the execution sequence begins. All the highest-level base class constructors at the same level are first executed, and so on down the hierarchy until we arrive at the derived class constructor, whose body is executed last in the construction chain.</li>
<li>The derived class destructor is invoked and executed first, followed by all the immediate base class destructors and so on, as we progress up the inheritance hierarchy.</li>
</ul>
<p>The member initialization list in the derived class constructor may be used to specify which constructor for each immediate base class should be invoked. In the absence of this specification, the default constructor will be used for that base class’ constructor.</p>
<p>Let’s take a look at a typical multiple inheritance example<a id="_idTextAnchor431"/> to implement a quintessential application of MI from an OO design, as well as to understand basic MI syntax in C++. This example will be broken into many segments; the full program can be found in the following GitHub<a id="_idIndexMarker681"/> location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
using std::string;
using std::to_string;
class Person
{
private: 
    string firstName;
    string lastName;
    char middleInitial = '\0';  // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
protected:
    void ModifyTitle(const string &amp;);  
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    Person(const Person &amp;) = delete;  // prohibit copies
    virtual ~Person();  // destructor prototype
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const 
        { return lastName; }    
    const string &amp;GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
};</pre>
<p>In the previous code <a id="_idIndexMarker682"/>segment, we have an expected class definition for <code>Person</code>, containing the class elements that we are accustomed to defining.</p>
<p>Next, let’s see the accompanying member functions for this class:</p>
<pre class="source-code">
// With in-class initialization, writing the default
// constructor is no longer necessary.
// Also, remember strings are member objects and will 
// be default constructed as empty.
Person::Person(const string &amp;fn, const string &amp;ln, char mi, 
               const string &amp;t): firstName(fn),
               lastName(ln), middleInitial(mi), title(t)
{
}
// Simple destructor so we can trace the destruction chain
Person::~Person()  
{
    cout &lt;&lt; "Person destructor &lt;" &lt;&lt; firstName &lt;&lt; " " &lt;&lt; 
            lastName &lt;&lt; "&gt;" &lt;&lt; endl;
}
void Person::ModifyTitle(const string &amp;newTitle)
{
    title = newTitle;
}</pre>
<p>In the previous <a id="_idIndexMarker683"/>segment of code, the member function definitions for <code>Person</code> are as expected. Nonetheless, it is useful to see the <code>Person</code> class defined, as this class will serve as a building block, and portions of it will be directly accessed in upcoming code segments.</p>
<p>Now, let’s define a new class, <code>BillableEntity</code>:</p>
<pre class="source-code">
class BillableEntity
{
private:
    float invoiceAmt = 0.0;   // in-class initialization
public:
    BillableEntity() = default;
    BillableEntity(float amt) invoiceAmt(amt) { } 
    // prohibit copies with prototype below
    BillableEntity(const BillableEntity &amp;) = delete; 
    virtual ~BillableEntity();
    void Pay(float amt) { invoiceAmt -= amt; }
    float GetBalance() const { return invoiceAmt; }
    void Balance() const;
};
// Simple destructor so we can trace destruction chain
BillableEntity::~BillableEntity()
{
    cout &lt;&lt; "BillableEntity destructor" &lt;&lt; endl;
}
void BillableEntity::Balance() const
{
    if (invoiceAmt)
       cout &lt;&lt; "Owed amount: $ " &lt;&lt; invoiceAmt &lt;&lt; endl;
    else
       cout &lt;&lt; "Credit: $ " &lt;&lt; 0.0 - invoiceAmt &lt;&lt; endl;
}</pre>
<p>In the previous <code>BillableEntity</code> class, we define a class containing simple functionality to encapsulate a billing structure. That is, we have an invoice amount and methods such as <code>Pay()</code> and <code>GetBalance()</code>. Notice that the copy constructor indicates <code>= delete</code> in its prototype; this will prohibit copies, which seems appropriate given the nature of this class.</p>
<p>Next, let’s combine the two aforementioned base classes, <code>Person</code> and <code>BillableEntity</code>, to <a id="_idIndexMarker684"/>serve as base classes for our <code>Student</code> class:</p>
<pre class="source-code">
class Student<strong class="bold">: public Person, public BillableEntity</strong>
{
private: 
    float gpa = 0.0;   // in-class initialization
    string currentCourse;
    const string studentId;
    static int numStudents;
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;, float); 
    Student(const Student &amp;) = delete;  // prohibit copies
    ~Student() override; 
    void Print() const;
    void EarnPhD();  
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const
        { return currentCourse; }
    const string &amp;GetStudentId() const 
        { return studentId; }
    void SetCurrentCourse(const string &amp;);
    static int GetNumberStudents();
};
// definition for static data member
int Student::numStudents = 0;  // notice initial value of 0
inline void Student::SetCurrentCourse(const string &amp;c)
{
   currentCourse = c;
}
inline int Student::GetNumberStudents()
{
    return numStudents;
}</pre>
<p>In the preceding <a id="_idIndexMarker685"/>class definition for <code>Student</code>, two public base classes, <code>Person</code> and <code>BillableEntity</code>, are specified in the base class list for <code>Student</code>. These two base classes are merely comma-separated in the <code>Student</code> base class list. We have also included the inline function definitions with the class definition, as these are usually bundled together in a header file.</p>
<p>Let’s further see what accommodations must be made in the remainder of the <code>Student</code> class by examining its member functions:</p>
<pre class="source-code">
// Due to non-specification in the member init list, this 
// constructor calls the default base class constructors
Student::Student() : studentId(to_string(numStudents + 100) 
                                         + "Id")
{
   // Note: since studentId is const, we need to set it at 
   // construction using member init list. Remember, string
   // members are default constructed w an empty str<a id="_idTextAnchor432"/>ing. 
   numStudents++;
}
// The member initialization list specifies which versions
// of each base class constructor should be utilized.
Student::Student(const string &amp;fn, const string &amp;ln, 
        char mi, const string &amp;t, float avg, 
        const string &amp;course, const string &amp;id, float amt)<strong class="bold">:</strong> 
        <strong class="bold">Person(fn, ln, mi, t)</strong>, <strong class="bold">BillableEntity(amt)</strong>,
        gpa(avg), currentCourse(course), studentId(id)
{
   numStudents++;
}
// Simple destructor so we can trace destruction sequence
Student::~Student()
{
   numStudents--;
   cout &lt;&lt; "Student destructor &lt;" &lt;&lt; GetFirstName() &lt;&lt; " "
        &lt;&lt; GetLastName() &lt;&lt; "&gt;" &lt;&lt; endl;
}
void Student::Print() const
{
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with id: " &lt;&lt; studentId &lt;&lt; " has a gpa of: ";
    cout &lt;&lt; " " &lt;&lt; gpa &lt;&lt; " and course: " &lt;&lt; currentCourse;
    cout &lt;&lt; " with balance: $" &lt;&lt; GetBalance() &lt;&lt; endl;
}
void Student::EarnPhD() 
{  
    ModifyTitle("Dr."); 
}</pre>
<p>Let’s consider <a id="_idIndexMarker686"/>the previous code segment. In the default constructor for <code>Student</code>, due to the lack of base class constructor specification in the member initialization list, the default constructors will be called for both the <code>Person</code> and <code>BillableEntity</code> base classes.</p>
<p>However, notice that in the alternate <code>Student</code> constructor, we merely comma-separate our two base class constructor choices in the member initialization list – that is, <code>Person(const string &amp;, const string &amp;, char, const string &amp;)</code> and <code>BillableEntity(float)</code> – and then pass various parameters from the <code>Student</code> constructor to the base class constructors using this list.</p>
<p>Finally, let’s take a look at our <code>main()</code> function:</p>
<pre class="source-code">
int main()
{
    float tuition1 = 1000.00, tuition2 = 2000.00;
    Student s1("Gabby", "Doone", 'A', "Ms.", 3.9, "C++",
               "178GWU", tuition1); 
    Student s2("Zack", "Moon", 'R', "Dr.", 3.9, "C++",
               "272MIT", tuition2); 
    // public mbrs. of Person, BillableEntity, Student are
    // accessible from any scope, including main()
    s1.Print();
    s2.Print();
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; " paid $500.00" &lt;&lt; endl;
    s1.Pay(500.00);
    cout &lt;&lt; s2.GetFirstName() &lt;&lt; " paid $750.00" &lt;&lt; endl;
    s2.Pay(750.00);
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; ": ";
    s1.Balance();
    cout &lt;&lt; s2.GetFirstName() &lt;&lt; ": ";
    s2.Balance();
    return 0;
}</pre>
<p>In our <code>main()</code> function <a id="_idIndexMarker687"/>in the previous code, we instantiate several <code>Student</code> instances. Notice that <code>Student</code> instances can utilize any methods in the public interface of <code>Student</code>, <code>Person</code>, or <code>BillableEntity</code>. </p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Ms. Gabby A. Doone with id: 178GWU has a gpa of:  3.9 and course: C++ with balance: $1000
Dr. Zack R. Moon with id: 272MIT has a gpa of:  3.9 and course: C++ with balance: $2000
Gabby paid $500.00
Zack paid $750.00
Gabby: Owed amount: $ 500
Zack: Owed amount: $ 1250
Student destructor &lt;Zack Moon&gt;
BillableEntity destructor
Person destructor &lt;Zack Moon&gt;
Student destructor &lt;Gabby Doone&gt;
BillableEntity destructor
Person destructor &lt;Gabby Doone&gt;</pre>
<p>Notice the destruction sequence in the aforementioned output. We can see each <code>Student</code> instance invokes the <code>Student</code> destructor, as well as the destructors for each base class (<code>BillableEntity</code> and <code>Person</code>).</p>
<p>We have now seen<a id="_idIndexMarker688"/> the language mechanics for MI with a typically implemented OO design. Now, let’s move forward by looking at the typical reasons for employing multiple inheritance in OO designs, some of which are more widely accepted than<a id="_idTextAnchor433"/><a id="_idTextAnchor434"/> others.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor435"/>Examining reasonable uses for multiple inheritance</h1>
<p>Multiple inheritance<a id="_idIndexMarker689"/> is a controversial concept that arises when creating OO designs. Many OO designs avoid MI; other designs embrace it with strict usage. Some OOP languages, such as Java, do not explicitly provide direct language support for multiple inheritance. Instead, they offer interfaces, such as we’ve modeled in C++ by creating interface classes using abstract classes (restricted to containing only pure virtual functions) in <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em>.</p>
<p>Of course, in C++, inheriting from two interface classes is still a use of multiple inheritance. Though C++ does not include interface classes within the language, this concept can be simulated by employing a more restrictive use of MI. For example, we can programmatically streamline abstract classes to include only pure virtual functions (no data members, and no member functions with definitions) to mimic the OO design idea of an interface class.</p>
<p>Typical MI conundrums form the basis of why MI is contentious in OOP. Classic MI quandaries will be detailed in this chapter and can be avoided by restricting MI to the usage of interface classes only, or through a redesign. This is why some OOP languages only support interface classes versus allowing unrestricted MI. In C++, you can carefully consider each OO design and choose when to utilize MI, when to utilize a restrictive form of MI (interface classes), or when to employ a redesign eliminating MI. </p>
<p>C++ is a <em class="italic">“you can do anything”</em> programming language. As such, C++ allows multiple inheritance without restrictions or reservations. As an OO programmer, we will look more closely at typical reasons to embrace MI. As we move further into this chapter, we will evaluate issues that arise by using MI and see how C++ solves these issues with additional language features. These MI issues will allow us to then apply metrics to understand more reasonably when we should use MI and when a redesign may be more appropriate.</p>
<p>Let’s begin our <a id="_idIndexMarker690"/>pursuit of reasonable uses of MI by considering Is-A and mix-in relationships, and then move to examining the controversial use of MI to implement Has-A relationships. </p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor436"/>Supporting Is-A and mix-in relationships</h2>
<p>As we have<a id="_idIndexMarker691"/> learned<a id="_idIndexMarker692"/> with single<a id="_idIndexMarker693"/> inheritance, an <a id="_idIndexMarker694"/>Is-A relationship is most often used to describe the relationship between two inherited classes. For example, a <code>Student</code> <em class="italic">Is-A</em> <code>Person</code>. The same desired ideal continues with MI; Is-A relationships are the primary motivations to specify inheritance. In pure OO designs and programming, inheritance should be used only to support Is-A relationships.</p>
<p>Nonetheless, as we have learned when we looked at interface classes (a concept modeled in C++ using abstract classes with the restriction of containing only pure virtual functions), mix-in relationships often apply when we inherit from an interface. Recall that a mix-in relationship is when we use inheritance to mix-in the functionality of another class, simply because that functionality is useful or meaningful for the derived class to have. The base class need not be an abstract or interface class, but employing an ideal OO design, it would be as such. </p>
<p>The mix-in base class represents a class in which an Is-A relationship does not apply. Mix-ins exist more so with multiple inheritance, at least as the reason supporting the necessity of one of the (many) base classes. Since C++ has direct language support for multiple inheritance, MI can be used to support implementing mix-ins (whereas languages such as Java may only use interface classes). In practice, MI is often used to inherit from one class to support an Is-A relationship and to also inherit from another class to support a mix-in relationship. In our last example, we saw that a <code>Student</code> <em class="italic">Is-A</em> <code>Person</code>, and a <code>Student</code> chooses to <em class="italic">mix-in</em> <code>BillableEntity</code> capabilities.</p>
<p>Reasonable uses of MI in C++ include supporting both Is-A and mix-in relationships; however, our<a id="_idIndexMarker695"/> discussion would <a id="_idIndexMarker696"/>not<a id="_idIndexMarker697"/> be<a id="_idIndexMarker698"/> complete without next considering an unusual use of MI – implementing Has-A relationships.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor437"/>Supporting Has-A relationships</h2>
<p>Less commonly, and <a id="_idIndexMarker699"/>much more<a id="_idIndexMarker700"/> controversially, MI can be used to implement a Has-A relationship, that is, to model containment, or a whole versus part relationship. We will see in <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, a more widely accepted implementation for Has-A relationships; however, MI provides a very simple implementation. Here, the parts serve as the base classes. The whole inherits from the parts, automatically including the parts in its memory layout (and also automatically inheriting the parts’ members and functionality). </p>
<p>For example, a <code>Student</code> <em class="italic">Is-A</em> <code>Person</code> and a <code>Student</code> <em class="italic">Has-A(n)</em> <code>Id</code>; the usage of the second base class (<code>Id</code>) is for containment. <code>Id</code> will serve as a base class and <code>Student</code> will be derived from <code>Id</code> to factor in all that an <code>Id</code> offers. The <code>Id</code> public interface is immediately usable to <code>Student</code>. In fact, any class that inherits from <code>Id</code> will inherit a uniform interface when utilizing its <code>Id</code> parts. This simplicity is a driving reason why inheritance is sometimes used to model containment. </p>
<p>However, using inheritance to implement Has-A relationships can cause unnecessary usage of MI, which can then complicate an inheritance hierarchy. Unnecessary usage of MI is the primary reason why using inheritance to model Has-A relationships is very controversial and is quite frankly frowned upon in pure OO designs. Nonetheless, we mention it <a id="_idIndexMarker701"/>because you will see <a id="_idIndexMarker702"/>some C++ applications using MI for Has-A implementation.</p>
<p>Let’s move forward to explore other controversial designs employing MI, namely that of a diamond-shaped hierarchy. </p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor438"/>Creating a diamond-shaped hierarchy</h1>
<p>When using <a id="_idIndexMarker703"/>multiple inheritance, sometimes it is tempting to utilize sibling (or cousin) classes as base classes for a new derived class. When this happens, the hierarchy is no longer a tree in shape, but rather, a graph containing a <em class="italic">diamond</em>. </p>
<p>Whenever an object of the derived class type is instantiated in such a situation, two copies of the common base class will be present in the instance of the derived class. Duplication of this sort obviously wastes space. Additional time is also wasted by calling duplicate constructors and destructors for this repeated subobject and by maintaining two parallel copies of a subobject (most likely unnecessarily). Ambiguities also result when trying to access members from this common base class.</p>
<p>Let’s see an example detailing this issue, starting with abbreviated (and simplified) class definitions of <code>LifeForm</code>, <code>Horse</code>, and <code>Person</code>. Though only portions of the full program example are shown, the program in its entirety can be found in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp</a></p>
<pre class="source-code">
class Lifeform
{   // abbreviated class definition – see full code online
private:
    int lifeExpectancy = 0;  // in-class initialization
public:
    LifeForm(int life): lifeExpectancy(life) { }
    [[nodiscard]] int GetLifeExpectancy() const 
        { return lifeExpectancy; }
    // additional constructors, destructor, etc.
    virtual void Print() const = 0; // pure virtual funcs.
    virtual string IsA() const = 0;
    virtual string Speak() const = 0;
};
class Horse: public LifeForm
{   // abbreviated class definition
private:
    string name;
    static constexpr int HORSE_LIFE = 35; // life exp Horse
public:
    Horse(): LifeForm(HORSE_LIFE) { }
    // additional constructors, destructor, etc …
    void Print() const override { cout &lt;&lt; name &lt;&lt; endl; }
    string IsA() <a id="_idTextAnchor439"/>const override { return "Horse"; }
    string Speak() const override { return "Neigh!"; }
};
class Person: public LifeForm
{   // abbreviated class definition
private: 
    string firstName;
    string lastName;
    static constexpr int PERSON_LIFE = 80; // life expect.
                                           // of Person
    // additional data members (imagine them here)
public:
    Person(): LifeForm(PERSON_LIFE) { }
    // additional constructors, destructor, etc.
    const string &amp;GetFirstName() const 
        { return firstName; }
    // additional access methods, etc. 
    void Print() const override
        { cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; lastName &lt;&lt; endl; }
    string IsA() <a id="_idTextAnchor440"/>const override { return "Person"; }
    string Speak() const override { return "Hello!"; }
};</pre>
<p>The previous fragment <a id="_idIndexMarker704"/>of code shows skeleton class definitions for <code>LifeForm</code>, <code>Person</code>, and <code>Horse</code>. Each class shows a default constructor, which merely serves as an example to show how <code>lifeExpectancy</code> is set for each class. In the default constructors for <code>Person</code> and <code>Horse</code>, the member initialization list is used to pass a value of <code>35</code> (<code>HORSE_LIFE</code>) or <code>80</code> (<code>PERSON_LIFE</code>) to the <code>LifeForm</code> constructor to set this value. </p>
<p>Though the previous class definitions are abbreviated (that is, purposely incomplete) to save space, let’s assume that each class has appropriate additional constructors defined, an appropriate destructor, and other necessary member functions. </p>
<p>We notice that <code>LifeForm</code> is an abstract class, in that it offers pure virtual functions: <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>. Both <code>Horse</code> and <code>Person</code> are concrete classes and will be instantiable because they override these pure virtual functions with virtual functions. These virtual functions are shown inline, only to make the code compact for viewing (virtual functions will almost never be inlined by the compiler as their methods are nearly always determined at runtime).</p>
<p>Next, let’s look at a new derived class that will introduce the graph, or diamond <a id="_idTextAnchor441"/>shape, in our hierarchy:</p>
<pre class="source-code">
class Centaur<strong class="bold">: public Person, public Horse</strong>
{   // abbreviated class definition
public:
    // constructors, destructor, etc …
    void Print() const override
       { cout &lt;&lt; GetFirstName() &lt;&lt; <a id="_idTextAnchor442"/>endl; }
    string IsA() const override { return "Centaur"; }
    string Speak() const override
       { return "Neigh! and Hello!"; }
};</pre>
<p>In the previous<a id="_idIndexMarker705"/> fragment, we define a new class, <code>Centaur</code>, using multiple inheritance. At first glance, we truly do mean to assert the Is-A relationship between <code>Centaur</code> and <code>Person</code>, and also between <code>Centaur</code> and <code>Horse</code>. However, we’ll soon challenge our assertion to test whether it is more of a combination than a true Is-A relationship. </p>
<p>We will assume that all of the necessary constructors, the destructor, and member functions exist to make <code>Centaur</code> a well-defined class. </p>
<p>Now, let’s move forward to look at a potential <code>main()</code> function we might utilize:</p>
<pre class="source-code">
int main()
{
    Centaur beast("Wild", "Man");
    cout &lt;&lt; beast.Speak() &lt;&lt; " I'm a " &lt;&lt; beast.IsA();
    cout &lt;&lt; endl;
    <strong class="bold">// Ambiguous method call – which LifeForm sub-object?</strong>
    <strong class="bold">// cout &lt;&lt; beast.GetLifeExpectancy();</strong>  
    cout &lt;&lt; "It is unclear how many years I will live: ";
    cout &lt;&lt; <strong class="bold">beast.Person::GetLifeExpectancy()</strong> &lt;&lt; " or ";
    cout &lt;&lt; <strong class="bold">beast.Horse::GetLifeExpectancy()</strong> &lt;&lt; endl; 
    return 0;
}</pre>
<p>Here, in <code>main()</code>, we instantiate a <code>Centaur</code> and we name the instance <code>beast</code>. We easily call two polymorphic operations on <code>beast</code>, namely <code>Speak()</code> and <code>IsA()</code>. Then we try to call the public inherited <code>GetLifeExpectancy()</code>, which is defined in <code>LifeForm</code>. Its implementation is included in <code>Lifeform</code> so that <code>Person</code>, <code>Horse</code>, or <code>Centaur</code> do not need to provide a definition (nor should they – it’s not a virtual function meant to be redefined).</p>
<p>Unfortunately, calls to <code>GetLifeExpectancy()</code> via <code>Centaur</code> instances are ambiguous. This is because there are two <code>LifeForm</code> subobjects in the <code>beast</code> instance. Remember, <code>Centaur</code> is derived from <code>Horse</code>, which is derived from <code>LifeForm</code>, providing the memory layout for all the aforementioned base class data members (<code>Horse</code> and <code>LifeForm</code>). And <code>Centaur</code> is also derived from <code>Person</code>, which is derived <a id="_idIndexMarker706"/>from <code>Lifeform</code>, which contributes the memory layout for <code>Person</code> and <code>LifeForm</code> within <code>Centaur</code>. The <code>LifeForm</code> piece is duplicated. </p>
<p>There are two copies of the inherited data member <code>int lifeExpectancy;</code>. There are two subobjects of <code>LifeForm</code> within the <code>Centaur</code> instance. Therefore, when we try to call <code>GetLifeExpectancy()</code> through the <code>Centaur</code> instance, the method call is ambiguous. Which <code>lifeExpectancy</code> are we trying to initialize? Which <code>LifeForm</code> subobject will serve as the <code>this</code> pointer when <code>GetLifeExpectancy()</code> is called? It is simply not clear, so the compiler will not choose for us.</p>
<p>To disambiguate the <code>GetLifeExpectancy()</code> function call, we must use the scope resolution operator. We precede the <code>::</code> operator with the intermediate base class from which we want the <code>LifeForm</code> subobject. Notice that we call, for example, <code>beast.Horse::GetLifeExpectancy()</code> to choose the <code>lifeExpectancy</code> from the <code>Horse</code> subobject’s path, which will include <code>LifeForm</code>. This is awkward, as neither <code>Horse</code> nor <code>Person</code> includes the ambiguous member; <code>lifeExpectancy</code> is found in <code>LifeForm</code>. </p>
<p>Let’s consider the output for the aforementioned program: </p>
<pre>Neigh! and Hello! I'm a Centaur.
It is unclear how many years I will live: 80 or 35.</pre>
<p>We can see that designing a hierarchy that includes a diamond shape has drawbacks. These conundrums include programming ambiguities that need to be resolved in an awkward fashion, duplication in memory of repeated subobjects, plus time to construct and destruct these duplicate subobjects. </p>
<p>Luckily, C++ has a language feature to alleviate these hardships with diamond-shaped hierarchies. After all, C++  is a language that will allow us to do anything. Knowing when and whether we should utilize these features is another concern. Let’s first take a look at the C++ language<a id="_idIndexMarker707"/> solution to deal with diamond-shaped hierarchies and their inherent problems by looking at virtual base classes.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor443"/>Utilizing virtual base classes to eliminate duplication</h1>
<p>We have just<a id="_idIndexMarker708"/> seen the MI implementation issues that quickly arise when a diamond shape is included in an OO design – duplication in memory for a repeated subobject, ambiguity accessing that subobject (even through inherited member functions), and the duplication of construction and destruction. For these reasons, pure OO designs will not include graphs in a hierarchy (that is, no diamond shapes). Yet, we know C++ is a powerhouse of a language and anything is possible. As such, C++ will provide us with a solution to these issues.</p>
<p><code>virtual</code> is placed in the base class list between the access label and the base class name of the sibling or cousin class that may <em class="italic">later</em> be used as a base class for the same derived class. Note that knowing two sibling classes may later be combined as common base classes for a new derived class can be difficult. It is important to note that sibling classes that do not specify a virtual base class will demand their own copy of the (otherwise) shared base class.</p>
<p>Virtual base classes should be used sparingly in implementation because they place restrictions and overhead on instances that have such a class as an ancestor class. Restrictions to be aw<a id="_idTextAnchor444"/>are of include the following:</p>
<ul>
<li>An instance having a virtual base class can use more memory than its non-virtual counterpart (the instance contains a pointer to the potentially shared base class component).</li>
<li>Casting from an object of a base class type to a derived class type is prohibited when a virtual base class is in the ancestor hierarchy.</li>
<li>The member initialization list of the most derived class must be used to specify which constructor of the shared object type should be used for initialization. If this specification is ignored, the default constructor will be used to initialize this subobject.</li>
</ul>
<p>Let us now look<a id="_idIndexMarker710"/> at a full program example that employs virtual base classes. As usual, the full program can be found in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
using std::string;
using std::to_string;
class LifeForm
{
private:
    int lifeExpectancy = 0;  // in-class initialization
public:
    LifeForm() = default; 
    LifeForm(int life): lifeExpectancy(life) { }
    // We're accepting default copy constructor, but if we
    // wanted to write it, it would look like:
    // LifeForm(const LifeForm &amp;form): 
    //         lifeExpectancy(form.lifeExpectancy) { }
    // prototype necessary to specify virtual dest. below
    virtual ~LifeForm() = default;
    [[nodiscard]] int GetLifeExpectancy() const 
        { return lifeExpectancy; }
    virtual void Print() const = 0; 
    virtual string IsA() const = 0;   
    virtual string Speak() const = 0;
};</pre>
<p>In the previous <a id="_idIndexMarker711"/>segment of code, we see the full class definition of <code>LifeForm</code>. Notice that the member functions with bodies are inlined in the class definition. Of course, the compiler will not actually make inline substitutions for constructors or the virtual destructor; knowing this, it is convenient to write the methods as inline to make the class compact for reviewing. </p>
<p>Next, let’s see the class definition for <code>Horse</code>:</p>
<pre class="source-code">
class Horse<strong class="bold">: public virtual LifeForm</strong>
{
private:
    string name;
    static constexpr int HORSE_LIFE = 35; // Horse life exp
public:
    Horse() : LifeForm(HORSE_LIFE) { }
    Horse(const string &amp;n);
    // Remember, it isn't necessary to proto def. copy ctor
    // Horse(const Horse &amp;) = default; 
    // Because base class destructor is virtual, ~Horse()
    // is automatically virtual (overridden) even w/o proto
    // ~Horse() override = default;
    const string &amp;GetName() const { return name; }
    void Print() const override 
        { cout &lt;&lt; name &lt;&lt; endl; }
    strin<a id="_idTextAnchor445"/>g IsA() const override { return "Horse"; }
    string Speak() const override { return "Neigh!"; }
};
Horse::Horse(const string &amp;n) : LifeForm(HORSE_LIFE),
                                name(n)
{
}
// We are using the default copy constructor, but if we
// wanted to write it, this is what it would look like:
// Horse::Horse(const Horse &amp;h): LifeForm (h), name(h.name)
// {
// }</pre>
<p>In the previous segment of code, we have the full class definition for <code>Horse</code>. Keep in mind that though certain methods are written as inline for compactness, the compiler will never actually inline a constructor or destructor. Nor can a virtual function be inlined, as its whole point is to have the appropriate method determined at runtime (except rare scenarios involving devirtualization).</p>
<p>Here, <code>LifeForm</code> is a virtual base class of <code>Horse</code>. This means that if <code>Horse</code> ever has a sibling (or cousin) that also inherits from <code>LifeForm</code> using a virtual base class, and those siblings serve as base classes for a derived class, then those siblings will <em class="italic">share</em> their copy of <code>LifeForm</code>. The virtual base class will reduce storage, reduce extra constructor and destructor calls, and eliminate ambiguity.</p>
<p>Notice the <code>Horse</code> constructors that specify a constructor specification of <code>LifeForm(HORSE_LIFE)</code> in their member initialization lists. This base class initialization will be ignored if <code>LifeForm</code> actually is a shared virtual base class, though these constructor specifications are certainly valid for instances of <code>Horse</code> or for instances of descendants of <code>Horse</code> in which the diamond shape hierarchy does not apply. In <a id="_idIndexMarker712"/>hierarchies where <code>Horse</code> is combined with a sibling class to truly serve as a virtual base class, the <code>LifeForm(HORSE_LIFE)</code> specification will be ignored and, instead, either the default <code>LifeForm</code> constructor will be called, or another will be selected at a lower (and unusual) level in the hierarchy.</p>
<p>Next, let’s see more of this program by looking at additional class def<a id="_idTextAnchor446"/>initions, beginning with <code>Person</code>:</p>
<pre class="source-code">
class Person<strong class="bold">: public virtual LifeForm</strong>
{
private: 
    string firstName;
    string lastName;
    char middleInitial = '\0';  // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
    static constexpr int PERSON_LIFE = 80; // Life expect.
protected:
    void ModifyTitle(const string &amp;);  
public:
    Person();   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;); 
    // Default copy constructor prototype is not necessary 
    // Person(const Person &amp;) = default;  // copy ctor.
    // Because base class destructor is virtual, ~Person()
    // is automatically virtual (overridden) even w/o proto
    // ~Person() override = default;  // destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const 
        { return lastName; }    
    const string &amp;GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
    void Print() const override;
    string IsA() const override;   
    string Speak() const override;
};</pre>
<p>In the prior segment<a id="_idIndexMarker713"/> of code, we see that <code>Person</code> has a public virtual base class of <code>LifeForm</code>. Should <code>Person</code> and a sibling of <code>Person</code> ever be combined using multiple inheritance to be base classes for a new derived class, those siblings that have indicated a virtual base class of <code>LifeForm</code> will agree to share a single subobject of <code>LifeForm</code>. </p>
<p>Moving onward, let’s review the member functions of <code>Person</code>:</p>
<pre class="source-code">
Person::Person(): LifeForm(PERSON_LIFE)
{  // Note that the base class init list specification of
   // LifeForm(PERSON_LIFE) is ignored if LifeForm is a 
   // shared, virtual base class.
}  // This is the same in all Person constructors.
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t): LifeForm(PERSON_LIFE),
               firstName(fn), lastName(ln),
               middleInitial(mi), title(t)
{
}
// We're using the default copy constructor, but if we 
// wrote/prototyped it, here's what the method would be:
// Person::Person(const Person &amp;p): LifeForm(p),
//           firstName(p.firstName), lastName(p.lastName),
//           middleInitial(p.middleInitial), title(p.title)
// {
// }
void Person::ModifyTitle(const string &amp;newTitle)
{
    title = newTitle;
}
void Person::Print() const
{
    cout &lt;&lt; title &lt;&lt; " " &lt;&lt; firstName &lt;&lt; " ";
    cout &lt;&lt; middleInitial &lt;&lt; ". " &lt;&lt; lastName &lt;&lt; endl;
}
string Person::IsA() const
{  
    return "Person"; 
}
string Person::Speak() const
{   
    return "Hello!"; 
}</pre>
<p>In the aforementioned <a id="_idIndexMarker714"/>methods of <code>Person</code>, we see few details that surprise us; the methods are largely as expected. However, as a reminder, note that the <code>LifeForm(PERSON_LIFE)</code> specifications in the member initialization lists of the <code>Person</code> constructor will be ignored if <code>Person</code> is combined in a diamond-shaped hierarchy where the <code>LifeForm</code> subobject becomes shared, rather than duplicated. </p>
<p>Next, let’s take a look at where multiple inheritance comes into play, with the definition of the <code>Centaur</code> class:</p>
<pre class="source-code">
class Centaur<strong class="bold">: public Person, public Horse</strong>
{
private:
    // no additional data members required, but the below
    // static constexpr eliminates a magic number of 1000
    <strong class="bold">static constexpr int CENTAUR_LIFE = 1000;</strong> //life expect
public:
    Centaur()<strong class="bold">: LifeForm(CENTAUR_LIFE)</strong> { }
    Centaur(const string &amp;, const string &amp;, char = ' ', 
            const string &amp; = "Mythological Creature"); 
    <strong class="bold">// We don't want default copy constructor due to the</strong>
    <strong class="bold">// needed virtual base class in the mbr init list below</strong>
    Centaur(const Centaur &amp;c)<strong class="bold">:</strong> 
           Person(c), Horse(c), <strong class="bold">LifeForm(CENTAUR_LIFE)</strong> { }
    // Because base class' destructors are virt, ~Centaur()
    // is automatically virtual (overridden) w/o prototype
    // ~Centaur() override = default;
    void Print() const override;
    string IsA() const override;
    string Speak() const override;
};
// Constructors for Centaur need to specify how the shared
// base class LifeForm will be initialized
Centaur::Centaur(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;title)<strong class="bold">:</strong>
                 Person(fn, ln, mi, title), Horse(fn),
                 <strong class="bold">LifeForm(CENTAUR_LIFE)</strong>
{
   // All initialization has been taken care of in 
}  // member initialization list
void Centaur::Print() const
{
    cout &lt;&lt; "My name is " &lt;&lt; GetFirstName();
    cout &lt;&lt; ".  I am a " &lt;&lt; GetTitle() &lt;&lt; endl;
}
string Centaur::IsA() const 
{ 
    return "Centaur"; 
}
string Centaur::Speak() const
{
    return "Neigh! Hello! I'm a master of two languages.";
} </pre>
<p>In the<a id="_idIndexMarker715"/> aforementioned <code>Centaur</code> class definition, we can see that <code>Centaur</code> has public base classes of <code>Horse</code> and <code>Person</code>. We are implying that a <code>Centaur</code> <em class="italic">Is-A</em> <code>Horse</code> and <code>Centaur</code> <em class="italic">Is-A</em> <code>Person</code>. </p>
<p>Notice, however, that the keyword <code>virtual</code> is not used in the base class list with the <code>Centaur</code> class definition. Yet, <code>Centaur</code> is the level in the hierarchy where the diamond shape is introduced. This means that we must plan ahead in our design stage to know to utilize the <code>virtual</code> keyword in the base class list for our <code>Horse</code> and <code>Person</code> class definitions. This is an example of why a proper design session is critical versus just jumping into implementation.</p>
<p>Also, quite unusually, notice the base class list of <code>Person(fn, ln, mi, title), Horse(fn), LifeForm(CENTAUR_LIFE)</code> in the <code>Centaur</code> alternate constructor. Here, we not only specify the preferred constructor of our immediate base classes of <code>Person</code> and <code>Horse</code>, but also the preferred constructor for <em class="italic">their</em> common base class of <code>LifeForm</code>. This is highly unusual. Without <code>LifeForm</code> as a virtual base class for <code>Horse</code> and <code>Person</code>, <code>Centaur</code> would not be able to specify how to construct the shared <code>LifeForm</code> piece (that is, by choosing a constructor for other than its immediate base classes). You also will notice the base class constructor specification of <code>:LifeForm(CENTAUR_LIFE)</code> in the member initialization list of the default as well as copy constructors for the same purposes. The virtual base class usage makes the <code>Person</code> and <code>Horse</code> classes less reusable for other applications, for reasons outlined at the beginning of this subsection.</p>
<p>Let’s take a look <a id="_idIndexMarker716"/>at what our <code>main()</code> function entails:</p>
<pre class="source-code">
int main()
{
   Centaur beast("Wild", "Man");
   cout &lt;&lt; beast.Speak() &lt;&lt; endl;
   cout &lt;&lt; " I'm a " &lt;&lt; beast.IsA() &lt;&lt; ". ";
   beast.Print();
   cout &lt;&lt; "I will live: ";
   cout &lt;&lt; <strong class="bold">beast.GetLifeExpectancy()</strong>;// no longer ambiguous
   cout &lt;&lt; " years" &lt;&lt; endl; 
   return 0;
}</pre>
<p>Similar to the <code>main()</code> function in our non-virtual base class example, we can see that <code>Centaur</code> is likewise instantiated and that virtual functions such as <code>Speak()</code>, <code>IsA()</code>, and <code>Print()</code> are easily called. Now, however, when we call <code>GetLifeExpectancy()</code> through our <code>beast</code> instance, the call is no longer ambiguous. There is only one subobject of <code>LifeForm</code>, whose <code>lifeExpectancy</code> (an integer) has been<a id="_idTextAnchor447"/> initialized to <code>1000</code> (<code>CENTAUR_LIFE</code>).</p>
<p>Here is the output for the full program example: </p>
<pre>Neigh! Hello! I'm a master of two languages.
I am a Centaur. My name is Wild. I am a Mythological Creature.
I will live: 1000 years.</pre>
<p>Virtual base classes have solved a difficult MI conundrum. But we have also seen that the code required to do so is less flexible for future expansion and reuse. As such, virtual base classes should be carefully and sparingly used only when the design truly supports a diamond-shaped<a id="_idIndexMarker717"/> hierarchy. With that in mind, let’s consider an OO concept of a discriminator, and consider when alternate designs may be more appropriate.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor448"/>Considering discriminators and alternate designs</h1>
<p>A <strong class="bold">discriminator</strong> is an <a id="_idIndexMarker718"/>object-oriented concept that helps <a id="_idIndexMarker719"/>outline the reasons why a given class is derived from its base class. <strong class="bold">Discriminators</strong> tend to characterize the types of groupings of specializations that exist for a given base class. </p>
<p>For example, in the aforementioned program examples with diamond-shaped hierarchies, we have the following discriminators (shown in parentheses), outlining our purpose for specializing a new class from a given base class:</p>
<div><div><img alt="Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators " height="415" src="img/Figure_9.01_B19087.jpg" width="570"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators</p>
<p>Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining the discriminators can help us decide whether the design is reasonable, or whether perhaps an alternate design would prove better. Here are some good design metrics to consider:</p>
<ul>
<li>If<a id="_idIndexMarker720"/> the <a id="_idIndexMarker721"/>discriminators for the sibling classes that are being brought back together are the same, then the diamond-shaped hierarchy is better off redesigned. </li>
<li>When the sibling classes do not have unique discriminators, the attributes and behaviors they will introduce will consist of duplications stemming from having a <em class="italic">like-discriminator</em>. Consider making the discriminator a class to house those commonalities.</li>
<li>If the discriminators for the sibling classes are unique, then the diamond-shaped hierarchy may be warranted. In this case, virtual base classes will prove helpful and should be added to the appropriate locations in the hierarchy.</li>
</ul>
<p>In the previous example, the discriminator detailing why <code>Horse</code> specializes <code>LifeForm</code> is <code>Equine</code>. That is, we are specializing <code>LifeForm</code> with equine characteristics and behaviors (hooves, galloping, neighing, etcetera). Had we derived classes such as <code>Donkey</code> or <code>Zebra</code> from <code>LifeForm</code>, the discriminator for these classes would also be <code>Equine</code>. Considering the same aforementioned example, the <code>Person</code> class would have a <code>Humanoid</code> discriminator when specializing <code>LifeForm</code>. Had we derived classes such as <code>Martian</code> or <code>Romulan</code> from <code>LifeForm</code>, these classes would also have <code>Humanoid</code> as a discriminator.</p>
<p>Bringing <code>Horse</code> and <code>Person</code> together as base classes for <code>Centaur</code> is combining two base classes with different discriminators, <code>Equine</code> and <code>Humanoid</code>. As such, wholly different types of characteristics and behaviors are factored in by each base class. Though an alternate design may be possible, this design is acceptable (except to OO design purists), and virtual base classes may be used in C++ to eliminate duplication of the otherwise-replicated <code>LifeForm</code> piece. Bringing two classes together that share a common base class and that each specializes the base class using distinct discriminators is an example of how MI and virtual base classes are reasonable in C++.</p>
<p>However, bringing<a id="_idIndexMarker722"/> together<a id="_idIndexMarker723"/> two classes such as <code>Horse</code> and <code>Donkey</code> (both derived from <code>LifeForm</code>) together in a derived class such as <code>Mule</code> also creates a diamond-shaped hierarchy. Examining the discriminators for <code>Horse</code> and <code>Donkey</code> reveals that both have the discriminator of <code>Equine</code>. In this case, bringing together these two classes using a diamond-shaped design is not the optimal design choice. Another design choice is possible and preferred. In this case, a preferred solution would be to make the discriminator, <code>Equine</code>, its own class, and then derive <code>Horse</code>, <code>Donkey</code>, and <code>Mule</code> from <code>Equine</code>. This would avoid MI and a diamond-shaped hierarchy. Let’s take a look at the two design options:</p>
<div><div><img alt="Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI " height="434" src="img/Figure_9.02_B19087.jpg" width="1271"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Diamond-shaped m<a id="_idTextAnchor449"/>ultiple inheritance redesigned without MI</p>
<p class="callout-heading">Reminder</p>
<p class="callout">In a diamond-shaped hierarchy, if the discriminators for the <em class="italic">combined</em> classes are the same, a better design is possible (by making the discriminator its own class). However, if the discriminators are different, consider keeping the diamond-shaped MI hierarchy and then use virtual base classes to avoid duplic<a id="_idTextAnchor450"/>ation of the common base class subobject.</p>
<p>We have now thoroughly examined the OO concept of a discriminator and have seen how discriminators can be used to help evaluate the reasonableness of a design. In many cases, designs <a id="_idIndexMarker724"/>using diamond-shaped hierarchies can be <a id="_idIndexMarker725"/>redesigned to not only eliminate the diamond shape but to eliminate multiple inheritance altogether. Let’s briefly recap the MI issues and OO concepts we’ve covered in this chapter before moving onward to our next chapter.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor451"/>Summary</h1>
<p>In this chapter, we have marched onward with our quest for understanding object-oriented programming by exploring a controversial OOP topic, that of multiple inheritance. First, in this chapter, we have understood the simple mechanics of multiple inheritance. Equally important, we have reviewed reasons for building inheritance hierarchies and possible reasons for using MI (that is, specifying Is-A, mix-in, and Has-A relationships). We have been reminded that using inheritance to specify Is-A relationships supports pure OO designs. We have also seen the utility of using MI to implement mix-in relationships. We have also taken a look at the controversial use of MI to quickly implement a Has-A relationship; we’ll see in <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, a preferred implementation for Has-A. </p>
<p>We have seen how having multiple inheritance in our OO design toolkit can lead to diamond-shaped hierarchies. We have seen the inevitable issues arising from diamond-shaped hierarchies, such as duplication in memory, duplication in construction/destruction, and ambiguity in accessing a replicated subobject. We have also seen that C++ provides a language-supported mechanism to correct these issues, using virtual base classes. We know that virtual base classes solve a tedious problem, yet they themselves are not perfect solutions.</p>
<p>In an effort to critique diamond-shaped hierarchies, we have looked at an OO concept of a discriminator to help us weigh the validity of an OO design using MI in a diamond shape. This has also led us to understand that alternate designs can apply to a set of objects; sometimes a redesign is a more elegant approach in which the solution will yield easier, long-term use.</p>
<p>C++ is a <em class="italic">“you can do anything”</em> OOP language, and multiple inheritance is a controversial OO concept. Knowing when certain MI designs may be warranted and understanding language features to help with those MI issues will make you a better programmer. Knowing when a redesign is in order is also critical. </p>
<p>We are now ready to continue to <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, to further enhance our OOP skills by next learning how to represent association, aggregation, and composition with programming techniques. These upcoming concepts will <em class="italic">not</em> have direct language support, but the concepts are instrumental in our OO arse<a id="_idTextAnchor452"/>nal of skills. Let’s move onward!</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor453"/>Questions</h1>
<ol>
<li>Type in (or use the online code) for the diamond-shaped hierarchy example in this chapter that uses virtual base classes. Run it as is. Hint: you may want to add explicit destructors with <code>cout</code> statements to trace the destruction sequence:<ol><li>How many <code>LifeForm</code> subobjects exist for the instance of <code>Centaur</code>?</li><li>How many times is the <code>LifeForm</code> constructor (and destructor) invoked? Hint: you may want to place trace statements using <code>cout</code> in each of your constructors and destructor.</li><li>Which <code>LifeForm</code> constructor would be invoked if the constructor selections for <code>LifeForm</code> in the member initialization list of the <code>Centaur</code> constructors were omitted?</li></ol></li>
<li>Now, remove the keyword <code>virtual</code> from the base class list of <code>Person</code> and <code>Horse</code> (that is, <code>LifeForm</code> will no longer be a virtual base class of <code>Person</code> and <code>Horse</code>. <code>LifeForm</code> will just be a typical base class of <code>Person</code> and <code>Horse</code>.) Also, remove the <code>LifeForm</code> constructor selection from the member initialization list of the <code>Centaur</code> constructors. Now, instantiate <code>Centaur</code>:<ol><li>How many <code>LifeForm</code> subobjects exist for the instance of <code>Centaur</code>?</li><li>Now, how many times is the <code>LifeForm</code> constructor (and destructor) invoked? Hint: you may want to add trace statements to your constructors and destructor.</li></ol></li>
</ol>
</div>
</div></body></html>