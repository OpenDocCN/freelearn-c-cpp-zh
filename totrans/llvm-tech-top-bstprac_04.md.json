["```cpp\n$ ninja check-llvm-support\n```", "```cpp\n$ git clone https://github.com/llvm/llvm-test-suite\n```", "```cpp\n$ mkdir .O3_build\n$ cd .O3_build\n$ cmake -G Ninja -DCMAKE_C_COMPILER=<desired Clang binary \\ path> -C ../cmake/caches/O3.cmake ../\n```", "```cpp\n$ ninja all\n```", "```cpp\n; RUN: opt < %s -instcombine -S -o - | FileCheck %s\ntarget triple = \"x86_64-unknown-linux\"\ndefine i32 @foo(i32 %c) {\nentry:\n  ; CHECK: [[RET:%.+]] = add nsw i32 %c, 3\n  ; CHECK: ret i32 [[RET]]\n  %add1 = add nsw i32 %c, 1\n  %add2 = add nsw i32 %add1, 2\n  ret i32 %add2\n}\n```", "```cpp\nconst foo = (a, b) => {\n  let c = a + b;\n  console.log(`This is ${c}`); \n}\n```", "```cpp\nconst foo = (a,b) => {let c = a + b; console.log(`This is ${c}`);}\n```", "```cpp\n/JSMinifier\n  |__ CMakeLists.txt\n  |__ /src\n      |__ js-minifier.cpp\n  |__ /test\n      |__ test.js\n      |__ CMakeLists.txt\n  |__ /build\n```", "```cpp\n$ cd build\n$ llvm-lit -sv .\n-- Testing: 1 tests, 1 workers –\nPASS: JSMinifier Test :: test.js (1 of 1)\nTesting Time: 0.03s\n  Expected Passes    : 1\n```", "```cpp\n// RUN: %jsm %s -o - | FileCheck\n// CHECK: const foo = (a,b) =>\n// CHECK-SAME: {let c = a + b; console.log(`This is ${c}`);}\nconst foo = (a, b) => {\n  let c = a + b;\n  console.log(`This is ${c}`); \n}\n```", "```cpp\n$ pip install --user lit\n```", "```cpp\n#!/usr/bin/env python\nfrom lit.main import main\nif __name__ == '__main__':\n    main()\n```", "```cpp\n    import lit.formats\n    config.name = 'JSMinifier Test'\n    config.test_format = config variable here is a Python object that will be populated later when this script is loaded into LIT's runtime. It's basically a registry with predefined fields that carry configuration values, along with custom fields that can be added by lit.*.py scripts at any time.The `config.test_format` field suggests that LIT will run every test inside a shell environment (in the `ShTest` format), while the `config.suffixes` field suggests that only files with `.js` in their filename suffix will be treated as test cases (that is, all the JavaScript files).\n    ```", "```cpp\n    …\n    config.suffixes = ['.js']\n    config.test_source_root = os.path.dirname(__file__)\n    config.test_exec_root = os.path.join(config.test_source_root, it's simply pointing to /JSMinifier/test. On the other hand, config.test_exec_root, which is the working directory, is pointing to a place whose parent folder is the value of a custom configuration field, my_obj_root. While it will be introduced later, simply put, it points to the build folder path. In other words, config.test_exec_root will eventually have a value of /JSMinifier/build/test.\n    ```", "```cpp\n    …\n    config.test_exec_root = os.path.join(config.my_obj_root, 'test')\n    config.config.substitutions field, which makes LIT replace every %jsm occurrence in the test files with the /JSMinifier/build/js-minifier value. This wraps up all the content in lit.cfg.py.\n    ```", "```cpp\n    import os\n    config.my_src_root = r'@CMAKE_SOURCE_DIR@'\n    config.my_obj_root = r'@CMAKE_BINARY_DIR@'\n    ```", "```cpp\n    …\n    lit_config.@ being resolved and copied into the build folder. From there, it will *call back* the lit.cfg.py script we saw in the earlier steps. This will be explained later in this section.\n    ```", "```cpp\n    configure_file function will replace all the @-clamped string occurrences in the input file (lit.site.cfg.py.in, in this case) with their CMake variable counterparts in the current CMake context. For example, let's say there is a file called `demo.txt.in` that contains the following content:\n\n    ```", "```cpp\n\n    Now, let's use `configure_file` in `CMakeLists.txt`:\n\n    ```", "```cpp\n\n    Here, the aforementioned replacement will kick in and generate an output file, `demo.txt`, that contains the following content:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    import os\n    config.my_src_root = r'/absolute/path/to/JSMinifier'\n    config.my_obj_root = r'/absolute/path/to/JSMinifier/build'\n    lit_config.load_config(\n        config, os.path.join(config.my_src_root, 'test/      lit.cfg.py'))\n    ```", "```cpp\n$ ninja check-llvm-support\n```", "```cpp\nconst onLoginPOST = (req, resp) => {\n  if(req.name == 'admin')\n    resp.send('OK');\n  else\n    resp.sendError(403);\n}\nmyReset.post('/console', onLoginPOST);\n```", "```cpp\nconst t = \"nikfmnsdzaO\";\nconst aaa = (a, b) => {\n  if(a.z[0] == t[9] && a.z[1] == t[7] &&…)\n    b.f0(t[10] + t[2].toUpperCase());\n  else\n    b.f1(0x193);\n}\nG.f4(YYY, aaa);\n```", "```cpp\nconst square = x => x * x;\nconst cube = x => x * x * x;\nconst my_func1 = (input1, input2, input3) => {\n  // TODO: Check if the arrow and curly brace are in the second   // line\n  // TODO: Check if local variable and parameter names are   // obfuscated\n  let intermediate = square(input3);\n  let output = input1 + intermediate - input2;\n  return output;\n}\nconst my_func2 = (factor1, factor2) => {\n  // TODO: Check if local variable and parameter names are   // obfuscated\n  let term2 = cube(factor1);\n  // TODO: Check if literal numbers are obfuscated\n  return my_func1(94,\n                  term2, factor2);\n}\nconsole.log(my_func2(1,2));\n```", "```cpp\n    // CHECK: my_func1 = ({{[a-z]+0}}, {{[a-z]+1}}, // {{[a-z]+2}})\n    const my_func1 = (input1, input2, input3) => {\n    …\n    ```", "```cpp\n    // CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])\n    const my_func1 = (input1, input2, input3) => {\n      // CHECK: square(A0 ~ A2 using the [[…]] syntax, in which the binding variable name and the pattern are divided by a colon: [[<binding variable>:<pattern>]]. On the reference sites of the binding variable, the same [[…]] syntax is used, but without the pattern part.NoteA binding variable can have multiple definition sites. Its reference sites will read the last defined value. \n    ```", "```cpp\n    // CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])\n    const my_func1 = (input1, input2, input3) => {\n      // CHECK directive, CHECK-NEXT will not only check if the pattern exists but also ensure that the pattern is in the line that follows the line matched by the previous directive.\n    ```", "```cpp\n    // CHECK: my_func1 = ([[A0:[a-z]+0]], // [[A1:[a-z]+1]], [[A2:[a-z]+2]])\n    const my_func1 = (input1, input2, input3) => {\n      // CHECK: let [[IM:[a-zA-Z]+]] = square([[A2]]);\n      let intermediate = square(input3);\n      // CHECK: let [[OUT:[a-zA-Z]+]] =\n      // CHECK-SAME directive was used to match the succeeding pattern in the exact same line. The rationale behind this is that FileCheck expected different CHECK directives to be matched in different *lines*. So, let's say part of the snippet was written like this:\n\n    ```", "```cpp\n\n    It will *only* match code that spread across two lines or more, as shown here:\n\n    ```", "```cpp\n\n    It will throw an error otherwise. This directive is especially useful if you wish to avoid writing a super long line of checking statements, thus making the testing scripts more concise and readable.\n    ```", "```cpp\n    …\n    // CHECK: return my_func1(\n    // CHECK-NOT: 94 \n    return my_func1(94,\n                    term2, factor2);\n    …\n    // CHECK: return my_func1\n    // CHECK-NOT: 94,\n    // CHECK-SAME: {{0x5[eE]}}\n    return my_func1(94,\n                    term2, factor2);\n    ```", "```cpp\n    // CHECK-DAG: 123\n    // CHECK-DAG: 456\n    ```", "```cpp\n    123\n    456\n    ```", "```cpp\n    456\n    123\n    ```", "```cpp\n    // CHECK-DAG: 123\n    // CHECK-DAG: 456\n    // CHECK: 789\n    // CHECK-DAG: abc\n    // CHECK-DAG: def\n    ```", "```cpp\n    456\n    123\n    789\n    def\n    abc\n    ```", "```cpp\n    456\n    789\n    123\n    def\n    abc\n    ```", "```cpp\n    …\n    // FileCheck provides a way to multiplex different *check suites* into a single file, where each suite can define how it runs and separates the checks from other suites. \n    ```", "```cpp\n    // --check-prefix command-line option. Here, the FileCheck command invocation will look like this:\n\n    ```", "```cpp\n\n    ```", "```cpp\n    …\n    // CHECK-SHUFFLE-DAG: const square =\n    // CHECK-SHUFFLE-DAG: const cube =\n    // CHECK-SHUFFLE-DAG: const my_func1 =\n    // CHECK-SHUFFLE-DAG: const my_func2 =\n    // CHECK-SHUFFLE: console.log\n    console.log(my_func2(1,2));\n    ```", "```cpp\n# Running the default check suite\n$ js-obfuscator test.js | FileCheck test.js\n# Running check suite for the function shuffling option\n$ js-obfuscator --shuffle-funcs test.js | \\\n  FileCheck --check-prefix=CHECK-SHUFFLE test.js\n```", "```cpp\nGeoDistance\n  |___ helper.cpp\n  |___ main.cpp\n  |___ sample_input.txt\n  |___ Makefile\n```", "```cpp\nFLAGS := -DSMALL_INPUT -ffast-math\nEXE := geo-distance\nOBJS := helper.o main.o\n%.o: %.cpp\n    $(CXX) $(FLAGS) -c $^\n$(EXE): $(OBJS)\n    $(CXX) $(FLAGS) $< -o $@\n```", "```cpp\n$ geo-distance ./sample_input.txt\n```", "```cpp\n$ geo-distance ./sample_input.txt\n94.873467\n```", "```cpp\n# Inside MultiSource/Applications/CMakeLists.txt\n…\nadd_subdirectory(GeoDistance)\n```", "```cpp\n# Inside MultiSource/Applications/GeoDistance/CMakeLists.txt\n# (Unfinished)\nllvm_multisource(geo-distance)\nllvm_test_data(geo-distance sample_input.txt)\n```", "```cpp\n# Inside MultiSource/Applications/GeoDistance/CMakeLists.txt\n# (Continue)\nlist(APPEND CPPFLAGS -DSMALL_INPUT)\nlist(APPEND CFLAGS -ffast-math)\nllvm_multisource(geo-distance)\nllvm_test_data(geo-distance sample_input.txt)\n```", "```cpp\n# Inside MultiSource/Applications/GeoDistance/CMakeLists.txt\n# (Continue)\n…\nset(RUN_OPTIONS sample_input.txt)\nset(FP_TOLERANCE 0.001)\nllvm_multisource(geo-distance)\n…\n```", "```cpp\n94.873\nexit 0\n```"]