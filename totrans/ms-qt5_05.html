<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5.      Dominating the Mobile UI     </h1></div></div></div><p>In <a class="link" title="Chapter 3.  Dividing Your Project and Ruling Your Code" href="part0034.xhtml#aid-10DJ42">Chapter 3</a>, <em>Dividing Your Project and Ruling Your Code</em>, we created a strong core library to handle a picture gallery. We will now use this <code class="literal">gallery-core</code> library to create a mobile application.</p><p>We will teach you how to create a Qt Quick project from scratch. You will create custom Qt Quick views with QML. This chapter will also cover how your QML views can communicate with the C++ library.</p><p>At the end of this chapter, your gallery application will run on your mobile (Android or iOS) with a dedicated GUI compliant with touch devices. This application will offer the same features as the desktop application.</p><p>This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Creating a Qt Quick project</li><li class="listitem">QML</li><li class="listitem">Qt Quick controls</li><li class="listitem">Qt for mobile (Android and iOS)</li><li class="listitem">Calling C++ functions from QML</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Starting with Qt Quick and QML</h1></div></div></div><p>Qt Quick is another way of creating applications with Qt. You can use it to create a complete application in place of Qt Widgets. The Qt Quick module provides transitions, animations, and visual effects. You can also customize graphical effects with shaders. This module is especially efficient at making software for devices using touchscreens. Qt Quick uses a dedicated language: Qt Modeling Language (QML). It is a declarative language; the syntax is close to the JSON (JavaScript Object Notation) syntax. Furthermore, QML also supports JavaScript expressions inline or in a separate file.</p><p>Let's begin with a simple example of a Qt Quick application using QML. Create a new file called <code class="literal">main.qml</code> with this code snippet:</p><pre class="programlisting">import QtQuick 2.5 
import QtQuick.Window 2.2 
 
Window { 
    visible: true 
    width: 640; height: 480 
 
    // A nice red rectangle 
    Rectangle { 
        width: 200; height: 200 
        color: "red" 
    } 
} 
</pre><p>Qt 5 provides a nice tool called <code class="literal">qmlscene</code> to prototype a QML user interface. You can find the binary file in your Qt installation folder, for example: <code class="literal">Qt/5.7/gcc_64/bin/qmlscene</code>. To load your <code class="literal">main.qml</code> file, you can run the tool and select the file, or use the CLI with the <code class="literal">.qml</code> file in an argument: <code class="literal">qmlscene main.qml</code>. You should see something like this:</p><div><img src="img/image00380.jpeg" alt="Starting with Qt Quick and QML"/></div><p style="clear:both; height: 1em;"> </p><p>To use a Qt Quick module, you need to import it. The syntax is easy:</p><pre class="programlisting">import &lt;moduleName&gt; &lt;moduleVersion&gt; 
</pre><p>In this example we import <code class="literal">QtQuick</code>, which is the common module that will provide basic components (<code class="literal">Rectangle</code>, <code class="literal">Image</code>, <code class="literal">Text</code>) and we also import the <code class="literal">QtQuick.Window</code> module that will provide the main window application (<code class="literal">Window</code>).</p><p>A QML component can have properties. For example, we set the <code class="literal">width</code> property of the <code class="literal">Window</code> class to the value <code class="literal">640</code>. Here is the generic syntax:</p><pre class="programlisting">&lt;ObjectType&gt; { 
    &lt;PropertyName&gt;: &lt;PropertyValue&gt; 
} 
</pre><p>We can now update <code class="literal">main.qml</code> file with some new rectangles:</p><pre class="programlisting">import QtQuick 2.5 
import QtQuick.Window 2.2 
 
Window { 
    visible: true 
    width: 640; height: 480 
 
    Rectangle { 
        width: 200; height: 200 
        color: "red" 
    } 
 
    Rectangle { 
        width: 200; height: 200 
        color: "green" 
        x: 100; y: 100 
 
        Rectangle { 
            width: 50; height: 50 
            color: "blue" 
            x: 100; y: 100 
        } 
    } 
} 
</pre><p>Here is the visual result:</p><div><img src="img/image00381.jpeg" alt="Starting with Qt Quick and QML"/></div><p style="clear:both; height: 1em;"> </p><p>Your QML file describes the UI as a hierarchy of components. The hierarchy below the <code class="literal">Window</code> element is the following:</p><div><ul class="itemizedlist"><li class="listitem">Red <code class="literal">Rectangle</code></li><li class="listitem">Green <code class="literal">Rectangle</code></li><li class="listitem">Blue <code class="literal">Rectangle</code></li></ul></div><p>Each nested item will always have its <code class="literal">x</code>, <code class="literal">y</code> coordinates relative to its parent.</p><p>To structure your application, you can build reusable QML components. You can easily create a new component. All QML components must have a single root item. Let's build a new <code class="literal">MyToolbar</code> component by creating a new file called <code class="literal">MyToolbar.qml</code>:</p><pre class="programlisting">import QtQuick 2.5 
 
import QtQuick 2.5 
 
Rectangle { 
    color: "gray" 
    height: 50 
 
    Rectangle { 
        id: purpleRectangle 
        width: 50; height: parent.height 
        color: "purple" 
        radius: 10 
    } 
 
    Text { 
        anchors.left: purpleRectangle.right 
        anchors.right: parent.right 
        text: "Dominate the Mobile UI" 
        font.pointSize: 30 
    } 
} 
</pre><p>The gray <code class="literal">Rectangle</code> element will be our root item used as background. We also created two items:</p><div><ul class="itemizedlist"><li class="listitem">A purple <code class="literal">Rectangle</code> element that can be identified with the ID <code class="literal">purpleRectangle</code>. The height of this item will be the height of its parent, that is, the gray <code class="literal">Rectangle</code> element.</li><li class="listitem">A <code class="literal">Text</code> item. In this case, we use anchors. It will help us to layout items without using hardcoded coordinates. The left of the <code class="literal">Text</code> item will be aligned with the right of <code class="literal">purpleRectangle</code>, and the right of the <code class="literal">Text</code> item will be aligned with the right of the parent (the gray <code class="literal">Rectangle</code> element).</li></ul></div><div><h3 class="title"><a id="note27"/>Note</h3><p>Qt Quick provides a lot of anchors: <code class="literal">left</code>, <code class="literal">horizontalCenter</code>, <code class="literal">right</code>, <code class="literal">top</code>, <code class="literal">verticalCenter</code>, and <code class="literal">bottom</code>. You can also use convenience anchors such as <code class="literal">fill</code> or <code class="literal">centerIn</code>. For more information on anchors, take a look at <a class="ulink" href="http://doc.qt.io/qt-5/qtquick-positioning-anchors.html">http://doc.qt.io/qt-5/qtquick-positioning-anchors.html</a>.</p></div><p>You can use <code class="literal">MyToolbar</code> in your window by updating your <code class="literal">main.qml</code>:</p><pre class="programlisting">Window { 
    ... 
    MyToolbar { 
        width: parent.width 
    } 
} 
</pre><p>We set the width to the parent width. Like this, the toolbar fills the window's width. Here is the result:</p><div><img src="img/image00382.jpeg" alt="Starting with Qt Quick and QML"/></div><p style="clear:both; height: 1em;"> </p><p>Anchors are great to align specific items, but if you want to layout several items in grid, row, or column fashion, you can use the <code class="literal">QtQuick.layouts</code> module. Here is an example of the updated <code class="literal">main.qml</code>:</p><pre class="programlisting">import QtQuick 2.5 
import QtQuick.Window 2.2 
import QtQuick.Layouts 1.3 
 
Window { 
    visible: true 
    width: 640; height: 480 
 
    MyToolbar { 
        id: myToolbar 
        width: parent.width 
    } 
 
    RowLayout { 
        anchors.top: myToolbar.bottom 
        anchors.left: parent.left 
        anchors.right: parent.right 
        anchors.bottom: parent.bottom 
 
        Rectangle { width: 200; height: 200; color: "red" } 
        Rectangle { width: 200; height: 200 color: "green" } 
        Rectangle { width: 50; height: 50; color: "blue" } 
    } 
} 
</pre><p>You should get something like this:</p><div><img src="img/image00383.jpeg" alt="Starting with Qt Quick and QML"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, we use a <code class="literal">RowLayout</code> element that fits under the <code class="literal">myToolbar</code> and to its parent, a <code class="literal">Window</code> element. This item provides a way to dynamically layout items in a row. Qt Quick also provides other layout items: <code class="literal">GridLayout</code> and <code class="literal">ColumnLayout</code>.</p><p>Your custom component can also expose custom properties that can be modified outside of the component itself. You can do it by adding the <code class="literal">property</code> attribute. Please update <code class="literal">MyToolbar.qml</code>:</p><pre class="programlisting">import QtQuick 2.5 
 
Rectangle { 
 
    property color iconColor: "purple" 
    property alias title: label.text 
 
    color: "gray" 
    height: 50 
 
    Rectangle { 
        id: purpleRectangle 
        width: 50; height: parent.height 
        color: iconColor 
        radius: 10 
    } 
 
    Text { 
        id: label 
        anchors.left: purpleRectangle.right 
        anchors.right: parent.right 
        text: "Dominate the Mobile UI" 
        font.pointSize: 30 
    } 
} 
</pre><p>The <code class="literal">iconColor</code> is a really new property that is a fully-fledged variable. We also update the <code class="literal">Rectangle</code> attribute to use this property as <code class="literal">color</code>. The <code class="literal">title</code> property is only an <code class="literal">alias</code>, you can see it as a pointer to update the <code class="literal">label.text</code> property.</p><p>From outside you can use these attributes with the same syntax; please update the <code class="literal">main.qml</code> file with the following snippet:</p><pre class="programlisting">import QtQuick 2.5 
import QtQuick.Window 2.2 
import QtQuick.Layouts 1.3 
 
Window { 
    visible: true 
    width: 640; height: 480 
 
    MyToolbar { 
        id: myToolbar 
        width: parent.width 
 
        title: "Dominate Qt Quick" 
        iconColor: "yellow" 
    } 
   ... 
} 
</pre><p>You should get a nice updated toolbar like this one:</p><div><img src="img/image00384.jpeg" alt="Starting with Qt Quick and QML"/></div><p style="clear:both; height: 1em;"> </p><p>We have covered the basics of QML, now we are going to proceed to mobile application development using QML.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Checking your development environment</h1></div></div></div><p>To be able to create a Qt application for Android, you must have:</p><div><ul class="itemizedlist"><li class="listitem">A device with Android v2.3.3 (API 10) or later</li><li class="listitem">Android SDK</li><li class="listitem">Android NDK</li><li class="listitem">JDK</li><li class="listitem">Qt Prebuilt Components for Android x86 (from the Qt Maintenance Tool)</li><li class="listitem">Qt Prebuilt Components for Android ARMv7 (from the Qt Maintenance Tool)</li></ul></div><p>To be able to create a Qt application for iOS, you must have:</p><div><ul class="itemizedlist"><li class="listitem">A device with iOS 5.0 or later</li><li class="listitem">A Mac desktop computer</li><li class="listitem">Xcode</li><li class="listitem">Qt for iOS (from Qt Maintenance Tool)</li></ul></div><p>When starting, Qt Creator will detect and create Android and iOS Qt kits. You can check your existing kits from <strong>Tools</strong> | <strong>Options</strong> | <strong>Build &amp; Run</strong> | <strong>Kits</strong>, as shown in the following screenshot:</p><div><img src="img/image00385.jpeg" alt="Checking your development environment"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Creating a Qt Quick project</h1></div></div></div><p>This chapter will follow the same project structure we covered in <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>: a parent project <code class="literal">ch05-gallery-mobile.pro</code> will host our two subprojects, <code class="literal">gallery-core</code> and the new <code class="literal">gallery-mobile</code>.</p><p>In Qt creator, you can create a Qt Quick subproject from <strong>File</strong> | <strong>New File or Project</strong> | <strong>Application</strong> | <strong>Qt Quick Controls Application</strong> | <strong>Choose</strong>.</p><p>The wizard will allow you to customize your project creation:</p><div><ul class="itemizedlist"><li class="listitem">Location<div><ul class="itemizedlist"><li class="listitem">Choose a project name (<code class="literal">gallery-mobile</code>) and a location</li></ul></div></li><li class="listitem">Details<div><ul class="itemizedlist"><li class="listitem">Deselect <strong>With ui.qml file</strong></li><li class="listitem">Deselect <strong>Enable native styling</strong></li></ul></div></li><li class="listitem">Kits<div><ul class="itemizedlist"><li class="listitem">Select your desktop kit</li><li class="listitem">Select at least one mobile kit</li></ul></div></li><li class="listitem">Summary<div><ul class="itemizedlist"><li class="listitem">Be sure to add gallery-mobile as a subproject of <code class="literal">ch05-gallery-mobile.pro</code></li></ul></div></li></ul></div><p>Let's take some time to explain why we created our project with these options.</p><p>The first thing to analyze is the application template. By default, Qt Quick only provides basic QML components (<code class="literal">Rectangle</code>, <code class="literal">Image</code>, <code class="literal">Text</code>, and so on). Advanced components will be handled by Qt Quick modules. For this project we will use Qt Quick Controls (<code class="literal">ApplicationWindow</code>, <code class="literal">Button</code>, <code class="literal">TextField</code>, and so on). That is why we chose to begin with a <strong>Qt Quick Controls application</strong>. Keep in mind that you can always import and use Qt Quick modules later.</p><p>In this chapter, we will not use the Qt Quick Designer. As a consequence, <code class="literal">.ui.qml</code> files are not required. Even if the designer can help a lot, it is good to understand and write QML files yourself.</p><p>The desktop "native styling" is disabled because this project mainly targets mobile platforms. Moreover, disabling "native styling" avoids heavy dependency on the Qt widgets module.</p><p>Finally, we select at least two kits. The first one is our desktop kit. The other kits are the mobile platforms you target. We usually use the following development workflow:</p><div><ul class="itemizedlist"><li class="listitem">Fast iterations on desktop</li><li class="listitem">Check and fix behavior on mobile emulator/simulator</li><li class="listitem">Real test on the mobile device</li></ul></div><p>Deployment on a real device is generally longer so you can do most development with the desktop kit. The mobile kits will allow you to check your application behavior on a real mobile device or on an emulator (for example with a Qt Android x86 kit).</p><p>Let's talk about the files automatically generated by the wizard. Here is the <code class="literal">main.cpp</code> file:</p><pre class="programlisting">#include &lt;QGuiApplication&gt; 
#include &lt;QQmlApplicationEngine&gt; 
 
int main(int argc, char *argv[]) 
{ 
    QGuiApplication app(argc, argv); 
 
    QQmlApplicationEngine engine; 
    engine.load(QUrl(QStringLiteral("qrc:/main.qml"))); 
 
    return app.exec(); 
} 
</pre><p>We use here <code class="literal">QGuiApplication</code> and not <code class="literal">QApplication</code> because we do not use Qt widgets in this project. Then, we create the QML engine and load <code class="literal">qrc:/mail.qml</code>. As you may have guessed (with the <code class="literal">qrc:/</code> prefix), this QML file is in a Qt resource file.</p><p>You can open the <code class="literal">qml.qrc</code> file to find the <code class="literal">main.qml</code>:</p><pre class="programlisting">import QtQuick 2.5 
import QtQuick.Controls 1.4 
 
ApplicationWindow { 
    visible: true 
    width: 640 
    height: 480 
    title: qsTr("Hello World") 
 
    menuBar: MenuBar { 
        Menu { 
            title: qsTr("File") 
            MenuItem { 
                text: qsTr("&amp;Open") 
                onTriggered: console.log("Open action triggered"); 
            } 
            MenuItem { 
                text: qsTr("Exit") 
                onTriggered: Qt.quit(); 
            } 
        } 
    } 
 
    Label { 
        text: qsTr("Hello World") 
        anchors.centerIn: parent 
    } 
} 
</pre><p>The first thing to do is to import types used in the file. Notice the module version at the end of each import. The <code class="literal">QtQuick</code> module will import basic QML elements (<code class="literal">Rectangle</code>, <code class="literal">Image</code>, and so on) while the <code class="literal">QtQuick.Controls</code> module will import advanced QML elements from the <code class="literal">QtQuick Controls</code> submodule (<code class="literal">ApplicationWindow</code>, <code class="literal">MenuBar</code>, <code class="literal">MenuItem</code>, <code class="literal">Label</code>, and so on).</p><p>Then, we define the root element of type <code class="literal">ApplicationWindow</code>. It provides a top-level application window with the following items: <code class="literal">MenuBar</code>, <code class="literal">ToolBar</code> and <code class="literal">StatusBar</code>. The properties <code class="literal">visible</code>, <code class="literal">width</code>, <code class="literal">height</code>, and <code class="literal">title</code> of <code class="literal">ApplicationWindow</code> are primitive types. The syntax is simple and intelligible.</p><p>The <code class="literal">menuBar</code> property is more complex. This <code class="literal">MenuBar</code> property is composed of a <code class="literal">Menu</code> file, itself composed of two <code class="literal">MenuItems</code>: <code class="literal">Open</code> and <code class="literal">Exit</code>. A <code class="literal">MenuItem</code> emits a <code class="literal">triggered()</code>signal each time it is activated. In this case, the <code class="literal">MenuItem</code> file will log a message on the console. The exit <code class="literal">MenuItem</code> terminates the application.</p><p>Finally, a <code class="literal">Label</code> displaying "Hello World" is added in the content area of our <code class="literal">ApplicationWindow</code> type. Positioning items with anchors is useful. In our case the label is centered vertically and horizontally in its parent, <code class="literal">ApplicationWindow</code>.</p><p>Before going ahead, check that this sample runs correctly on your desktop and on your mobile.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Preparing your Qt Quick gallery entry point</h1></div></div></div><p>First of all, you need to link this project to our <code class="literal">gallery-core</code> library. We already covered how to link an internal library in <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>. For more details, refer to it. This is the updated <code class="literal">gallery-mobile.pro</code> file:</p><pre class="programlisting">TEMPLATE = app 
 
QT += qml quick sql svg 
 
CONFIG += c++11 
 
SOURCES += main.cpp 
 
RESOURCES += gallery.qrc 
 
LIBS += -L$$OUT_PWD/../gallery-core/ -lgallery-core 
INCLUDEPATH += $$PWD/../gallery-core 
DEPENDPATH += $$PWD/../gallery-core 
 
contains(ANDROID_TARGET_ARCH,x86) { 
    ANDROID_EXTRA_LIBS = \ 
        $$[QT_INSTALL_LIBS]/libQt5Sql.so 
} 
</pre><p>Please notice that we made several changes here:</p><div><ul class="itemizedlist"><li class="listitem">We added the <code class="literal">sql</code> module to deploy the dependency on your mobile device</li><li class="listitem">We added the <code class="literal">svg</code> module for the button icons</li><li class="listitem">The <code class="literal">qml.qrc</code> file has been renamed in <code class="literal">gallery.qrc</code></li><li class="listitem">We linked the <code class="literal">gallery-core</code> library</li><li class="listitem">By default, the <code class="literal">sql</code> shared object (<code class="literal">libQt5Sql.so</code>) will not be deployed on your Android x86 device. You have to explicitly include it in your <code class="literal">.pro</code> file.</li></ul></div><p>You can now use classes from the <code class="literal">gallery-core</code> library in our <code class="literal">gallery-mobile</code> application. Let's see how to bind C++ models with QML. This is the updated <code class="literal">main.cpp</code>:</p><pre class="programlisting">#include &lt;QGuiApplication&gt; 
#include &lt;QQmlApplicationEngine&gt; 
#include &lt;QQmlContext&gt; 
#include &lt;QQuickView&gt; 
 
#include "AlbumModel.h" 
#include "PictureModel.h" 
 
int main(int argc, char *argv[]) 
{ 
    QGuiApplication app(argc, argv); 
 
    AlbumModel albumModel; 
    PictureModel pictureModel(albumModel); 
 
    QQmlApplicationEngine engine; 
 
    QQmlContext* context = engine.rootContext(); 
    context-&gt;setContextProperty("albumModel", &amp;albumModel); 
    context-&gt;setContextProperty("pictureModel", &amp;pictureModel); 
 
    engine.load(QUrl(QStringLiteral("qrc:/qml/main.qml"))); 
 
    return app.exec(); 
} 
</pre><p>Our models will be instantiated in C++ and exposed to QML using the root <code class="literal">QQmlContext</code> object. The <code class="literal">setContextProperty()</code> function allows us to bind a C++ <code class="literal">QObject</code> to a QML property. The first argument will be the QML property name. We are only binding a C++ object to a QML property; the context object does not take ownership of this object.</p><p>Let's now talk about the mobile application itself. We will define three pages with specific roles:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">AlbumListPage</code><div><ul class="itemizedlist"><li class="listitem">Displays existing albums</li><li class="listitem">Album creation</li><li class="listitem">Album selection</li></ul></div></li><li class="listitem"><code class="literal">AlbumPage</code><div><ul class="itemizedlist"><li class="listitem">Displays existing pictures as thumbnails</li><li class="listitem">Adds pictures in album</li><li class="listitem">Album rename</li><li class="listitem">Album deletion</li><li class="listitem">Picture selection</li></ul></div></li><li class="listitem"><code class="literal">PicturePage</code><div><ul class="itemizedlist"><li class="listitem">Displays selected picture</li><li class="listitem">Picture selection</li><li class="listitem">Picture deletion</li></ul></div></li></ul></div><p>To handle the navigation, we will use a <code class="literal">StackView</code> component from Qt Quick Controls. This QML component implements a stack-based navigation. You can push a page when you want to display it. When the user requests to go back, you can pop it. Here is the workflow using a <code class="literal">StackView</code> component for our gallery mobile application. The page with the solid border is the page currently displayed on screen:</p><div><img src="img/image00386.jpeg" alt="Preparing your Qt Quick gallery entry point"/></div><p style="clear:both; height: 1em;"> </p><p>This is the implementation of <code class="literal">main.qml</code>:</p><pre class="programlisting">import QtQuick 2.6 
import QtQuick.Controls 2.0 
 
ApplicationWindow { 
 
    readonly property alias pageStack: stackView 
 
    id: app 
    visible: true 
    width: 768 
    height: 1280 
 
    StackView { 
        id: stackView 
        anchors.fill: parent 
        initialItem: AlbumListPage {} 
    } 
 
    onClosing: { 
        if (Qt.platform.os == "android") { 
            if (stackView.depth &gt; 1) { 
                close.accepted = false 
                stackView.pop() 
            } 
        } 
    } 
} 
</pre><p>This main file is really simple. The application is constructed around the <code class="literal">StackView</code> component. We set the <code class="literal">id</code> property to allow our <code class="literal">StackView</code> to be identified and referred to by other QML objects. The <code class="literal">anchors</code> property will set <code class="literal">stackView</code> to fill its parent, the <code class="literal">ApplicationWindow</code> type. Finally, we set the <code class="literal">initialItem</code> property to a page, <code class="literal">AlbumListPage</code> that will be implemented soon.</p><p>On Android, <code class="literal">onClosing</code> will be executed each time the user presses the back button. To mimic a native Android application, we will first pop the last stacked page before really closing the application.</p><p>At the top of the file, we define a <code class="literal">property alias</code> for the <code class="literal">stackView</code>. A <code class="literal">property alias</code> is a simple reference to another existing property. This alias will be useful to access <code class="literal">stackView</code> from other QML components. To prevent a QML component to crush the <code class="literal">stackView</code> we are using the <code class="literal">readonly</code> keyword. After initialization, the components can access the property but not change its value.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Displaying albums with ListView</h1></div></div></div><p>Let's make our first page for this mobile application! Create a file in <code class="literal">gallery.qrc </code>called <code class="literal">AlbumListPage.qml</code>. Here is the page header implementation:</p><pre class="programlisting">import QtQuick 2.0 
import QtQuick.Layouts 1.3 
 
import QtQuick.Controls 2.0 
 
Page { 
 
    header: ToolBar { 
        Label { 
            Layout.fillWidth: true 
            text: "Albums" 
            font.pointSize: 30 
        } 
    } 
... 
} 
</pre><p>A <code class="literal">Page</code> is a container control with a header and footer. In this application, we will only use the header item. We assign a <code class="literal">ToolBar</code> to the <code class="literal">header</code> property. The height of this toolbar will be handled by Qt and will be adjusted depending on the target platform. In this first simple implementation, we only put a <code class="literal">Label</code> displaying the text "Albums".</p><p>Add a <code class="literal">ListView</code> element to this page after the <code class="literal">header</code> initialization:</p><pre class="programlisting">ListView { 
    id: albumList 
    model: albumModel 
    spacing: 5 
    anchors.fill: parent 
 
    delegate: Rectangle { 
        width: parent.width 
        height: 120 
        color: "#d0d1d2" 
 
        Text { 
            text: name 
            font.pointSize: 16 
            color: "#000000" 
            anchors.verticalCenter: parent.verticalCenter 
        } 
    } 
} 
</pre><p>The Qt Quick <code class="literal">ListView</code> is the Qt Widget <code class="literal">QListView</code> equivalent. It displays a list of items from a provided model. We set the <code class="literal">model</code> property to value <code class="literal">albumModel</code>. This refers to the C++ model from <code class="literal">main.cpp</code> file accessible from QML because we used the <code class="literal">setContextProperty()</code> function. In Qt Quick, you must provide a delegate to describe how a row will be displayed. In this case, a row will only display the album's name with a <code class="literal">Text</code> item. Accessing the album's name in QML is easy because our <code class="literal">AlbumModel</code> model exposes its role list to QML. Let's refresh your memory concerning the overridden <code class="literal">roleNames()</code> function of <code class="literal">AlbumModel</code>:</p><pre class="programlisting">QHash&lt;int, QByteArray&gt; AlbumModel::roleNames() const 
{ 
    QHash&lt;int, QByteArray&gt; roles; 
    roles[Roles::IdRole] = "id"; 
    roles[Roles::NameRole] = "name"; 
    return roles; 
} 
</pre><p>So each time your delegate from Qt Quick uses the <code class="literal">name</code> role, it will call the <code class="literal">AlbumModel</code> function <code class="literal">data()</code> with the correct role integer and return the correct album name string.</p><p>To handle the mouse, click on a row and add a <code class="literal">MouseArea</code> element on the delegate:</p><pre class="programlisting">ListView { 
    ... 
    delegate: Rectangle { 
        ... 
        MouseArea { 
            anchors.fill: parent 
            onClicked: { 
                albumList.currentIndex = index 
                pictureModel.setAlbumId(id) 
                pageStack.push("qrc:/qml/AlbumPage.qml", 
                       { albumName: name, albumRowIndex: index }) 
            } 
        } 
    } 
} 
</pre><p>The <code class="literal">MouseArea</code> is an invisible item that can be used with any visible item to handle mouse events. This also applies to a simple touch on a phone touch screen. Here we tell the <code class="literal">MouseArea</code> element to take the full area of the parent <code class="literal">Rectangle</code>.</p><p>In our case, we only perform tasks on the <code class="literal">clicked</code> signal. We update the <code class="literal">currentIndex</code> of the <code class="literal">ListView</code> with <code class="literal">index</code>. This <code class="literal">index</code> is a special role containing the index of the item in the model.</p><p>When the user clicks, we will tell <code class="literal">pictureModel</code> to load the selected album with the <code class="literal">pictureModel.setAlbumId(id)</code> call. We will see soon how QML can call C++ methods.</p><p>Finally, we push <code class="literal">AlbumPage</code> on <code class="literal">pageStack</code> property. The <code class="literal">push()</code> function allows us to set a list of QML properties using a {<code class="literal">key: value</code>, ... } syntax. Each property will be copied into the pushed item. Here the <code class="literal">name</code> and the <code class="literal">index</code> will be copied in the <code class="literal">albumName</code> and <code class="literal">albumRowIndex</code> properties of <code class="literal">AlbumPage</code>. It is a simple yet powerful way to instantiate a QML page with properties arguments.</p><p>From your QML code, you can only call some specific C++ methods:</p><div><ul class="itemizedlist"><li class="listitem">Properties (using <code class="literal">Q_PROPERTY</code>)</li><li class="listitem">Public slot</li><li class="listitem">Function decorated as invokable (using <code class="literal">Q_INVOKABLE</code>)</li></ul></div><p>In this case we will decorate <code class="literal">PictureModel::setAlbumId()</code> as <code class="literal">Q_INVOKABLE</code>, please update the <code class="literal">PictureModel.h</code> file:</p><pre class="programlisting">class GALLERYCORESHARED_EXPORT PictureModel : public QAbstractListModel 
{ 
    Q_OBJECT 
public: 
   ... 
    Q_INVOKABLE void setAlbumId(int albumId); 
   ... 
}; 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Theming the application with a QML singleton</h1></div></div></div><p>Styling and theming a QML application can be done in various ways. In this chapter, we will declare a QML singleton with the theme data used by custom components. Moreover, we will also create a custom <code class="literal">Page</code> component to handle the toolbar and its default item (back button and page's title).</p><p>Please create a new <code class="literal">Style.qml</code> file:</p><pre class="programlisting">pragma Singleton 
import QtQuick 2.0 
 
QtObject { 
    property color text: "#000000" 
 
    property color windowBackground: "#eff0f1" 
    property color toolbarBackground: "#eff0f1" 
    property color pageBackground: "#fcfcfc" 
    property color buttonBackground: "#d0d1d2" 
 
    property color itemHighlight: "#3daee9" 
} 
</pre><p>We declare a <code class="literal">QtObject</code> component that will only contain our theme properties. A <code class="literal">QtObject</code> is a non-visual QML component.</p><p>Declaring a singleton type in QML requires two steps. First you need to use the <code class="literal">pragma singleton</code>, it will indicate the use of a single instance of the component. The second step is to register it. This can be done in C++ or by creating a <code class="literal">qmldir</code> file. Let's see the second step. Create a new plain-text file called <code class="literal">qmldir</code>:</p><pre class="programlisting">singleton Style 1.0 Style.qml 
</pre><p>This simple line will declare a QML <code class="literal">singleton</code> type named <code class="literal">Style</code> with the version 1.0 from the file named <code class="literal">Style.qml</code>.</p><p>It is now time to use these theme properties in custom components. Let's see a simple example. Create a new QML file called <code class="literal">ToolBarTheme.qml</code>:</p><pre class="programlisting">import QtQuick 2.0 
import QtQuick.Controls 2.0 
 
import "." 
 
ToolBar { 
     background: Rectangle { 
         color: Style.toolbarBackground 
     } 
 
} 
</pre><p>This QML object describes a customized <code class="literal">ToolBar</code>. Here, the <code class="literal">background</code> element is a simple <code class="literal">Rectangle</code> with our color. We can easily access our singleton <code class="literal">Style</code> and its theme property using <code class="literal">Style.toolbarBackground</code>.</p><div><h3 class="title"><a id="note28"/>Note</h3><p>QML Singletons require an explicit import to load the <code class="literal">qmldir</code> file. The <code class="literal">import "."</code> is a workaround for this Qt bug. For more information, please check <a class="ulink" href="https://bugreports.qt.io/browse/QTBUG-34418">https://bugreports.qt.io/browse/QTBUG-34418</a>.</p></div><p>We will now create a QML file <code class="literal">PageTheme.qml</code>, with the aim of containing all the code related to the page's toolbar and theme:</p><pre class="programlisting">import QtQuick 2.0 
 
import QtQuick.Layouts 1.3 
import Qt.labs.controls 1.0 
import QtQuick.Controls 2.0 
import "." 
 
Page { 
 
    property alias toolbarButtons: buttonsLoader.sourceComponent 
    property alias toolbarTitle: titleLabel.text 
 
    header: ToolBarTheme { 
        RowLayout { 
            anchors.fill: parent 
            ToolButton { 
                background: Image { 
                    source: "qrc:/res/icons/back.svg" 
                } 
                onClicked: { 
                    if (stackView.depth &gt; 1) { 
                        stackView.pop() 
                    } 
                } 
            } 
 
            Label { 
                id: titleLabel 
                Layout.fillWidth: true 
                color: Style.text 
                elide: Text.ElideRight 
                font.pointSize: 30 
            } 
 
            Loader { 
                Layout.alignment: Qt.AlignRight 
                id: buttonsLoader 
            } 
        } 
    } 
 
    Rectangle { 
        color: Style.pageBackground 
        anchors.fill: parent 
    } 
} 
</pre><p>This <code class="literal">PageTheme</code> element will customize the page's header. We use our previously created <code class="literal">ToolBarTheme</code>. This toolbar only contains a <code class="literal">RowLayout</code> element to display items horizontally in one row. This layout contains three elements:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ToolButton</code>: This is the "back" that displays an image from <code class="literal">gallery.qrc</code> and pops the current page if required</li><li class="listitem"><code class="literal">Label</code>: This is the element that displays the page title</li><li class="listitem"><code class="literal">Loader</code>: This is the element that allows a page to dynamically add specific items in this generic toolbar</li></ul></div><p>The <code class="literal">Loader</code> element owns a <code class="literal">sourceComponent</code> property. In this application, this property can be assigned by <code class="literal">PageTheme</code> pages to add specific buttons. These buttons will be instantiated at runtime.</p><p>The <code class="literal">PageTheme</code> pages also contain a <code class="literal">Rectangle</code> element that fits the parent and configures the page background color using the <code class="literal">Style.pageBackground</code>.</p><p>Now that our <code class="literal">Style.qml</code> and <code class="literal">PageTheme.qml</code> files are ready, we can update the <code class="literal">AlbumListPage.qml</code> file to use it:</p><pre class="programlisting">import QtQuick 2.6 
import QtQuick.Controls 2.0 
import "." 
 
PageTheme { 
 
    toolbarTitle: "Albums" 
 
    ListView { 
        id: albumList 
        model: albumModel 
        spacing: 5 
        anchors.fill: parent 
 
        delegate: Rectangle { 
            width: parent.width 
            height: 120 
            color: Style.buttonBackground 
 
            Text { 
                text: name 
                font.pointSize: 16 
                color: Style.text 
                anchors.verticalCenter: parent.verticalCenter 
            } 
            ... 
        } 
    } 
} 
</pre><p>Now that <code class="literal">AlbumListPage</code> is a <code class="literal">PageTheme</code> element, we do not manipulate <code class="literal">header</code> directly. We only need to set the property <code class="literal">toolbarTitle</code> to display a nice "Albums" text in the toolbar. We can also enjoy nice colors using properties from the <code class="literal">Style</code> singleton.</p><p>By centralizing the theme properties in a single file, you can easily change the look and feel of your application. The source code of the project also contains a dark theme.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Loading a database on mobile</h1></div></div></div><p>Before continuing the UI implementation, we have to take care of the database deployment on mobile. Spoiler: this will not be fun.</p><p>We have to jump back to <code class="literal">DatabaseManager.cpp</code> in the <code class="literal">gallery-core</code> project:</p><pre class="programlisting">DatabaseManager&amp; DatabaseManager::instance() 
{ 
    return singleton; 
} 
 
DatabaseManager::DatabaseManager(const QString&amp; path) : 
    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase("QSQLITE"))), 
    albumDao(*mDatabase), 
    pictureDao(*mDatabase) 
{ 
    mDatabase-&gt;setDatabaseName(path); 
    ... 
} 
</pre><p>Whereas on Desktop, the SQLite3 database is created at the instruction <code class="literal">mDatabase-&gt;setDatabaseName()</code>, on mobile it does not work at all. This is due to the fact that the filesystem is very specific on each mobile platform (Android and iOS). An application has only access to a narrow sandbox where it cannot mess with the rest of the filesystem. All the files inside the application directory must have specific file permissions. If we let SQLite3 create the database file, it will not have the right permission and the OS will block the database from opening.</p><p>As a consequence, the database will not be properly created and your data cannot be persisted. When using the native API, this is not a problem since the OS takes care of the proper configuration of the database. Because we are developing with Qt, we do not have easy access to this API (except by using JNI or other black magic). A workaround is to embed a "ready-to-use" database in the application's package and copy it at the right filesystem path with the correct rights.</p><p>This database should contain an empty created database without any content. The database is available in the source code of the chapter (you can also generate it from the source code of <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>). You can add it to the <code class="literal">gallery.qrc</code> file.</p><p>Because our layers are clearly defined, we just have to modify the <code class="literal">DatabaseManager::instance()</code> implementation to handle this case:</p><pre class="programlisting">DatabaseManager&amp; DatabaseManager::instance() 
{ 
#if defined(Q_OS_ANDROID) || defined(Q_OS_IOS) 
    QFile assetDbFile(":/database/" + DATABASE_FILENAME); 
    QString destinationDbFile = QStandardPaths::writableLocation( 
                            QStandardPaths::AppLocalDataLocation) 
                    .append("/" + DATABASE_FILENAME); 
 
        if (!QFile::exists(destinationDbFile)) { 
            assetDbFile.copy(destinationDbFile); 
            Qfile::setPermissions(destinationDbFile, 
                            QFile::WriteOwner | QFile::ReadOwner); 
        } 
    } 
    static DatabaseManager singleton(destinationDbFile); 
#else 
    static DatabaseManager singleton; 
#endif 
    return singleton; 
} 
</pre><p>We first retrieve the platform-specific path of the application with a nifty Qt class: <code class="literal">QStandardPaths</code>. This class return paths for multiple types (<code class="literal">AppLocalDataLocation</code>, <code class="literal">DocumentsLocation</code>, <code class="literal">PicturesLocation</code>, and so on). The database should be stored in the application data directory. If the file does not exist, we copy it from our assets.</p><p>Finally, the permissions of the file are modified to ensure that the OS does not block the opening of the database (due to permissions not being restrictive enough).</p><p>When everything is done, the <code class="literal">DatabaseManager singleton</code> is instantiated with the correct database file path and the constructor can open this database transparently.</p><div><h3 class="title"><a id="note29"/>Note</h3><p>In the iOS Simulator, the <code class="literal">QStandardPaths::writableLocation()</code> function will not return the proper path. Since iOS 8, the simulator's storage path on the host has changed and Qt does not reflect this. For more information, please check out <a class="ulink" href="https://bugreports.qt.io/browse/QTCREATORBUG-13655">https://bugreports.qt.io/browse/QTCREATORBUG-13655</a>.</p></div><p>These workarounds were not trivial. This shows the limitations of a cross-platform application on mobile. Each platform has its own very specific way of handling the filesystem and deploying its content. Even if we manage to write platform agnostic code in QML, we still have to deal with differences between the OSes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Creating a new album from a custom InputDialog</h1></div></div></div><p>The <code class="literal">AlbumListPage</code> needs some data to display. The next step is to be able to add a new album. To do this, at some point we will have to call an <code class="literal">AlbumModel</code> function from QML to add this new album. Before building the UI, we have to make a small modification in <code class="literal">gallery-core</code>.</p><p>The <code class="literal">AlbumModel</code> function is already available in QML. However, we cannot directly call <code class="literal">AlbumModel::addAlbum(const Album&amp; album)</code> from the QML code; the QML engine will not recognize the function and will throw an error <strong>TypeError: Property 'addAlbum' of object AlbumModel(...) is not a function</strong>. This can be fixed by simply decorating the desired function with the <code class="literal">Q_INVOKABLE</code> macro (as we did for <code class="literal">PictureModel::setAlbumId()</code>).</p><p>Nonetheless, there is another issue here: <code class="literal">Album</code> is a C++ class which is not recognized in QML. If we wanted to have full access to <code class="literal">Album</code> in QML, it would involve important modifications to the class:</p><div><ul class="itemizedlist"><li class="listitem">Force <code class="literal">Album</code> class to inherit from the <code class="literal">QObject</code> class.</li><li class="listitem">Add a <code class="literal">Q_PROPERTY</code> macro to specify which property of the class should be accessible from QML.</li><li class="listitem">Add multiple constructors (copy constructor, <code class="literal">QObject* parent</code>, and so on).</li><li class="listitem">Force <code class="literal">AlbumModel::addAlbum()</code> function to take an <code class="literal">Album*</code> rather than an <code class="literal">Album&amp;</code>. For complex objects (that is, not primitive types), QML can only handle pointers. This is not a big problem, but using references instead of pointers tends to make the code safer.</li></ul></div><p>These modifications are perfectly reasonable if the class is heavily manipulated in QML. Our use case is very limited: we only want to create a new album. Throughout the application, we will rely on the native Model/View API to display the album data and nothing specific to <code class="literal">Album</code> will be used.</p><p>For all these reasons, we will simply add a wrapper function in <code class="literal">AlbumModel</code>:</p><pre class="programlisting">// In AlbumModel.h 
... 
QModelIndex addAlbum(const Album&amp; album); 
Q_INVOKABLE void addAlbumFromName(const QString&amp; name); 
... 
 
// In AlbumModel.cpp 
void AlbumModel::addAlbumFromName(const QString&amp; name) 
{ 
    addAlbum(Album(name)); 
} 
</pre><p>The new function <code class="literal">addAlbumFromName()</code> just wraps the call to <code class="literal">addAlbum()</code> with the desired album <code class="literal">name</code> parameter. It can be called from the QML with the <code class="literal">Q_INVOKABLE</code> macro.</p><p>We can now switch back to the UI in the <code class="literal">gallery-mobile</code> project. We will add this album using a QML <code class="literal">Dialog</code>. QtQuick provides various default implementations of dialogs:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ColorDialog</code>: This dialog is used to choose a color</li><li class="listitem"><code class="literal">Dialog</code>: This dialog is uses the generic dialog with standard buttons (equivalent of a <code class="literal">QDialog</code>)</li><li class="listitem"><code class="literal">FileDialog</code>: This dialog is used to choose a file from the local filesystem</li><li class="listitem"><code class="literal">FontDialog</code>: This dialog is used to choose a font</li><li class="listitem"><code class="literal">MessageDialog</code>: This dialog is used to display a message</li></ul></div><p>You would have expected to see an <code class="literal">InputDialog</code> in this list (as we used the <code class="literal">QInputDialog</code> widget in <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>) but Qt Quick does not have it. Create a new <strong>QML File (Qt Quick 2)</strong> and name it <code class="literal">InputDialog.qml</code>. The content should look like so:</p><pre class="programlisting">import QtQuick 2.6 
import QtQuick.Layouts 1.3 
import Qt.labs.controls 1.0 
import QtQuick.Dialogs 1.2 
import QtQuick.Window 2.2 
import "." 
 
Dialog { 
 
    property string label: "New item" 
    property string hint: "" 
    property alias editText : editTextItem 
 
    standardButtons: StandardButton.Ok | StandardButton.Cancel 
    onVisibleChanged: { 
        editTextItem.focus = true 
        editTextItem.selectAll() 
    } 
    onButtonClicked: { 
        Qt.inputMethod.hide(); 
    } 
    Rectangle { 
 
        implicitWidth: parent.width 
        implicitHeight: 100 
 
        ColumnLayout { 
            Text { 
                id: labelItem 
                text: label 
                color: Style.text 
            } 
 
            TextInput { 
                id: editTextItem 
                inputMethodHints: Qt.ImhPreferUppercase 
                text: hint 
                color: Style.text 
            } 
        } 
    } 
} 
</pre><p>In this custom <code class="literal">InputDialog</code>, we take the generic Qt Quick <code class="literal">Dialog</code> and modify it to contain our <code class="literal">TextInput</code> item referenced by the ID <code class="literal">editTextItem</code>. We also added a <code class="literal">labelItem</code> just above <code class="literal">editTextItem</code> to describe the expected input. There are several things to note in this dialog.</p><p>First, because we want this dialog to be generic, it has to be configurable. The caller should be able to provide parameters to display its specific data. This is done with the three properties at the top of the <code class="literal">Dialog</code> element:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">label</code>: This property configures the displayed text in <code class="literal">labelItem</code>.</li><li class="listitem"><code class="literal">hint</code>: This property is the default text displayed in <code class="literal">editTextItem</code>.</li><li class="listitem"><code class="literal">editText</code>: This property references the "local" <code class="literal">editTextItem</code> element. This will let the caller retrieve the value when the dialog is closed.</li></ul></div><p>We also configure the <code class="literal">Dialog</code> element to automatically use the platform buttons to validate or cancel the dialog with <code class="literal">standardButtons: StandardButton.Ok | StandardButton.Cancel</code> syntax.</p><p>Finally, to make the dialog a bit more user-friendly, <code class="literal">editTextItem</code> has the focus when the <code class="literal">Dialog</code> element becomes visible and the text is selected. These two steps are done in the <code class="literal">onVisibleChanged()</code> callback function. When the dialog is hidden (that is, <strong>Ok</strong> or <strong>Cancel</strong> has been clicked), we hide the virtual keyboard with <code class="literal">Qt.InputMethod.hide()</code>.</p><p>The <code class="literal">InputDialog</code> is ready to be used! Open <code class="literal">AlbumListPage.qml</code> and modify it like so:</p><pre class="programlisting">PageTheme { 
 
    toolbarTitle: "Albums" 
    toolbarButtons: ToolButton { 
        background: Image { 
            source: "qrc:/res/icons/album-add.svg" 
        } 
        onClicked: { 
            newAlbumDialog.open() 
        } 
    } 
 
    InputDialog { 
        id: newAlbumDialog 
        title: "New album" 
        label: "Album name:" 
        hint: "My Album" 
 
        onAccepted: { 
            albumModel.addAlbumFromName(editText.text) 
        } 
    } 
</pre><p>We add <code class="literal">InputDialog</code> with the ID <code class="literal">newAlbumDialog</code> inside <code class="literal">PageTheme</code> element. We define all our custom properties: <code class="literal">title</code>, <code class="literal">label</code>, and <code class="literal">hint</code>. When the user clicks on the <strong>Ok</strong> button, the <code class="literal">onAccepted()</code> function is called. Here, it is a simple matter of calling the wrapper function <code class="literal">addAlbumFromName()</code> in the <code class="literal">AlbumModel</code> element with the entered text.</p><p>This <code class="literal">Dialog</code> element is not visible by default, we open it by adding a <code class="literal">ToolButton</code> in  <code class="literal">toolbarButtons</code>. This <code class="literal">ToolButton</code> will be added at the far right of the header as we specified in the <code class="literal">PageTheme.qml</code> file. To match mobile standards, we simply use a custom icon inside that button rather than text.</p><p>Here you can see that it is possible to reference images stored in the <code class="literal">.qrc</code> file with the syntax <code class="literal">qrc:/res/icons/album-add.svg</code>. We use SVG files to have scalable icons, but you are free to use your own icons for the <code class="literal">gallery-mobile</code> application.</p><p>When the user clicks on the <code class="literal">ToolButton</code>, the <code class="literal">onClicked()</code> function is called, where we open <code class="literal">newAlbumDialog</code>. On our reference device, a Nexus 5X, this is how it looks:</p><div><img src="img/image00387.jpeg" alt="Creating a new album from a custom InputDialog"/></div><p style="clear:both; height: 1em;"> </p><p>When the user clicks on the <strong>OK</strong> button, the whole Model/View pipeline starts to work. This new album is persisted, the <code class="literal">AlbumModel</code> element emits the correct signals to notify our <code class="literal">ListView</code>, <code class="literal">albumList</code>, to refresh itself. We are starting to leverage the power of our <code class="literal">gallery-core</code>, which can be used in a desktop application and a mobile application without rewriting a significant portion of the engine code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Loading images with an ImageProvider</h1></div></div></div><p>It is now time to display the thumbnails for our freshly persisted album. These thumbnails have to be loaded somehow. Because our application is targeted at mobile devices, we cannot afford to freeze the UI thread while loading thumbnails. We would either hog the CPU or be killed by the OS, neither of which are desirable destinies for <code class="literal">gallery-mobile</code>. Qt provides a very handy class to handle the image loading: <code class="literal">QQuickImageProvider</code>.</p><p>The <code class="literal">QQuickImageProvider</code> class provides an interface to load the <code class="literal">QPixmap</code> class in your QML code in an asynchronous manner. This class automatically spawns threads to load the <code class="literal">QPixmap</code> class and you simply have to implement the function <code class="literal">requestPixmap()</code>. There is more to it, <code class="literal">QQuickImageProvider</code> caches by default the requested pixmap to avoid hitting the data source too much.</p><p>Our thumbnails must be loaded from the <code class="literal">PictureModel</code> element, which gives access to the <code class="literal">fileUrl</code> of a given <code class="literal">Picture</code>. Our implementation of <code class="literal">r</code>QQuickImageProvider will have to get the <code class="literal">QPixmap</code> class for a row index in <code class="literal">PicturelModel</code>. Create a new C++ class named <code class="literal">PictureImageProvider</code>, and modify <code class="literal">PictureImageProvider.h</code> like this:</p><pre class="programlisting">#include &lt;QQuickImageProvider&gt; 
 
class PictureModel; 
 
class PictureImageProvider : public QQuickImageProvider 
{ 
public: 
 
    PictureImageProvider(PictureModel* pictureModel); 
 
    QPixmap requestPixmap(const QString&amp; id, QSize* size,  
            const QSize&amp; requestedSize) override; 
 
private: 
    PictureModel* mPictureModel; 
}; 
</pre><p>A pointer to the <code class="literal">PictureModel</code> element has to be provided in the constructor to be able to retrieve <code class="literal">fileUrl</code>. We override <code class="literal">requestPixmap()</code>, which takes an <code class="literal">id</code> parameter in its parameters list (the <code class="literal">size</code> and <code class="literal">requestedSize</code> can be safely ignored for now). This <code class="literal">id</code> parameter will be provided in the QML code when we want to load a picture. For a given <code class="literal">Image</code> in QML, the <code class="literal">PictureImageProvider</code> class will be called like so:</p><pre class="programlisting">Image { source: "image://pictures/" + index } 
</pre><p>Let's break it down:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">image</code>: This is the scheme for the URL source of the image. This tells Qt to work with an image provider to load the image.</li><li class="listitem"><code class="literal">pictures</code>: This is the identifier of the image provider. We will link the <code class="literal">PictureImageProvider</code> class and this identifier at the initialization of  <code class="literal">QmlEngine</code> in <code class="literal">main.cpp</code>.</li><li class="listitem"><code class="literal">index</code>: This is the ID of the image. Here it is the row index of the picture. This corresponds to the <code class="literal">id</code> parameter in <code class="literal">requestPixmap()</code>.</li></ul></div><p>We already know that we want to display a picture in two modes: thumbnail and full resolution. In both cases, a <code class="literal">QQuickImageProvider</code> class will be used. These two modes have a very similar behavior: they will request <code class="literal">PictureModel</code> for <code class="literal">fileUrl</code> and return the loaded <code class="literal">QPixmap</code>.</p><p>There is a pattern here. We can easily encapsulate these two modes in <code class="literal">PictureImageProvider</code>. The only thing we have to know is when the caller wants a thumbnail or a full resolution <code class="literal">QPixmap</code>. This can be easily done by making the <code class="literal">id</code> parameter more explicit.</p><p>We are going to implement the <code class="literal">requestPixmap()</code> function to be able to be called in two ways:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">images://pictures/&lt;index&gt;/full</code>: Using this syntax to retrieve the full resolution picture</li><li class="listitem"><code class="literal">images://pictures/&lt;index&gt;/thumbnail</code>: Using this syntax to retrieve the thumbnail version of the picture</li></ul></div><p>If the <code class="literal">index</code> value was <code class="literal">0</code>, these two calls would set the ID to <code class="literal">0/full</code> or <code class="literal">0/thumbnail</code> in <code class="literal">requestPixmap()</code>. Let's see the implementation in <code class="literal">PictureImageProvider.cpp</code>:</p><pre class="programlisting">#include "PictureModel.h" 
 
PictureImageProvider::PictureImageProvider(PictureModel* pictureModel) : 
    QQuickImageProvider(QQuickImageProvider::Pixmap), 
    mPictureModel(pictureModel) 
{ 
} 
 
QPixmap PictureImageProvider::requestPixmap(const QString&amp; id, QSize* /*size*/, const QSize&amp; /*requestedSize*/) 
{ 
    QStringList query = id.split('/'); 
    if (!mPictureModel || query.size() &lt; 2) { 
        return QPixmap(); 
    } 
 
    int row = query[0].toInt(); 
    QString pictureSize = query[1]; 
 
    QUrl fileUrl = mPictureModel-&gt;data(mPictureModel-&gt;index(row, 0),       PictureModel::Roles::UrlRole).toUrl(); 
    return ?? // Patience, the mystery will be soon unraveled 
} 
</pre><p>We start by calling the <code class="literal">QQuickImageProvider</code> constructor with the <code class="literal">QQuickImageProvider::Pixmap</code> parameter to configure <code class="literal">QQuickImageProvider</code> to call <code class="literal">requestPixmap()</code>. The <code class="literal">QQuickImageProvider</code> constructor supports various image types (<code class="literal">QImage</code>, <code class="literal">QPixmap</code>, <code class="literal">QSGTexture</code>, <code class="literal">QQuickImageResponse</code>) and each one has its specific <code class="literal">requestXXX()</code> function.</p><p>In the <code class="literal">requestPixmap()</code> function, we start by splitting this ID with the <code class="literal">/</code> separator. From here, we retrieve the <code class="literal">row</code> values and the desired <code class="literal">pictureSize</code>. The <code class="literal">fileUrl</code> is loaded by simply calling the <code class="literal">mPictureModel::data()</code> function with the right parameters. We used the exact same call in <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>.</p><p>Great, we know which <code class="literal">fileUrl</code> should be loaded and what the desired dimension is. However, we have one last thing to handle. Because we manipulate a row and not a database ID, we will have the same request URL for two different pictures, which are in different albums. Remember that <code class="literal">PictureModel</code> loads a list of pictures for a given <code class="literal">Album</code>.</p><p>We should picture (pun intended) the situation. For an album called <code class="literal">Holidays</code>, the request URL will be <code class="literal">images://pictures/0/thumbnail</code> to load the first picture. It will be the same URL for another album <code class="literal">Pets</code>, which will load the first picture with <code class="literal">images://pictures/0/thumbnail</code>. As we said earlier, <code class="literal">QQuickImageProvider</code> automatically generates a cache which will avoid subsequent calls to <code class="literal">requestPixmap()</code> for the same URL. Thus, we will always serve the same picture, no matter which album is selected.</p><p>This constraint forces us to disable the cache in <code class="literal">PictureImageProvider</code> and to roll out our own cache. This is an interesting thing to do; here is a possible implementation:</p><pre class="programlisting">// In PictureImageProvider.h 
 
#include &lt;QQuickImageProvider&gt; 
#include &lt;QCache&gt; 
 
... 
public: 
    static const QSize THUMBNAIL_SIZE; 
 
    QPixmap requestPixmap(const QString&amp; id, QSize* size, const QSize&amp; requestedSize) override; 
 
    QPixmap* pictureFromCache(const QString&amp; filepath, const QString&amp; pictureSize); 
 
private: 
    PictureModel* mPictureModel; 
    QCache&lt;QString, QPixmap&gt; mPicturesCache; 
}; 
 
// In PictureImageProvider.cpp 
const QString PICTURE_SIZE_FULL = "full"; 
const QString PICTURE_SIZE_THUMBNAIL = "thumbnail"; 
const QSize PictureImageProvider::THUMBNAIL_SIZE = QSize(350, 350); 
 
QPixmap PictureImageProvider::requestPixmap(const QString&amp; id, QSize* /*size*/, const QSize&amp; /*requestedSize*/) 
{ 
    ... 
    return *pictureFromCache(fileUrl.toLocalFile(), pictureSize); 
} 
 
QPixmap* PictureImageProvider::pictureFromCache(const QString&amp; filepath, const QString&amp; pictureSize) 
{ 
    QString key = QStringList{ pictureSize, filepath } 
                    .join("-"); 
 
        QPixmap* cachePicture = nullptr; 
    if (!mPicturesCache.contains(pictureSize)) { 
        QPixmap originalPicture(filepath); 
        if (pictureSize == PICTURE_SIZE_THUMBNAIL) { 
            cachePicture = new QPixmap(originalPicture 
                                  .scaled(THUMBNAIL_SIZE, 
                                          Qt::KeepAspectRatio, 
                                          Qt::SmoothTransformation)); 
        } else if (pictureSize == PICTURE_SIZE_FULL) { 
            cachePicture = new QPixmap(originalPicture); 
        } 
        mPicturesCache.insert(key, cachePicture); 
    } else { 
        cachePicture = mPicturesCache[pictureSize]; 
    } 
 
    return cachePicture; 
} 
</pre><p>This new <code class="literal">pictureFromCache()</code> function aims to store the generated <code class="literal">QPixmap</code> in <code class="literal">mPicturesCache</code> and return the proper <code class="literal">QPixmap</code>. The <code class="literal">mPicturesCache</code> class relies on a <code class="literal">QCache</code>; this class lets us store data in a key/value fashion with the possibility to assign a cost for each entry. This cost should roughly map the memory cost of the object (by default, <code class="literal">cost = 1</code>). When <code class="literal">QCache</code> is instantiated, it is initialized with a <code class="literal">maxCost</code> value (by default <code class="literal">100</code>). When the cost of the sum of all objects' exceeds the <code class="literal">maxCost</code>, <code class="literal">QCache</code> starts deleting objects to make room for the new objects, starting with the less recently accessed objects.</p><p>In the <code class="literal">pictureFromCache()</code> function, we first generate a key composed of the <code class="literal">fileUrl</code> and the <code class="literal">pictureSize</code> before trying to retrieve the <code class="literal">QPixmap</code> from the cache. If it is not present, the proper <code class="literal">QPixmap</code> (scaled to <code class="literal">THUMBNAIL_SIZE</code> macro if needed) will be generated and stored inside the cache. The <code class="literal">mPicturesCache</code> class becomes the owner of this <code class="literal">QPixmap</code>.</p><p>The last step to complete the <code class="literal">PictureImageProvider</code> class is to make it available in the QML context. This is done in <code class="literal">main.cpp</code>:</p><pre class="programlisting">#include "AlbumModel.h" 
#include "PictureModel.h" 
#include "PictureImageProvider.h" 
 
int main(int argc, char *argv[]) 
{ 
    QGuiApplication app(argc, argv); 
    ... 
 
    QQmlContext* context = engine.rootContext(); 
    context-&gt;setContextProperty("thumbnailSize", PictureImageProvider::THUMBNAIL_SIZE.width()); 
    context-&gt;setContextProperty("albumModel", &amp;albumModel); 
    context-&gt;setContextProperty("pictureModel", &amp;pictureModel); 
 
    engine.addImageProvider("pictures", new 
                            PictureImageProvider(&amp;pictureModel)); 
    ... 
} 
</pre><p>The <code class="literal">PictureImageProvider</code> class is added to the QML engine with <code class="literal">engine.addImageProvider()</code>. The first argument will be the provider identifier in QML. Note that the engine takes ownership of the passed <code class="literal">PictureImageProvider</code>. One last thing, the <code class="literal">thumbnailSize</code> parameter is also passed to <code class="literal">engine</code>, it will constrain the thumbnails to be displayed with the specified size in the QML code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Displaying thumbnails in a GridView</h1></div></div></div><p>The next step is to display these thumbnails. Create a new QML file named <code class="literal">AlbumPage.qml</code>:</p><pre class="programlisting">import QtQuick 2.6 
import QtQuick.Layouts 1.3 
import QtQuick.Controls 2.0 
import "." 
 
PageTheme { 
 
    property string albumName 
    property int albumRowIndex 
 
    toolbarTitle: albumName 
 
    GridView { 
        id: thumbnailList 
        model: pictureModel 
        anchors.fill: parent 
        anchors.leftMargin: 10 
        anchors.rightMargin: 10 
        cellWidth : thumbnailSize 
        cellHeight: thumbnailSize 
 
        delegate: Rectangle { 
            width: thumbnailList.cellWidth - 10 
            height: thumbnailList.cellHeight - 10 
            color: "transparent" 
 
            Image { 
                id: thumbnail 
                anchors.fill: parent 
                fillMode: Image.PreserveAspectFit 
                cache: false 
                source: "image://pictures/" + index + "/thumbnail" 
            } 
        } 
    } 
} 
</pre><p>This new <code class="literal">PageTheme</code> element defines two properties: <code class="literal">albumName</code> and <code class="literal">albumRowIndex</code>. The <code class="literal">albumName</code> property is used to update the title in <code class="literal">toolbarTitle</code>; <code class="literal">albumRowIndex</code> will be used to interact with <code class="literal">AlbumModel</code> in order to rename or delete the album from the current page.</p><p>To display thumbnails, we rely on a <code class="literal">GridView</code> element which will layout the thumbnails in a grid of cells. This <code class="literal">thumbnailList</code> item uses the <code class="literal">pictureModel</code> to request its data. The delegate is simply a <code class="literal">Rectangle</code> element with a single <code class="literal">Image</code> inside. This <code class="literal">Rectangle</code> element is slightly smaller than the <code class="literal">thumbnailList.cellWidth</code> or <code class="literal">thumbnailList.cellHeight</code>. The <code class="literal">GridView</code> element does not provide a <code class="literal">spacing</code> property (like <code class="literal">ListView</code>) for some room between each item. Thus, we simulate it by using a smaller area to display the content.</p><p>The <code class="literal">Image</code> item will try to take all the available space with <code class="literal">anchors.fill: parent</code> but will still keep the aspect ratio of the provided picture with <code class="literal">fillMode: Image.PreserveAspectFit</code>. You recognize the <code class="literal">source</code> attribute where the current delegate <code class="literal">index</code> is provided to retrieve the thumbnail. Finally, the <code class="literal">cache: false</code> attribute ensures that the <code class="literal">PictureImageProvider</code> class will not try to use the native cache.</p><p>To display <code class="literal">AlbumPage.qml</code>, we have to update the <code class="literal">stackView</code> (located in <code class="literal">main.qml</code>). Remember that <code class="literal">stackView</code> has been declared as a property (<code class="literal">pageStack</code>), it is thus accessible from any QML file.</p><p>The <code class="literal">AlbumPage</code> element will be displayed when the user clicks on the <code class="literal">MouseArea</code> element for a given <code class="literal">Album</code> value in <code class="literal">AlbumListPage.qml</code>.</p><p>We will now give the ability to the user to add a new picture. To do this, we will rely on a QtQuick Dialog: <code class="literal">FileDialog</code>. Here is the updated version of <code class="literal">AlbumPage.qml</code>:</p><pre class="programlisting">import QtQuick 2.6 
import QtQuick.Layouts 1.3 
import QtQuick.Controls 2.0 
import QtQuick.Dialogs 1.2 
import "." 
 
PageTheme { 
 
    property string albumName 
    property int albumRowIndex 
 
    toolbarTitle: albumName 
    toolbarButtons: RowLayout { 
        ToolButton { 
            background: Image { 
                source: "qrc:/res/icons/photo-add.svg" 
            } 
            onClicked: { 
                dialog.open() 
            } 
        } 
    } 
 
    FileDialog { 
        id: dialog 
        title: "Open file" 
        folder: shortcuts.pictures 
        onAccepted: { 
            var pictureUrl = dialog.fileUrl 
            pictureModel.addPictureFromUrl(pictureUrl) 
            dialog.close() 
        } 
    } 
 
    GridView { 
        ... 
} 
</pre><p>The <code class="literal">FileDialog</code> element is straightforward to implement. By using the <code class="literal">folder: shortcuts.pictures</code> property, QtQuick will automatically position the <code class="literal">FileDialog</code> element in the platform-specific pictures directory. Even better, on iOS it will open the native photo application where you can pick your own picture.</p><p>When the user validates his picture choice, the path is available in the <code class="literal">onAccepted()</code>function with the <code class="literal">dialog.fileUrl</code> field, which we stored in the <code class="literal">pictureUrl</code> variable. This <code class="literal">pictureUrl</code> variable is then passed to a new wrapper function of <code class="literal">PictureModel: addPictureFromUrl()</code>. The pattern used is exactly the same as we did for <code class="literal">AlbumModel::addAlbumFromName()</code>: a <code class="literal">Q_INVOKABLE</code> wrapper function around <code class="literal">PictureModel::addPicture()</code>.</p><p>The only missing parts of <code class="literal">AlbumPage</code> are the delete album and rename album features. They follow patterns we already covered. The deletion will be done using a wrapper function in <code class="literal">AlbumModel</code>, and the rename reuses the <code class="literal">InputDialog</code> we created for <code class="literal">AlbumListPage.qml</code>. Please refer to the source code of the chapter to see the implementation for these features. This is how the thumbnails will look on an Android device:</p><div><img src="img/image00388.jpeg" alt="Displaying thumbnails in a GridView"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Swiping through full resolution pictures</h1></div></div></div><p>The last page we have to implement in <code class="literal">gallery-mobile</code> is the full resolution picture page. In <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>, we navigated through the pictures using previous/next buttons. In this chapter, we target the mobile platform. Therefore, the navigation should be done using a touch-based gesture: a fling.</p><p>Here is the implementation of this new <code class="literal">PicturePage.qml</code> file:</p><pre class="programlisting">import QtQuick 2.0 
import QtQuick.Layouts 1.3 
import QtQuick.Controls 2.0 
import "." 
 
PageTheme { 
 
    property string pictureName 
    property int pictureIndex 
 
    toolbarTitle: pictureName 
 
    ListView { 
        id: pictureListView 
        model: pictureModel 
        anchors.fill: parent 
        spacing: 5 
        orientation: Qt.Horizontal 
        snapMode: ListView.SnapOneItem 
        currentIndex: pictureIndex 
 
        Component.onCompleted: { 
            positionViewAtIndex(currentIndex, 
                                ListView.SnapPosition) 
        } 
 
        delegate: Rectangle { 
            property int itemIndex: index 
            property string itemName: name 
 
            width: ListView.view.width == 0 ? 
                   parent.width : ListView.view.width 
            height: pictureListView.height 
            color: "transparent" 
 
            Image { 
                fillMode: Image.PreserveAspectFit 
                cache: false 
                width: parent.width 
                height: parent.height 
                source: "image://pictures/" + index + "/full" 
            } 
        } 
    } 
} 
</pre><p>We first define two properties, <code class="literal">pictureName</code> and <code class="literal">pictureIndex</code>. The current <code class="literal">pictureName</code> property is displayed in the <code class="literal">toolbarTitle</code> and <code class="literal">pictureIndex</code> is used to initialize the correct <code class="literal">currentIndex</code> in <code class="literal">ListView</code>, <code class="literal">currentIndex: pictureIndex</code>.</p><p>To be able to swipe through the pictures, we again use a <code class="literal">ListView</code>. Here, each item (a simple <code class="literal">Image</code> element) will take the full size of its parent. When the component is loaded, even if <code class="literal">currentIndex</code> is correctly set, the view has to be updated to be positioned at the correct index. This is what we do in <code class="literal">pictureListView</code> with this:</p><pre class="programlisting">Component.onCompleted: { 
    positionViewAtIndex(currentIndex, ListView.SnapPosition) 
} 
</pre><p>This will update the position of the current visible item to <code class="literal">currentIndex</code>. So far so good. Nonetheless, when a <code class="literal">ListView</code> is created, the first thing it does is to initialize its delegate. A <code class="literal">ListView</code> has a <code class="literal">view</code> property, which is filled with the <code class="literal">delegate</code> content. That implies that the <code class="literal">ListView.view</code> (yes, it hurts) does not have any width in <code class="literal">Component.onCompleted()</code>. As a consequence, the <code class="literal">positionViewAtIndex()</code> function does... absolutely nothing. To prevent this behavior, we have to provide a default initial width to the delegate with the ternary expression <code class="literal">ListView.view.width == 0 ? parent.width : ListView.view.width</code>. The view will then have a default width on the first load and the <code class="literal">positionViewAtIndex()</code> function can happily move until <code class="literal">ListView.view</code> is properly loaded.</p><p>To swipe through each picture, we set the <code class="literal">snapMode</code> value of the <code class="literal">ListView</code> to <code class="literal">ListView.SnapOneItem</code>. Each fling will snap to the next or previous picture without continuing the motion.</p><p>The <code class="literal">Image</code> item of the delegate looks very much like the thumbnail version. The sole difference is the source property, where we request <code class="literal">PictureImageProvider</code> class with the <code class="literal">full</code> resolution.</p><p>When <code class="literal">PicturePage</code> opens, the correct <code class="literal">pictureName</code> property is displayed in the header. However, when the user flings to another picture, the name is not updated. To handle this, we have to detect the motion state. Add the following callbacks in <code class="literal">pictureListView</code>:</p><pre class="programlisting">onMovementEnded: { 
    currentIndex = itemAt(contentX, contentY).itemIndex 
} 
 
onCurrentItemChanged: { 
    toolbarTitleLabel.text = currentItem.itemName 
} 
</pre><p>The <code class="literal">onMovementEnded()</code> class is triggered when the motion started by the swipe has ended. In this function, we update the <code class="literal">ListViewcurrentIndex</code> with the <code class="literal">itemIndex</code> of the visible item at the <code class="literal">contentX</code> and <code class="literal">contentY</code> coordinates.</p><p>The second function, <code class="literal">onCurrentItemChanged()</code>, is called upon the <code class="literal">currentIndex</code> update. It will simply update the <code class="literal">toolbarTitleLabel.text</code> with the picture name of the current item.</p><p>To display <code class="literal">PicturePage.qml</code>, the same <code class="literal">MouseArea</code> pattern is used in the <code class="literal">thumbnailList</code> delegate of <code class="literal">AlbumPage.qml</code>:</p><pre class="programlisting">MouseArea { 
    anchors.fill: parent 
    onClicked: { 
        thumbnailList.currentIndex = index 
        pageStack.push("qrc:/qml/PicturePage.qml",  
    { pictureName: name, pictureIndex: index }) 
    } 
} 
</pre><p>Again, the <code class="literal">PicturePage.qml</code> file is pushed on the <code class="literal">pageStack</code> and the needed parameters (<code class="literal">pictureName</code> and <code class="literal">pictureIndex</code>) are provided in the same manner.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Summary</h1></div></div></div><p>This chapter brings closure to the development of the gallery application. We built a strong foundation with <code class="literal">gallery-core</code>, created a widget UI with <code class="literal">gallery-desktop</code>, and finally crafted a QML UI with <code class="literal">gallery-mobile</code>.</p><p>QML enables a very fast approach to UI development. Unfortunately, the technology is still young and rapidly changing. The integration with mobile OSes (Android, iOS) is under heavy development and we hope that it will lead to great mobile applications with Qt. For now, the inherent limits of a mobile cross-platform toolkit are still hard to overcome.</p><p>The next chapter will take QML technology to new shores: the development of a snake game running on a Raspberry Pi.</p></div></body></html>