["```cpp\n#include <vector> \n\n#include \"Camera.h\" \n#include \"LightRenderer.h\" \n\n#include <GL/glew.h> \n\n#include \"Dependencies/glm/glm/glm.hpp\" \n#include \"Dependencies/glm/glm/gtc/matrix_transform.hpp\" \n#include \"Dependencies/glm/glm/gtc/type_ptr.hpp\" \n```", "```cpp\nClass MeshRenderer{  \n\n}; \n```", "```cpp\n   public: \n         MeshRenderer(MeshType modelType, Camera* _camera); \n         ~MeshRenderer(); \n\n          void draw(); \n\n         void setPosition(glm::vec3 _position); \n         void setScale(glm::vec3 _scale); \n         void setProgram(GLuint _program); \n         void setTexture(GLuint _textureID); \n```", "```cpp\n   private: \n\n         std::vector<Vertex>vertices; \n         std::vector<GLuint>indices; \n         glm::mat4 modelMatrix; \n\n         Camera* camera; \n\n         glm::vec3 position, scale; \n\n               GLuint vao, vbo, ebo, texture, program;  \n```", "```cpp\nMeshRenderer::MeshRenderer(MeshType modelType, Camera* _camera) { \n\n} \n```", "```cpp\n   camera = _camera; \n\n   scale = glm::vec3(1.0f, 1.0f, 1.0f); \n   position = glm::vec3(0.0, 0.0, 0.0);\n```", "```cpp\n   switch (modelType){ \n\n         case kTriangle: Mesh::setTriData(vertices, indices);  \n               break; \n         case kQuad: Mesh::setQuadData(vertices, indices);  \n               break; \n         case kCube: Mesh::setCubeData(vertices, indices); \n               break; \n         case kSphere: Mesh::setSphereData(vertices, indices);  \n               break; \n   } \n```", "```cpp\n   glGenVertexArrays(1, &vao); \n   glBindVertexArray(vao); \n\n   glGenBuffers(1, &vbo); \n   glBindBuffer(GL_ARRAY_BUFFER, vbo); \n   glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * vertices.size(),\n   &vertices[0], GL_STATIC_DRAW); \n\n   glGenBuffers(1, &ebo); \n   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo); \n   glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint) * \n      indices.size(), &indices[0], GL_STATIC_DRAW); \n```", "```cpp\nglEnableVertexAttribArray(0);\n\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), \n   (GLvoid*)0);\n\nglEnableVertexAttribArray(1);\n\nglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),   \n   (void*)(offsetof(Vertex, Vertex::texCoords)));\n```", "```cpp\nglBindBuffer(GL_ARRAY_BUFFER, 0); \nglBindVertexArray(0); \n```", "```cpp\nvoid MeshRenderer::draw() { \n\n} \n\n```", "```cpp\n\n   glm::mat4 TranslationMatrix = glm::translate(glm::mat4(1.0f),  \n      position); \n\n   glm::mat4 scaleMatrix = glm::scale(glm::mat4(1.0f), scale); \n\n   modelMatrix = glm::mat4(1.0f); \n\n   modelMatrix = TranslationMatrix *scaleMatrix; \n```", "```cpp\nglm::mat4 vp = camera->getprojectionMatrix() * camera->\n               getViewMatrix(); \n\n```", "```cpp\nglUseProgram(this->program); \n\nGLint vpLoc = glGetUniformLocation(program, \"vp\"); \nglUniformMatrix4fv(vpLoc, 1, GL_FALSE, glm::value_ptr(vp)); \n\nGLint modelLoc = glGetUniformLocation(program, \"model\"); \nglUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(modelMatrix));  \n```", "```cpp\nglBindTexture(GL_TEXTURE_2D, texture);  \n```", "```cpp\nglBindVertexArray(vao);           \nglDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);   \n```", "```cpp\nglBindVertexArray(0); \n\n```", "```cpp\nMeshRenderer::~MeshRenderer() { \n\n} \n\n// setters  \n\nvoid MeshRenderer::setTexture(GLuint textureID) { \n\n   texture = textureID; \n\n} \n\nvoid MeshRenderer::setScale(glm::vec3 _scale) { \n\n   this->scale = _scale; \n} \n\nvoid MeshRenderer::setPosition(glm::vec3 _position) { \n\n   this->position = _position; \n} \n\nvoid MeshRenderer::setProgram(GLuint _program) { \n\n   this->program = _program; \n} \n```", "```cpp\n#include <string> \n#include <GL/glew.h> \n\nclass TextureLoader \n{ \npublic: \n   TextureLoader(); \n\n   GLuint getTextureID(std::string  texFileName); \n   ~TextureLoader(); \n}; \n```", "```cpp\n#define STB_IMAGE_IMPLEMENTATION \n#include \"Dependencies/stb-master/stb_image.h\" \n```", "```cpp\n\nTextureLoader::TextureLoader(){ \n\n} \n\nTextureLoader::~TextureLoader(){ \n\n} \n```", "```cpp\nGLuint TextureLoader::getTextureID(std::string texFileName){ \n\n}  \n```", "```cpp\n   int width, height, channels;  \n```", "```cpp\nstbi_uc* image = stbi_load(texFileName.c_str(), &width, &height,   \n                 &channels, STBI_rgb); \n```", "```cpp\nGLuint mtexture; \nglGenTextures(1, &mtexture); \nglBindTexture(GL_TEXTURE_2D, mtexture);    \n```", "```cpp\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  \n```", "```cpp\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \n```", "```cpp\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, \n   GL_LINEAR_MIPMAP_LINEAR); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \n```", "```cpp\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,GL_RGB, \n    GL_UNSIGNED_BYTE, image); \n```", "```cpp\nglGenerateMipmap(GL_TEXTURE_2D); \n```", "```cpp\nglBindTexture(GL_TEXTURE_2D, 0); \nstbi_image_free(image); \n\n   return mtexture; \n```", "```cpp\nCamera* camera; \nLightRenderer* light; \nMeshRenderer* sphere;\n```", "```cpp\nGLuint flatShaderProgram = shader.CreateProgram(\n                           \"Assets/Shaders/FlatModel.vs\", \n                           \"Assets/Shaders/FlatModel.fs\"); \nGLuint texturedShaderProgram = shader.CreateProgram(\n                               \"Assets/Shaders/TexturedModel.vs\",   \n                               \"Assets/Shaders/TexturedModel.fs\");\n```", "```cpp\n#version 450 core \nlayout (location = 0) in vec3 position; \nlayout (location = 1) in vec2 texCoord; \n\nout vec2 TexCoord; \n\nuniform mat4 vp; \nuniform mat4 model; \n\nvoid main(){ \n\n   gl_Position = vp * model *vec4(position, 1.0); \n\n   TexCoord = texCoord; \n} \n\n```", "```cpp\n #version 450 core \n\nin vec2 TexCoord; \n\nout vec4 color; \n\n// texture \nuniform sampler2D Texture; \n\nvoid main(){ \n\n         color = texture(Texture, TexCoord);  \n} \n```", "```cpp\n TextureLoader tLoader; \nGLuint sphereTexture = tLoader.getTextureID(\"Assets/Textures/globe.jpg\");  \n```", "```cpp\n   sphere = new MeshRenderer(MeshType::kSphere, camera); \n   sphere->setProgram(texturedShaderProgram); \n   sphere->setTexture(sphereTexture); \n   sphere->setPosition(glm::vec3(0.0f, 0.0f, 0.0f)); \n   sphere->setScale(glm::vec3(1.0f)); \n```", "```cpp\nvoid renderScene(){ \n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n   glClearColor(1.0, 1.0, 0.0, 1.0); \n\n   sphere->draw(); \n\n}  \n```", "```cpp\n\ncamera = new Camera(45.0f, 800, 600, 0.1f, 100.0f, glm::vec3(0.0f, \n         0.0f, 4.0f)); \n```", "```cpp\n#include \"Camera.h\" \n#include \"LightRenderer.h\" \n#include \"MeshRenderer.h\" \n#include \"TextureLoader.h\" \n\n#include <btBulletDynamicsCommon.h> \n```", "```cpp\nbtDiscreteDynamicsWorld* dynamicsWorld; \n```", "```cpp\n//init physics \nbtBroadphaseInterface* broadphase = new btDbvtBroadphase(); \nbtDefaultCollisionConfiguration* collisionConfiguration = \n   new btDefaultCollisionConfiguration(); \nbtCollisionDispatcher* dispatcher = \n   new btCollisionDispatcher(collisionConfiguration); \nbtSequentialImpulseConstraintSolver* solver = \n   new btSequentialImpulseConstraintSolver(); \n```", "```cpp\ndynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration); \n```", "```cpp\ndynamicsWorld->setGravity(btVector3(0, -9.8f, 0)); \n```", "```cpp\n   btCollisionShape* sphereShape = new btSphereShape(1.0f);   \n```", "```cpp\nbtDefaultMotionState* sphereMotionState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(0, 10.0f, 0))); \n```", "```cpp\nbtScalar mass = 10.0; \nbtVector3 sphereInertia(0, 0, 0); \nsphereShape->calculateLocalInertia(mass, sphereInertia); \n\n```", "```cpp\nbtScalar mass = 10.0; \nbtVector3 sphereInertia(0, 0, 0); \nsphereShape->calculateLocalInertia(mass, sphereInertia); \n\nbtRigidBody::btRigidBodyConstructionInfo sphereRigidBodyCI(mass, \nsphereMotionState, sphereShape, sphereInertia); \n\n```", "```cpp\nbtRigidBody* sphereRigidBody = new btRigidBody(sphereRigidBodyCI); \n```", "```cpp\nsphereRigidBody->setRestitution(1.0f); \nsphereRigidBody->setFriction(1.0f);  \n```", "```cpp\ndynamicsWorld->addRigidBody(sphereRigidBody); \n```", "```cpp\n#include <btBulletDynamicsCommon.h> \n\n   class MeshRenderer{ \n\npublic: \nMeshRenderer(MeshType modelType, Camera* _camera, btRigidBody* _rigidBody); \n         . \n         . \n   private: \n         . \n         . \n         btRigidBody* rigidBody; \n};\n```", "```cpp\nMeshRenderer::MeshRenderer(MeshType modelType, Camera* _camera, btRigidBody* _rigidBody) { \n\n   rigidBody = _rigidBody; \n   camera = _camera; \n   . \n   . \n}\n```", "```cpp\n   btTransform t; \n\n   rigidBody->getMotionState()->getWorldTransform(t); \n```", "```cpp\n   btQuaternion rotation = t.getRotation(); \n   btVector3 translate = t.getOrigin(); \n```", "```cpp\nglm::mat4 RotationMatrix = glm::rotate(glm::mat4(1.0f), rotation.getAngle(),glm::vec3(rotation.getAxis().getX(),rotation.getAxis().getY(), rotation.getAxis().getZ())); \n\nglm::mat4 TranslationMatrix = glm::translate(glm::mat4(1.0f), \n                              glm::vec3(translate.getX(),  \n                              translate.getY(), translate.getZ())); \n\nglm::mat4 scaleMatrix = glm::scale(glm::mat4(1.0f), scale); \n```", "```cpp\n   modelMatrix = TranslationMatrix * RotationMatrix * scaleMatrix;  \n```", "```cpp\n   // Sphere Mesh \n\n   sphere = new MeshRenderer(MeshType::kSphere, camera, \n            sphereRigidBody); \n   sphere->setProgram(texturedShaderProgram); \n   sphere->setTexture(sphereTexture); \n   sphere->setScale(glm::vec3(1.0f)); \n```", "```cpp\ncamera = new Camera(45.0f, 800, 600, 0.1f, 100.0f, glm::vec3(0.0f, \n         4.0f, 20.0f)); \n```", "```cpp\nauto previousTime = std::chrono::high_resolution_clock::now(); \n\nwhile (!glfwWindowShouldClose(window)){ \n\n         auto currentTime = std::chrono::\n                            high_resolution_clock::now(); \n         float dt = std::chrono::duration<float, std::\n                    chrono::seconds::period>(currentTime - \n                    previousTime).count(); \n\n         dynamicsWorld->stepSimulation(dt); \n\n         renderScene(); \n\n         glfwSwapBuffers(window); \n         glfwPollEvents(); \n\n         previousTime = currentTime; \n   } \n\n```", "```cpp\n   btCollisionShape* groundShape = new btBoxShape(btVector3(4.0f, \n                                   0.5f, 4.0f)); \n\n   btDefaultMotionState* groundMotionState = new  \n     btDefaultMotionState(btTransform(btQuaternion\n     (0, 0, 0, 1), btVector3(0, -2.0f, 0))); \n   btRigidBody::btRigidBodyConstructionInfo \n    groundRigidBodyCI(0.0f, new btDefaultMotionState(), \n    groundShape, btVector3(0, 0, 0)); \n\n   btRigidBody* groundRigidBody = new btRigidBody(\n                                  groundRigidBodyCI); \n\n   groundRigidBody->setFriction(1.0); \n   groundRigidBody->setRestitution(0.9); \n\n   groundRigidBody->setCollisionFlags(btCollisionObject\n     ::CF_STATIC_OBJECT); \n\n   dynamicsWorld->addRigidBody(groundRigidBody);  \n```", "```cpp\n   // Ground Mesh \n   GLuint groundTexture = tLoader.getTextureID(\n                          \"Assets/Textures/ground.jpg\"); \n   ground = new MeshRenderer(MeshType::kCube, camera,  \n            groundRigidBody); \n   ground->setProgram(texturedShaderProgram); \n   ground->setTexture(groundTexture); \n   ground->setScale(glm::vec3(4.0f, 0.5f, 4.0f));  \n```", "```cpp\nvoid renderScene(){ \n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n   glClearColor(1.0, 1.0, 0.0, 1.0); \n\n   sphere->draw(); \n   ground->draw(); \n}\n```"]