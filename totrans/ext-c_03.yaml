- en: Chapter 03
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: Object Files
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象文件
- en: This chapter details the various products that a C/C++ project can have. Possible
    products include relocatable object files, executable object files, static libraries,
    and shared object files. However, relocatable object files are considered to be
    temporary products and they act as ingredients for making other types of products
    that are final.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了 C/C++ 项目可能产生的各种产品。可能的产品包括可重定位对象文件、可执行对象文件、静态库和共享对象文件。然而，可重定位对象文件被认为是临时产品，它们作为制作其他最终产品的原料。
- en: It seems that today in C, it's crucial to have further discussion about the
    various types of object files and their internal structures. The majority of C
    books only talk about the C syntax and the language itself; but, in real-world
    you need more in-depth knowledge to be a successful C programmer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，在今天的 C 语言中，进一步讨论各种类型的对象文件及其内部结构至关重要。大多数 C 语言书籍只讨论 C 语法和语言本身；但在现实生活中，你需要更深入的知识才能成为一名成功的
    C 语言程序员。
- en: 'When you are creating software, it is not just about the development and the
    programming language. In fact, it is about the whole process: writing the code,
    compilation, optimization, producing correct products, and further subsequent
    steps, in order to run and maintain those products on the target platforms.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建软件时，不仅仅是关于开发和编程语言。实际上，它是关于整个流程：编写代码、编译、优化、生产正确的产品，以及进一步的后续步骤，以便在目标平台上运行和维护这些产品。
- en: You should be knowledgeable about these intermediate steps, to the extent that
    you are able to solve any issues you might encounter. This is even more serious
    regarding embedded development, as the hardware architectures and the instruction
    sets can be challenging and atypical.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对这些中间步骤有所了解，以便能够解决你可能会遇到的问题。这对于嵌入式开发来说尤其严重，因为硬件架构和指令集可能具有挑战性和非典型性。
- en: 'This chapter is divided into the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下几部分：
- en: '**Application binary interface**: Here, we are first going to talk about the
    **Application Binary Interface** (**ABI**) and its importance.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用程序二进制接口**：在这里，我们首先将讨论 **应用程序二进制接口**（**ABI**）及其重要性。'
- en: '**Object file formats**: In this section, we talk about various object file
    formats that exist today or they have become obsolete over the years. We also
    introduce ELF as the most used object file format in Unix-like systems.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象文件格式**：在本节中，我们讨论今天存在或在过去几年中变得过时的各种对象文件格式。我们还介绍了 ELF 作为 Unix-like 系统中最常用的对象文件格式。'
- en: '**Relocatable object files**: Here we discuss relocatable object files and
    the very first products of a C project. We take a look inside ELF relocatable
    object files to see what we can find there.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可重定位对象文件**：在这里，我们讨论可重定位对象文件以及 C 项目的第一个产品。我们深入 ELF 可重定位对象文件内部，看看我们能找到什么。'
- en: '**Executable object files**: As part of this section, we talk about the executable
    object files. We also explain how they are created from a number of relocatable
    object files. We discuss the differences between ELF relocatable and executable
    object files in terms of their internal structure.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可执行对象文件**：作为本节的一部分，我们讨论可执行对象文件。我们还解释了它们是如何从多个可重定位对象文件中创建的。我们讨论了 ELF 可重定位对象文件和可执行对象文件在内部结构上的差异。'
- en: '**Static library**: In this section, we talk about static libraries and how
    we can create them. We also demonstrate how to write a program and use already
    built static libraries.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**静态库**：在本节中，我们讨论静态库以及如何创建它们。我们还演示了如何编写程序并使用已经构建的静态库。'
- en: '**Dynamic library**: Here we talk about shared object files. We demonstrate
    how to create them out of a number of relocatable object files and how to use
    them in a program. We also briefly talk about the internal structure of an ELF
    shared object file.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态库**：在这里，我们讨论共享对象文件。我们演示了如何从多个可重定位对象文件中创建它们，以及如何在程序中使用它们。我们还简要地讨论了 ELF 共享对象文件的内部结构。'
- en: Our discussions in this chapter will be mostly themed around Unix-like systems,
    but we will discuss some differences in other operating systems like Microsoft
    Windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的讨论将主要围绕 Unix-like 系统，但我们也会讨论与其他操作系统（如 Microsoft Windows）的一些差异。
- en: '**Note**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Before moving on to read this chapter, you need to be familiar with the basic
    ideas and steps required for building a C project. You need to know what a translation
    unit is and how linking is different from compilation. Please read the previous
    chapter before moving on with this one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读本章之前，你需要熟悉构建C项目所需的基本思想和步骤。你需要知道什么是翻译单元以及链接与编译的不同之处。请在继续阅读本章之前先阅读上一章。
- en: Let's begin the chapter by talking about ABI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍ABI（应用程序二进制接口）开始本章。
- en: Application binary interface (ABI)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序二进制接口 (ABI)
- en: As you may already know, every library or framework, regardless of the technologies
    or the programming language used, exposes a set of certain functionalities, which
    is known as its **Application Programming Interface** (**API**). If a library
    is supposed to be used by another code, then the consumer code should use the
    provided API. To be clear, nothing other than the API should be used in order
    to use a library because it is the public interface of the library and everything
    else is seen as a black box, hence cannot be used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，每个库或框架，无论使用的技术或编程语言如何，都暴露了一组特定的功能，这被称为其**应用程序编程接口**（**API**）。如果一个库应该被其他代码使用，那么消费者代码应该使用提供的API。为了清楚起见，除了API之外，不应使用任何其他东西来使用库，因为它是库的公共接口，其他所有内容都被视为黑盒，因此不能使用。
- en: Now suppose after some time, the library's API undergoes some modifications.
    In order for the consumer code to continue using the newer versions of the library,
    the code must adapt itself to the new API; otherwise, it won't be able to use
    it anymore. The consumer code could stick to a certain version of the library
    (maybe an old one) and ignore the newer versions, but let's assume that there
    is a desire to upgrade to the latest version of the library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设经过一段时间后，库的API进行了某些修改。为了使消费者代码能够继续使用库的新版本，代码必须适应新的API；否则，它将无法再使用它。消费者代码可以坚持使用库的某个版本（可能是一个旧版本）并忽略新版本，但让我们假设有一个升级到库最新版本的愿望。
- en: To put it simply, an API is like a convention (or standard) accepted between
    two software components to serve or use each other. An ABI is pretty similar to
    API, but at a different level. While the API guarantees the compatibility of two
    software components to continue their functional cooperation, the ABI guarantees
    that two programs are compatible at the level of their machine-level instructions,
    together with their corresponding object files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，API就像两个软件组件之间接受（或标准）的约定。ABI与API非常相似，但处于不同的层面。虽然API保证了两个软件组件在功能合作方面的兼容性，但ABI保证了两个程序在机器级指令及其相应的目标文件级别上的兼容性。
- en: For instance, a program cannot use a dynamic or static library that has a different
    ABI. Perhaps worse than that, an executable file (which is, in fact, an object
    file) cannot be run on a system supporting a different ABI than the one that the
    executable file was built for. A number of vital and obvious system functionalities,
    such as *dynamic linking*, *loading an executable*, and *function calling convention*,
    should be done precisely according to an agreed upon ABI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个程序不能使用具有不同ABI的动态或静态库。或许更糟糕的是，一个可执行文件（实际上是一个目标文件）不能在支持与可执行文件构建的ABI不同的系统上运行。许多关键且明显的系统功能，如*动态链接*、*加载可执行文件*和*函数调用约定*，必须精确地按照约定的ABI执行。
- en: 'An ABI will typically cover the following things:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ABI通常涵盖以下内容：
- en: The instruction set of the target architecture, which includes the processor
    instructions, memory layout, endianness, registers, and so on.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标架构的指令集，包括处理器指令、内存布局、字节序、寄存器等。
- en: Existing data types, their sizes, and the alignment policy.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的数据类型、它们的大小和对齐策略。
- en: The function calling convention describes how functions should be called. For
    example, subjects like the structure of the *stack frame* and the pushing order
    of the arguments are part of it.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用约定描述了函数应该如何被调用。例如，*栈帧*的结构和参数的推入顺序都属于其中。
- en: Defining how *system calls* should be called in a Unix-like system.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在类Unix系统中如何调用*系统调用*。
- en: Used *object file format*, which we will explain in the following section, for having
    *relocatable, executable*, and *shared object files*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*目标文件格式*，我们将在下一节中解释，以拥有*可重定位、可执行*和*共享目标文件*。
- en: Regarding object files produced by a C++ compiler, the *name mangling*, *virtual
    table* layout, is part of the ABI.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于由 C++ 编译器生成的目标文件，*名称编码*、*虚函数表布局*是 ABI 的一部分。
- en: The *System V ABI* is the most widely used ABI standard among Unix-like operating
    systems like Linux and the BSD systems. **Executable and Linking Format** (**ELF**)
    is the standard object file format used in the System V ABI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*System V ABI* 是在 Linux 和 BSD 等类 Unix 操作系统中最广泛使用的 ABI 标准。**可执行和链接格式**（**ELF**）是
    System V ABI 中使用的标准目标文件格式。'
- en: '**Note**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'The following link is the System V ABI for AMD 64-bit architectur[e: https://www.uclibc.org/docs/psABI-x86_64.](https://www.uclibc.org/docs/psABI-x86_64.pdf)pdf.
    You can go through the list of contents and see the areas it covers.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是 AMD 64 位架构的 System V ABI：[https://www.uclibc.org/docs/psABI-x86_64.pdf](https://www.uclibc.org/docs/psABI-x86_64.pdf)。您可以查看目录列表，并了解它涵盖的领域。
- en: In the following section, we will discuss the object file formats, particularly
    ELF.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论目标文件格式，特别是 ELF。
- en: Object file formats
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标文件格式
- en: As we explained in the previous chapter, *Chapter 2*, *Compilation and Linking*,
    on a platform, object files have their own specific format for storing machine-level
    instructions. Note that this is about the structure of object files and this is
    different from the fact that each architecture has its own instruction set. As
    we know from the previous discussion, these two variations are different parts
    of the ABI in a platform; the object file format and the architecture's instruction
    set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章，即 *第 2 章，编译和链接* 中所解释的，在平台上，目标文件有其自己的特定格式来存储机器级指令。请注意，这是关于目标文件的结构，这与每个架构都有自己的指令集的事实不同。正如我们从之前的讨论中了解到的，这两个变体是平台中
    ABI 的不同部分；目标文件格式和架构的指令集。
- en: 'In this section, we are going to have a brief look into some widely known object
    file formats. To start with, let''s look at some object file formats used in various
    operating systems:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些广为人知的目标文件格式。首先，让我们看看各种操作系统中使用的某些目标文件格式：
- en: '**ELF** used by Linux and many other Unix-like operating systems'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ELF** 被 Linux 和许多其他类 Unix 操作系统使用'
- en: '**Mach-O** used in OS X (macOS and iOS) systems'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OS X（macOS 和 iOS）系统中使用的 **Mach-O**
- en: '**PE** used in Microsoft Windows'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Microsoft Windows 中使用的 **PE**（可移植执行）格式
- en: To give some history and context about the current and past object file formats,
    we can say that all object file formats that exist today are successors to the
    old `a.out` object file format. It was designed for early versions of Unix.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供关于当前和过去目标文件格式的历史和背景信息，我们可以这样说，今天存在的所有目标文件格式都是旧 `a.out` 目标文件格式的继承者。它是为 Unix
    的早期版本设计的。
- en: The term **a.out** stands for **assembler output**. Despite the fact that the
    file format is obsolete today, the name is still used as the default filename
    for the executable files produced by most linkers. You should remember seeing
    `a.out` in a number of examples in the first chapter of the book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **a.out** 代表 **汇编器输出**。尽管今天该文件格式已经过时，但该名称仍然被用作大多数链接器生成的可执行文件的默认文件名。您应该记得在本书的第一章中看到过
    `a.out`。
- en: However, the `a.out` format was soon replaced by **COFF** or the **Common Object
    File Format**. COFF is the basis for ELF – the object format that we use in most
    Unix-like systems. Apple also replaced `a.out` with Mach-O as part of OS/X. Windows
    uses the **PE** or **Portable Execution** file format for its object files, which
    is based on COFF.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`a.out` 格式很快就被 **COFF** 或 **通用目标文件格式** 所取代。COFF 是 ELF 的基础——我们在大多数类 Unix 系统中使用的目标文件格式。苹果公司也用
    Mach-O 替换了 `a.out` 作为 OS/X 的一部分。Windows 使用 **PE** 或 **可移植执行** 文件格式来处理其目标文件，该格式基于
    COFF。
- en: '**Note**:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'A deeper history of object file formats can be found here: [https://en.wikipedia.org/wiki/COFF#History](https://en.wikipedia.org/wiki/COFF#History).
    Knowing about the history of a specific topic will help you to get a better understanding
    of its evolution path and current and past characteristics.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入的目标文件格式历史可以在这里找到：[https://en.wikipedia.org/wiki/COFF#History](https://en.wikipedia.org/wiki/COFF#History)。了解特定主题的历史将有助于您更好地理解其演变路径以及当前和过去的特点。
- en: As you can see, all of today's major object file formats are based on the historic
    object file format `a.out`, and then COFF, and in many ways share the same ancestry.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，今天所有的主流目标文件格式都基于历史目标文件格式 `a.out`，然后是 COFF，并且在很多方面都拥有相同的血统。
- en: ELF is the standard object file format used in Linux and most Unix-like operating
    systems. In fact, ELF is the object file format used as part of the System V ABI,
    heavily employed in most Unix systems. Today, it is the most widely accepted object
    file format used by operating systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 是 Linux 和大多数类 Unix 操作系统中使用的标准对象文件格式。实际上，ELF 是作为 System V ABI 的一部分使用的对象文件格式，在大多数
    Unix 系统中得到广泛使用。如今，它是操作系统使用最广泛的对象文件格式。
- en: 'ELF is the standard binary file format for operating systems including, but
    not limited to:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 是包括但不限于以下操作系统的标准二进制文件格式：
- en: Linux
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: FreeBSD
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: NetBSD
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBSD
- en: Solaris
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: This means that as long as the architecture beneath them remains the same, an
    ELF object file created for one of these operating systems can be run and used
    in others. ELF, like all other *file formats*, has a structure that we will describe
    briefly in the upcoming sections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，只要它们下面的架构保持不变，为这些操作系统之一创建的 ELF 对象文件可以在其他操作系统中运行和使用。ELF，像所有其他 *文件格式* 一样，有一个结构，我们将在接下来的章节中简要描述。
- en: '**Note**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'More information about ELF and its details can be f[ound here: https://www.uclibc.org/docs/psABI](https://www.uclibc.org/docs/psABI-x86_64.pdf)-x86_64.pdf.
    Note that this link refers to the System V ABI for AMD 64-bits (`amd64`) architecture.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 ELF 及其细节的信息可以在以下链接找到：[https://www.uclibc.org/docs/psABI](https://www.uclibc.org/docs/psABI-x86_64.pdf)。请注意，此链接指的是
    AMD 64 位（`amd64`）架构的 System V ABI。
- en: 'You can also read the HTML version of the System V ABI here: [http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html](http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处阅读 System V ABI 的 HTML 版本：[http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html](http://www.sco.com/developers/gabi/2003-12-17/ch4.intro.html)。
- en: In the upcoming sections, we are going to talk about the temporary and final
    products of a C project. We start with relocatable object files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 C 项目的临时和最终产品。我们从可重定位对象文件开始。
- en: Relocatable object files
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重定位对象文件
- en: In this section, we are going to talk about relocatable object files. As we
    explained in the previous chapter, these object files are the output of the assembly
    step in the C compilation pipeline. These files are considered to be temporary
    products of a C project, and they are the main ingredients to produce further
    and final products. For this reason, it would be useful to have a deeper look
    at them and see what we can find in a relocatable object file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论可重定位对象文件。正如我们在上一章中解释的，这些对象文件是 C 编译管道中汇编步骤的输出。这些文件被认为是 C 项目的临时产品，并且是生产进一步和最终产品的主要成分。因此，深入了解它们并查看我们可以在可重定位对象文件中找到什么将是有用的。
- en: 'In a relocatable object file, we can find the following items regarding the
    compiled translation unit:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在可重定位对象文件中，我们可以找到以下关于编译的翻译单元的项目：
- en: The machine-level instructions produced for the functions found in the translation
    unit (code).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为翻译单元中找到的函数生成的机器级指令（代码）。
- en: The values of the initialized global variables declared in the translation unit
    (data).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在翻译单元（数据）中声明的初始化全局变量的值。
- en: The *symbol table* containing all the defined and reference symbols found in
    the translation unit.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含翻译单元中找到的所有定义和引用符号的 *符号表*。
- en: These are the key items that can be found in any relocatable object file. Of
    course, the way that they are put together depends on the object file format,
    but using proper tools, you should be able to extract these items from a relocatable
    object file. We are going to do this for an ELF relocatable object file shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在任何可重定位对象文件中可以找到的关键项目。当然，它们的组合方式取决于对象文件格式，但使用适当的工具，你应该能够从可重定位对象文件中提取这些项目。我们将很快对
    ELF 可重定位对象文件进行这样的操作。
- en: But before delving into the example, let's talk about the reason why relocatable
    object files are named like this. In other words, what does the *relocatable*
    mean after all? The reason comes from the process that a linker performs in order
    to put some relocatable object files together and form a bigger object file –
    an executable object file or a shared object file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入示例之前，让我们谈谈为什么可重定位对象文件会这样命名。换句话说，*可重定位*究竟意味着什么？原因来自于链接器执行的过程，以便将一些可重定位对象文件组合在一起，形成一个更大的对象文件——可执行对象文件或共享对象文件。
- en: We discuss what can be found in an executable file in the next section, but
    for now, we should know that the items we find in an executable object file are
    the sum of all the items found in all the constituent relocatable object files.
    Let's just talk about machine-level instructions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论可执行文件中可以找到的内容，但到目前为止，我们应该知道我们在可执行对象文件中找到的项目是所有构成可重定位对象文件中找到的项目之和。让我们只谈谈机器级指令。
- en: The machine-level instructions found in one relocatable object file should be
    put next to the machine-level instructions coming from another relocatable object
    file. This means that the instructions should be easily *movable* or *relocatable*.
    For this to happen, the instructions have no addresses in a relocatable object
    file, and they obtain their addresses only after the linking step. This is the
    main reason why we call these object files relocatable. To elaborate more on this,
    we need to show it in a real example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个可重定位对象文件中找到的机器级指令应该放在来自另一个可重定位对象文件的机器级指令旁边。这意味着指令应该是容易 *移动* 或 *重定位* 的。为了实现这一点，指令在可重定位对象文件中没有地址，并且它们只在链接步骤后获得地址。这就是我们称这些对象文件为可重定位的主要原因。为了更详细地说明这一点，我们需要在真实示例中展示。
- en: '*Example 3.1* is about two source files, one containing the definitions of
    two functions, `max` and `max_3`, and the other source file containing the `main`
    function using the declared functions `max` and `max_3`. Next, you can see the
    content of the first source file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3.1* 是关于两个源文件，一个包含两个函数的定义，`max` 和 `max_3`，另一个源文件包含使用声明的函数 `max` 和 `max_3`
    的 `main` 函数。接下来，您可以看到第一个源文件的内容：'
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 3-1 [ExtremeC_examples_chapter3_1_funcs.c]: A source file containing
    two function definitions'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 3-1 [ExtremeC_examples_chapter3_1_funcs.c]：包含两个函数定义的源文件
- en: 'And the second source file looks like the following code box:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个源文件看起来像以下代码框：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 3-2 [ExtremeC_examples_chapter3_1.c]: The main function using the
    already declared functions. Definitions are put in a separate source file.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 3-2 [ExtremeC_examples_chapter3_1.c]：使用已声明的函数的 `main` 函数。定义被放入单独的源文件中。
- en: 'Let''s produce the relocatable object files for the preceding source files.
    This way, we can investigate the content and that which we explained before. Note
    that, since we are compiling these sources on a Linux machine, we expect to see
    ELF object files as the result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为前面的源文件生成可重定位对象文件。这样，我们可以调查内容和之前解释的内容。请注意，由于我们在 Linux 机器上编译这些源文件，我们期望看到 ELF
    对象文件作为结果：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 3-1: Compiling source files to their corresponding relocatable object
    files'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 3-1：将源文件编译成相应的可重定位对象文件
- en: 'Both `funcs.o` and `main.o` are relocatable ELF object files. In an ELF object
    file, the items described to be in a relocatable object file are put into a number
    of sections. In order to see the present sections in the preceding relocatable
    object files, we can use the `readelf` utility as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`funcs.o` 和 `main.o` 都是可重定位的 ELF 对象文件。在 ELF 对象文件中，描述为可重定位对象文件中的项目被放入多个部分中。为了查看先前可重定位对象文件中的当前部分，我们可以使用以下
    `readelf` 工具：'
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 3-2: The ELF content of the funcs.o object file'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 3-2：`funcs.o` 对象文件的 ELF 内容
- en: As you can see in the preceding shell box, the relocatable object file has 11
    sections. The sections in bold font are the sections that we have introduced as
    items existing in an object file. The `.text` section contains all the machine-level
    instructions for the translation unit. The `.data` and `.bss` sections contain
    the values for initialized global variables, and the number of bytes required
    for uninitialized global variables respectively. The `.symtab` section contains
    the symbol table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的 shell 框中看到的，可重定位对象文件有 11 个部分。粗体字体的部分是我们介绍为存在于对象文件中的项目。`.text` 部分包含翻译单元的所有机器级指令。`.data`
    和 `.bss` 部分包含初始化全局变量的值，以及未初始化全局变量所需的字节数。`.symtab` 部分包含符号表。
- en: Note that, the sections existing in both preceding object files are the same,
    but their content is different. Therefore, we don't show the sections for the
    other relocatable object file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前两个对象文件中存在的部分是相同的，但它们的内容是不同的。因此，我们不显示其他可重定位对象文件的部分。
- en: As we mentioned before, one of the sections in an ELF object file contains the
    symbol table. In the previous chapter, we had a thorough discussion about the
    symbol table and its entries. We described how it is being used by the linker
    to produce executable and shared object files. Here, we want to draw your attention
    to something about the symbol table that we didn't discuss in the previous chapter.
    This would be in accordance with our explanation on why relocatable object files
    are named in this manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，ELF 对象文件中的一个部分包含符号表。在上一章中，我们对符号表及其条目进行了详细讨论。我们描述了链接器如何使用它来生成可执行和共享对象文件。在这里，我们想提醒您注意我们在上一章中没有讨论的符号表的一些内容。这将是根据我们关于为什么可重定位对象文件以这种方式命名的解释。
- en: 'Let''s dump the symbol table for `funcs.o`. In the previous chapter, we used
    `objdump` but now, we are going to use `readelf` to do so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导出 `funcs.o` 的符号表。在上一章中，我们使用了 `objdump`，但现在，我们将使用 `readelf` 来完成：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 3-3: The symbol table of the funcs.o object file'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-3：funcs.o 对象文件的符号表
- en: 'As you can see in the `Value` column, the address assigned to `max` is `0`
    and the address assigned to `max_3` is `22` (hexadecimal `16`). This means that
    the instructions related to these symbols are adjacent and their addresses start
    from 0\. These symbols, and their corresponding machine-level instructions, are
    ready to be relocated to other places in the final executable. Let''s look at
    the symbol table of `main.o`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 `Value` 列中看到的，分配给 `max` 的地址是 `0`，分配给 `max_3` 的地址是 `22`（十六进制 `16`）。这意味着与这些符号相关的指令是相邻的，并且它们的地址从
    0 开始。这些符号及其对应的机器级指令已准备好被重新定位到最终可执行文件中的其他位置。让我们看看 `main.o` 的符号表：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 3-4: The symbol table of the main.o object file'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-4：main.o 对象文件的符号表
- en: As you can see, the symbols associated with global variables `a` and `b`, as
    well as the symbol for the `main` function are put at addresses that don't seem
    be the final addresses that they should be placed at. This is a sign of being
    a relocatable object file. As we have said before, the symbols in a relocatable
    object files don't have any final and absolute addresses and their addresses will
    be determined as part of the linking step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与全局变量 `a` 和 `b` 相关的符号，以及 `main` 函数的符号被放置在似乎不是它们应该放置的最终地址上。这是可重定位对象文件的标志。正如我们之前所说的，可重定位对象文件中的符号没有最终和绝对地址，它们的地址将在链接步骤中确定。
- en: In the following section, we continue to produce an executable file from the
    preceding relocatable object files. You will see that the symbol table is different.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们继续从前面的可重定位对象文件中生成可执行文件。您将看到符号表是不同的。
- en: Executable Object Files
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可执行对象文件
- en: Now, it's time to talk about executable object files. You should know by now
    that executable object file is one of the final products of a C project. Like
    relocatable object files, they have the same items in the:; the machine-level
    instructions, the values for initialized global variables, and the symbol tabl;t
    however, the arrangement can be different. We can show this regarding the ELF
    executable object files since it would be easy to generate them and study their
    internal structure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候讨论可执行对象文件了。您现在应该知道，可执行对象文件是 C 项目的最终产品之一。与可重定位对象文件一样，它们在：; 机器级指令、初始化全局变量的值、符号表中有相同的项；然而，它们的排列可能不同。我们可以通过
    ELF 可执行对象文件来展示这一点，因为它们很容易生成并研究其内部结构。
- en: In order to produce an executable ELF object file, we continue with *example
    3.1*. In the previous section, we generated relocatable object files for the two
    sources existing in the example, and in this section, we are going to link them
    to form an executable file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成可执行的 ELF 对象文件，我们继续进行 *示例 3.1*。在上一节中，我们为示例中的两个源生成了可重定位对象文件，在本节中，我们将它们链接起来形成一个可执行文件。
- en: 'The following commands do that for you, as explained in the previous chapter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为您完成这些操作，如前一章所述：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 3-5: Linking previously built relocatable object files in example
    3.1'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-5：在示例 3.1 中链接之前构建的可重定位对象文件
- en: In the previous section, we spoke about sections being present in an ELF object
    file. We should say that more sections exist in an ELF executable object file,
    but together with some segments. Every ELF executable object file, and as you
    will see later in this chapter, every ELF shared object file, has a number of
    *segments* in addition to sections. Each segment consists of a number of sections
    (zero or more), and the sections are put into segments based on their content.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了存在于ELF对象文件中的段。我们应该指出，ELF可执行对象文件中存在更多的段，但与一些段一起。每个ELF可执行对象文件，正如你将在本章后面看到的那样，每个ELF共享对象文件，除了段之外，还有许多*段*。每个段由多个段（零个或更多）组成，并且根据其内容将段放入段中。
- en: For example, all sections containing machine-level instructions go into the
    same segment. You will see in *Chapter 4*, *Process Memory Structure*, that these
    segments nicely map to static *memory segments* found in the memory layout of
    a running process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有包含机器级指令的段都放入同一个段中。你将在*第四章*，*进程内存结构*中看到，这些段很好地映射到运行进程内存布局中找到的静态*内存段*。
- en: Let's look at the contents of an executable file and meet these segments. Similarly,
    to relocatable object files, we can use the same command to show the sectios,
    and the segments found in an executable ELF object file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可执行文件的内容，并了解这些段。同样，对于可重定位对象文件，我们可以使用相同的命令来显示段，以及在一个可执行ELF对象文件中找到的段。
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 3-6: The ELF content of ex3_1.out executable object file'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-6：ex3_1.out可执行对象文件的ELF内容
- en: 'There are multiple notes about the above output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上述输出有以下几点说明：
- en: We can see that the type of object file from the ELF point of vew, is a shared
    object file. In other words, in ELF, an executable object file is a shared object
    file that has some specific segments like `INTERP`. This segment (actually the
    `.interp` section which is referred to by this segment) is used by the loader
    program to load and execute the executable object file.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ELF的角度来看，我们可以看到对象文件的类型是共享对象文件。换句话说，在ELF中，可执行对象文件是一种具有特定段（如`INTERP`）的共享对象文件。这个段（实际上是此段引用的`.interp`段）由加载程序用于加载和执行可执行对象文件。
- en: We have made four segments bold. The first one refers to the `INTERP` segment
    which is explained in the previous bullet point. The second one is the `TEXT`
    segment. It contains all the section having machine-level instructions. The third
    one is the `DATA` segment that contains all the values that should be used to
    initialize the global variables and other early structures. The fourth segment
    refers to the section that *dynamic linking* related information can be found.
    For instance, the shared object files that need to be loaded as part of the execution.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将四个段加粗。第一个指的是上一条项目符号中解释的`INTERP`段。第二个是`TEXT`段，它包含所有包含机器级指令的段。第三个是`DATA`段，它包含所有用于初始化全局变量和其他早期结构的值。第四个段指的是可以找到*动态链接*相关信息的段。例如，需要作为执行部分加载的共享对象文件。
- en: As you see, we've got more sections in comparison to a relocatable shared object,
    probably filled with data required to load and execute the object file.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所见，与可重定位共享对象相比，我们得到了更多的段，可能填充了加载和执行对象文件所需的数据。
- en: As we explained in the previous section, the symbols found in the symbol table
    of a relocatable object file do not have any absolute and determined addresses.
    That's because the sections containing machine-level instructions are not linked
    yet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所述，可重定位目标文件的符号表中找到的符号没有任何绝对和确定的地址。这是因为包含机器级指令的部分尚未链接。
- en: In a deeper sense, linking a number of relocatable object files is actually
    to collect all similar sections from the given relocatable object files and put
    them together to form a bigger section, and finally put the resulting section
    into the output executable or the shared object file. Therefore, only after this
    step, the symbols can be finalized and obtain the addresses that are not going
    to change. In executable object files, the addresses are absolute, while in shared
    object files, the relative addresses are absolute. We will discuss this more in
    the section dedicated to dynamic libraries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深层次上，链接多个可重定位对象文件实际上是将给定可重定位对象文件中的所有类似段收集起来，并将它们组合成一个更大的段，最后将生成的段放入输出可执行文件或共享对象文件中。因此，只有在这个步骤之后，符号才能最终确定并获得不会改变的地址。在可执行对象文件中，地址是绝对的，而在共享对象文件中，相对地址是绝对的。我们将在专门讨论动态库的章节中进一步讨论这个问题。
- en: 'Let''s look at the symbol table found in the executable file `ex3_1.out`. Note
    that the symbol table has many entries and that''s why the output is not fully
    shown in the following shell box:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在可执行文件`ex3_1.out`中找到的符号表。请注意，符号表有很多条目，这就是为什么以下Shell Box中的输出没有完全显示：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Shell Box 3-7: The symbol tables found in the ex3_1.out executable object file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-7：在`ex3_1.out`可执行目标文件中找到的符号表
- en: As you see in the preceding shell box, we have two different symbol tables in
    an executable object file. The first one, `.dynsym`, contains the symbols that
    should be resolved when loading the executable, but the second symbol table, `.symtab`,
    contains all the resolved symbols together with unresolved symbols brought from
    the dynamic symbol table. In other words, the symbol table contains the unresolved
    symbols from the dynamic table as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述Shell Box所示，一个可执行目标文件中有两个不同的符号表。第一个，`.dynsym`，包含在加载可执行文件时应解析的符号，但第二个符号表`.symtab`包含所有解析出的符号，以及从动态符号表中带来的未解析符号。换句话说，符号表包含来自动态表的未解析符号。
- en: As you see, the resolved symbols in the symbol table have absolute corresponding
    addresses that they have obtained after the linking step. The addresses for `max`
    and `max_3` symbols are shown in bold font.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，符号表中解析出的符号具有在链接步骤后获得的绝对对应地址。`max`和`max_3`符号的地址以粗体显示。
- en: In this section, we took a brief look into the executable object file. In the
    next section, we are going to talk about static libraries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地了解了可执行目标文件。在下一节中，我们将讨论静态库。
- en: Static libraries
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态库
- en: As we have explained before, a static library is one of the possible products
    of a C project. In this section, we are going to talk about static libraries and
    the way they are created and used. We will then continue this discussion by introducing
    dynamic libraries in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，静态库是C项目可能的产物之一。在本节中，我们将讨论静态库以及它们的创建和使用方式。然后，我们将在下一节中通过介绍动态库继续这一讨论。
- en: A static library is simply a Unix archive made from the relocatable object files.
    Such a library is usually linked together with other object files to form an executable
    object file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库简单地说就是由可重定位目标文件组成的Unix归档。这样的库通常与其他目标文件链接在一起，形成一个可执行目标文件。
- en: Note that a static library itself is not considered as an object file, rather
    it is a container for them. In other words, static libraries are not ELF files
    in Linux systems, nor are they Mach-O files in macOS systems. They are simply
    archived files that have been created by the Unix `ar` utility.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，静态库本身不被视为对象文件，而是一个容器。换句话说，静态库在Linux系统中不是ELF文件，在macOS系统中也不是Mach-O文件。它们只是由Unix的`ar`实用程序创建的归档文件。
- en: When a linker is about to use a static library in the linking step, it first
    tries to extract the relocatable object files from it, then it starts to look
    up and resolve the undefined symbols that may be found in some of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当链接器在链接步骤中准备使用静态库时，它首先尝试从中提取可重定位的目标文件，然后开始查找并解析可能存在于其中的一些未定义符号。
- en: Now, it's time to create a static library for a project with multiple source
    files. The first step is to create some relocatable object files. Once you have
    compiled all of the source files in a C/C++ project, you can use the Unix archiving
    tool, `ar`, to create the static library's archive file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为具有多个源文件的项目创建一个静态库了。第一步是创建一些可重定位的目标文件。一旦你编译了一个C/C++项目中的所有源文件，你就可以使用Unix归档工具`ar`来创建静态库的归档文件。
- en: In Unix systems, static libraries are usually named according to an accepted
    and widely used convention. The name starts with `lib`, and it ends with the `.a`
    extension. This can be different for other operating systems; for instance, in
    Microsoft Windows, static libraries carry the `.lib` extension.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中，静态库通常根据一个公认且广泛使用的约定命名。名称以`lib`开头，并以`.a`扩展名结尾。在其他操作系统中可能会有所不同；例如，在Microsoft
    Windows中，静态库带有`.lib`扩展名。
- en: 'Suppose that, in an imaginary C project, you have the source files `aa.c`,
    `bb.c`, all the way up to `zz.c`. In order to produce the relocatable object files,
    you will need to compile the source files in a similar manner to how we use the
    commands next. Note that the compilation process has been thoroughly explained
    in the previous chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在一个虚构的C项目中，你拥有源文件 `aa.c`、`bb.c`，一直到 `zz.c`。为了生成可重定位的目标文件，你需要以类似以下命令的方式编译源文件。注意，编译过程已经在上一章中进行了详细解释：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Shell Box 3-8: Compiling a number of sources to their corresponding relocatable
    object files'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-8：将多个源文件编译成相应的可重定位目标文件
- en: By running the preceding commands, we will get all the required relocatable
    object files. Note that this can take a considerable amount of time if the project
    is big and contains thousands of source files. Of course, having a powerful build
    machine, together with running the compilation jobs in parallel, can reduce the
    build time significantly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的命令，我们将得到所有必需的可重定位目标文件。注意，如果项目很大且包含成千上万的源文件，这可能需要相当长的时间。当然，拥有一个强大的构建机器，以及并行运行编译任务，可以显著减少构建时间。
- en: 'When it comes to creating a static library file, we simply need to run the
    following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建静态库文件时，我们只需运行以下命令：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 3-9: The general recipe for making a static library out of a number
    of relocatable object files'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-9：从多个可重定位目标文件中制作静态库的一般方法
- en: 'As a result, `libexample.a` is created, which contains all of the preceding
    relocatable object files as a single archive. Explaining the `crs` option passed
    to `ar` would be out of the scope of this chapter, but in the following link,
    you can read [about its meaning: https://stackoverflow.com/questions/29714300/what-does-th](https://stackoverflow.com/questions/29714300/what-does-the-rcs-option-in-ar-do)e-rcs-option-in-ar-do.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，生成了 `libexample.a` 库，其中包含了前面所有的可重定位目标文件作为一个单独的归档。解释传递给 `ar` 命令的 `crs` 选项超出了本章的范围，但在以下链接中，你可以阅读关于其含义的说明：[关于其含义：https://stackoverflow.com/questions/29714300/what-does-th](https://stackoverflow.com/questions/29714300/what-does-the-rcs-option-in-ar-do)e-rcs-option-in-ar-do.
- en: '**Note**:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: The `ar` command does not necessarily create a *compressed* archive file. It
    is only used to put files together to form a single file that is an archive of
    all those files. The tool `ar` is general purpose, and you can use it to put any
    kind of files together and create your own archive out of them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ar` 命令不一定创建一个 *压缩* 的归档文件。它仅用于将文件组合在一起形成一个包含所有这些文件的单一文件。工具 `ar` 是通用的，你可以用它将任何类型的文件组合在一起，并从中创建自己的归档。'
- en: Now that we know how to create a static library, we are going to create a real
    one as part of *example 3.2*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建一个静态库，我们将创建一个真实的静态库作为 *示例 3.2* 的一部分。
- en: First, we are going to presume that *example 3.2* is a C project about geometry.
    The example consists of three source files and one header file. The purpose of
    the library is to define a selection of geometry related functions that can be
    used in other applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将假设 *示例 3.2* 是一个关于几何学的C项目。该示例由三个源文件和一个头文件组成。库的目的是定义一组可用于其他应用的几何相关函数。
- en: To do this, we need to create a static library file named `libgeometry.a` out
    of the three source files. By having the static library, we can use the header
    file and the static library file together in order to write another program that
    will use the geometry functions defined in the library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要从三个源文件中创建一个名为 `libgeometry.a` 的静态库文件。通过拥有静态库，我们可以将头文件和静态库文件一起使用，以便编写另一个使用库中定义的几何函数的程序。
- en: The following code boxes are the contents of the source and header files. The
    first file, `ExtremeC_examples_chapter3_2_geometry.h`, contains all of the declarations
    that need to be exported from our geometry library. These declarations will be
    used by future applications that are going to use the library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框是源文件和头文件的内容。第一个文件 `ExtremeC_examples_chapter3_2_geometry.h` 包含了需要从我们的几何库中导出的所有声明。这些声明将被未来使用该库的应用程序使用。
- en: '**Note**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: All the commands provided for creating object files are run and tested on Linux.
    Some modifications might be necessary if you're going to execute them on a different
    operating system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的所有用于创建目标文件的命令都在Linux上运行并测试过。如果你要在不同的操作系统上执行它们，可能需要进行一些修改。
- en: 'We need to take note that future applications *must* be only dependent on the
    declarations and not the definitions at all. Therefore, firstly, let''s look at
    the declarations of the geometry library:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意，未来的应用程序*必须*只依赖于声明，而完全不依赖于定义。因此，首先，让我们看看几何库的声明：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 3-3 [ExtremeC_examples_chapter3_2_geometry.h]: The header file of
    example 3.2'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 3-3 [ExtremeC_examples_chapter3_2_geometry.h]: 示例 3.2 的头文件'
- en: 'The second file, which is a source file, contains the definitions of the trigonometry
    functions, the first six functions declared in the preceding header file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是一个源文件，包含三角函数的定义，这是在前面头文件中声明的六个函数中的前六个：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 3-4 [ExtremeC_examples_chapter3_2_trigon.c]: The source file containing
    the definitions of the trigonometry functions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 3-4 [ExtremeC_examples_chapter3_2_trigon.c]: 包含三角函数定义的源文件'
- en: Note that it is not necessary for sources to include the header file unless
    they are going to use a declaration like `PI` or `to_degree`, which is declared
    in the header file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，源文件不需要包含头文件，除非它们将要使用头文件中声明的像 `PI` 或 `to_degree` 这样的声明。
- en: 'The third file, which is a source file again, contains the definitions of all
    2D Geometry functions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个文件，同样是一个源文件，包含所有 2D 几何函数的定义：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 3-5 [ExtremeC_examples_chapter3_2_2d.c]: The source file containing
    the definitions of the 2D functions'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 3-5 [ExtremeC_examples_chapter3_2_2d.c]: 包含 2D 函数定义的源文件'
- en: 'And finally, the fourth file that contains the definitions of 3D Geometry functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，包含 3D 几何函数定义的第四个文件：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 3-6 [ExtremeC_examples_chapter3_2_3d.c]: The source file containing
    the definitions of the 3D functions'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 3-6 [ExtremeC_examples_chapter3_2_3d.c]: 包含 3D 函数定义的源文件'
- en: Now we'll create the static library file. To do this, firstly we need to compile
    the preceding sources to their corresponding relocatable object files. You need
    to note that we cannot link these object files to create an executable file as
    there is no `main` function in any of the preceding source files. Therefore, we
    can either keep them as relocatable object files or archive them to form a static
    library. We have another option to create a shared object file out of them, but
    we'll wait until the next section to look at this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建静态库文件。为此，首先我们需要将前面的源文件编译成它们对应的目标文件。需要注意的是，源文件不需要包含头文件，除非它们将要使用像 `PI`
    或 `to_degree` 这样的声明，这些声明在头文件中声明。
- en: 'In this section, we have chosen to archive them in order to create a static
    library file. The following commands will do the compilation on a Linux system:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们选择将它们存档以创建一个静态库文件。以下命令将在 Linux 系统上执行编译：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 3-10: Compiling source files to their corresponding relocatable object
    files'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行框 3-10：将源文件编译成对应的目标文件
- en: 'When it comes to archiving these object files into a static library file, we
    need to run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将这些目标文件存档到静态库文件中时，我们需要运行以下命令：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 3-11: Creating the static library file out of the relocatable object
    files'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行框 3-11：从可重定位的目标文件创建静态库文件
- en: 'As we can see, the file `libgeometry.a` has been created. As you see, we have
    moved the library file to the `/opt/geometry` directory to be easily locatable
    by any other program. Again, using the `ar` command, and via passing the `t` option,
    we can see the content of the archive file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，已经创建了文件 `libgeometry.a`。如您所见，我们已经将库文件移动到 `/opt/geometry` 目录，以便其他任何程序都能轻松找到。再次使用
    `ar` 命令，并通过传递 `t` 选项，我们可以查看存档文件的内容：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Shell Box 3-12: Listing the content of the static library file'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行框 3-12：列出静态库文件的内容
- en: As is clear from the preceding shell box, the static library file contains three
    relocatable object files as we intended. The next step is to use the static library
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的命令行框所示，静态库文件包含三个可重定位的目标文件，正如我们预期的。下一步是使用静态库文件。
- en: Now that we have created a static library for our geometry example, *example
    3.2*, we are going to use it in a new application. When using a C library, we
    need to have access to the declarations that are exposed by the library together
    with its static library file. The declarations are considered as the *public interface*
    of the library, or more commonly, the API of the library.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的几何示例 *example 3.2* 创建了一个静态库，我们将将其用于一个新的应用程序。在使用 C 库时，我们需要访问库公开的声明以及与其静态库文件一起的声明。这些声明被认为是库的
    *公共接口*，或者更常见的是，库的 API。
- en: We need declarations in the compile stage, when the compiler needs to know about
    the existence of types, function signatures, and so on. Header files serve this
    purpose. Other details such as type sizes and function addresses are needed at
    later stages; linking and loading.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译阶段，我们需要声明，当编译器需要了解类型、函数签名等信息的存在时。头文件就起到这个作用。在后续阶段，如链接和加载，还需要其他详细信息，例如类型大小和函数地址。
- en: As we said before, we usually find a C API (an API exposed by a C library) as
    a group of header files. Therefore, the header file from *example 3.2*, and the
    created static library file `libgeometry.a`, are enough for us to write a new
    program that uses our geometry library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们通常将 C API（由 C 库公开的 API）作为一个头文件组找到。因此，*example 3.2* 的头文件和创建的静态库文件
    `libgeometry.a` 就足够我们编写一个新的程序，该程序使用我们的几何库。
- en: 'When it comes to using the static library, we need to write a new source file
    that includes the library''s API and make use of its functions. We write the new
    code as a new example, *example 3.3*. The following code is the source that we
    have written for *example 3.3*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用静态库时，我们需要编写一个新的源文件，该文件包含库的 API 并使用其函数。我们将新代码作为一个新的示例，*example 3.3*。以下代码是
    *example 3.3* 的源代码：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 3-7 [ExtremeC_examples_chapter3_3.c]: The main function testing some
    of the geometry functions'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 3-7 [ExtremeC_examples_chapter3_3.c]：测试一些几何函数的主函数
- en: As you can see, *example 3.3* has included the header file from *example 3.2*.
    It has done this because it needs the declarations of the functions that it is
    going to use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*example 3.3* 包含了 *example 3.2* 的头文件。它这样做是因为它需要使用到的函数的声明。
- en: 'We now need to compile the preceding source file to create its corresponding
    relocatable object file in a Linux system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编译前面的源文件，在 Linux 系统中创建其对应的可重定位目标文件：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 3-13: Compiling example 3.3'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-13：编译示例 3.3
- en: 'After we have done that, we need to link it with the static library that we
    created for *example 3.2*. In this case, we assume that the file `libgeometry.a`
    is located in the `/opt/geometry` directory, as we had in *Shell Box 3-11*. The
    following command will complete the build by performing the linking step and creating
    the executable object file, *ex3_3.out*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们需要将其与为 *example 3.2* 创建的静态库进行链接。在这种情况下，我们假设文件 `libgeometry.a` 位于 `/opt/geometry`
    目录中，就像我们在 *Shell Box 3-11* 中做的那样。以下命令将通过执行链接步骤并创建可执行目标文件 *ex3_3.out* 来完成构建：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Shell Box 3-14: Linking with the static library created as part of example
    3.2'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-14：使用示例 3.2 中创建的静态库进行链接
- en: 'To explain the preceding command, we are going to explain each passing option
    separately:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面的命令，我们将分别解释每个传递选项：
- en: '`-L/opt/geometry` tells `gcc` to consider the directory `/opt/geometry` as
    one of the various locations in which static and shared libraries could be found.
    There are well-known paths like `/usr/lib` or `/usr/local/lib` in which the linker
    searches for library files by default. If you do not specify the `-L` option,
    the linker only searches its default paths.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L/opt/geometry` 告诉 `gcc` 将目录 `/opt/geometry` 视为静态和共享库可能存在的多个位置之一。默认情况下，链接器会在已知路径如
    `/usr/lib` 或 `/usr/local/lib` 中搜索库文件。如果你没有指定 `-L` 选项，链接器只会在默认路径中搜索。'
- en: '`-lgeometry` tells `gcc` to look for the file `libgeometry.a` or `libgeometry.so`.
    A file ending with `.so` is a shared object file, which we explain in the next
    section. Note the convention used. If you pass the option `-lxyz` for instance,
    the linker will search for the file `libxyz.a` or `libxyz.so` in the default and
    specified directories. If the file is not found, the linker stops and generates
    an error.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lgeometry` 告诉 `gcc` 查找文件 `libgeometry.a` 或 `libgeometry.so`。以 `.so` 结尾的文件是共享对象文件，我们将在下一节中解释。注意使用的约定。例如，如果你传递
    `-lxyz` 选项，链接器将在默认和指定目录中搜索文件 `libxyz.a` 或 `libxyz.so`。如果找不到文件，链接器将停止并生成错误。'
- en: '`-lm` tells `gcc` to look for another library named `libm.a` or `libm.so`.
    This library keeps the definitions of mathematical functions in *glibc*. We need
    it for the `cos`, `sin`, and `acos` functions. Note that we are building *example
    3.3* on a Linux machine, which uses *glibc* as its default C library''s implementation.
    In macOS and possibly some other Unix-like systems, you don''t need to specify
    this option.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lm` 告诉 `gcc` 查找另一个名为 `libm.a` 或 `libm.so` 的库。这个库保存了 *glibc* 中的数学函数定义。我们需要它来使用
    `cos`、`sin` 和 `acos` 函数。请注意，我们正在 Linux 机器上构建 *example 3.3*，它使用 *glibc* 作为其默认 C
    库的实现。在 macOS 和可能的一些其他类 Unix 系统中，你不需要指定此选项。'
- en: '`-o ex3_3.out` tells `gcc` that the output executable file should be named
    `ex3_3.out`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o ex3_3.out` 告诉 `gcc` 输出的可执行文件应该命名为 `ex3_3.out`。'
- en: After running the preceding command, if everything goes smoothly, you will have
    an executable binary file that contains all the relocatable object files found
    in the static library `libgeometry.a` plus `main.o`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，如果一切顺利，你将有一个包含在静态库 `libgeometry.a` 中找到的所有可重定位目标文件以及 `main.o` 的可执行二进制文件。
- en: Note that there will not be any dependency on the existence of the static library
    file after linking, as everything is *embedded* inside the executable file itself.
    In other words, the final executable file can be run on its own without needing
    the static library to be present.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在链接之后，不会对静态库文件的存在有任何依赖，因为所有内容都*嵌入*在可执行文件本身中。换句话说，最终的可执行文件可以独立运行，无需静态库存在。
- en: However, executable files produced from the linkage of many static libraries
    usually have huge sizes. The more static libraries and the more relocatable object
    files inside them, the bigger the size of the final executable. Sometimes it can
    go up to several hundred megabytes or even a few gigabytes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从许多静态库的链接中产生的可执行文件通常具有很大的体积。静态库越多，其中的可重定位目标文件越多，最终可执行文件的体积就越大。有时它可以达到几百兆字节，甚至几吉字节。
- en: It is a trade-off between the size of the binary and the dependencies it might
    have. You can have a smaller binary, but by using shared libraries. It means that
    the final binary is not complete and cannot be run if the external shared libraries
    do not exist or cannot be found. We talk more about this in the upcoming sections.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在二进制文件的大小和它可能具有的依赖项之间的一种权衡。你可以拥有一个更小的二进制文件，但通过使用共享库。这意味着最终的二进制文件并不完整，如果外部共享库不存在或找不到，则无法运行。我们将在接下来的章节中更多地讨论这个问题。
- en: In this section, we described what static libraries are and how they should
    be created and used. We also demonstrated how another program can use the exposed
    API and get linked to an existing static library. In the following section, we
    are going to talk about dynamic libraries and how to produce a shared object file
    (dynamic library) from sources in *example 3.2*, instead of using a static library.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了静态库是什么，以及它们应该如何创建和使用。我们还演示了另一个程序如何使用公开的 API 并将其链接到现有的静态库。在下一节中，我们将讨论动态库以及如何从
    *example 3.2* 的源代码中生成共享对象文件（动态库），而不是使用静态库。
- en: Dynamic libraries
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态库
- en: Dynamic libraries, or shared libraries, are another way to produce libraries
    for reuse. As their name implies, unlike the static libraries, dynamic libraries
    are not part of the final executable itself. Instead, they should be loaded and
    brought in while loading a process for execution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 动态库，或共享库，是生成可重用库的另一种方式。正如其名所示，与静态库不同，动态库不是最终可执行文件本身的一部分。相反，它们应该在加载用于执行的过程时加载和引入。
- en: Since static libraries are part of the executable, the linker puts everything
    found in the given relocatable files into the final executable file. In other
    words, the linker detects the undefined symbols, and required definitions, and
    tries to find them in the given relocatable object files, then puts them all in
    the output executable file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态库是可执行文件的一部分，链接器会将给定可重定位文件中找到的所有内容放入最终的可执行文件中。换句话说，链接器检测未定义的符号和所需的定义，并尝试在给定的可重定位目标文件中找到它们，然后将它们全部放入输出可执行文件中。
- en: The final product is only produced when every undefined symbol is found. From
    a unique perspective, we detect all dependencies and resolve them at linking time.
    Regarding dynamic libraries, it is possible to have undefined symbols that are
    not resolved at linking time. These symbols are searched for when the executable
    product is about to be loaded and begin the execution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有未定义的符号都被找到时，最终产品才会被生成。从独特的角度来看，我们在链接时检测所有依赖关系并解决它们。至于动态库，在链接时可能存在未解决的未定义符号。这些符号将在可执行产品即将加载并开始执行时被搜索。
- en: In other words, a different kind of linking step is needed when you have undefined
    dynamic symbols. A *dynamic linker*, or simply the *loader*, usually does the
    linking while loading an executable file and preparing it to be run as a process.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当你有未定义的动态符号时，需要不同的链接步骤。一个*动态链接器*，或者简单地称为*加载器*，通常在加载可执行文件并准备将其作为进程运行时执行链接操作。
- en: Since the undefined dynamic symbols are not found in the executable file, they
    should be found somewhere else. These symbols should be loaded from shared object
    files. These files are sister files to static library files. While the static
    library files have a `.a` extension in their names, the shared object files carry
    the `.so` extension in most Unix-like systems. In macOS, they have the `.dylib`
    extension.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未定义的动态符号没有在可执行文件中找到，它们应该在别处找到。这些符号应该从共享对象文件中加载。这些文件是静态库文件的姐妹文件。虽然静态库文件在其名称中有`.a`扩展名，但共享对象文件在大多数类Unix系统中携带`.so`扩展名。在macOS中，它们有`.dylib`扩展名。
- en: When loading a process and about to be launched, a shared object file will be
    loaded and mapped to a memory region accessible by the process. This procedure
    is done by a dynamic linker (or loader), which loads and executes an executable
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个进程并即将启动时，一个共享对象文件将被加载并映射到一个进程可访问的内存区域。这个步骤是由动态链接器（或加载器）完成的，它加载并执行可执行文件。
- en: Like we said in the section dedicated to executable object files, both ELF executable
    and shared object files have segments in their ELF structure. Each segment has
    zero or more sections in them. There are two main differences between an ELF executable
    object file and an ELF shared object file. Firstly, the symbols have relative
    absolute addresses that allow them to be loaded as part of many processes at the
    same time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在专门讨论可执行对象文件的章节中所说的那样，ELF可执行文件和共享对象文件在其ELF结构中都有段。每个段包含零个或多个节。ELF可执行对象文件和ELF共享对象文件之间有两个主要区别。首先，符号具有相对绝对地址，这使得它们可以作为许多进程的一部分同时加载。
- en: This means that while the address of each instruction is different in any process,
    the distance between two instructions remains fixed. In other words, the addresses
    are fixed relative to an offset. This is because the relocatable object files
    are *position independent*. We talk more about this in the last section of this
    chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然每个进程中的每条指令的地址都不同，但两条指令之间的距离保持固定。换句话说，地址相对于偏移量是固定的。这是因为可重定位对象文件是*位置无关的*。我们将在本章的最后部分更多地讨论这一点。
- en: For instance, if two instructions are located at addresses 100 and 200 in a
    process, in another process they may be at 140 and 240, and in another one they
    could be at 323 and 423\. The related addresses are absolute, but the actual addresses
    can change. These two instructions will always be 100 addresses apart from each
    other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果两条指令在一个进程中的地址是100和200，在另一个进程中它们可能在140和240，在另一个进程中可能是323和423。相关的地址是绝对的，但实际地址可以改变。这两条指令之间的距离始终是100个地址。
- en: The second difference is that some segments related to loading an ELF executable
    object file are not present in shared object files. This effectively means that
    shared object files cannot be executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，与加载ELF可执行对象文件相关的某些段在共享对象文件中不存在。这实际上意味着共享对象文件不能被执行。
- en: Before giving more details on how a shared object is accessed from different
    processes, we need to show an example of how they are created and used. Therefore,
    we are going to create dynamic libraries for the same geometry library, *example
    3.2*, that we worked on in the previous section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细介绍如何从不同的进程访问共享对象之前，我们需要展示一个示例，说明它们是如何创建和使用的。因此，我们将为我们在上一节中工作的相同几何库，*示例3.2*，创建动态库。
- en: 'In the previous section we created a static library for the geometry library.
    In this section, we want to compile the sources again in order to create a shared
    object file out of them. The following commands show you how to compile the three
    sources into their corresponding relocatable object files, with just one difference
    in comparison to what we did for *example 3.2*. In the following commands, note
    the `-fPIC` option that is passed to `gcc`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为几何库创建了一个静态库。在本节中，我们想要再次编译源代码，以便从中创建一个共享对象文件。以下命令显示了如何将三个源代码编译成它们对应的位置无关可重定位目标文件，与我们在
    *示例 3.2* 中所做的工作只有一个不同。在以下命令中，请注意传递给 `gcc` 的 `-fPIC` 选项：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shell Box 3-15: Compiling the sources of example 3.2 to corresponding position-independent
    relocatable object files'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-15：将示例 3.2 的源代码编译成相应的位置无关可重定位目标文件
- en: Looking at the commands, you can see that we have passed an extra option,`-fPIC`,
    to `gcc` while compiling the sources. This option is *mandatory* if you are going
    to create a shared object file out of some relocatable object files. **PIC** stands
    for **position independent code**. As we explained before, if a relocatable object
    file is position independent, it simply means that the instructions within it
    don't have fixed addresses. Instead, they have relative addresses; hence they
    can obtain different addresses in different processes. This is a requirement because
    of the way we use shared object files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 观察命令，你可以看到我们在编译源代码时传递了一个额外的选项 `-fPIC` 给 `gcc`。如果你打算从一些可重定位目标文件中创建共享对象文件，这个选项是**强制性的**。**PIC**代表**位置无关代码**。正如我们之前解释的，如果一个可重定位目标文件是位置无关的，那么它仅仅意味着其中的指令没有固定的地址。相反，它们有相对地址；因此，它们可以在不同的进程中获得不同的地址。这是由于我们使用共享对象文件的方式所要求的。
- en: There is no guarantee that the loader program will load a shared object file
    at the same address in different processes. In fact, the loader creates memory
    mappings to the shared object files, and the address ranges for those mappings
    can be different. If the instruction addresses were absolute, we couldn't load
    the same shared object file in various processes, and in various memory regions,
    at the same time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证加载程序将在不同进程中以相同的地址加载共享对象文件。实际上，加载程序为共享对象文件创建内存映射，这些映射的地址范围可能不同。如果指令地址是绝对的，我们就不能同时在不同的进程和不同的内存区域中加载相同的共享对象文件。
- en: '**Note**:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'For more detailed information on how the dynamic loading of programs and shared
    object files works, you can see the following resources:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关程序和共享对象文件动态加载工作方式的更详细信息，你可以查看以下资源：
- en: '[https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf](https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf](https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf)'
- en: '[https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html](https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html)'
- en: To create shared object files, you need to use the compiler, in this case, `gcc`,
    again. Unlike a static library file, which is a simple archive, a shared object
    file is an object file itself. Therefore, they should be created by the same linker
    program, for instance `ld`, that we used to produce the relocatable object files.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建共享对象文件，你需要再次使用编译器，在这种情况下，是 `gcc`。与是一个简单的存档的静态库文件不同，共享对象文件本身就是一个目标文件。因此，它们应该由相同的链接程序创建，例如我们用来生成可重定位目标文件的
    `ld`。
- en: We know that, on most Unix-like systems, `ld` does that. However, it is strongly
    recommended not to use `ld` directly for linking object files for the reasons
    we explained in the previous chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在大多数类 Unix 系统中，`ld` 会这样做。然而，强烈建议不要直接使用 `ld` 链接对象文件，原因我们在上一章中已经解释过。
- en: 'The following command shows how you should create a shared object file out
    of a number of relocatable object files that have been compiled using the `-fPIC`
    option:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了如何从使用 `-fPIC` 选项编译的多个可重定位目标文件中创建共享对象文件：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Shell Box 3-16: Creating a shared object file out of the relocatable object
    files'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-16：从可重定位目标文件中创建共享对象文件
- en: As you can see in the first command, we passed the `-shared` option, to ask
    `gcc` to create a shared object file out of the relocatable object files. The
    result is a shared object file named `libgeometry.so`. We have moved the shared
    object file to `/opt/geometry` to make it easily available to other programs willing
    to use it. The next step is to compile and link *example 3.3* again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在第一个命令中看到的，我们传递了 `-shared` 选项，要求 `gcc` 从可重定位目标文件中创建一个共享对象文件。结果是名为 `libgeometry.so`
    的共享对象文件。我们已经将共享对象文件移动到 `/opt/geometry` 以便其他愿意使用它的程序可以轻松访问。下一步是再次编译和链接 *示例 3.3*。
- en: Previously, we compiled and linked *example 3.3* with the created static library
    file, `libgeometry.a`. Here, we are going to do the same, but instead, link it
    with `libgeometry.so`, a dynamic library.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用创建的静态库文件 `libgeometry.a` 编译并链接了 *示例 3.3*。这里，我们将做同样的事情，但我们将使用 `libgeometry.so`，一个动态库来链接它。
- en: 'While everything seems to be the same, especially the commands, they are in
    fact different. This time, we are going to link *example 3.3* with `libgeometry.so`
    instead of `libgeometry.a`, and more than that, the dynamic library won''t get
    embedded into the final executable, instead it will load the library upon execution.
    While practicing this, make sure that you have removed the static library file,
    `libgeometry.a`, from `/opt/geometry` before linking *example 3.3* again:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切似乎都一样，特别是命令，但事实上它们是不同的。这次，我们将用 `libgeometry.so` 而不是 `libgeometry.a` 链接 *示例
    3.3*，而且不仅如此，动态库不会嵌入到最终的执行文件中，而是在执行时加载库。在练习这个过程中，确保在再次链接 *示例 3.3* 之前，你已经从 `/opt/geometry`
    中移除了静态库文件 `libgeometry.a`：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Shell Box 3-17: Linking example 3.3 against the built shared object file'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-17：将示例 3.3 链接到构建的共享对象文件
- en: As we explained before, the option `-lgeometry` tells the compiler to find and
    use a library, either static or shared, to link it with the rest of the object
    files. Since we have removed the static library file, the shared object file is
    picked up. If both the static library and shared object files exist for a defined
    library, then `gcc` prefers to pick the shared object file and link it with the
    program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的那样，选项 `-lgeometry` 告诉编译器查找并使用一个库，无论是静态的还是共享的，以便将其与其它目标文件链接。由于我们已经移除了静态库文件，所以选择了共享对象文件。如果定义的库既有静态库文件又有共享对象文件，那么
    `gcc` 会优先选择共享对象文件并将其与程序链接。
- en: 'If you now try to run the executable file `ex3_3.out`, you will most probably
    face the following error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行可执行文件 `ex3_3.out`，你很可能会遇到以下错误：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Shell Box 3-18: Trying to run example 3.3'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-18：尝试运行示例 3.3
- en: We haven't seen this error so far, because we were using static linkage and
    a static library. But now, by introducing dynamic libraries, if we are going to
    run a program that has *dynamic dependencies*, we should provide the required
    dynamic libraries to have it run. But what has happened and why we've received
    the error message?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有看到这个错误，因为我们使用的是静态链接和静态库。但现在，通过引入动态库，如果我们打算运行一个具有 *动态依赖性* 的程序，我们应该提供所需的动态库以便它能够运行。但发生了什么，为什么我们会收到错误信息？
- en: The `ex3_3.out` executable file depends on `libgeometry.so`. That's because
    some of the definitions it needs can only be found inside that shared object file.
    We should note that this is not true for the static library `libgeometry.a`. An
    executable file linked with a static library can be run on its own as a standalone
    executable, since it has copied everything from the static library file, and therefore,
    doesn't rely on its existence anymore.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件 `ex3_3.out` 依赖于 `libgeometry.so` 库。这是因为它需要的某些定义只能在该共享对象文件中找到。我们应该注意，这并不适用于静态库
    `libgeometry.a`。与静态库链接的可执行文件可以作为独立可执行文件运行，因为它已经从静态库文件中复制了所有内容，因此不再依赖于其存在。
- en: This is not true for the shared object files. We received the error because
    the program loader (dynamic linker) could not find `libgeometry.so` in its default
    search paths. Therefore, we need to add `/opt/geometry` to its search paths, so
    that it finds the `libgeometry.so` file there. To do this, we will update the
    environment variable `LD_LIBRARY_PATH` to point to the current directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享对象文件来说，情况并非如此。我们收到错误是因为程序加载器（动态链接器）在其默认搜索路径中找不到 `libgeometry.so`。因此，我们需要将
    `/opt/geometry` 添加到其搜索路径中，以便在那里找到 `libgeometry.so` 文件。为此，我们将更新环境变量 `LD_LIBRARY_PATH`
    以指向当前目录。
- en: The loader will check the value of this environment variable, and it will search
    the specified paths for the required shared libraries. Note that more than one
    path can be specified in this environment variable (using the separator colon
    `:`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 加载程序将检查这个环境变量的值，并将在指定的路径中搜索所需的共享库。请注意，在这个环境变量中可以指定多个路径（使用冒号 `:` 作为分隔符）。
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Shell Box 3-19: Running example 3.3 by specifying LD_LIBRARY_PATH'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-19：通过指定LD_LIBRARY_PATH运行示例 3.3
- en: This time, the program has successfully been run! This means that the program
    loader has found the shared object file and the dynamic linker has loaded the
    required symbols from it successfully.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，程序已经成功运行！这意味着程序加载器已经找到了共享对象文件，动态链接器已经成功从其中加载所需的符号。
- en: 'Note that, in the preceding shell box, we used the `export` command to change
    the `LD_LIBRARY_PATH`. However, it is common to set the environment variable together
    with the execution command. You can see this in the following shell box. The result
    would be the same for both usages:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的 shell box 中，我们使用了 `export` 命令来更改 `LD_LIBRARY_PATH`。然而，将环境变量与执行命令一起设置是很常见的。你可以在下面的
    shell box 中看到这一点。两种用法的结果将是相同的：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Shell Box 3-20: Running example 3.3 by specifying LD_LIBRARY_PATH as part of
    the same command'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-20：通过指定 LD_LIBRARY_PATH 作为同一命令的一部分运行示例 3.3
- en: By linking an executable with several shared object files, as we did before,
    we tell the system that this executable file needs a number of shared libraries
    to be found and loaded at runtime. Therefore, before running the executable, the
    loader searches for those shared object files automatically, and the required
    symbols are mapped to the proper addresses that are accessible by the process.
    Only then can the processor begin the execution.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将可执行文件与多个共享对象文件链接，就像我们之前做的那样，我们告诉系统这个可执行文件需要找到并加载在运行时所需的多个共享库。因此，在运行可执行文件之前，加载程序会自动搜索这些共享对象文件，并将所需的符号映射到进程可访问的正确地址。只有在这种情况下，处理器才能开始执行。
- en: Manual loading of shared libraries
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动加载共享库
- en: Shared object files can also be loaded and used in a different way, in which
    they are not loaded *automatically* by the loader program (dynamic linker). Instead,
    the programmer will use a set of functions to load a shared object file *manually*
    before using some symbols (functions) that can be found inside that shared library.
    There are applications for this manual loading mechanism, and we'll talk about
    them once we've discussed the example we'll look at in this section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象文件也可以以不同的方式加载和使用，在这种情况下，它们不是由加载程序（动态链接器）自动加载的。相反，程序员将使用一系列函数在需要使用共享库中可找到的一些符号（函数）之前手动加载共享对象文件。这种手动加载机制有一些应用，一旦我们讨论了本节中将要查看的示例，我们就会谈到它们。
- en: '*Example 3.4* demonstrates how to load a shared object file lazily, or manually,
    without having it in the linking step. This example borrows the same logic from
    *example 3.3*, but instead, it loads the shared object file `libgeometry.so` manually
    inside the program.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*Example 3.4* 展示了如何懒加载或手动加载共享对象文件，而不在链接步骤中包含它。这个例子借鉴了 *example 3.3* 的相同逻辑，但不同之处在于它手动在程序内部加载共享对象文件
    `libgeometry.so`。'
- en: 'Before going through *example 3.4*, we need to produce `libgeometry.so` a bit
    differently in order to make *example 3.4* work. To do this, we have to use the
    following command in Linux:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入 *example 3.4* 之前，我们需要以不同的方式生成 `libgeometry.so`，以便 *example 3.4* 能够工作。为此，我们必须在
    Linux 中使用以下命令：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 3-21: Linking the geometry shared object file against the standard
    math library'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-21：将几何共享对象文件链接到标准数学库
- en: Looking at the preceding command, you can see a new option, `-lm`, which tells
    the linker to link the shared object file against the standard math library, `libm.so`.
    That is done because when we load `libgeometry.so` manually, its dependencies
    should, somehow, be loaded automatically. If they're not, then we will get errors
    about the symbols that are required by `libgeometry.so` itself, such as `cos`
    or `sqrt`. Note that we won't link the final executable file with the math standard
    library, and it will be resolved automatically by the loader when loading `libgeometry.so`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的命令，你可以看到一个新选项 `-lm`，它告诉链接器将共享对象文件链接到标准数学库 `libm.so`。这样做是因为当我们手动加载 `libgeometry.so`
    时，它的依赖项应该以某种方式自动加载。如果不是这样，那么我们将得到关于 `libgeometry.so` 本身所需的符号的错误，例如 `cos` 或 `sqrt`。请注意，我们不会将最终的可执行文件与数学标准库链接，它将在加载
    `libgeometry.so` 时由加载程序自动解析。
- en: 'Now that we have a linked shared object file, we can proceed to *example 3.4*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了链接的共享对象文件，我们可以继续进行*示例3.4*：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 3-8 [ExtremeC_examples_chapter3_4.c]: Example 3.4 loading the geometry
    shared object file manually'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 3-8 [ExtremeC_examples_chapter3_4.c]：示例3.4手动加载几何共享对象文件
- en: Looking at the preceding code, you can see how we have used the functions `dlopen`
    and `dlsym` to load the shared object file and then find the symbol `convert_to_2d_polar_pos`
    in it. The function `dlsym` returns a function pointer, which can be used to invoke
    the target function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的代码，你可以看到我们是如何使用`dlopen`和`dlsym`函数来加载共享对象文件，并在其中找到`convert_to_2d_polar_pos`符号。`dlsym`函数返回一个函数指针，可以用来调用目标函数。
- en: It is worth noting that the preceding code searches for the shared object file
    in `/opt/geometry`, and if there is no such object file, then an error message
    is shown. Note that in macOS, the shared object files end in the `.dylib` extension.
    Therefore, the preceding code should be modified in order to load the file with
    the correct extension.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，前面的代码在`/opt/geometry`中搜索共享对象文件，如果没有这样的对象文件，则会显示错误信息。请注意，在macOS中，共享对象文件的扩展名以`.dylib`结尾。因此，前面的代码应该修改为加载具有正确扩展名的文件。
- en: 'The following command compiles the preceding code and runs the executable file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令编译了前面的代码并运行可执行文件：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Shell Box 3-22: Running example 3.4'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 3-22：运行示例3.4
- en: As you can see, we did not link the program with the file `libgeometry.so`.
    We didn't do this because we want to instead load it manually when it is needed.
    This method is often referred to as the *lazy loading* of shared object files.
    Yet, despite the name, in certain scenarios, lazy loading the shared object files
    can be really useful.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们没有将程序与`libgeometry.so`文件链接。我们没有这样做是因为我们希望在需要时手动加载它。这种方法通常被称为共享对象文件的*延迟加载*。尽管名称如此，但在某些场景下，延迟加载共享对象文件可能非常有用。
- en: One such case is when you have different shared object files for different implementations
    or versions of the same library. Lazy loading gives you increased freedom to load
    the desired shared objects according to your own logic and when it is needed,
    instead of having them automatically loaded at load time, where you have less
    control over them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是当你有不同的共享对象文件用于同一库的不同实现或版本时。延迟加载让你有更大的自由度，可以根据自己的逻辑和需要加载所需的共享对象，而不是在加载时自动加载，那时你对它们的控制较少。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter mainly talked about various types of object files, as products
    of a C/C++ project after building. As part of this chapter, we covered the following points:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论了各种类型的对象文件，它们是C/C++项目构建后的产物。作为本章的一部分，我们涵盖了以下内容：
- en: We discussed the API and ABI, along with their differences.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了API和ABI，以及它们之间的区别。
- en: We went through various object file formats and looked at a brief history of
    them. They all share the same ancestor, but they have changed in their specific
    paths to become what they are today.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了各种对象文件格式，并简要回顾了它们的历史。它们都有相同的祖先，但它们在特定的路径上发生了变化，成为了今天的模样。
- en: We talked about relocatable object files and their internal structure regarding
    ELF relocatable object files.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了可重定位对象文件及其内部结构，特别是关于ELF可重定位对象文件。
- en: We discussed executable object files and the differences between them and relocatable
    object files. We also took a look at an ELF executable object file.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了可执行对象文件，以及它们与可重定位对象文件之间的区别。我们还查看了一个ELF可执行对象文件。
- en: We showed static and dynamic symbol tables and how their content can be read
    using some command-line tools.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了静态和动态符号表，以及如何使用一些命令行工具读取它们的内容。
- en: We discussed static linking and dynamic linking and how various symbol tables
    are looked up in order to produce the final binary or execute a program.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了静态链接和动态链接，以及如何查找各种符号表以生成最终的二进制文件或执行程序。
- en: We discussed static library files and the fact that they are just archive files
    that contain a number of relocatable object files.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了静态库文件，以及它们实际上是包含多个可重定位对象文件的归档文件。
- en: Shared object files (dynamic libraries) were discussed and we demonstrated how
    they can be made out of a number of relocatable object files.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了共享对象文件（动态库），并演示了如何将多个可重定位对象文件组合成它们。
- en: We explained what position-independent code is and why the relocatable object
    files participating in the creation of a shared library must be position-independent.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了什么是位置无关代码以及为什么参与创建共享库的可重定位目标文件必须是位置无关的。
- en: In the following chapter, we will go through the memory structure of a process;
    another key topic in C/C++ programming. The various memory segments will be described
    as part of the next chapter and we'll see how we can write code that has no memory
    issues in it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨进程的内存结构；这是C/C++编程中的另一个关键主题。下一章将描述各种内存段，我们将看到如何编写没有内存问题的代码。
