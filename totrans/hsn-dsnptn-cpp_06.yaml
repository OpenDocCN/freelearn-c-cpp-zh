- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Understanding Type Erasure
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型擦除
- en: Type erasure is often seen as a mysterious, enigmatic programming technique.
    It is not exclusive to C++ (most tutorials on type erasure use Java for their
    examples). The goal of this chapter is to lift the shroud of mystery and teach
    you what type erasure is and how to use it in C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除通常被视为一种神秘、神秘的编程技术。它不仅限于 C++（大多数关于类型擦除的教程都使用 Java 作为示例）。本章的目标是揭开神秘的面纱，教您什么是类型擦除以及如何在
    C++ 中使用它。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is type erasure?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型擦除？
- en: Is type erasure a design pattern, or an implementation technique?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型擦除是设计模式，还是实现技术？
- en: How can we implement type erasure?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何实现类型擦除？
- en: What design and performance considerations must be taken into account when deciding
    to use type erasure? What other guidelines can be offered for the use of type
    erasure?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定使用类型擦除时，必须考虑哪些设计和性能方面的因素？对于类型擦除的使用，还可以提供哪些其他指导方针？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Example code can be found at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06)
- en: 'You will need the Google Benchmark library installed and configured, details
    for which can be found here: [https://github.com/google/benchmark](https://github.com/google/benchmark)
    (see [*Chapter 4*](B19262_04.xhtml#_idTextAnchor152), *Swap - From Simple* *to
    Subtle*)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装和配置 Google Benchmark 库，具体细节可以在此处找到：[https://github.com/google/benchmark](https://github.com/google/benchmark)（参见[*第4章*](B19262_04.xhtml#_idTextAnchor152)，*从简单到微妙*）
- en: What is type erasure?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型擦除？
- en: '**Type erasure**, in general, is a programming technique by which the explicit
    type information is removed from the program. It is a type of abstraction that
    ensures that the program does not explicitly depend on some of the data types.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型擦除**，一般而言，是一种编程技术，通过该技术从程序中移除显式的类型信息。这是一种抽象类型，确保程序不显式依赖于某些数据类型。'
- en: This definition, while perfectly correct, also serves perfectly to surround
    type erasure in mystery. It does so by employing a sort of circular reasoning—it
    dangles before you the hope for something that, at first glance, appears impossible—a
    program written in a strongly typed language that does not use the actual types.
    How can this be? Why, by abstracting away the type, of course! And so, the hope
    and the mystery lives on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义虽然完全正确，但也完美地服务于将类型擦除笼罩在神秘之中。它通过一种循环推理的方式做到这一点——在你面前悬挂着一种看似不可能的希望——用强类型语言编写的程序实际上不使用类型。这怎么可能？当然是通过抽象掉类型！因此，希望和神秘得以延续。
- en: It is hard to imagine a program that uses types without explicitly mentioning
    them (at least a C++ program; there are certainly languages where all types are
    not final until runtime).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个不明确提及类型的程序（至少是一个 C++ 程序；当然，肯定有语言在运行时所有类型都不是最终的）。
- en: So, we begin by demonstrating what is meant by type erasure using an example.
    This should allow us to gain an intuitive understanding of type erasure, which,
    in the later sections of this chapter, we will develop and make more rigorous.
    The aim here is to increase the level of abstraction—instead of writing some type-specific
    code, perhaps several versions of it for different types, we can write just one
    version that is more abstract, and expresses the concept—for example, instead
    of writing a function whose interface expresses the concept *sort an array of
    integers*, we want to write a more abstract function, *sort* *any array*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先通过一个示例来展示类型擦除的含义。这应该能让我们对类型擦除有一个直观的理解，在本书的后续章节中，我们将对其进行发展和完善。这里的目的是提高抽象级别——而不是编写一些特定类型的代码，可能为不同类型编写几个版本，我们可以编写一个更抽象的版本，表达概念——例如，而不是编写一个接口表达“对整数数组进行排序”的概念的函数，我们希望编写一个更抽象的函数，“排序”任何数组。
- en: Type erasure by example
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例进行类型擦除
- en: We will go through a detailed explanation of what type erasure is and how it
    is accomplished in C++. But first, let’s see what a program that has had the explicit
    type information removed from it looks like.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细解释什么是类型擦除以及如何在 C++ 中实现它。但首先，让我们看看一个从程序中移除了显式类型信息的程序是什么样的。
- en: 'We start with a very simple example of using a unique pointer, `std::unique_ptr`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个使用唯一指针的简单例子开始，`std::unique_ptr`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an owning pointer (see [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110),
    *Memory and Ownership*)—the entity containing this pointer, such as an object
    or a functional scope, also controls the lifetime of the integer we allocated,
    and is responsible for its deletion. The deletion is not explicitly visible in
    the code and will happen when the `p` pointer is deleted (for example, when it
    goes out of scope). The way this deletion will be accomplished is also not explicitly
    visible—by default, `std::unique_ptr` deletes the object it owns using `operator
    delete`, or, more precisely, by invoking `std::default_delete`, which, in turn,
    calls `operator delete`. What if we do not want to use the regular standard `delete`?
    For example, we may have objects that are allocated on our own heap:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个拥有指针（参见[*第3章*](B19262_03.xhtml#_idTextAnchor110)，*内存和所有权*）——包含此指针的实体，例如对象或函数作用域，也控制我们分配的整数的生命周期，并负责其删除。删除在代码中不是显式的——当`p`指针被删除时（例如，当它超出作用域时）将发生删除。这种删除方式也不是显式的——默认情况下，`std::unique_ptr`使用`operator
    delete`删除它拥有的对象，或者更准确地说，通过调用`std::default_delete`，它反过来调用`operator delete`。如果我们不想使用常规的标准`delete`呢？例如，我们可能有在自定义堆上分配的对象：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Allocation is no problem, with the help of the overloaded `operator new`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 分配没有问题，借助重载的`operator new`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This syntax invokes the two-argument `operator new` function; the first argument
    is always the size and is added by the compiler, and the second argument is the
    heap pointer. Since we have such an overload declared, it will be invoked and
    will return the memory allocated from the heap. But we have not done anything
    to change the way the object is deleted. The regular `operator delete` function
    will be called and will attempt to return to the global heap some memory that
    wasn’t allocated from there. The result is likely to be memory corruption, and
    probably a crash. We could define an `operator delete` function with the same
    additional argument, but it does us no good here—unlike `operator new`, there
    is no place to pass arguments to `delete` (you will often see such an `operator
    delete` function defined anyway, and it should behave as such, but it has nothing
    to do with any `delete` you see in the program; it is used in the stack unwinding
    if the constructor throws an exception).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法调用了双参数的`operator new`函数；第一个参数总是大小，由编译器添加，第二个参数是堆指针。由于我们声明了这样的重载，它将被调用，并返回从堆中分配的内存。但我们没有做任何改变对象删除方式的事情。常规的`operator
    delete`函数将被调用，并尝试将一些未从那里分配的内存返回给全局堆。结果很可能是内存损坏，并且可能崩溃。我们可以定义一个具有相同额外参数的`operator
    delete`函数，但这在这里对我们没有好处——与`operator new`不同，没有地方可以传递参数给`delete`（你经常会看到定义这样的`operator
    delete`函数，并且它应该这样行为，但它与程序中看到的任何`delete`都没有关系；它用于构造函数抛出异常时的栈回溯）。
- en: 'Somehow, we need to tell the unique pointer that this particular object is
    to be deleted differently. It turns out that `std::unique_ptr` has a second `template`
    argument. You usually don’t see it because it defaults to `std::default_delete`,
    but that can be changed and a custom `deleter` object can be defined to match
    the allocation mechanism. The `deleter` has a very simple interface—it needs to
    be callable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，我们需要告诉唯一指针，这个特定的对象要以不同的方式被删除。结果发现`std::unique_ptr`有一个第二个`template`参数。你通常看不到它，因为它默认为`std::default_delete`，但这是可以改变的，可以定义一个自定义的`deleter`对象来匹配分配机制。`deleter`有一个非常简单的接口——它需要是可调用的：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `std::default_delete` policy is implemented pretty much like that and simply
    calls `delete` on the `p` pointer. Our custom `deleter` will need a non-trivial
    constructor to store the pointer to the heap. Note that, while the `deleter` needs,
    in general, to be able to delete an object of any type that can be allocated,
    it does not have to be a template class. A non-template class with a template
    member function will do just as well, as long as the data members of the class
    do not depend on the deleted type. In our case, the data members depend only on
    the type of the heap, but not on what is being deleted:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::default_delete`策略的实现基本上就是这样，它简单地调用`p`指针上的`delete`。我们的自定义`deleter`需要一个非平凡的构造函数来存储堆指针。请注意，虽然`deleter`通常需要能够删除任何可以分配的类型的对象，但它不必是一个模板类。一个具有模板成员函数的非模板类也可以做到这一点，只要类的数据成员不依赖于被删除的类型。在我们的情况下，数据成员只依赖于堆的类型，而不是被删除的内容：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `deleter` has to perform the equivalent of both functions of the standard
    `operator` `delete` function—it has to invoke the destructor of the object being
    deleted, then it must deallocate the memory that was allocated for this object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleter`必须执行标准`operator delete`函数的两个函数的等效操作——它必须调用被删除对象的析构函数，然后它必须释放为该对象分配的内存。'
- en: 'Now that we have the appropriate `deleter`, we can finally use `std::unique_ptr`
    with our own heap:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了合适的`deleter`，我们终于可以使用我们自己的堆来使用`std::unique_ptr`：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that `deleter` objects are often created on demand, at the point of allocation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`deleter`对象通常在需要时创建，即在分配点：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Either way, the `deleter` must be no-throw-copyable or no-throw-movable; that
    is, it must have a copy constructor or a move constructor, and the constructor
    must be declared `noexcept`. The built-in types, such as raw pointers, are, of
    course, copyable, and the default compiler-generated constructor does not throw.
    Any aggregate type combining one or more of these types as data members, such
    as our `deleter`, has a default constructor that also does not throw (unless it
    has been redefined, of course).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，`deleter`都必须是不可抛出复制的或不可抛出移动的；也就是说，它必须有一个复制构造函数或移动构造函数，并且构造函数必须声明为`noexcept`。内置类型，如原始指针，当然是可复制的，并且默认的编译器生成的构造函数不会抛出异常。任何将一个或多个这些类型作为数据成员的组合聚合类型，例如我们的`deleter`，都有一个默认构造函数，也不会抛出异常（除非它已经被重新定义，当然）。
- en: 'Note that the `deleter` is a part of the unique pointer’s type. Two unique
    pointers that own objects of the same type, but have different deleters, are different
    types:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`deleter`是唯一指针类型的一部分。拥有相同类型对象但具有不同`deleter`的唯一指针是不同的类型：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, the unique pointer must be constructed with the `deleter` of the
    right type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，唯一指针必须使用正确类型的`deleter`来构造：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As an aside, while experimenting with unique pointers of different types, you
    might notice that the two pointers in the preceding code, `p` and `q`, while not
    assignable, are comparable: `p == q` compiles. This happens because the `comparison`
    operator is actually a template—it accepts two unique pointers of different types
    and compares the underlying raw pointers (if that type differs as well, the compilation
    error is likely to not mention the unique pointer at all, but instead, to say
    something about comparing pointers to distinct types without a cast).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在实验不同类型的唯一指针时，你可能会注意到前面代码中的两个指针`p`和`q`，虽然不可赋值，但可以比较：`p == q`可以编译。这是因为比较运算符实际上是一个模板——它接受两种不同类型的唯一指针并比较其底层原始指针（如果该类型也不同，编译错误可能不会提到唯一指针，而是说一些关于比较没有转换的不同类型的指针的事情）。
- en: 'Now let’s do the same example, but with the shared pointer, `std::shared_ptr`.
    First, we point the shared pointer to an object constructed with the regular `operator
    new` function as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用共享指针`std::shared_ptr`来做同样的例子。首先，我们将共享指针指向使用常规`operator new`函数构造的对象，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For comparison, we left the unique pointer declaration there as well. The two
    smart pointers are declared and constructed in exactly the same way. And now,
    in the following code block, the shared pointer to an object allocated on our
    `heap`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，我们也将唯一指针的声明留在了那里。这两个智能指针以完全相同的方式声明和构造。现在，在下面的代码块中，是分配在我们`heap`上的对象的共享指针：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you see a difference—the shared pointer that was created with a custom `deleter`
    is, nonetheless, of the same type as the one that uses the default `deleter`!
    In fact, all shared pointers to `int` have the same type, `std::shared_ptr<int>`—the
    template does not have another argument. Think this through—the `deleter` is specified
    in the constructor but is used only in the destructor, therefore it must be stored
    inside the smart pointer object until needed. There is no way to recover it later
    if we lose the object that was given to us during construction. Both `std::shared_ptr`
    and `std::unique_ptr` must store the `deleter` object of an arbitrary type inside
    the pointer object itself. But only the `std::unique_ptr` class has the deleter
    information in its type. The `std::shared_ptr` class is the same for all deleter
    types. Going back to the very beginning of this section, the program that uses
    `std::shared_ptr<int>` does not have any explicit information about the deleter
    type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到区别了——使用自定义`deleter`创建的共享指针，尽管如此，其类型与使用默认`deleter`的指针相同！实际上，所有指向`int`的共享指针都具有相同的类型，`std::shared_ptr<int>`——模板没有另一个参数。仔细思考一下——`deleter`在构造函数中指定，但仅在析构函数中使用，因此它必须存储在智能指针对象中，直到需要时。如果我们失去了在构造过程中给出的对象，就没有办法恢复它。`std::shared_ptr`和`std::unique_ptr`都必须在指针对象内部存储任意类型的`deleter`对象。但只有`std::unique_ptr`类在其类型中包含删除器信息。`std::shared_ptr`类对所有删除器类型都是相同的。回到本节的开头，使用`std::shared_ptr<int>`的程序没有关于删除器类型的任何显式信息。
- en: 'This type has been erased from the program. This, then, is what a type-erased
    program looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型已经被从程序中擦除。这就是类型擦除程序的样子：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We spent so much time dissecting `std::shared_ptr` because it provides a very
    simple example of type erasure, especially since we can contrast it with `std::unique_ptr`
    which has to solve exactly the same problem but chooses the opposite approach.
    This simple example, however, does not highlight the design implications of choosing
    type erasure and does not illustrate what design problems this pattern solves.
    For that, we should look at the quintessential type-erased object in C++: `std::function`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花费了大量的时间来剖析`std::shared_ptr`，因为它提供了一个非常简单的类型擦除示例，尤其是当我们将其与必须解决相同问题但选择相反方法的`std::unique_ptr`进行对比时。然而，这个简单的例子并没有突出选择类型擦除的设计含义，也没有说明这个模式解决了哪些设计问题。为了了解这一点，我们应该看看C++中典型的类型擦除对象：`std::function`。
- en: From example to generalization
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从例子到一般化
- en: 'In C++, `std::function` is a general-purpose polymorphic function wrapper,
    or a general callable object. It is used to store any callable entity such as
    a function, a lambda expression, a functor (an object with the `operator()`),
    or a member function pointer. The only requirement for these different callable
    entities is that they must have the same call signature, i.e., accept the same
    arguments and return the result of the same type. The signature is specified when
    a particular `std::function` object is declared:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`std::function`是一个通用的多态函数包装器，或者是一个通用的可调用对象。它用于存储任何可调用实体，如函数、lambda表达式、仿函数（具有`operator()`的对象）或成员函数指针。这些不同可调用实体的唯一要求是它们必须具有相同的调用签名，即接受相同的参数并返回相同类型的结果。签名是在声明特定`std::function`对象时指定的：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have just declared a callable that can be invoked with two arguments, `long`
    and `double` (or, to be more precise, with any two arguments convertible to `long`
    and `double`), and returns a result that can be converted to `int`. What does
    it do with the arguments and what is the result? That is determined by the concrete
    callable entity that is assigned to `f`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明了一个可以接受两个参数（`long`和`double`，或者更准确地说，接受任何两个可以转换为`long`和`double`的参数）的可调用对象，并且返回的结果可以被转换为`int`。它对参数做了什么，结果是什么？这取决于分配给`f`的具体可调用实体：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we first assign a non-member function `f1` to `f`; now calling
    `f(s)` returns the capacity of the string `s` since that’s what `f1` does. Next,
    we change `f` to contain a lambda expression; calling `f(s)` now invokes that
    expression. The only thing these two functions have in common is the interface:
    they accept the same arguments and have the same result types. Finally, we assign
    a member function pointer to `f`; while the function `std::string::size()` takes
    no arguments, all member functions have an implicit first argument which is a
    reference to the object itself, so it fits the requirement on the interface.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先将一个非成员函数`f1`赋值给`f`；现在调用`f(s)`返回字符串`s`的容量，因为这就是`f1`所做的事情。接下来，我们将`f`改为包含一个lambda表达式；现在调用`f(s)`将调用该表达式。这两个函数唯一共同之处是接口：它们接受相同的参数并具有相同的返回类型。最后，我们将成员函数指针赋值给`f`；虽然`std::string::size()`函数不接受任何参数，但所有成员函数都有一个隐含的第一个参数，即对对象的引用，因此它符合接口的要求。
- en: 'We can now see type erasure in its more general form: it is an abstraction
    for many different implementations that all provide the same behavior. Let us
    consider what design capabilities it opens.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到类型擦除的更一般形式：它是对许多不同实现提供相同行为的抽象。让我们考虑它打开了哪些设计能力。
- en: Type erasure as a design pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除作为设计模式
- en: 'We have already seen how type erasure manifests itself in a program: the code
    expects certain semantics behavior, but, instead of dealing with specific types
    that provide it, we use an abstraction and “erase” the properties of those types
    that are not relevant to the task at hand (starting with the name of the type).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了类型擦除在程序中的表现：代码期望某些语义行为，但不是处理提供它的特定类型，而是使用一个抽象并“擦除”那些与当前任务无关的类型属性（从类型的名称开始）。
- en: In this way, type erasure has attributes of several other design patterns, but
    it’s not equivalent to any of them. It could reasonably be considered a design
    pattern in its own right. So, what does type erasure offer as a design pattern?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，类型擦除具有其他几个设计模式的属性，但它并不等同于任何一种。它可以合理地被认为是一种独立的设计模式。那么，类型擦除作为设计模式提供了什么？
- en: 'In type erasure, we find an abstract expression of certain behavior, such as
    a function call, that can be used to separate the interface from the implementation.
    So far, this sounds very similar to inheritance. Recall now how, at the end of
    the last section, we made a `std::function` object invoke several completely different
    callables: a function, a lambda expression, and a member function. This illustrates
    the fundamental difference between type erasure and inheritance: with inheritance,
    the base class determines the abstract behavior (the interface), and any class
    that needs to implement that interface must be derived from the same base. With
    type erasure, there is no such requirement: the types that provide the common
    behavior do not have to form any particular hierarchy; in fact, they need not
    be classes at all.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型擦除中，我们发现了一种对某些行为（如函数调用）的抽象表达，可以用来将接口与实现分离。到目前为止，这听起来非常类似于继承。现在回想一下，在上一个部分的结尾，我们是如何让一个`std::function`对象调用几个完全不同的可调用对象的：一个函数、一个lambda表达式和一个成员函数。这说明了类型擦除与继承之间的基本区别：在继承中，基类决定了抽象行为（接口），任何需要实现该接口的类都必须从同一个基类派生。而在类型擦除中，没有这样的要求：提供共同行为的类型不需要形成任何特定的层次结构；实际上，它们甚至不需要是类。
- en: 'It can be said that type erasure offers a non-intrusive way to separate the
    interface from the implementation. By “intrusive” we mean the fact that we must
    change a type in order to use the abstraction: for example, we may have a class
    that has the desired behavior, but, in order to be used polymorphically, it must
    also inherit from the common base class. This is the “intrusion” – the enforced
    change we must make to the otherwise perfectly good class in order to make it
    usable as a concrete implementation of a certain abstract interface. As we have
    just seen, type erasure has no such need. As long as the class (or any other type)
    has the desired behavior – usually, a way to invoke it in a function call-like
    manner with certain arguments – it can be used to implement this behavior. The
    other properties of the type are not relevant for supporting the interface we
    are focusing on and are “erased.”'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说类型擦除提供了一种非侵入式的方法来分离接口和实现。当我们说“侵入式”时，指的是我们必须改变类型才能使用抽象：例如，我们可能有一个具有所需行为的类，但为了能够多态地使用，它还必须继承自公共基类。这就是“侵入”
    —— 我们必须对原本非常好的类进行强制更改，以便使其能够作为某个抽象接口的具体实现使用。正如我们刚才看到的，类型擦除没有这样的需求。只要类（或任何其他类型）具有所需的行为——通常，以函数调用类似的方式使用某些参数来调用它——就可以用来实现这种行为。类型的其他属性对我们关注的接口支持并不相关，并且被“擦除”。
- en: We can also say that type erasure provides “external polymorphism:” there is
    no unifying hierarchy required, and the set of types that can be used to implement
    a particular abstraction is extensible, not limited to just classes derived from
    a common base.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说类型擦除提供了“外部多态性”：不需要统一的层次结构，可以用来实现特定抽象的类型集是可扩展的，不仅限于从公共基类派生的类。
- en: So, why doesn’t type erasure completely replace inheritance in C++? To some
    extent, it is tradition; don’t be too fast to kick tradition, though – the other
    name for tradition is “convention,” and conventional code is also familiar, easy-to-understand
    code. But there are two “real” reasons as well. The first one is performance.
    We will study the implementations of type erasure and their respective performance
    later in this chapter; however, without spoiling anything, we can say that high-performance
    implementations of type erasure became available only recently. The second one
    is convenience, and we can see that already. If we need to declare an abstraction
    for a whole set of related operations, we can declare a base class with the necessary
    virtual member functions. If we use a `std::function` approach, a type-erased
    implementation would have to handle each of these operations separately. As we
    will see soon, this is not a requirement – we can implement a type-erased abstraction
    for a whole set of operations at once. However, doing it with inheritance is easier.
    Also, remember that all concrete types hiding behind the type erasure must provide
    the required behavior; if we require that all these types support several different
    member functions, it is more likely that they are going to be coming from the
    same hierarchy for other reasons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么类型擦除不能完全取代C++中的继承？在某种程度上，这是传统；不过，不要过于迅速地摒弃传统——传统的另一个名字是“惯例”，惯例代码也是熟悉且易于理解的代码。但还有两个“真实”的原因。第一个是性能。我们将在本章后面研究类型擦除的实现及其相应的性能；然而，不提前剧透，我们可以这样说，高性能的类型擦除实现最近才变得可用。第二个原因是便利性，我们已经在其中看到了这一点。如果我们需要为一系列相关操作声明一个抽象，我们可以声明一个具有必要虚拟成员函数的基类。如果我们使用`std::function`方法，类型擦除的实现将不得不分别处理这些操作中的每一个。正如我们很快就会看到的，这不是一个要求——我们可以一次性实现一组操作的类型擦除抽象。然而，使用继承来做这件事更容易。此外，记住，所有隐藏在类型擦除背后的具体类型都必须提供所需的行为；如果我们要求所有这些类型支持多个不同的成员函数，那么它们更有可能来自相同的层次结构，出于其他原因。
- en: Type erasure as an implementation technique
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型擦除作为一种实现技术
- en: Not every use of type erasure has a grand design idea behind it. Often, type
    erasure is used purely as an implementation technique (the same is true for inheritance,
    and we are about to see one such use). In particular, type erasure is a great
    tool for breaking dependencies between components of a large system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个类型擦除的使用都背后有一个宏伟的设计理念。通常，类型擦除纯粹作为一种实现技术（继承也是如此，我们即将看到这样一个用法）。特别是，类型擦除是打破大型系统组件之间依赖关系的一个伟大工具。
- en: 'Here is a simple example. We are building a large distributed software system,
    so one of our core components is the network communication layer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。我们正在构建一个大型分布式软件系统，因此我们的核心组件之一是网络通信层：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is, of course, a very simplified and abstract view of a component that
    is, at best, non-trivial, but sending data across the network is not what we want
    to focus on now. The important point is that this is one of our foundational components,
    the rest of the system depends on it. We may have several different programs built
    as a part of our software solution; all of them include this communication library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常简化和抽象的组件视图，这个组件至多是非平凡的，但我们现在不想关注通过网络发送数据。重要的是，这是我们的基础组件之一，系统的其余部分都依赖于它。我们可能有几个不同的程序作为我们的软件解决方案的一部分构建；它们都包含这个通信库。
- en: 'Now, in one specific application, we have a need to process the data packets
    before and after they are sent across the network; it could be a high-security
    system that requires advanced encryption, or it could be the only tool in our
    system that is designed to work over unreliable networks and needs to insert error
    correction codes. The point is, the designer of the network layer is now asked
    to introduce a dependency on some external code that comes from a higher-level
    application-specific component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某个具体的应用程序中，我们需要在网络发送数据包之前和之后处理这些数据包；这可能是一个需要高级加密的高安全性系统，或者它可能是我们系统中唯一设计用于在不可靠网络上工作并需要插入错误纠正代码的工具。重点是，网络层的开发者现在被要求引入对来自更高层应用程序特定组件的外部代码的依赖：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While this code looks simple, it is a dependency nightmare: the low-level library
    now has to be built with the `apply_processing()` function from the specific application.
    Even worse, all other programs that do not require this functionality must still
    be compiled and linked with this code, even if they never set `needs_processing`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码看起来很简单，但它却是一个依赖噩梦：低级库现在必须使用特定应用程序的`apply_processing()`函数来构建。更糟糕的是，所有不需要这个功能的其他程序仍然必须编译和链接这段代码，即使它们从未设置`needs_processing`。
- en: 'While this problem can be handled the “old school” way – with some function
    pointers or (worse) global variables, type erasure offers an elegant solution:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个问题可以用“老式”的方法处理——使用一些函数指针或（更糟的是）全局变量，但类型擦除提供了一个优雅的解决方案：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is an example of the strategy design pattern, where the implementation
    of a particular behavior can be chosen at run-time. Now, any higher-level component
    of the system can specify its own processor function (or a lambda expression,
    or a callable object) without forcing the rest of the software to link with their
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个策略设计模式的例子，其中特定行为的实现可以在运行时选择。现在，系统的任何更高层组件都可以指定它自己的处理器函数（或lambda表达式，或可调用对象），而无需强迫软件的其他部分与其代码链接：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we know what type erasure looks like and how it can help decouple components,
    both as a design pattern and as a convenient implementation technique, there is
    only one more question left - how does it work?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了类型擦除的样子以及它如何作为设计模式和方便的实现技术帮助解耦组件，只剩下最后一个问题——它是如何工作的？
- en: How is type erasure implemented in C++?
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除在C++中是如何实现的？
- en: We have seen what type erasure looks like in C++. Now we understand what it
    means for a program to not explicitly depend on a type. But the mystery remains—the
    program makes no mention of the type, and yet, at the right time, invokes an operation
    on the type it knows nothing about. How? That is what we are about to see.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了C++中类型擦除的样子，现在我们理解了程序不显式依赖于类型意味着什么。但谜团仍然存在——程序没有提及类型，然而，在正确的时间，它却调用了它一无所知的类型的操作。如何？这正是我们即将看到的。
- en: Very old type erasure
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非常古老的擦除类型
- en: 'The idea of writing a program without explicit type information is certainly
    not new. In fact, it predates object-oriented programming and the notion of objects
    by a long time. Consider this C program (no C++ here) as an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编写没有显式类型信息的程序的想法当然不是新的。实际上，它比面向对象编程和对象的概念要早得多。以这个C程序（这里没有C++）为例：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now remember the function declaration for `qsort` from the standard `C` library:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住标准`C`库中`qsort`函数的声明：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, while we are using it to sort an array of integers, the `qsort` function
    itself does not have any explicit types—it uses `void*` to pass in the array to
    be sorted. Similarly, the comparison function takes two `void*` pointers and has
    no explicit type information in its declaration. Of course, at some point, we
    need to know how to compare the real types. In our C program, the pointers that
    could, in theory, point to anything, are reinterpreted as pointers to integers.
    This action, which reverses the abstraction, is known as **reification**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们使用它来对整数数组进行排序，但`qsort`函数本身没有任何显式类型——它使用`void*`来传递要排序的数组。同样，比较函数接受两个`void*`指针，其声明中没有显式类型信息。当然，在某个时候，我们需要知道如何比较实际类型。在我们的C程序中，理论上可以指向任何内容的指针被重新解释为指向整数的指针。这种反转抽象的行为被称为**具体化**。
- en: In C, restoring concrete types is entirely the responsibility of the programmer—our
    `less()` comparison function does, in fact, only compare integers, but it is impossible
    to deduce so from the interface. Neither is it possible to validate, at runtime,
    that the correct types are used throughout the program, and it is certainly not
    possible for the program to automatically select the right comparison operation
    for the actual type at runtime.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，恢复具体类型完全是程序员的职责——我们的`less()`比较函数实际上只比较整数，但从接口中无法推断出来。同样，在程序运行时验证整个程序中是否使用了正确的类型也是不可能的，程序自动选择运行时实际类型的正确比较操作当然也是不可能的。
- en: 'Nonetheless, this simple example lets us penetrate the magic of type erasure:
    the general code indeed does not depend on the concrete type that was erased,
    but that type is hidden in the code of a function called through the type-erased
    interface. In our example, it was the comparison function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个简单的例子让我们揭开了类型擦除的神秘面纱：一般代码确实不依赖于被擦除的具体类型，但这种类型隐藏在通过类型擦除接口调用的函数的代码中。在我们的例子中，是比较函数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The calling code knows nothing about the type `int`, but the implementation
    of `less()` operates on this type. The type is “hidden” in the code of a function
    invoked through the type-agnostic interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码对类型`int`一无所知，但`less()`函数的实现操作的是这个类型。类型“隐藏”在通过类型无关接口调用的函数的代码中。
- en: The major downside of this C approach is that the programmer is wholly responsible
    for ensuring that all the pieces of the type-erased code are consistent; in our
    example, it is the sorted data and the comparison function that must refer to
    the same type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种C语言方法的重大缺点是程序员必须完全负责确保所有类型擦除代码的各个部分保持一致；在我们的例子中，这是排序数据和比较函数必须引用相同的类型。
- en: 'In C++, we can do a lot better, but the idea is still the same: the erased
    type is reified by the implementation of some type-specific code that is invoked
    through the type-agnostic interface. The key difference is that we are going to
    force the compiler to generate this code for us. There are, fundamentally, two
    techniques that can be used. The first one relies on run-time polymorphism (inheritance),
    and the second one uses template magic. Let us start with the polymorphic implementation.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们可以做得更好，但理念仍然是相同的：被擦除的类型通过通过类型无关接口调用的某些特定类型代码的实现而具体化。关键的区别是我们将强迫编译器为我们生成此代码。从根本上讲，有两种技术可以使用。第一种依赖于运行时多态（继承），第二种使用模板魔法。让我们从多态实现开始。
- en: Type erasure using inheritance
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用继承进行类型擦除
- en: 'We’re now going to see how `std::shared_ptr` does its magic. We will do it
    with a simplified example of a smart pointer that focuses specifically on the
    type erasure aspect. It should not surprise you to learn that this is done with
    a combination of generic and object-oriented programming:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到`std::shared_ptr`是如何施展其魔法的。我们将用一个简化的智能指针示例来完成，这个示例专门关注类型擦除方面。了解到这是通过泛型和面向对象编程的组合来完成，你不会感到惊讶：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `smartptr` template has only one type parameter. Since the erased type is
    not part of the smart pointer’s type, it has to be captured in some other object.
    In our case, this object is an instantiation of the nested `smartptr<T>::destroy`
    template. This object is created by the constructor, which is the last point in
    the code where the deleter type is explicitly present. But `smartptr` must refer
    to the `destroy` instance through a pointer whose type does not depend on `destroy`
    (since the `smartptr` object has the same type for all deleters). Therefore, all
    instances of the `destroy` template inherit from the same base class, `destroy_base`,
    and the actual deleter is invoked through a virtual function. The constructor
    is a template that deduces the type of deleter, but the type is only hidden, as
    it’s part of the actual declaration of the specific instantiation of this template.
    The smart pointer class itself, and, in particular, its destructor, where the
    deleter is actually used, really have the deleter type erased. The compile-time
    type detection is used to create a correct-by-construction polymorphic object
    that will rediscover the deleter type at runtime and perform the correct action.
    For that reason, we do not need a dynamic cast, and can use the static cast instead,
    which only works if we know the real derived type (and we do).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`smartptr`模板只有一个类型参数。由于擦除的类型不是智能指针类型的组成部分，它必须被捕获在其他某个对象中。在我们的例子中，这个对象是嵌套的`smartptr<T>::destroy`模板的一个实例化。这个对象是由构造函数创建的，这是代码中显式存在删除器类型的最后一个点。但是`smartptr`必须通过一个不依赖于`destroy`（因为智能指针对象对所有删除器都有相同的类型）的指针来引用`destroy`实例。因此，所有`destroy`模板的实例都继承自同一个基类，`destroy_base`，实际的删除器是通过一个虚拟函数调用的。构造函数是一个模板，它推导出删除器的类型，但这个类型只是隐藏的，因为它实际上是这个模板特定实例化的声明的一部分。智能指针类本身，特别是它的析构函数，实际上使用了删除器类型，进行了擦除。编译时类型检测用于创建一个在运行时重新发现删除器类型并执行正确操作的构造正确性的多态对象。因此，我们不需要动态类型转换，而可以使用静态类型转换，这只有在我们知道实际的派生类型时才有效（我们确实知道）。'
- en: 'The same technique can be used to implement `std::function` and other type-erased
    types, such as the ultimate type-erased class, `std::any` (in C++17 and above).
    This is a class, not a template, but it can hold a value of any type:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以用来实现`std::function`和其他类型擦除类型，例如终极类型擦除类`std::any`（在C++17及以上版本）。这是一个类，而不是模板，但它可以持有任何类型的值：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, without knowing the type, `std::any` cannot provide any interfaces.
    You can store any value in it, and get it back if you know the right type (or
    you can ask for the type and get back a `std::type_info` object).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果不了解类型，`std::any`就无法提供任何接口。你可以将它存储任何值，如果你知道正确的类型（或者你可以请求类型并获取一个`std::type_info`对象）。
- en: 'Before we learn the other (usually more efficient) way to implement type erasure,
    we have to address one glaringly obvious inefficiency in our design: every time
    we create or delete a shared pointer or a `std::function` object that is implemented
    as described above, we must allocate and deallocate memory for the derived object
    that conceals the erased type.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习其他（通常更有效）实现类型擦除的方法之前，我们必须解决我们设计中一个明显低效的问题：每次我们创建或删除一个共享指针或一个按上述方式实现的`std::function`对象时，我们必须为隐藏擦除类型的派生对象分配和释放内存。
- en: Type erasure without memory allocation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无内存分配的类型擦除
- en: 'There are, however, ways to optimize the type-erased pointers (as well as any
    other type-erased data structures) and avoid the additional memory allocation
    that happens when we construct the polymorphic `smartptr::destroy` object. We
    can avoid this allocation, at least sometimes, by pre-allocating a memory buffer
    for these objects. The details of this optimization, as well as its limitations,
    are discussed in [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453), *Local Buffer
    Optimization*. Here is the gist of the optimization:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有方法可以优化类型擦除指针（以及任何其他类型擦除数据结构），并避免在构建多态的`smartptr::destroy`对象时发生的额外内存分配。我们可以通过预先为这些对象分配内存缓冲区来避免这种分配，至少在某些情况下可以这样做。这种优化的细节以及它的限制在[*第10章*](B19262_10.xhtml#_idTextAnchor453)，*本地缓冲区优化*中进行了讨论。以下是优化的要点：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The local buffer optimization does make type-erased pointers and functions a
    lot more efficient, as we will see later in this chapter. Of course, it imposes
    restrictions on the size of the deleter; for this reason, most real-life implementations
    use a local buffer for small enough erased types and dynamic memory for types
    that don’t fit into the buffer. The alternative solution - to assert as shown
    above and force the programmer to increase the buffer – is often embraced in very
    high-performance applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本地缓冲区优化确实使类型擦除指针和函数变得更加高效，正如我们将在本章后面看到的那样。当然，它对删除器的尺寸施加了限制；因此，大多数实际应用使用本地缓冲区来存储足够小的擦除类型，而对于不适合缓冲区的类型则使用动态内存。上述替代方案——断言并强制程序员增加缓冲区——在非常高性能的应用中通常被采用。
- en: 'There are some subtler consequences of the use of this optimization: the deleter
    (or another erased object) is now stored as a part of the class and must be copied
    with the rest of the class. How do we copy an object whose type we no longer know?
    This and other details will have to wait until [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453)*,
    Local Buffer Optimization*. For now, we will use the local buffer optimization
    in the rest of the examples, both to show its use and to simplify the code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种优化的某些细微后果：删除器（或另一个擦除对象）现在作为类的一部分存储，并且必须与类的其余部分一起复制。我们如何复制一个我们不再知道其类型的对象？这个问题和其他细节将留待第[*第10章*](B19262_10.xhtml#_idTextAnchor453)*，本地缓冲区优化*中讨论。现在，我们将继续在其余的示例中使用本地缓冲区优化，以展示其用法并简化代码。
- en: Type erasure without inheritance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无继承的类型擦除
- en: 'There is an alternative implementation of type erasure that does not use an
    internal hierarchy of classes to store the erased type. Instead, the type is captured
    in the implementation of a function, just like it was done in C:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除的另一种实现不使用内部类层次结构来存储擦除类型。相反，类型被捕获在函数的实现中，就像在C中做的那样：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In C++, we make the function a template so the compiler generates instantiations
    for every type `TE` we need:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们将函数做成模板，以便编译器为每个我们需要的类型 `TE` 生成实例：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a somewhat unusual template function: the type parameter cannot be
    deduced from the arguments and must be explicitly specified. We already know that
    this will be done in the constructor of a type-erased class, such as our smart
    pointer: there, we still know the type that is about to be erased. The other very
    important point is that any function generated by the preceding template can be
    invoked through the same function pointer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有些不寻常的模板函数：类型参数不能从参数中推断出来，必须显式指定。我们已经知道这将在类型擦除类的构造函数中完成，例如我们的智能指针：在那里，我们仍然知道即将被擦除的类型。另一个非常重要的点是，由前面的模板生成的任何函数都可以通过相同的函数指针调用：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can see how the type erasure magic works: we have a function pointer
    whose type does not depend on the type `TE` we are erasing. We are going to generate
    a function with an implementation that uses this type and assign it to this pointer.
    When we need to use the erased type `TE`, such as deleting the object with the
    specified deleter, we are going to call a function through this pointer; we can
    do that without knowing what `TE` is. We just have to put this all together into
    a correct-by-construction implementation, and here is our type-erased smart pointer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到类型擦除的魔法是如何工作的：我们有一个函数指针，其类型不依赖于我们正在擦除的类型 `TE`。我们将生成一个使用此类型的实现，并将其分配给此指针。当我们需要使用擦除类型
    `TE` 时，例如使用指定的删除器删除对象，我们将通过这个指针调用一个函数；我们可以做到这一点而无需知道 `TE` 是什么。我们只需将这些全部组合成一个正确构建的实现，这就是我们的类型擦除智能指针：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We store the user-given deleter in a small local buffer; in this example, we
    do not show the alternative implementation for a larger deleter that would require
    dynamic memory allocation. The function template that retains the information
    about the erased type is `invoke_destroy()`. Note that it is a static function;
    static functions can be invoked through a regular function pointer instead of
    a more cumbersome member function pointer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户提供的删除器存储在一个小的本地缓冲区中；在这个例子中，我们没有展示对于需要动态内存分配的较大删除器的替代实现。保留关于擦除类型信息的函数模板是
    `invoke_destroy()`。请注意，它是一个静态函数；静态函数可以通过常规函数指针而不是更繁琐的成员函数指针来调用。
- en: 'In the constructor of the `smartptr` class, we instantiate `invoke_destroy<Deleter>`
    and assign it to the `destroy_` function pointer. We also need a copy of the deleter
    object, since the deleter may contain a state (for example, a pointer to the allocator
    that provided the memory for the object owned by the smart pointer). We construct
    this deleter in the space provided by the local buffer `buf_`. At this point,
    the original `Deleter` type is erased: all we have is a function pointer that
    does not depend on the `Deleter` type and a character array.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`smartptr`类的构造函数中，我们实例化`invoke_destroy<Deleter>`并将其赋值给`destroy_`函数指针。我们还需要删除器对象的副本，因为删除器可能包含状态（例如，指向为智能指针拥有的对象提供内存的分配器的指针）。我们在局部缓冲区`buf_`提供的空间中构建这个删除器。此时，原始的`Deleter`类型已被擦除：我们拥有的只是一个不依赖于`Deleter`类型的函数指针和一个字符数组。
- en: When the time comes to destroy the object owned by the shared pointer, we need
    to invoke the deleter. Instead, we invoke the function through the `destroy_`
    pointer and pass to it the object to be destroyed and the buffer where the deleter
    resides. The erased `Deleter` type is nowhere to be seen, but it is hiding inside
    the specific implementation of `invoke_destroy()`. There, the pointer to the buffer
    is cast back to the type that is actually stored in the buffer (`Deleter`) and
    the deleter is invoked.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要销毁共享指针拥有的对象时，我们需要调用删除器。相反，我们通过`destroy_`指针调用函数，并将要销毁的对象以及删除器所在的缓冲区传递给它。擦除的`Deleter`类型无处可寻，但它隐藏在`invoke_destroy()`的具体实现中。在那里，缓冲区的指针被转换回实际存储在缓冲区中的类型（`Deleter`），然后调用删除器。
- en: 'This example is, perhaps, the most concise demonstration of type erasure machinery
    in C++. But it is not quite equivalent to the example in the previous section
    where we used inheritance. While we invoke the deleter on the object of type `T`
    owned by the smart pointer, we do nothing to destroy the deleter object itself,
    specifically, the copy we stored inside the local buffer. The local buffer is
    not the problem here: if we dynamically allocated the memory instead, it would
    still be accessed through a generic pointer such as `char*` or `void*`, and we
    would now know how to properly delete it. For that, we need another function that
    can reify the original type. Well, maybe: trivially destructible deleters (and,
    in general, trivially destructible callable objects) are very common. All function
    pointers, member function pointers, stateless objects, and lambdas that do not
    capture any non-trivial objects by value are all trivially destructible. So we
    could simply add a static assert to our constructor and restrict our smart pointer
    to trivially destructible deleters, and, in reality, it would serve us fine in
    most cases. But I also want to show you a more general solution.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能是C++中类型擦除机制最简洁的演示。但它并不完全等同于前一个章节中我们使用继承的例子。当我们对智能指针拥有的类型为`T`的对象调用删除器时，我们并没有对删除器对象本身进行任何销毁操作，特别是我们存储在局部缓冲区内的副本。这里的局部缓冲区并不是问题：如果我们动态分配内存，它仍然会通过一个通用指针，如`char*`或`void*`来访问，而现在我们知道如何正确地删除它。为此，我们需要另一个可以具体化原始类型的函数。好吧，也许：平凡可销毁的删除器（以及在一般情况下，平凡可销毁的可调用对象）非常常见。所有函数指针、成员函数指针、无状态对象以及不通过值捕获任何非平凡对象的lambda表达式都是平凡可销毁的。因此，我们可以在构造函数中简单地添加一个静态断言，并将我们的智能指针限制为平凡可销毁的删除器，实际上，在大多数情况下它都会很好地为我们服务。但我也想向你展示一个更通用的解决方案。
- en: 'We can, of course, use another pointer to a static function that destroys the
    deleter and is instantiated with the right type in the constructor. But the destructor
    is not the end of what we need: in general, we also need to copy and move deleters,
    and maybe even compare them. That’s a lot of function pointers making our `smartptr`
    class bloated. By comparison, the inheritance-based implementation did everything
    with just the pointer to the `destroy` object (stored as a pointer to the base
    class `destroy_base`). There is a way we can do the same. For this example, there
    is no good way to gradually reveal the magic, so we have to jump right in and
    follow up with a line-by-line explanation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用另一个指向静态销毁删除器的指针，并在构造函数中以正确的类型实例化它。但析构函数并不是我们需要的结束：通常，我们还需要复制和移动删除器，甚至可能需要比较它们。这会导致我们的`smartptr`类变得臃肿。相比之下，基于继承的实现只需要一个指向`destroy`对象的指针（存储为基类`destroy_base`的指针）就完成了所有操作。有一种方法我们可以做到同样的事情。对于这个例子，没有好的方法可以逐步揭示魔法，所以我们不得不直接跳进去，并逐行进行解释：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let us explain how this code works. First of all, we declare a `struct vtable_t`
    that contains function pointers to every operation we need to implement on the
    erased `Deleter` type. In our case, there are just two: invoke the deleter on
    an object to be destroyed and destroy the deleter itself. In general, we would
    have at least copy and move operations there as well (you will find such implementation
    in [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453)*, Local Buffer Optimization*).
    Next, we have the `vtable_` pointer. After the object is constructed, it will
    point to an object of the type `vtable_t`. While this may suggest dynamic memory
    allocation ahead, we are going to do much better than that. Next is a variable
    template `vtable`; instantiating it on a concrete `Deleter` type will create a
    static instance of a variable of type `vtable_t`. This is, perhaps, the most tricky
    part: usually, when we have a static data member of a class, it’s just a variable,
    and we can access it by name. But here is something different: the name `vtable`
    can refer to many objects, all of the same type, `vtable_t`. None of them are
    explicitly created by us: we do not allocate memory for them, do not call `operator
    new` to construct them. The compiler creates one of these objects for every `Deleter`
    type we use. For every smartptr object, the address of the specific `vtable` object
    we want it to use is stored in the `vtable_` pointer.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这段代码是如何工作的。首先，我们声明一个 `struct vtable_t`，它包含指向我们需要在擦除的 `Deleter` 类型上实现的所有操作的函数指针。在我们的例子中，只有两个：对一个将被销毁的对象调用删除器，以及销毁删除器本身。一般来说，我们至少会在那里有复制和移动操作（你将在
    [*第10章*](B19262_10.xhtml#_idTextAnchor453)*，局部缓冲区优化*）中找到这样的实现）。接下来，我们有 `vtable_`
    指针。在对象构建之后，它将指向 `vtable_t` 类型的对象。虽然这可能会暗示接下来会有动态内存分配，但我们将做得更好。接下来是一个变量模板 `vtable`；在具体的
    `Deleter` 类型上实例化它将创建一个 `vtable_t` 类型的静态变量实例。这可能是最棘手的部分：通常，当我们有一个类的静态数据成员时，它只是一个变量，我们可以通过名称访问它。但这里有一些不同：名称
    `vtable` 可以引用许多对象，它们都是同一类型 `vtable_t`。我们都没有显式创建它们：我们不会为它们分配内存，也不会调用 `operator
    new` 来构建它们。编译器为每个我们使用的 `Deleter` 类型创建一个这样的对象。对于每个 `smartptr` 对象，我们想要它使用的特定 `vtable`
    对象的地址存储在 `vtable_` 指针中。
- en: 'An object of type `vtable_t` contains pointers to static functions. Our `vtable`
    must do so as well: as you can see, we initialized the function pointers in `vtable`
    to point to instantiations of static member functions of the `smartptr` class.
    These instantiations are for the same `Deleter` type that the `vtable` itself
    is instantiated with.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `vtable_t` 的对象包含指向静态函数的指针。我们的 `vtable` 也必须这样做：正如你所见，我们在 `vtable` 中初始化了函数指针，使其指向
    `smartptr` 类静态成员函数的实例化。这些实例化是为了与 `vtable` 本身实例化的相同 `Deleter` 类型。
- en: 'The name `vtable` was not chosen lightly: we have indeed implemented a virtual
    table; the compiler builds a very similar structure with function pointers for
    every polymorphic hierarchy, and every virtual class has a virtual pointer that
    points to the table for its original type (the one it was constructed with).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`vtable` 这个名字不是随便选择的：我们确实实现了一个虚表；编译器为每个多态层次结构构建了一个非常类似的结构，其中包含函数指针，每个虚拟类都有一个虚拟指针，指向其原始类型（它被构建时的类型）的表。'
- en: After the `vtable`, we have two static function templates. That is where the
    erased type is really hidden and later reified. As we have seen before, the function
    signatures do not depend on the `Deleter` type, but their implementations do.
    Finally, we have the same buffer for storing deleter objects locally.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `vtable` 之后，我们有两个静态函数模板。这就是擦除的类型真正隐藏的地方，稍后会被重新实现。正如我们之前所看到的，函数签名不依赖于 `Deleter`
    类型，但它们的实现是。最后，我们有一个相同的缓冲区用于在本地存储删除器对象。
- en: 'As before, the constructor ties everything together; this must be so since
    the constructor is the only place in this code where the `Deleter` type is explicitly
    known. Our constructor does three things: first, it stores the pointer to the
    object, as any other smart pointer does. Second, it points the `vtable_` pointer
    to an instance of the static `vtable` variable for the right `Deleter` type. Finally,
    it constructs a copy of the deleter in the local buffer. At this point, the `Deleter`
    type is erased: nothing in the `smartptr` object explicitly depends on it.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，构造函数将一切联系在一起；这是必须的，因为构造函数是此代码中唯一一个显式知道 `Deleter` 类型的位置。我们的构造函数做了三件事：首先，它存储了对象的指针，就像任何其他智能指针一样。其次，它将
    `vtable_` 指针指向正确的 `Deleter` 类型的静态 `vtable` 变量的一个实例。最后，它在局部缓冲区中构造了删除器的副本。此时，`Deleter`
    类型被擦除：`smartptr` 对象中的任何内容都没有显式依赖于它。
- en: The deleter, and its true type, come into play again when the destructor of
    the smart pointer is called and we need to destroy the owned object and the deleter
    itself. Each of these actions is done by means of an indirect function call. The
    functions to call are stored in the `*vtable_` object (just like for polymorphic
    classes, the correct virtual function overrides are found in the virtual table
    of function pointers). The deleter is passed into these functions using the address
    of the buffer – no type information there. But the functions were generated for
    the specific `Deleter` type, so they cast the `void*` buffer address to the right
    type and use the deleter that was stored in the buffer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用智能指针的析构函数，需要销毁所拥有的对象和析构函数本身时，销毁者和它的真实类型再次发挥作用。这些操作都是通过间接函数调用来完成的。要调用的函数存储在
    `*vtable_` 对象中（就像对于多态类，正确的虚拟函数重写可以在函数指针的虚表中找到）。销毁者通过缓冲区的地址传递给这些函数——那里没有类型信息。但是，这些函数是为特定的
    `Deleter` 类型生成的，因此它们将 `void*` 缓冲区地址转换为正确的类型，并使用存储在缓冲区中的销毁者。
- en: This implementation allows us to have multiple type-erased operations while
    storing just one `vtable_` pointer in the object itself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现允许我们在对象本身中只存储一个 `vtable_` 指针的同时执行多个类型擦除操作。
- en: 'We can also combine the two approaches: invoke some operations through a virtual
    table and have dedicated function pointers for others. Why? Performance, possibly:
    invoking a function through a virtual table may be a little slower. This needs
    to be measured for any specific application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以结合两种方法：通过虚拟表调用一些操作，并为其他操作保留专用函数指针。为什么？可能是性能：通过虚拟表调用函数可能稍微慢一些。这需要针对任何特定应用程序进行测量。
- en: So far, we used type erasure to provide abstract interfaces for very specific
    behaviors. We already know that type erasure does not need to be so restricted
    – we have seen the example of the `std::function`. The last example in this section
    will be our own generic type-erased function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用类型擦除来提供针对非常特定行为的抽象接口。我们已经知道类型擦除不需要如此受限——我们已经看到了 `std::function` 的例子。本节最后的例子将是我们的通用类型擦除函数。
- en: Efficient type erasure
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效的类型擦除
- en: After the examples and explanations of the last section, a type-erased function
    is not going to be much of a challenge. Nonetheless, there is value in showing
    it here. We are going to demonstrate a very efficient implementation of type erasure
    (the implementation you find in this book was inspired by the works of Arthur
    O’Dwyer and Eduardo Magrid).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的示例和解释之后，类型擦除函数不会构成太大的挑战。尽管如此，在这里展示它的价值仍然存在。我们将展示一个非常高效的类型擦除实现（本书中找到的实现受到了
    Arthur O’Dwyer 和 Eduardo Magrid 的工作的启发）。
- en: 'The template for a generic function looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数的模板如下所示：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here `Signature` is something like `int(std::string)` for a function that takes
    a string and returns an integer. This function can be constructed to invoke any
    `Callable` type as long as an object of this type can be invoked like a function
    with the specified signature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `Signature` 类似于 `int(std::string)`，这是一个接受字符串并返回整数的函数。只要可以像具有指定签名的函数一样调用此类型的对象，该函数就可以构造为调用任何
    `Callable` 类型。
- en: 'We are going to use a local buffer again, but instead of hard-coding it into
    the class, we will add template parameters to control buffer size and alignment:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用局部缓冲区，但不是将其硬编码到类中，而是将模板参数添加到其中以控制缓冲区大小和对齐：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For ease of coding, it is convenient to unpack the function signature into
    the argument types `Args…` and the return type `Res`. The easiest way to do so
    is with a class template specialization:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于编码，将函数签名拆分为参数类型 `Args...` 和返回类型 `Res` 是方便的。这样做最简单的方法是使用类模板特化：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now all that is left is the small matter of the implementation. First, we need
    the buffer to store the `Callable` object in it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是实现的小问题。首先，我们需要一个缓冲区来存储其中的 `Callable` 对象：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Second, we need a function pointer `executor_` to store the address of the
    static function `executor` generated from a template with the type of the `Callable`
    object:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一个函数指针 `executor_` 来存储从模板生成的静态函数 `executor` 的地址，该模板具有 `Callable` 对象的类型：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, in the constructor we must initialize the executor and store the callable
    in the buffer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在构造函数中，我们必须初始化执行器并将可调用对象存储在缓冲区中：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The constructor has two subtle details. The first is the treatment of the type
    of the callable: we deduce it as `CallableArg` but then use it as `Callable`.
    This is because `CallableArg` may be a reference to the type of the callable,
    such as the function pointer, and we don’t want to construct a copy of a reference.
    The second is the concept restriction: the `Function` itself is a callable object
    with the same signature, but we do not want this constructor to apply in such
    a case – that is the job of the copy constructor. If you don’t use C++20, you
    have to use SFINAE to achieve the same effect (see [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314)*,
    SFINAE, Concepts, and Overload Resolution Management,* for details). If you like
    the concept style, you can emulate it to some degree:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有两个微妙之处。第一个是处理可调用对象类型的方式：我们推断其为`CallableArg`，但随后将其用作`Callable`。这是因为`CallableArg`可能是指向可调用对象类型的引用，例如函数指针，我们不希望构造一个引用的副本。第二个是概念限制：`Function`本身是一个具有相同签名的可调用对象，但我们不希望这个构造函数在这种情况下适用——那是复制构造函数的工作。如果你不使用C++20，你必须使用SFINAE来实现相同的效果（有关详细信息，请参阅[*第7章*](B19262_07.xhtml#_idTextAnchor314)*，SFINAE、概念和重载解析管理*）。如果你喜欢概念风格，你可以在一定程度上模拟它：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Speaking of copying, our `Function` is correct only for trivially copyable and
    trivially destructible `Callable` types since we did not provide any means to
    destroy or copy the callable objects stored in the buffer. This still covers a
    lot of ground, but we can handle non-trivial callables as well using the vtable
    approach (you will find an example in [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453)*,
    Local* *Buffer Optimization*).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到复制，我们的`Function`函数仅适用于可以轻易复制和轻易破坏的`Callable`类型，因为我们没有提供任何销毁或复制存储在缓冲区中的可调用对象的手段。这仍然覆盖了很多领域，但我们可以使用vtable方法处理非平凡的可调用对象（你可以在[*第10章*](B19262_10.xhtml#_idTextAnchor453)*，本地*
    *缓冲区优化*）中找到一个示例）。
- en: 'There is one more detail we need to take care of right now: `std::function`
    can be default-constructed without any callable; calling such a “null” function
    throws a `std::bad_function_call` exception. We can do this too if we initialize
    the executor to a pre-defined function that does nothing except throw this exception:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还需要注意的一个细节是：`std::function`可以无任何可调用对象进行默认构造；调用这样的“空”函数会抛出`std::bad_function_call`异常。如果我们初始化执行器为一个预定义的什么也不做只是抛出这个异常的函数，我们也可以这样做：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we have a generic function that is very similar to `std::function` (or
    would have been if we added support for calling member functions, copy and move
    semantics, and the few missing member functions). It does work the same way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个与`std::function`非常相似（或者如果添加了对调用成员函数、复制和移动语义以及少数缺失的成员函数的支持，它将是这样）的泛型函数。它确实以相同的方式工作：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And just what did that convenience cost us? All performance should be measured,
    but we can also get some idea by examining the machine code generated by the compiler
    when it has to call a type-erased function. Here is what it takes to invoke `std::function`
    with the same signature as we just used:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那这种便利性又让我们付出了什么代价呢？所有性能都应该被衡量，但通过检查编译器在必须调用类型擦除函数时生成的机器代码，我们也可以得到一些启示。以下是我们使用与我们刚刚使用的相同签名的`std::function`进行调用的过程：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The compiler (GCC-11 with O3) turns this code into this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器（GCC-11与O3）将此代码转换为以下形式：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now our function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的函数：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This time, the compiler can do much better:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，编译器可以做得更好：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What we see here is the so-called tail call: the compiler simply redirects
    the execution to the actual callable that needs to be invoked. You might ask,
    doesn’t it always? Not usually: most function calls are implemented with `call`
    and `ret` instructions. To call a function, its arguments must be stored in a
    predefined location, then the return address is pushed onto the stack and the
    execution is transferred to the function entry point by the `call` instruction.
    The return instruction `ret` takes the address off the stack and transfers execution
    to it. The beauty of the tail call is this: while we want the call to `Function`
    to call the original callable in the end, we don’t need the execution to return
    to the `Function` object. If there is nothing to do in the `Function` executor
    except to return the control to the caller, we might as well simply leave the
    original return address as-is and have the callable return the control to the
    right place without an additional indirection. Of course, this assumes that the
    executor has nothing to do after the call.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是所谓的尾调用：编译器简单地将执行权转移到需要调用的实际可调用对象。你可能会问，难道不是总是这样吗？通常不是：大多数函数调用都是通过 `call`
    和 `ret` 指令实现的。为了调用一个函数，其参数必须存储在预定义的位置，然后返回地址被压入栈中，通过 `call` 指令将执行权转移到函数入口点。返回指令
    `ret` 从栈中取出地址并将执行权转移到它。尾调用的美妙之处在于：虽然我们希望 `Function` 调用最终调用原始可调用对象，但我们不需要执行权返回到
    `Function` 对象。如果在 `Function` 执行器中没有其他事情要做，除了将控制权返回给调用者，我们完全可以简单地保留原始返回地址不变，让可调用对象将控制权返回到正确的位置，而不需要额外的间接引用。当然，这假设执行器在调用后没有其他事情要做。
- en: 'There are two key optimizations in our code that enable this compact implementation.
    The first one is the way we handle the null function: most implementations of
    `std::function` initialize the executor to `nullptr` and do a pointer comparison
    on every call. We did no such comparison; we always invoke the executor. But then,
    our executor is never null: unless otherwise initialized, it points to the default
    executor.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中有两个关键的优化使得这种紧凑的实现成为可能。第一个是处理空函数的方式：大多数 `std::function` 的实现将执行器初始化为 `nullptr`
    并在每次调用时进行指针比较。我们没有进行这样的比较；我们总是调用执行器。但是，我们的执行器永远不会是空的：除非其他初始化，它指向默认的执行器。
- en: 'The second optimization is more subtle. You might have noticed that the executor
    has one more argument than the callable: to call a function with the signature
    `int(int, int)` our executor needs the two original function arguments (of course)
    and the pointer to the callable object (stored in the local buffer in our case).
    So our executor’s signature is `int(int, int, void*)`. Why not pass the object
    first? That’s what the `std::function` does (at least the one whose assembly we
    have just seen). The problem is that the original function arguments are also
    sitting on the stack. Adding one more argument at the end of the stack is easy.
    But to insert the new first argument, we have to shift all the existing arguments
    by one (this is why the code generated for `std::function` becomes longer the
    more arguments you have).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种优化更为微妙。你可能已经注意到执行器比可调用对象多一个参数：为了调用具有签名 `int(int, int)` 的函数，我们的执行器需要两个原始函数参数（当然）以及指向可调用对象的指针（在我们的例子中存储在局部缓冲区中）。因此，我们的执行器签名是
    `int(int, int, void*)`。为什么不先传递对象呢？这正是 `std::function` 所做的（至少是我们刚刚看到的汇编版本）。问题是原始函数参数也位于栈上。在栈末尾添加一个参数很容易。但是，为了插入新的第一个参数，我们必须将所有现有参数移动一个位置（这就是为什么
    `std::function` 生成的代码随着参数数量的增加而变长的原因）。
- en: As convincing as it sounds, any speculations about performance are hardly worth
    the electrons expanded to have them written down. Performance must always be measured,
    and this is the last task left for us to do in this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很有说服力，但关于性能的任何推测几乎不值得用电子来记录下来。性能必须始终测量，这是我们在这个章节中剩下的最后一个任务。
- en: Performance of type erasure
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除的性能
- en: We are going to measure the performance of a type-erased generic function and
    a type-erased smart pointer deleter. First, we need the right tools; in this case,
    a micro-benchmarking library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测量类型擦除的泛型函数和类型擦除的智能指针删除器的性能。首先，我们需要正确的工具；在这种情况下，一个微基准测试库。
- en: Installing the micro-benchmark library
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装微基准测试库
- en: 'In our case, we are interested in the efficiency of very small fragments of
    code that construct and delete objects using different kinds of smart pointers.
    The appropriate tool for measuring the performance of small fragments of code
    is a micro-benchmark. There are many micro-benchmark libraries and tools out there;
    in this book, we will use the Google Benchmark library. To follow along with the
    examples in this section, you must first download and install the library (to
    do this, follow the instructions in the `Readme.md` file). Then you can compile
    and run the examples. You can build the sample files included with the library
    to see how to build a benchmark on your particular system. For example, on a Linux
    machine, the command to build and run a `smartptr.C` benchmark program might look
    something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们感兴趣的是使用不同类型的智能指针构建和删除对象的非常小代码片段的效率。测量小代码片段性能的适当工具是微基准测试。现在有许多微基准测试库和工具；在这本书中，我们将使用
    Google Benchmark 库。要跟随本节中的示例，你必须首先下载并安装库（为此，请遵循 `Readme.md` 文件中的说明）。然后你可以编译并运行示例。你可以构建库中包含的示例文件，以了解如何在你的特定系统上构建基准测试。例如，在
    Linux 机器上，构建和运行 `smartptr.C` 基准测试程序的命令可能看起来像这样：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `$CXX` is your C++ compiler, such as `clang++` or `g++-11`, and `$GBENCH_DIR`
    is the directory where the benchmark is installed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$CXX` 是你的 C++ 编译器，例如 `clang++` 或 `g++-11`，而 `$GBENCH_DIR` 是基准测试安装的目录。
- en: The overhead of type erasure
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型擦除的开销
- en: 'Every benchmark needs a baseline. In our case, the baseline is a raw pointer.
    We can reasonably assume that no smart pointer will be able to outperform a raw
    pointer, and the best smart pointer will have zero overhead. Thus, we begin by
    measuring how long it takes to construct and destroy a small object using a raw
    pointer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个基准测试都需要一个基线。在我们的案例中，基线是原始指针。我们可以合理地假设没有任何智能指针能够超越原始指针，并且最好的智能指针将没有开销。因此，我们首先测量使用原始指针构建和销毁一个小对象所需的时间：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A good optimizing compiler can do a great deal of damage to a microbenchmark
    like this by optimizing the “unnecessary” work (which is, really, all the work
    done by this program). We can prevent such optimizations by moving the allocation
    into a different compilation unit:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的优化编译器可以通过优化“不必要的”工作（实际上，这是程序所做的所有工作）对像这样的微基准测试造成很大的破坏。我们可以通过将分配移动到不同的编译单元来防止此类优化：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you have a compiler that can do whole program optimizations, turn them off
    for this benchmark. But don’t turn off the optimization of each file: we want
    to profile the optimized code since that’s what the real program will use.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可以进行整个程序优化的编译器，请为这个基准测试关闭它。但是不要关闭每个文件的优化：我们希望分析优化后的代码，因为这才是实际程序将使用的代码。
- en: 'The actual numbers reported by the benchmark depend, of course, on the machine
    that it runs on. But we are interested in the relative changes, so any machine
    will do, as long as we stay with it for all measurements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试报告的实际数字当然取决于运行它的机器。但我们对相对变化感兴趣，所以任何机器都可以，只要我们在所有测量中都使用它：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now verify that `std::unique_ptr` indeed has zero overhead (as long
    as we construct and delete objects the same way, of course):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证 `std::unique_ptr` 确实没有开销（当然，只要我们以相同的方式构建和删除对象）：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result is within the measurement noise from the raw pointer, as can be
    seen here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在原始指针的测量噪声范围内，如下所示：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can similarly measure the performance of `std::shared_ptr` as well as different
    versions of our own smart pointer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地测量 `std::shared_ptr` 以及我们自己的智能指针的不同版本的性能：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first line, `BM_sharedptr`, constructs and deletes a `std::shared_ptr<int>`
    with our custom deleter. The shared pointer is much more expensive than the unique
    pointer. Of course, there is more than one reason for that—`std::shared_ptr` is
    a reference-counting smart pointer, and maintaining a reference count has its
    own overhead. Using `std::make_shared` to allocate shared pointers makes its creation
    and deletion considerably faster, as we can see in the `BM_make_sharedptr` benchmark,
    but, to make sure that we measure only the overhead of type erasure, we should
    implement a type-erased unique pointer. But we already did—it’s our `smartptr`
    that we saw in the *How is type erasure implemented in C++?* section of this chapter.
    It has just enough functionality to measure the performance of the same benchmark
    that we used for all other pointers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`BM_sharedptr`，使用我们的自定义删除器构建和删除`std::shared_ptr<int>`。共享指针比唯一指针昂贵得多。当然，这不止一个原因——`std::shared_ptr`是一个引用计数智能指针，维护引用计数有其自身的开销。使用`std::make_shared`来分配共享指针使其创建和删除显著更快，正如我们在`BM_make_sharedptr`基准测试中所看到的，但为了确保我们只测量类型擦除的开销，我们应该实现一个类型擦除唯一指针。但我们已经做到了——这是我们在本章*如何在C++中实现类型擦除*部分看到的`smartptr`。它具有刚好足够的功能来测量与其他所有指针相同的基准测试的性能：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, `smartptr_te` stands for the type-erased version of the smart pointer
    implemented using inheritance. It is slightly faster than `std::shared_ptr`, proving
    our suspicion that the latter has more than one source of overhead. Just like
    `std::shared_ptr`, deleting `smartptr_te` touches two memory locations: in our
    case, it is the object that is being deleted and the deleter (embedded in a polymorphic
    object). This is exactly what `std::make_shared` avoids by consolidating both
    memory locations for `std::shared_ptr`, and it definitely pays off. We can reasonably
    assume that the second memory allocation is also the reason for the poor performance
    of our type-erased smart pointer (approximately twice as slow as the raw or unique
    pointers). We can avoid this allocation if we use an internal buffer reserved
    inside the smart pointer object. We have already seen a local buffer implementation
    of the smart pointer in the section *Type erasure without memory allocation* (in
    this benchmark, it is renamed as `smartptr_te_lb0`). Here it is benchmarked under
    the name `BM_smartptr_te_lb0`. The version that uses the local buffer when possible
    but switches to dynamic allocation for larger deleters is named `smartptr_te_lb`
    and is slightly slower (`BM_smartptr_te_lb`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`smartptr_te`代表使用继承实现的智能指针的类型擦除版本。它比`std::shared_ptr`略快，这证实了我们的怀疑，即后者有多个开销来源。就像`std::shared_ptr`一样，删除`smartptr_te`会触及两个内存位置：在我们的案例中，它是被删除的对象和删除器（内嵌在多态对象中）。这正是`std::make_shared`通过合并`std::shared_ptr`的两个内存位置来避免的，这肯定是有益的。我们可以合理地假设第二个内存分配也是我们类型擦除智能指针性能不佳（大约是原始或唯一指针的两倍慢）的原因。如果我们使用智能指针对象内部预留的内部缓冲区，我们可以避免这种分配。我们已经在*类型擦除不涉及内存分配*部分看到了智能指针的本地缓冲区实现（在这个基准测试中，它被重命名为`smartptr_te_lb0`）。这里以`BM_smartptr_te_lb0`的名字进行了基准测试。当可能时使用本地缓冲区，但对于较大的删除器切换到动态分配的版本被命名为`smartptr_te_lb`，并且略慢（`BM_smartptr_te_lb`）：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have also benchmarked the two type-erased smart pointers implemented without
    inheritance. The static function version `BM_smartptr_te_static` is slightly faster
    than the version that uses the vtable (`BM_smartptr_te_vtable`). Both of these
    use local buffers; it should not come as a surprise that the compiler-generated
    vtable performs exactly as well as the equivalent structure we crafted using static
    variable templates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对两种不使用继承实现的类型擦除智能指针进行了基准测试。静态函数版本`BM_smartptr_te_static`比使用虚表的版本`BM_smartptr_te_vtable`略快。这两个版本都使用本地缓冲区；编译器生成的虚表与我们所精心制作的等效结构表现完全相同，这并不令人惊讶。
- en: Overall, there is some overhead even for the best type erasure implementation,
    just under 10 percent in our case. Whether or not this is acceptable, depends
    on the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，即使是最好的类型擦除实现也存在一些开销，在我们的案例中不到10%。是否可以接受这个开销，取决于应用程序。
- en: 'We should also measure the performance of the generic type-erased function.
    We can measure its performance with any callable entity, for example, a lambda
    expression:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该测量泛型类型擦除函数的性能。我们可以用任何可调用实体来测量其性能，例如，一个lambda表达式：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can do the same measurement for `std::function` as well, and compare the
    results:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对`std::function`进行相同的测量，并比较结果：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'While it may seem like a great success, this benchmark also hides the warning
    against going overboard with type erasure. All we have to do to reveal this warning
    is to measure the performance of the direct call to the same lambda:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来是一个巨大的成功，但这个基准也隐藏了对过度使用类型擦除的警告。要揭示这个警告，我们只需测量对同一lambda的直接调用的性能：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How do we reconcile this major slowdown with the minor cost of type erasure
    we have seen earlier when we were comparing smart and raw pointers?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这种主要的减速与我们在比较智能指针和原始指针时看到的类型擦除的微小成本相协调？
- en: It is important to pay attention to what is being erased. A well-implemented
    type-erased interface can deliver performance very similar to that of a virtual
    function call. A non-inlined non-virtual function call is going to be slightly
    faster (in our case, a call that took just under 9 nanoseconds incurred about
    10 percent overhead). But a type-erased invocation is always indirect. The one
    competition it can’t come close to is an inlined function call. This is exactly
    what we observed when we compared the performance of type-erased and direct invocations
    of lambdas.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意正在擦除的内容。一个实现良好的类型擦除接口可以提供与虚拟函数调用非常相似的性能。非内联的非虚拟函数调用将稍微快一点（在我们的例子中，耗时不到9纳秒的调用产生了大约10%的开销）。但类型擦除的调用始终是间接的。它无法接近的一个竞争点是内联函数调用。这正是我们在比较类型擦除和直接调用lambda的性能时观察到的。
- en: With what we learned about the performance of type erasure, when can we recommend
    it?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了类型擦除的性能之后，我们何时可以推荐使用它？
- en: Guidelines for using type erasure
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型擦除的指南
- en: 'What problems does type erasure solve, and when is the cost of the solution
    acceptable? First of all, it is important to not lose sight of the original goal:
    type erasure is a design pattern that helps with the separation of concerns, a
    very powerful design technique. It is used to create an abstraction for a certain
    behavior when the implementation of said behavior can be provided by an open set
    of possibly unrelated types.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除解决了哪些问题，何时解决方案的成本是可以接受的？首先，重要的是不要忘记原始目标：类型擦除是一种设计模式，有助于关注点的分离，这是一种非常强大的设计技术。它用于在实现该行为可以由一组可能无关的类型提供时，为某种行为创建一个抽象。
- en: It is also used as an implementation technique, mostly to aid in breaking dependencies
    between compilation units and other program components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它还用作实现技术，主要用来帮助打破编译单元和其他程序组件之间的依赖关系。
- en: 'Before we can answer the question “*Is type erasure worth the cost?*”, we need
    to consider the alternatives. In many cases, the alternative is another way to
    implement the same abstraction: polymorphic class hierarchies or function pointers.
    The performance of either option is similar to that of the type erasure (in its
    optimal implementation), so it comes down to convenience and code quality. For
    a single function, using a type-erased function is easier than developing a new
    class hierarchy, and more flexible than using a function pointer. For a class
    with many member functions, it is usually easier and less error-prone to maintain
    a class hierarchy.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够回答“*类型擦除值得付出代价吗？*”这个问题之前，我们需要考虑替代方案。在许多情况下，替代方案是另一种实现相同抽象的方法：多态类层次结构或函数指针。这两种选项的性能与类型擦除（在其最佳实现中）相似，所以这取决于便利性和代码质量。对于单个函数，使用类型擦除函数比开发新的类层次结构更容易，比使用函数指针更灵活。对于具有许多成员函数的类，维护类层次结构通常更容易且更不容易出错。
- en: 'The other possible alternative is to do nothing and allow tighter coupling
    between parts of the design. The downsides of such a decision are often inversely
    proportional to its performance benefit: closely coupled parts of the system often
    need to coordinate implementation to achieve good performance, but they are closely
    coupled for a reason. Components that are logically well separated should not
    interact extensively, therefore, the performance of such interaction should not
    be critical.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的替代方案是不采取任何行动，允许设计部分之间更紧密的耦合。这种决定的缺点通常与其性能收益成反比：系统紧密耦合的部分通常需要协调实现以达到良好的性能，但它们紧密耦合是有原因的。逻辑上分离良好的组件不应进行大量交互，因此，这种交互的性能不应是关键的。
- en: 'What do we do when performance is important but we still need an abstraction?
    Often, the direct opposite of type erasure: we make everything into templates.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能很重要但我们仍然需要抽象时，我们该怎么办？通常，这是类型擦除的直接对立面：我们将一切变成模板。
- en: Consider C++20 ranges. On one hand, they are abstract sequences. We can write
    a function that operates on a range and invoke it with a vector, a deque, a range
    created from one of these containers, a subrange of that range, or a filtered
    view. Anything is a range as long as it can be iterated from `begin()` to `end()`.
    But ranges created from a vector and a deque are different types, even though
    they are abstractions for sequences, interface-wise. The standard library provides
    multiple range adapters and range views, and they are all templates. So are the
    functions operating on the ranges.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑C++20的范围。一方面，它们是抽象序列。我们可以编写一个操作范围的函数，并用向量、deque、从这些容器之一创建的范围、该范围的子范围或过滤视图来调用它。只要可以从`begin()`迭代到`end()`，任何东西都是范围。但是，从向量和一个deque创建的范围是不同的类型，尽管它们在接口上是序列的抽象。标准库提供了多个范围适配器和范围视图，它们都是模板。操作这些范围的函数也是模板。
- en: 'Could we implement a type-erased range? Yes, it is not even that hard. We end
    up with a single type, `GenericRange`, that can be constructed from a vector,
    a deque, a list, or anything else that has `begin()`, `end()`, and a forward iterator.
    We also get something that is about twice as slow as most container iterators,
    except for vectors: their iterators are really just pointers, and vectorizing
    compilers can do optimizations that speed up the code by at least an order of
    magnitude. The possibility of such optimizations is lost when we erase the type
    of the original container.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否实现一个类型擦除的范围？是的，这甚至并不难。我们最终得到一个单一的类型，`GenericRange`，可以从向量、deque、列表或其他具有`begin()`、`end()`和前向迭代器的任何东西中构建。我们还得到一些东西，其速度大约是大多数容器迭代器的一半，除了向量：它们的迭代器实际上只是指针，向量化的编译器可以进行优化，至少将代码速度提高一个数量级。当我们擦除原始容器的类型时，这种优化的可能性就丢失了。
- en: The C++ designers made the decision that, on the one hand, ranges provide an
    abstraction for certain behavior and let us separate the interface from the implementation.
    On the other hand, they were unwilling to sacrifice performance. So they chose
    to make ranges and all code that operates on them into templates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C++设计者做出了决定，一方面，范围提供了一种对某些行为的抽象，并让我们将接口与实现分离。另一方面，他们不愿意牺牲性能。因此，他们选择将范围及其所有操作代码都做成模板。
- en: As a designer of a software system, you may have to make similar decisions.
    The general guideline is to prefer tighter coupling for closely related components
    where such coupling is essential for performance. Conversely, prefer better separation
    for loosely coupled components whose interaction does not require high efficiency.
    When in that domain, type erasure should be considered at least equally to polymorphism
    and other decoupling techniques.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件系统的设计者，你可能不得不做出类似的决策。一般准则是在这种耦合对于性能至关重要的情况下，更倾向于紧密耦合相关组件。相反，对于交互不需要高效率的松耦合组件，更倾向于更好的分离。当处于这个领域时，类型擦除至少应该与多态和其他解耦技术同等考虑。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have, hopefully, demystified the programming technique known
    as type erasure. We have shown how a program can be written without all of the
    type information being explicitly visible, and some of the reasons why this may
    be a desirable implementation. We have also demonstrated that, when implemented
    efficiently and used wisely, it is a powerful technique that may lead to much
    simpler and more flexible interfaces and clearly separated components.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望已经解除了被称为类型擦除的编程技术的神秘感。我们展示了如何编写一个程序，其中并非所有的类型信息都是显式可见的，以及为什么这可能是一种理想的实现方式的原因。我们还展示了，当高效实现并明智使用时，它是一种强大的技术，可能导致更简单、更灵活的接口和明显分离的组件。
- en: The next chapter is a change of direction—we are done with the abstraction idioms
    for some time and now move on to C++ idioms that facilitate the binding of template
    components into complex interacting systems. We start with the SFINAE idiom.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将改变方向——我们已经处理了一些抽象惯用法一段时间了，现在转向C++惯用法，这些惯用法有助于将模板组件绑定到复杂交互系统中。我们首先从SFINAE惯用法开始。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is type erasure, really?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真正的类型擦除是什么？
- en: How is type erasure implemented in C++?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型擦除在C++中是如何实现的？
- en: What is the difference between hiding a type behind `auto` and erasing it?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auto`后面隐藏类型和擦除它之间有什么区别？
- en: How is the concrete type reified when the program needs to use it?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序需要使用具体类型时，它是如何被具体化的？
- en: What is the performance overhead of type erasure?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型擦除的性能开销是什么？
