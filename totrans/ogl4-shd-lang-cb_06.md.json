["```cpp\nin vec3 Position; \nin vec3 Normal; \n\nuniform int Pass; // Pass number\n\n// The texture containing the results of the first pass \nlayout( binding=0 ) uniform sampler2D RenderTex; \n\nuniform float EdgeThreshold; // The squared threshold \n\n// Light/material uniforms...\n\nlayout( location = 0 ) out vec4 FragColor; \nconst vec3 lum = vec3(0.2126, 0.7152, 0.0722); \n\nvec3 blinnPhong( vec3 pos, vec3 norm ) {\n // ... \n} \n\n// Approximates the brightness of a RGB value. \nfloat luminance( vec3 color ) { \n return dot(lum, color);\n} \nvec4 pass1() { \n return vec4(blinnPhong( Position, normalize(Normal) ),1.0); \n} \n\nvec4 pass2() { \n ivec2 pix = ivec2(gl_FragCoord.xy); \n float s00 = luminance( \n    texelFetchOffset(RenderTex, pix, 0, \n            ivec2(-1,1)).rgb); \n float s10 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(-1,0)).rgb); \n float s20 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(-1,-1)).rgb); \n float s01 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(0,1)).rgb); \n float s21 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(0,-1)).rgb); \n float s02 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(1,1)).rgb); \n float s12 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(1,0)).rgb); \n float s22 = luminance( \n       texelFetchOffset(RenderTex, pix, 0, \n                ivec2(1,-1)).rgb); \n\n float sx = s00 + 2 * s10 + s20 - (s02 + 2 * s12 + s22); \n float sy = s00 + 2 * s01 + s02 - (s20 + 2 * s21 + s22); \n\n float g = sx * sx + sy * sy; \n\n if( g > EdgeThreshold ) return vec4(1.0); \n else return vec4(0.0,0.0,0.0,1.0); \n} \n\nvoid main() { \n  if( Pass == 1 ) FragColor = pass1();\n  if( Pass == 2 ) FragColor = pass2(); \n}\n```", "```cpp\nin vec3 Position; // Vertex position \nin vec3 Normal;  // Vertex normal \n\nuniform int Pass; // Pass number\nlayout(binding=0) uniform sampler2D Texture0; \n\n// Light/material uniforms ....\nlayout( location = 0 ) out vec4 FragColor; \n\nuniform int PixOffset[5] = int[](0,1,2,3,4); \nuniform float Weight[5]; \n\nvec3 blinnPhong( vec3 pos, vec3 norm ) { \n  // ... \n} \n\nvec4 pass1() {\n return vec4(blinnPhong( Position, normalize(Normal) ),1.0); \n} \n\nvec4 pass2() { \n ivec2 pix = ivec2(gl_FragCoord.xy); \n vec4 sum = texelFetch(Texture0, pix, 0) * Weight[0]; \n for( int i = 1; i < 5; i++ ) \n { \n  sum += texelFetchOffset( Texture0, pix, 0, \n        ivec2(0,PixOffset[i])) * Weight[i]; \n  sum += texelFetchOffset( Texture0, pix, 0, \n        ivec2(0,-PixOffset[i])) * Weight[i]; \n } \n return sum; \n} \n\nvec4 pass3() { \n ivec2 pix = ivec2(gl_FragCoord.xy); \n vec4 sum = texelFetch(Texture0, pix, 0) * Weight[0]; \n for( int i = 1; i < 5; i++ ) \n { \n  sum += texelFetchOffset( Texture0, pix, 0, \n        ivec2(PixOffset[i],0)) * Weight[i]; \n  sum += texelFetchOffset( Texture0, pix, 0, \n        ivec2(-PixOffset[i],0)) * Weight[i]; \n } \n return sum; \n} \n\nvoid main() \n{ \n if( Pass == 1 ) FragColor = pass1();\n else if( Pass == 2 ) FragColor = pass2();\n else if( Pass == 3 ) FragColor = pass3();\n} \n```", "```cpp\nchar uniName[20]; \nfloat weights[5], sum, sigma2 = 4.0f; \n\n// Compute and sum the weights \nweights[0] = gauss(0,sigma2); // The 1-D Gaussian function \nsum = weights[0]; \nfor( int i = 1; i < 5; i++ ) { \n weights[i] = gauss(i, sigma2); \n sum += 2 * weights[i]; \n} \n\n// Normalize the weights and set the uniform \nfor( int i = 0; i < 5; i++ ) { \n snprintf(uniName, 20, \"Weight[%d]\", i); \n prog.setUniform(uniName, weights[i] / sum); \n} \n```", "```cpp\nint size = width * height;\nstd::vector<GLfloat> texData(size*3);\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, hdrTex);\nglGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, texData.data());\nfloat sum = 0.0f;\nfor( int i = 0; i < size; i++ ) {\n float lum = computeLum(texData[i*3+0], texData[i*3+1], texData[i*3+2]);\n sum += logf( lum + 0.00001f );\n}\nfloat logAve = expf( sum / size ); \n```", "```cpp\n// Retrieve high-res color from texture \nvec4 color = texture( HdrTex, TexCoord ); \n\n// Convert to XYZ \nvec3 xyzCol = rgb2xyz * vec3(color); \n\n// Convert to xyY \nfloat xyzSum = xyzCol.x + xyzCol.y + xyzCol.z; \nvec3 xyYCol = vec3(0.0); \nif( xyzSum > 0.0 ) // Avoid divide by zero \n  xyYCol = vec3( xyzCol.x / xyzSum, \n         xyzCol.y / xyzSum, xyzCol.y); \n\n// Apply the tone mapping operation to the luminance \n// (xyYCol.z or xyzCol.y) \nfloat L = (Exposure * xyYCol.z) / AveLum; \nL = (L * ( 1 + L / (White * White) )) / ( 1 + L ); \n\n// Using the new luminance, convert back to XYZ \nif( xyYCol.y > 0.0 ) { \n xyzCol.x = (L * xyYCol.x) / (xyYCol.y); \n xyzCol.y = L; \n xyzCol.z = (L * (1 - xyYCol.x - xyYCol.y))/xyYCol.y; \n} \n\n// Convert back to RGB and send to output buffer \nFragColor = vec4( xyz2rgb * xyzCol, 1.0); \n```", "```cpp\nvec4 val = texture(HdrTex, TexCoord); \nif( luminance(val.rgb) > LumThresh ) \n  FragColor = val; \nelse \n  FragColor = vec4(0.0); \n```", "```cpp\n// Retrieve high-res color from texture \nvec4 color = texture( HdrTex, TexCoord ); \n\n// Apply tone mapping to color, result is toneMapColor \n... \n\n///////// Combine with blurred texture ////////// \nvec4 blurTex = texture(BlurTex1, TexCoord); \n\nFragColor = toneMapColor + blurTex;\n```", "```cpp\nvec3 color = lightingModel( ... ); \nFragColor = vec4( pow( color, vec3(1.0/Gamma) ), 1.0 ); \n```", "```cpp\nglfwWindowHint(GLFW_SAMPLES, 8); \n... // Other settings \nwindow = glfwCreateWindow( WIN_WIDTH, WIN_HEIGHT, \n            \"Window title\", NULL, NULL ); \n```", "```cpp\nGLint bufs, samples; \nglGetIntegerv(GL_SAMPLE_BUFFERS, &bufs); \nglGetIntegerv(GL_SAMPLES, &samples); \nprintf(\"MSAA: buffers = %d samples = %dn\", bufs, samples); \n```", "```cpp\nglEnable(GL_MULTISAMPLE); \n```", "```cpp\nglDisable(GL_MULTISAMPLE); \n```", "```cpp\nin vec2 TexCoord; \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n vec3 yellow = vec3(1.0,1.0,0.0); \n vec3 color = vec3(0.0);  // black \n if( TexCoord.s > 1.0 ) \n  color = yellow; \n FragColor = vec4( color , 1.0 ); \n}\n```", "```cpp\ncentroid in vec2 TexCoord; \n```", "```cpp\nsample in vec2 TexCoord;\n```", "```cpp\nvoid createGBufTex(GLenum texUnit, GLenum format, \n          GLuint &texid ) { \n  glActiveTexture(texUnit); \n  glGenTextures(1, &texid); \n  glBindTexture(GL_TEXTURE_2D, texid); \n  glTexStorage2D(GL_TEXTURE_2D,1,format,width,height); \n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, \n          GL_NEAREST); \n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, \n          GL_NEAREST); \n} \n... \nGLuint depthBuf, posTex, normTex, colorTex; \n\n// Create and bind the FBO \nglGenFramebuffers(1, &deferredFBO); \nglBindFramebuffer(GL_FRAMEBUFFER, deferredFBO); \n\n// The depth buffer \nglGenRenderbuffers(1, &depthBuf); \nglBindRenderbuffer(GL_RENDERBUFFER, depthBuf); \nglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, \n           width, height); \n\n// The position, normal and color buffers \ncreateGBufTex(GL_TEXTURE0, GL_RGB32F, posTex); // Position \ncreateGBufTex(GL_TEXTURE1, GL_RGB32F, normTex); // Normal \ncreateGBufTex(GL_TEXTURE2, GL_RGB8, colorTex); // Color \n\n// Attach the images to the framebuffer \nglFramebufferRenderbuffer(GL_FRAMEBUFFER, \n     GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuf); \nglFramebufferTexture2D(GL_FRAMEBUFFER, \n     GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, posTex, 0); \nglFramebufferTexture2D(GL_FRAMEBUFFER, \n     GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, normTex, 0); \nglFramebufferTexture2D(GL_FRAMEBUFFER, \n     GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, colorTex, 0); \n\nGLenumdrawBuffers[] = {GL_NONE, GL_COLOR_ATTACHMENT0, \n     GL_COLOR_ATTACHMENT1,GL_COLOR_ATTACHMENT2}; \nglDrawBuffers(4, drawBuffers); :\n```", "```cpp\nin vec3 Position;\nin vec3 Normal;\nin vec2 TexCoord;\n\nlayout (location = 0) out vec4 FragColor;\nlayout (location = 1) out vec3 PositionData;\nlayout (location = 2) out vec3 NormalData;\nlayout (location = 3) out vec3 ColorData;\n\n// The g-buffer textures \nlayout(binding = 0) uniform sampler2D PositionTex; \nlayout(binding = 1) uniform sampler2D NormalTex; \nlayout(binding = 2) uniform sampler2D ColorTex; \n\nuniform int Pass; // Pass number\n\n// Material/light uniforms...\n\nvec3 diffuseModel( vec3 pos, vec3 norm, vec3 diff ) { \n vec3 s = normalize( vec3(Light.Position) - pos);\n float sDotN = max( dot(s,norm), 0.0 );\n return Light.L * diff * sDotN;\n}\n\nvoid pass1() { \n  // Store position, norm, and diffuse color in g-buffer \n  PositionData = Position; \n  NormalData = Normal; \n  ColorData = Material.Kd; \n} \n\nvoid pass2() { \n  // Retrieve position, normal and color information from \n  // the g-buffer textures \n  vec3 pos = vec3( texture( PositionTex, TexCoord ) ); \n  vec3 norm = vec3( texture( NormalTex, TexCoord ) ); \n  vec3 diffColor = vec3( texture(ColorTex, TexCoord) ); \n\n  FragColor=vec4(diffuseModel(pos,norm,diffColor), 1.0); \n} \n\nvoid main() { \n if( Pass == 1 ) pass1();\n else if( Pass==2 ) pass2();\n} \n```", "```cpp\nglDrawBuffers(4, drawBuffers); \n```", "```cpp\nint kernSize = 64;\nstd::vector<float> kern(3 * kernSize);\nfor (int i = 0; i < kernSize; i++) {\n glm::vec3 randDir = rand.uniformHemisphere();\n float scale = ((float)(i * i)) / (kernSize * kernSize);\n randDir *= glm::mix(0.1f, 1.0f, scale);\n\n kern[i * 3 + 0] = randDir.x;\n kern[i * 3 + 1] = randDir.y;\n kern[i * 3 + 2] = randDir.z;\n}\n```", "```cpp\nint size = 4;\nstd::vector<GLfloat> randDirections(3 * size * size);\nfor (int i = 0; i < size * size; i++) {\n glm::vec3 v = rand.uniformCircle();\n randDirections[i * 3 + 0] = v.x;\n randDirections[i * 3 + 1] = v.y;\n randDirections[i * 3 + 2] = v.z;\n}\nglGenTextures(1, &tex);\nglBindTexture(GL_TEXTURE_2D, tex);\nglTexStorage2D(GL_TEXTURE_2D, 1, GL_RGB16F, size, size);\nglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, size, size, GL_RGB, GL_FLOAT, randDirections.data());\n// ...\n```", "```cpp\n// Create the random tangent space matrix\nvec3 randDir = normalize( texture(RandTex, TexCoord.xy * randScale).xyz );\nvec3 n = normalize( texture(NormalTex, TexCoord).xyz );\nvec3 biTang = cross( n, randDir );\n// If n and randDir are parallel, n is in x-y plane\nif( length(biTang) < 0.0001 ) \n  biTang = cross( n, vec3(0,0,1));\nbiTang = normalize(biTang);\nvec3 tang = cross(biTang, n);\nmat3 toCamSpace = mat3(tang, biTang, n);\n```", "```cpp\nfloat occlusionSum = 0.0;\nvec3 camPos = texture(PositionTex, TexCoord).xyz;\nfor( int i = 0; i < kernelSize; i++ ) {\n vec3 samplePos = camPos + Radius * (toCamSpace * SampleKernel[i]);\n\n // Project point to texture space\n vec4 p = ProjectionMatrix * vec4(samplePos,1);\n p *= 1.0 / p.w;\n p.xyz = p.xyz * 0.5 + 0.5;\n\n // Camera space z-coordinate of surface at the x,y position\n float surfaceZ = texture(PositionTex, p.xy).z;\n float dz = surfaceZ - camPos.z;\n\n // Count points that ARE occluded within the hemisphere\n if( dz >= 0.0 && dz <= Radius && surfaceZ > samplePos.z ) \n  occlusionSum += 1.0;\n}\n\nAoData = 1.0 - occlusionSum / kernelSize;\n```", "```cpp\nivec2 pix = ivec2( gl_FragCoord.xy );\nfloat sum = 0.0;\nfor( int x = -1; x <= 1; ++x ) {\n for( int y = -1; y <= 1; y++ ) {\n  sum += texelFetchOffset( AoTex, pix, 0, ivec2(x,y) ).r;\n }\n}\nAoData = sum / 9.0;\n```", "```cpp\nvec3 pos = texture( PositionTex, TexCoord ).xyz;\nvec3 norm = texture( NormalTex, TexCoord ).xyz;\nvec3 diffColor = texture(ColorTex, TexCoord).rgb;\nfloat aoVal = texture( AoTex, TexCoord).r;\n\naoVal = pow(aoVal, 4);\nvec3 ambient = Light.La * diff * aoVal;\nvec3 s = normalize( vec3(Light.Position) - pos);\nfloat sDotN = max( dot(s,norm), 0.0 );\nvec3 col = ambient + Light.L * diff * sDotN;\n\ncol = pow(col, vec3(1.0/2.2)); // Gamma\n\nFragColor = vec4(col, 1.0);\n```", "```cpp\nvec3 samplePos = camPos + Radius * (toCamSpace * SampleKernel[i]);\n```", "```cpp\nlayout(early_fragment_tests) in; \n```", "```cpp\nlayout (depth_*) out float gl_FragDepth; \n```", "```cpp\nlayout(early_fragment_tests) in; \n```", "```cpp\nGLuint counterBuffer;  \nglGenBuffers(1, &counterBuffer); \nglBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, counterBuffer); \nglBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), NULL, \n       GL_DYNAMIC_DRAW); \n```", "```cpp\nGLuint llBuf; \nglGenBuffers(1, &llBuf); \nglBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, llBuf); \nglBufferData(GL_SHADER_STORAGE_BUFFER, maxNodes * nodeSize, NULL, \n       GL_DYNAMIC_DRAW); \n```", "```cpp\nglGenTextures(1, &headPtrTex); \nglBindTexture(GL_TEXTURE_2D, headPtrTex); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_R32UI, width, height); \nglBindImageTexture(0, headPtrTex, 0, GL_FALSE, 0, GL_READ_WRITE, \n          GL_R32UI); \n```", "```cpp\nvector<GLuint> headPtrClear(width * height, 0xffffffff); \nGLuint clearBuf; \nglGenBuffers(1, &clearBuf); \nglBindBuffer(GL_PIXEL_UNPACK_BUFFER, clearBuf); \nglBufferData(GL_PIXEL_UNPACK_BUFFER, \n       headPtrClear.size()*sizeof(GLuint), \n       &headPtrClear[0], GL_STATIC_COPY); \n```", "```cpp\nglBindBuffer(GL_PIXEL_UNPACK_BUFFER, clearBuf); \nglBindTexture(GL_TEXTURE_2D, headPtrTex); \nglTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, \n        GL_RED_INTEGER, GL_UNSIGNED_INT, NULL); \nGLuint zero = 0; \nglBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, counterBuffer); \nglBufferSubData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &zero);\n```", "```cpp\nlayout (early_fragment_tests) in; \n\n#define MAX_FRAGMENTS 75 \n\nin vec3 Position; \nin vec3 Normal; \n\nstruct NodeType { \n vec4 color; \n float depth; \n uint next; \n}; \n\nlayout(binding=0, r32ui) uniform uimage2D headPointers; \nlayout(binding=0, offset=0) uniform atomic_uint \n                     nextNodeCounter; \nlayout(binding=0, std430) buffer linkedLists { \n NodeType nodes[]; \n}; \nuniform uint MaxNodes; \n\nsubroutine void RenderPassType(); \nsubroutine uniform RenderPassType RenderPass; \n\n... \n\nsubroutine(RenderPassType) \nvoid pass1() \n{ \n // Get the index of the next empty slot in the buffer \n uint nodeIdx = atomicCounterIncrement(nextNodeCounter); \n\n // Is there space left in the buffer? \n if( nodeIdx < MaxNodes ) { \n  // Update the head pointer image \n  uint prevHead = imageAtomicExchange(headPointers, \n              ivec2(gl_FragCoord.xy), nodeIdx); \n\n  // Set the color and depth of this new node to the color \n  // and depth of the fragment. The next pointer points to the \n  // previous head of the list. \n  nodes[nodeIdx].color = vec4(shadeFragment(), Kd.a); \n  nodes[nodeIdx].depth = gl_FragCoord.z; \n  nodes[nodeIdx].next = prevHead; \n } \n} \n```", "```cpp\nglMemoryBarrier( GL_ALL_BARRIER_BITS ); \n```", "```cpp\nstruct NodeType frags[MAX_FRAGMENTS]; \nint count = 0; \n\n// Get the index of the head of the list \nuint n = imageLoad(headPointers, ivec2(gl_FragCoord.xy)).r; \n\n// Copy the linked list for this fragment into an array \nwhile( n != 0xffffffff && count < MAX_FRAGMENTS) { \n frags[count] = nodes[n]; \n n = frags[count].next; \n count++; \n} \n```", "```cpp\n// Sort the array by depth (largest to smallest). \nfor( uint i = 1; i < count; i++ ) \n{ \n struct NodeType toInsert = frags[i]; \n uint j = i; \n while( j > 0 && toInsert.depth > frags[j-1].depth ) { \n  frags[j] = frags[j-1]; \n  j--; \n } \n frags[j] = toInsert; \n}\n```", "```cpp\n// Traverse the array, and blend the colors. \nvec4 color = vec4(0.5, 0.5, 0.5, 1.0); // Background color \nfor( int i = 0; i < count; i++ ) { \n color = mix( color, frags[i].color, frags[i].color.a); \n} \n\n// Output the final color \nFragColor = color; \n```", "```cpp\nlayout (early_fragment_tests) in; \n```"]