- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts, with the continued goal of writing more extensible code.
    We will next explore creating generic code using C++ templates – both **template
    functions** and **template classes**. We will learn how template code, when written
    correctly, is the pinnacle in code reuse. In addition to exploring how to create
    both template functions and template classes, we will also understand how the
    appropriate use of operator overloading can make a template function reusable
    for nearly any type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring template basics to genericize code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to create and use template functions and template classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how operator overloading can make templates more extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many object-oriented languages include the concept of programming with generics,
    allowing the types of classes and interfaces to be parameterized themselves. In
    some languages, generics are merely wrappers for casting objects to the desired
    type. In C++, the idea of generics is more comprehensive and is implemented using
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to design more generic code by
    building both template functions and template classes. You will understand how
    operator overloading can ensure that a template function can become highly extensible
    for any data type. By pairing together well-designed template member functions
    with operator overloading, you will be able to create highly reusable and extensible
    template classes in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our understanding of C++ by expanding your programming repertoire
    by exploring templates.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter13` in a file named `Chp13-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3A7lx0U](https://bit.ly/3A7lx0U).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring template basics to genericize code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates allow code to be generically specified in a manner that is abstracted
    from the data types primarily used within relevant functions or classes. The motivation
    for creating templates is to generically specify the definition of functions and
    classes that we repeatedly want to utilize, but with varying data types. The individualized
    versions of these components would otherwise differ only in the core data type
    utilized; these key data types can then be extracted and written generically.
  prefs: []
  type: TYPE_NORMAL
- en: When we then opt to utilize such a class or function with a specific type, rather
    than copying and pasting existing code from a similar class or function (with
    preset data types) and changing it slightly, the preprocessor instead would take
    the template code and *expand* it for our requested, bonafide type. This template
    *expansion* capability allows the programmer to write and maintain only one version
    of the genericized code, versus the many type-specific versions of code that would
    otherwise need to be written. The benefit is also that the preprocessor will do
    a more accurate expansion of the template code to a bonafide type than we might
    have done using a copy, paste, and slight modification method.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a moment to further investigate the motivation for using templates
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the motivation for templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that we wish to create a class to safely handle dynamically allocated
    arrays for data type `int`, such as we have created in a solution for *Question
    3* of [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator
    Overloading*. Our motivation may be to have an array type that can grow or shrink
    to any size (unlike native, fixed-sized arrays), yet have bounds checking for
    safe usage (unlike the raw manipulation of a dynamic array implemented using `int
    *`, which would unscrupulously allow us to access elements well beyond the length
    of our dynamic array allocation).
  prefs: []
  type: TYPE_NORMAL
- en: 'We may decide to create an `ArrayInt` class with the following beginning framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code segment, notice that our `ArrayInt` class implements the
    data structure comprising the array using `int *contents`, which is dynamically
    allocated to the desired size in the constructor. We have overloaded `operator[]`
    to safely return only indexed values in the array that are within the proper range,
    and throw a `std::out_of_range` exception otherwise. We can add methods to `Resize()`
    an `ArrayInt` and so on. Overall, we love the safety and flexibility of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we may want to have an `ArrayFloat` class (or later, an `ArrayStudent`
    class). Rather than copying our baseline `ArrayInt` class and modifying it slightly
    to create an `ArrayFloat` class, for example, we may ask whether there is a more
    automated way to make this substitution. After all, what would we change in creating
    an `ArrayFloat` class using an `ArrayInt` class as a starting point? We would
    change the *type* of the data member `contents` – from an `int *` to a `float
    *`. We would change the *type* in the memory allocation in the constructor from
    `contents = new int [size];` to utilize `float` instead of `int` (and similarly
    so in any reallocation, such as in a `Resize()` method).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than copying, pasting, and slightly modifying an `ArrayInt` class to
    create an `ArrayFloat` class, we can simply use a **template class** to genericize
    the *type* associated with the data manipulated within this class. Similarly,
    any functions relying on the specific data type will become **template functions**.
    We will examine the syntax for creating and utilizing templates shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Using templates, we can instead create just one template class called `Array`
    where the type is genericized. At compile time, should the preprocessor detect
    we have utilized this class for type `int` or `float` in our code, the preprocessor
    will then provide the necessary template *expansions* for us. That is, by copying
    and pasting (behind the scenes) each template class (and its methods) and substituting
    in the data types that the preprocessor identifies we are using.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting code, once expanded under the hood, is no smaller than if we had
    written the code for each individual class ourselves. But the point is that we
    did not have to tediously create, modify, test, and later maintain each minorly
    different class ourselves. This is done on our behalf by C++. This is the noteworthy
    purpose of template classes and template functions.
  prefs: []
  type: TYPE_NORMAL
- en: Templates are not restricted for use with primitive data types. For example,
    we may wish to create an `Array` of a user defined type, such as `Student`. We
    will need to ensure that all of our template member functions are meaningful for
    the data types that we actually expand the template class to utilize. We may need
    to overload selected operators so that our template member functions can work
    seamlessly with user defined types, just as they do with primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: We will later see in this chapter an example illustrating how we may need to
    overload selected operators if we choose to expand a template class for user defined
    types so that the member functions of a class can work fluidly with any data type.
    Fortunately, we know how to overload operators!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to explore the mechanics of specifying and utilizing template
    functions and template classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template functions and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Templates** provide the ability to create generic functions and classes by
    abstracting the data types associated with those functions and classes. Template
    functions and classes can both be carefully written in such a way as to genericize
    the relevant data types that underlie these functions and classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by examining how to create and utilize template functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using template functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Template functions** parameterize the types of arguments in a function in
    addition to the arguments themselves. Template functions require the body of the
    function to be applicable to almost any data type. Template functions can be member
    or non-member functions. Operator overloading can help ensure that the bodies
    of template functions are applicable to user defined types – we’ll see more of
    that shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `template`, along with angle brackets, `<` `>`, and placeholders
    for the *type* names are used to specify a template function and its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a template function that is not a member of a class (we
    will see examples of template member functions shortly). This example can be found,
    as a full working program, in our GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the previous function example, we first see a template function prototype.
    The preamble of `template <class Type1, class Type 2>` indicates that the prototype
    will be a template prototype and that placeholders `Type1` and `Type2` will be
    used instead of actual data types. The placeholders `Type1` and `Type2` may be
    (nearly) any name, following the rules of creating identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to complete the prototype, we see `Type2 ChooseFirst(Type1, Type2);`,
    which indicates that the return type from this function will be of `Type2` and
    that the arguments of the `ChooseFirst()` function will be of `Type1` and `Type2`
    (which may certainly be expanded to be the same type).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the function definition. It, too, begins with a preamble of `template
    <class Type1, class Type 2>`. Similar to the prototype, the function header `Type2
    ChooseFirst(Type1 x, Type2 y)` indicates that formal parameters `x` and `y` are
    of types `Type1` and `Type2`, respectively. The body of this function is rather
    straightforward. We simply determine which of the two parameters should be ranked
    first in an ordering of the two values by using a simple comparison with the `<`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in `main()`, when the preprocessor portion of the compiler sees a call
    to `ChooseFirst()` with actual parameters, `int value1` and `float value3`, the
    preprocessor notices that `ChooseFirst()` is a template function. If no such version
    of `ChooseFirst()` yet exists to handle an `int` and a `float`, the preprocessor
    copies this template function and replaces `Type1` with `int` and `Type2` with
    `float` – creating on our behalf the appropriate version of this function to fit
    our needs. Notice that when `ChooseFirst(value2, value1)` is called and the types
    are both integers, the placeholder types of `Type1` and `Type2` will both be replaced
    with `int` when the template function is again expanded (under the hood) in our
    code by the preprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: Though `ChooseFirst()` is a simple function, with it we can see the straightforward
    mechanics of creating a template function that genericizes key data types. We
    can also see how the preprocessor notices how the template function is used and
    takes on the effort on our behalf to expand this function, as needed, for our
    specific type usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen the basic mechanics of template functions, let us move
    forward to understand how we can expand this process to include template classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using template classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Template classes** parameterize the ultimate type of a class definition,
    and will additionally require template member functions for any methods that need
    to know the core data type being manipulated.'
  prefs: []
  type: TYPE_NORMAL
- en: The keywords `template` and `class`, along with angle brackets, `<` `>`, and
    placeholders for the *type* names are used to specify a template class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a template class definition and its supporting template
    member functions. This example can be found as a complete program (with the necessary
    `#include` and `using` statements) in our GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class definition, let’s first notice the template class preamble
    of `template <class Type>`. This preamble specifies that the impending class definition
    will be that of a template class and that the placeholder `Type` will be used
    to genericize the data types primarily used within this class.
  prefs: []
  type: TYPE_NORMAL
- en: We then see the class definition for `Array`. Data member `contents` will be
    of the placeholder type of `Type`. Of course, not all data types will need to
    be genericized. Data member `int numElements` is perfectly reasonable as an integer.
    Next, we see an assortment of member functions prototyped and some defined inline,
    including overloaded `operator[]`. For the member functions defined inline, a
    template preamble is not necessary in front of the function definition. The only
    thing we need to do for inline functions is to genericize the data type using
    our placeholder, `Type`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at selected member functions. In the constructor, we now
    notice that the memory allocation of `contents = new Type [size];` merely uses
    the placeholder `Type` in lieu of an actual data type. Similarly, for overloaded
    `operator[]`, the return type of this method is `Type`.
  prefs: []
  type: TYPE_NORMAL
- en: However, looking at a member function that is not inline, we notice that the
    template preamble of `template <class Type>` must precede the member function
    definition. For example, let’s consider the member function definition for `void
    Array<Type>::operator+(Type item);`. In addition to the preamble, the class name
    (preceding the member function name and scope resolution operator, `::`) in the
    function definition must be augmented to include the placeholder type `<Type>`
    in angle brackets. Also, any generic function parameters must use the placeholder
    type of `Type`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in our `main()` function, we merely use the data type of `Array<int>` to
    instantiate a safe, easily resizable array of integers. We could have alternatively
    used `Array<float>` had we instead wanted to instantiate an array of floating-point
    numbers. Under the hood, when we create an instance of a specific array type,
    the preprocessor notices whether we have previously expanded this class for that
    *type*. If not, the class definition and applicable template member functions
    are copied for us and the placeholder types are replaced with the type that we
    need. This is no fewer lines of code than if we had copied, pasted, and slightly
    modified the code ourselves; however, the point is that we only have one version
    to specify and maintain ourselves. This is less error-prone and easier for long-term
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An interesting tangent – std::optional
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, `Array<Type>::operator[]` throws an `out_of_range`
    exception when the selected index is out of bounds. Sometimes, exception handling
    can be programmatically expensive. In such cases, using an optional return type
    may be a useful alternative. Remember, a valid return value for `operator[]` is
    a reference to the memory location for the array element in question. For the
    out-of-bounds index scenario, knowing we simply cannot return the corresponding
    memory location for an array element from this method (it would not make sense),
    an alternative to exception handling may be to use `std::optional<Type>` in the
    return value of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s next take a look at a different full program example to pull together
    template functions and template classes.
  prefs: []
  type: TYPE_NORMAL
- en: Examining a full program example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is useful to see an additional example that illustrates template functions
    and template classes. Let us expand on a `LinkList` program we reviewed most recently
    in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*;
    we will upgrade this program to utilize templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This complete program can be found in our GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine the preceding template class definitions for `LinkListElement`
    and `LinkList`. Initially, we notice that the forward declaration of the `LinkList`
    class contains the necessary template preamble of `template class <Type>`. We
    also should notice that each class definition itself contains the same template
    preamble to dually specify that the class will be a template class and that the
    placeholder for the data type will be the identifier `Type`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinkListElement` class, notice that the data type will be `Type` (the
    placeholder type). Also notice that the placeholder for the type will be necessary
    in the friend class specification of `LinkList`, that is, `friend class LinkList<Type>;`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinkList` class, notice that any reference to the associated class of
    `LinkListElement` will include the type placeholder of `<Type>`. Notice, for example,
    this placeholder usage in the data member declaration of `LinkListElement<Type>
    *head;` or the return type of `RemoveAtFront()`, which is `LinkListElement<Type>`.
    Additionally, notice that the inline function definitions do not require a template
    preamble before each method; we are still covered by the preamble occurring before
    the class definition itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move forward to take a look at the three non-inline member functions
    of the `LinkList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we examine the preceding code, we can see that in the non-inline methods
    of `LinkList`, the template preamble of `template <class Type>` appears before
    each member function definition. We also see that the class name tied with the
    scope resolution operator to the member function name is augmented with `<Type>`,
    for example, `void LinkList<Type>::Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: We notice that the aforementioned template member functions require some part
    of their method to utilize the placeholder type, `Type`. For example, the `InsertAtFront(Type
    *theItem)` method uses both the placeholder `Type` as the data type of the formal
    parameter `theItem`, and to specify the associated class `LinkListElement<Type>`
    when declaring a local pointer variable `temp`. The `RemoveAtFront()` method similarly
    utilizes a local variable of type `LinkListElement<Type>`, hence necessitating
    its use as a template function. Similarly, `Print()` introduces a local variable
    of type `Type` to assist with output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at our `main()` function to see how we can utilize our
    template classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our preceding `main()` function, we utilize our template classes to create
    two types of linked lists, that is, a `LinkList` of integers with the declaration
    `LinkList<int> list1;` and a `LinkList` of floating-point numbers with the declaration
    `LinkList<float> list2;`.
  prefs: []
  type: TYPE_NORMAL
- en: In each case, we instantiate the various link lists, then add elements and print
    the respective lists. In the case of the first `LinkList` instance, we also demonstrate
    how elements can be successively removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Overall, we see that creating a `LinkList<int>` and a `LinkList<float>` is very
    easy. The template code is simply expanded behind the scenes to accommodate each
    data type we desire. We may then ask ourselves, how easy is it to create a linked
    list of `Student` instances? Very easy! We could simply instantiate `LinkList<Student>
    list3;` and call the appropriate `LinkList` methods, such as `list3.InsertAtFront(new
    Student("George", "Katz", 'C', "Mr.", 3.2, "C++", "123GWU"));`.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps we would like to include a means to order our elements in the template
    `LinkList` class, such as by adding an `OrderedInsert()` method (which typically
    relies on `operator<` or `operator>` for the comparison of elements). Would that
    work for all data types? That’s a good question. It could, provided the code written
    in the method is generic to work for all data types. Can operator overloading
    help with this endeavor? Yes!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the mechanics of template classes and functions in action,
    let’s consider how we can ensure that our template classes and functions are fully
    extensible to work for any data type. To do this, let’s consider how operator
    overloading can be of value.
  prefs: []
  type: TYPE_NORMAL
- en: Making templates more flexible and extensible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The addition of templates in C++ gives us the ability to make certain types
    of classes and functions generically specified a single time by the programmer,
    while behind the scenes, the preprocessor generates many versions of that code
    on our behalf. However, in order for a class to truly be extensible to expand
    for many different user defined types, code written within member functions must
    be universally applicable to any type of data. To help with this endeavor, operator
    overloading can be used to extend operations that may easily exist for standard
    types to include definitions for user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we know operator overloading can allow simple operators to work not
    only with standard types but also with user defined types. By overloading operators
    in our template code, we can ensure that our template code is highly reusable
    and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider how we can strengthen templates with the use of operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding operator overloading to further genericize template code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that when overloading an operator, it is important to promote the same
    meaning that the operator has for standard types. Imagine that we would like to
    add an `OrderedInsert()` method to our `LinkList` class. The body of this member
    function might rely on comparing two elements to see which one should go before
    the other. The easiest way to do this is using `operator<`. This operator is easily
    defined to work with standard types, but will it work with user defined types?
    It can, provided we overload the operator to work with the desired types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example where we will need to overload an operator
    to make the member function code universally applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template member function, we rely on `operator<` to be able
    to work with any data type in which we would like to utilize this template class.
    That is, when the preprocessor expands this code for a specific, user defined
    type, the `<` operator must work for whatever data type this method has been specifically
    expanded for.
  prefs: []
  type: TYPE_NORMAL
- en: Should we wish to create a `LinkList` of `Student` instances and apply an `OrderedInsert()`
    of one `Student` versus another, we then need to ensure that the comparison with
    `operator<` is defined for two `Student` instances. Of course, by default, `operator<`
    is only defined for standard types. But, if we simply overload `operator<` for
    `Student`, we can ensure that the `LinkList<Type>::OrderedInsert()` method will
    work for `Student` data types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can overload `operator<` for `Student` instances,
    both as a member function or as a non-member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can recognize `operator<` implemented as either a
    member function of `Student` or as a non-member function. If you have access to
    the class definition for `Student`, the preferred approach would be to utilize
    the member function definition for this operator function. However, sometimes,
    we do not have access to modify a class. In such cases, we must utilize the non-member
    function approach. Nonetheless, in either implementation, we simply compare the
    `gpa` of the two `Student` instances, and return `true` if the first instance
    has a lower `gpa` than the second `Student` instance, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `operator<` has been defined for two `Student` instances, we can return
    to our prior template function of `LinkList<Type>::OrderedInsert(Type *)`, which
    utilizes operator `<` for comparison of two objects of type `Type` in the `LinkList`.
    When a `LinkList<Student>` is made somewhere in our code, the template code for
    `LinkList` and `LinkListElement` will be expanded by the preprocessor for `Student`;
    `Type` will be replaced with `Student`. When the expanded code is then compiled,
    the code in the expanded `LinkList<Student>::OrderedInsert()` will compile without
    error, as `operator<` has been defined for two `Student` objects.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we neglect to overload `operator<` for a given type, however,
    `OrderedInsert()` (or another method relying on `operator<`) is never called in
    our code on an object of that same expanded template type? Believe it or not,
    the code will compile and work without issue. In this case, we are not actually
    calling a function (that is, `OrderedInsert()`) that would require `operator<`
    to be implemented for that type. Because the function is never called, the template
    expansion for that member function is skipped. The compiler has no reason to discover
    that `operator<` should have been overloaded for the type in question (in order
    for the method to compile successfully). The uncalled method has simply not been
    expanded for the compiler to verify.
  prefs: []
  type: TYPE_NORMAL
- en: By using operator overloading to complement template classes and functions,
    we can make template code even further extensible by ensuring that typical operators
    used within method bodies can be made applicable to any type we would want to
    utilize in the template expansion. Our code becomes more widely applicable.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to utilize template functions and classes, and how operator
    overloading can enhance templates to create even more extensible code. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our C++ programming knowledge beyond OOP
    language features to include additional language features that will enable us
    to write more extensible code. We have learned how to utilize template functions
    and template classes, and how operator overloading nicely supports these endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that templates can allow us to generically specify a class or function
    with respect to the data type primarily used within that class or function. We
    have seen that template classes inevitably utilize template functions because
    those methods generally need to generically use the data upon which the class
    is built. We have seen that by taking advantage of operator overloading for user
    defined types, we can take advantage of method bodies written using simple operators
    to accommodate usage by more complex data types, making the template code much
    more useful and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: The power of templates coupled with operator overloading (to make a method usable
    for nearly any type) makes C++’s implementation of generics much more powerful
    than simple type replacement.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand that using templates can allow us to specify a class or function
    just one time more abstractly, and allow the preprocessor to generate many versions
    of that class or function for us, based upon specific data types that may be needed
    within the application.
  prefs: []
  type: TYPE_NORMAL
- en: By allowing the preprocessor to expand many versions of a template class or
    set of template functions for us based on types needed in an application, the
    work of creating many similar classes or functions (and maintaining those versions)
    is passed to C++, rather than the programmer. In addition to having less code
    for the user to maintain, changes made in the template classes or functions need
    only be made in one place – the preprocessor will re-expand the code without errors
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: We have added additional, useful features to our C++ repertoire through examining
    templates, which, combined with operator overloading, will ensure we can write
    highly extensible and reusable code for nearly any data type. We are now ready
    to continue forward with [*Chapter 14*](B19087_14.xhtml#_idTextAnchor595), *Understanding
    STL Basics*, so that we can continue extending our C++ programming skills with
    useful C++ library features that will make us better programmers. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convert your `ArrayInt` class from [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526),
    *Friends and Operator Overloading*, to a template `Array` class to support a dynamically
    allocated array of any data type that can be easily resized and has built-in bounds
    checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Consider what operators, if any, you will need to overload to allow generic
    code within each method to support any user defined types you may wish to store
    in the template `Array` type.
  prefs: []
  type: TYPE_NORMAL
- en: b. Using your template `Array` class, create an array of `Student` instances.
    Utilize various member functions to demonstrate that various template functions
    operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the template `LinkList` class, complete the implementation for `LinkList<Type>::OrderedInsert()`.
    Create a `LinkList` of `Student` instances in `main()`. After several `Student`
    instances have been inserted in the list using `OrderedInsert()`, verify that
    this method works correctly by displaying each `Student` and their `gpa`. The
    `Student` instances should be ordered from lowest to highest `gpa`. You may wish
    to use the online code as a starting point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
