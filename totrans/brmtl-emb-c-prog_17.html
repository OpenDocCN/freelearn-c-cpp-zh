<html><head></head><body>
<div><div><div><h1 id="_idParaDest-285" class="chapter-number"><a id="_idTextAnchor467"/>17</h1>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor468"/>Direct Memory Access (DMA)</h1>
			<p>In this chapter, we will explore <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>), a powerful feature in microcontrollers that allows peripherals to transfer data to and from memory without involving the CPU. This functionality is critical for improving data throughput and freeing up the CPU to handle other tasks, making it fundamental to high-performance embedded system development.</p>
			<p>We will begin by understanding the basic principles of DMA and its significance in embedded systems. We will then delve into the specifics of the DMA controller in STM32F4 microcontrollers, examining its structure and features and how it manages data transfers. Following this, we will apply this theoretical knowledge to develop practical DMA drivers for various use cases, including memory-to-memory transfers, <strong class="bold">Analog-to-Digital Converter</strong> (<strong class="bold">ADC</strong>) data transfers, and <strong class="bold">Universal Asynchronous Receiver-Transmitter</strong> (<strong class="bold">UART</strong>) communications.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>An overview of DMA</li>
				<li>The STM32F4 DMA</li>
				<li>Developing the DMA ADC driver</li>
				<li>Developing the DMA UART driver</li>
				<li>Developing the DMA memory-to-memory driver</li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of how DMA works and how to implement it in your projects. You will be able to develop efficient DMA drivers to handle data transfers in various scenarios, significantly enhancing the performance and responsiveness of your embedded systems.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor469"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor470"/>Understanding Direct Memory Access (DMA)</h1>
			<p>DMA is a feature that can<a id="_idIndexMarker1176"/> significantly elevate the performance of your embedded systems. If you’ve been dealing with data transfers in your microcontroller projects, you know how taxing it can be on the CPU to handle all that data movement. This is where DMA steps in as a game-changer, offloading the data transfer tasks from the CPU and allowing it to focus on more critical functions. Let’s see how it works.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor471"/>How DMA works</h2>
			<p>So, what exactly is DMA, and how does it work? In simple terms, DMA is a method that allows peripherals within a microcontroller to<a id="_idIndexMarker1177"/> transfer data directly to and from memory, without requiring continuous CPU intervention. Imagine it as a dedicated assistant that takes over the tedious task of moving boxes (data) so that you (the CPU) can focus on more important work, such as solving complex problems or managing other peripherals.</p>
			<p>A typical DMA controller in a microcontroller has multiple channels, each capable of handling a specific data transfer operation. Each channel can be configured independently to manage transfers between various peripherals and memory.</p>
			<p>Here’s a step-by-step look at how DMA generally operates:</p>
			<ol>
				<li><strong class="bold">Initialization</strong>: The DMA controller and channels are configured. This setup includes specifying the source and destination addresses, the direction of data transfer, and the number of data units to transfer.</li>
				<li><strong class="bold">Trigger</strong>: The data transfer is initiated by a trigger, which can be an event such as a peripheral signaling that it’s ready to send or receive data, or a software command.</li>
				<li><strong class="bold">Data transfer</strong>: Once triggered, the DMA controller takes over, reading data from the source address and writing it to the destination address. This process continues until the specified number of data units is transferred.</li>
				<li><strong class="bold">Completion</strong>: Upon completing the transfer, the DMA controller can generate an interrupt to notify the CPU <a id="_idIndexMarker1178"/>that the transfer is done, allowing the system to perform any necessary post-transfer processing.</li>
			</ol>
			<p>Next, let’s take a look at some key features of DMA controllers.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor472"/>Key features</h2>
			<p>DMA controllers are packed with features that <a id="_idIndexMarker1179"/>make them versatile and powerful. Let’s break down some of the key specifications you’ll often encounter:</p>
			<ul>
				<li><strong class="bold">Channels and streams</strong>: DMA controllers typically have multiple channels and streams, each capable of handling a different transfer. For instance, the STM32F4 microcontroller has up to 16 streams in its DMA controllers.</li>
				<li><strong class="bold">Priorities</strong>: Channels can be assigned different priority levels, ensuring that more critical transfers get precedence over less critical ones.</li>
				<li><strong class="bold">Transfer Types</strong>: DMA can handle various types of transfers, including memory-to-memory, peripheral-to-memory, and memory-to-peripheral.</li>
				<li><strong class="bold">FIFO</strong>: Some DMA controllers <a id="_idIndexMarker1180"/>come with a <strong class="bold">First-In-First-Out</strong> (<strong class="bold">FIFO</strong>) buffer, which helps manage data flow and improve efficiency, especially in burst transfers.</li>
				<li><strong class="bold">Circular mode</strong>: This mode allows the DMA to continuously transfer data in a loop, which is particularly useful for peripherals that need constant data streaming, such as audio or video feeds.</li>
				<li><strong class="bold">Interrupts</strong>: DMA controllers can generate interrupts on transfer completion, half-transfer completion, and transfer errors, allowing the CPU to react appropriately to different stages of the transfer.</li>
			</ul>
			<p>To understand the real power of DMA, let’s look at some common use cases where DMA shines.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor473"/>Common use cases</h2>
			<p>Here are some common use <a id="_idIndexMarker1181"/>cases of DMA:</p>
			<ul>
				<li><strong class="bold">Audio streaming</strong>: DMA is heavily used in audio applications where continuous data streaming is essential. For instance, in a digital audio player, the audio samples must be <a id="_idIndexMarker1182"/>continuously sent to a <strong class="bold">Digital-to-Analog Converter</strong> (<strong class="bold">DAC</strong>). Using DMA, the audio data can be streamed from memory to the DAC without CPU intervention, ensuring smooth playback and freeing up the CPU to manage the user interface and other tasks.</li>
				<li><strong class="bold">Sensor data acquisition</strong>: In applications such as environmental monitoring or industrial automation, sensors often need to sample data at precise intervals. For example, an ADC can be configured to continuously sample temperature data, with DMA transferring the sampled data directly to memory. This setup ensures that the CPU isn’t bogged down with handling each individual sample, thus maintaining efficient and timely data collection.</li>
				<li><strong class="bold">Communication interfaces</strong>: DMA is a lifesaver when dealing with high-speed communication protocols such as UART, SPI, or I2C. Consider a scenario where an embedded system needs to log data received over UART to an SD card. Without DMA, the CPU would need to handle each byte of data, process it, and then write it to the SD card, which can be highly inefficient. With DMA, the data received over UART can be directly written to memory, and another DMA channel can transfer it to the SD card, all with minimal CPU intervention.</li>
				<li><strong class="bold">Graphics processing</strong>: DMA is also crucial in applications involving graphics, such as updating a display buffer. In a system where the display needs to be refreshed continuously, the DMA can handle the transfer of image data from memory to the display controller. This ensures smooth and flicker-free graphics rendering, while the CPU can focus on generating the next frame or managing user inputs.</li>
			</ul>
			<p>With this in mind, let’s compare some DMA solutions to non-DMA solutions.</p>
			<h3>Case study 1 – audio streaming</h3>
			<p><strong class="bold">Scenario</strong>: You are developing an <a id="_idIndexMarker1183"/>audio playback system that streams digital audio data from a microcontroller to a DAC.</p>
			<p><strong class="bold">Without DMA</strong>: The CPU is responsible for fetching each audio sample from memory and sending it to the DAC. Given the high sampling rate required for audio applications (e.g., 44.1 kHz for CD-quality audio), the CPU must handle tens of thousands of interrupts per second just to maintain the audio stream. This constant load significantly limits the CPU’s ability to perform other tasks, potentially leading to audio glitches and reduced system responsiveness.</p>
			<p><strong class="bold">With DMA</strong>: The DMA controller is configured to transfer audio data directly from memory to the DAC. The CPU sets up the DMA transfer and then handles higher-level tasks, only occasionally checking the status of the transfer. This setup ensures smooth and uninterrupted audio playback while freeing up the CPU to manage other aspects of the system, such as user interface and control logic.</p>
			<h3>Case study 2 – high-speed data acquisition</h3>
			<p><strong class="bold">Scenario</strong>: You are developing a data<a id="_idIndexMarker1184"/> acquisition system that continuously samples data from multiple sensors via ADCs and stores the data for later analysis.</p>
			<p><strong class="bold">Without DMA</strong>: The CPU must handle each ADC conversion, read the data, and store it in memory. If the sampling rate is high, the CPU can become overwhelmed, leading to missed samples and unreliable data collection. This approach can also complicate real-time data processing and analysis, as the CPU is bogged down with managing the data flow.</p>
			<p><strong class="bold">With DMA</strong>: The ADC is configured to generate DMA requests. Each time a conversion is complete, the DMA controller transfers the data from the ADC to memory without CPU intervention. The CPU can then process the collected data in batches, ensuring that no samples are missed and enabling real-time data analysis and decision-making.</p>
			<h3>Case study 3 – an LCD display refresh</h3>
			<p><strong class="bold">Scenario</strong>: You are developing a<a id="_idIndexMarker1185"/> graphical application that continuously updates an LCD display with new data.</p>
			<p><strong class="bold">Without DMA</strong>: The CPU must update the display by sending each pixel or line of data directly to the LCD controller. This process can be very CPU-intensive, especially for high-resolution displays, leading to sluggish performance and reduced responsiveness in the user interface.</p>
			<p><strong class="bold">With DMA</strong>: The DMA controller is configured to transfer display data from memory to the LCD controller. The CPU sets <a id="_idIndexMarker1186"/>up the DMA transfer and then focuses on generating new graphical data or handling user inputs. The DMA controller ensures that the display is updated smoothly and efficiently.</p>
			<p>In each of the case studies, we’ve seen how using DMA can transform a system’s capabilities, freeing up the CPU to handle more critical tasks and ensuring that data transfers are handled efficiently and reliably. Understanding and implementing DMA in your projects can lead to more robust, responsive, and high-performance embedded systems.</p>
			<p>In the following section, we will delve deeper into the specifics of the STM32F4 DMA controller, exploring its architecture, key registers, and practical implementation techniques.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor474"/>The DMA modules of the STM32F4 microcontroller</h1>
			<p>Each STM32F4 microcontroller<a id="_idIndexMarker1187"/> is equipped with <strong class="bold">two DMA</strong> controllers, each supporting up to <strong class="bold">8 streams</strong>. Each stream can manage <a id="_idIndexMarker1188"/>multiple requests, providing up to <strong class="bold">16 streams</strong> in total to handle various data transfer tasks. A <strong class="bold">stream</strong> is a unidirectional pathway that facilitates data transfer between a source and a destination. The<a id="_idIndexMarker1189"/> architecture includes an <strong class="bold">arbiter</strong> to prioritize these DMA requests, ensuring that high-priority transfers are handled promptly.</p>
			<p>Let’s see some key features of the STM32F4 DMA controller.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor475"/>The key features of the STM32F4 DMA controller</h2>
			<p>The following are the key features <a id="_idIndexMarker1190"/>of the STM32F4 DMA controller:</p>
			<ul>
				<li><strong class="bold">Independent FIFO</strong>: Each stream includes a <strong class="bold">four-word FIFO buffer</strong>, which can operate in either direct mode or FIFO mode. In direct mode, data transfers occur immediately upon request, while FIFO mode allows for <strong class="bold">threshold-level buffering</strong>, enhancing efficiency for<a id="_idIndexMarker1191"/> burst data transfers.</li>
				<li><strong class="bold">Flexible configuration</strong>: Each stream can be configured to handle the following:<ul><li>Peripheral-to-memory</li><li>Memory-to-peripheral</li><li>Memory-to-memory transfers</li></ul></li>
			</ul>
			<p>Additionally, streams can be set up for regular or double-buffer transfers, the latter enabling seamless data handling by swapping memory buffers automatically:</p>
			<ul>
				<li><strong class="bold">Prioritization and arbitration</strong>: DMA stream requests are prioritized via software with four levels – <strong class="bold">very high</strong>, <strong class="bold">high</strong>, <strong class="bold">medium</strong>, and <strong class="bold">low</strong>. If two streams have the same priority, hardware prioritization based on the stream number ensures orderly data transfer.</li>
				<li><strong class="bold">Incremental and burst transfers</strong>: The DMA controller supports both incremental and non-incremental addressing for source and destination. It can manage burst transfers of <strong class="bold">4, 8, or 16 beats</strong>, optimizing bandwidth usage. The term <strong class="bold">beat</strong> refers to the individual units of data that are transferred in a single DMA transaction.</li>
				<li><strong class="bold">Interrupts and error handling</strong>: Each stream supports multiple event flags such as transfer complete, half-transfer, transfer error, FIFO error, and direct mode error. These<a id="_idIndexMarker1192"/> flags can trigger interrupts, providing robust error handling and status monitoring.</li>
			</ul>
			<p>To fully utilize the STM32F DMA controller, it’s important to understand DMA transactions and channel selection. Let’s break these concepts down.</p>
			<ul>
				<li><code>DMA_SxNDTR</code> register to track the number of remaining data items</li></ul></li>
				<li><code>CHSEL</code> bits in the <code>DMA_SxCR</code> register. This flexibility allows various peripherals to initiate DMA requests efficiently.</li>
			</ul>
			<p>Previously, we discussed that the STM32F4 DMA controller supports three distinct transfer modes. Now, let’s explore the characteristics of each mode.</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor476"/>Transfer modes</h2>
			<p>There are three transfer modes:</p>
			<ul>
				<li><code>EN</code> bit in the <code>DMA_SxCR</code> register. The stream<a id="_idIndexMarker1195"/> transfers data from the<a id="_idIndexMarker1196"/> peripheral to memory, using the FIFO buffer if enabled.</li>
				<li><strong class="bold">Memory-to-peripheral mode</strong>: This is similar to peripheral-to-memory, but the transfer direction is reversed. Data is<a id="_idIndexMarker1197"/> loaded from memory and sent to the peripheral.</li>
				<li><strong class="bold">Memory-to-memory mode</strong>: This mode is unique, as it does not require peripheral requests. The DMA<a id="_idIndexMarker1198"/> stream transfers data between two memory locations, using the FIFO buffer if enabled. This is particularly useful for large data transfers within memory.</li>
			</ul>
			<p>The DMA controller can automatically increment source and destination pointers, facilitating efficient data transfers across different memory regions. This is configurable via the <code>PINC</code> and <code>MINC</code> bits in the <code>DMA_SxCR</code> register.</p>
			<p>The STM32F4 DMA controller also provides data mode options.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor477"/>DMA data modes</h2>
			<p>This data mode options include the following:</p>
			<ul>
				<li><code>DMA_SxNDTR</code> register. This is especially useful for applications such as ADC sampling, where data needs to be continuously recorded.</li>
				<li><strong class="bold">Double buffer mode</strong>: Double buffer mode enhances efficiency by allowing the DMA controller to swap <a id="_idIndexMarker1200"/>between two memory buffers automatically. This ensures continuous data processing. While the CPU works on one buffer, the DMA can load the next set of data into the other buffer.</li>
			</ul>
			<p>In the next section, we will <a id="_idIndexMarker1201"/>examine the STM32F4 DMA block diagram from the reference manual. This will help us better understand the key characteristics and functionalities of the DMA controller.</p>
			<h2 id="_idParaDest-296">The <a id="_idTextAnchor478"/>STM32F4 DMA block diagram</h2>
			<p>The DMA has <strong class="bold">two ports</strong> for data transfer – one<a id="_idIndexMarker1202"/> peripheral port and one memory port, as shown in <em class="italic">Figure 17</em><em class="italic">.1</em>.</p>
			<div><div><img src="img/B21914_17_1.jpg" alt="Figure 17.1: The DMA module, indicating the data transfer ports" width="1650" height="1209"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1: The DMA module, indicating the data transfer ports</p>
			<p>Each of the two DMA modules features <strong class="bold">eight distinct streams</strong>, with each stream dedicated to handling memory access requests from various peripherals.</p>
			<div><div><img src="img/B21914_17_2.jpg" alt="Figure 17.2: The DMA module, indicating the streams" width="1650" height="1302"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2: The DMA module, indicating the streams</p>
			<p>Each stream can accommodate up to <strong class="bold">eight selectable channels</strong>, which are software-configurable to enable <a id="_idIndexMarker1203"/>multiple peripherals to initiate DMA requests. However, within any given stream, only one channel can be active at a time.</p>
			<div><div><img src="img/B21914_17_3.jpg" alt="Figure 17.3: The DMA module, with channels zoomed in" width="1641" height="1012"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3: The DMA module, with channels zoomed in</p>
			<p>To find the mappings of DMA channels and streams to the various peripherals of the microcontroller, refer to <em class="italic">page 170</em> of the reference manual (<strong class="bold">RM0383</strong>).</p>
			<p>Before we start developing our DMA drivers, the final piece of the puzzle involves familiarizing ourselves <a id="_idIndexMarker1204"/>with the key DMA registers.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor479"/>The key STM32 DMA registers</h2>
			<p>In this section, we will <a id="_idIndexMarker1205"/>explore the characteristics and functions of some of the crucial registers within the DMA peripheral, starting with the<a id="_idIndexMarker1206"/> DMA Str<a id="_idTextAnchor480"/>eam Configuration Register.</p>
			<h3>The DMA Stream Configuration Register (DMA_SxCR)</h3>
			<p>The DMA Stream Configuration Register (<code>DMA_SxCR</code>) is one of the primary registers used to configure a <a id="_idIndexMarker1207"/>DMA stream’s operational settings. This register allows us to set up various parameters, such as the <strong class="bold">data direction</strong>, the <strong class="bold">size</strong> of the data items, and the <strong class="bold">priority</strong> level of the stream. The<a id="_idIndexMarker1208"/> key bits in this register include the following:</p>
			<ul>
				<li><strong class="bold">EN</strong>: Stream enable. Setting this bit activates the stream.</li>
				<li><strong class="bold">CHSEL[2:0]</strong>: Channel selection. These bits select the DMA channel for the stream.</li>
				<li><strong class="bold">DIR[1:0]</strong>: Data transfer direction. These bits specify the direction of the data transfer (peripheral-to-memory, memory-to-peripheral, or memory-to-memory).</li>
				<li><strong class="bold">CIRC</strong>: Circular mode. Setting this bit enables circular mode, which allows continuous data transfers.</li>
				<li><strong class="bold">PINC</strong>: Peripheral increment mode. When set, this bit increments the peripheral address after each data transfer.</li>
				<li><strong class="bold">MINC</strong>: Memory increment mode. When set, this bit increments the memory address after each data transfer.</li>
				<li><strong class="bold">PSIZE[1:0]</strong>: Peripheral data size. These bits specify the size of the data items read from or written to the peripheral (8-bit, 16-bit, or 32-bit).</li>
				<li><strong class="bold">MSIZE[1:0]</strong>: Memory data<a id="_idIndexMarker1209"/> size. These bits specify the size of the data items read from or written to memory.</li>
				<li><strong class="bold">PL[1:0]</strong>: Priority level. These bits set the priority level of the stream (low, medium, high, or very high).</li>
			</ul>
			<p>You can find detailed information <a id="_idIndexMarker1210"/>about this register on <em class="italic">page 190</em> of the STM32F411 reference manual (RM0383). Next, we have the DMA Stream Number of Data Register (<code>DMA_SxNDTR</code>).</p>
			<h3>DMA Stream Number of Data Register (DMA_SxNDTR)</h3>
			<p>The DMA Stream <a id="_idIndexMarker1211"/>Number of Data Register (<code>DMA_SxNDTR</code>) specifies the number of data items to be transferred by<a id="_idIndexMarker1212"/> the DMA<a id="_idIndexMarker1213"/> stream. This register is crucial for controlling the length of the data transfer.</p>
			<p>The only field in this register is <strong class="bold">NDT[15:0]</strong>. This stands for the number of data items. This field specifies the total number of data items to be transferred. The value in this register is decremented after each transfer until it reaches zero.</p>
			<p>Further information about this register can be found on <em class="italic">page 193</em> of the reference manual. Let’s move on to the DMA Stream Peripheral Address Register (<code>DMA_SxPAR</code>).</p>
			<h3>DMA Stream Peripheral Address Register (DMA_SxPAR)</h3>
			<p>The DMA Stream Peripheral <a id="_idIndexMarker1214"/>Address Register (<code>DMA_SxPAR</code>) holds<a id="_idIndexMarker1215"/> the address of the peripheral data register that the data will be read to or written from.</p>
			<p>The only field in this register is <strong class="bold">PA[31:0]</strong>. This stands for <strong class="bold">peripheral address</strong>. This field contains the address<a id="_idIndexMarker1216"/> of the peripheral data register involved in the data transfer.</p>
			<p>More details about this register can be found on <em class="italic">page 194</em> of the reference manual. Finally, we have the DMA<a id="_idIndexMarker1217"/> Stream Memory Address Registers (<code>DMA_SxM0AR</code> and <code>DMA_SxM1AR</code>).</p>
			<h3>DMA Stream Memory Address Registers (DMA_SxM0AR and DMA_SxM1AR)</h3>
			<p>These registers store the addresses of the memory locations used for data transfers. The <code>DMA_SxM0AR</code> register is used<a id="_idIndexMarker1218"/> for single buffer mode, while both <code>DMA_SxM0AR</code> and <code>DMA_SxM1AR</code> are used in double buffer mode.</p>
			<p>The only field in these<a id="_idIndexMarker1219"/> registers is <strong class="bold">MA[31:0]</strong>. This stands for <strong class="bold">memory address</strong>. This field contains the <a id="_idIndexMarker1220"/>address of the memory location involved in the data transfer. For detailed information, refer to <em class="italic">pages 194</em> of the reference manual.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor481"/>Developing the ADC DMA driver</h1>
			<p>In this section, we will develop three distinct DMA drivers – one for transferring ADC data, another for UART data, and a third for transferring data between memory locations. Let’s begin with the<a id="_idIndexMarker1221"/> ADC DMA driver.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor482"/>The ADC DMA driver</h2>
			<p>Create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project <code>ADC_DMA</code>. Next, create a new file named <code>adc_dma.c</code> in the <code>Src</code> folder and another file named <code>adc_dma.h</code> in the <code>Inc</code> folder.</p>
			<p>Populate your <code>adc_dma.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adc_dma.h"
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN            (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR1_SCAN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR2_DMA            (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR2_DDS            (1U&lt;&lt;9)
<strong class="bold">#define</strong> CR2_CONT        (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_ADCON        (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_SWSTART        (1U&lt;&lt;30)
<strong class="bold">#define</strong> DMA2EN                (1U&lt;&lt;22)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_CIRC        (1U&lt;&lt;8)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
uint16_t adc_raw_data[NUM_OF_CHANNELS];
<strong class="bold">void adc_dma_init</strong>(<strong class="bold">void</strong>)
{
    /************GPIO Configuration**********/
    /*Enable clock access to ADC GPIO Pin's Port*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA0 and PA1 mode to analog mode*/
    GPIOA-&gt;MODER |= (1U&lt;&lt;0);
    GPIOA-&gt;MODER |= (1U&lt;&lt;1);
    GPIOA-&gt;MODER |= (1U&lt;&lt;2);
    GPIOA-&gt;MODER |= (1U&lt;&lt;3);
    /************ADC Configuration**********/
    /*Enable clock access to ADC*/
    RCC-&gt;APB2ENR |= ADC1EN;
    /*Set sequence length*/
    ADC1-&gt;SQR1 |= (1U&lt;&lt;20);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;21);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;22);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;23);
    /*Set sequence*/
    ADC1-&gt;SQR3 = (0U&lt;&lt;0) | (1U&lt;&lt;5);
    /*Enable scan mode*/
    ADC1-&gt;CR1 = CR1_SCAN;
    /*Select to use DMA*/
    ADC1-&gt;CR2 |=CR2_CONT |CR2_DMA|CR2_DDS;
    /************DMA Configuration**********/
    /*Enable clock access to DMA*/
    RCC-&gt;AHB1ENR |=DMA2EN;
    /*Disable DMA stream*/
    DMA2_Stream0-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till DMA is disabled*/
    <strong class="bold">while</strong>((DMA2_Stream0-&gt;CR &amp; DMA_SCR_EN)){}
    /*Enable Circular mode*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_CIRC;
    /*Set MSIZE i.e Memory data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;13);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;14);
    /*Set PSIZE i.e Peripheral data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;11);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;12);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_MINC;
    /*Set <strong class="bold">periph</strong> address*/
    DMA2_Stream0-&gt;PAR = (uint32_t)(&amp;(ADC1-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA2_Stream0-&gt;M0AR = (uint32_t)(&amp;adc_raw_data);
    /*Set number of transfer*/
    DMA2_Stream0-&gt;NDTR = (uint16_t)NUM_OF_CHANNELS;
    /*Enable DMA stream*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_EN;
    /************ADC Configuration**********/
    /*Enable ADC*/
    ADC1-&gt;CR2 |=CR2_ADCON;
    /*Start ADC*/
    ADC1-&gt;CR2 |=CR2_SWSTART;
}</pre>			<p>Let’s go through each part of the code step by step to understand its purpose and functionality.</p>
			<ol>
				<li><code>adc_dma.h</code> header file, which calls the <code>stm32f4xx.h</code> file and contains a macro for the number of channels <a id="_idIndexMarker1222"/>of our DMA driver. We then define several constants using <code>#define</code> statements. These constants represent bit masks for various registers and control flags, making the code more readable and maintainable.</li>
				<li><code>adc_raw_data</code>, that stores the raw ADC data. The size of this array is determined by a predefined constant, <code>NUM_OF_CHANNELS</code>.</li>
				<li><code>adc_dma_init</code> function, we begin by enabling the clock for GPIOA, which is necessary for configuring the GPIO pins used by the ADC. We then set the mode of the <code>PA0</code> and <code>PA1</code> pins to analog, as they are connected to the ADC channels.</li>
				<li>Next, we enable the clock for ADC1 and configure the ADC sequence length and channel sequence. We set the ADC to scan mode, allowing it to convert multiple channels sequentially. Additionally, we enable DMA and continuous conversion mode for the ADC.</li>
				<li><code>DMA2</code> and ensure that the DMA stream is disabled before making any configurations. We configure the DMA stream for circular mode, which allows continuous data transfer. We set the memory and peripheral data sizes to half-word (16 bits). We enable memory address increment to correctly move through the <code>adc_raw_data</code> array and set the peripheral address to <a id="_idIndexMarker1223"/>the ADC data register. We specify the number of data items to transfer and, finally, enable the DMA stream.</li>
				<li><strong class="bold">Enable and start ADC</strong>: In the final steps, we simply enable the ADC and start the conversion proce<a id="_idTextAnchor483"/>ss by setting the appropriate control bits.</li>
			</ol>
			<p>Our next task is to populate the <code>adc_dma.h</code> file. Here is the code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADC_DMA_H__
<strong class="bold">#define</strong> ADC_DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void adc_dma_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">#define</strong> NUM_OF_CHANNELS        2
<code>main.c</code> file. Update your <code>main.c</code> file, as shown here:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adc_dma.h"
<strong class="bold">extern</strong> uint16_t adc_raw_data[NUM_OF_CHANNELS];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize ADC DMA*/
    adc_dma_init();
    <strong class="bold">while</strong>(1)
    {
        <strong class="bold">printf</strong>("Value from sensor one : %d \n\r ",adc_raw_data[0]);
        <strong class="bold">printf</strong>("Value from sensor two : %d \n\r ",adc_raw_data[1]);
        <strong class="bold">for</strong>( <strong class="bold">int</strong> i = 0; i &lt; 90000; i++){}
    }
}</pre>			<p>This code initializes the UART for debugging, and it sets up the ADC with DMA to continuously read sensor data from ADC channels connected to GPIO pins. In the main function, we start by <a id="_idIndexMarker1224"/>initializing the UART for communication, and then we call the <code>adc_dma_init</code> function to configure the ADC and DMA for data transfers. In the infinite loop, we repeatedly print the values from two sensors stored in the <code>adc_raw_data</code> array to the console.</p>
			<p>To test the project, follow the steps we outlined in <a href="B21914_11.xhtml#_idTextAnchor303"><em class="italic">Chapter 11</em></a>. Let’s proceed by developing the UART DMA driver.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor484"/>Developing the UART DMA driver</h1>
			<p>Create a copy of your <a id="_idIndexMarker1225"/>previous project in your IDE. Rename this copied p<a id="_idTextAnchor485"/>roject <code>UART_DMA</code>. Next, create a new file named <code>uart_dma.c</code> in the <code>Src</code> folder and another file named <code>uart_dma.h</code> in the <code>Inc</code> folder. Update your <code>uart_dma.c</code> file, as shown here:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "uart_dma.h"
<strong class="bold">#define</strong> UART2EN            (1U&lt;&lt;17)
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR1_TE            (1U&lt;&lt;3)
<strong class="bold">#define</strong> CR1_RE            (1U&lt;&lt;2)
<strong class="bold">#define</strong> CR1_UE            (1U&lt;&lt;13)
<strong class="bold">#define</strong> SR_TXE            (1U&lt;&lt;7)
<strong class="bold">#define</strong> CR3_DMAT        (1U&lt;&lt;7)
<strong class="bold">#define</strong> CR3_DMAR        (1U&lt;&lt;6)
<strong class="bold">#define</strong> SR_TC            (1U&lt;&lt;6)
<strong class="bold">#define</strong> CR1_TCIE        (1U&lt;&lt;6)
<strong class="bold">#define</strong> UART_BAUDRATE    115200
<strong class="bold">#define</strong> CLK                16000000
<strong class="bold">#define</strong> DMA1EN                (1U&lt;&lt;21)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_CIRC        (1U&lt;&lt;8)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
<strong class="bold">#define</strong> HIFCR_CDMEIF5        (1U&lt;&lt;8)
<strong class="bold">#define</strong> HIFCR_CTEIF5        (1U&lt;&lt;9)
<strong class="bold">#define</strong> HIFCR_CTCIF5        (1U&lt;&lt;11)
<strong class="bold">#define</strong> HIFCR_CDMEIF6        (1U&lt;&lt;18)
<strong class="bold">#define</strong> HIFCR_CTEIF6        (1U&lt;&lt;19)
<strong class="bold">#define</strong> HIFCR_CTCIF6        (1U&lt;&lt;21)
<strong class="bold">#define</strong> HIFSR_TCIF5        (1U&lt;&lt;11)
<strong class="bold">#define</strong> HIFSR_TCIF6        (1U&lt;&lt;21)
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk, uint32_t baudrate);
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk, uint32_t baudrate);
<strong class="bold">char</strong> uart_data_buffer[UART_DATA_BUFF_SIZE];
uint8_t g_rx_cmplt;
uint8_t g_tx_cmplt;
uint8_t g_uart_cmplt;
<strong class="bold">void uart2_rx_tx_init</strong>(<strong class="bold">void</strong>)
{
    /*************Configure UART GPIO pin********************/
    /*1.Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*2.Set PA2 mode to alternate function mode*/
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;4);
    GPIOA-&gt;MODER |=     (1U&lt;&lt;5);
    /*3.Set PA3 mode to alternate function mode*/
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;6);
    GPIOA-&gt;MODER |=     (1U&lt;&lt;7);
    /*4.Set PA2 alternate function function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;8);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;9);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;10);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;11);
    /*5.Set PA3 alternate function function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;12);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;13);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;14);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;15);
    /*************Configure UART Module********************/
    /*6. Enable clock access to UART2*/
    RCC-&gt;APB1ENR |= UART2EN;
    /*7. Set <strong class="bold">baudrate</strong>*/
    uart_set_baudrate(CLK,UART_BAUDRATE);
    /*8. Select to use DMA for TX and RX*/
    USART2-&gt;CR3 = CR3_DMAT |CR3_DMAR;
    /*9. Set transfer direction*/
    USART2-&gt;CR1 = CR1_TE |CR1_RE;
    /*10.Clear TC flag*/
    USART2-&gt;SR &amp;=~SR_TC;
    /*11.Enable TCIE*/
    USART2-&gt;CR1 |=CR1_TCIE;
    /*12. Enable <strong class="bold">uart</strong> module*/
    USART2-&gt;CR1 |= CR1_UE;
    /*13.Enable USART2 interrupt in the NVIC*/
    NVIC_EnableIRQ(<strong class="bold">USART2_IRQn</strong>);
}</pre>			<p>Next, we have the initialization function:</p>
			<pre class="source-code">
void dma1_init(void)
{
   /*Enable clock access to DMA*/
    RCC-&gt;AHB1ENR |=DMA1EN;
    /*Enable DMA Stream6 Interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA1_Stream6_IRQn</strong>);
}</pre>			<p><a id="_idIndexMarker1226"/>And then, the function for configuring the <code>rx</code> stream:</p>
			<pre class="source-code">
void dma1_stream5_uart_rx_config(void)
{
    /*Disable DMA stream*/
    DMA1_Stream5-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till DMA Stream is disabled*/
    while((DMA1_Stream5-&gt;CR &amp; DMA_SCR_EN)){}
    /*Clear interrupt flags for stream 5*/
    DMA1-&gt;HIFCR = HIFCR_CDMEIF5 |HIFCR_CTEIF5|HIFCR_CTCIF5;
    /*Set <strong class="bold">periph</strong> address*/
    DMA1_Stream5-&gt;PAR = (uint32_t)(&amp;(USART2-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA1_Stream5-&gt;M0AR = (uint32_t)(&amp;uart_data_buffer);
    /*Set number of transfer*/
    DMA1_Stream5-&gt;NDTR = (uint16_t)UART_DATA_BUFF_SIZE;
    /*Select Channel 4*/
    DMA1_Stream5-&gt;CR &amp;= ~(1u&lt;&lt;25);
    DMA1_Stream5-&gt;CR &amp;= ~(1u&lt;&lt;26);
    DMA1_Stream5-&gt;CR |= (1u&lt;&lt;27);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA1_Stream5-&gt;CR |=DMA_SCR_MINC;
    /*Enable transfer complete interrupt*/
    DMA1_Stream5-&gt;CR |= DMA_SCR_TCIE;
    /*Enable Circular mode*/
    DMA1_Stream5-&gt;CR |=DMA_SCR_CIRC;
    /*Set transfer direction : <strong class="bold">Periph</strong> to <strong class="bold">Mem</strong>*/
    DMA1_Stream5-&gt;CR &amp;=~(1U&lt;&lt;6);
    DMA1_Stream5-&gt;CR &amp;=~(1U&lt;&lt;7);
    /*Enable DMA stream*/
    DMA1_Stream5-&gt;CR |= DMA_SCR_EN;
    /*Enable DMA Stream5 Interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA1_Stream5_IRQn</strong>);
}</pre>			<p><a id="_idIndexMarker1227"/>And then, the one for the <code>tx</code> stream</p>
			<pre class="source-code">
<strong class="bold">void dma1_stream6_uart_tx_config</strong>(uint32_t msg_to_snd, uint32_t msg_len)
{
    /*Disable DMA stream*/
    DMA1_Stream6-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till  DMA Stream is disabled*/
    <strong class="bold">while</strong>((DMA1_Stream6-&gt;CR &amp; DMA_SCR_EN)){}
    /*Clear interrupt flags for stream 6*/
    DMA1-&gt;HIFCR = HIFCR_CDMEIF6 |HIFCR_CTEIF6|HIFCR_CTCIF6;
    /*Set <strong class="bold">periph</strong> address*/
    DMA1_Stream6-&gt;PAR = (uint32_t)(&amp;(USART2-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA1_Stream6-&gt;M0AR = msg_to_snd;
    /*Set number of transfer*/
    DMA1_Stream6-&gt;NDTR = msg_len;
    /*Select Channel 4*/
    DMA1_Stream6-&gt;CR &amp;= ~(1u&lt;&lt;25);
    DMA1_Stream6-&gt;CR &amp;= ~(1u&lt;&lt;26);
    DMA1_Stream6-&gt;CR |= (1u&lt;&lt;27);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA1_Stream6-&gt;CR |=DMA_SCR_MINC;
    /*Set transfer direction :<strong class="bold">Mem</strong> to <strong class="bold">Periph</strong>*/
    DMA1_Stream6-&gt;CR |=(1U&lt;&lt;6);
    DMA1_Stream6-&gt;CR &amp;=~(1U&lt;&lt;7);
    /*Set transfer complete interrupt*/
    DMA1_Stream6-&gt;CR |= DMA_SCR_TCIE;
    /*Enable DMA stream*/
    DMA1_Stream6-&gt;CR |= DMA_SCR_EN;
}</pre>			<p><a id="_idIndexMarker1228"/>Next, the function for computing the baudrate value for the UART:</p>
			<pre class="source-code">
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk, uint32_t baudrate)
{
    <strong class="bold">return</strong> ((periph_clk +( baudrate/2U ))/baudrate);
}</pre>			<p>And then, the function for writing the baudrate value to the baudrate register:</p>
			<pre class="source-code">
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk, uint32_t baudrate)
{
    USART2-&gt;BRR  = compute_uart_bd(periph_clk,baudrate);
}</pre>			<p>Next, we have the interrupt handler for <code>Stream6</code>:</p>
			<pre class="source-code">
void DMA1_Stream6_IRQHandler(void)
{
    if((DMA1-&gt;HISR) &amp; HIFSR_TCIF6)
    {
        //do_ssomething
        g_tx_cmplt = 1;
        /*Clear the flag*/
        DMA1-&gt;HIFCR |= HIFCR_CTCIF6;
    }
}</pre>			<p><a id="_idIndexMarker1229"/>And then, the interrupt handler for <code>Stream5</code>:</p>
			<pre class="source-code">
void DMA1_Stream5_IRQHandler(void)
{
    if((DMA1-&gt;HISR) &amp; HIFSR_TCIF5)
    {
        g_rx_cmplt = 1;
        /*Clear the flag*/
        DMA1-&gt;HIFCR |= HIFCR_CTCIF5;
    }
}
void USART2_IRQHandler(void)
{
    g_uart_cmplt  = 1;
    /*Clear TC interrupt flag*/
    USART2-&gt;SR &amp;=~SR_TC;
}</pre>			<p>Let’s go <a id="_idIndexMarker1230"/>through each part of the code step by step.</p>
			<h3>UART initialization</h3>
			<p>In the <code>uart2_rx_tx_init</code> function, we start by configuring the GPIO pins for UART2 communication. We enable the<a id="_idIndexMarker1231"/> clock for GPIOA, ensuring that the <code>PA2</code> and <code>PA3</code> pins can be used. Setting PA2 and PA3 to alternate function mode allows them to serve as <code>UART2_TX</code> and <code>UART2_RX</code>, respectively. We further specify the alternate function type to <code>AF7</code>, which is the type for UART2 operations.</p>
			<p>With the GPIO configuration complete, we proceed to enable the clock for UART2. We set the baud rate using the <code>uart_set_baudrate</code> function. By enabling DMA for both transmission and reception, we offload data handling from the CPU, allowing for more efficient data transfers. We set the transfer direction to both transmit and receive, clear any pending transmission complete flags, and enable the transmission complete interrupt. Finally, we enable the UART module and configure the NVIC to handle UART2 interrupts, ensuring that the system can respond to UART events promptly.</p>
			<h3>DMA initialization</h3>
			<p>Here, we start by enabling <a id="_idIndexMarker1232"/>the clock for <code>DMA1</code>, ensuring that the DMA controller is powered and ready for configuration. Additionally, we enable<a id="_idIndexMarker1233"/> the <strong class="bold">DMA Stream6</strong> interrupt in the NVIC, preparing the system to handle DMA-related interrupts efficiently.</p>
			<h3>DMA configuration for UART reception</h3>
			<p>In <code>dma1_stream5_uart_rx_config</code>, we configure <code>USART2-DR</code>) and the memory address to our <code>uart_data_buffer</code>, where incoming data will be stored.</p>
			<p>We specify the number of data items to transfer and select the appropriate DMA channel. Enabling memory address increment mode ensures that the data buffer is filled sequentially. Circular mode is enabled to allow continuous data reception, and the transfer direction is set <strong class="bold">from peripheral to memory</strong>. We enable the DMA stream and configure<a id="_idIndexMarker1236"/> the NVIC to handle Stream5 interrupts, ensuring that the system is prepared for DMA events.</p>
			<h3>DMA configuration for UART transmission</h3>
			<p>The <code>dma1_stream6_uart_tx_config</code> function configures DMA1 Stream6 to transmit data via UART2. Similar to the reception configuration, we start by disabling the DMA stream and<a id="_idIndexMarker1237"/> clearing any existing interrupt flags. We set the peripheral address to the UART2 data register and the memory address to the data buffer that will be transmitted.</p>
			<p>We specify the number of data items to transfer and select the appropriate DMA channel. Memory address increment mode is enabled to ensure that data is transmitted sequentially from the buffer. We set the transfer direction <strong class="bold">from memory to peripheral</strong> and enable the transfer complete interrupt. Finally, we enable the DMA stream to start the data transmission process.</p>
			<h3>Helper functions</h3>
			<p>The <code>compute_uart_bd</code> function calculates the UART baud rate setting based on the peripheral clock and<a id="_idIndexMarker1238"/> desired baud rate. The <code>uart_set_baudrate</code> function uses<a id="_idIndexMarker1239"/> this computed value to set the baud rate in the UART’s <code>BRR</code> register, ensuring that UART communication occurs at the correct speed.</p>
			<h3>Interrupt handlers</h3>
			<p>Let’s break down the interrupt<a id="_idIndexMarker1240"/> handlers:</p>
			<ul>
				<li><code>DMA1_Stream6_IRQHandler</code>: This handler responds to DMA Stream6 interrupts. When a transfer completes, it sets the <code>g_tx_cmplt</code> flag and clears the interrupt flag, ensuring that the <a id="_idIndexMarker1241"/>system is aware that the transmission is complete.</li>
				<li><code>DMA1_Stream5_IRQHandler</code>: This handler responds to DMA Stream5 interrupts. When a transfer completes, it sets the <code>g_rx_cmplt</code> flag and clears the interrupt flag, indicating that new data has been received.</li>
				<li><code>USART2_IRQHandler</code>: This handler manages UART2 interrupts. It sets the <code>g_uart_cmplt</code> flag when a UART event occurs and clears the transmission complete flag, maintaining the<a id="_idIndexMarker1242"/> proper flow of UART communication.</li>
			</ul>
			<p>Next, we populate the <code>uart_dma.h</code> file. Here is the code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> UART_DMA_H__
<strong class="bold">#define</strong> UART_DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong> UART_DATA_BUFF_SIZE        5
<strong class="bold">void uart2_rx_tx_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_stream5_uart_rx_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_stream6_uart_tx_config</strong>(uint32_t msg_to_snd, uint32_t msg_len);
<code>main.c</code> file:</p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "uart.h"
#include "uart_dma.h"
extern uint8_t g_rx_cmplt;
extern uint8_t g_uart_cmplt;
extern uint8_t g_tx_cmplt;
extern char uart_data_buffer[UART_DATA_BUFF_SIZE];
char msg_buff[150] ={'\0'};
int main(void)
{
    uart2_rx_tx_init();
    dma1_init();
    dma1_stream5_uart_rx_config();
    sprintf(msg_buff,"Initialization...<strong class="bold">cmplt</strong>\n\r");
    dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_buff));
    while(!g_tx_cmplt){}
    while(1)
    {
        if(g_rx_cmplt)
        {
            sprintf(msg_buff, "Message received : %s \r\n",uart_data_
            buffer);
            g_rx_cmplt = 0;
            g_tx_cmplt = 0;
            g_uart_cmplt = 0;
            dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_
            buff));
            while(!g_tx_cmplt){}
        }
    }
}</pre>			<p>In the <code>main</code> function, we start by initializing the UART and DMA, and then we configure DMA1 Stream5 for UART reception and DMA1 Stream6 for UART transmission. We prepare a message that<a id="_idIndexMarker1244"/> indicates initialization completion and initiate its transmission via DMA. The main loop continuously checks <a id="_idIndexMarker1245"/>whether a UART message has been received. When a message is received, it formats the received data into a response message, r<a id="_idTextAnchor486"/>esets the completion flags, and transmits the response using DMA.</p>
			<h3>Testing the project</h3>
			<p>To test the project, compile the code and upload it to your microcontroller. Open RealTerm or any other <a id="_idIndexMarker1246"/>serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. Ensure the output area of RealTerm is active by clicking on it. Then, type any five keys on your keyboard. You should see these keys appear in the output area of RealTerm. The microcontroller receives the typed keys through the <code>dma1_stream5_uart_rx_config</code> function, stores them in the <code>msg_buff</code>, and transmits them to your host computer’s serial port via the <code>dma1_stream6_uart_tx_config</code> function. The last received data remains in <code>msg_buff</code> for further processing if needed. We type five characters because the <code>UART_DATA_BUFF_SIZE</code> is set to <code>5</code> in the <code>uart_dma.h</code> file.</p>
			<p>In the next section, we will develop our final DMA driver – the DMA memory-to-memory driver.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor487"/>Developing the DMA memory-to-memory driver</h1>
			<p>Create a copy of your<a id="_idIndexMarker1247"/> previous project in your IDE and rename it <code>DMA_MemToMem</code>. Next, create a new file named <code>dma.c</code> in the <code>Src</code> folder and another file named <code>dma.h</code> in the <code>Inc</code> folder. Update your <code>dma.c</code> file, as shown here:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "dma.h"
<strong class="bold">#define</strong> DMA2EN                (1U&lt;&lt;22)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
<strong class="bold">void dma2_mem2mem_config</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to the <strong class="bold">dma</strong> module*/
    RCC-&gt;AHB1ENR |= DMA2EN;
    /*Disable <strong class="bold">dma</strong> stream*/
    DMA2_Stream0-&gt;CR = 0;
    /*Wait until stream is disabled*/
    <strong class="bold">while</strong>((DMA2_Stream0-&gt;CR &amp; DMA_SCR_EN)){}
    /*Configure <strong class="bold">dma</strong> parameters*/
    /*Set MSIZE i.e Memory data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;13);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;14);
    /*Set PSIZE i.e Peripheral data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;11);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;12);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_MINC;
    /*Enable peripheral <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_PINC;
    /*Select mem-to-mem transfer*/
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;6);
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;7);
    /*Enable transfer complete interrupt*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_TCIE;
    /*Enable transfer error interrupt*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_TEIE;
    /*Disable direct mode*/
    DMA2_Stream0-&gt;FCR |=DMA_SFCR_DMDIS;
    /*Set DMA FIFO threshold*/
    DMA2_Stream0-&gt;FCR |=(1U&lt;&lt;0);
    DMA2_Stream0-&gt;FCR |=(1U&lt;&lt;1);
    /*Enable DMA interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA2_Stream0_IRQn</strong>);
}</pre>			<p>This function sets up the <code>DMA2</code> controller for memory-to-memory data transfers. It begins by enabling the clock for the DMA2 module and ensures that the DMA stream is disabled before making any configuration changes. The function configures the data size for both memory and peripheral to <code>half-word</code> (16-bit) and enables automatic incrementing of the memory and peripheral addresses. It sets the transfer direction to <code>memory-to-memory</code> and<a id="_idIndexMarker1248"/> enables interrupts for transfer completion and transfer errors, ensuring robust error handling and efficient operation. Direct mode is disabled to use <code>FIFO mode</code>, and the FIFO threshold is set to <code>full</code>. Finally, the function enables the DMA stream and configures the NVIC to handle DMA interrupts, ensuring that the system can respond to DMA eve<a id="_idTextAnchor488"/>nts appropriately. We also have the <code>dma_transfer_start</code> function:</p>
			<pre class="source-code">
<strong class="bold">void dma_transfer_start</strong>(uint32_t src_buff, uint32_t dest_buff, uint32_t len)
{
    /*Set peripheral address*/
    DMA2_Stream0-&gt;PAR = src_buff;
    /*Set memory address*/
    DMA2_Stream0-&gt;M0AR = dest_buff;
    /*Set transfer length*/
    DMA2_Stream0-&gt;NDTR = len;
    /*Enable <strong class="bold">dma</strong> stream*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_EN;
}</pre>			<p>This function initiates the DMA transfer by configuring the source and destination addresses and the length of the data transfer. It begins by setting the peripheral address of the value passed in <code>src_buff</code> and the memory address of the value passed in <code>dest_buff</code>. The transfer length is<a id="_idIndexMarker1249"/> then specified by setting the <code>NDTR</code> register to <code>len</code>, indicating the number of data items to transfer. Finally, the function enables the DMA stream by setting the <code>EN</code> bit in the <code>CR</code> register, thereby starting the data transfer from the source to the destination. This is the <code>dma.h</code> file:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> DMA_H__
<strong class="bold">#define</strong> DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong> LISR_TCIF0        (1U&lt;&lt;5)
<strong class="bold">#define</strong> LIFCR_CTCIF0        (1U&lt;&lt;5)
<strong class="bold">#define</strong> LISR_TEIF0        (1U&lt;&lt;3)
<strong class="bold">#define</strong> LIFCR_CTEIF0        (1U&lt;&lt;3)
<strong class="bold">void dma2_mem2mem_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma_transfer_start</strong>(uint32_t src_buff, uint32_t dest_buff, uint32_t len);
<code>main.c</code> file:</p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "uart.h"
#include "dma.h"
#include "uart.h"
#define BUFFER_SIZE        5
uint16_t sensor_data_arr[BUFFER_SIZE] = {892,731,1234,90,23};
uint16_t temp_data_arr[BUFFER_SIZE];
volatile uint8_t g_transfer_cmplt;
int main(void)
{
    g_transfer_cmplt = 0;
    uart_init();
    dma2_mem2mem_config();
    dma_transfer_start((uint32_t)sensor_data_arr,(uint32_t) temp_data_
    arr, BUFFER_SIZE);
    /*Wait until transfer complete*/
    while(!g_transfer_cmplt){}
    for( int i = 0; i &lt; BUFFER_SIZE; i++)
    {
        printf("Temp buffer[%d]: %d\r\n",i,temp_data_arr[i]);
    }
    g_transfer_cmplt = 0;
    while(1)
    {
    }
}</pre>			<p>The <code>main</code> function sets up and initiates a memory-to-memory DMA transfer, transferring data from the globally declared and initialized <code>sensor_data_arr</code> to the uninitialized <code>temp_data_arr</code>. It starts by initializing the transfer complete flag, <code>g_transfer_cmplt</code>, to <code>0</code>, ensuring that we can monitor the transfer status. The function then initializes UART for debugging purposes and configures the DMA using <code>dma2_mem2mem_config</code>. The DMA<a id="_idIndexMarker1251"/> transfer is started by calling <code>dma_transfer_start</code>, specifying the source (<code>sensor_data_arr</code>), destination (<code>temp_data_arr</code>), and the length of the transfer (<code>BUFFER_SIZE</code>). The function then enters a loop, waiting until the transfer is complete, indicated by<code> g_transfer_cmplt</code> being set to <code>1</code>. Once the transfer is complete, it prints the contents of the <code>temp_data_arr</code> to the console, confirming that the data has been successfully transferred.</p>
			<p>Our <code>main.c</code> file also contains the DMA stream’s IRQHandler:</p>
			<pre class="source-code">
void DMA2_Stream0_IRQHandler(void)
{
    /*Check if transfer complete interrupt occurred*/
    if((DMA2-&gt;LISR) &amp; LISR_TCIF0)
    {
        g_transfer_cmplt = 1;
        /*Clear flag*/
        DMA2-&gt;LIFCR |=LIFCR_CTCIF0;
    }
    /*Check if transfer error occurred*/
    if((DMA2-&gt;LISR) &amp; LISR_TEIF0)
    {
        /*Do something...*/
        /*Clear flag*/
        DMA2-&gt;LIFCR |= LIFCR_CTEIF0;
    }
}</pre>			<p>The handler manages both transfer completion and error events. The function first checks whether the transfer complete interrupt flag (<code>TCIF0</code>) is set in the low interrupt status register (<code>LISR</code>). If this flag is set, it indicates that the DMA transfer has successfully finished. The function then sets the <code>g_transfer_cmplt</code> flag to <code>1</code> to signal to the main function that the transfer is complete, and it clears the interrupt flag by writing to the low<a id="_idIndexMarker1252"/> interrupt flag clear register (<code>LIFCR</code>). Additionally, the function checks for a transfer error interrupt (<code>TEIF0</code>). If a transfer error is detected, it performs any necessary error handling and clears the error flag in <code>LIFCR</code>. This interrupt handler ensures smooth operation by promptly handling the completion of data transfers and addressing any errors that might occur during the process.</p>
			<p>Now, it’s time to test the project. To test the project, compile the code and upload it to your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the sensor values printed, indicating that the values have been successfully copied from <code>sensor_data_arr</code> to <code>temp_data_arr</code>, as our code only prints the contents of <code>temp_data_arr</code>.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor489"/>Summary</h1>
			<p>In this chapter, we learned about DMA, an important feature in microcontrollers for enhancing data throughput and offloading the CPU from routine data transfer tasks. We began by discussing the basic principles of DMA, emphasizing its role in high-performance embedded systems. We explored how DMA works and its significance in improving system efficiency, by allowing peripherals to transfer data directly to and from memory without continuous CPU intervention.</p>
			<p>Then, we focused on the STM32F4 implementation of the DMA controller, examining its key features and configuration options. We detailed the structure of the DMA controller, including its channels, streams, and key registers, such as the Stream Configuration Register (<code>DMA_SxCR</code>), Stream Number of Data Register (<code>DMA_SxNDTR</code>), Stream Peripheral Address Register (<code>DMA_SxPAR</code>), and Stream Memory Address Registers (<code>DMA_SxM0AR</code> and <code>DMA_SxM1AR</code>). This provided a comprehensive understanding of how to configure and control DMA for various data transfer operations.</p>
			<p>We provided practical <a id="_idIndexMarker1253"/>examples to solidify our understanding, including the development of DMA drivers for different use cases, such as ADC data transfers, UART communications, and memory-to-memory transfers. These examples involved initializing DMA, setting up the necessary parameters, and implementing functions to handle data transfers efficiently.</p>
			<p>In the next chapter, we will learn about power management energy efficiency techniques in embedded systems.</p>
		</div>
	</div>
</div>
</body></html>