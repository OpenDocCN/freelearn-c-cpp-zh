<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer133">
			<h1 id="_idParaDest-285" class="chapter-number"><a id="_idTextAnchor467"/>17</h1>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor468"/>Direct Memory Access (DMA)</h1>
			<p>In this chapter, we will explore <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>), a powerful feature in microcontrollers that allows peripherals to transfer data to and from memory without involving the CPU. This functionality is critical for improving data throughput and freeing up the CPU to handle other tasks, making it fundamental to high-performance embedded <span class="No-Break">system development.</span></p>
			<p>We will begin by understanding the basic principles of DMA and its significance in embedded systems. We will then delve into the specifics of the DMA controller in STM32F4 microcontrollers, examining its structure and features and how it manages data transfers. Following this, we will apply this theoretical knowledge to develop practical DMA drivers for various use cases, including memory-to-memory transfers, <strong class="bold">Analog-to-Digital Converter</strong> (<strong class="bold">ADC</strong>) data transfers, and <strong class="bold">Universal Asynchronous Receiver-Transmitter</strong> (<span class="No-Break"><strong class="bold">UART</strong></span><span class="No-Break">) communications.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>An overview <span class="No-Break">of DMA</span></li>
				<li>The <span class="No-Break">STM32F4 DMA</span></li>
				<li>Developing the DMA <span class="No-Break">ADC driver</span></li>
				<li>Developing the DMA <span class="No-Break">UART driver</span></li>
				<li>Developing the DMA <span class="No-Break">memory-to-memory driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of how DMA works and how to implement it in your projects. You will be able to develop efficient DMA drivers to handle data transfers in various scenarios, significantly enhancing the performance and responsiveness of your <span class="No-Break">embedded systems.</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor469"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor470"/>Understanding Direct Memory Access (DMA)</h1>
			<p>DMA is a feature that can<a id="_idIndexMarker1176"/> significantly elevate the performance of your embedded systems. If you’ve been dealing with data transfers in your microcontroller projects, you know how taxing it can be on the CPU to handle all that data movement. This is where DMA steps in as a game-changer, offloading the data transfer tasks from the CPU and allowing it to focus on more critical functions. Let’s see how <span class="No-Break">it works.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor471"/>How DMA works</h2>
			<p>So, what exactly is DMA, and how does it work? In simple terms, DMA is a method that allows peripherals within a microcontroller to<a id="_idIndexMarker1177"/> transfer data directly to and from memory, without requiring continuous CPU intervention. Imagine it as a dedicated assistant that takes over the tedious task of moving boxes (data) so that you (the CPU) can focus on more important work, such as solving complex problems or managing <span class="No-Break">other peripherals.</span></p>
			<p>A typical DMA controller in a microcontroller has multiple channels, each capable of handling a specific data transfer operation. Each channel can be configured independently to manage transfers between various peripherals <span class="No-Break">and memory.</span></p>
			<p>Here’s a step-by-step look at how DMA <span class="No-Break">generally operates:</span></p>
			<ol>
				<li><strong class="bold">Initialization</strong>: The DMA controller and channels are configured. This setup includes specifying the source and destination addresses, the direction of data transfer, and the number of data units <span class="No-Break">to transfer.</span></li>
				<li><strong class="bold">Trigger</strong>: The data transfer is initiated by a trigger, which can be an event such as a peripheral signaling that it’s ready to send or receive data, or a <span class="No-Break">software command.</span></li>
				<li><strong class="bold">Data transfer</strong>: Once triggered, the DMA controller takes over, reading data from the source address and writing it to the destination address. This process continues until the specified number of data units <span class="No-Break">is transferred.</span></li>
				<li><strong class="bold">Completion</strong>: Upon completing the transfer, the DMA controller can generate an interrupt to notify the CPU <a id="_idIndexMarker1178"/>that the transfer is done, allowing the system to perform any necessary <span class="No-Break">post-transfer processing.</span></li>
			</ol>
			<p>Next, let’s take a look at some key features of <span class="No-Break">DMA controllers.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor472"/>Key features</h2>
			<p>DMA controllers are packed with features that <a id="_idIndexMarker1179"/>make them versatile and powerful. Let’s break down some of the key specifications you’ll <span class="No-Break">often encounter:</span></p>
			<ul>
				<li><strong class="bold">Channels and streams</strong>: DMA controllers typically have multiple channels and streams, each capable of handling a different transfer. For instance, the STM32F4 microcontroller has up to 16 streams in its <span class="No-Break">DMA controllers.</span></li>
				<li><strong class="bold">Priorities</strong>: Channels can be assigned different priority levels, ensuring that more critical transfers get precedence over less <span class="No-Break">critical ones.</span></li>
				<li><strong class="bold">Transfer Types</strong>: DMA can handle various types of transfers, including memory-to-memory, peripheral-to-memory, <span class="No-Break">and memory-to-peripheral.</span></li>
				<li><strong class="bold">FIFO</strong>: Some DMA controllers <a id="_idIndexMarker1180"/>come with a <strong class="bold">First-In-First-Out</strong> (<strong class="bold">FIFO</strong>) buffer, which helps manage data flow and improve efficiency, especially in <span class="No-Break">burst transfers.</span></li>
				<li><strong class="bold">Circular mode</strong>: This mode allows the DMA to continuously transfer data in a loop, which is particularly useful for peripherals that need constant data streaming, such as audio or <span class="No-Break">video feeds.</span></li>
				<li><strong class="bold">Interrupts</strong>: DMA controllers can generate interrupts on transfer completion, half-transfer completion, and transfer errors, allowing the CPU to react appropriately to different stages of <span class="No-Break">the transfer.</span></li>
			</ul>
			<p>To understand the real power of DMA, let’s look at some common use cases where <span class="No-Break">DMA shines.</span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor473"/>Common use cases</h2>
			<p>Here are some common use <a id="_idIndexMarker1181"/>cases <span class="No-Break">of DMA:</span></p>
			<ul>
				<li><strong class="bold">Audio streaming</strong>: DMA is heavily used in audio applications where continuous data streaming is essential. For instance, in a digital audio player, the audio samples must be <a id="_idIndexMarker1182"/>continuously sent to a <strong class="bold">Digital-to-Analog Converter</strong> (<strong class="bold">DAC</strong>). Using DMA, the audio data can be streamed from memory to the DAC without CPU intervention, ensuring smooth playback and freeing up the CPU to manage the user interface and <span class="No-Break">other tasks.</span></li>
				<li><strong class="bold">Sensor data acquisition</strong>: In applications such as environmental monitoring or industrial automation, sensors often need to sample data at precise intervals. For example, an ADC can be configured to continuously sample temperature data, with DMA transferring the sampled data directly to memory. This setup ensures that the CPU isn’t bogged down with handling each individual sample, thus maintaining efficient and timely <span class="No-Break">data collection.</span></li>
				<li><strong class="bold">Communication interfaces</strong>: DMA is a lifesaver when dealing with high-speed communication protocols such as UART, SPI, or I2C. Consider a scenario where an embedded system needs to log data received over UART to an SD card. Without DMA, the CPU would need to handle each byte of data, process it, and then write it to the SD card, which can be highly inefficient. With DMA, the data received over UART can be directly written to memory, and another DMA channel can transfer it to the SD card, all with minimal <span class="No-Break">CPU intervention.</span></li>
				<li><strong class="bold">Graphics processing</strong>: DMA is also crucial in applications involving graphics, such as updating a display buffer. In a system where the display needs to be refreshed continuously, the DMA can handle the transfer of image data from memory to the display controller. This ensures smooth and flicker-free graphics rendering, while the CPU can focus on generating the next frame or managing <span class="No-Break">user inputs.</span></li>
			</ul>
			<p>With this in mind, let’s compare some DMA solutions to <span class="No-Break">non-DMA solutions.</span></p>
			<h3>Case study 1 – audio streaming</h3>
			<p><strong class="bold">Scenario</strong>: You are developing an <a id="_idIndexMarker1183"/>audio playback system that streams digital audio data from a microcontroller to <span class="No-Break">a DAC.</span></p>
			<p><strong class="bold">Without DMA</strong>: The CPU is responsible for fetching each audio sample from memory and sending it to the DAC. Given the high sampling rate required for audio applications (e.g., 44.1 kHz for CD-quality audio), the CPU must handle tens of thousands of interrupts per second just to maintain the audio stream. This constant load significantly limits the CPU’s ability to perform other tasks, potentially leading to audio glitches and reduced <span class="No-Break">system responsiveness.</span></p>
			<p><strong class="bold">With DMA</strong>: The DMA controller is configured to transfer audio data directly from memory to the DAC. The CPU sets up the DMA transfer and then handles higher-level tasks, only occasionally checking the status of the transfer. This setup ensures smooth and uninterrupted audio playback while freeing up the CPU to manage other aspects of the system, such as user interface and <span class="No-Break">control logic.</span></p>
			<h3>Case study 2 – high-speed data acquisition</h3>
			<p><strong class="bold">Scenario</strong>: You are developing a data<a id="_idIndexMarker1184"/> acquisition system that continuously samples data from multiple sensors via ADCs and stores the data for <span class="No-Break">later analysis.</span></p>
			<p><strong class="bold">Without DMA</strong>: The CPU must handle each ADC conversion, read the data, and store it in memory. If the sampling rate is high, the CPU can become overwhelmed, leading to missed samples and unreliable data collection. This approach can also complicate real-time data processing and analysis, as the CPU is bogged down with managing the <span class="No-Break">data flow.</span></p>
			<p><strong class="bold">With DMA</strong>: The ADC is configured to generate DMA requests. Each time a conversion is complete, the DMA controller transfers the data from the ADC to memory without CPU intervention. The CPU can then process the collected data in batches, ensuring that no samples are missed and enabling real-time data analysis <span class="No-Break">and decision-making.</span></p>
			<h3>Case study 3 – an LCD display refresh</h3>
			<p><strong class="bold">Scenario</strong>: You are developing a<a id="_idIndexMarker1185"/> graphical application that continuously updates an LCD display with <span class="No-Break">new data.</span></p>
			<p><strong class="bold">Without DMA</strong>: The CPU must update the display by sending each pixel or line of data directly to the LCD controller. This process can be very CPU-intensive, especially for high-resolution displays, leading to sluggish performance and reduced responsiveness in the <span class="No-Break">user interface.</span></p>
			<p><strong class="bold">With DMA</strong>: The DMA controller is configured to transfer display data from memory to the LCD controller. The CPU sets <a id="_idIndexMarker1186"/>up the DMA transfer and then focuses on generating new graphical data or handling user inputs. The DMA controller ensures that the display is updated smoothly <span class="No-Break">and efficiently.</span></p>
			<p>In each of the case studies, we’ve seen how using DMA can transform a system’s capabilities, freeing up the CPU to handle more critical tasks and ensuring that data transfers are handled efficiently and reliably. Understanding and implementing DMA in your projects can lead to more robust, responsive, and high-performance <span class="No-Break">embedded systems.</span></p>
			<p>In the following section, we will delve deeper into the specifics of the STM32F4 DMA controller, exploring its architecture, key registers, and practical <span class="No-Break">implementation techniques.</span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor474"/>The DMA modules of the STM32F4 microcontroller</h1>
			<p>Each STM32F4 microcontroller<a id="_idIndexMarker1187"/> is equipped with <strong class="bold">two DMA</strong> controllers, each supporting up to <strong class="bold">8 streams</strong>. Each stream can manage <a id="_idIndexMarker1188"/>multiple requests, providing up to <strong class="bold">16 streams</strong> in total to handle various data transfer tasks. A <strong class="bold">stream</strong> is a unidirectional pathway that facilitates data transfer between a source and a destination. The<a id="_idIndexMarker1189"/> architecture includes an <strong class="bold">arbiter</strong> to prioritize these DMA requests, ensuring that high-priority transfers are <span class="No-Break">handled promptly.</span></p>
			<p>Let’s see some key features of the STM32F4 <span class="No-Break">DMA controller.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor475"/>The key features of the STM32F4 DMA controller</h2>
			<p>The following are the key features <a id="_idIndexMarker1190"/>of the STM32F4 <span class="No-Break">DMA controller:</span></p>
			<ul>
				<li><strong class="bold">Independent FIFO</strong>: Each stream includes a <strong class="bold">four-word FIFO buffer</strong>, which can operate in either direct mode or FIFO mode. In direct mode, data transfers occur immediately upon request, while FIFO mode allows for <strong class="bold">threshold-level buffering</strong>, enhancing efficiency for<a id="_idIndexMarker1191"/> burst <span class="No-Break">data transfers.</span></li>
				<li><strong class="bold">Flexible configuration</strong>: Each stream can be configured to handle <span class="No-Break">the following:</span><ul><li><span class="No-Break">Peripheral-to-memory</span></li><li><span class="No-Break">Memory-to-peripheral</span></li><li><span class="No-Break">Memory-to-memory transfers</span></li></ul></li>
			</ul>
			<p>Additionally, streams can be set up for regular or double-buffer transfers, the latter enabling seamless data handling by swapping memory <span class="No-Break">buffers automatically:</span></p>
			<ul>
				<li><strong class="bold">Prioritization and arbitration</strong>: DMA stream requests are prioritized via software with four levels – <strong class="bold">very high</strong>, <strong class="bold">high</strong>, <strong class="bold">medium</strong>, and <strong class="bold">low</strong>. If two streams have the same priority, hardware prioritization based on the stream number ensures orderly <span class="No-Break">data transfer.</span></li>
				<li><strong class="bold">Incremental and burst transfers</strong>: The DMA controller supports both incremental and non-incremental addressing for source and destination. It can manage burst transfers of <strong class="bold">4, 8, or 16 beats</strong>, optimizing bandwidth usage. The term <strong class="bold">beat</strong> refers to the individual units of data that are transferred in a single <span class="No-Break">DMA transaction.</span></li>
				<li><strong class="bold">Interrupts and error handling</strong>: Each stream supports multiple event flags such as transfer complete, half-transfer, transfer error, FIFO error, and direct mode error. These<a id="_idIndexMarker1192"/> flags can trigger interrupts, providing robust error handling and <span class="No-Break">status monitoring.</span></li>
			</ul>
			<p>To fully utilize the STM32F DMA controller, it’s important to understand DMA transactions and channel selection. Let’s break these <span class="No-Break">concepts down.</span></p>
			<ul>
				<li><strong class="bold">DMA transactions</strong>: A typical DMA<a id="_idIndexMarker1193"/> transaction involves <span class="No-Break">the following:</span><ul><li>Loading data from the source address (either a peripheral <span class="No-Break">or memory)</span></li><li>Storing data to the <span class="No-Break">destination address</span></li><li>Decrementing the <strong class="source-inline">DMA_SxNDTR</strong> register to track the number of remaining <span class="No-Break">data items</span></li></ul></li>
				<li><strong class="bold">Channel selection</strong>: Each stream can<a id="_idIndexMarker1194"/> be associated with up to eight different channels, selectable via the <strong class="source-inline">CHSEL</strong> bits in the <strong class="source-inline">DMA_SxCR</strong> register. This flexibility allows various peripherals to initiate DMA <span class="No-Break">requests efficiently.</span></li>
			</ul>
			<p>Previously, we discussed that the STM32F4 DMA controller supports three distinct transfer modes. Now, let’s explore the characteristics of <span class="No-Break">each mode.</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor476"/>Transfer modes</h2>
			<p>There are three <span class="No-Break">transfer modes:</span></p>
			<ul>
				<li><strong class="bold">Peripheral-to-memory mode</strong>: This mode is activated by setting the <strong class="source-inline">EN</strong> bit in the <strong class="source-inline">DMA_SxCR</strong> register. The stream<a id="_idIndexMarker1195"/> transfers data from the<a id="_idIndexMarker1196"/> peripheral to memory, using the FIFO buffer <span class="No-Break">if enabled.</span></li>
				<li><strong class="bold">Memory-to-peripheral mode</strong>: This is similar to peripheral-to-memory, but the transfer direction is reversed. Data is<a id="_idIndexMarker1197"/> loaded from memory and sent to <span class="No-Break">the peripheral.</span></li>
				<li><strong class="bold">Memory-to-memory mode</strong>: This mode is unique, as it does not require peripheral requests. The DMA<a id="_idIndexMarker1198"/> stream transfers data between two memory locations, using the FIFO buffer if enabled. This is particularly useful for large data transfers <span class="No-Break">within memory.</span></li>
			</ul>
			<p>The DMA controller can automatically increment source and destination pointers, facilitating efficient data transfers across different memory regions. This is configurable via the <strong class="source-inline">PINC</strong> and <strong class="source-inline">MINC</strong> bits in the <span class="No-Break"><strong class="source-inline">DMA_SxCR</strong></span><span class="No-Break"> register.</span></p>
			<p>The STM32F4 DMA controller also provides data <span class="No-Break">mode options.</span></p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor477"/>DMA data modes</h2>
			<p>This data mode options include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Circular mode</strong>: Circular mode<a id="_idIndexMarker1199"/> allows the DMA to handle continuous data flows by automatically reloading the initial values in the <strong class="source-inline">DMA_SxNDTR</strong> register. This is especially useful for applications such as ADC sampling, where data needs to be <span class="No-Break">continuously recorded.</span></li>
				<li><strong class="bold">Double buffer mode</strong>: Double buffer mode enhances efficiency by allowing the DMA controller to swap <a id="_idIndexMarker1200"/>between two memory buffers automatically. This ensures continuous data processing. While the CPU works on one buffer, the DMA can load the next set of data into the <span class="No-Break">other buffer.</span></li>
			</ul>
			<p>In the next section, we will <a id="_idIndexMarker1201"/>examine the STM32F4 DMA block diagram from the reference manual. This will help us better understand the key characteristics and functionalities of the <span class="No-Break">DMA controller.</span></p>
			<h2 id="_idParaDest-296">The <a id="_idTextAnchor478"/>STM32F4 DMA block diagram</h2>
			<p>The DMA has <strong class="bold">two ports</strong> for data transfer – one<a id="_idIndexMarker1202"/> peripheral port and one memory port, as shown in <span class="No-Break"><em class="italic">Figure 17</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B21914_17_1.jpg" alt="Figure 17.1: The DMA module, indicating the data transfer ports" width="1650" height="1209"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1: The DMA module, indicating the data transfer ports</p>
			<p>Each of the two DMA modules features <strong class="bold">eight distinct streams</strong>, with each stream dedicated to handling memory access requests from <span class="No-Break">various peripherals.</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B21914_17_2.jpg" alt="Figure 17.2: The DMA module, indicating the streams" width="1650" height="1302"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2: The DMA module, indicating the streams</p>
			<p>Each stream can accommodate up to <strong class="bold">eight selectable channels</strong>, which are software-configurable to enable <a id="_idIndexMarker1203"/>multiple peripherals to initiate DMA requests. However, within any given stream, only one channel can be active at <span class="No-Break">a time.</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B21914_17_3.jpg" alt="Figure 17.3: The DMA module, with channels zoomed in" width="1641" height="1012"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3: The DMA module, with channels zoomed in</p>
			<p>To find the mappings of DMA channels and streams to the various peripherals of the microcontroller, refer to <em class="italic">page 170</em> of the reference <span class="No-Break">manual (</span><span class="No-Break"><strong class="bold">RM0383</strong></span><span class="No-Break">).</span></p>
			<p>Before we start developing our DMA drivers, the final piece of the puzzle involves familiarizing ourselves <a id="_idIndexMarker1204"/>with the key <span class="No-Break">DMA registers.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor479"/>The key STM32 DMA registers</h2>
			<p>In this section, we will <a id="_idIndexMarker1205"/>explore the characteristics and functions of some of the crucial registers within the DMA peripheral, starting with the<a id="_idIndexMarker1206"/> DMA Str<a id="_idTextAnchor480"/>eam <span class="No-Break">Configuration Register.</span></p>
			<h3>The DMA Stream Configuration Register (DMA_SxCR)</h3>
			<p>The DMA Stream Configuration Register (<strong class="source-inline">DMA_SxCR</strong>) is one of the primary registers used to configure a <a id="_idIndexMarker1207"/>DMA stream’s operational settings. This register allows us to set up various parameters, such as the <strong class="bold">data direction</strong>, the <strong class="bold">size</strong> of the data items, and the <strong class="bold">priority</strong> level of the stream. The<a id="_idIndexMarker1208"/> key bits in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">EN</strong>: Stream enable. Setting this bit activates <span class="No-Break">the stream.</span></li>
				<li><strong class="bold">CHSEL[2:0]</strong>: Channel selection. These bits select the DMA channel for <span class="No-Break">the stream.</span></li>
				<li><strong class="bold">DIR[1:0]</strong>: Data transfer direction. These bits specify the direction of the data transfer (peripheral-to-memory, memory-to-peripheral, <span class="No-Break">or memory-to-memory).</span></li>
				<li><strong class="bold">CIRC</strong>: Circular mode. Setting this bit enables circular mode, which allows continuous <span class="No-Break">data transfers.</span></li>
				<li><strong class="bold">PINC</strong>: Peripheral increment mode. When set, this bit increments the peripheral address after each <span class="No-Break">data transfer.</span></li>
				<li><strong class="bold">MINC</strong>: Memory increment mode. When set, this bit increments the memory address after each <span class="No-Break">data transfer.</span></li>
				<li><strong class="bold">PSIZE[1:0]</strong>: Peripheral data size. These bits specify the size of the data items read from or written to the peripheral (8-bit, 16-bit, <span class="No-Break">or 32-bit).</span></li>
				<li><strong class="bold">MSIZE[1:0]</strong>: Memory data<a id="_idIndexMarker1209"/> size. These bits specify the size of the data items read from or written <span class="No-Break">to memory.</span></li>
				<li><strong class="bold">PL[1:0]</strong>: Priority level. These bits set the priority level of the stream (low, medium, high, or <span class="No-Break">very high).</span></li>
			</ul>
			<p>You can find detailed information <a id="_idIndexMarker1210"/>about this register on <em class="italic">page 190</em> of the STM32F411 reference manual (RM0383). Next, we have the DMA Stream Number of Data <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">DMA_SxNDTR</strong></span><span class="No-Break">).</span></p>
			<h3>DMA Stream Number of Data Register (DMA_SxNDTR)</h3>
			<p>The DMA Stream <a id="_idIndexMarker1211"/>Number of Data Register (<strong class="source-inline">DMA_SxNDTR</strong>) specifies the number of data items to be transferred by<a id="_idIndexMarker1212"/> the DMA<a id="_idIndexMarker1213"/> stream. This register is crucial for controlling the length of the <span class="No-Break">data transfer.</span></p>
			<p>The only field in this register is <strong class="bold">NDT[15:0]</strong>. This stands for the number of data items. This field specifies the total number of data items to be transferred. The value in this register is decremented after each transfer until it <span class="No-Break">reaches zero.</span></p>
			<p>Further information about this register can be found on <em class="italic">page 193</em> of the reference manual. Let’s move on to the DMA Stream Peripheral Address <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">DMA_SxPAR</strong></span><span class="No-Break">).</span></p>
			<h3>DMA Stream Peripheral Address Register (DMA_SxPAR)</h3>
			<p>The DMA Stream Peripheral <a id="_idIndexMarker1214"/>Address Register (<strong class="source-inline">DMA_SxPAR</strong>) holds<a id="_idIndexMarker1215"/> the address of the peripheral data register that the data will be read to or <span class="No-Break">written from.</span></p>
			<p>The only field in this register is <strong class="bold">PA[31:0]</strong>. This stands for <strong class="bold">peripheral address</strong>. This field contains the address<a id="_idIndexMarker1216"/> of the peripheral data register involved in the <span class="No-Break">data transfer.</span></p>
			<p>More details about this register can be found on <em class="italic">page 194</em> of the reference manual. Finally, we have the DMA<a id="_idIndexMarker1217"/> Stream Memory Address Registers (<strong class="source-inline">DMA_SxM0AR</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DMA_SxM1AR</strong></span><span class="No-Break">).</span></p>
			<h3>DMA Stream Memory Address Registers (DMA_SxM0AR and DMA_SxM1AR)</h3>
			<p>These registers store the addresses of the memory locations used for data transfers. The <strong class="source-inline">DMA_SxM0AR</strong> register is used<a id="_idIndexMarker1218"/> for single buffer mode, while both <strong class="source-inline">DMA_SxM0AR</strong> and <strong class="source-inline">DMA_SxM1AR</strong> are used in double <span class="No-Break">buffer mode.</span></p>
			<p>The only field in these<a id="_idIndexMarker1219"/> registers is <strong class="bold">MA[31:0]</strong>. This stands for <strong class="bold">memory address</strong>. This field contains the <a id="_idIndexMarker1220"/>address of the memory location involved in the data transfer. For detailed information, refer to <em class="italic">pages 194</em> of the <span class="No-Break">reference manual.</span></p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor481"/>Developing the ADC DMA driver</h1>
			<p>In this section, we will develop three distinct DMA drivers – one for transferring ADC data, another for UART data, and a third for transferring data between memory locations. Let’s begin with the<a id="_idIndexMarker1221"/> ADC <span class="No-Break">DMA driver.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor482"/>The ADC DMA driver</h2>
			<p>Create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project <strong class="source-inline">ADC_DMA</strong>. Next, create a new file named <strong class="source-inline">adc_dma.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">adc_dma.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<p>Populate your <strong class="source-inline">adc_dma.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adc_dma.h"
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> ADC1EN            (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR1_SCAN        (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR2_DMA            (1U&lt;&lt;8)
<strong class="bold">#define</strong> CR2_DDS            (1U&lt;&lt;9)
<strong class="bold">#define</strong> CR2_CONT        (1U&lt;&lt;1)
<strong class="bold">#define</strong> CR2_ADCON        (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR2_SWSTART        (1U&lt;&lt;30)
<strong class="bold">#define</strong> DMA2EN                (1U&lt;&lt;22)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_CIRC        (1U&lt;&lt;8)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
uint16_t adc_raw_data[NUM_OF_CHANNELS];
<strong class="bold">void adc_dma_init</strong>(<strong class="bold">void</strong>)
{
    /************GPIO Configuration**********/
    /*Enable clock access to ADC GPIO Pin's Port*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA0 and PA1 mode to analog mode*/
    GPIOA-&gt;MODER |= (1U&lt;&lt;0);
    GPIOA-&gt;MODER |= (1U&lt;&lt;1);
    GPIOA-&gt;MODER |= (1U&lt;&lt;2);
    GPIOA-&gt;MODER |= (1U&lt;&lt;3);
    /************ADC Configuration**********/
    /*Enable clock access to ADC*/
    RCC-&gt;APB2ENR |= ADC1EN;
    /*Set sequence length*/
    ADC1-&gt;SQR1 |= (1U&lt;&lt;20);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;21);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;22);
    ADC1-&gt;SQR1 &amp;= ~(1U&lt;&lt;23);
    /*Set sequence*/
    ADC1-&gt;SQR3 = (0U&lt;&lt;0) | (1U&lt;&lt;5);
    /*Enable scan mode*/
    ADC1-&gt;CR1 = CR1_SCAN;
    /*Select to use DMA*/
    ADC1-&gt;CR2 |=CR2_CONT |CR2_DMA|CR2_DDS;
    /************DMA Configuration**********/
    /*Enable clock access to DMA*/
    RCC-&gt;AHB1ENR |=DMA2EN;
    /*Disable DMA stream*/
    DMA2_Stream0-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till DMA is disabled*/
    <strong class="bold">while</strong>((DMA2_Stream0-&gt;CR &amp; DMA_SCR_EN)){}
    /*Enable Circular mode*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_CIRC;
    /*Set MSIZE i.e Memory data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;13);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;14);
    /*Set PSIZE i.e Peripheral data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;11);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;12);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_MINC;
    /*Set <strong class="bold">periph</strong> address*/
    DMA2_Stream0-&gt;PAR = (uint32_t)(&amp;(ADC1-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA2_Stream0-&gt;M0AR = (uint32_t)(&amp;adc_raw_data);
    /*Set number of transfer*/
    DMA2_Stream0-&gt;NDTR = (uint16_t)NUM_OF_CHANNELS;
    /*Enable DMA stream*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_EN;
    /************ADC Configuration**********/
    /*Enable ADC*/
    ADC1-&gt;CR2 |=CR2_ADCON;
    /*Start ADC*/
    ADC1-&gt;CR2 |=CR2_SWSTART;
}</pre>			<p>Let’s go through each part of the code step by step to understand its purpose <span class="No-Break">and functionality.</span></p>
			<ol>
				<li><strong class="bold">Including the header file and defining constants</strong>: We start by including the <strong class="source-inline">adc_dma.h</strong> header file, which calls the <strong class="source-inline">stm32f4xx.h</strong> file and contains a macro for the number of channels <a id="_idIndexMarker1222"/>of our DMA driver. We then define several constants using <strong class="source-inline">#define</strong> statements. These constants represent bit masks for various registers and control flags, making the code more readable <span class="No-Break">and maintainable.</span></li>
				<li><strong class="bold">Defining the ADC data array</strong>: We declare an array, <strong class="source-inline">adc_raw_data</strong>, that stores the raw ADC data. The size of this array is determined by a predefined <span class="No-Break">constant, </span><span class="No-Break"><strong class="source-inline">NUM_OF_CHANNELS</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">The ADC DMA initialization function</strong>: In the <strong class="source-inline">adc_dma_init</strong> function, we begin by enabling the clock for GPIOA, which is necessary for configuring the GPIO pins used by the ADC. We then set the mode of the <strong class="source-inline">PA0</strong> and <strong class="source-inline">PA1</strong> pins to analog, as they are connected to the <span class="No-Break">ADC channels.</span></li>
				<li>Next, we enable the clock for ADC1 and configure the ADC sequence length and channel sequence. We set the ADC to scan mode, allowing it to convert multiple channels sequentially. Additionally, we enable DMA and continuous conversion mode for <span class="No-Break">the ADC.</span></li>
				<li><strong class="bold">DMA configuration</strong>: We then enable the clock for <strong class="source-inline">DMA2</strong> and ensure that the DMA stream is disabled before making any configurations. We configure the DMA stream for circular mode, which allows continuous data transfer. We set the memory and peripheral data sizes to half-word (16 bits). We enable memory address increment to correctly move through the <strong class="source-inline">adc_raw_data</strong> array and set the peripheral address to <a id="_idIndexMarker1223"/>the ADC data register. We specify the number of data items to transfer and, finally, enable the <span class="No-Break">DMA stream.</span></li>
				<li><strong class="bold">Enable and start ADC</strong>: In the final steps, we simply enable the ADC and start the conversion proce<a id="_idTextAnchor483"/>ss by setting the appropriate <span class="No-Break">control bits.</span></li>
			</ol>
			<p>Our next task is to populate the <strong class="source-inline">adc_dma.h</strong> file. Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADC_DMA_H__
<strong class="bold">#define</strong> ADC_DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void adc_dma_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">#define</strong> NUM_OF_CHANNELS        2
<strong class="bold">#endif</strong></pre>			<p>Let’s move on to the <strong class="source-inline">main.c</strong> file. Update your <strong class="source-inline">main.c</strong> file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adc_dma.h"
<strong class="bold">extern</strong> uint16_t adc_raw_data[NUM_OF_CHANNELS];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize ADC DMA*/
    adc_dma_init();
    <strong class="bold">while</strong>(1)
    {
        <strong class="bold">printf</strong>("Value from sensor one : %d \n\r ",adc_raw_data[0]);
        <strong class="bold">printf</strong>("Value from sensor two : %d \n\r ",adc_raw_data[1]);
        <strong class="bold">for</strong>( <strong class="bold">int</strong> i = 0; i &lt; 90000; i++){}
    }
}</pre>			<p>This code initializes the UART for debugging, and it sets up the ADC with DMA to continuously read sensor data from ADC channels connected to GPIO pins. In the main function, we start by <a id="_idIndexMarker1224"/>initializing the UART for communication, and then we call the <strong class="source-inline">adc_dma_init</strong> function to configure the ADC and DMA for data transfers. In the infinite loop, we repeatedly print the values from two sensors stored in the <strong class="source-inline">adc_raw_data</strong> array to <span class="No-Break">the console.</span></p>
			<p>To test the project, follow the steps we outlined in <a href="B21914_11.xhtml#_idTextAnchor303"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. Let’s proceed by developing the UART <span class="No-Break">DMA driver.</span></p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor484"/>Developing the UART DMA driver</h1>
			<p>Create a copy of your <a id="_idIndexMarker1225"/>previous project in your IDE. Rename this copied p<a id="_idTextAnchor485"/>roject <strong class="source-inline">UART_DMA</strong>. Next, create a new file named <strong class="source-inline">uart_dma.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">uart_dma.h</strong> in the <strong class="source-inline">Inc</strong> folder. Update your <strong class="source-inline">uart_dma.c</strong> file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "uart_dma.h"
<strong class="bold">#define</strong> UART2EN            (1U&lt;&lt;17)
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define</strong> CR1_TE            (1U&lt;&lt;3)
<strong class="bold">#define</strong> CR1_RE            (1U&lt;&lt;2)
<strong class="bold">#define</strong> CR1_UE            (1U&lt;&lt;13)
<strong class="bold">#define</strong> SR_TXE            (1U&lt;&lt;7)
<strong class="bold">#define</strong> CR3_DMAT        (1U&lt;&lt;7)
<strong class="bold">#define</strong> CR3_DMAR        (1U&lt;&lt;6)
<strong class="bold">#define</strong> SR_TC            (1U&lt;&lt;6)
<strong class="bold">#define</strong> CR1_TCIE        (1U&lt;&lt;6)
<strong class="bold">#define</strong> UART_BAUDRATE    115200
<strong class="bold">#define</strong> CLK                16000000
<strong class="bold">#define</strong> DMA1EN                (1U&lt;&lt;21)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_CIRC        (1U&lt;&lt;8)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
<strong class="bold">#define</strong> HIFCR_CDMEIF5        (1U&lt;&lt;8)
<strong class="bold">#define</strong> HIFCR_CTEIF5        (1U&lt;&lt;9)
<strong class="bold">#define</strong> HIFCR_CTCIF5        (1U&lt;&lt;11)
<strong class="bold">#define</strong> HIFCR_CDMEIF6        (1U&lt;&lt;18)
<strong class="bold">#define</strong> HIFCR_CTEIF6        (1U&lt;&lt;19)
<strong class="bold">#define</strong> HIFCR_CTCIF6        (1U&lt;&lt;21)
<strong class="bold">#define</strong> HIFSR_TCIF5        (1U&lt;&lt;11)
<strong class="bold">#define</strong> HIFSR_TCIF6        (1U&lt;&lt;21)
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk, uint32_t baudrate);
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk, uint32_t baudrate);
<strong class="bold">char</strong> uart_data_buffer[UART_DATA_BUFF_SIZE];
uint8_t g_rx_cmplt;
uint8_t g_tx_cmplt;
uint8_t g_uart_cmplt;
<strong class="bold">void uart2_rx_tx_init</strong>(<strong class="bold">void</strong>)
{
    /*************Configure UART GPIO pin********************/
    /*1.Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*2.Set PA2 mode to alternate function mode*/
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;4);
    GPIOA-&gt;MODER |=     (1U&lt;&lt;5);
    /*3.Set PA3 mode to alternate function mode*/
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;6);
    GPIOA-&gt;MODER |=     (1U&lt;&lt;7);
    /*4.Set PA2 alternate function function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;8);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;9);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;10);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;11);
    /*5.Set PA3 alternate function function type to AF7(UART2_TX)*/
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;12);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;13);
    GPIOA-&gt;AFR[0] |= (1U&lt;&lt;14);
    GPIOA-&gt;AFR[0] &amp;= ~(1U&lt;&lt;15);
    /*************Configure UART Module********************/
    /*6. Enable clock access to UART2*/
    RCC-&gt;APB1ENR |= UART2EN;
    /*7. Set <strong class="bold">baudrate</strong>*/
    uart_set_baudrate(CLK,UART_BAUDRATE);
    /*8. Select to use DMA for TX and RX*/
    USART2-&gt;CR3 = CR3_DMAT |CR3_DMAR;
    /*9. Set transfer direction*/
    USART2-&gt;CR1 = CR1_TE |CR1_RE;
    /*10.Clear TC flag*/
    USART2-&gt;SR &amp;=~SR_TC;
    /*11.Enable TCIE*/
    USART2-&gt;CR1 |=CR1_TCIE;
    /*12. Enable <strong class="bold">uart</strong> module*/
    USART2-&gt;CR1 |= CR1_UE;
    /*13.Enable USART2 interrupt in the NVIC*/
    NVIC_EnableIRQ(<strong class="bold">USART2_IRQn</strong>);
}</pre>			<p>Next, we have the <span class="No-Break">initialization function:</span></p>
			<pre class="source-code">
void dma1_init(void)
{
   /*Enable clock access to DMA*/
    RCC-&gt;AHB1ENR |=DMA1EN;
    /*Enable DMA Stream6 Interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA1_Stream6_IRQn</strong>);
}</pre>			<p><a id="_idIndexMarker1226"/>And then, the function for configuring the <span class="No-Break"><strong class="source-inline">rx</strong></span><span class="No-Break"> stream:</span></p>
			<pre class="source-code">
void dma1_stream5_uart_rx_config(void)
{
    /*Disable DMA stream*/
    DMA1_Stream5-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till DMA Stream is disabled*/
    while((DMA1_Stream5-&gt;CR &amp; DMA_SCR_EN)){}
    /*Clear interrupt flags for stream 5*/
    DMA1-&gt;HIFCR = HIFCR_CDMEIF5 |HIFCR_CTEIF5|HIFCR_CTCIF5;
    /*Set <strong class="bold">periph</strong> address*/
    DMA1_Stream5-&gt;PAR = (uint32_t)(&amp;(USART2-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA1_Stream5-&gt;M0AR = (uint32_t)(&amp;uart_data_buffer);
    /*Set number of transfer*/
    DMA1_Stream5-&gt;NDTR = (uint16_t)UART_DATA_BUFF_SIZE;
    /*Select Channel 4*/
    DMA1_Stream5-&gt;CR &amp;= ~(1u&lt;&lt;25);
    DMA1_Stream5-&gt;CR &amp;= ~(1u&lt;&lt;26);
    DMA1_Stream5-&gt;CR |= (1u&lt;&lt;27);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA1_Stream5-&gt;CR |=DMA_SCR_MINC;
    /*Enable transfer complete interrupt*/
    DMA1_Stream5-&gt;CR |= DMA_SCR_TCIE;
    /*Enable Circular mode*/
    DMA1_Stream5-&gt;CR |=DMA_SCR_CIRC;
    /*Set transfer direction : <strong class="bold">Periph</strong> to <strong class="bold">Mem</strong>*/
    DMA1_Stream5-&gt;CR &amp;=~(1U&lt;&lt;6);
    DMA1_Stream5-&gt;CR &amp;=~(1U&lt;&lt;7);
    /*Enable DMA stream*/
    DMA1_Stream5-&gt;CR |= DMA_SCR_EN;
    /*Enable DMA Stream5 Interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA1_Stream5_IRQn</strong>);
}</pre>			<p><a id="_idIndexMarker1227"/>And then, the one for the <span class="No-Break"><strong class="source-inline">tx</strong></span><span class="No-Break"> stream</span></p>
			<pre class="source-code">
<strong class="bold">void dma1_stream6_uart_tx_config</strong>(uint32_t msg_to_snd, uint32_t msg_len)
{
    /*Disable DMA stream*/
    DMA1_Stream6-&gt;CR &amp;=~DMA_SCR_EN;
    /*Wait till  DMA Stream is disabled*/
    <strong class="bold">while</strong>((DMA1_Stream6-&gt;CR &amp; DMA_SCR_EN)){}
    /*Clear interrupt flags for stream 6*/
    DMA1-&gt;HIFCR = HIFCR_CDMEIF6 |HIFCR_CTEIF6|HIFCR_CTCIF6;
    /*Set <strong class="bold">periph</strong> address*/
    DMA1_Stream6-&gt;PAR = (uint32_t)(&amp;(USART2-&gt;DR));
    /*Set <strong class="bold">mem</strong> address*/
    DMA1_Stream6-&gt;M0AR = msg_to_snd;
    /*Set number of transfer*/
    DMA1_Stream6-&gt;NDTR = msg_len;
    /*Select Channel 4*/
    DMA1_Stream6-&gt;CR &amp;= ~(1u&lt;&lt;25);
    DMA1_Stream6-&gt;CR &amp;= ~(1u&lt;&lt;26);
    DMA1_Stream6-&gt;CR |= (1u&lt;&lt;27);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA1_Stream6-&gt;CR |=DMA_SCR_MINC;
    /*Set transfer direction :<strong class="bold">Mem</strong> to <strong class="bold">Periph</strong>*/
    DMA1_Stream6-&gt;CR |=(1U&lt;&lt;6);
    DMA1_Stream6-&gt;CR &amp;=~(1U&lt;&lt;7);
    /*Set transfer complete interrupt*/
    DMA1_Stream6-&gt;CR |= DMA_SCR_TCIE;
    /*Enable DMA stream*/
    DMA1_Stream6-&gt;CR |= DMA_SCR_EN;
}</pre>			<p><a id="_idIndexMarker1228"/>Next, the function for computing the baudrate value for <span class="No-Break">the UART:</span></p>
			<pre class="source-code">
<strong class="bold">static</strong> uint16_t <strong class="bold">compute_uart_bd</strong>(uint32_t periph_clk, uint32_t baudrate)
{
    <strong class="bold">return</strong> ((periph_clk +( baudrate/2U ))/baudrate);
}</pre>			<p>And then, the function for writing the baudrate value to the <span class="No-Break">baudrate register:</span></p>
			<pre class="source-code">
<strong class="bold">static void uart_set_baudrate</strong>(uint32_t periph_clk, uint32_t baudrate)
{
    USART2-&gt;BRR  = compute_uart_bd(periph_clk,baudrate);
}</pre>			<p>Next, we have the interrupt handler <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Stream6</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
void DMA1_Stream6_IRQHandler(void)
{
    if((DMA1-&gt;HISR) &amp; HIFSR_TCIF6)
    {
        //do_ssomething
        g_tx_cmplt = 1;
        /*Clear the flag*/
        DMA1-&gt;HIFCR |= HIFCR_CTCIF6;
    }
}</pre>			<p><a id="_idIndexMarker1229"/>And then, the interrupt handler <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Stream5</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
void DMA1_Stream5_IRQHandler(void)
{
    if((DMA1-&gt;HISR) &amp; HIFSR_TCIF5)
    {
        g_rx_cmplt = 1;
        /*Clear the flag*/
        DMA1-&gt;HIFCR |= HIFCR_CTCIF5;
    }
}
void USART2_IRQHandler(void)
{
    g_uart_cmplt  = 1;
    /*Clear TC interrupt flag*/
    USART2-&gt;SR &amp;=~SR_TC;
}</pre>			<p>Let’s go <a id="_idIndexMarker1230"/>through each part of the code step <span class="No-Break">by step.</span></p>
			<h3>UART initialization</h3>
			<p>In the <strong class="source-inline">uart2_rx_tx_init</strong> function, we start by configuring the GPIO pins for UART2 communication. We enable the<a id="_idIndexMarker1231"/> clock for GPIOA, ensuring that the <strong class="source-inline">PA2</strong> and <strong class="source-inline">PA3</strong> pins can be used. Setting PA2 and PA3 to alternate function mode allows them to serve as <strong class="source-inline">UART2_TX</strong> and <strong class="source-inline">UART2_RX</strong>, respectively. We further specify the alternate function type to <strong class="source-inline">AF7</strong>, which is the type for <span class="No-Break">UART2 operations.</span></p>
			<p>With the GPIO configuration complete, we proceed to enable the clock for UART2. We set the baud rate using the <strong class="source-inline">uart_set_baudrate</strong> function. By enabling DMA for both transmission and reception, we offload data handling from the CPU, allowing for more efficient data transfers. We set the transfer direction to both transmit and receive, clear any pending transmission complete flags, and enable the transmission complete interrupt. Finally, we enable the UART module and configure the NVIC to handle UART2 interrupts, ensuring that the system can respond to UART <span class="No-Break">events promptly.</span></p>
			<h3>DMA initialization</h3>
			<p>Here, we start by enabling <a id="_idIndexMarker1232"/>the clock for <strong class="source-inline">DMA1</strong>, ensuring that the DMA controller is powered and ready for configuration. Additionally, we enable<a id="_idIndexMarker1233"/> the <strong class="bold">DMA Stream6</strong> interrupt in the NVIC, preparing the system to handle DMA-related <span class="No-Break">interrupts efficiently.</span></p>
			<h3>DMA configuration for UART reception</h3>
			<p>In <strong class="source-inline">dma1_stream5_uart_rx_config</strong>, we configure <strong class="bold">DMA1 Stream5</strong> to receive data via UART2. First, we disable <a id="_idIndexMarker1234"/>the DMA stream to safely <a id="_idIndexMarker1235"/>configure its parameters. After ensuring that the stream is disabled, we clear any existing interrupt flags. We set the peripheral address to the UART2 data register (<strong class="source-inline">USART2-DR</strong>) and the memory address to our <strong class="source-inline">uart_data_buffer</strong>, where incoming data will <span class="No-Break">be stored.</span></p>
			<p>We specify the number of data items to transfer and select the appropriate DMA channel. Enabling memory address increment mode ensures that the data buffer is filled sequentially. Circular mode is enabled to allow continuous data reception, and the transfer direction is set <strong class="bold">from peripheral to memory</strong>. We enable the DMA stream and configure<a id="_idIndexMarker1236"/> the NVIC to handle Stream5 interrupts, ensuring that the system is prepared for <span class="No-Break">DMA events.</span></p>
			<h3>DMA configuration for UART transmission</h3>
			<p>The <strong class="source-inline">dma1_stream6_uart_tx_config</strong> function configures DMA1 Stream6 to transmit data via UART2. Similar to the reception configuration, we start by disabling the DMA stream and<a id="_idIndexMarker1237"/> clearing any existing interrupt flags. We set the peripheral address to the UART2 data register and the memory address to the data buffer that will <span class="No-Break">be transmitted.</span></p>
			<p>We specify the number of data items to transfer and select the appropriate DMA channel. Memory address increment mode is enabled to ensure that data is transmitted sequentially from the buffer. We set the transfer direction <strong class="bold">from memory to peripheral</strong> and enable the transfer complete interrupt. Finally, we enable the DMA stream to start the data <span class="No-Break">transmission process.</span></p>
			<h3>Helper functions</h3>
			<p>The <strong class="source-inline">compute_uart_bd</strong> function calculates the UART baud rate setting based on the peripheral clock and<a id="_idIndexMarker1238"/> desired baud rate. The <strong class="source-inline">uart_set_baudrate</strong> function uses<a id="_idIndexMarker1239"/> this computed value to set the baud rate in the UART’s <strong class="source-inline">BRR</strong> register, ensuring that UART communication occurs at the <span class="No-Break">correct speed.</span></p>
			<h3>Interrupt handlers</h3>
			<p>Let’s break down the <span class="No-Break">interrupt</span><span class="No-Break"><a id="_idIndexMarker1240"/></span><span class="No-Break"> handlers:</span></p>
			<ul>
				<li><strong class="source-inline">DMA1_Stream6_IRQHandler</strong>: This handler responds to DMA Stream6 interrupts. When a transfer completes, it sets the <strong class="source-inline">g_tx_cmplt</strong> flag and clears the interrupt flag, ensuring that the <a id="_idIndexMarker1241"/>system is aware that the transmission <span class="No-Break">is complete.</span></li>
				<li><strong class="source-inline">DMA1_Stream5_IRQHandler</strong>: This handler responds to DMA Stream5 interrupts. When a transfer completes, it sets the <strong class="source-inline">g_rx_cmplt</strong> flag and clears the interrupt flag, indicating that new data has <span class="No-Break">been received.</span></li>
				<li><strong class="source-inline">USART2_IRQHandler</strong>: This handler manages UART2 interrupts. It sets the <strong class="source-inline">g_uart_cmplt</strong> flag when a UART event occurs and clears the transmission complete flag, maintaining the<a id="_idIndexMarker1242"/> proper flow of <span class="No-Break">UART communication.</span></li>
			</ul>
			<p>Next, we populate the <strong class="source-inline">uart_dma.h</strong> file. Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> UART_DMA_H__
<strong class="bold">#define</strong> UART_DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong> UART_DATA_BUFF_SIZE        5
<strong class="bold">void uart2_rx_tx_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_stream5_uart_rx_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma1_stream6_uart_tx_config</strong>(uint32_t msg_to_snd, uint32_t msg_len);
<strong class="bold">#endif</strong></pre>			<p>And then, we<a id="_idIndexMarker1243"/> populate the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "uart.h"
#include "uart_dma.h"
extern uint8_t g_rx_cmplt;
extern uint8_t g_uart_cmplt;
extern uint8_t g_tx_cmplt;
extern char uart_data_buffer[UART_DATA_BUFF_SIZE];
char msg_buff[150] ={'\0'};
int main(void)
{
    uart2_rx_tx_init();
    dma1_init();
    dma1_stream5_uart_rx_config();
    sprintf(msg_buff,"Initialization...<strong class="bold">cmplt</strong>\n\r");
    dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_buff));
    while(!g_tx_cmplt){}
    while(1)
    {
        if(g_rx_cmplt)
        {
            sprintf(msg_buff, "Message received : %s \r\n",uart_data_
            buffer);
            g_rx_cmplt = 0;
            g_tx_cmplt = 0;
            g_uart_cmplt = 0;
            dma1_stream6_uart_tx_config((uint32_t)msg_buff,strlen(msg_
            buff));
            while(!g_tx_cmplt){}
        }
    }
}</pre>			<p>In the <strong class="source-inline">main</strong> function, we start by initializing the UART and DMA, and then we configure DMA1 Stream5 for UART reception and DMA1 Stream6 for UART transmission. We prepare a message that<a id="_idIndexMarker1244"/> indicates initialization completion and initiate its transmission via DMA. The main loop continuously checks <a id="_idIndexMarker1245"/>whether a UART message has been received. When a message is received, it formats the received data into a response message, r<a id="_idTextAnchor486"/>esets the completion flags, and transmits the response <span class="No-Break">using DMA.</span></p>
			<h3>Testing the project</h3>
			<p>To test the project, compile the code and upload it to your microcontroller. Open RealTerm or any other <a id="_idIndexMarker1246"/>serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. Ensure the output area of RealTerm is active by clicking on it. Then, type any five keys on your keyboard. You should see these keys appear in the output area of RealTerm. The microcontroller receives the typed keys through the <strong class="source-inline">dma1_stream5_uart_rx_config</strong> function, stores them in the <strong class="source-inline">msg_buff</strong>, and transmits them to your host computer’s serial port via the <strong class="source-inline">dma1_stream6_uart_tx_config</strong> function. The last received data remains in <strong class="source-inline">msg_buff</strong> for further processing if needed. We type five characters because the <strong class="source-inline">UART_DATA_BUFF_SIZE</strong> is set to <strong class="source-inline">5</strong> in the <span class="No-Break"><strong class="source-inline">uart_dma.h</strong></span><span class="No-Break"> file.</span></p>
			<p>In the next section, we will develop our final DMA driver – the DMA <span class="No-Break">memory-to-memory driver.</span></p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor487"/>Developing the DMA memory-to-memory driver</h1>
			<p>Create a copy of your<a id="_idIndexMarker1247"/> previous project in your IDE and rename it <strong class="source-inline">DMA_MemToMem</strong>. Next, create a new file named <strong class="source-inline">dma.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">dma.h</strong> in the <strong class="source-inline">Inc</strong> folder. Update your <strong class="source-inline">dma.c</strong> file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "dma.h"
<strong class="bold">#define</strong> DMA2EN                (1U&lt;&lt;22)
<strong class="bold">#define</strong> DMA_SCR_EN          (1U&lt;&lt;0)
<strong class="bold">#define</strong> DMA_SCR_MINC        (1U&lt;&lt;10)
<strong class="bold">#define</strong> DMA_SCR_PINC        (1U&lt;&lt;9)
<strong class="bold">#define</strong> DMA_SCR_TCIE        (1U&lt;&lt;4)
<strong class="bold">#define</strong> DMA_SCR_TEIE        (1U&lt;&lt;2)
<strong class="bold">#define</strong> DMA_SFCR_DMDIS        (1U&lt;&lt;2)
<strong class="bold">void dma2_mem2mem_config</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to the <strong class="bold">dma</strong> module*/
    RCC-&gt;AHB1ENR |= DMA2EN;
    /*Disable <strong class="bold">dma</strong> stream*/
    DMA2_Stream0-&gt;CR = 0;
    /*Wait until stream is disabled*/
    <strong class="bold">while</strong>((DMA2_Stream0-&gt;CR &amp; DMA_SCR_EN)){}
    /*Configure <strong class="bold">dma</strong> parameters*/
    /*Set MSIZE i.e Memory data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;13);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;14);
    /*Set PSIZE i.e Peripheral data size to half-word*/
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;11);
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;12);
    /*Enable memory <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_MINC;
    /*Enable peripheral <strong class="bold">addr</strong> increment*/
    DMA2_Stream0-&gt;CR |=DMA_SCR_PINC;
    /*Select mem-to-mem transfer*/
    DMA2_Stream0-&gt;CR &amp;= ~(1U&lt;&lt;6);
    DMA2_Stream0-&gt;CR |= (1U&lt;&lt;7);
    /*Enable transfer complete interrupt*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_TCIE;
    /*Enable transfer error interrupt*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_TEIE;
    /*Disable direct mode*/
    DMA2_Stream0-&gt;FCR |=DMA_SFCR_DMDIS;
    /*Set DMA FIFO threshold*/
    DMA2_Stream0-&gt;FCR |=(1U&lt;&lt;0);
    DMA2_Stream0-&gt;FCR |=(1U&lt;&lt;1);
    /*Enable DMA interrupt in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">DMA2_Stream0_IRQn</strong>);
}</pre>			<p>This function sets up the <strong class="source-inline">DMA2</strong> controller for memory-to-memory data transfers. It begins by enabling the clock for the DMA2 module and ensures that the DMA stream is disabled before making any configuration changes. The function configures the data size for both memory and peripheral to <strong class="source-inline">half-word</strong> (16-bit) and enables automatic incrementing of the memory and peripheral addresses. It sets the transfer direction to <strong class="source-inline">memory-to-memory</strong> and<a id="_idIndexMarker1248"/> enables interrupts for transfer completion and transfer errors, ensuring robust error handling and efficient operation. Direct mode is disabled to use <strong class="source-inline">FIFO mode</strong>, and the FIFO threshold is set to <strong class="source-inline">full</strong>. Finally, the function enables the DMA stream and configures the NVIC to handle DMA interrupts, ensuring that the system can respond to DMA eve<a id="_idTextAnchor488"/>nts appropriately. We also have the <span class="No-Break"><strong class="source-inline">dma_transfer_start</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
<strong class="bold">void dma_transfer_start</strong>(uint32_t src_buff, uint32_t dest_buff, uint32_t len)
{
    /*Set peripheral address*/
    DMA2_Stream0-&gt;PAR = src_buff;
    /*Set memory address*/
    DMA2_Stream0-&gt;M0AR = dest_buff;
    /*Set transfer length*/
    DMA2_Stream0-&gt;NDTR = len;
    /*Enable <strong class="bold">dma</strong> stream*/
    DMA2_Stream0-&gt;CR |= DMA_SCR_EN;
}</pre>			<p>This function initiates the DMA transfer by configuring the source and destination addresses and the length of the data transfer. It begins by setting the peripheral address of the value passed in <strong class="source-inline">src_buff</strong> and the memory address of the value passed in <strong class="source-inline">dest_buff</strong>. The transfer length is<a id="_idIndexMarker1249"/> then specified by setting the <strong class="source-inline">NDTR</strong> register to <strong class="source-inline">len</strong>, indicating the number of data items to transfer. Finally, the function enables the DMA stream by setting the <strong class="source-inline">EN</strong> bit in the <strong class="source-inline">CR</strong> register, thereby starting the data transfer from the source to the destination. This is the <span class="No-Break"><strong class="source-inline">dma.h</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> DMA_H__
<strong class="bold">#define</strong> DMA_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong> LISR_TCIF0        (1U&lt;&lt;5)
<strong class="bold">#define</strong> LIFCR_CTCIF0        (1U&lt;&lt;5)
<strong class="bold">#define</strong> LISR_TEIF0        (1U&lt;&lt;3)
<strong class="bold">#define</strong> LIFCR_CTEIF0        (1U&lt;&lt;3)
<strong class="bold">void dma2_mem2mem_config</strong>(<strong class="bold">void</strong>);
<strong class="bold">void dma_transfer_start</strong>(uint32_t src_buff, uint32_t dest_buff, uint32_t len);
<strong class="bold">#endif</strong></pre>			<p>And this<a id="_idIndexMarker1250"/> is the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "uart.h"
#include "dma.h"
#include "uart.h"
#define BUFFER_SIZE        5
uint16_t sensor_data_arr[BUFFER_SIZE] = {892,731,1234,90,23};
uint16_t temp_data_arr[BUFFER_SIZE];
volatile uint8_t g_transfer_cmplt;
int main(void)
{
    g_transfer_cmplt = 0;
    uart_init();
    dma2_mem2mem_config();
    dma_transfer_start((uint32_t)sensor_data_arr,(uint32_t) temp_data_
    arr, BUFFER_SIZE);
    /*Wait until transfer complete*/
    while(!g_transfer_cmplt){}
    for( int i = 0; i &lt; BUFFER_SIZE; i++)
    {
        printf("Temp buffer[%d]: %d\r\n",i,temp_data_arr[i]);
    }
    g_transfer_cmplt = 0;
    while(1)
    {
    }
}</pre>			<p>The <strong class="source-inline">main</strong> function sets up and initiates a memory-to-memory DMA transfer, transferring data from the globally declared and initialized <strong class="source-inline">sensor_data_arr</strong> to the uninitialized <strong class="source-inline">temp_data_arr</strong>. It starts by initializing the transfer complete flag, <strong class="source-inline">g_transfer_cmplt</strong>, to <strong class="source-inline">0</strong>, ensuring that we can monitor the transfer status. The function then initializes UART for debugging purposes and configures the DMA using <strong class="source-inline">dma2_mem2mem_config</strong>. The DMA<a id="_idIndexMarker1251"/> transfer is started by calling <strong class="source-inline">dma_transfer_start</strong>, specifying the source (<strong class="source-inline">sensor_data_arr</strong>), destination (<strong class="source-inline">temp_data_arr</strong>), and the length of the transfer (<strong class="source-inline">BUFFER_SIZE</strong>). The function then enters a loop, waiting until the transfer is complete, indicated by<strong class="source-inline"> g_transfer_cmplt</strong> being set to <strong class="source-inline">1</strong>. Once the transfer is complete, it prints the contents of the <strong class="source-inline">temp_data_arr</strong> to the console, confirming that the data has been <span class="No-Break">successfully transferred.</span></p>
			<p>Our <strong class="source-inline">main.c</strong> file also contains the DMA <span class="No-Break">stream’s IRQHandler:</span></p>
			<pre class="source-code">
void DMA2_Stream0_IRQHandler(void)
{
    /*Check if transfer complete interrupt occurred*/
    if((DMA2-&gt;LISR) &amp; LISR_TCIF0)
    {
        g_transfer_cmplt = 1;
        /*Clear flag*/
        DMA2-&gt;LIFCR |=LIFCR_CTCIF0;
    }
    /*Check if transfer error occurred*/
    if((DMA2-&gt;LISR) &amp; LISR_TEIF0)
    {
        /*Do something...*/
        /*Clear flag*/
        DMA2-&gt;LIFCR |= LIFCR_CTEIF0;
    }
}</pre>			<p>The handler manages both transfer completion and error events. The function first checks whether the transfer complete interrupt flag (<strong class="source-inline">TCIF0</strong>) is set in the low interrupt status register (<strong class="source-inline">LISR</strong>). If this flag is set, it indicates that the DMA transfer has successfully finished. The function then sets the <strong class="source-inline">g_transfer_cmplt</strong> flag to <strong class="source-inline">1</strong> to signal to the main function that the transfer is complete, and it clears the interrupt flag by writing to the low<a id="_idIndexMarker1252"/> interrupt flag clear register (<strong class="source-inline">LIFCR</strong>). Additionally, the function checks for a transfer error interrupt (<strong class="source-inline">TEIF0</strong>). If a transfer error is detected, it performs any necessary error handling and clears the error flag in <strong class="source-inline">LIFCR</strong>. This interrupt handler ensures smooth operation by promptly handling the completion of data transfers and addressing any errors that might occur during <span class="No-Break">the process.</span></p>
			<p>Now, it’s time to test the project. To test the project, compile the code and upload it to your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the sensor values printed, indicating that the values have been successfully copied from <strong class="source-inline">sensor_data_arr</strong> to <strong class="source-inline">temp_data_arr</strong>, as our code only prints the contents <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">temp_data_arr</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor489"/>Summary</h1>
			<p>In this chapter, we learned about DMA, an important feature in microcontrollers for enhancing data throughput and offloading the CPU from routine data transfer tasks. We began by discussing the basic principles of DMA, emphasizing its role in high-performance embedded systems. We explored how DMA works and its significance in improving system efficiency, by allowing peripherals to transfer data directly to and from memory without continuous <span class="No-Break">CPU intervention.</span></p>
			<p>Then, we focused on the STM32F4 implementation of the DMA controller, examining its key features and configuration options. We detailed the structure of the DMA controller, including its channels, streams, and key registers, such as the Stream Configuration Register (<strong class="source-inline">DMA_SxCR</strong>), Stream Number of Data Register (<strong class="source-inline">DMA_SxNDTR</strong>), Stream Peripheral Address Register (<strong class="source-inline">DMA_SxPAR</strong>), and Stream Memory Address Registers (<strong class="source-inline">DMA_SxM0AR</strong> and <strong class="source-inline">DMA_SxM1AR</strong>). This provided a comprehensive understanding of how to configure and control DMA for various data <span class="No-Break">transfer operations.</span></p>
			<p>We provided practical <a id="_idIndexMarker1253"/>examples to solidify our understanding, including the development of DMA drivers for different use cases, such as ADC data transfers, UART communications, and memory-to-memory transfers. These examples involved initializing DMA, setting up the necessary parameters, and implementing functions to handle data <span class="No-Break">transfers efficiently.</span></p>
			<p>In the next chapter, we will learn about power management energy efficiency techniques in <span class="No-Break">embedded systems.</span></p>
		</div>
	</div>
</div>
</body></html>