["```cpp\nclass Image {};\nclass BitmapImage : public Image {};\nclass PngImage    : public Image {};\nclass JpgImage    : public Image {}; \n```", "```cpp\nstruct IImageFactory\n{\n  virtual std::unique_ptr<Image> Create(std::string_view type) = 0;\n};\nstruct ImageFactory : public IImageFactory\n{\n  std::unique_ptr<Image> \n Create(std::string_view type) override\n {\n    if (type == \"bmp\")\n      return std::make_unique<BitmapImage>();\n    else if (type == \"png\")\n      return std::make_unique<PngImage>();\n    else if (type == \"jpg\")\n      return std::make_unique<JpgImage>();\n    return nullptr;\n  }\n}; \n```", "```cpp\n    struct ImageFactory : public IImageFactory\n    {\n      std::unique_ptr<Image> Create(std::string_view type) override\n     { \n        // continued with 2\\. and 3.\n      }\n    }; \n    ```", "```cpp\n    static std::map<\n      std::string,\n      std::function<std::unique_ptr<Image>()>> mapping\n    {\n      { \"bmp\", []() {return std::make_unique<BitmapImage>(); } },\n      { \"png\", []() {return std::make_unique<PngImage>(); } },\n      { \"jpg\", []() {return std::make_unique<JpgImage>(); } }\n    }; \n    ```", "```cpp\n    auto it = mapping.find(type.data());\n    if (it != mapping.end())\n      return it->second();\n    return nullptr; \n    ```", "```cpp\nauto factory = ImageFactory{};\nauto image = factory.Create(\"png\"); \n```", "```cpp\nstruct IImageFactoryByType\n{\n  virtual std::unique_ptr<Image> Create(\n    std::type_info const & type) = 0;\n};\nstruct ImageFactoryByType : public IImageFactoryByType\n{\n  std::unique_ptr<Image> Create(std::type_info const & type) \n override\n {\n    auto it = mapping.find(&type);\n    if (it != mapping.end())\n      return it->second();\n    return nullptr;\n  }\nprivate:\n  static std::map<\n    std::type_info const *,\n    std::function<std::unique_ptr<Image>()>> mapping;\n};\nstd::map<\n  std::type_info const *,\n  std::function<std::unique_ptr<Image>()>> ImageFactoryByType::mapping\n{\n  {&typeid(BitmapImage),[](){\n      return std::make_unique<BitmapImage>();}},\n  {&typeid(PngImage),   [](){\n      return std::make_unique<PngImage>();}},\n  {&typeid(JpgImage),   [](){\n      return std::make_unique<JpgImage>();}}\n}; \n```", "```cpp\nauto factory = ImageFactoryByType{};\nauto movie = factory.Create(typeid(PngImage)); \n```", "```cpp\nclass control\n{\n  std::string text;\n  int width = 0;\n  int height = 0;\n  bool visible = true;\n  void draw()\n {\n    std::cout \n      << \"control \" << '\\n'\n      << \" visible: \" << std::boolalpha << visible << \n         std::noboolalpha << '\\n'\n      << \" size: \" << width << \", \" << height << '\\n'\n      << \" text: \" << text << '\\n';\n  }\npublic:\n  void set_text(std::string_view t)\n {\n    text = t.data();\n    draw();\n  }\n  void resize(int const w, int const h)\n {\n    width = w;\n    height = h;\n    draw();\n  }\n  void show() \n { \n    visible = true; \n    draw();\n  }\n  void hide() \n { \n    visible = false; \n    draw();\n  }\n}; \n```", "```cpp\n    // in control.h\n    class control_pimpl; \n    ```", "```cpp\n    class control\n    {\n      std::unique_ptr<control_pimpl, void(*)(control_pimpl*)> pimpl;\n      public:\n        control();\n        void set_text(std::string_view text);\n        void resize(int const w, int const h);\n        void show();\n        void hide();\n    }; \n    ```", "```cpp\n    // in control.cpp\n    class control_pimpl\n    {\n      std::string text;\n      int width = 0;\n      int height = 0;\n      bool visible = true;\n      void draw()\n     {\n        std::cout\n          << \"control \" << '\\n'\n          << \" visible: \" << std::boolalpha << visible \n          << std::noboolalpha << '\\n'\n          << \" size: \" << width << \", \" << height << '\\n'\n          << \" text: \" << text << '\\n';\n      }\n    public:\n      void set_text(std::string_view t)\n     {\n        text = t.data();\n        draw();\n      }\n      void resize(int const w, int const h)\n     {\n        width = w;\n        height = h;\n        draw();\n      }\n      void show()\n     {\n        visible = true;\n        draw();\n      }\n      void hide()\n     {\n        visible = false;\n        draw();\n      }\n    }; \n    ```", "```cpp\n    control::control() :\n      pimpl(new control_pimpl(),\n            [](control_pimpl* pimpl) {delete pimpl; })\n    {} \n    ```", "```cpp\n    void control::set_text(std::string_view text)\n    {\n      pimpl->set_text(text);\n    }\n    void control::resize(int const w, int const h)\n    {\n      pimpl->resize(w, h);\n    }\n    void control::show()\n    {\n      pimpl->show();\n    }\n    void control::hide()\n    {\n      pimpl->hide();\n    } \n    ```", "```cpp\nstd::unique_ptr<control_pimpl, void(*)(control_pimpl*)> pimpl; \n```", "```cpp\ncontrol c;\nc.resize(100, 20);\nc.set_text(\"sample\");\nc.hide();\ncontrol c2 = c;             // copy\nc2.show();\ncontrol c3 = std::move(c2); // move\nc3.hide(); \n```", "```cpp\nclass control_copyable\n{\n  std::unique_ptr<control_pimpl, void(*)(control_pimpl*)> pimpl;\npublic:\n  control_copyable();\n  control_copyable(control_copyable && op) noexcept;\n  control_copyable& operator=(control_copyable && op) noexcept;\n  control_copyable(const control_copyable& op);\n  control_copyable& operator=(const control_copyable& op);\n  void set_text(std::string_view text);\n  void resize(int const w, int const h);\n  void show();\n  void hide();\n};\ncontrol_copyable::control_copyable() :\n  pimpl(new control_pimpl(),\n        [](control_pimpl* pimpl) {delete pimpl; })\n{}\ncontrol_copyable::control_copyable(control_copyable &&) \n   noexcept = default;\ncontrol_copyable& control_copyable::operator=(control_copyable &&) \n   noexcept = default;\ncontrol_copyable::control_copyable(const control_copyable& op)\n   : pimpl(new control_pimpl(*op.pimpl),\n           [](control_pimpl* pimpl) {delete pimpl; })\n{}\ncontrol_copyable& control_copyable::operator=(\n   const control_copyable& op) \n{\n  if (this != &op) \n  {\n    pimpl = std::unique_ptr<control_pimpl,void(*)(control_pimpl*)>(\n               new control_pimpl(*op.pimpl),\n               [](control_pimpl* pimpl) {delete pimpl; });\n  }\n  return *this;\n}\n// the other member functions \n```", "```cpp\nclass control\n{\n  int id_;\n  std::string text_;\n  int width_;\n  int height_;\n  bool visible_;\npublic:\n  control(\n    int const id,\n    std::string_view text = \"\",\n    int const width = 0,\n    int const height = 0,\n    bool const visible = false):\n      id_(id), text_(text), \n      width_(width), height_(height), \n      visible_(visible)\n  {}\n}; \n```", "```cpp\n    class control_properties\n    {\n      int id_;\n      std::string text_;\n      int width_ = 0;\n      int height_ = 0;\n      bool visible_ = false;\n    }; \n    ```", "```cpp\n    friend class control; \n    ```", "```cpp\n    public:\n      control_properties(int const id) :id_(id)\n      {} \n    ```", "```cpp\n    public:\n      control_properties& text(std::string_view t) \n     { text_ = t.data(); return *this; }\n      control_properties& width(int const w) \n     { width_ = w; return *this; }\n      control_properties& height(int const h) \n     { height_ = h; return *this; }\n      control_properties& visible(bool const v) \n     { visible_ = v; return *this; } \n    ```", "```cpp\n    control(control_properties const & cp):\n      id_(cp.id_), \n      text_(cp.text_),\n      width_(cp.width_), \n      height_(cp.height_),\n      visible_(cp.visible_)\n    {} \n    ```", "```cpp\nclass control;\nclass control_properties\n{\n  int id_;\n  std::string text_;\n  int width_ = 0;\n  int height_ = 0;\n  bool visible_ = false;\n  friend class control;\npublic:\n  control_properties(int const id) :id_(id)\n  {}\n  control_properties& text(std::string_view t) \n { text_ = t.data(); return *this; }\n  control_properties& width(int const w) \n { width_ = w; return *this; }\n  control_properties& height(int const h) \n { height_ = h; return *this; }\n  control_properties& visible(bool const v) \n { visible_ = v; return *this; }\n};\nclass control\n{\n  int         id_;\n  std::string text_;\n  int         width_;\n  int         height_;\n  bool        visible_;\npublic:\n  control(control_properties const & cp):\n    id_(cp.id_), \n    text_(cp.text_),\n    width_(cp.width_), \n    height_(cp.height_),\n    visible_(cp.visible_)\n  {}\n}; \n```", "```cpp\ncontrol c(1044, \"sample\", 100, 20, true); \n```", "```cpp\ncontrol c(control_properties(1044)\n          .visible(true)\n          .height(20)\n          .width(100)); \n```", "```cpp\nclass control\n{\nprivate:\n  virtual void paint() = 0;\nprotected:\n  virtual void erase_background() \n {\n    std::cout << \"erasing control background...\" << '\\n';\n  }\npublic:\n  void draw()\n {\n    erase_background();\n    paint();\n  }\n  virtual ~control() {}\n};\nclass button : public control\n{\nprivate:\n  virtual void paint() override\n {\n    std::cout << \"painting button...\" << '\\n';\n  }\nprotected:\n  virtual void erase_background() override\n {\n    control::erase_background();\n    std::cout << \"erasing button background...\" << '\\n';\n  }\n};\nclass checkbox : public button\n{\nprivate:\n  virtual void paint() override\n {\n    std::cout << \"painting checkbox...\" << '\\n';\n  }\nprotected:\n  virtual void erase_background() override\n {\n    button::erase_background();\n    std::cout << \"erasing checkbox background...\" << '\\n';\n  }\n}; \n```", "```cpp\nstd::vector<std::unique_ptr<control>> controls;\ncontrols.emplace_back(std::make_unique<button>());\ncontrols.emplace_back(std::make_unique<checkbox>());\nfor (auto& c : controls)\n  c->draw(); \n```", "```cpp\nerasing control background...\nerasing button background...\npainting button...\nerasing control background...\nerasing button background...\nerasing checkbox background...\npainting checkbox...\ndestroying button...\ndestroying control...\ndestroying checkbox...\ndestroying button...\ndestroying control... \n```", "```cpp\nclass control\n{\nprotected:\n  virtual void initialize_impl()\n {\n    std::cout << \"initializing control...\" << '\\n';\n  }\npublic:\n  void initialize()\n {\n    initialize_impl();\n  }\n};\nclass button : public control\n{\nprotected:\n  virtual void initialize_impl()\n {\n    control::initialize_impl();\n    std::cout << \"initializing button...\" << '\\n';\n  }\n}; \n```", "```cpp\nclass Client\n{\n  int data_1;\n  int data_2;\n  void action1() {}\n  void action2() {}\n  friend class Friend;\npublic:\n  // public interface\n};\nclass Friend\n{\npublic:\n  void access_client_data(Client& c)\n {\n    c.action1();\n    c.action2();\n    auto d1 = c.data_1;\n    auto d2 = c.data_1;\n  }\n}; \n```", "```cpp\n    class Client\n    {\n      int data_1;\n      int data_2;\n      void action1() {}\n      void action2() {}\n      friend class Attorney;\n    public:\n      // public interface\n    }; \n    ```", "```cpp\n    class Attorney\n    {\n      static inline void run_action1(Client& c)\n     {\n        c.action1();\n      }\n      static inline int get_data1(Client& c)\n     {\n        return c.data_1;\n      }\n      friend class Friend;\n    }; \n    ```", "```cpp\n    class Friend\n    {\n    public:\n      void access_client_data(Client& c)\n     {\n        Attorney::run_action1(c);\n        auto d1 = Attorney::get_data1(c);\n      }\n    }; \n    ```", "```cpp\nclass B\n{\n  virtual void execute() { std::cout << \"base\" << '\\n'; }\n  friend class BAttorney;\n};\nclass D : public B\n{\n  virtual void execute() override \n { std::cout << \"derived\" << '\\n'; }\n};\nclass BAttorney\n{\n  static inline void execute(B& b)\n {\n    b.execute();\n  }\n  friend class F;\n};\nclass F\n{\npublic:\n  void run()\n {\n    B b;\n    BAttorney::execute(b); // prints 'base'\n    D d;\n    BAttorney::execute(d); // prints 'derived'\n  }\n};\nF;\nf.run(); \n```", "```cpp\n    template <class T>\n    class control\n    {\n    public:\n      void draw()\n     {\n        static_cast<T*>(this)->erase_background();\n        static_cast<T*>(this)->paint();\n      }\n    }; \n    ```", "```cpp\n    class button : public control<button>\n    {\n    public:\n      void erase_background()\n     {\n        std::cout << \"erasing button background...\" << '\\n';\n      }\n      void paint()\n     {\n        std::cout << \"painting button...\" << '\\n';\n      }\n    };\n    class checkbox : public control<checkbox>\n    {\n    public:\n      void erase_background()\n     {\n        std::cout << \"erasing checkbox background...\" \n                  << '\\n';\n      }\n      void paint()\n     {\n        std::cout << \"painting checkbox...\" << '\\n';\n      }\n    }; \n    ```", "```cpp\n    template <class T>\n    void draw_control(control<T>& c)\n    {\n      c.draw();\n    }\n    button b;\n    draw_control(b);\n    checkbox c;\n    draw_control(c); \n    ```", "```cpp\ntemplate <class T>\nclass control\n{\n  T* derived() { return static_cast<T*>(this); }\npublic:\n  void draw()\n {\n    derived()->erase_background();\n    derived()->paint();\n  }\n}; \n```", "```cpp\n    class button : public control<button>\n    {\n    private:\n      friend class control<button>;\n      void erase_background()\n     {\n        std::cout << \"erasing button background...\" << '\\n';\n      }\n      void paint()\n     {\n        std::cout << \"painting button...\" << '\\n';\n      }\n    }; \n    ```", "```cpp\nclass controlbase\n{\npublic:\n  virtual void draw() = 0;\n  virtual ~controlbase() {}\n};\ntemplate <class T>\nclass control : public controlbase\n{\npublic:\n  virtual void draw() override\n {\n    static_cast<T*>(this)->erase_background();\n    static_cast<T*>(this)->paint();\n  }\n}; \n```", "```cpp\nvoid draw_controls(std::vector<std::unique_ptr<controlbase>>& v)\n{\n  for (auto & c : v)\n  {\n    c->draw();\n  }\n}\nstd::vector<std::unique_ptr<controlbase>> v;\nv.emplace_back(std::make_unique<button>());\nv.emplace_back(std::make_unique<checkbox>());\ndraw_controls(v); \n```", "```cpp\n    class button\n    {\n    public:\n       void erase_background()\n     {\n          std::cout << \"erasing button background...\" << '\\n';\n       }\n       void paint()\n     {\n          std::cout << \"painting button...\" << '\\n';\n       }\n    };\n    class checkbox\n    {\n    public:\n       void erase_background()\n     {\n          std::cout << \"erasing checkbox background...\" << '\\n';\n       }\n       void paint()\n     {\n          std::cout << \"painting checkbox...\" << '\\n';\n       }\n    }; \n    ```", "```cpp\n    template <typename T>\n    class control : public T\n    {\n    public:\n       void draw()\n     {\n          T::erase_background();\n          T::paint();\n       }\n    }; \n    ```", "```cpp\n    control<button> b;\n    b.draw();\n    control<checkbox> c;\n    c.draw(); \n    ```", "```cpp\nvoid draw_all(std::vector<???*> const & controls)\n{\n   for (auto& c : controls)\n   {\n      c->draw();\n   }\n} \n```", "```cpp\nclass control_base\n{\npublic:\n   virtual ~control_base() {}\n   virtual void draw() = 0;\n}; \n```", "```cpp\ntemplate <typename T>\nclass control : public control_base, public T \n{\npublic:\n   void draw() override\n {\n      T::erase_background();\n      T::paint();\n   }\n}; \n```", "```cpp\nvoid draw_all(std::vector<control_base*> const & controls)\n{\n   for (auto& c : controls)\n   {\n      c->draw();\n   }\n}\nint main()\n{\n   std::vector<control_base*> controls;\n   control<button> b;\n   control<checkbox> c;\n   draw_all({&b, &c});\n} \n```", "```cpp\nclass button\n{\npublic:\n   void erase_background()\n {\n      std::cout << \"erasing button background...\" << '\\n';\n   }\n   void paint()\n {\n      std::cout << \"painting button...\" << '\\n';\n   }\n};\nclass checkbox\n{\npublic:\n   void erase_background()\n {\n      std::cout << \"erasing checkbox background...\" << '\\n';\n   }\n   void paint()\n {\n      std::cout << \"painting checkbox...\" << '\\n';\n   }\n}; \n```", "```cpp\n    struct control\n    {\n    }; \n    ```", "```cpp\n    struct control_concept\n    {\n       virtual ~control_concept() = default;\n       virtual void draw() = 0;\n    }; \n    ```", "```cpp\n    template <typename T>\n    struct control_model : public control_concept\n    {\n       control_model(T & unit) : t(unit) {}\n       void draw() override\n     {\n          t.erase_background();\n          t.paint();\n       }\n    private:\n       T& t;\n    }; \n    ```", "```cpp\n    private:\n       std::shared_ptr<control_concept> ctrl; \n    ```", "```cpp\n    template <typename T>\n    control(T&& obj) : \n       ctrl(std::make_shared<control_model<T>>(std::forward<T>(obj)))\n    {\n    } \n    ```", "```cpp\n    void draw()\n    {\n       ctrl->draw();\n    } \n    ```", "```cpp\nstruct control\n{\n   template <typename T>\n   control(T&& obj) : \n      ctrl(std::make_shared<control_model<T>>(std::forward<T>(obj)))\n   {\n   }\n   void draw()\n {\n      ctrl->draw();\n   }\n   struct control_concept\n   {\n      virtual ~control_concept() = default;\n      virtual void draw() = 0;\n   };\n   template <typename T>\n   struct control_model : public control_concept\n   {\n      control_model(T& unit) : t(unit) {}\n      void draw() override\n {\n         t.erase_background();\n         t.paint();\n      }\n   private:\n      T& t;\n   };\nprivate:\n   std::shared_ptr<control_concept> ctrl;\n}; \n```", "```cpp\nvoid draw(std::vector<control>& controls)\n{\n   for (auto& c : controls)\n   {\n      c.draw();\n   }\n}\nint main()\n{\n   checkbox cb;\n   button btn;\n   std::vector<control> v{control(cb), control(btn)};\n   draw(v);\n} \n```", "```cpp\nvoid draw_button(void* ptr)\n{\n   button* b = static_cast<button*>(ptr);\n   if (b)\n   {\n      b->erase_background();\n      b->paint();\n   }\n}\nint main()\n{\n   button btn;\n   draw_button(&btn);\n   checkbox cb;\n   draw_button(&cb); // runtime error\n} \ndraw_button() is a function that knows how to draw a button. But we can pass a pointer to anything – there will be no compile-time error or warning. However, the program will likely crash at runtime.\n```", "```cpp\nstruct control_concept\n{\n   virtual ~control_concept() = default;\n   virtual void draw() = 0;\n}; \n```", "```cpp\nstruct button_wrapper : control_concept\n{\n   button_wrapper(button& b):btn(b)\n   {}\n   void draw() override\n {\n      btn.erase_background();\n      btn.paint();\n   }\nprivate:\n   button& btn;\n};\nstruct checkbox_wrapper : control_concept\n{\n   checkbox_wrapper(checkbox& cb) :cbox(cb)\n   {}\n   void draw() override\n {\n      cbox.erase_background();\n      cbox.paint();\n   }\nprivate:\n   checkbox& cbox;\n}; \n```", "```cpp\nvoid draw(std::vector<control_concept*> const & controls)\n{\n   for (auto& c : controls)\n      c->draw();\n}\nint main()\n{\n   checkbox cb;\n   button btn;\n   checkbox_wrapper cbw(cb);\n   button_wrapper btnw(btn);\n   std::vector<control_concept*> v{ &cbw, &btnw };\n   draw(v);\n} \n```", "```cpp\ntemplate <typename T>\nstruct control_wrapper : control_concept\n{\n   control_wrapper(T& b) : ctrl(b)\n   {}\n   void draw() override\n {\n      ctrl.erase_background();\n      ctrl.paint();\n   }\nprivate:\n   T& ctrl;\n}; \n```", "```cpp\nint main()\n{\n   checkbox cb;\n   button btn;\n   control_wrapper<checkbox> cbw(cb);\n   control_wrapper<button> btnw(btn);\n   std::vector<control_concept*> v{ &cbw, &btnw };\n   draw(v);\n} \n```", "```cpp\nstruct control_collection\n{\n   template <typename T>\n   void add_control(T&& obj) \n {      \n      ctrls.push_back(\n         std::make_shared<control_model<T>>(std::forward<T>(obj)));\n   }\n   void draw()\n {\n      for (auto& c : ctrls)\n      {\n         c->draw();\n      }\n   }\n   struct control_concept\n   {\n      virtual ~control_concept() = default;\n      virtual void draw() = 0;\n   };\n   template <typename T>\n   struct control_model : public control_concept\n   {\n      control_model(T& unit) : t(unit) {}\n      void draw() override\n {\n         t.erase_background();\n         t.paint();\n      }\n   private:\n      T& t;\n   };\nprivate:\n   std::vector<std::shared_ptr<control_concept>> ctrls;\n}; \n```", "```cpp\nint main()\n{\n   checkbox cb;\n   button btn;\n   control_collection cc;\n\n   cc.add_control(cb);\n   cc.add_control(btn);\n   cc.draw();\n} \n```", "```cpp\n    class Singleton\n    {\n    }; \n    ```", "```cpp\n    private:\n      Singleton() = default; \n    ```", "```cpp\n    public:\n      Singleton(Singleton const &) = delete;\n      Singleton& operator=(Singleton const&) = delete; \n    ```", "```cpp\n    public:\n      static Singleton& instance()\n     {\n        static Singleton single;\n        return single;\n      } \n    ```", "```cpp\ntemplate <class T>\nclass SingletonBase\n{\nprotected:\n  SingletonBase() {}\npublic:\n  SingletonBase(SingletonBase const &) = delete;\n  SingletonBase& operator=(SingletonBase const&) = delete;\n  static T& instance()\n {\n    static T single;\n    return single;\n  }\n};\nclass Single : public SingletonBase<Single>\n{\n  Single() {}\n  friend class SingletonBase<Single>;\npublic:\n  void demo() { std::cout << \"demo\" << '\\n'; }\n}; \n```"]