["```cpp\nPROVIDE(_end_stack = ORIGIN(CCRAM) + LENGTH(CCRAM));\nPROVIDE(stack_space = ORIGIN(CCRAM));\nPROVIDE(_start_heap = _end);\n```", "```cpp\nextern uint32_t stack_space;\n#define STACK_SIZE (256)\n```", "```cpp\n#define TASK_WAITING 0\n#define TASK_READY 1\n#define TASK_RUNNING 2\n#define TASK_NAME_MAXLEN 16;\nstruct task_block {\n  char name[TASK_NAME_MAXLEN];\n  int id;\n  int state;\n  void (*start)(void *arg);\n  void *arg;\n  uint32_t *sp;\n};\n```", "```cpp\n#define MAX_TASKS 8\nstatic struct task_block TASKS[MAX_TASKS];\nstatic int n_tasks = 1;\nstatic int running_task_id = 0;\n#define kernel TASKS[0]\n```", "```cpp\nstruct task_block *task_create(char *name, void (*start)(void *arg), void *arg)\n{\n  struct task_block *t;\n  int i;\n  if (n_tasks >= MAX_TASKS)\n    return NULL;\n  t = &TASKS[n_tasks];\n  t->id = n_tasks++;\n  for (i = 0; i < TASK_NAME_MAXLEN; i++) {\n    t->name[i] = name[i];\n    if (name[i] == 0)\n      break;\n  }\n  t->state = TASK_READY;\n  t->start = start;\n  t->arg = arg;\n  t->sp = ((&stack_space) + n_tasks * STACK_SIZE);\n  task_stack_init(t);\n  return t;\n}\n```", "```cpp\nstatic void __attribute__((naked)) store_context(void)\n{\n  asm volatile(\"mrs r0, msp\");\n  asm volatile(\"stmdb r0!, {r4-r11}\");\n  asm volatile(\"msr msp, r0\");\n  asm volatile(\"bx lr\");\n}\nstatic void __attribute__((naked)) restore_context(void)\n{\n  asm volatile(\"mrs r0, msp\");\n  asm volatile(\"ldmfd r0!, {r4-r11}\");\n  asm volatile(\"msr msp, r0\");\n  asm volatile(\"bx lr\");\n}\n```", "```cpp\nstruct stack_frame {\n  uint32_t r0, r1, r2, r3, r12, lr, pc, xpsr;\n};\nstruct extra_frame {\n  uint32_t r4, r5, r6, r7, r8, r9, r10, r11;\n};\nstatic void task_stack_init(struct task_block *t)\n{\n  struct stack_frame *tf;\n  t->sp -= sizeof(struct stack_frame);\n  tf = (struct stack_frame *)(t->sp);\n  tf->r0 = (uint32_t) t->arg;\n  tf->pc = (uint32_t) t->start;\n  tf->lr = (uint32_t) task_terminated;\n  tf->xpsr = (1 << 24);\n  t->sp -= sizeof(struct extra_frame);\n}\n```", "```cpp\nvoid main(void) {\n  clock_pll_on(0);\n  systick_enable();\n  led_setup();\n  kernel.name[0] = 0;\n  kernel.id = 0;\n  kernel.state = TASK_RUNNING;\n  task_create(\"test0\",task_test0, NULL);\n  task_create(\"test1\",task_test1, NULL);\n  while(1) {\n    schedule();\n  }\n}\n```", "```cpp\n#define SCB_ICSR (*((volatile uint32_t *)0xE000ED04))\n#define schedule() SCB_ICSR |= (1 << 28)\n```", "```cpp\nvoid __attribute__((naked)) isr_pendsv(void)\n{\n  store_context();\n  asm volatile(\"mrs %0, msp\" : \"=r\"(\n          TASKS[running_task_id].sp));\n  TASKS[running_task_id].state = TASK_READY;\n  running_task_id++;\n  if (running_task_id >= n_tasks)\n    running_task_id = 0;\n  TASKS[running_task_id].state = TASK_RUNNING;\n  asm volatile(\"msr msp, %0\"::\"r\"(\n                 TASKS[running_task_id].sp));\n  restore_context();\n  asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFF9));\n  asm volatile(\"bx lr\");\n}\n```", "```cpp\nvoid task_test0(void *arg)\n{\n  uint32_t now = jiffies;\n  blue_led_on();\n  while(1) {\n    if ((jiffies - now) > 1000) {\n      blue_led_off();\n      schedule();\n      now = jiffies;\n      blue_led_on();\n    }\n  }\n}\nvoid task_test1(void *arg)\n{\n  uint32_t now = jiffies;\n  red_led_on();\n  while(1) {\n    if ((jiffies - now) > 1000) {\n      red_led_off();\n      schedule();\n      now = jiffies;\n      red_led_on();\n    }\n  }\n}\n```", "```cpp\nvoid task_test0(void *arg)\n{\n  uint32_t now = jiffies;\n  blue_led_on();\n  while(1) {\n    if ((jiffies - now) > 500) {\n      blue_led_toggle();\n      now = jiffies;\n    }\n  }\n}\nvoid task_test1(void *arg)\n{\n  uint32_t now = jiffies;\n  red_led_on();\n  while(1) {\n    if ((jiffies - now) > 125) {\n      red_led_toggle();\n      now = jiffies;\n    }\n  }\n}\n```", "```cpp\n#define TIMESLICE (20)\nvoid isr_systick(void)\n{\n  if ((++jiffies % TIMESLICE) == 0)\n  schedule();\n}\n```", "```cpp\nvoid task_test0(void *arg){\n  blue_led_on();\n  while(1) {\n    sleep_ms(500);\n    blue_led_toggle();\n  }\n}\nvoid task_test1(void *arg)\n{\n  red_led_on();\n  while(1) {\n    sleep_ms(125);\n    red_led_toggle();\n  }\n}\n```", "```cpp\nstruct task_block {\n  char name[TASK_NAME_MAXLEN];\n  int id;\n  int state;\n  void (*start)(void *arg);\n  void *arg;\n  uint8_t *sp;\n  uint32_t wakeup_time;\n  struct task_block *next;\n};\n```", "```cpp\nstruct task_block *tasklist_active = NULL;\nstruct task_block *tasklist_waiting = NULL;\nstatic void tasklist_add(struct task_block **list,struct task_block *el)\n{\n  el->next = *list;\n  *list = el;\n}\nstatic int tasklist_del(struct task_block **list, struct task_block *delme)\n{\n  struct task_block *t = *list;\n  struct task_block *p = NULL;\n  while (t) {\n    if (t == delme) {\n      if (p == NULL)\n        *list = t->next;\n      else\n        p->next = t->next;\n      return 0;\n    }\n    p = t;\n    t = t->next;\n  }\n  return -1;\n}\n```", "```cpp\nstatic void task_waiting(struct task_block *t)\n{\n  if (tasklist_del(&tasklist_active, t) == 0) {\n    tasklist_add(&tasklist_waiting, t);\n    t->state = TASK_WAITING;\n  }\n}\nstatic void task_ready(struct task_block *t)\n{\n  if (tasklist_del(&tasklist_waiting, t) == 0) {\n    tasklist_add(&tasklist_active, t);\n    t->state = TASK_READY;\n  }\n}\n```", "```cpp\nvoid sleep_ms(int ms)\n{\n  if (ms < TASK_TIMESLICE)\n    return;\n  t_cur->wakeup_time = jiffies + ms;\n  task_waiting(t_cur);\n  schedule();\n}\n```", "```cpp\nstatic inline struct task_block *tasklist_next_ready(struct task_block *t)\n{\n  if ((t->next == NULL) || (t->next->state != TASK_READY))\n    return tasklist_active;\n  return t->next;\n}\n```", "```cpp\nvoid __attribute__((naked)) isr_pendsv(void)\n{\n  store_context();\n  asm volatile(\"mrs %0, msp\" : \"=r\"(t_cur->sp));\n  if (t_cur->state == TASK_RUNNING) {\n    t_cur->state = TASK_READY;\n  }\n  t_cur = tasklist_next_ready(t_cur);\n  t_cur->state = TASK_RUNNING;\n  asm volatile(\"msr msp, %0\" ::\"r\"(t_cur->sp));\n  restore_context();\n  asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFF9));\n  asm volatile(\"bx lr\");\n}\n```", "```cpp\nvoid main(void) {\n  clock_pll_on(0);\n  led_setup();\n  button_setup();\n  systick_enable();\n  kernel.name[0] = 0;\n  kernel.id = 0;\n  kernel.state = TASK_RUNNING;\n  kernel.wakeup_time = 0;\n  tasklist_add(&tasklist_active, &kernel);\n  task_create(\"test0\",task_test0, NULL);\n  task_create(\"test1\",task_test1, NULL);\n  task_create(\"test2\",task_test2, NULL);\n  while(1) {\n    struct task_block *t = tasklist_waiting;\n    while (t) {\n      if (t->wakeup_time && (t->wakeup_time < jiffies)) {\n        t->wakeup_time = 0;\n        task_ready(t);\n      }\n      t = t->next;\n    }\n    WFI();\n  }\n}\n```", "```cpp\n#define BUTTON_DEBOUNCE_TIME 120\nvoid task_test2(void *arg)\n{\n  uint32_t toggle_time = 0;\n  green_led_off();\n  while(1) {\n    if (button_read()) {\n      if((jiffies - toggle_time) > BUTTON_DEBOUNCE_TIME)\n      {\n        green_led_toggle();\n        toggle_time = jiffies;\n      }\n    }\n  }\n}\n```", "```cpp\nstruct task_block *button_task = NULL;\nint button_read(void)\n{\n  if (button_task)\n    return 0;\n  button_task = t_cur;\n  task_waiting(t_cur);\n  button_start_read();\n  schedule();\n  return 1;\n}\n```", "```cpp\nstatic void (*button_callback)(void) = NULL;\nvoid button_setup(void (*callback)(void))\n{\n  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;\n  GPIOA_MODE &= ~ (0x03 << (BUTTON_PIN * 2));\n  EXTI_CR0 &= ~EXTI_CR_EXTI0_MASK;\n  button_callback = callback;\n}\n```", "```cpp\nvoid button_wakeup(void)\n{\n  if (button_task) {\n    task_ready(button_task);\n    button_task = NULL;\n    schedule();\n  }\n}\n```", "```cpp\nvoid button_start_read(void)\n{\n  EXTI_IMR |= (1 << BUTTON_PIN);\n  EXTI_EMR |= (1 << BUTTON_PIN);\n  EXTI_RTSR |= (1 << BUTTON_PIN);\n  nvic_irq_enable(NVIC_EXTI0_IRQN);\n}\n```", "```cpp\nvoid isr_exti0(void)\n{\n  nvic_irq_disable(NVIC_EXTI0_IRQN);\n  EXTI_PR |= (1 << BUTTON_PIN);\n  if (button_callback)\n    button_callback();\n}\n```", "```cpp\nstruct task_block {\n  char name[TASK_NAME_MAXLEN];\n  int id;\n  int state;\n  void (*start)(void *arg);\n  void *arg;\n  uint8_t *sp;\n  uint32_t wakeup_time;\n  uint8_t priority;\n  struct task_block *next;\n};\n```", "```cpp\nstatic void tasklist_add_active(struct task_block *el)\n{\n  tasklist_add(&tasklist_active[el->priority], el);\n}\nstatic int tasklist_del_active(struct task_block *el)\n{\n  return tasklist_del(&tasklist_active[el->priority], el);\n}\n```", "```cpp\nstatic void task_waiting(struct task_block *t)\n{\n  if (tasklist_del_active(t) == 0) {\n    tasklist_add(&tasklist_waiting, t);\n    t->state = TASK_WAITING;\n  }\n}\nstatic void task_ready(struct task_block *t)\n{\n  if (tasklist_del(&tasklist_waiting, t) == 0) {\n    tasklist_add_active(t);\n    t->state = TASK_READY;\n  }\n}\n```", "```cpp\nvoid main(void) {\n  clock_pll_on(0);\n  led_setup();\n  button_setup(button_wakeup);\n  systick_enable();\n  kernel.name[0] = 0;\n  kernel.id = 0;\n  kernel.state = TASK_RUNNING;\n  kernel.wakeup_time = 0;\n  kernel.priority = 0;\n  tasklist_add_active(&kernel);\n  task_create(\"test0\",task_test0, NULL, 1);\n  task_create(\"test1\",task_test1, NULL, 1);\n  task_create(\"test2\",task_test2, NULL, 3);\n  while(1) {\n    struct task_block *t = tasklist_waiting;\n    while (t) {\n      if (t->wakeup_time && (t->wakeup_time < jiffies)) {\n        t->wakeup_time = 0;\n        task_ready(t);\n      }\n      t = t->next;\n    }\n    WFI();\n  }\n}\n```", "```cpp\nstatic int idx;\nstatic inline struct task_block *\ntasklist_next_ready(struct task_block *t)\n{\n for (idx = MAX_PRIO - 1; idx >= 0; idx--) {\n    if ((idx == t->priority) && (t->next != NULL) &&\n        (t->next->state == TASK_READY))\n      return t->next;\n    if (tasklist_active[idx])\n      return tasklist_active[idx];\n  }\n  return t;\n}\n```", "```cpp\nsem_trywait:\n  LDREX r1, [r0]\n  CMP r1, #0\n  BEQ sem_trywait_fail\n  SUBS r1, #1\n  STREX r2, r1, [r0]\n  CMP r2, #0\n  BNE sem_trywait\n  DMB\n  MOVS r0, #0\n  BX lr\nsem_trywait_fail:\n  DMB\n  MOV r0, #-1\n  BX lr\n```", "```cpp\n.global sem_dopost\nsem_dopost:\n  LDREX r1, [r0]\n  ADDS r1, #1\n  STREX r2, r1, [r0]\n  CMP r2, #0\n  BNE sem_dopost\n  CMP r0, #1\n  DMB\n  BGE sem_signal_up\n  MOVS r0, #0\n  BX lr\nsem_signal_up:\n  MOVS r0, #1\n  BX lr\n```", "```cpp\n#define MAX_LISTENERS 4\nstruct semaphore {\n  uint32_t value;\n  uint8_t listeners[MAX_LISTENERS];\n};\ntypedef struct semaphore semaphore;\n```", "```cpp\nint sem_wait(semaphore *s)\n{\n  int i;\n  if (s == NULL)\n    return -1;\n  if (sem_trywait(s) == 0)\n    return 0;\n  for (i = 0; i < MAX_LISTENERS; i++) {\n    if (!s->listeners[i])\n      s->listeners[i] = t_cur->id;\n    if (s->listeners[i] == t_cur->id)\n      break;\n  }\n  task_waiting(t_cur);\n  schedule();\n  return sem_wait(s);}\n```", "```cpp\ntypedef semaphore mutex;\n#define mutex_init(m) sem_init(m, 1)\n#define mutex_trylock(m) sem_trywait(m)\n#define mutex_lock(x) sem_wait(x)\n#define mutex_unlock(x) sem_post(x)\n```", "```cpp\nstatic void __attribute__((naked)) store_user_context(void)\n{\n  asm volatile(\"mrs r0, psp\");\n  asm volatile(\"stmdb r0!, {r4-r11}\");\n  asm volatile(\"msr psp, r0\");\n  asm volatile(\"bx lr\");\n}\nstatic void __attribute__((naked)) restore_user_context(void)\n{\n  asm volatile(\"mrs r0, psp\");\n  asm volatile(\"ldmfd r0!, {r4-r11}\");\n  asm volatile(\"msr psp, r0\");\n  asm volatile(\"bx lr\");\n}\n```", "```cpp\nvoid __attribute__((naked)) isr_pendsv(void)\n{\n  if (t_cur->id == 0) {\n    store_kernel_context();\n    asm volatile(\"mrs %0, msp\" : \"=r\"(t_cur->sp));\n  } else {\n    store_user_context();\n    asm volatile(\"mrs %0, psp\" : \"=r\"(t_cur->sp));\n  }\n  if (t_cur->state == TASK_RUNNING) {\n    t_cur->state = TASK_READY;\n  }\n  t_cur = tasklist_next_ready(t_cur);\n  t_cur->state = TASK_RUNNING;\n  if (t_cur->id == 0) {\n    asm volatile(\"msr msp, %0\" ::\"r\"(t_cur->sp));\n    restore_kernel_context();\n    asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFF9));\n    asm volatile(\"msr CONTROL, %0\" ::\"r\"(0x00));\n  } else {\n    asm volatile(\"msr psp, %0\" ::\"r\"(t_cur->sp));\n    restore_user_context();\n    asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFFD));\n    asm volatile(\"msr CONTROL, %0\" ::\"r\"(0x01));\n  }\n  asm volatile(\"bx lr\");\n}\n```", "```cpp\n#define RASR_KERNEL_RW (1 << 24)\n#define RASR_KERNEL_RO (5 << 24)\n#define RASR_RDONLY (6 << 24)\n#define RASR_NOACCESS (0 << 24)\n#define RASR_USER_RW (3 << 24)\n#define RASR_USER_RO (2 << 24)\n```", "```cpp\nint mpu_enable(void)\n{\n  volatile uint32_t type;\n  volatile uint32_t start;\n  volatile uint32_t attr;\n  type = MPU_TYPE;\n  if (type == 0)\n    return -1;\n  MPU_CTRL = 0;\n  start = 0;\n  attr = RASR_ENABLED | MPUSIZE_256K | RASR_SCB | \n         RASR_RDONLY;\n  mpu_set_region(0, start, attr);\n  start = 0x20000000;\n  attr = RASR_ENABLED | MPUSIZE_128K | RASR_SCB |         RASR_USER_RW | RASR_NOEXEC;\n  mpu_set_region(1, start, attr);\n```", "```cpp\n  start = 0x10000000;\n  attr = RASR_ENABLED | MPUSIZE_64K | RASR_SCB |\n         RASR_KERNEL_RW | RASR_NOEXEC;\n  mpu_set_region(2, start, attr);\n```", "```cpp\n  start = 0x40000000;\n  attr = RASR_ENABLED | MPUSIZE_1G | RASR_SB |\n         RASR_KERNEL_RW | RASR_NOEXEC;\n  mpu_set_region(4, start, attr);\n  start = 0xE0000000;\n  attr = RASR_ENABLED | MPUSIZE_256M | RASR_SB |\n         RASR_KERNEL_RW | RASR_NOEXEC;\n  mpu_set_region(5, start, attr);\n  SHCSR |= MEMFAULT_ENABLE;\n  MPU_CTRL = 1;\n  return 0;\n}\n```", "```cpp\nvoid mpu_task_stack_permit(void *start)\n{\n  uint32_t attr = RASR_ENABLED | MPUSIZE_1K |\n           RASR_SCB | RASR_USER_RW;\n  MPU_CTRL = 0;\n  DMB();\n  mpu_set_region(3, (uint32_t)start, attr);\n  MPU_CTRL = 1;\n}\n```", "```cpp\n#define SVC() asm volatile (\"svc 0\")\n```", "```cpp\nstatic int syscall(int arg0)\n{\n  SVC();\n}\n```", "```cpp\n#define SYS_SCHEDULE 0\n#define SYS_BUTTON_READ 1\n#define SYS_BLUELED_ON 2\n#define SYS_BLUELED_OFF 3\n#define SYS_BLUELED_TOGGLE 4\n#define SYS_REDLED_ON 5\n#define SYS_REDLED_OFF 6\n#define SYS_REDLED_TOGGLE 7\n#define SYS_GREENLED_ON 8\n#define SYS_GREENLED_OFF 9\n#define SYS_GREENLED_TOGGLE 10\n```", "```cpp\nvoid __attribute__((naked)) isr_svc(int arg)\n{\n   store_user_context();\n   asm volatile(\"mrs %0, psp\" : \"=r\"(t_cur->sp));\n   if (t_cur->state == TASK_RUNNING) {\n       t_cur->state = TASK_READY;\n   }\n   switch(arg) {\n    case SYS_BUTTON_READ: /* cmd to read button value */\n       button_start_read();\n       break;\n    case SYS_SCHEDULE: /* cmd to schedule the next task */\n       t_cur = tasklist_next_ready(t_cur);\n       t_cur->state = TASK_RUNNING;\n       break;\n    case SYS_BLUELED_ON: /* cmd to turn on blue LED */\n       blue_led_on();\n       break;\n    /* case ... (more LED related cmds follow) */\n}\n```", "```cpp\n   if (t_cur->id == 0) {\n       asm volatile(\"msr msp, %0\" ::\"r\"(t_cur->sp));\n       restore_kernel_context();\n       asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFF9));\n       asm volatile(\"msr CONTROL, %0\" ::\"r\"(0x00));\n   } else {\n       asm volatile(\"msr psp, %0\" ::\"r\"(t_cur->sp));\n       restore_user_context();\n       mpu_task_stack_permit(((uint8_t *)((&stack_space))\n            +(t_cur->id << 10)));            asm volatile(\"mov lr, %0\" ::\"r\"(0xFFFFFFFD));\n       asm volatile(\"msr CONTROL, %0\" ::\"r\"(0x01));\n   }\n   asm volatile(\"bx lr\");}\n```", "```cpp\nvoid task_test0(void *arg)\n{\n  while(1) {\n    syscall(SYS_BLUELED_ON);\n    mutex_lock(&m);\n    sleep_ms(500);\n    syscall(SYS_BLUELED_OFF);\n    mutex_unlock(&m);\n    sleep_ms(1000);\n  }\n}\nvoid task_test1(void *arg)\n{\n  syscall(SYS_REDLED_ON);\n  while(1) {\n    sleep_ms(50);\n    mutex_lock(&m);\n    syscall(SYS_REDLED_TOGGLE);\n    mutex_unlock(&m);\n  }\n}\nvoid task_test2(void *arg)\n{\n  uint32_t toggle_time = 0;\n  syscall(SYS_GREENLED_OFF);\n  while(1) {\n    button_read();\n    if ((jiffies - toggle_time) > 120) {\n      syscall(SYS_GREENLED_TOGGLE);\n      toggle_time = jiffies;\n    }\n  }\n}\n```", "```cpp\nxTaskCreate(task_entry_fn, \"TaskName\", task_stack_size,\n      ( void * ) custom_params, priority, task_handle);\n```", "```cpp\n    vTaskStartScheduler();\n```", "```cpp\n thread_create(task_stack_mem, task_stack_size, priority, \n     flags, task_entry_fn, (void*)custom_args, \"TaskName\");\n```"]