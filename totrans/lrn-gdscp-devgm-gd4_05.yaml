- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How and Why to Keep Your Code Clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapters 1* to *4*, we learned all the basics of programming and are about
    to dive deep into developing our very own game.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do so, we must realize that the code base for games can grow very
    large. This means that the code and systems we write one day can be buried under
    other code and systems. As a result, returning to our earlier work can be a hassle
    because we forget how or why we coded certain things in a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: That is why now is the ideal moment to stand still and think about how to keep
    our code clean and understandable even months after writing it. Most of the things
    in this chapter were learned through making mistakes myself and having to find
    a solution in books and articles.
  prefs: []
  type: TYPE_NORMAL
- en: Although most of the tips can feel like critical thinking and will bring you
    to the same point (which they probably will), it always helps to voice them and
    explain why programmers employ them.
  prefs: []
  type: TYPE_NORMAL
- en: Holding them in the back of your mind while programming will give you a big
    step up from other starting programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming things (again)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing good functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use private variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t repeat yourself (DRY)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defensive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding style guides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the `chapter05` folder in the repository of code examples if you
    get stuck anywhere. You can find the repository here: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter05](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Back to naming things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s have another look at how to name variables, functions, and classes. Picking
    the right name for any of these is very important as it will make understanding
    the code way easier.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in *Chapters 3* and *4*, variable, function, and class names have
    different constraints. We used specific rules to name each. These ways are called
    **naming conventions**. They give a term to how we want to constrain the formation
    of names. The three main naming conventions that are recommended in the GDScript
    style guide are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`player_health`, `movement_speed`, and `weekly_highscore`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUTTON_SIZE`, `PI`, and `TEAM_A_COLOR`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackgroundColor`, `PlayerWeapon`, and `GameStartTimer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a bunch of other, more exotic conventions, like the following: **kebab-case**,
    **camelCase**, **flatcase**, and so on. But these are not used in GDScript.'
  prefs: []
  type: TYPE_NORMAL
- en: General naming tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let me be clear: naming things is not easy. It is, in fact, one of the
    hardest things in programming. So, if you have the naming right, you’ll always
    be able to return to any code quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are some tips to make you a naming master.
  prefs: []
  type: TYPE_NORMAL
- en: Use meaningful and descriptive names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the early days, programmers had to work with computers that didn’t have a
    lot of computational power and memory, and they also prided themselves in creating
    the shortest script to solve a problem. This resulted in code where variables
    were given one or two-letter names such as `a` or `c5`. Optimizing a piece of
    code to be as short as possible is very satisfying. However, these pieces of code
    are very incomprehensible. Even the person who wrote the script is not able to
    read it anymore after some time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: That is why descriptive variable names are a big plus. Sure, they take a few
    extra seconds to type out, but that is nothing compared to spending minutes or
    even hours figuring out why a variable exists and how it should be used; and,
    anyway, autocomplete will always help us out.
  prefs: []
  type: TYPE_NORMAL
- en: Some people even go as far as to say that short variable names result in a better-performing
    game. This is not true at all. A programming language will tokenize the variables
    in the code, making any variable name perform equally fast, no matter how long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is making a variable’s, method’s, or class’s name meaningful and
    descriptive. To do this, you can ask yourself these questions for the different
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of data will the variable contain?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How should this data be used?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the function do?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What data does the function return?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of parameters does the function require to work?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will the class be used for?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What data is the class responsible for?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these questions will guide your decision making while coming up with names
    for variables, functions, and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid filler words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although long descriptive names are the way to go, we also don’t want to obscure
    the name with filler or unnecessary words such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such words just bog down the name and make it unnecessarily long while providing
    no extra meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Keep names pronounceable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good code should be easily readable. This means that you should be able to read
    it like a book and it should make sense without you having to look at the content
    of the function or the data type of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that we should keep names pronounceable. Use complete words
    or very common abbreviations if we decide to abbreviate one.
  prefs: []
  type: TYPE_NORMAL
- en: Be consistent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, for the most important tip: be consistent in your naming. This way, you
    can count on your own style of naming and make assumptions about the variables,
    functions, and classes you write. If you break any of the rules, at least break
    them consistently, and don’t just do something different every time.'
  prefs: []
  type: TYPE_NORMAL
- en: Public and private class members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19358_04.xhtml#_idTextAnchor164), we learned that **abstraction**
    and **encapsulation** are two key components of **object-oriented programming**.
    This means that code outside of a class should not need to worry about how that
    class gets results. For all the outside world is concerned, it could be magic
    or, even worse, manual labor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To signify that a particular variable or method is meant for internal use by
    the class alone, GDScript took over the convention popularized in Python: putting
    an underscore before the name of that variable or function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The auto-complete still suggests private variables](img/B19358_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The auto-complete still suggests private variables
  prefs: []
  type: TYPE_NORMAL
- en: However, as shown in *Figure 5**.1*, you’ll notice that the auto-complete still
    suggests private class members. It is still very important to indicate which members
    of the class are private and should not be accessed. This will help you or any
    other programmer coming after you by using the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Make short functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more a function tries to do, the more code there is within that function
    and the harder it is to understand what it is doing. So, to keep functions easily
    understandable, a great rule of thumb is to keep the number of lines under 20\.
    This lets you quickly understand what is happening and how to use the function
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can call different functions. Splitting long functions into multiple
    smaller ones with a good descriptive name will save you many hours of figuring
    out what code does.
  prefs: []
  type: TYPE_NORMAL
- en: DRY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two acronyms that almost every programming student will have heard
    of. The first is DRY. This acronym urges us to write a piece of code only once
    and then reuse it as much as possible. If we create small, generic functions,
    we can prevent copy-pasting the same few lines over our whole code base.
  prefs: []
  type: TYPE_NORMAL
- en: But I should also warn you not to overdo it. Sometimes, it is okay to have a
    little bit of duplicate code that is better tailored to a particular scenario
    than to hack multiple scenarios into one piece of code. Use your best judgment.
  prefs: []
  type: TYPE_NORMAL
- en: Do one thing (KISS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second acronym everyone knows about is **KISS**, which stands for **keep
    it simple, stupid**. This could be interpreted in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the solution to the bare minimum, which means you don’t solve problems
    that do not exist yet. This way, you don’t develop features that are not needed
    and don’t spend time creating something nobody will use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t make your code complex. Complex code is notoriously hard to maintain and
    understand. That is why it’s better to keep any solution simple, so you always
    know what is happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple code is always easier to read, comprehend, and maintain. So, keep it
    simple, stupid!
  prefs: []
  type: TYPE_NORMAL
- en: Defensive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last principle I want to show you is **defensive programming**. In this
    paradigm, you try to play it safe by checking as many things and edge cases in
    code as possible. In a function, for example, you can check at the start of the
    function whether the parameters are correct. This way, you will prevent a lot
    of crashes in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a function that should return the item within an inventory
    at a certain index, you could write it non-defensively and defensively like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second version of the function is defensive because it checks first if the
    index of the item we want is within the range of the inventory. We do this because
    if the index is outside of this range, we crash the game.
  prefs: []
  type: TYPE_NORMAL
- en: Programming style guides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, I would like to go over what programming style guides are. These are
    guides that tell you how to structure your code. These guides never say anything
    about the content of the code but more about how to style it.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare these guides to the style of this book. I could put all the
    sentences in one long line without styling, headers, or images. But in the end,
    this would make the content very hard to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Next to making code more readable, these style guides also get whole teams of
    coders on one line, so each person’s code looks more alike and people don’t have
    to keep switching between different coding styles when trying to comprehend the
    code base of a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most companies have their internal style guide, and yes, there is an official
    GDScript style guide! You can read it over here: [https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_styleguide.html](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_styleguide.html).'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t recommend you read the whole thing and try to apply it all at once.
    Instead, you could read some snippets here and there and once you have those guidelines
    down, read some more and try to fit these in your own coding style.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get mistaken. Even with these style guides, there is still room for a
    personal touch while coding. These guides will just be within a framework that
    makes your code nicer and easier to understand for other programmers working within
    the same programming language and framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of this chapter, I would like to review some of the tips from
    the official GDScript style guide. Namely, the following few:'
  prefs: []
  type: TYPE_NORMAL
- en: White spacing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blank lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let’s dive right into these style recommendations of the Godot Engine developers
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: White spacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Except for indentation, which we discussed in [*Chapter 2*](B19358_02.xhtml#_idTextAnchor044),
    GDScript doesn’t care about white space within lines of code. The next two lines
    are functionally the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the second line is way more readable for humans because each part has
    room to breathe. That is why it’s essential to always use a space between numbers,
    function calls, and operators. This way, a line doesn’t just become a jumble of
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In arrays, we also want to add a space between elements to clearly show that
    each is a separate entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite can also be true. Inserting unnecessary spaces could obscure certain
    operators, for example, accessing a key in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, it is more apparent that the square brackets are there
    to access a key from the dictionary and not to define an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two other examples where no space shows a clear relation between the elements
    are the function name and its parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can see this when accessing a member variable or function from an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In general, it is very important to use white space within a line of code to
    show when things are separate entities or belong together. This will improve readability
    tremendously.
  prefs: []
  type: TYPE_NORMAL
- en: Blank lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other kind of white space we can use to make code more readable is blank
    lines. A blank line is simply a line that contains nothing. The style guide suggests
    using two blank lines to separate functions and class definitions. This way, it
    is clear which pieces of text belong together as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to separating functions and classes with two blank lines, the guide
    advises us to use one blank line to separate lines of code that are logically
    grouped. For example, if we have code that calculates the damage from an attack
    and then applies that damage to all enemies, we can nicely group this logic into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the total damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the damage to all enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will see me sin against the blank lines guide rules here and there throughout
    the book. I do this mainly to make the code more compact to fit the pages, but
    that doesn’t make the rule less important!
  prefs: []
  type: TYPE_NORMAL
- en: Line length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days, computer monitors were tiny. They often couldn’t hold more
    than 70 to 90 characters in one line of text before it scrolled off the end or
    wrapped around. That is why code was best written in lines with, at most, this
    length. Nowadays, my ultra-wide computer monitor can hold over 500 characters
    on one line without a problem. Well, not a technical problem anyway. Working with
    text this wide makes it very hard to read for humans!
  prefs: []
  type: TYPE_NORMAL
- en: This is why people still restrict their line lengths while programming, to keep
    everything nice and easy to read. While, of course, not everyone agrees on the
    perfect line length, the GDScript defaults are 80 characters as a soft limit and
    `100` as a hard limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is advised to keep your lines under this amount of characters. If you do
    run into them, you can always subdivide your line by storing intermediate results
    in separate variables. For example, the next snippet of code checks if the player’s
    health is between `0` and `100` and whether the player has a potion in their inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not technically too long, but to show how we can lower the line length
    and even make the condition in the `if` statement more readable, let’s rewrite
    this snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are no extra-long lines now and the `if` statement is
    way more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is hard to anticipate how the built-in classes, functions, or
    variables of the Godot Engine work. Luckily, the engine has great documentation
    that explains everything in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a class’s documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can always access the documentation of any internal class by simply using
    *Ctrl* + clicking on the name of the class. This will take you to the specific
    documentation page of that class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Ctrl + clicking on an internal class name, such as the Array
    class](img/B19358_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Ctrl + clicking on an internal class name, such as the Array class
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 5**.3*, the documentation page starts with a simple description
    of what the class is used for and sometimes this part gives usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The documentation page for the Array class](img/B19358_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The documentation page for the Array class
  prefs: []
  type: TYPE_NORMAL
- en: Then follows an overview of the class’s member functions, variables, signals,
    and operators. We’ll see more about signals in [*Chapter 9*](B19358_09.xhtml#_idTextAnchor590).
    Note that you can easily click on the function or variable names to directly go
    to their explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that functions can also be called methods and variables can be called
    properties. This is because functions bound to a class are called methods and
    variables bound to a class properties.
  prefs: []
  type: TYPE_NORMAL
- en: After the overview section, there is a detailed description of each function
    and variable. For the functions, we get an explanation of what the function does,
    what parameters the function takes, and what data type gets returned.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The documentation section for a function](img/B19358_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The documentation section for a function
  prefs: []
  type: TYPE_NORMAL
- en: For variables, we also get a description of what this variable is used for and
    what data type the value should be.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The documentation section for a variable](img/B19358_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The documentation section for a variable
  prefs: []
  type: TYPE_NORMAL
- en: This way of accessing the documentation works very well if we want to get a
    general feel for what a class does.
  prefs: []
  type: TYPE_NORMAL
- en: Directly accessing a function or variable’s documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To directly go to the documentation of a function or variable, you just have
    to press *Ctrl* + click that function or variable and you’ll go directly to the
    relevant section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Holding Ctrl + clicking on a function or variable will bring
    you to the right section in the documentation directly](img/B19358_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Holding Ctrl + clicking on a function or variable will bring you
    to the right section in the documentation directly
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the link, we directly get to the section from *Figure 5**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: Going to the definition of a function or variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This shortcut also works with our own code: if you hold *Ctrl* + click on Windows
    or Linux or *option* + click on Mac a function or variable that we defined somewhere,
    the editor will show where this function or variable was defined in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, try using this shortcut on the different functions we defined
    on the `Enemy` classes we created in [*Chapter 4*](B19358_04.xhtml#_idTextAnchor164).
  prefs: []
  type: TYPE_NORMAL
- en: Searching the documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also search all the classes, functions, and variables. Simply follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Press *F1* and a search bar will pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in any class, function, or variable you want to search for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the right search result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result is shown in *Figure 5**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – You can also search all the documentation by pressing F11 on
    your keyboard](img/B19358_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – You can also search all the documentation by pressing F11 on your
    keyboard
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easy to find the right section in the documentation if you are
    not able to hold *Ctrl + click* on Windows and Linux or press *Option + click*
    on Mac, on a class, function, or variable within your code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the online documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of this documentation is also hosted online. There are some pages and tutorials
    on the online version that you cannot access in the offline one. It’s also easier
    to open up multiple pages of documentation on the online version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just navigate to: [https://docs.godotengine.org/](https://docs.godotengine.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The online documentation](img/B19358_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The online documentation
  prefs: []
  type: TYPE_NORMAL
- en: In the menu bar on the left, you can see all the different articles available
    and navigate to sections that interest you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There we go! Throughout *Part 1* of the book, we learned how to program and
    we topped it off with some extra tips on becoming a good programmer during this
    chapter. Remember, no tips in this chapter are chiseled in stone or enforced by
    the engine. So, you can break them where needed. But they are here for your own
    good and many programmers have adopted them as daily practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is also at the beginning of the next part of the
    book, we will finally start working on our game! I hope you are as excited as
    I am!
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the three naming conventions used in the Godot Engine and GDScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the following functions been named well?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculateLifePoints()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop_moving()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do_a_thing()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawcircles()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the following classes been named well?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal_enemy`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOTORCYCLE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What do the acronyms DRY and KISS stand for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Making a Game in Godot Engine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the fundamentals of programming under our belt, we will finally start working
    on our very own game from scratch. In this part, we’ll learn all about Godot Engine’s
    flexible node-based system and create a *Vampire* *Survivors*-like game.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, you will have created a whole game using different
    nodes and game development techniques. You will even be able to play the game
    with your friends, because we will end this part with a chapter on making the
    game multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19358_06.xhtml#_idTextAnchor411), *Creating a World of Your
    Own in Godot*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19358_07.xhtml#_idTextAnchor523), *Making the Character Move*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19358_08.xhtml#_idTextAnchor573), *Splitting and Reusing Scenes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19358_09.xhtml#_idTextAnchor590), *Cameras, Collisions, and
    Collectibles*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19358_10.xhtml#_idTextAnchor632), *Creating Menus, Making Enemies,
    and Using Autoloads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19358_11.xhtml#_idTextAnchor660), *Playing Together with Multiplayer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
