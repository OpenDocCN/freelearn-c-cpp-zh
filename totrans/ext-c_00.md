# 前言

在这个现代时代，我们经常目睹令人惊叹的技术，并体验到远超几十年前想象的奢华与愉悦。我们发现自动驾驶汽车正逐渐成为我们街道上的现实。物理学和其他科学分支的进步正在改变我们感知现实本身的方式。我们阅读关于研究人员在量子计算领域迈出第一步的新闻，有关区块链技术和加密货币的传闻，以及殖民其他星球的计划。难以置信的是，如此多样化的突破仅源于少数几个核心技术。这本书就是关于这些技术之一：C。

我在高中的第一年就开始用 C++编程。在那里，我加入了一个面向青少年的 2D 足球模拟团队。不久之后，我就接触到了 Linux 和 C。我必须承认，在那些年里，我对 C 和 Unix 的重要性知之甚少，但随着时间的推移，通过在各种项目中使用它们获得更多经验，以及通过我的教育了解它们，我开始看到它们的关键作用和地位。我对 C 了解得越多，我对它的尊重就越大。最终，我决定成为这个吸引我兴趣的编程语言的专家。我还决定成为传播知识和让人们意识到 C 重要性的倡导者。这本书就是那个雄心的结果。

尽管存在 C 是一种已死语言的错误观念，以及技术人士对 C 的一般无知，但可以在[`www.tiobe.com/tiobe-index`](https://www.tiobe.com/tiobe-index/c)找到的 TIOBE 指数表明了相反的情况。事实上，C 在过去 15 年中是最受欢迎的编程语言之一，与 Java 并列，并且在近年来获得了更多的流行度。

我在多年的使用 C、C++、Golang、Java 和 Python 进行开发和设计经验的基础上来到这本书。本书的主要目的是提高读者的技能水平；使他们能够在使用 C 方面迈出下一步，并以经过艰苦努力获得的经验来实际应用。对我们来说，这不会是一次轻松的旅程，这就是为什么我们称这本书为《极端 C》。这本书的核心关注点是这次旅程，我们不会进入 C 与其他编程语言的辩论。本书试图保持实用性，但仍然不得不处理大量与实际应用相关的核心理论。本书充满了旨在帮助你应对真实系统中会遇到的问题的例子。

能够就如此重要的主题发表演讲确实是一种巨大的荣幸。言语无法表达，所以我只能说，有机会撰写一个如此贴近我心的话题是一种难以置信的喜悦。这一切的乐趣和惊讶都归功于 Andrew Waldron，他让我有机会承担这本书，这是我写作生涯的第一次尝试。

作为其中的一部分，我想向我的特别尊敬和最好的感谢对象 Ian Hough，这位发展编辑，他在这一旅程中与我一起逐章前行，感谢 Aliakbar Abbasi 不辞辛劳的同行评审反馈，以及感谢 Kishor Rit、Gaurav Gavas、Veronica Pais 和许多其他为准备和出版本书付出最大努力的宝贵人士。

话虽如此，我邀请您成为我在这漫长旅程中的同伴。我希望这本书的阅读能够证明是具有变革性的，帮助您以新的视角看待 C 语言，并在这一过程中成为一名更好的程序员。

# 本书面向对象

本书是为那些对 C 和 C++开发有一定了解的读者所写。初级和中级 C/C++工程师是本书的主要受众，他们可以从本书中获得最大收益，并利用他们的专业知识和技能。希望阅读本书后，他们能够在职位上获得提升，成为高级工程师。此外，阅读本书后，他们的专业知识将更好地匹配更多具有挑战性和通常薪酬较高的相关职位。一些主题对高级 C/C++工程师也可能有用，但预计大多数主题他们已经了解，只有一些额外的细节可能仍然有用。

另一个可以从阅读本书中受益的受众是学生和研究人员。任何科学或工程领域（如计算机科学、软件工程、人工智能、**物联网**（**IoT**）、天文学、粒子物理学和宇宙学）的学士、硕士或博士研究生，以及这些领域的所有研究人员，都可以使用本书来提高他们对 C/C++、类 Unix 操作系统和相关编程技能的了解水平。对于从事复杂、多线程或甚至多进程系统（如远程设备控制、模拟、大数据处理、机器学习、深度学习等）的工程师和科学家来说，本书将是一个很好的选择。

# 本书涵盖的内容

本书分为 7 个部分。在这 7 个部分中，我们涵盖了 C 编程的一些特定方面。第一部分专注于如何构建 C 项目，第二部分关注内存，第三部分关注面向对象，第四部分主要探讨 Unix 及其与 C 的关系。第五部分讨论并发，第六部分涵盖进程间通信，最后，本书的第七部分是关于测试和维护。以下是本书中包含的 23 个章节的摘要。

*第一章*，*基本特性*：本章讲述了 C 中的一些基本特性，这些特性对我们使用 C 的方式产生了深远的影响。在本书的整个过程中，我们将经常使用这些特性。主要内容包括预处理和定义宏、变量和函数指针、函数调用机制以及结构。

*第二章*，*编译和链接*：在本章中，我们讨论了如何构建 C 项目。我们详细研究了编译管道，包括整个管道以及各个管道组件。

*第三章*，*目标文件*：本章在通过编译管道构建 C 项目后，探讨了其产物。我们介绍了目标文件及其各种类型。我们还深入研究了这些目标文件，看看可以从中提取哪些信息。

*第四章*，*进程内存结构*：在本章中，我们探讨了进程的内存布局。我们看到了在这个内存布局中可以找到哪些段，以及静态和动态内存布局的含义。

*第五章*，*栈和堆*：在本章中，我们专门讨论了栈和堆段。我们讨论了栈和堆变量以及它们在 C 中的生命周期管理。我们还讨论了有关堆变量的最佳实践以及它们应该如何管理的相关内容。

*第六章*，*面向对象编程和封装*：这是关于 C 中面向对象编程的四章中的第一章。在本章中，我们探讨了面向对象的理论，并给出了文献中常用术语的重要定义。

*第七章*，*组合和聚合*：本章专注于组合及其特殊形式：聚合。我们讨论了组合和聚合之间的区别，并举例说明这些区别。

*第八章*，*继承和多态*：继承是面向对象编程（OOP）中最重要的话题之一。在本章中，我们展示了如何建立两个类之间的继承关系，以及如何在 C 中实现它。多态也是本章讨论的另一个重要话题。

*第九章*，*C++中的抽象和面向对象编程*：作为本书第三部分的最后一章，我们讨论了抽象。我们讨论了抽象数据类型以及如何在 C 中实现它们。我们还讨论了 C++的内部结构，并展示了面向对象的概念是如何在 C++中实现的。

*第十章*，*Unix – 历史 和 架构*：在谈论 C 时，不能忘记 Unix。在本章中，我们描述了它们之间为何紧密相连，以及 Unix 和 C 是如何相互帮助至今仍能存活的。Unix 的架构也得到了研究，我们看到了程序是如何使用操作系统暴露的功能的。

*第十一章*，*系统调用和内核*：在本章中，我们关注 Unix 架构中的内核环。我们更详细地讨论了系统调用，并为 Linux 添加了一个新的系统调用。我们还讨论了各种类型的内核，并编写了一个新的简单内核模块来演示内核模块的工作原理。

*第十二章*，*最新的 C 标准*：作为本章的一部分，我们审视了最新的 C 标准版本，C18。我们探讨了它与之前版本 C11 的不同之处，并展示了与 C99 相比新增的一些特性。

*第十三章*，*并发*：这是本书第五部分的第一章，关于并发。本章主要讨论并发环境和它们的各种属性，如交错。我们解释了为什么这些系统是非确定性的，以及这种属性如何导致并发问题，如竞争条件。

*第十四章*，*同步*：在本章中，我们继续讨论并发环境，并讨论在并发系统中可能观察到的各种问题。竞争条件、数据竞争和死锁是我们讨论的问题之一。我们还讨论了可以用来克服这些问题的技术。本章讨论了信号量、互斥锁和条件变量。

*第十五章*，*线程执行*：作为本章的一部分，我们演示了如何执行多个线程以及如何管理它们。我们还提供了关于前一章讨论的并发问题的真实 C 语言示例。

*第十六章*，*线程同步*：在本章中，我们探讨了可以用来同步多个线程的技术。信号量、互斥锁和条件变量是本章讨论和演示的显著主题之一。

*第十七章*，*进程执行*：本章讨论了创建或生成新进程的方法。我们还讨论了在多个进程之间共享状态的基于推和基于拉的技巧。我们还使用真实的 C 语言示例演示了在第十四章*同步*中讨论的并发问题。

*第十八章*，*进程同步*：本章主要处理位于同一台机器上的多个进程的同步机制。进程共享信号量、进程共享互斥锁和进程共享条件变量是本章讨论的技术之一。

*第十九章*，*单主机 IPC 和套接字*：在本章中，我们主要讨论基于推的**进程间通信**（IPC）技术。我们的重点是位于同一台机器上的进程可用的技术。我们还介绍了套接字编程，以及在网络中不同节点上的进程之间建立通道所需的相关背景知识。

**第二十章**，**套接字编程**：作为本章的一部分，我们通过代码示例讨论套接字编程。我们通过提出一个将支持各种类型套接字示例来驱动我们的讨论。讨论了在流或数据报通道上运行的 Unix 域套接字、TCP 和 UDP 套接字。

**第二十一章**，**与其他语言的集成**：在本章中，我们演示了如何将作为共享对象文件构建的 C 库加载并用于用 C++、Java、Python 和 Golang 编写的程序。

**第二十二章**，**单元测试和调试**：本章专门用于测试和调试。在测试部分，我们解释了各种测试级别，但我们专注于 C 中的单元测试。我们还介绍了 CMocka 和 Google Test 作为两个可用于编写 C 测试套件的库。在调试部分，我们介绍了可用于调试不同类型错误的多种工具。

**第二十三章**，**构建系统**：在本书的最后一章，我们讨论了构建系统和构建脚本生成器。Make、Ninja 和 Bazel 是我们在本章中解释的构建系统。CMake 也是我们本章中讨论的唯一构建脚本生成器。

# 为了充分利用本书

正如我们之前所解释的，这本书要求你具备一定的计算机编程知识和技能。最低要求如下：

+   计算机体系结构基础知识：你应该了解内存、CPU、外围设备及其特性，以及程序如何在计算机系统中与这些元素交互。

+   编程基础知识：你应该知道什么是算法，其执行过程如何追踪，什么是源代码，什么是二进制数，以及它们相关的算术运算如何进行。

+   熟悉在类似 Linux 或 macOS 的 Unix-like 操作系统中使用*终端*和基本*shell 命令*。

+   关于编程主题（如条件语句、不同类型的循环、至少一种编程语言中的结构或类、C 或 C++中的指针、函数等）的中级知识。

+   面向对象编程的基本知识：这不是强制性的，因为我们将详细解释 OOP，但它可以帮助你在阅读本书第三部分“面向对象”的章节时更好地理解。 

此外，强烈建议下载代码仓库并遵循 shell 框中给出的命令。请使用已安装 Linux 或 macOS 的平台。其他符合 POSIX 标准的操作系统也可以使用。

## 下载示例代码文件

你可以从[www.packt.com/](http://www.packt.com/)上的账户下载本书的示例代码文件。如果你在其他地方购买了这本书，你可以访问[www.packtpub.com/support](https://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。

你可以通过以下步骤下载代码文件：

1.  在[`www.packt.com`](http://www.packt.com)登录或注册。

1.  选择**支持**选项卡。

1.  点击**代码下载**。

1.  在**搜索**框中输入书籍名称，并遵循屏幕上的说明。

文件下载完成后，请确保使用最新版本的软件解压缩或提取文件夹：

+   适用于 Windows 的 WinRAR / 7-Zip

+   适用于 Mac 的 Zipeg / iZip / UnRarX

+   适用于 Linux 的 7-Zip / PeaZip

本书代码包也托管在 GitHub 上：[`github.com/PacktPublishing/Extreme-C`](https://github.com/PacktPublishing/Extreme-C)。如果代码有更新，它将在现有的 GitHub 仓库中更新。

我们还有其他丰富的图书和视频的代码包可供使用，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们吧！

## 使用的约定

在本书中，我们使用了代码框和 Shell 框。代码框包含一段 C 代码或伪代码。如果代码框的内容来自代码文件，则代码文件名将显示在框的下方。下面是一个代码框的示例：

```cpp
#include <stdio.h>
#include <unistd.h>
int main(int argc, char** argv) {
  printf("This is the parent process with process ID: %d\n",
          getpid());
  printf("Before calling fork() ...\n");
  pid_t ret = fork();
  if (ret) {
    printf("The child process is spawned with PID: %d\n", ret);
  } else {
    printf("This is the child process with PID: %d\n", getpid());
  }
  printf("Type CTRL+C to exit ...\n");
  while (1);
  return 0;
}
```

代码框 17-1 [ExtremeC_examples_chapter17_1.c]：使用 fork API 创建子进程

如您所见，上述代码可以在`ExtremeC_examples_chapter17_1.c`文件中找到，它是本书代码包的一部分，位于*第十七章，进程执行*目录中。您可以从 GitHub 获取代码包：[`github.com/PacktPublishing/Extreme-C`](https://github.com/PacktPublishing/Extreme-C)。

如果代码框没有关联的文件名，则它包含伪代码或无法在代码包中找到的 C 代码。以下是一个示例：

```cpp
Task P {
    1\. num = 5
    2\. num++
    3\. num = num – 2
    4\. x = 10
    5\. num = num + x
}
```

代码框 13-1：一个包含 5 条指令的简单任务

有时在代码框中可能会显示一些粗体字行的内容。这些通常是代码框前后讨论的代码行。它们以粗体字显示，以便您更容易找到它们。

Shell 框用于显示在运行多个 shell 命令时终端的输出。命令通常以粗体字显示，输出以正常字体显示。以下是一个示例：

```cpp
$ ls /dev/shm
shm0
$ gcc ExtremeC_examples_chapter17_5.c -lrt -o ex17_5.out
$ ./ex17_5.out
Shared memory is opened with fd: 3
The contents of the shared memory object: ABC
$ ls /dev/shm
$
```

Shell Box 17-6：从示例 17.4 中创建的共享内存对象中读取，最后将其删除

命令以`$`或`#`开头。以`$`开头的命令应以普通用户身份运行，而以`#`开头的命令应以超级用户身份运行。

Shell 框的工作目录通常是代码包中找到的章节目录。在需要选择特定目录作为工作目录的情况下，我们将提供必要的信息。

**粗体**：表示新术语、重要词汇。屏幕上看到的单词，例如在菜单或对话框中，也会以这种方式出现在文本中。例如：“从**管理**面板中选择**系统信息**。”

警告或重要注意事项会像这样出现。

小贴士和技巧会像这样出现。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**: 如果你对此书的任何方面有疑问，请在邮件主题中提及书名，并通过`customercare@packtpub.com`发送邮件给我们。

**勘误**: 尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果你在这本书中发现了错误，我们将不胜感激，如果你能向我们报告这一点。

请访问[www.packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择你的书籍，点击“勘误表提交表单”链接，并输入详细信息。

**盗版**: 如果你在互联网上以任何形式遇到我们作品的非法副本，如果你能提供位置地址或网站名称，我们将不胜感激。请通过发送链接至`copyright@packt.com`与我们联系。

**如果你有兴趣成为作者**: 如果你有一个你擅长的主题，并且你对撰写或为书籍做出贡献感兴趣，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

## 评论

请留下评论。一旦你阅读并使用了这本书，为何不在你购买它的网站上留下评论呢？潜在读者可以查看并使用你的客观意见来做出购买决定，Packt 公司可以了解你对我们的产品有何看法，我们的作者也可以看到他们对书籍的反馈。谢谢！

想了解更多关于 Packt 的信息，请访问 packt.com。
