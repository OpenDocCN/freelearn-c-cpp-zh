<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor314"/>6</h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor315"/>Implementing Hierarchies with Single Inheritance</h1>
<p>This chapter will extend our pursuit of object-oriented programming in C++. We will begin by introducing additional OO concepts, such as <strong class="bold">generalization</strong> and s<strong class="bold">pecialization</strong>, and then understand how these concepts are implemented in C++ through <em class="italic">direct language support</em>. We will begin building hierarchies of related classes, and understand how each class can become an easier to maintain, potentially reusable building block in our applications. We will understand how the new OO concepts presented in this chapter will support well-planned designs, and we will have a clear understanding of how to implement these designs with robust code in C++.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Object-oriented concepts of generalization and specialization, and <em class="italic">Is-A</em> relationships</li>
<li>Single inheritance basics – defining derived classes, accessing inherited members, understanding inherited access labels and regions, and <strong class="source-inline">final</strong> class specification</li>
<li><a id="_idTextAnchor316"/>Construction and destruction sequence in a single inheritance hierarchy; selecting base class constructors with the member initialization list</li>
<li>Modifying access labels in the base class list – <strong class="source-inline">public</strong> versus <strong class="source-inline">privat</strong>e and <strong class="source-inline">protected</strong> base classes – to change the OO purpose of inheritance to <em class="italic">Implementation Inheritance</em></li>
</ul>
<p>By the end of this chapter, you will understand the object-oriented concepts of generalization and specialization and will know how to use inheritance in C++ as a mechanism to realize these ideals. You will understand terms such as base and derived classes, as well as OO motivations for building hierarchies, such as supporting Is-A relationships or supporting implementation inheritance. </p>
<p>Specifically, you will understand how to grow inheritance hierarchies using single inheritance, and how to access inherited data members and member functions. You will also understand which inherited members you may directly access, based on their defined access regions. </p>
<p>You will understand the order of constructor and destructor invocations when instances of derived class types are instantiated and destroyed. You will know how to make use of the member initialization list to select which, from a potential group, of inherited constructors a derived class object may need to utilize as part of its own construction. </p>
<p>You will also understand how changing access labels in a base class list changes the OO meaning for the type of inheritance hierarchy you are growing. By examining public versus private and protected base classes, you will understand different types of hierarchies, such as those built to support Is-A relationships versus those built to support implementation inheritance.</p>
<p>By understanding the direct language support of single inheritance in C++, you will be able to implement the OO concepts of generalization and specialization. Each class within your hierarchy will be a more easily maintained component and can serve as a potential building block for creating new, more specialized components. Let us further our understanding of C++ as an OOP language by detailing single inheritance.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor317"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter06</strong> in a file named <strong class="source-inline">Chp6-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3R7uNci">https://bit.ly/3R7uNci</a>.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor318"/><a id="_idTextAnchor319"/>Expanding object-oriented concepts and terminology</h1>
<p>In this section, we <a id="_idIndexMarker444"/>will introduce essential <a id="_idIndexMarker445"/>object-oriented concepts, as well as applicable terminology that will accompany these key ideas. </p>
<p>From <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, you now understand the key OO ideas of encapsulation and information hiding, and how C++ supports these ideals through the C++ class. Now, we will look at how we can grow a hierarchy of related classes, using a very general class as a building block, and then extend that class by creating a more specific class. Through growing a hierarchy of related classes in this repeated fashion, OO systems provide building blocks of potential reuse. Each class within the hierarchy is encapsulated, so maintenance and upgrades to a specific class can be made more easily and without impact to the entire system. By incrementally refining each class with a more specific and more detailed class to build a hierarchy of related classes, specific maintenance for each component is in a focused area for maintenance and changes.</p>
<p>Let’s start by extending our basic OO terminology.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor320"/>Deciphering generalization and specialization</h2>
<p>The main <a id="_idIndexMarker446"/>object-oriented <a id="_idIndexMarker447"/>concepts extending through this chapter are <em class="italic">generalization</em> and <em class="italic">specialization</em>. Incorporating these principles into your design will provide the basis for writing more easily modifiable and maintainable code, and for code that can potentially be reused in related applications.</p>
<p><strong class="bold">Generalization</strong> describes the process of abstracting commonalities from a grouping of classes and creating a <a id="_idIndexMarker448"/>more generalized class for that grouping to <a id="_idIndexMarker449"/>house the common properties and behaviors. The more <a id="_idIndexMarker450"/>generalized class can be known as a <strong class="bold">base</strong> (or <strong class="bold">parent</strong>) class. Generalization can <a id="_idIndexMarker451"/>also be used to collect more general properties and behaviors of a single class into a base class with the expectation that the new, generalized class can later serve as a building block or basis for additional, more specific (derived) classes.</p>
<p><strong class="bold">Specialization</strong> describes the <a id="_idIndexMarker452"/>process of deriving a new class from an existing, generalized <a id="_idIndexMarker453"/>base class, for the purpose of adding specific, distinguishable properties and behaviors to adequately represent the <a id="_idIndexMarker454"/>new class. The specialized class can also be referred to <a id="_idIndexMarker455"/>as a <strong class="bold">derived</strong> (or <strong class="bold">child</strong>) class. A hierarchy of classes can incrementally <a id="_idIndexMarker456"/>refine their respective properties and behaviors <a id="_idIndexMarker457"/>through specialization.</p>
<p>Though reuse is difficult to achieve, the OOP concepts such as generalization and specialization <a id="_idIndexMarker458"/>make reuse more easily obtainable. Reuse <a id="_idIndexMarker459"/>can potentially be realized in applications that are similar in nature or in the same <a id="_idIndexMarker460"/>project domain, in continuations of existing projects, or potentially in related domains where minimally the most generalized classes and associated components can be reused. </p>
<p>Building a hierarchy is a fundamental language feature of C++. Let’s move forward by exploring single inheritance to put this i<a id="_idTextAnchor321"/>dea into action.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor322"/>Understanding single inheritance basics</h1>
<p><strong class="bold">Inheritance</strong> is the C++ language mechanism that allows the concepts of generalization and specialization <a id="_idIndexMarker461"/>to be realized. <strong class="bold">Single inheritance</strong> is when a given class has exactly one immediate base class. Both single inheritance and multiple inheritance are <a id="_idIndexMarker462"/>supported in C++; however, we will focus on single inheritance in this chapter and will cover multiple inheritance in a later chapter.</p>
<p>Inheritance hierarchies can be built using both classes and structures in C++. Classes, however, are most often utilized rather than structures to support inheritance and OOP.</p>
<p>Growing an inheritance hierarchy for the purpose of generalization and specialization supports an <strong class="bold">Is-A</strong> relationship. For <a id="_idIndexMarker463"/>example, given a base class of <strong class="source-inline">Person</strong> and a derived class of <strong class="source-inline">Student</strong>, we can say <em class="italic">a Student Is-A Person</em>. That is, a <strong class="source-inline">Student</strong> is a specialization of a <strong class="source-inline">Person</strong>, adding additional data members and member functions above and beyond those provided by its base class, <strong class="source-inline">Person</strong>. Specifying an Is-A relationship through generalization and specialization is the most typical reason inheritance is used to create base and derived classes. Later in this chapter, we will look at another reason to utilize inheritance.</p>
<p>Let’s get started by looking at the language mechanics in C++ to specify base and derived classes and to define an inh<a id="_idTextAnchor323"/><a id="_idTextAnchor324"/>eritance hierarchy.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor325"/>Defining base and derived classes and accessing inherited members</h2>
<p>With single <a id="_idIndexMarker464"/>inheritance, the derived class specifies who its immediate <a id="_idIndexMarker465"/>ancestor or base class is. The base class does not specify <a id="_idIndexMarker466"/>that it has any derived classes. </p>
<p>The derived class simply creates a base class list by adding a <strong class="source-inline">:</strong> after its class name, followed by the keyword <strong class="source-inline">public</strong> (for now), and then the specific base class name. Whenever you see a <strong class="source-inline">public</strong> keyword in the base class list, it means that we are using inheritance to specify<a id="_idTextAnchor326"/> an Is-A relationship.</p>
<p>Here is a simple example to illustrate the basic syntax:</p>
<ul>
<li><strong class="source-inline">Student</strong> <em class="italic">Is-A</em> <a id="_idTextAnchor327"/>derived class of <strong class="source-inline">Person</strong>:<p class="source-code">class Person  // base class</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    string name;</p><p class="source-code">    string title;</p><p class="source-code">public:</p><p class="source-code">    // constructors, destructor, </p><p class="source-code">    // public access functions, public interface etc.</p><p class="source-code">    const string &amp;GetTitle() const<a id="_idTextAnchor328"/> { return title; }</p><p class="source-code">};</p><p class="source-code">class Student<strong class="bold">: public Person</strong>  // derived class</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    float gpa;</p><p class="source-code">public:</p><p class="source-code">    // constructors, destructor specific to Student,</p><p class="source-code">    // public access functions, public interface, etc.</p><p class="source-code">    float GetGpa()<a id="_idTextAnchor329"/> con<a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>st { return gpa; }</p><p class="source-code">}; </p></li>
</ul>
<p>Here, the base class is <strong class="source-inline">Person</strong>, and the derived class is <strong class="source-inline">Student</strong>. The derived class need only define additional data members and member functions that augment those specified in the base class. </p>
<p>Instances of a derived class may generally access <strong class="source-inline">public</strong> members specified by the derived <a id="_idIndexMarker467"/>class or by any ancestor of the derived class. Inherited <a id="_idIndexMarker468"/>members are accessed in the <a id="_idIndexMarker469"/>same fashion as those specified by the derived class. Recall, dot notation (<strong class="source-inline">.</strong>) is used to access members of objects, and arrow notation (<strong class="source-inline">-&gt;</strong>) is used to access members of pointers to objects. </p>
<p>Of course, to make this example complete, we will need to add the applicable constructors, which we currently assume exist. Naturally, there will be nuances with constructors relating to inheritance, which we will soon cover in this chapter. </p>
<ul>
<li>Simple access of inherited members can be seen using the aforementioned classes as follows:<p class="source-code">int main()</p><p class="source-code">{   </p><p class="source-code">    // Let's assume the applicable constructors exist</p><p class="source-code">    Person p1("Cyrus Bond", "Mr.");</p><p class="source-code">    Student *s1 = new Student("Anne Lin", "Ms.", 4.0);</p><p class="source-code">    cout &lt;&lt; p1.GetTitle() &lt;&lt; " " &lt;&lt; s1-&gt;GetTitle();</p><p class="source-code">    cout &lt;&lt; s1-&gt;GetGpa() &lt;&lt; endl;</p><p class="source-code">    delete s1; // remember to relinquish alloc. memory</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
</ul>
<p>In the previous <a id="_idIndexMarker470"/>code fragment, the derived class instance of <strong class="source-inline">Student</strong>, pointed <a id="_idIndexMarker471"/>to by <strong class="source-inline">s1</strong>, can access both base <a id="_idIndexMarker472"/>and derived class members, such as <strong class="source-inline">Person::GetTitle()</strong> and <strong class="source-inline">Student::GetGpa()</strong>. The base class instance of <strong class="source-inline">Person</strong>, <strong class="source-inline">p1</strong>, can only access its own members, such as <strong class="source-inline">Person::GetTitle()</strong>. </p>
<p>Looking at a memory model for the preceding example, we have the following:</p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 6.1 – Memory model for current example" height="696" src="image/Figure_6.01_B19087.jpg" width="1202"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Memory model for current example</p>
<p>Notice that in the preceding memory model, a <strong class="source-inline">Student</strong> instance is comprised of a <strong class="source-inline">Person</strong> subobject. That is, at the memory address indicating the beginning of <strong class="source-inline">*s1</strong>, a <strong class="source-inline">Student</strong>, we first see the memory layout of its <strong class="source-inline">Person</strong> data members. Then, we see the memory layout of its additional <strong class="source-inline">Student</strong> data members. Of course, <strong class="source-inline">p1</strong>, which is a <strong class="source-inline">Person</strong>, only contains <strong class="source-inline">Person</strong> data members.</p>
<p>Access to <a id="_idIndexMarker473"/>base and derived class members will be subject to the access <a id="_idIndexMarker474"/>regions specified by each class. Let’s take a look to see <a id="_idIndexMarker475"/>how inherited access regions work.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor332"/>Examining inherited access regions</h2>
<p>Access <a id="_idIndexMarker476"/>regions, including inherited access regions, define from which scope members, including inherited members, are directly accessible.</p>
<p>The derived class inherits all members specified in its base class. However, direct access to those members is subject to the access regions specified in the base class.</p>
<p>Members (both data and function) inherited from the <em class="italic">base class</em> are accessible to the <em class="italic">derived class</em> as specified by the access regions that are imposed by the base class. The inherited access regions, and how they relate to derived class access, are as follows:</p>
<ul>
<li><strong class="bold">private</strong> members defined <a id="_idIndexMarker477"/>in the base class are inaccessible outside the scope of the base class. The scope of a class includes member functions of that class.</li>
<li><strong class="bold">protected</strong> members defined in the base class are accessible in the scope of the base class <a id="_idIndexMarker478"/>and within the scope of the derived class, or its descendants. This means member functions of these classes.</li>
<li><strong class="bold">public</strong> members defined <a id="_idIndexMarker479"/>in the base class are accessible from any scope, including the scope of the derived class.</li>
</ul>
<p>In the previous, simple example, we noticed that both a <strong class="source-inline">Person</strong> and a <strong class="source-inline">Student</strong> instance accessed the <strong class="source-inline">public</strong> member function <strong class="source-inline">Person::GetTitle()</strong> from the scope of <strong class="source-inline">main()</strong>. Also, we noticed that the <strong class="source-inline">Student</strong> instance accessed its <strong class="source-inline">public</strong> member <strong class="source-inline">Student::GetGpa()</strong> from <strong class="source-inline">main()</strong>. Generally, outside the scope of a given class, the only members that are accessible are those that are in the public interface, such as in this example. </p>
<p>We will soon see a larger, full program example in this chapter showcasing the <strong class="source-inline">protected</strong> access region. But first, let’s discover an additional specifier that may be useful in determining the shape and extensibility of our inheritance hierarchy. </p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor333"/>Specifying a class as final</h2>
<p>In C++, we can <a id="_idIndexMarker480"/>indicate that a class may not be further <a id="_idIndexMarker481"/>extended within our inheritance hierarchy. This is known as a <strong class="bold">leaf-node</strong> and can support an OO design <a id="_idIndexMarker482"/>to enforce that a given class may not be further specialized. The keyword <strong class="source-inline">final</strong> is used in the base class list to designate a class as a <strong class="bold">final</strong> (unextendible) class or <strong class="bold">leaf-node</strong>.</p>
<p>Here is a simple example to illustrate the basic syntax:</p>
<ul>
<li>Given our previous base class <strong class="source-inline">Person</strong>, <strong class="source-inline">Student</strong> <em class="italic">Is-A</em> derived class of <strong class="source-inline">Person</strong>. Additionally, <strong class="source-inline">GradStudent</strong> <em class="italic">Is-A</em> final derived class of <strong class="source-inline">Student</strong>:<p class="source-code">class GradStudent <strong class="bold">final</strong>: public Person // derived class</p><p class="source-code">{</p><p class="source-code">   // class definition</p><p class="source-code">};</p></li>
</ul>
<p>Here, <strong class="source-inline">GradStudent</strong> is specified as a final, unextendible class. Therefore, <strong class="source-inline">GradStudent</strong> may not appear in the base class list of a new derived class. </p>
<p>Next, let’s review inherited constructors and destructors so that our upcoming full program example <a id="_idTextAnchor334"/><a id="_idTextAnchor335"/>can provide greater overall utility. </p>
<h1 id="_idParaDest-131">Understanding in<a id="_idTextAnchor336"/>herited constructors and destructors </h1>
<p>Through single <a id="_idIndexMarker483"/>inheritance, we can build a hierarchy of related classes. We have seen that when we <a id="_idIndexMarker484"/>instantiate a derived class object, memory for its base class data members is then followed by the additional memory required for the additional derived class data members. Each of these subobjects will need to be constructed. Luckily, each class will have defined a suite of constructors for just that purpose. We then need to understand how the language can be utilized to allow us to specify the appropriate base class constructor for the base class subobject when instantiating and constructing a derived class object. </p>
<p>Similarly, when an object of a derived class type is no longer needed and will be destructed, it is important to note that a destructor for each subobject comprising the derived class instance will be implicitly called on our behalf.</p>
<p>Let’s take a look at the <a id="_idIndexMarker485"/>constructor and destructor sequence in a single <a id="_idIndexMarker486"/>inheritance hierarchy, and how we can make choices when more than one constructor is available for a base class subobject found in a derived class instance.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor337"/>Implicit constructor and destructor invocations</h2>
<p>Constructors and destructors are two types of member functions that are not explicitly inherited by the <a id="_idIndexMarker487"/>derived class. This means that the signature of a base <a id="_idIndexMarker488"/>class constructor may not be used to instantiate a derived class object. However, we will see that when a derived class object is instantiated, the memory for both the base and derived class portions of the overall object will be separately initialized using each class’s respective constructors. </p>
<p>When an object of a derived class type is instantiated, not only will one of its constructors be invoked but so will one in each of its preceding base classes. The most generalized base class constructor will first be executed, followed by the constructors all the way down the hierarchy until we arrive at the derived class constructor that is the same type as the instance at hand.</p>
<p>Similarly, when a derived class instance goes out of scope (or is explicitly deallocated for pointers to instances), all the relevant destructors will be invoked, but in the opposite order of construction. First, the derived class destructor will be executed, then all the destructors in an upward fashion for each preceding base class will be invoked and executed until we reach the most generalized base class.</p>
<p>You may now ask, how may I choose from a set of potential base class constructors for my base class subobject when instantiating a derived class? Let’s take a more detailed look at the member initialization list to discover the solution.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor338"/>Usage of member initialization list to select a base class constructor</h2>
<p>The member <a id="_idIndexMarker489"/>initialization <a id="_idIndexMarker490"/>list may be used to specify which base class constructor should be invoked when instantiating a derived class object. Each derived class constructor may specify that a different base class constructor should be used to initialize the given base class portion of the derived class object.</p>
<p>If the derived class constructor’s member initialization list does not specify which base class constructor should be utilized, the default base class constructor will be invoked.</p>
<p>The member initialization list is specified using a <strong class="source-inline">:</strong> after the parameter list in the derived class constructor. To specify which base class constructor should be used, the name of the base class constructor, followed by parentheses including any values to be passed to that base class constructor, can be indicated. Based upon the signature of the parameters in the base class list following the base class name, the appropriate base class constructor will be selected to initialize the bas<a id="_idTextAnchor339"/>e class portion of the derived class object. </p>
<p>Here is a simple example to illustrate the basic syntax for base class constructor selection:</p>
<ul>
<li>Let’s start with the basic class definitions (note that many member functions are omitted, as are some usual data members):<p class="source-code">class Person</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    string name;</p><p class="source-code">    string title;</p><p class="source-code">public:</p><p class="source-code">    Person() = default;  // various constructors</p><p class="source-code">    Person(const string &amp;, const string &amp;); </p><p class="source-code">    Person(const Person &amp;);</p><p class="source-code">    // Assume the public interface, access fns. exist</p><p class="source-code">};</p><p class="source-code">class Student: public Person</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    float gpa = 0.0;  // use in-class initializer</p><p class="source-code">public:</p><p class="source-code">    Student() = default;</p><p class="source-code">    Student(const string &amp;, const string &amp;, float);</p><p class="source-code">    // Assume the public interface, access fns. exist</p><p class="source-code">};</p></li>
<li>The <a id="_idIndexMarker491"/>constructors <a id="_idIndexMarker492"/>for the previous class definitions would be as follows (notice two of the derived class constructors use the member i<a id="_idTextAnchor340"/>nitialization list):<p class="source-code">// Base class constructors</p><p class="source-code">// Note: default constructor is included by = default</p><p class="source-code">// specification in Person constructor prototype</p><p class="source-code">Person::Person(const string &amp;n, const string &amp;t): </p><p class="source-code">               name(n), title(t)</p><p class="source-code">{    </p><p class="source-code">}</p><p class="source-code">Person::Person(const Person &amp;p): </p><p class="source-code">               name(p.name), title(p.title)</p><p class="source-code">{   </p><p class="source-code">}</p><p class="source-code">// Derived class constructors</p><p class="source-code">// Note: default constructor is included by = default</p><p class="source-code">// specification in Student constructor prototype and</p><p class="source-code">// gpa is set with value of in-class initializer (0.0)</p><p class="source-code"> </p><p class="source-code">Student::Student(const char *n, const char *t, </p><p class="source-code">                 float g)<strong class="bold">: Person(n, t)</strong>, gpa(g)</p><p class="source-code">{                    </p><p class="source-code">}                 </p><p class="source-code">                             </p><p class="source-code">Student::Student(const Student &amp;s)<strong class="bold">: Person(s)</strong>,</p><p class="source-code">                                    gpa(s.gpa)</p><p class="source-code">{                                  </p><p class="source-code">}</p></li>
</ul>
<p>In the previous short segment of code, notice that the system-supplied default derived class constructor, <strong class="source-inline">Student::Student()</strong>, has been elected with <strong class="source-inline">=default</strong> added to the constructor prototype. With an alternate constructor in this <a id="_idIndexMarker493"/>class <a id="_idIndexMarker494"/>definition, this specification (or by writing the default constructor ourselves) is necessary if we would like to support this simple interface for class instantiation. Remember, we only get a system-supplied default constructor if there are no other constructors (that is, means for instantiation) in our class definition.</p>
<p>Next, notice in the alternate derived class constructor, <strong class="source-inline">Student::Student(const string &amp;, const string &amp;, float)</strong>, the use of the member initialization list for base class construction specification. Here, the <strong class="source-inline">Person</strong> constructor matching the signature of <strong class="source-inline">Person::Person(const string &amp;, const string &amp;)</strong> is selected to initialize the <strong class="source-inline">Person</strong> subobject at hand. Also, notice that parameters from the <strong class="source-inline">Student</strong> constructor, <strong class="source-inline">n</strong> and <strong class="source-inline">t</strong>, are passed up to the aforementioned <strong class="source-inline">Person</strong> constructor to help complete the <strong class="source-inline">Person</strong> subobject initialization. Had we not specified which <strong class="source-inline">Person</strong> base class constructor should be used in the member initialization list, the default <strong class="source-inline">Person</strong> constructor will be used to initialize the <strong class="source-inline">Person</strong> base class subobject of <strong class="source-inline">Student</strong>. The member initialization list is additionally used in this constructor to initialize data members introduced within the <strong class="source-inline">Student</strong> class definition (such as <strong class="source-inline">gpa</strong>).</p>
<p>Now, notice in the copy constructor for the derived class, <strong class="source-inline">Student::Student(const Student &amp;)</strong>, the member initialization list is used to select the <strong class="source-inline">Person</strong> copy constructor, passing <strong class="source-inline">s</strong> as a parameter to the <strong class="source-inline">Person</strong> copy constructor. Here, the object referenced by <strong class="source-inline">s</strong> is a <strong class="source-inline">Student</strong>, however, the <a id="_idIndexMarker495"/>top part of <strong class="source-inline">Student</strong> memory contains <strong class="source-inline">Person</strong> data members. Hence, it <a id="_idIndexMarker496"/>is acceptable to implicitly upcast the <strong class="source-inline">Student</strong> to a <strong class="source-inline">Person</strong> to allow the <strong class="source-inline">Person</strong> copy constructor to initialize the <strong class="source-inline">Person</strong> subobject. Also, in the member initialization list of the <strong class="source-inline">Student</strong> copy constructor, the additional data member added by the <strong class="source-inline">Student</strong> class definition is initialized, namely, by initializing <strong class="source-inline">gpa(s.gpa)</strong>. These additional data members could have also been set in the body of this constructor.</p>
<p>Now that we understand how to utilize the member initialization list to specify a base class constructor, let’s move forward with a complete program example.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor341"/>Putting all the pieces together</h2>
<p>So far in this chapter, we have seen many pieces contributing to a full program example. It is important <a id="_idIndexMarker497"/>to see our code in action, with all its various components. We need to see the basic mechanics of inheritance, how the member initialization list is used to specify which base class constructor should implicitly be invoked, and the significance of the <strong class="source-inline">protected</strong> access region.</p>
<p>Let’s take a look at a more complex, full program example to fully illustrate single inheritance. This example will be broken into segments; the full p<a id="_idTextAnchor342"/>rogram can be found in the following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;  // preferred to: using namespace std;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
class Person
{
private: 
   // data members   
   string firstName; // str mbrs are default constructed,
   string lastName;  // so don't need in-class initializers
   char middleInitial = '\0';  // in-class initialization
   string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
<strong class="bold">protected:</strong> // make avail. to derived classes in their scope
   void ModifyTitle(const string &amp;); 
public:
   Person() = default;   // default constructor
   Person(const string &amp;, const string &amp;, char, 
          const string &amp;);  
   // We get default copy constructor and destructor even
   // without the below protypes; hence, commented out
   // Person(const Person &amp;) = default;  // def. copy ctor
   // ~Person() = default;  // use default destructor
   // inline function definitions
   const string &amp;GetFirstName() const { return firstName; }  
   const string &amp;GetLastName() const { return lastName; }    
   const string &amp;GetTitle() const { return title; } 
   char GetMiddleInitial() const { return middleInitial; }
};</pre>
<p>In the previous class definition, we now have a fully-fledged class definition for <strong class="source-inline">Person</strong>, with <a id="_idIndexMarker498"/>many more details than our simple syntax examples formerly used in this section. Notice that we have introduced a <strong class="source-inline">protected</strong> access region and placed member function <strong class="source-inline">void ModifyTitle(const string &amp;);</strong> in this access region. </p>
<p>Moving onward, let’s examine <a id="_idTextAnchor343"/>the non-line member function definitions for <strong class="source-inline">Person</strong>: </p>
<pre class="source-code">
// Def<a id="_idTextAnchor344"/>ault constructor included with = default in prototype
// With in-class initialization, it is often not necessary
// to write the default constructor yourself.
// alternate constructor
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t): firstName(fn),
               lastName(ln), middleInitial(mi), title(t)
{
   // dynamically allocate memory for<a id="_idTextAnchor345"/> any ptr data members
}
// We are using default copy constructor; let's see what
// it would look like if we prototyped/defined it ourselves
// (so we may better understand an upcoming discussion with
// the upcoming derived class copy constructor). Also,
// this is what the system-supplied version may look like.
// Person::Person(const Person &amp;p): firstName(p.firstName),
//    lastName(p.lastName), middleInitial(p.middleInitial),
//    title(p.title)
// {
   <a id="_idTextAnchor346"/>     // deep copy any pointer data members here
// }
// Using default destructor – no need to write it ourselves
void Person::ModifyTitle(const string &amp;newTitle)
{
   title = newTitle;
}</pre>
<p>The implementation for the aforesaid <strong class="source-inline">Person</strong> member functions is as expected. Now, let’s add the <a id="_idIndexMarker499"/>class definition for the derived class, <strong class="source-inline">Student</strong>, along with its inline function definitions:</p>
<pre class="source-code">
class Student<strong class="bold">: public Person</strong>
{
private: 
   // data members
   float gpa = 0.0;   // in-class initialization
   string currentCourse;  
   const string studentId;  // studentId is not modifiable
   static int numStudents; // static data mbr. init. occurs
public:                  // outside of the class definition
   // member function prototypes
   Student();   // we will provide default constructor
   Student(const string &amp;, const string &amp;, char, 
           const string &amp;, float, const string &amp;, 
           const string &amp;); 
   Student(const Student &amp;);  // copy constructor
   ~Student();  // we will provide destructor
   void Print() const;
   void EarnPhD();  // public interface to inherited 
                    // protected member
   // inline function definitions
   float GetGpa() const { return gpa; }
   const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
   const string &amp;GetStudentId() const { return studentId; }
   // prototype only, see inline function definition below
   void SetCurrentCourse(const string &amp;);
   static int GetNumberStudents(); // static mbr function
};
// definition for static data mbr. (implemented as extern)
int Student::numStudents = 0;  // notice initial value of 0
inline void Student::SetCurrentCourse(const string &amp;c)
{
   currentCourse = c;
}
// Definition for static member function (it's also inline)
inline int Student::GetNumberStudents()
{
    return numStudents;
}</pre>
<p>In the preceding definition of <strong class="source-inline">Student</strong>, <strong class="source-inline">class Student</strong> is derived from <strong class="source-inline">Person</strong> using <strong class="source-inline">public</strong> inheritance (that is, a public base class), which supports an Is-A relationship. Notice <a id="_idIndexMarker500"/>the <strong class="source-inline">public</strong> access label after the base class list following the <strong class="source-inline">:</strong> in the derived class definition (that is, <strong class="source-inline">class Student: public Person</strong>). Notice that our <strong class="source-inline">Student</strong> class has added data members and member functions above and beyond those that it automatically inherits from <strong class="source-inline">Person</strong>. </p>
<p>Next, adding in <a id="_idIndexMarker501"/>the non-inline <strong class="source-inline">Student</strong> member functions, we continue growing our code:</p>
<pre class="source-code">
// Default constructor uses in-class init. for gpa, while
// currentCourse (string mbr object) is default constructed
Student::Student(): studentId(to_string(numStudents + 100) 
                              + "Id")
{
   // Since studentId is const, we need to initialize it 
   // during construction using member init list (above)
   // Also, remember to dynamically allocate memory for any 
   <a id="_idTextAnchor347"/>// pointer data mbrs. here (not needed in this example)
   numStudents++;   // increment static counter
}
// alternate constructor
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;t, float avg, 
                 const string &amp;course, const string &amp;id)<strong class="bold">:</strong>
<strong class="bold">            Person(fn, ln, mi, t)</strong>,
            gpa(avg), currentCourse(course), studentId(id)
{
   // Remember to dynamically allocate memory for any 
   // pointer data members (none in this example) 
   numStudents++;   // increment static counter
}
// copy constructor 
Student::Student(const Student &amp;s)<strong class="bold">: Person(s)</strong>, gpa(s.gpa),
                 currentCourse(s.currentCourse),
                 studentId(s.studentId)
{
   // deep copy any ptr data mbrs (none in this example)
   numStudents++;   // increment static counter
}
 
// destructor definition
Student::~Student()
{
   // Remember to release memory for any dynamically 
   // allocated data members (none in this example)
   numStudents--;  // decrement static counter
}
void Student::Print() const
{
   // Private members of Person are not directly accessible
   // within the scope of Student, so we use access fns. 
   cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
   cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
   cout &lt;&lt; " with id: " &lt;&lt; studentId &lt;&lt; " gpa: ";
   cout &lt;&lt; setprecision(2) &lt;&lt; gpa;
   cout &lt;&lt; " course: " &lt;&lt; currentCourse &lt;&lt; endl;
}
void Student::EarnPhD()
{
   // Protected members defined by the base class are
   // accessible within the scope of the derived class.
   // EarnPhd() provides a public interface to this
   // functionality for derived class instances. 
   ModifyTitle("Dr.");  
}</pre>
<p>In the aforementioned segment of code, we define the non-inline member functions of <strong class="source-inline">Student</strong>. Notice that the default constructor merely uses the member initialization list to initialize a data member, as we did in the last chapter. Since no <strong class="source-inline">Person</strong> constructor has been <a id="_idIndexMarker502"/>specified in the member initialization list of the default <strong class="source-inline">Student</strong> constructor, the default <strong class="source-inline">Person</strong> constructor will be used to initialize the <strong class="source-inline">Person</strong> subobject when instantiating a <strong class="source-inline">Student</strong> with its default constructor.</p>
<p>Next, the alternate constructor for <strong class="source-inline">Student</strong> uses the member initialization list to specify that the alternate constructor of <strong class="source-inline">Person</strong> should be utilized to construct the <strong class="source-inline">Person</strong> subobject contained within a given <strong class="source-inline">Student</strong> instance. Notice that the selected constructor will match the signature <strong class="source-inline">Person::Person(const string &amp;, const string &amp;, char, const string &amp;)</strong>, and that selected input parameters from the <strong class="source-inline">Student</strong> constructor (namely <strong class="source-inline">fn</strong>, <strong class="source-inline">ln</strong>, <strong class="source-inline">mi</strong>, and <strong class="source-inline">t</strong>) will be passed as parameters to the <strong class="source-inline">Person</strong> alternate constructor. The <strong class="source-inline">Student</strong> constructor’s member initialization list is then used to initialize additional data members introduced by the <strong class="source-inline">Student</strong> class.</p>
<p>In the copy constructor for <strong class="source-inline">Student</strong>, the member initialization list is used to specify that the <strong class="source-inline">Person</strong> copy constructor should be called to initialize the <strong class="source-inline">Person</strong> subobject of the <strong class="source-inline">Student</strong> instance that is being constructed. The <strong class="source-inline">Student &amp;</strong> will be implicitly upcast to a <strong class="source-inline">Person &amp;</strong> as the <strong class="source-inline">Person</strong> copy constructor is called. Recall that the top part of a <strong class="source-inline">Student</strong> object <em class="italic">Is-A</em> <strong class="source-inline">Person</strong>, so this is fine. Next, in the remainder of the copy constructor’s member initialization list for <strong class="source-inline">Student</strong>, we initialize any remaining data members the <strong class="source-inline">Student</strong> class has defined. Any data members requiring a deep copy (such as those that are pointers) may be handled in the body of the copy constructor. </p>
<p>Moving onward, we see a comment indicating the <strong class="source-inline">Student</strong> destructor. Implicitly, as the <em class="italic">last</em> line of code in this method (whether the destructor is system-supplied or user-written), a call to the <strong class="source-inline">Person</strong> destructor is patched in for us by the compiler. This is how the destructor sequence is automated for us. Consequently, the most specialized portion of the object, the <strong class="source-inline">Student</strong> pieces, will first be destructed, followed by the implicit call to the <strong class="source-inline">Person</strong> destructor to destruct the base class subobject. </p>
<p>Next, in the <strong class="source-inline">Print()</strong> method for <strong class="source-inline">Student</strong>, notice that we would like to print out various data members that are inherited from <strong class="source-inline">Person</strong>. Alas, these data members are <strong class="source-inline">private</strong>. We may not access them outside the scope of the <strong class="source-inline">Person</strong> class. Nevertheless, the <strong class="source-inline">Person</strong> class has left us with a public interface, such as <strong class="source-inline">Person::GetTitle()</strong> and <strong class="source-inline">Person::GetFirstName()</strong>, so that we may access these data members from any scope of our application, including from <strong class="source-inline">Student::Print()</strong>.</p>
<p>Finally, we come to the <strong class="source-inline">Student::EarnPhD()</strong> method. Notice that all this method does is invoke the <strong class="source-inline">protected</strong> member function <strong class="source-inline">Person::ModifyTitle("Dr.");</strong>. Recall that <strong class="source-inline">protected</strong> members defined by the base class are accessible within the scope of the derived class. <strong class="source-inline">Student::EarnPhD()</strong> is a member function of the derived class. <strong class="source-inline">EarnPhD()</strong> provides a public interface to modify the title of a <strong class="source-inline">Person</strong>, perhaps after checking whether the student <a id="_idIndexMarker503"/>has met graduation requirements. Because <strong class="source-inline">Person::ModifyTitle()</strong> is not <strong class="source-inline">public</strong>, instances of <strong class="source-inline">Person</strong> or <strong class="source-inline">Student</strong> must go through a controlled <strong class="source-inline">public</strong> interface to change their respective titles. Such interfaces might include methods such as <strong class="source-inline">Student::EarnPhD()</strong> or <strong class="source-inline">Person::GetMarried()</strong>, and so on.</p>
<p>Nonetheless, le<a id="_idTextAnchor348"/>t’s complete our full program example by exam<a id="_idTextAnchor349"/>ining <strong class="source-inline">main()</strong>:</p>
<pre class="source-code">
int main()
{
    Student s1("Jo", "Li", 'U', "Ms.", 3.8, 
               "C++", "178PSU"); 
    // Public members of Person and Student are accessible
    // outside the scope of their respective classes....
    s1.Print();
    s1.SetCurrentCourse("Doctoral Thesis");
    s1.EarnPhD();
    s1.Print();
    cout &lt;&lt; "Total number of students: " &lt;&lt; 
             Student::GetNumberStudents() &lt;&lt; endl;
    return 0;
}</pre>
<p>In the last segment of this program, in <strong class="source-inline">main()</strong>, we simply instantiate a <strong class="source-inline">Student</strong>, namely <strong class="source-inline">s1</strong>. The <strong class="source-inline">Student</strong> utilizes <strong class="source-inline">Student::Print()</strong> to print its current data. The <strong class="source-inline">Student</strong> then sets her current course set to <strong class="source-inline">"Doctoral Thesis"</strong> and then invokes <strong class="source-inline">Student::EarnPhD();</strong>. Note that any <strong class="source-inline">public</strong> members of <strong class="source-inline">Student</strong> or <strong class="source-inline">Person</strong> are <a id="_idIndexMarker504"/>available for <strong class="source-inline">s1</strong> to utilize outside the scope of their class, such as in <strong class="source-inline">main()</strong>. To complete the example, <strong class="source-inline">s1</strong> reprints her details usin<a id="_idTextAnchor350"/>g <strong class="source-inline">Student::Print()</strong>.</p>
<p>Here is the output for the full program example:</p>
<p class="source-code">Ms. Jo U. Li with id: 178PSU gpa: 3.9 course: C++</p>
<p class="source-code">Dr. Jo U. Li with id: 178PSU gpa: 3.9 course: Doctoral Thesis</p>
<p class="source-code">Total number of students: 1</p>
<p>Now that we <a id="_idIndexMarker505"/>have competency with the basic mechanics of single inheritance, and have used single inheritance to model an Is-A relationship, let’s move onward to see how inheritance can be used to model a different concept by exploring <strong class="source-inline">protected</strong> and <strong class="source-inline">private</strong> base classes.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor351"/>Implementation inheritance – changing the purpose of inheritance</h1>
<p>So far we demonstrated using a public base class, known also as <em class="italic">public inheritance</em>. Public base <a id="_idIndexMarker506"/>classes are used to model Is-A relationships and provide the primary motivation behind building an inheritance hierarchy. This usage supports the concepts of generalization and specialization.</p>
<p>Occasionally, inheritance may be used as a tool to implement one class in terms of another, that is, by one class using another as its underlying implementation. This is known as <strong class="bold">implementation inheritance</strong> and it does not support the ideals of generalization and specialization. Yet, implementation inheritance can provide a quick and easily reusable way to implement one class based upon another. It is fast and relatively error-free. Many class libraries use this tool without the knowledge of their class users. It is important to distinguish implementation inheritance from traditional hierarchy building for the motivation of specifying Is-A relationships.</p>
<p>Implementation inheritance, supported in C++ with private and protected base classes, is exclusive to C++. Other OOP languages choose to only embrace inheritance for the purpose of modeling Is-A relationships, which is supported in C++ through public base classes. An OO purist would endeavor to use inheritance only to support generalization and specialization (<em class="italic">Is-A</em>). However, using C++, we will understand appropriate uses of implementation inheritance so that we may use this language feature wisely.</p>
<p>Let’s move onward to unde<a id="_idTextAnchor352"/>rstand how and why we might utilize this type of inheritance.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor353"/>Modifying access labels in the base class list by using protected or private base classes </h2>
<p>To reiterate, the <a id="_idIndexMarker507"/>usual type <a id="_idIndexMarker508"/>of inheritance is <strong class="source-inline">public</strong> inheritance. The <strong class="source-inline">public</strong> label is used in the base class list for a given derived class. However, in the base class list, the keywords <strong class="source-inline">protected</strong> and <strong class="source-inline">private</strong> are also options.</p>
<p>That is, in addition to labeling access regions within a class or structure definition, an access label can be used in the base class list of a derived class definition to designate how members defined in a base class are inherited by derived classes.</p>
<p>Inherited members can only be made more restrictive than they were designated to be in the <a id="_idIndexMarker509"/>base class. When the derived class specifies that <a id="_idIndexMarker510"/>inherited members should be treated in a more restrictive fashion, any descendants of that derived class will also be subject to these specifications.</p>
<p>Let’s see a quick example of the <em class="italic">base class list</em>:</p>
<ul>
<li>Recall that most often, a <strong class="source-inline">public</strong> access label will be specified in the base class list.</li>
<li>In this example, a <strong class="source-inline">public</strong> access label is used to specify that a <strong class="source-inline">Person</strong> is a <strong class="source-inline">public</strong> base class of <strong class="source-inline">Student</strong>. That is, a <strong class="source-inline">Student</strong> <em class="italic">Is-A</em> <strong class="source-inline">Person</strong>:<p class="source-code">class Student: <strong class="bold">public</strong> Person</p><p class="source-code">{</p><p class="source-code">    // usual class definition</p><p class="source-code">};</p></li>
</ul>
<p>Access labels specified in the <em class="italic">base class list</em> modify inherited access regions as follows:</p>
<ul>
<li><strong class="bold">public</strong>: Public members in the base class are accessible from any scope; protected members in the base class are accessible from the scope of the base and derived classes. We are familiar with using a public base class.</li>
<li><strong class="bold">protected</strong>: Public and protected members in the base class act as though they are defined as protected by the derived class (that is, accessible from the scope of the base and derived classes and any descendants of the derived class).</li>
<li><strong class="bold">private</strong>: Public and protected members in the base class act as though they are defined as private by the derived class, allowing these members to be accessible within the scope of the derived class, but not within the scope of any of the derived class descendants.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">In all cases, class members labeled as private within a class definition, are accessible only within the scope of the defining class. Modifying the access labels in the base class list can only treat inherited members more restrictively, never less restrictively.</p>
<p>In the absence <a id="_idIndexMarker511"/>of an access label specified in conjunction <a id="_idIndexMarker512"/>with the base class, <strong class="source-inline">private</strong> will be assumed if the user defined type is a <strong class="source-inline">class</strong>, and <strong class="source-inline">public</strong> will be the default if the user defined type is a <strong class="source-inline">struct</strong>. A good rule of thumb is to always include the access label in the base class list for a derived class (or structure) definition.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor354"/>Creating a base class to illustrate implementation inheritance</h2>
<p>To understand <a id="_idIndexMarker513"/>implementation <a id="_idIndexMarker514"/>inheritance, let’s review a base class that may serve as a basis to implement other classes. We will examine a typical pair of classes to implement an encapsulated <strong class="source-inline">LinkList</strong>. Though this example will be broken into several segments<a id="_idTextAnchor355"/>, the full example will be shown, and can also be found in the GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
using Item = int;  
class LinkListElement  // a 'node' or element of a LinkList
{
private:
    void *data = nullptr;   // in-class initialization
    LinkListElement *next = nullptr;
public:
    LinkListElement() = default;
    LinkListElement(Item *i) : data(i), next(nullptr) { }
    ~LinkListElement()
       { delete static_cast&lt;Item *&gt;(data); 
         next = nullptr; }
    void *GetData() const { return data; }
    LinkListElement *GetNext() const { return next; }
    void SetNext(LinkListElement *e) { next = e; }
};
class LinkList   // an encapsulated LinkList
{
private:
    LinkListElement *head = nullptr;  // in-class init.
    LinkListElement *tail = nullptr;
    LinkListElement *current = nullptr;
public:
    LinkList() = default; // required to keep default
                          // interface
    LinkList(LinkListElement *);
   ~LinkList();
    void InsertAtFront(Item *);
    LinkListElement *RemoveAtFront();
    void DeleteAtFront();
    int IsEmpty() const { return head == nullptr; } 
    void Print() const;  
};</pre>
<p>We begin the previous segment of code with class definitions for both <strong class="source-inline">LinkListElement</strong> and <strong class="source-inline">LinkList</strong>. The <strong class="source-inline">LinkList</strong> class will contain data members that are <a id="_idIndexMarker515"/>pointers to the <strong class="source-inline">head</strong>, <strong class="source-inline">tail</strong>, and <strong class="source-inline">current</strong> element in the <strong class="source-inline">LinkList</strong>. Each of these pointers is of type <strong class="source-inline">LinkListElement</strong>. A <a id="_idIndexMarker516"/>variety of typical <strong class="source-inline">LinkList</strong> processing methods are included, such as <strong class="source-inline">InsertAtFront()</strong>, <strong class="source-inline">RemoveAtFront()</strong>, <strong class="source-inline">DeleteAtFront()</strong>, <strong class="source-inline">IsEmpty()</strong>, and <strong class="source-inline">Print()</strong>. Let’s take a quick peek at the implementation of these methods with the next segment of code:</p>
<pre class="source-code">
// default constructor – not necessary to write it 
// ourselves with in-class initialization above 
LinkList::LinkList(LinkListElement *element)
{
    head = tail = current = element;
}
void LinkList::InsertAtFront(Item *theItem)
{
    LinkListElement *newHead = new
                               LinkListElement(theItem);
    newHead-&gt;SetNext(head);  // newHead-&gt;next = head;
    head = newHead;
}
LinkListElement *LinkList::RemoveAtFront()
{
    LinkListElement *remove = head;
    head = head-&gt;GetNext();  // head = head-&gt;next;
    current = head;    // reset current for usage elsewhere
    return remove;
}
 
void LinkList::DeleteAtFront()
{
    LinkListElement *deallocate;
    deallocate = RemoveAtFront();
    delete deallocate;  // destructor will both delete data 
}                       // and will set next to nullptr
 
void LinkList::Print() const
{
    if (!head)
       cout &lt;&lt; "&lt;EMPTY&gt;";
    LinkListElement *traverse = head;
    while (traverse)
    {
        Item output = *(static_cast&lt;Item *&gt;
                        (traverse-&gt;GetData()));
        cout &lt;&lt; output &lt;&lt; " ";
        traverse = traverse-&gt;GetNext();
    }
    cout &lt;&lt; endl;
}
LinkList::~LinkList()
{
    while (!IsEmpty())
        DeleteAtFront();
}</pre>
<p>In the <a id="_idIndexMarker517"/>previously mentioned <a id="_idIndexMarker518"/>member function definitions, we note that a <strong class="source-inline">LinkList</strong> can be constructed either empty or with one element (note the two available constructors). <strong class="source-inline">LinkList::InsertAtFront()</strong> adds an item to the front of the list for efficiency. <strong class="source-inline">LinkList::RemoveAtFront()</strong> removes an item and returns it to the user, whereas <strong class="source-inline">LinkList::DeleteAtFront()</strong> removes and deletes the front item. The <strong class="source-inline">LinkList::Print()</strong> function allows us to view the <strong class="source-inline">LinkList</strong> whenever necessary. </p>
<p>Next, let’s <a id="_idIndexMarker519"/>see a typical <strong class="source-inline">main()</strong> <a id="_idIndexMarker520"/>function to illustrate how a <strong class="source-inline">LinkList</strong> can be instantiated and manipulated:</p>
<pre class="source-code">
int main()
{
    // Create a few items, to be data for LinkListElements
    Item *item1 = new Item;
    *item1 = 100;
    Item *item2 = new Item(200);
    // create an element for the Linked List
    LinkListElement *element1 = new LinkListElement(item1);
    // create a linked list and initialize with one element
    LinkList list1(element1);
    // Add some new items to the list and print
    list1.InsertAtFront(item2);   
    list1.InsertAtFront(new Item(50)); // add nameless item
    cout &lt;&lt; "List 1: ";
    list1.Print();         // print out contents of list
    // delete elements from list, one by one
    while (!(list1.IsEmpty()))
    {
        list1.DeleteAtFront();
        cout &lt;&lt; "List 1 after removing an item: ";
        list1.Print();
    }
    // create a second linked list, add some items, print
    LinkList list2;
    list2.InsertAtFront(new Item (3000));
    list2.InsertAtFront(new Item (600));
    list2.InsertAtFront(new Item (475));
    cout &lt;&lt; "List 2: ";
    list2.Print();
    // delete elements from list, one by one
    while (!(list2.IsEmpty()))
    {
        list2.DeleteAtFront();
        cout &lt;&lt; "List 2 after removing an item: ";
        list2.Print();
    }
    return 0;
}</pre>
<p>In <strong class="source-inline">main()</strong>, we <a id="_idIndexMarker521"/>create <a id="_idIndexMarker522"/>a few items, of type <strong class="source-inline">Item</strong>, which will later be data for <strong class="source-inline">LinkListElement</strong>. We then instantiate a <strong class="source-inline">LinkListElement</strong>, namely <strong class="source-inline">element1</strong>, and add it to a newly constructed <strong class="source-inline">LinkList</strong>, using <strong class="source-inline">LinkList list1(element1);</strong>. We then add several items to the list using <strong class="source-inline">LinkList::InsertAtFront()</strong>, and call <strong class="source-inline">LinkList::Print()</strong> to print out <strong class="source-inline">list1</strong> for a baseline. Next, we delete elements from <strong class="source-inline">list1</strong>, one by one, printing as we go, using <strong class="source-inline">LinkList::DeleteAtFront()</strong> and <strong class="source-inline">LinkList::Print()</strong>, respectively.</p>
<p>Now, we <a id="_idIndexMarker523"/>instantiate a <a id="_idIndexMarker524"/>second <strong class="source-inline">LinkList</strong>, namely <strong class="source-inline">list2</strong>, which starts out empty. We gradually insert several items using <strong class="source-inline">LinkList::InsertAtFront()</strong>, then print the list, and then delete each element, one by one, using <strong class="source-inline">LinkList::DeleteAtFront()</strong>, printing the revised list with each step.</p>
<p>The point of this example is not to exhaustively review the inner workings of this code. You are undoubtedly familiar with the concept of a <strong class="source-inline">LinkList</strong>. More so, the point is to establish this set of classes, <strong class="source-inline">LinkListElement</strong> and <strong class="source-inline">LinkList</strong>, as a set of building blocks in which several <em class="italic">Abstract Data Types</em> can be built. </p>
<p>Nonetheless, the output for the preceding example is as follows:</p>
<p class="source-code">List 1: 50 200 100</p>
<p class="source-code">List 1 after removing an item: 200 100</p>
<p class="source-code">List 1 after removing an item: 100</p>
<p class="source-code">List 1 after removing an item: &lt;EMPTY&gt;</p>
<p class="source-code">List 2: 475 600 3000</p>
<p class="source-code">List 2 after removing an item: 600 3000</p>
<p class="source-code">List 2 after removing an item: 3000</p>
<p class="source-code">List 2 after removing an item: &lt;EMPTY&gt;</p>
<p>Next, let’s see how <strong class="source-inline">LinkList</strong> can be used as a private base class.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor356"/>Using a private base class to implement one class in terms of another</h2>
<p>We have just created a <strong class="source-inline">LinkList</strong> class to support the basic handling of an encapsulated <a id="_idIndexMarker525"/>linked list data structure. Now, let’s imagine that we would <a id="_idIndexMarker526"/>like to implement an <strong class="bold">Abstract Data Type</strong> (<strong class="bold">ADT</strong>), such as a stack. A <strong class="bold">stack</strong> is an ADT in that it has a set <a id="_idIndexMarker527"/>of expected <a id="_idIndexMarker528"/>operations to define its interface, such as <strong class="source-inline">Push()</strong>, <strong class="source-inline">Pop()</strong>, <strong class="source-inline">IsEmpty()</strong>, and perhaps <strong class="source-inline">Print()</strong>. </p>
<p>You may ask how a stack is implemented. The answer is that the implementation does not matter, so long as it supports the expected interface of the ADT being modeled. Perhaps a stack is implemented using an array, or perhaps it is implemented in a file. Perhaps it is implemented using a <strong class="source-inline">LinkedList</strong>. Each implementation has pros and cons. In fact, the underlying implementation of the ADT might change, yet users of the ADT should not be affected by such a change. This is the basis of <em class="italic">implementation inheritance</em>. A derived class is implemented in terms of a base class, yet the underlying details of the <a id="_idIndexMarker529"/>base class from which the new class is derived are effectively <a id="_idIndexMarker530"/>hidden. These details cannot be directly used by instances of the derived class (in this case, the ADT). Nonetheless, the base class silently provides the implementation for the derived class.</p>
<p>We will use this approach to implement a <strong class="source-inline">Stack</strong> using a <strong class="source-inline">LinkedList</strong> as its underlying implementation. To do this, we will have <strong class="source-inline">class Stack</strong> extend <strong class="source-inline">LinkedList</strong> using a <strong class="source-inline">private</strong> base class. <strong class="source-inline">Stack</strong> will define a public interface for its users to establish the interface for this ADT, such as <strong class="source-inline">Push()</strong>, <strong class="source-inline">Pop()</strong>, <strong class="source-inline">IsEmpty()</strong>, and <strong class="source-inline">Print()</strong>. The implementation of these member functions will make use of selected <strong class="source-inline">LinkedList</strong> member functions, but <strong class="source-inline">Stack</strong> users will not see this, nor will <strong class="source-inline">Stack</strong> instances be able to use any <strong class="source-inline">LinkList</strong> members directly themselves. </p>
<p>Here, we are not saying a <strong class="source-inline">Stack</strong> <em class="italic">Is-A</em> <strong class="source-inline">LinkList</strong>, but rather, a <strong class="source-inline">Stack</strong> is implemented in terms of a <strong class="source-inline">LinkedList</strong> at the moment—and that underlying implementation could change!</p>
<p>The code to implement <strong class="source-inline">Stack</strong> is simple. <a id="_idTextAnchor357"/><a id="_idTextAnchor358"/>Assume we are using the <strong class="source-inline">LinkList</strong> and <strong class="source-inline">LinkListElement</strong> classes from the previous example. Let’s add the <strong class="source-inline">Stack</strong> class here. The full program example can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp</a></p>
<pre class="source-code">
class St<a id="_idTextAnchor359"/>ack<strong class="bold">: private LinkList</strong>
{
private:
    // no new data members are necessary
public:  
    // Constructor / destructor prototypes shown below are
    // not needed; we get both without these prototypes! 
    // Commented to remind what's automatically provided
    // Stack() = default; // will call :LinkList() def ctor
    // ~Stack() = default; 
    // the public interface for Stack 
    void Push(Item *i) { <strong class="bold">InsertAtFront(i);</strong> }
    Item *Pop(); 
    // It is necessary to redefine these operations because
    // LinkList is a private base class of Stack
    int IsEmpty() const { return <strong class="bold">LinkList::IsEmpty();</strong> }  
    void Print() { <strong class="bold">LinkList::Print();</strong> }
};
Item *Stack::Pop()
{
    LinkListElement *top;
    top = <strong class="bold">RemoveAtFront();</strong>
    // copy top's data
    Item *item = new Item(*(static_cast&lt;Item *&gt;
                            (top-&gt;GetData())));
    delete top;
    return item;
}
int main()
{
    <strong class="bold">Stack stack1;</strong>    // create a Stack
    // Add some items to the stack, using public interface 
    stack1.Push(new Item (3000)); 
    stack1.Push(new Item (600));
    stack1.Push(new Item (475));
    cout &lt;&lt; "Stack 1: ";
    stack1.Print();
    // Pop elements from stack, one by one
    while (!(stack1.IsEmpty()))
    {
        stack1.Pop();
        cout &lt;&lt; "Stack 1 after popping an item: ";
        stack1.Print();
    }
    return 0;
} </pre>
<p>Notice how compact the aforementioned code is for our <strong class="source-inline">Stack</strong> class! We begin by specifying <a id="_idIndexMarker531"/>that <strong class="source-inline">Stack</strong> has a <strong class="source-inline">private</strong> base class of <strong class="source-inline">LinkList</strong>. Recall that <a id="_idIndexMarker532"/>a <strong class="source-inline">private</strong> base class means that the <strong class="source-inline">protected</strong> and <strong class="source-inline">public</strong> members inherited from <strong class="source-inline">LinkList</strong> act as though they were defined by <strong class="source-inline">Stack</strong> as <strong class="source-inline">private</strong> (and are only accessible within the scope of <strong class="source-inline">Stack</strong>, that is, member functions of <strong class="source-inline">Stack</strong>). This means that instances of <strong class="source-inline">Stack</strong> may not use the <em class="italic">former</em> public interface of <strong class="source-inline">LinkList</strong>. This also means that the underlying implementation of <strong class="source-inline">Stack</strong> as a <strong class="source-inline">LinkList</strong> is effectively hidden. Of course, <strong class="source-inline">LinkList</strong> instances are not affected in any way and may use their <strong class="source-inline">public</strong> interface as usual.</p>
<p>We notice that <strong class="source-inline">=default</strong> has been added to both the <strong class="source-inline">Stack</strong> constructor and destructor prototypes. Neither of these methods has work to do because we are not adding any data members to this class; therefore, the default system-supplied versions are acceptable. Note that if we omitted both the default constructor and destructor prototypes, we get both system-supplied versions linked in. </p>
<p>We easily define <strong class="source-inline">Stack::Push()</strong> to simply call <strong class="source-inline">LinkList::InsertAtFront()</strong>, just as <strong class="source-inline">Stack::Pop()</strong> does little more than call <strong class="source-inline">LinkList::RemoveAtFront()</strong>. Even though <strong class="source-inline">Stack</strong> would love to simply use the inherited implementations of <strong class="source-inline">LinkList::IsEmpty()</strong> and <strong class="source-inline">LinkList::Print()</strong>, due to <strong class="source-inline">LinkList</strong> being a <strong class="source-inline">private</strong> base class, these functions are not part of the public interface of <strong class="source-inline">Stack</strong>. Accordingly, <strong class="source-inline">Stack</strong> adds an <strong class="source-inline">IsEmpty()</strong> method that simply calls <strong class="source-inline">LinkList::IsEmpty();</strong>. Notice the use of the scope resolution operator to specify the <strong class="source-inline">LinkList::IsEmpty()</strong> method; without the base class qualification, we would be adding <a id="_idIndexMarker533"/>a recursive function call! This call to the base class method is allowed because <strong class="source-inline">Stack</strong> member functions can call the <em class="italic">once public</em> methods of <strong class="source-inline">LinkList</strong> (they are now treated as <strong class="source-inline">private</strong> within <strong class="source-inline">Stack</strong>). Similarly, <strong class="source-inline">Stack::Print()</strong> merely calls <strong class="source-inline">LinkList::Print()</strong>.</p>
<p>In the scope of <strong class="source-inline">main()</strong>, we instantiate a <strong class="source-inline">Stack</strong>, namely <strong class="source-inline">stack1</strong>. Using the public interface of <strong class="source-inline">Stack</strong>, we easily manipulate <strong class="source-inline">stack1</strong> using <strong class="source-inline">Stack::Push()</strong>, <strong class="source-inline">Stack::Pop()</strong>, <strong class="source-inline">Stack::IsEmpty()</strong>, and <strong class="source-inline">Stack::Print()</strong>. </p>
<p>The output for this example is as follows:</p>
<p class="source-code">Stack 1: 475 600 3000</p>
<p class="source-code">Stack 1 after popping an item: 600 3000</p>
<p class="source-code">Stack 1 after popping an item: 3000</p>
<p class="source-code">Stack 1 after popping an item: &lt;EMPTY&gt;</p>
<p>It is important to note that a pointer to a <strong class="source-inline">Stack</strong> instance cannot be upcast to be stored as a pointer to a <strong class="source-inline">LinkList</strong>. Upcasting is not allowed across a <strong class="source-inline">private</strong> base class boundary. This would allow a <strong class="source-inline">Stack</strong> to reveal its underlying implementation; C++ does not allow this to happen. Here, we see that a <strong class="source-inline">Stack</strong> is merely implemented in terms of a <strong class="source-inline">LinkList</strong>; we are not saying that a <strong class="source-inline">Stack</strong> <em class="italic">Is-A</em> <strong class="source-inline">LinkedList</strong>. This is the concept of implementation inheritance in its best light; this example illustrates implementation inheritance favorably.</p>
<p>Next, let’s move forward to see how we can use a <strong class="source-inline">protected</strong> base class, and how that differs from a <strong class="source-inline">private</strong> base class using implementation inheritance.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor360"/>Using a protected base class to implement one class in terms of another</h2>
<p>We have <a id="_idIndexMarker534"/>just implemented a <strong class="source-inline">Stack</strong> in terms of a <strong class="source-inline">LinkList</strong> using a <strong class="source-inline">private</strong> base class. Now, let’s <a id="_idIndexMarker535"/>implement a <strong class="source-inline">Queue</strong> and a <strong class="source-inline">PriorityQueue</strong>. We will implement a <strong class="source-inline">Queue</strong> using <strong class="source-inline">LinkList</strong> as a <strong class="source-inline">protected</strong> base class, and a <strong class="source-inline">PriorityQueue</strong> using <strong class="source-inline">Queue</strong> as a <strong class="source-inline">public</strong> base class. </p>
<p>Again, <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong> are Abstract Data Types. It is (relatively) unimportant how a <strong class="source-inline">Queue</strong> is implemented. The underlying implementation may change. Implementation inheritance allows us to implement our <strong class="source-inline">Queue</strong> using a <strong class="source-inline">LinkedList</strong> without revealing the underlying implementation to users of the <strong class="source-inline">Queue</strong> class. </p>
<p>Now, our class <strong class="source-inline">Queue</strong> will use <strong class="source-inline">LinkedList</strong> as a <strong class="source-inline">protected</strong> base class. <strong class="source-inline">Queue</strong> will define a public interface for its users to establish the expected interface for this ADT, such as <strong class="source-inline">Enqueue()</strong>, <strong class="source-inline">Dequeue()</strong>, <strong class="source-inline">IsEmpty()</strong>, and <strong class="source-inline">Print()</strong>. The implementation of these member functions will make use of selected <strong class="source-inline">LinkedList</strong> member functions, but <strong class="source-inline">Queue</strong> users will not see this, nor will <strong class="source-inline">Queue</strong> instances be able to use any <strong class="source-inline">LinkList</strong> members directly themselves. </p>
<p>Furthermore, our class <strong class="source-inline">PriorityQueue</strong> will extend <strong class="source-inline">Queue</strong> using <strong class="source-inline">public</strong> inheritance. That’s right, we’re back to Is-A. We are saying that a <strong class="source-inline">PriorityQueue</strong> <em class="italic">Is-A</em> <strong class="source-inline">Queue</strong>, and a <strong class="source-inline">Queue</strong> is implemented using a <strong class="source-inline">LinkedList</strong>. </p>
<p>We will just add a priority enqueuing method to our <strong class="source-inline">PriorityQueue</strong> class; this class will be glad to inherit the <strong class="source-inline">public</strong> interface from <strong class="source-inline">Queue</strong> (but obviously not from <strong class="source-inline">LinkList</strong>, which luckily is hidden behind a <strong class="source-inline">protected</strong> base class at its parent’s level).</p>
<p>The code to implement <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong> is again straightforward. The <strong class="source-inline">LinkList</strong> base class needs to be augmented to be more fully functional in order to proceed. The <strong class="source-inline">LinkListElement</strong> class can remain the same. We will show the basics of the <a id="_idIndexMarker536"/>revised <strong class="source-inline">LinkList</strong> class with only its class definition. The full code <a id="_idIndexMarker537"/>for both <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong> will be shown in a separate segment. The full program example can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp</a></p>
<pre class="source-code">
// class LinkListElement is as shown previously
// The enhanced class definition of LinkList is:
class LinkList
{
private:
    LinkListElement *head = nullptr;
    LinkListElement *tail = nullptr;
    LinkListElement *current = nullptr;
public:
    LinkList() = default;
    LinkList(LinkListElement *);
    ~LinkList();
    void InsertAtFront(Item *);  
    LinkListElement *RemoveAtFront();
    void DeleteAtFront();
    // Notice additional member functions added
    void InsertBeforeItem(Item *, Item *); 
    LinkListElement *RemoveSpecificItem(Item *);
    void DeleteSpecificItem(Item *);
    void InsertAtEnd(Item *);
    LinkListElement *RemoveAtEnd();
    void DeleteAtEnd();
    int IsEmpty() const { return head == nullptr; } 
    void Print() const;  
};
// Assume we have the implementation for the methods here…</pre>
<p>Notice that <strong class="source-inline">LinkList</strong> has been expanded to have a fuller set of features, such as being <a id="_idIndexMarker538"/>able to add, remove, and delete elements at various positions <a id="_idIndexMarker539"/>within the <strong class="source-inline">LinkList</strong>. To keep our examined code together brief, we will not show the implementation of these methods. </p>
<p>Now, let’s add the class definitions for <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong> in the next code segment:</p>
<pre class="source-code">
<a id="_idTextAnchor361"/>class Queue<strong class="bold">: protected LinkList</strong>
{
private:
    // no new data members are necessary
public: 
    // Constructor prototype shown below is not needed; 
    // we get default w/o prototype (since no other ctor)
    // Commented to remind what's automatically provided
    // Queue() = default;  // calls :LinkList() def. ctor
    // Destructor prototype is needed (per virtual keyword)
    virtual ~Queue() = default; // we'll see virtual Chp. 7
    // public interface of Queue
    void Enqueue(Item *i) { <strong class="bold">InsertAtEnd(i);</strong> }
    Item *Dequeue(); 
    // redefine these methods, LinkList is prot. base class
    int IsEmpty() const { return <strong class="bold">LinkList::IsEmpty();</strong> }
    void Print() { <strong class="bold">LinkList::Print();</strong> }
};
Item *Queue::Dequeue()
{
    LinkListElement *front;
    front = <strong class="bold">RemoveAtFront();</strong>
    // make copy of front's data
    Item *item = new Item(*(static_cast&lt;Item *&gt;
                            (front-&gt;GetData())));
    delete front; 
    return item;
}
class PriorityQueue<strong class="bold">: public Queue</strong>
{
private:
    // no new data members are necessary
public:
    // Constructor prototype shown below is not needed; 
    // we get default w/o protoype (since no other ctor)
    // Commented to remind what's automatically provided
    // PriorityQueue() = default; // calls :Queue() 
                                  // default constructor
    // destructor proto. is not needed for overriden dtor
    // ~PriorityQueue() override = default; // see Chp 7
    void PriorityEnqueue(Item *i1, Item *i2) 
    {  <strong class="bold">InsertBeforeItem(i1, i2);</strong> } // accessible in this 
};                                 // scope</pre>
<p>In the previous segment of code, we define the <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQue</strong> classes. Notice that <strong class="source-inline">Queue</strong> has a <strong class="source-inline">protected</strong> base class of <strong class="source-inline">LinkList</strong>. With a <strong class="source-inline">protected</strong> base class, the <strong class="source-inline">protected</strong> and <strong class="source-inline">public</strong> members inherited from <strong class="source-inline">LinkList</strong> act as though <a id="_idIndexMarker540"/>they are defined by <strong class="source-inline">Queue</strong> as <strong class="source-inline">protected</strong>, which means that these <a id="_idIndexMarker541"/>inherited members are not only accessible within the scope of <strong class="source-inline">Queue</strong>, but also within any potential descendants of <strong class="source-inline">Queue</strong>. As before, these restrictions only apply to the <strong class="source-inline">Queue</strong> class, its descendants, and their instances; the <strong class="source-inline">LinkList</strong> class and its instances are unaffected. </p>
<p>In the <strong class="source-inline">Queue</strong> class, no new data members are necessary. The internal implementation is handled by <strong class="source-inline">LinkList</strong>. With a <strong class="source-inline">protected</strong> base class, we are saying that the <strong class="source-inline">Queue</strong> is implemented using a <strong class="source-inline">LinkList</strong>. Nonetheless, we must provide the <strong class="source-inline">public</strong> interface for <strong class="source-inline">Queue</strong> and we do so by adding methods such as <strong class="source-inline">Queue::Enqueue()</strong>, <strong class="source-inline">Queue::Dequeue()</strong>, <strong class="source-inline">Queue::IsEmpty()</strong> and <strong class="source-inline">Queue::Print()</strong>. Notice that in their implementations, these methods merely call <strong class="source-inline">LinkList</strong> methods to perform the necessary operations. Users of <strong class="source-inline">Queue</strong> must use <strong class="source-inline">Queue</strong>’s public interface; the <em class="italic">once public</em> <strong class="source-inline">LinkList</strong> interface is hidden to <strong class="source-inline">Queue</strong> instances. </p>
<p>Next, we define <strong class="source-inline">PriorityQueue</strong>, another ADT. Notice that <strong class="source-inline">PriorityQueue</strong> defines <strong class="source-inline">Queue</strong> as a <strong class="source-inline">public</strong> base class. We are back to inheritance to support an Is-A relationship. A <strong class="source-inline">PriorityQueue</strong> <em class="italic">Is-A</em> <strong class="source-inline">Queue</strong> and can do everything a <strong class="source-inline">Queue</strong> can do, just a <a id="_idIndexMarker542"/>little more. As such, <strong class="source-inline">PriorityQueue</strong> inherits as usual from <strong class="source-inline">Queue</strong>, including <strong class="source-inline">Queue</strong>’s public interface. <strong class="source-inline">PriorityQueue</strong> needs only to add an <a id="_idIndexMarker543"/>additional method for priority enqueuing, namely <strong class="source-inline">PriorityQueue::PriorityEnqueue()</strong>.</p>
<p>Since <strong class="source-inline">Queue</strong> has a protected base class of <strong class="source-inline">LinkList</strong>, the <strong class="source-inline">public</strong> interface from <strong class="source-inline">LinkList</strong> is considered <strong class="source-inline">protected</strong> to <strong class="source-inline">Queue</strong> and its descendants, including <strong class="source-inline">PriorityQueue</strong>, so that <strong class="source-inline">LinkList</strong>’s <em class="italic">once public</em> methods are considered <strong class="source-inline">protected</strong> to both <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong>. Notice that <strong class="source-inline">PriorityQueue::PriorityEnqueue()</strong> makes use of <strong class="source-inline">LinkList::InsertBeforeItem()</strong>. This would not be possible if <strong class="source-inline">LinkList</strong> were a <strong class="source-inline">private</strong>, versus a <strong class="source-inline">protected</strong>, base class of <strong class="source-inline">Queue</strong>.</p>
<p>With the class definitions and implementation in place, let’s continue with our <strong class="source-inline">main()</strong> function:</p>
<pre class="source-code">
int main()
{
    <strong class="bold">Queue q1;</strong>   // Queue instance
    q1.Enqueue(new Item(50));
    q1.Enqueue(new Item(67));
    q1.Enqueue(new Item(80));
    q1.Print();
    while (!(q1.IsEmpty()))
    {
        q1.Dequeue();
        q1.Print();
    }
    <strong class="bold">PriorityQueue q2;</strong>   // PriorityQueue instance
    Item *item = new Item(167); // save a handle to item
    q2.Enqueue(new Item(67));   // first item added
    q2.Enqueue(item);           // second item
    q2.Enqueue(new Item(180));  // third item
    // add new item before an existing item
    q2.PriorityEnqueue(new Item(100), item); // 4<span class="superscript">th</span> item
    q2.Print();
    while (!(q2.IsEmpty()))
    {
       q2.Dequeue();
       q2.Print();
    }
    return 0;
}</pre>
<p>Now, in <strong class="source-inline">main()</strong>, we <a id="_idIndexMarker544"/>instantiate a <strong class="source-inline">Queue</strong>, namely <strong class="source-inline">q1</strong>, which utilizes the <a id="_idIndexMarker545"/>public interface of <strong class="source-inline">Queue</strong>. Note that <strong class="source-inline">q1</strong> may not use the <em class="italic">once public</em> interface of <strong class="source-inline">LinkList</strong>. The <strong class="source-inline">Queue</strong> may only behave like a <strong class="source-inline">Queue</strong>, not a <strong class="source-inline">LinkList</strong>. The ADT of <strong class="source-inline">Queue</strong> is preserved.</p>
<p>Finally, we instantiate a <strong class="source-inline">PriorityQueue</strong>, namely <strong class="source-inline">q2</strong>, which utilizes the public interface of both <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong>, such as <strong class="source-inline">Queue::Enqueue()</strong> and <strong class="source-inline">PriorityQueue::PriorityEnqueue()</strong>, respectively. Because a <strong class="source-inline">Queue</strong> <em class="italic">Is-A</em> <strong class="source-inline">PriorityQueue</strong> (<strong class="source-inline">Queue</strong> is the <strong class="source-inline">public</strong> base class), the typical mechanics of inheritance are in place, allowing <strong class="source-inline">PriorityQueue</strong> to utilize the public interface of its ancestors. </p>
<p>The output for this example is as follows:</p>
<p class="source-code">50 67 80</p>
<p class="source-code">67 80</p>
<p class="source-code">80</p>
<p class="source-code">&lt;EMPTY&gt;</p>
<p class="source-code">67 100 167 180</p>
<p class="source-code">100 167 180</p>
<p class="source-code">167 180</p>
<p class="source-code">180</p>
<p class="source-code">&lt;EMPTY&gt;</p>
<p>Finally, we have seen two examples of using implementation inheritance; it is not an often-used feature of C++. However, you now understand <strong class="source-inline">protected</strong> or <strong class="source-inline">private</strong> base classes should you run across them in library code, application code that you are maintaining, or the rare opportunity in which this technique may prove useful for a programming task you may encounter.</p>
<p class="callout-heading">Optional uses for =default</p>
<p class="callout">We have <a id="_idIndexMarker546"/>seen <strong class="source-inline">=default</strong> used in constructor and destructor prototypes to alleviate the user need to supply such method definitions. However, let’s recall some guidelines for when a constructor (or destructor) is provided for us automatically. In such cases, using <strong class="source-inline">=default</strong> with a constructor or destructor prototype will be more documentative in nature than a requirement; we will get the same system-supplied method in the absence of the <strong class="source-inline">=default</strong> prototype. </p>
<p class="callout">Using an <strong class="source-inline">=default</strong> prototype is not necessary if the default constructor is the only constructor in a class; recall that you will get a system-supplied default constructor if a class has no constructors (to provide an interface to instantiate the class). Using <strong class="source-inline">=default</strong> with a default constructor prototype is crucial, however, if there are other constructors in the class (not including the copy constructor) and you want to maintain the default object creation (construction) interface. For the copy constructor, if the default system-supplied version is adequate, you will get this method regardless of whether you use an <strong class="source-inline">=default</strong> prototype or omit the prototype entirely. Likewise, with the destructor, if the system-supplied version is adequate, you will get this version linked in regardless of whether you use an <strong class="source-inline">=default</strong> prototype or omit the prototype altogether; the latter style is becoming more prevalent. </p>
<p>We have <a id="_idIndexMarker547"/>now covered the basic features of single inheritance in C++. Let’s <a id="_idIndexMarker548"/>quickly review what we’ve covered before moving to the next chapter.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor362"/>Summary</h1>
<p>In this chapter, we have moved further along our journey with object-oriented programming. We have added additional OO concepts and terms, and have seen how C++ has direct language support for these concepts. We have seen how inheritance in C++ supports generalization and specialization. We have seen how to incrementally build a hierarchy of related classes.</p>
<p>We have seen how to grow inheritance hierarchies using single inheritance, and how to access inherited data members and member functions. We have reviewed access regions to understand which inherited members may be directly accessed, based upon the access regions in which the members are defined in the base class. We know that having a <strong class="source-inline">public</strong> base class equates to defining an Is-A relationship, which supports the ideals of generalization and specialization, which is the most commonly used reason for inheritance.</p>
<p>We have detailed the order of constructor and destructor invocations when instances of derived class types are instantiated and destroyed. We have seen the member initialization list to select which inherited constructor a derived class object may choose to utilize as part of its own construction (for its base class subobject). </p>
<p>We have seen how changing access labels in a base class list changes the OO meaning for the type of inheritance being used. By comparing <strong class="source-inline">public</strong> versus <strong class="source-inline">private</strong> and <strong class="source-inline">protected</strong> base classes, we now understand different types of hierarchies, such as those built to support Is-A relationships versus those built to support implementation inheritance.</p>
<p>We have seen that base classes in our hierarchies may serve as potential building blocks for more specialized components, leading to potential reuse. Any potential reuse of existing code saves development time and cuts down on maintenance of otherwise duplicated code.</p>
<p>Through extending our OOP knowledge, we have gained a preliminary set of skills relating to inheritance and hierarchy building in C++. With the basic mechanics of single inheritance under our belts, we can now move forward to learn about many more interesting object-oriented concepts and details relating to inheritance. Continuing to <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em>, we will next learn how to dynamically bind methods to their respective operations in a hierarchy of related classes. </p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor363"/>Questions</h1>
<ol>
<li>Using your <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, solution, create a C++ program to<a id="_idTextAnchor364"/> <a id="_idTextAnchor365"/>build an inheritance hierarchy, generalizing <strong class="source-inline">Person</strong> as a base class from the derived class of <strong class="source-inline">Student</strong>. <ol><li>Decide which data members and member functions of your <strong class="source-inline">Student</strong> class are more generic and would be better positioned in a <strong class="source-inline">Person</strong> class. Build your <strong class="source-inline">Person</strong> class with these members, including appropriate constructors (default, alternate, and copy), a destructor, access member functions, and a suitable public interface. Be sure to place your data members in the private access region.</li><li>Using a <strong class="source-inline">public</strong> base class, derive <strong class="source-inline">Student</strong> from <strong class="source-inline">Person</strong>. Remove members from <strong class="source-inline">Student</strong> that are now represented in <strong class="source-inline">Person</strong>. Adjust constructors and the destructor accordingly. Use the member initialization list to specify base class constructors as needed.</li><li>Instantiate both <strong class="source-inline">Student</strong> and <strong class="source-inline">Person</strong> several times and utilize the appropriate <strong class="source-inline">public</strong> interfaces on each. Be sure to dynamically allocate several instances. </li><li>Add a message using <strong class="source-inline">cout</strong> as the first line in each of your constructors and as the first line in your destructors so that you can see the construction and destruction order of each instance. </li></ol></li>
<li>(Optional) Complete the class hierarchy, which includes <strong class="source-inline">LinkList</strong>, <strong class="source-inline">Queue</strong>, and <strong class="source-inline">PriorityQueue</strong>, using the online code as a basis. Complete the remaining operations in the <strong class="source-inline">LinkList</strong> class, and call them as appropriate in the public interface of <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong>. <ol><li>Be sure to add copy constructors for each class (or prototype them in the private access region or use <strong class="source-inline">=delete</strong> in the prototype to suppress copying if you truly do not want to allow copies).</li><li>Instantiate <strong class="source-inline">LinkList</strong> using either constructor, then demonstrate how each of your operations works. Be sure to invoke <strong class="source-inline">Print()</strong> after adding or deleting an element. </li><li>Instantiate <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong>, and demonstrate that each of the operations in their <strong class="source-inline">public</strong> interfaces works correctly. Remember to demonstrate the inherited operations in the <strong class="source-inline">public</strong> interface of <strong class="source-inline">Queue</strong> for instances of <strong class="source-inline">PriorityQueue</strong>.</li></ol></li>
</ol>
</div>
</div></body></html>