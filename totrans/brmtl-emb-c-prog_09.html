<html><head></head><body>
<div><div><div><h1 id="_idParaDest-146" class="chapter-number"><a id="_idTextAnchor262"/>9</h1>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor263"/>General-Purpose Timers (TIM)</h1>
			<p>In this chapter, we will delve into <a id="_idIndexMarker590"/>the <strong class="bold">general-purpose timers</strong> (<strong class="bold">TIM</strong>) found in the STM32F411 microcontroller. Unlike the SysTick timer, these timer peripherals are unique to STM32 microcontrollers and offer a range of capabilities essential for various applications.</p>
			<p>We will begin by discussing the common uses of timers, providing a foundation for understanding their importance in embedded systems. Following this, we will explore the specific characteristics of the timers on STM32 microcontrollers. This includes understanding the timer clock source, the mechanics of prescaling, and a detailed look at the commonly used timer registers.</p>
			<p>In the latter part of the chapter, we will put theory into practice by developing a timer driver and applying the knowledge we’ve gained to create functional and efficient code.</p>
			<p>In this chapter, we’re going to cover the following main topics:<a id="_idTextAnchor264"/></p>
			<ul>
				<li>Introduction to timers and their uses</li>
				<li>Common use cases of timers<a id="_idTextAnchor265"/></li>
				<li>STM32 timers</li>
				<li>Developing the timer driver</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of STM32 timers and how to develop drivers for them, enhancing your ability to utilize these peripherals effectively in your projects.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor266"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor267"/>Introduction to timers and their uses</h1>
			<p>Timers are<a id="_idIndexMarker591"/> crucial components in embedded systems, serving essential functions in a wide array of applications. In this section, we will explore the concept of timers, their types, and their various applications.</p>
			<p>The question is, <em class="italic">What </em><em class="italic">are timers?</em></p>
			<p>Timers are hardware peripherals found in microcontrollers that <strong class="bold">count clock pulses</strong>. <strong class="bold">These pulses can be used to measure time intervals, generate precise delays, or trigger events at specific intervals</strong>. Timers can operate in several modes, including <strong class="bold">counting up</strong>, <strong class="bold">counting down</strong>, and <a id="_idIndexMarker592"/>generating <strong class="bold">Pulse Width Modulation</strong> (<strong class="bold">PWM</strong>) signals.</p>
			<p>The choice between using the<a id="_idIndexMarker593"/> SysTick timer and general-purpose timers on STM32 microcontrollers comes down to the complexity and precision of your timing needs. While the SysTick timer is great for simple system timing tasks such as generating periodic interrupts or creating delays, it’s limited in flexibility and features, as it’s often dedicated<a id="_idIndexMarker594"/> to <strong class="bold">real-time operating system</strong> (<strong class="bold">RTOS</strong>) ticks. On the other hand, general-purpose timers, as we have just discussed, offer far more versatility, with the ability to handle complex tasks such as PWM generation, input capture, and output compare. They also support multiple channels for concurrent timing events and provide advanced functionalities such as precise frequency measurement and low-power operation.</p>
			<p>Let’s explore some typical use cases to illustrate the importance of timers.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor268"/>Common use cases of timers</h1>
			<p>Let’s start<a id="_idIndexMarker595"/> with timers for time interval measurement.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor269"/>Time interval measurement</h2>
			<p>One<a id="_idIndexMarker596"/> common use of timers is in ultrasonic sensors for distance measurement, widely used in robotics, automotive parking systems, and obstacle detection.</p>
			<p>Timers play a vital role in the operation of these sensors. Here’s how they work:</p>
			<ol>
				<li>The microcontroller sends a trigger signal to the ultrasonic sensor, causing it to emit an ultrasonic pulse.</li>
				<li>The sensor<a id="_idIndexMarker597"/> waits for the echo of the pulse to return after bouncing off an object.</li>
				<li>A timer starts counting when the pulse is emitted and stops when the echo is received.</li>
				<li>The time interval measured by the timer is used to calculate the distance to the object based on the speed of sound.</li>
			</ol>
			<p>By accurately measuring the time interval between sending the pulse and receiving the echo, the system can determine the distance to objects, enabling precise navigation and obstacle avoidance.</p>
			<p>Timers are also essential for <a id="_idIndexMarker598"/>generating precise delays, such as in the refresh mechanism of <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>) matrix displays.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor270"/>Delay generation</h2>
			<p>In embedded<a id="_idIndexMarker599"/> systems, LED matrix displays are used for various applications, including digital signage, scoreboards, and simple graphical displays. To display images or text, the microcontroller needs to refresh the display at a precise rate to ensure smooth visuals.</p>
			<p>Over here, the following happens:</p>
			<ul>
				<li>The microcontroller drives an LED matrix display and needs to refresh the display rows sequentially.</li>
				<li>A timer generates precise delays to control the time each row is activated before moving to the next row.<p class="list-inset">For example, the timer might be set to generate a delay of 1 millisecond between switching rows.</p><p class="list-inset">This ensures that each row is displayed for a consistent period, maintaining a stable and flicker-free image.</p></li>
			</ul>
			<p>Now, let’s see an example of how timers can be used for triggering events in embedded systems.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor271"/>Event trigger</h2>
			<p>Periodic <a id="_idIndexMarker600"/>data sampling from sensors is important for applications<a id="_idIndexMarker601"/> such as environmental monitoring and <strong class="bold">industrial process control</strong> (<strong class="bold">IPC</strong>). A timer can be used to trigger the <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>) at<a id="_idIndexMarker602"/> specific intervals to ensure consistent data sampling.</p>
			<p>Over here, the following happens:</p>
			<ul>
				<li>The microcontroller is connected to an environmental sensor (for example, a temperature or humidity sensor) that outputs an analog signal</li>
				<li>A general-purpose timer is configured to trigger the ADC conversion periodically (for example, every 100 milliseconds)</li>
				<li>The ADC is set up to use the timer trigger option, automatically starting a conversion at each timer event</li>
				<li>The main loop of the microcontroller regularly checks for completed ADC conversions and processes the data</li>
			</ul>
			<p>In the next section, we will focus on the features and characteristics of STM32 timers.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor272"/>STM32 timers</h1>
			<p>The timers<a id="_idIndexMarker603"/> in STM32 microcontrollers are classified into two main categories: <strong class="bold">general-purpose timers</strong> and <strong class="bold">advanced timers</strong>.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor273"/>Introduction to general-purpose timers and advanced timers</h2>
			<p>General-purpose timers<a id="_idIndexMarker604"/> are highly versatile and can be used for a variety of applications, whereas advanced timers offer more sophisticated <a id="_idIndexMarker605"/>features than general-purpose timers, making them suitable for high-precision and complex timing tasks.</p>
			<p>In the <a id="_idIndexMarker606"/>STM32F411 microcontroller, timers <strong class="bold">TIM2</strong>, <strong class="bold">TIM3</strong>, <strong class="bold">TIM4</strong>, <strong class="bold">TIM5</strong>, <strong class="bold">TIM9</strong>, <strong class="bold">TIM10</strong>, and <strong class="bold">TIM11</strong> are general-purpose timers, whereas <strong class="bold">TIM1</strong> is an advanced timer.</p>
			<p>Key features <a id="_idIndexMarker607"/>of the <a id="_idIndexMarker608"/>general-purpose timers include the following:</p>
			<ul>
				<li><strong class="bold">Counter size</strong>: They feature 16-bit counters for TIM3 and TIM4 and 32-bit counters for TIM2 and TIM5, capable of operating in up, down, or up/down auto-reload modes</li>
				<li><strong class="bold">Prescaler</strong>: They are equipped with a 16-bit programmable prescaler, which allows us to divide the counter-clock frequency by any factor ranging from 1 to 65,536</li>
				<li><strong class="bold">Channels</strong>: They offer up to four independent channels</li>
				<li><strong class="bold">Synchronization</strong>: The timers can synchronize with external signals and interconnect with multiple timers, enhancing flexibility and coordination in complex applications</li>
				<li><strong class="bold">Interrupt/direct memory access (DMA) generation</strong>: The timers can generate interrupts or DMA requests based on various events, including counter overflow/underflow, counter initialization, trigger events, input capture, and output compare</li>
				<li><strong class="bold">Encoder support</strong>: These timers also support incremental (quadrature) encoders and Hall-sensor circuitry, making them suitable for precise positioning applications</li>
			</ul>
			<p>The <a id="_idIndexMarker609"/>advanced timer, TIM1, has a 16-bit counter size. Apart from the difference in counter size, it shares all the features of the general-purpose timers with the following <a id="_idIndexMarker610"/>additional features:</p>
			<ul>
				<li><strong class="bold">Complementary outputs</strong>: Support for complementary outputs with programmable dead-time insertion</li>
				<li><strong class="bold">Repetition counter</strong>: Allows updating the timer registers only after a specific number of counter cycles</li>
				<li><strong class="bold">Break input</strong>: It has the ability to put the timer’s output signals into a reset or known state <a id="_idIndexMarker611"/>upon activation</li>
			</ul>
			<p>Before we start analyzing <a id="_idIndexMarker612"/>some of the key registers provided in the reference manual, let’s first understand how STM32 timers work.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor274"/>How STM32 timers work</h2>
			<p>The core <a id="_idIndexMarker613"/>of the timer is the 16-bit/32-bit counter and its associated auto-reload register. The counter can count upward or downward, and its clock can be divided by a prescaler. We can read from and write to the counter, auto-reload register, and <a id="_idIndexMarker614"/>prescaler register even while the counter is running.</p>
			<p>The time-base unit includes the following registers:</p>
			<ul>
				<li><code>TIMx_CNT</code>)</li>
				<li><code>TIMx_PSC</code>)</li>
				<li><code>TIMx_ARR</code>)</li>
			</ul>
			<p>The <a id="_idIndexMarker615"/>prescaler register (<code>TIMx_PSC</code>) divides the timer’s input clock frequency by a programmable value between 1 and 65,536. This allows for slower counting rates to accommodate longer timing intervals.</p>
			<p>The <a id="_idIndexMarker616"/>auto-reload register (<code>TIMx_ARR</code>) defines the value at which the counter resets to zero in up-counting mode or to the auto-reload value in down-counting mode. We use it to set the period of the timer.</p>
			<p>Apart from the registers in the time-base unit, the timer peripheral also includes control registers (<code>TIMx_CR1</code>, <code>TIMx_CR2</code>, and so on) for configuring the various operational parameters, such <a id="_idIndexMarker617"/>as enabling the counter, setting the counting direction, and configuring <code>TIMx_SR</code>) indicates <a id="_idIndexMarker618"/>the status of the timer, such as whether a UEV has occurred and other auxiliary registers for controlling the timer, among other things.</p>
			<p>As we mentioned earlier, the timer has two counting modes: up-counting mode and down-counting mode. Let’s break them down:</p>
			<ul>
				<li><code>TIMx_ARR</code>) and generates a UEV on overflow</p></li>
				<li><strong class="bold">Down-counting mode</strong>:<p class="list-inset">The <a id="_idIndexMarker620"/>counter counts down from the auto-reload value to 0 and generates a UEV on underflow</p></li>
			</ul>
			<p>The next <a id="_idIndexMarker621"/>question that arises is: <em class="italic">What exactly is </em><em class="italic">a UEV?</em></p>
			<p>Let’s break this down:</p>
			<ul>
				<li>In simple terms, it is when the timeout should occur</li>
				<li>When the counter reaches the auto-reload value or 0 (based on the count mode), a UEV occurs</li>
				<li>This event can trigger an <a id="_idIndexMarker622"/>interrupt or a DMA request and set the <code>TIMx_SR</code>)</li>
				<li>UEVs can also be generated manually by <a id="_idIndexMarker623"/>setting the <code>TIMx_EGR</code>)</li>
			</ul>
			<p>Now that we know what a UEV is, let’s understand how timer clock prescaling is achieved; this will enable us to accurately calculate the timing for UEVs.</p>
			<h3>Timer clock prescaling</h3>
			<p>We use <a id="_idIndexMarker624"/>prescaling to reduce the high-frequency system clock to a lower frequency suitable for driving the timer. <em class="italic">Figure 9</em><em class="italic">.1</em> illustrates the process of timer clock pre-scaling in our STM32 microcontroller, showing how the system clock (<code>SYSCLK</code>) is divided down to drive the timer counters (<code>TIMx_CNT</code>) through a series of prescalers:</p>
			<div><div><img src="img/B21914_09_1.jpg" alt="Figure 9.1: Timer clock prescaling" width="1650" height="627"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Timer clock prescaling</p>
			<p>Let’s explain <a id="_idIndexMarker625"/>each component and step involved in this process:</p>
			<ul>
				<li><strong class="bold">System </strong><strong class="bold">clock (SYSCLK)</strong><p class="list-inset">This is the<a id="_idIndexMarker626"/> main system clock that drives the microcontroller. It serves as the initial clock source for all subsequent operations.</p></li>
				<li><code>SYSCLK</code> frequency by a factor of 1, 2, 4, 8, 16, 64, 128, 256, or 512. The resulting clock signal is referred to as <strong class="bold">HCLK</strong> (AHB clock).</p></li>
				<li><strong class="bold">High-performance Bus </strong><strong class="bold">Clock (HCLK)</strong><p class="list-inset">This is <a id="_idIndexMarker628"/>the clock signal generated after the AHB prescaler. It is used to drive the core and the system bus.</p></li>
				<li><strong class="bold">Advanced Peripheral Bus (</strong><strong class="bold">APB) prescalers</strong><ul><li><strong class="bold">APB1 prescaler</strong>: This<a id="_idIndexMarker629"/> further divides HCLK to generate the clock for the APB1 peripheral bus. The division factors available are 1, 2, 4, 8, and 16.</li><li><strong class="bold">APB2 prescaler</strong>: Similar to the APB1 prescaler but used for the APB2 peripheral bus. It also <a id="_idIndexMarker630"/>divides HCLK by factors of 1, 2, 4, 8, and 16.</li></ul></li>
				<li><strong class="bold">Timer </strong><strong class="bold">prescaler (TIMx_PSC)</strong><p class="list-inset">Each<a id="_idIndexMarker631"/> timer has its own prescaler register that can divide the APB1 or APB2 clock further by any value between 1 and 65,535. This flexibility allows for precise control over the timer’s counting rate.</p></li>
				<li><code>TIMx_PSC</code>. The rate at which this counter increments or decrements depends on the combined division effect of the previous prescalers.</p></li>
			</ul>
			<p>The prescalers<a id="_idIndexMarker633"/> directly influence the rate at which the timer counter (<code>TIMx_CNT</code>) increments or decrements. While the other prescalers (AHB and APB) are shared among all peripherals on the same bus, <code>TIMx_PSC</code> prescaler, we can precisely control the resolution and period of that specific timer without affecting other peripherals.</p>
			<p>Now, let’s learn how to compute a UEV.</p>
			<h3>Computing a UEV</h3>
			<p>A <a id="_idIndexMarker634"/>UEV occurs <a id="_idIndexMarker635"/>when the timer counter reaches the value set in the auto-reload register (<code>TIMx_ARR</code>) in up-counting mode. Calculating this event is crucial for determining the timer’s period and ensuring it operates at the desired frequency.</p>
			<p>We can derive the freq<a id="_idTextAnchor275"/>uency of the UEV with the following formula:</p>
			<p>Update Event Frequency = <img src="img/1.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;X&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.560em;height:2.107em;width:13.513em" width="396" height="54"/></p>
			<p>Here, we have the following:</p>
			<ul>
				<li><code>SYSCLK</code> when using the default clock configuration (in a bare-metal setup) on the NUCLEO-F411 development board.</li>
				<li><code>TIMx_PSC</code> register.</li>
				<li><code>TIMx_ARR</code> register.</li>
			</ul>
			<p>Let’s see <a id="_idIndexMarker636"/>an example. Let’s say we have the following parameters:</p>
			<ul>
				<li><strong class="bold">Timer clock (APB1 clock)</strong>: 16 MHz</li>
				<li><strong class="bold">Prescaler (TIMx_PSC </strong><strong class="bold">value)</strong>: 15999</li>
				<li><strong class="bold">Period (TIMx_ARR </strong><strong class="bold">value):</strong> 499</li>
			</ul>
			<p>This means<a id="_idIndexMarker637"/> we have the following values:</p>
			<ul>
				<li>The timer clock is 16,000,000 Hz</li>
				<li>The <code>TIMx_PSC</code> register is set to 15999, but since the prescaler divides the clock by the value plus one, we use 15999 + 1 = 16000</li>
				<li>The <code>TIMx_ARR</code> register is set to 499, but since the period counts to the value plus one, we use 499 + 1 = 500</li>
			</ul>
			<p>Plugging these values into our formula, we get the following:</p>
			<p>Update Event Frequency =<img src="img/2.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mn&gt;16,000,000&lt;/mn&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;15999&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;X&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;499&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.383em;height:2.036em;width:8.737em" width="335" height="60"/></p>
			<p> =<img src="img/3.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mn&gt;16,000,000&lt;/mn&gt;&lt;mn&gt;8000000&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.292em;height:1.945em;width:4.731em" width="159" height="55"/> </p>
			<p>= 2Hz</p>
			<p>This means the UEV occurs at a frequency of <strong class="bold">2 Hz, or twice every second</strong>. This concludes this section. In the next section, we will develop our timer driver.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor276"/>Developing the timer driver</h1>
			<p>In this section, we <a id="_idIndexMarker638"/>will apply the knowledge gained about the TIM peripheral to develop a driver for generating delays.</p>
			<p>First, create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project <code>GTIM</code>. Next, create a new file named <code>tim.c</code> in the <code>Src</code> folder and another file named <code>tim.h</code> in the <code>Inc</code> folder.</p>
			<p>Our goal is to develop a driver that initializes TIM2 to generate a 1 Hz timeout. Populate your <code>tim.c</code> file with the following code:</p>
			<pre class="source-code">
#include "tim.h"
#define TIM2EN        (1U&lt;&lt;0)
#define CR1_CEN        (1U&lt;&lt;0)
void tim2_1hz_init(void)
{
    /*Enable clock access to tim2*/
    RCC-&gt;APB1ENR |=TIM2EN;
    /*Set prescaler value*/
    TIM2-&gt;PSC =  1600 - 1 ;
    /*Set auto-reload value*/
    TIM2-&gt;ARR =  10000 - 1;
    /*Clear counter*/
    TIM2-&gt;CNT = 0;
    /*Enable timer*/
    TIM2-&gt;CR1 = CR1_CEN;
}</pre>			<p>Let’s break it down:</p>
			<pre class="source-code">
#define TIM2EN    (1U&lt;&lt;0)
#define CR1_CEN   (1U&lt;&lt;0)</pre>			<p>The <code>TIM2EN</code> instance <a id="_idIndexMarker639"/>is defined as <code>(1U&lt;&lt;0)</code>, which sets bit 0. This is used to enable the clock for TIM2.</p>
			<p>The <code>CR1_CEN</code> instance is defined as <code>(1U&lt;&lt;0)</code>, which also sets bit 0. This is used to enable the counter in the TIM2 control register 1 (<code>CR1</code>):</p>
			<pre class="source-code">
    /* Enable clock access to TIM2 */
    RCC-&gt;APB1ENR |= TIM2EN;</pre>			<p>This line enables the clock for TIM2 by setting the appropriate bit in the APB1 peripheral clock enable register (<code>RCC-&gt;APB1ENR</code>):</p>
			<pre class="source-code">
    /* Set prescaler value */
    TIM2-&gt;PSC = 1600 - 1;  // 16,000,000 / 1,600 = 10,000</pre>			<p>The<a id="_idIndexMarker640"/> prescaler value is set to 1599. The prescaler divides the input clock frequency (16 MHz) by (1599 + 1), resulting in a 10,000 Hz (10 kHz) timer clock:</p>
			<pre class="source-code">
    /* Set auto-reload value */
    TIM2-&gt;ARR = 10000 - 1;</pre>			<p>The auto-reload value is set to 9999. This means the timer will count from 0 to 9999, creating a period of 10,000 ticks. Since the timer clock is 10 kHz, counting 10,000 ticks results in 1 second (10,000 / 10,000 Hz = 1 s):</p>
			<pre class="source-code">
    /* Clear counter */
    TIM2-&gt;CNT = 0;</pre>			<p>This line resets the timer counter to 0. It ensures that the counting starts from 0 when the timer is enabled:</p>
			<pre class="source-code">
    /* Enable timer */
    TIM2-&gt;CR1 = CR1_CEN;</pre>			<p>This line enables the timer by setting the <code>CEN</code> (Counter Enable) bit in the TIM2 control register 1 (<code>CR1</code>). This starts the timer, and it begins counting based on the configured prescaler and auto-reload values.</p>
			<p>In summary, our code accomplishes the following:</p>
			<ol>
				<li>Enables the clock for TIM2.</li>
				<li>Sets a prescaler value to divide the input clock to 10 kHz.</li>
				<li>Sets an auto-reload value to make the timer count up to 10,000, creating a 1-second period.</li>
				<li>Clears the timer counter.</li>
				<li>Enables the timer.</li>
			</ol>
			<p>Our<a id="_idIndexMarker641"/> next task is to populate the <code>tim.h</code> file.</p>
			<p>Here is the code:</p>
			<pre class="source-code">
#include "stm32f4xx.h"
#ifndef TIM_H_
#define TIM_H_
#define SR_UIF  (1U&lt;&lt;0)
void tim2_1hz_init(void);
#endif</pre>			<p>The following line defines a <code>SR_UIF</code> macro that sets the 0th bit (least significant bit) to 1:</p>
			<pre class="source-code">
#define SR_UIF  (1U &lt;&lt; 0)</pre>			<p>This bit represents the UIF in the SR of the timer. When the timer overflows or reaches the auto-reload value, this flag is set, indicating a UEV. We will need to access this bit in the <code>main.c</code> file.</p>
			<p>We are now ready to test inside <code>main.c</code>.</p>
			<p>Update your <code>main.c</code> file as shown next:</p>
			<pre class="source-code">
#include "gpio.h"
#include "tim.h"
int main(void)
{
    /*Initialize LED*/
    led_init();
    /*Initialize timer*/
    tim2_1hz_init();
    while(1)
    {
           led_toggle();
            /*Wait for UIF */
           while(!(TIM2-&gt;SR &amp; SR_UIF)){}
           /*Clear UIF*/
           TIM2-&gt;SR &amp;=~SR_UIF;
    }
}</pre>			<p>In this code, we<a id="_idIndexMarker642"/> initialize the LED and TIM2 to toggle the LED at a 1 Hz frequency. The code works by waiting for the timer’s UIF to be set, indicating that 1 second has passed, then toggling the LED and clearing the UIF to repeat the process. This cycle continues indefinitely in the main loop, resulting in the LED toggling every second.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor277"/>Summary</h1>
			<p>In this chapter, we explored the general-purpose timers (TIM) in the STM32F411 microcontroller, which are distinct from the SysTick timer and offer a variety of features crucial for embedded systems applications. We began by discussing the fundamental uses of timers, emphasizing their importance in tasks such as time interval measurement, delay generation, and event triggering.</p>
			<p>We then learned about the specifics of STM32 timers, detailing their classification into general-purpose and advanced timers.</p>
			<p>Next, we examined the workings of STM32 timers, focusing on key registers such as the counter register (<code>TIMx_CNT</code>), prescaler register (<code>TIMx_PSC</code>), and auto-reload register (<code>TIMx_ARR</code>). We explained how the timer’s clock prescaling mechanism reduces the system clock to a suitable frequency for the timer and how this affects the timer’s operation.</p>
			<p>We also provided a practical example of computing UEV frequency, demonstrating how to calculate the period and frequency of the timer based on the prescaler and auto-reload values.</p>
			<p>Finally, we applied the theoretical knowledge by developing a timer driver for TIM2 to generate a 1 Hz timeout. In the next chapter, we will learn about another useful peripheral.</p>
		</div>
	</div>
</div>
</body></html>