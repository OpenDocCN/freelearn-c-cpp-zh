<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer090">
			<h1 id="_idParaDest-146" class="chapter-number"><a id="_idTextAnchor262"/>9</h1>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor263"/>General-Purpose Timers (TIM)</h1>
			<p>In this chapter, we will delve into <a id="_idIndexMarker590"/>the <strong class="bold">general-purpose timers</strong> (<strong class="bold">TIM</strong>) found in the STM32F411 microcontroller. Unlike the SysTick timer, these timer peripherals are unique to STM32 microcontrollers and offer a range of capabilities essential for <span class="No-Break">various applications.</span></p>
			<p>We will begin by discussing the common uses of timers, providing a foundation for understanding their importance in embedded systems. Following this, we will explore the specific characteristics of the timers on STM32 microcontrollers. This includes understanding the timer clock source, the mechanics of prescaling, and a detailed look at the commonly used <span class="No-Break">timer registers.</span></p>
			<p>In the latter part of the chapter, we will put theory into practice by developing a timer driver and applying the knowledge we’ve gained to create functional and <span class="No-Break">efficient code.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span><a id="_idTextAnchor264"/></p>
			<ul>
				<li>Introduction to timers and <span class="No-Break">their uses</span></li>
				<li>Common use cases <span class="No-Break">of timers</span><a id="_idTextAnchor265"/></li>
				<li><span class="No-Break">STM32 timers</span></li>
				<li>Developing the <span class="No-Break">timer driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of STM32 timers and how to develop drivers for them, enhancing your ability to utilize these peripherals effectively in <span class="No-Break">your projects.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor266"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor267"/>Introduction to timers and their uses</h1>
			<p>Timers are<a id="_idIndexMarker591"/> crucial components in embedded systems, serving essential functions in a wide array of applications. In this section, we will explore the concept of timers, their types, and their <span class="No-Break">various applications.</span></p>
			<p>The question is, <em class="italic">What </em><span class="No-Break"><em class="italic">are timers?</em></span></p>
			<p>Timers are hardware peripherals found in microcontrollers that <strong class="bold">count clock pulses</strong>. <strong class="bold">These pulses can be used to measure time intervals, generate precise delays, or trigger events at specific intervals</strong>. Timers can operate in several modes, including <strong class="bold">counting up</strong>, <strong class="bold">counting down</strong>, and <a id="_idIndexMarker592"/>generating <strong class="bold">Pulse Width Modulation</strong> (<span class="No-Break"><strong class="bold">PWM</strong></span><span class="No-Break">) signals.</span></p>
			<p>The choice between using the<a id="_idIndexMarker593"/> SysTick timer and general-purpose timers on STM32 microcontrollers comes down to the complexity and precision of your timing needs. While the SysTick timer is great for simple system timing tasks such as generating periodic interrupts or creating delays, it’s limited in flexibility and features, as it’s often dedicated<a id="_idIndexMarker594"/> to <strong class="bold">real-time operating system</strong> (<strong class="bold">RTOS</strong>) ticks. On the other hand, general-purpose timers, as we have just discussed, offer far more versatility, with the ability to handle complex tasks such as PWM generation, input capture, and output compare. They also support multiple channels for concurrent timing events and provide advanced functionalities such as precise frequency measurement and <span class="No-Break">low-power operation.</span></p>
			<p>Let’s explore some typical use cases to illustrate the importance <span class="No-Break">of timers.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor268"/>Common use cases of timers</h1>
			<p>Let’s start<a id="_idIndexMarker595"/> with timers for time <span class="No-Break">interval measurement.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor269"/>Time interval measurement</h2>
			<p>One<a id="_idIndexMarker596"/> common use of timers is in ultrasonic sensors for distance measurement, widely used in robotics, automotive parking systems, and <span class="No-Break">obstacle detection.</span></p>
			<p>Timers play a vital role in the operation of these sensors. Here’s how <span class="No-Break">they work:</span></p>
			<ol>
				<li>The microcontroller sends a trigger signal to the ultrasonic sensor, causing it to emit an <span class="No-Break">ultrasonic pulse.</span></li>
				<li>The sensor<a id="_idIndexMarker597"/> waits for the echo of the pulse to return after bouncing off <span class="No-Break">an object.</span></li>
				<li>A timer starts counting when the pulse is emitted and stops when the echo <span class="No-Break">is received.</span></li>
				<li>The time interval measured by the timer is used to calculate the distance to the object based on the speed <span class="No-Break">of sound.</span></li>
			</ol>
			<p>By accurately measuring the time interval between sending the pulse and receiving the echo, the system can determine the distance to objects, enabling precise navigation and <span class="No-Break">obstacle avoidance.</span></p>
			<p>Timers are also essential for <a id="_idIndexMarker598"/>generating precise delays, such as in the refresh mechanism of <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>) <span class="No-Break">matrix displays.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor270"/>Delay generation</h2>
			<p>In embedded<a id="_idIndexMarker599"/> systems, LED matrix displays are used for various applications, including digital signage, scoreboards, and simple graphical displays. To display images or text, the microcontroller needs to refresh the display at a precise rate to ensure <span class="No-Break">smooth visuals.</span></p>
			<p>Over here, the <span class="No-Break">following happens:</span></p>
			<ul>
				<li>The microcontroller drives an LED matrix display and needs to refresh the display <span class="No-Break">rows sequentially.</span></li>
				<li>A timer generates precise delays to control the time each row is activated before moving to the <span class="No-Break">next row.</span><p class="list-inset">For example, the timer might be set to generate a delay of 1 millisecond between <span class="No-Break">switching rows.</span></p><p class="list-inset">This ensures that each row is displayed for a consistent period, maintaining a stable and <span class="No-Break">flicker-free image.</span></p></li>
			</ul>
			<p>Now, let’s see an example of how timers can be used for triggering events in <span class="No-Break">embedded systems.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor271"/>Event trigger</h2>
			<p>Periodic <a id="_idIndexMarker600"/>data sampling from sensors is important for applications<a id="_idIndexMarker601"/> such as environmental monitoring and <strong class="bold">industrial process control</strong> (<strong class="bold">IPC</strong>). A timer can be used to trigger the <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>) at<a id="_idIndexMarker602"/> specific intervals to ensure consistent <span class="No-Break">data sampling.</span></p>
			<p>Over here, the <span class="No-Break">following happens:</span></p>
			<ul>
				<li>The microcontroller is connected to an environmental sensor (for example, a temperature or humidity sensor) that outputs an <span class="No-Break">analog signal</span></li>
				<li>A general-purpose timer is configured to trigger the ADC conversion periodically (for example, every <span class="No-Break">100 milliseconds)</span></li>
				<li>The ADC is set up to use the timer trigger option, automatically starting a conversion at each <span class="No-Break">timer event</span></li>
				<li>The main loop of the microcontroller regularly checks for completed ADC conversions and processes <span class="No-Break">the data</span></li>
			</ul>
			<p>In the next section, we will focus on the features and characteristics of <span class="No-Break">STM32 timers.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor272"/>STM32 timers</h1>
			<p>The timers<a id="_idIndexMarker603"/> in STM32 microcontrollers are classified into two main categories: <strong class="bold">general-purpose timers</strong> and <span class="No-Break"><strong class="bold">advanced timers</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor273"/>Introduction to general-purpose timers and advanced timers</h2>
			<p>General-purpose timers<a id="_idIndexMarker604"/> are highly versatile and can be used for a variety of applications, whereas advanced timers offer more sophisticated <a id="_idIndexMarker605"/>features than general-purpose timers, making them suitable for high-precision and complex <span class="No-Break">timing tasks.</span></p>
			<p>In the <a id="_idIndexMarker606"/>STM32F411 microcontroller, timers <strong class="bold">TIM2</strong>, <strong class="bold">TIM3</strong>, <strong class="bold">TIM4</strong>, <strong class="bold">TIM5</strong>, <strong class="bold">TIM9</strong>, <strong class="bold">TIM10</strong>, and <strong class="bold">TIM11</strong> are general-purpose timers, whereas <strong class="bold">TIM1</strong> is an <span class="No-Break">advanced timer.</span></p>
			<p>Key features <a id="_idIndexMarker607"/>of the <a id="_idIndexMarker608"/>general-purpose timers include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Counter size</strong>: They feature 16-bit counters for TIM3 and TIM4 and 32-bit counters for TIM2 and TIM5, capable of operating in up, down, or up/down <span class="No-Break">auto-reload modes</span></li>
				<li><strong class="bold">Prescaler</strong>: They are equipped with a 16-bit programmable prescaler, which allows us to divide the counter-clock frequency by any factor ranging from 1 <span class="No-Break">to 65,536</span></li>
				<li><strong class="bold">Channels</strong>: They offer up to four <span class="No-Break">independent channels</span></li>
				<li><strong class="bold">Synchronization</strong>: The timers can synchronize with external signals and interconnect with multiple timers, enhancing flexibility and coordination in <span class="No-Break">complex applications</span></li>
				<li><strong class="bold">Interrupt/direct memory access (DMA) generation</strong>: The timers can generate interrupts or DMA requests based on various events, including counter overflow/underflow, counter initialization, trigger events, input capture, and <span class="No-Break">output compare</span></li>
				<li><strong class="bold">Encoder support</strong>: These timers also support incremental (quadrature) encoders and Hall-sensor circuitry, making them suitable for precise <span class="No-Break">positioning applications</span></li>
			</ul>
			<p>The <a id="_idIndexMarker609"/>advanced timer, TIM1, has a 16-bit counter size. Apart from the difference in counter size, it shares all the features of the general-purpose timers with the following <a id="_idIndexMarker610"/><span class="No-Break">additional features:</span></p>
			<ul>
				<li><strong class="bold">Complementary outputs</strong>: Support for complementary outputs with programmable <span class="No-Break">dead-time insertion</span></li>
				<li><strong class="bold">Repetition counter</strong>: Allows updating the timer registers only after a specific number of <span class="No-Break">counter cycles</span></li>
				<li><strong class="bold">Break input</strong>: It has the ability to put the timer’s output signals into a reset or known state <a id="_idIndexMarker611"/><span class="No-Break">upon activation</span></li>
			</ul>
			<p>Before we start analyzing <a id="_idIndexMarker612"/>some of the key registers provided in the reference manual, let’s first understand how STM32 <span class="No-Break">timers work.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor274"/>How STM32 timers work</h2>
			<p>The core <a id="_idIndexMarker613"/>of the timer is the 16-bit/32-bit counter and its associated auto-reload register. The counter can count upward or downward, and its clock can be divided by a prescaler. We can read from and write to the counter, auto-reload register, and <a id="_idIndexMarker614"/>prescaler register even while the counter <span class="No-Break">is running.</span></p>
			<p>The time-base unit includes the <span class="No-Break">following registers:</span></p>
			<ul>
				<li><strong class="bold">Counter </strong><span class="No-Break"><strong class="bold">register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">TIMx_CNT</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Prescaler </strong><span class="No-Break"><strong class="bold">register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">TIMx_PSC</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Auto-reload </strong><span class="No-Break"><strong class="bold">register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">TIMx_ARR</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>The <a id="_idIndexMarker615"/>prescaler register (<strong class="source-inline">TIMx_PSC</strong>) divides the timer’s input clock frequency by a programmable value between 1 and 65,536. This allows for slower counting rates to accommodate longer <span class="No-Break">timing intervals.</span></p>
			<p>The <a id="_idIndexMarker616"/>auto-reload register (<strong class="source-inline">TIMx_ARR</strong>) defines the value at which the counter resets to zero in up-counting mode or to the auto-reload value in down-counting mode. We use it to set the period of <span class="No-Break">the timer.</span></p>
			<p>Apart from the registers in the time-base unit, the timer peripheral also includes control registers (<strong class="source-inline">TIMx_CR1</strong>, <strong class="source-inline">TIMx_CR2</strong>, and so on) for configuring the various operational parameters, such <a id="_idIndexMarker617"/>as enabling the counter, setting the counting direction, and configuring <strong class="bold">update events</strong> (<strong class="bold">UEVs</strong>). A <strong class="bold">status register</strong> (<strong class="bold">SR</strong>) (<strong class="source-inline">TIMx_SR</strong>) indicates <a id="_idIndexMarker618"/>the status of the timer, such as whether a UEV has occurred and other auxiliary registers for controlling the timer, among <span class="No-Break">other things.</span></p>
			<p>As we mentioned earlier, the timer has two counting modes: up-counting mode and down-counting mode. Let’s break <span class="No-Break">them down:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Up-counting mode</strong></span><span class="No-Break">:</span><p class="list-inset">The counter <a id="_idIndexMarker619"/>counts from 0 to the auto-reload value (<strong class="source-inline">TIMx_ARR</strong>) and generates a UEV <span class="No-Break">on overflow</span></p></li>
				<li><span class="No-Break"><strong class="bold">Down-counting mode</strong></span><span class="No-Break">:</span><p class="list-inset">The <a id="_idIndexMarker620"/>counter counts down from the auto-reload value to 0 and generates a UEV <span class="No-Break">on underflow</span></p></li>
			</ul>
			<p>The next <a id="_idIndexMarker621"/>question that arises is: <em class="italic">What exactly is </em><span class="No-Break"><em class="italic">a UEV?</em></span></p>
			<p>Let’s break <span class="No-Break">this down:</span></p>
			<ul>
				<li>In simple terms, it is when the timeout <span class="No-Break">should occur</span></li>
				<li>When the counter reaches the auto-reload value or 0 (based on the count mode), a <span class="No-Break">UEV occurs</span></li>
				<li>This event can trigger an <a id="_idIndexMarker622"/>interrupt or a DMA request and set the <strong class="bold">update interrupt flag</strong> (<strong class="bold">UIF</strong>) in the <span class="No-Break">SR (</span><span class="No-Break"><strong class="source-inline">TIMx_SR</strong></span><span class="No-Break">)</span></li>
				<li>UEVs can also be generated manually by <a id="_idIndexMarker623"/>setting the <strong class="bold">UG</strong> bit in the event generation register (<span class="No-Break"><strong class="source-inline">TIMx_EGR</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Now that we know what a UEV is, let’s understand how timer clock prescaling is achieved; this will enable us to accurately calculate the timing <span class="No-Break">for UEVs.</span></p>
			<h3>Timer clock prescaling</h3>
			<p>We use <a id="_idIndexMarker624"/>prescaling to reduce the high-frequency system clock to a lower frequency suitable for driving the timer. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> illustrates the process of timer clock pre-scaling in our STM32 microcontroller, showing how the system clock (<strong class="source-inline">SYSCLK</strong>) is divided down to drive the timer counters (<strong class="source-inline">TIMx_CNT</strong>) through a series <span class="No-Break">of prescalers:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B21914_09_1.jpg" alt="Figure 9.1: Timer clock prescaling" width="1650" height="627"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: Timer clock prescaling</p>
			<p>Let’s explain <a id="_idIndexMarker625"/>each component and step involved in <span class="No-Break">this process:</span></p>
			<ul>
				<li><strong class="bold">System </strong><span class="No-Break"><strong class="bold">clock (SYSCLK)</strong></span><p class="list-inset">This is the<a id="_idIndexMarker626"/> main system clock that drives the microcontroller. It serves as the initial clock source for all <span class="No-Break">subsequent operations.</span></p></li>
				<li><strong class="bold">Advanced High-performance Bus (</strong><span class="No-Break"><strong class="bold">AHB) prescaler</strong></span><p class="list-inset">This is the <a id="_idIndexMarker627"/>first prescaler in the chain, which divides the <strong class="source-inline">SYSCLK</strong> frequency by a factor of 1, 2, 4, 8, 16, 64, 128, 256, or 512. The resulting clock signal is referred to as <strong class="bold">HCLK</strong> (<span class="No-Break">AHB clock).</span></p></li>
				<li><strong class="bold">High-performance Bus </strong><span class="No-Break"><strong class="bold">Clock (HCLK)</strong></span><p class="list-inset">This is <a id="_idIndexMarker628"/>the clock signal generated after the AHB prescaler. It is used to drive the core and the <span class="No-Break">system bus.</span></p></li>
				<li><strong class="bold">Advanced Peripheral Bus (</strong><span class="No-Break"><strong class="bold">APB) prescalers</strong></span><ul><li><strong class="bold">APB1 prescaler</strong>: This<a id="_idIndexMarker629"/> further divides HCLK to generate the clock for the APB1 peripheral bus. The division factors available are 1, 2, 4, 8, <span class="No-Break">and 16.</span></li><li><strong class="bold">APB2 prescaler</strong>: Similar to the APB1 prescaler but used for the APB2 peripheral bus. It also <a id="_idIndexMarker630"/>divides HCLK by factors of 1, 2, 4, 8, <span class="No-Break">and 16.</span></li></ul></li>
				<li><strong class="bold">Timer </strong><span class="No-Break"><strong class="bold">prescaler (TIMx_PSC)</strong></span><p class="list-inset">Each<a id="_idIndexMarker631"/> timer has its own prescaler register that can divide the APB1 or APB2 clock further by any value between 1 and 65,535. This flexibility allows for precise control over the timer’s <span class="No-Break">counting rate.</span></p></li>
				<li><strong class="bold">Timer </strong><span class="No-Break"><strong class="bold">counter (TIMx_CNT)</strong></span><p class="list-inset">This is <a id="_idIndexMarker632"/>the final counter that uses the clock derived from <strong class="source-inline">TIMx_PSC</strong>. The rate at which this counter increments or decrements depends on the combined division effect of the <span class="No-Break">previous prescalers.</span></p></li>
			</ul>
			<p>The prescalers<a id="_idIndexMarker633"/> directly influence the rate at which the timer counter (<strong class="source-inline">TIMx_CNT</strong>) increments or decrements. While the other prescalers (AHB and APB) are shared among all peripherals on the same bus, <strong class="bold">the TIMx_PSC prescaler is unique to each timer</strong>. By adjusting the <strong class="source-inline">TIMx_PSC</strong> prescaler, we can precisely control the resolution and period of that specific timer without affecting <span class="No-Break">other peripherals.</span></p>
			<p>Now, let’s learn how to compute <span class="No-Break">a UEV.</span></p>
			<h3>Computing a UEV</h3>
			<p>A <a id="_idIndexMarker634"/>UEV occurs <a id="_idIndexMarker635"/>when the timer counter reaches the value set in the auto-reload register (<strong class="source-inline">TIMx_ARR</strong>) in up-counting mode. Calculating this event is crucial for determining the timer’s period and ensuring it operates at the <span class="No-Break">desired frequency.</span></p>
			<p>We can derive the freq<a id="_idTextAnchor275"/>uency of the UEV with the <span class="No-Break">following formula:</span></p>
			<p>Update Event Frequency = <img src="image/1.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;X&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.560em;height:2.107em;width:13.513em" width="396" height="54"/></p>
			<p>Here, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Timer clock</strong>: The clock frequency driving the timer (APB1 or APB2). The APB1 and APB2 bus frequencies are equal to <strong class="source-inline">SYSCLK</strong> when using the default clock configuration (in a bare-metal setup) on the NUCLEO-F411 <span class="No-Break">development board.</span></li>
				<li><strong class="bold">Prescaler</strong>: The value set in the <span class="No-Break"><strong class="source-inline">TIMx_PSC</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="bold">Period</strong>: The value set in the <span class="No-Break"><strong class="source-inline">TIMx_ARR</strong></span><span class="No-Break"> register.</span></li>
			</ul>
			<p>Let’s see <a id="_idIndexMarker636"/>an example. Let’s say we have the <span class="No-Break">following parameters:</span></p>
			<ul>
				<li><strong class="bold">Timer clock (APB1 clock)</strong>: <span class="No-Break">16 MHz</span></li>
				<li><strong class="bold">Prescaler (TIMx_PSC </strong><span class="No-Break"><strong class="bold">value)</strong></span><span class="No-Break">: 15999</span></li>
				<li><strong class="bold">Period (TIMx_ARR </strong><span class="No-Break"><strong class="bold">value):</strong></span><span class="No-Break"> 499</span></li>
			</ul>
			<p>This means<a id="_idIndexMarker637"/> we have the <span class="No-Break">following values:</span></p>
			<ul>
				<li>The timer clock is <span class="No-Break">16,000,000 Hz</span></li>
				<li>The <strong class="source-inline">TIMx_PSC</strong> register is set to 15999, but since the prescaler divides the clock by the value plus one, we use 15999 + 1 = <span class="No-Break">16000</span></li>
				<li>The <strong class="source-inline">TIMx_ARR</strong> register is set to 499, but since the period counts to the value plus one, we use 499 + 1 = <span class="No-Break">500</span></li>
			</ul>
			<p>Plugging these values into our formula, we get <span class="No-Break">the following:</span></p>
			<p>Update Event <span class="No-Break">Frequency =</span><span class="No-Break"><img src="image/2.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mn&gt;16,000,000&lt;/mn&gt;&lt;mrow&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mn&gt;15999&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;X&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;499&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.383em;height:2.036em;width:8.737em" width="335" height="60"/></span></p>
			<p> =<img src="image/3.png" alt="&lt;math &gt;&lt;mrow&gt;&lt;mstyle scriptlevel=&quot;+1&quot;&gt;&lt;mfrac&gt;&lt;mn&gt;16,000,000&lt;/mn&gt;&lt;mn&gt;8000000&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;/math&gt;" style="vertical-align:-0.292em;height:1.945em;width:4.731em" width="159" height="55"/> </p>
			<p>= <span class="No-Break">2Hz</span></p>
			<p>This means the UEV occurs at a frequency of <strong class="bold">2 Hz, or twice every second</strong>. This concludes this section. In the next section, we will develop our <span class="No-Break">timer driver.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor276"/>Developing the timer driver</h1>
			<p>In this section, we <a id="_idIndexMarker638"/>will apply the knowledge gained about the TIM peripheral to develop a driver for <span class="No-Break">generating delays.</span></p>
			<p>First, create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project <strong class="source-inline">GTIM</strong>. Next, create a new file named <strong class="source-inline">tim.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">tim.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<p>Our goal is to develop a driver that initializes TIM2 to generate a 1 Hz timeout. Populate your <strong class="source-inline">tim.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#include "tim.h"
#define TIM2EN        (1U&lt;&lt;0)
#define CR1_CEN        (1U&lt;&lt;0)
void tim2_1hz_init(void)
{
    /*Enable clock access to tim2*/
    RCC-&gt;APB1ENR |=TIM2EN;
    /*Set prescaler value*/
    TIM2-&gt;PSC =  1600 - 1 ;
    /*Set auto-reload value*/
    TIM2-&gt;ARR =  10000 - 1;
    /*Clear counter*/
    TIM2-&gt;CNT = 0;
    /*Enable timer*/
    TIM2-&gt;CR1 = CR1_CEN;
}</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<pre class="source-code">
#define TIM2EN    (1U&lt;&lt;0)
#define CR1_CEN   (1U&lt;&lt;0)</pre>			<p>The <strong class="source-inline">TIM2EN</strong> instance <a id="_idIndexMarker639"/>is defined as <strong class="source-inline">(1U&lt;&lt;0)</strong>, which sets bit 0. This is used to enable the clock <span class="No-Break">for TIM2.</span></p>
			<p>The <strong class="source-inline">CR1_CEN</strong> instance is defined as <strong class="source-inline">(1U&lt;&lt;0)</strong>, which also sets bit 0. This is used to enable the counter in the TIM2 control register <span class="No-Break">1 (</span><span class="No-Break"><strong class="source-inline">CR1</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
    /* Enable clock access to TIM2 */
    RCC-&gt;APB1ENR |= TIM2EN;</pre>			<p>This line enables the clock for TIM2 by setting the appropriate bit in the APB1 peripheral clock enable <span class="No-Break">register (</span><span class="No-Break"><strong class="source-inline">RCC-&gt;APB1ENR</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
    /* Set prescaler value */
    TIM2-&gt;PSC = 1600 - 1;  // 16,000,000 / 1,600 = 10,000</pre>			<p>The<a id="_idIndexMarker640"/> prescaler value is set to 1599. The prescaler divides the input clock frequency (16 MHz) by (1599 + 1), resulting in a 10,000 Hz (10 kHz) <span class="No-Break">timer clock:</span></p>
			<pre class="source-code">
    /* Set auto-reload value */
    TIM2-&gt;ARR = 10000 - 1;</pre>			<p>The auto-reload value is set to 9999. This means the timer will count from 0 to 9999, creating a period of 10,000 ticks. Since the timer clock is 10 kHz, counting 10,000 ticks results in 1 second (10,000 / 10,000 Hz = <span class="No-Break">1 s):</span></p>
			<pre class="source-code">
    /* Clear counter */
    TIM2-&gt;CNT = 0;</pre>			<p>This line resets the timer counter to 0. It ensures that the counting starts from 0 when the timer <span class="No-Break">is enabled:</span></p>
			<pre class="source-code">
    /* Enable timer */
    TIM2-&gt;CR1 = CR1_CEN;</pre>			<p>This line enables the timer by setting the <strong class="source-inline">CEN</strong> (Counter Enable) bit in the TIM2 control register 1 (<strong class="source-inline">CR1</strong>). This starts the timer, and it begins counting based on the configured prescaler and <span class="No-Break">auto-reload values.</span></p>
			<p>In summary, our code accomplishes <span class="No-Break">the following:</span></p>
			<ol>
				<li>Enables the clock <span class="No-Break">for TIM2.</span></li>
				<li>Sets a prescaler value to divide the input clock to <span class="No-Break">10 kHz.</span></li>
				<li>Sets an auto-reload value to make the timer count up to 10,000, creating a <span class="No-Break">1-second period.</span></li>
				<li>Clears the <span class="No-Break">timer counter.</span></li>
				<li>Enables <span class="No-Break">the timer.</span></li>
			</ol>
			<p>Our<a id="_idIndexMarker641"/> next task is to populate the <span class="No-Break"><strong class="source-inline">tim.h</strong></span><span class="No-Break"> file.</span></p>
			<p>Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
#include "stm32f4xx.h"
#ifndef TIM_H_
#define TIM_H_
#define SR_UIF  (1U&lt;&lt;0)
void tim2_1hz_init(void);
#endif</pre>			<p>The following line defines a <strong class="source-inline">SR_UIF</strong> macro that sets the 0th bit (least significant bit) <span class="No-Break">to 1:</span></p>
			<pre class="source-code">
#define SR_UIF  (1U &lt;&lt; 0)</pre>			<p>This bit represents the UIF in the SR of the timer. When the timer overflows or reaches the auto-reload value, this flag is set, indicating a UEV. We will need to access this bit in the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></p>
			<p>We are now ready to test <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break">.</span></p>
			<p>Update your <strong class="source-inline">main.c</strong> file as <span class="No-Break">shown next:</span></p>
			<pre class="source-code">
#include "gpio.h"
#include "tim.h"
int main(void)
{
    /*Initialize LED*/
    led_init();
    /*Initialize timer*/
    tim2_1hz_init();
    while(1)
    {
           led_toggle();
            /*Wait for UIF */
           while(!(TIM2-&gt;SR &amp; SR_UIF)){}
           /*Clear UIF*/
           TIM2-&gt;SR &amp;=~SR_UIF;
    }
}</pre>			<p>In this code, we<a id="_idIndexMarker642"/> initialize the LED and TIM2 to toggle the LED at a 1 Hz frequency. The code works by waiting for the timer’s UIF to be set, indicating that 1 second has passed, then toggling the LED and clearing the UIF to repeat the process. This cycle continues indefinitely in the main loop, resulting in the LED toggling <span class="No-Break">every second.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor277"/>Summary</h1>
			<p>In this chapter, we explored the general-purpose timers (TIM) in the STM32F411 microcontroller, which are distinct from the SysTick timer and offer a variety of features crucial for embedded systems applications. We began by discussing the fundamental uses of timers, emphasizing their importance in tasks such as time interval measurement, delay generation, and <span class="No-Break">event triggering.</span></p>
			<p>We then learned about the specifics of STM32 timers, detailing their classification into general-purpose and <span class="No-Break">advanced timers.</span></p>
			<p>Next, we examined the workings of STM32 timers, focusing on key registers such as the counter register (<strong class="source-inline">TIMx_CNT</strong>), prescaler register (<strong class="source-inline">TIMx_PSC</strong>), and auto-reload register (<strong class="source-inline">TIMx_ARR</strong>). We explained how the timer’s clock prescaling mechanism reduces the system clock to a suitable frequency for the timer and how this affects the <span class="No-Break">timer’s operation.</span></p>
			<p>We also provided a practical example of computing UEV frequency, demonstrating how to calculate the period and frequency of the timer based on the prescaler and <span class="No-Break">auto-reload values.</span></p>
			<p>Finally, we applied the theoretical knowledge by developing a timer driver for TIM2 to generate a 1 Hz timeout. In the next chapter, we will learn about another <span class="No-Break">useful peripheral.</span></p>
		</div>
	</div>
</div>
</body></html>