<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer067">
			<h1 id="_idParaDest-76" class="chapter-number"><a id="_idTextAnchor118"/>4</h1>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor119"/>Developing the Linker Script and Startup File</h1>
			<p><a id="_idTextAnchor120"/>In this chapter, we undertake an in-depth exploration of the core components of embedded <strong class="bold">bare-metal programming</strong>, focusing on three critical areas: the microcontroller memory model, the writing of the linker script, and the <span class="No-Break">startup file.</span></p>
			<p>First, we’ll explore the microcontroller memory model to understand how memory is organized and utilized. This knowledge is important for accurately allocating program code and data sections within the microcontroller memory. Next, we’ll go through the intricacies of writing linker scripts. These scripts are essential for correctly mapping our program to the appropriate sections of the microcontroller’s memory, ensuring that the executable runs <span class="No-Break">as intended.</span></p>
			<p>Finally, we will learn about the startup file and then proceed to write our own, focusing on initializing the vector table and <span class="No-Break">configuring </span><span class="No-Break"><strong class="source-inline">Reset_Handler</strong></span><span class="No-Break">.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><a id="_idTextAnchor121"/>Understanding the <span class="No-Break">memory model</span></li>
				<li>The <span class="No-Break">linker scripts</span></li>
				<li><a id="_idTextAnchor122"/>Writing the linker script and <span class="No-Break">startup file</span></li>
			</ul>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor123"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor124"/>Understanding the STM32 memory model</h1>
			<p>While the <a id="_idIndexMarker285"/>STM32 memory map consists of various memory areas, our primary focus in developing the linker script and startup file revolves around two critical areas: <strong class="bold">flash memory</strong> and <strong class="bold">static random access memory</strong> (<strong class="bold">SRAM</strong>). These areas<a id="_idIndexMarker286"/> are <a id="_idIndexMarker287"/>of utmost<a id="_idIndexMarker288"/> importance<a id="_idIndexMarker289"/> because they are directly involved in program storage. In the initial parts of this section, we will learn about the characteristics of these memory areas and the distinct roles <span class="No-Break">they play.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em> shows a section of the <a id="_idIndexMarker290"/>stm32f411 memory map, highlighting the flash memory <span class="No-Break">and SRAM.</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B21914_04_1.jpg" alt="Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory and SRAM areas" width="603" height="444"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory and SRAM areas</p>
			<p>Let’s start with <span class="No-Break">flash mem<a id="_idTextAnchor125"/>ory.</span></p>
			<h2 id="_idParaDest-80">Flash me<a id="_idTextAnchor126"/>mory</h2>
			<p>One of the primary advantages of flash memory<a id="_idIndexMarker291"/> is its non-volatile <a id="_idIndexMarker292"/>nature. This means that data stored in flash memory remains intact even when the power supply is disconnected. In STM32 microcontrollers (as well as other microcontrollers), flash memory is typically where the executable code is stored and is read-only during normal operation. Flash memory starts at the <strong class="source-inline">0x08000000</strong> address. However, its size varies depending on the specific STM32 <span class="No-Break">microcontroller model.</span></p>
			<p>STM32 microcontrollers come in various series and models, offering a range of flash memory densities to accommodate different <span class="No-Break">application requirements.</span></p>
			<p class="callout-heading">What is memory density?</p>
			<p class="callout"><strong class="bold">Memory density</strong> refers<a id="_idIndexMarker293"/> to the concentration of memory storage within a given physical space or component. Memory density is often expressed in terms of bits or bytes stored per unit of physical area, such as bits per square millimeter or bytes per square centimeter. It measures how densely or compactly data can be stored within that space. Higher memory density means that we can store more data than we can in a smaller <span class="No-Break">physical space.</span></p>
			<p class="callout">Memory size, on the <a id="_idIndexMarker294"/>other hand, refers to the total amount of memory (storage capacity) available in a given storage<a id="_idIndexMarker295"/> device. It is typically measured<a id="_idIndexMarker296"/> in units such as bytes, <strong class="bold">kilobytes</strong> (<strong class="bold">KB</strong>), <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>), <strong class="bold">gigabytes</strong> (<span class="No-Break"><strong class="bold">GB</strong></span><span class="No-Break">), etc.</span></p>
			<p>Now, let’s talk about some operational nuances of <span class="No-Break">flash memory.</span></p>
			<p>Flash memory, including<a id="_idIndexMarker297"/> STM32 flash memory, has a limited <a id="_idIndexMarker298"/>number of program and erase cycles. Each time we write (program) or erase, it consumes one of these cycles. It is important to consider these limitations when designing applications that frequently write to or erase data from <span class="No-Break">flash memory.</span></p>
			<p>STM32 microcontrollers are known for their low power consumption, and this extends to their flash memory operations. Efficient power management ensures that the microcontroller can operate on minimal power while reading from or writing to flash memory, making STM32 devices suitable for <span class="No-Break">battery-powered applications.</span></p>
			<p>To ensure data integrity, STM32 flash memory often includes built-in error correction mechanisms. These mechanisms help identify and correct errors that may occur during data storage and retrieval, enhancing the reliability of the <span class="No-Break">stor<a id="_idTextAnchor127"/>ed firmware.</span></p>
			<p>The following are some key attributes<a id="_idIndexMarker299"/> of the STM32 <span class="No-Break">flash memory:</span></p>
			<ul>
				<li><strong class="bold">Read-only nature</strong>: Primarily used for storing <span class="No-Break">program code</span></li>
				<li><strong class="bold">Memory start </strong><span class="No-Break"><strong class="bold">address</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">0x08000000</strong></span></li>
				<li><strong class="bold">Variable size</strong>: Dependent on the specific STM32 <span class="No-Break">microcontroller model</span></li>
				<li><strong class="bold">Vector table </strong><span class="No-Break"><strong class="bold">location</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">0x08000004</strong></span></li>
			</ul>
			<p>Let’s take a look at the other primary memory areas relevant to writing our linker script and <a id="_idTextAnchor128"/><span class="No-Break">startup file.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor129"/>SRAM</h2>
			<p><strong class="bold">SRAM</strong> is a <a id="_idIndexMarker300"/>type of volatile memory, meaning it loses its<a id="_idIndexMarker301"/> contents when the power supply is disconnected. It is used in STM32 microcontrollers for temporary data storage during program execution. Unlike flash memory, which is used for long-term storage of program code, SRAM is designed for high-speed access and low latency, making it ideal for storing variables, intermediate data, and managing the stack <span class="No-Break">during runtime.</span></p>
			<p>Like flash memory, the STM32 microcontrollers feature varying sizes of SRAM, tailored to the needs of different applications. The size of the SRAM determines the amount of runtime data that can be handled and affects the overall performance of the microcontroller in handling complex tasks or multitasking. The SRAM in STM32 microcontrollers starts at the <strong class="source-inline">0x20000000</strong> address. Like flash memory, its size varies depending on the specific STM32 <span class="No-Break">microcontroller model.</span></p>
			<p>The following are the key attributes of the <a id="_idIndexMarker302"/><span class="No-Break">STM32 SRAM:</span></p>
			<ul>
				<li><strong class="bold">Read and write</strong>: Variables and the stack are <span class="No-Break">stored here</span></li>
				<li><strong class="bold">Memory start </strong><span class="No-Break"><strong class="bold">address</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">0x20000000</strong></span></li>
				<li><strong class="bold">Variable size</strong>: Dependent on the specific STM32 <span class="No-Break">microcontroller model</span></li>
			</ul>
			<p>Before moving on to introduce the linker script, let’s touch on one other memory area that is not relevant to the linker script, but is still relevant to our understanding of the memory layout of <span class="No-Break">our microcontroller.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor130"/>Peripheral memory</h2>
			<p><strong class="bold">Peripheral memory</strong> is <a id="_idIndexMarker303"/>dedicated to managing and interfacing with the <a id="_idIndexMarker304"/>microcontroller’s onboard peripherals. These peripherals include components such as timers, communication interfaces (UART, SPI, I2C), <a id="_idIndexMarker305"/>and <strong class="bold">analog-to-digital converters</strong> (<strong class="bold">ADCs</strong>). Peripheral memory is made up of registers that are used to configure and manage <span class="No-Break">these peripherals.</span></p>
			<p>An important aspect of <a id="_idIndexMarker306"/>microcontroller architecture is the use of <strong class="bold">memory-mapped input/output</strong> (<strong class="bold">I/O</strong>). Memory-mapped I/O is a technique where peripheral registers are assigned specific addresses in the system’s memory space. This approach allows firmware to interact with hardware peripherals by reading from or writing to these memory addresses, just as it would with regular memory. The peripheral memory area of the STM32 memory map is the memory-mapped area for the <a id="_idIndexMarker307"/><span class="No-Break">peripheral registers.</span></p>
			<p>Now that we are familiar with the major memory areas, we are ready to learn about the <span class="No-Break">linker script.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor131"/>The linker script</h1>
			<p>Linker scripts play <a id="_idIndexMarker308"/>an important role in the build process, especially in defining the memory layout and allocating various memory sections used by the firmware. They specify where different sections of the firmware, such as code, data, and uninitialized data, are to be placed in the <span class="No-Break">microcontroller’s memory.</span></p>
			<p>While linker scripts set up the structure and boundaries for these sections, it is important to note that they do not populate these sections with data. The actual process of initializing data with specific values is handled by the startup code, which runs when the microcontroller boots up. We provide these linker scripts to the linker to effectively guide the organization of memory during the <span class="No-Break">linking phase.</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B21914_04_2.jpg" alt="Figure 4.2: The build process with the linker highlighted" width="1035" height="432"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: The build process with the linker highlighted</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor132"/>Understanding the linking process</h2>
			<p>In the build process, the linking of <a id="_idIndexMarker309"/>object files is an important step that transforms individual pieces of code into functional firmware. The assembler generates object files from source code, each containing code and data sections necessary for the firmware. However, these object files often have unresolved internal references to variables and functions, making them incomplete on their own. For instance, an object file may contain a reference to an <strong class="source-inline">adc_value</strong> variable that is defined elsewhere. It is the linker’s job to amalgamate these object files, systematically resolving all such unresolved symbols to create a cohesive output file. To fully appreciate the meticulous work of the linker, we have to understand the attributes assigned to each section by <span class="No-Break">the linker.</span></p>
			<h3>Section attributes and their implications</h3>
			<p>Each<a id="_idIndexMarker310"/> section within an <a id="_idIndexMarker311"/>object file is identified by a unique name and size, with specific attributes that dictate how they should <span class="No-Break">be treated:</span></p>
			<ul>
				<li><strong class="bold">Loadable sections</strong>: These <a id="_idIndexMarker312"/>sections contain content that must be loaded into memory at<a id="_idIndexMarker313"/> runtime. They are essential for the execution of the program and include executable code and <span class="No-Break">initialized data.</span></li>
				<li><strong class="bold">Allocatable sections</strong>: These <a id="_idIndexMarker314"/>sections do not carry content by themselves. Instead, they <a id="_idIndexMarker315"/>signal that a certain area of memory should be reserved, typically for uninitialized data that will be defined <span class="No-Break">at runtime.</span></li>
				<li><strong class="bold">Non-loadable, non-allocatable sections</strong>: Often, a section that is neither loadable nor allocatable contains <a id="_idIndexMarker316"/>debugging information or <a id="_idIndexMarker317"/>metadata that helps in the development process but is not require<a id="_idTextAnchor133"/>d for the <span class="No-Break">program’s execution.</span></li>
			</ul>
			<p>A crucial aspect of the linking process is the determination of two types of addresses for each allocatable and loadable output<a id="_idIndexMarker318"/> section: the <strong class="bold">virtual memory address</strong> (<strong class="bold">VMA</strong>) and <a id="_idIndexMarker319"/>the <strong class="bold">load memory </strong><span class="No-Break"><strong class="bold">address</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LMA</strong></span><span class="No-Break">).</span></p>
			<p>These are the roles of these <span class="No-Break">two addresses:</span></p>
			<ul>
				<li><strong class="bold">VMA</strong>: This<a id="_idIndexMarker320"/> address represents where the section will reside in memory during the execution of the output file. It is the runtime address used by the system to access the section’s data <span class="No-Break">or instructions.</span></li>
				<li><strong class="bold">LMA</strong>: Conversely, the <a id="_idIndexMarker321"/>LMA is the address where the section is physically loaded <span class="No-Break">into memory.</span></li>
			</ul>
			<p class="callout-heading">In most scenarios, the VMA and LMA are identical</p>
			<p class="callout">A notable exception occurs when a data section is initially loaded into flash memory but then copied to SRAM <span class="No-Break">upon startup.</span></p>
			<p>To provide a clearer and more comprehensive understanding of the latter stages of the build process, it’s essential to delve into another fundamental aspect of our discussion: the specific responsibilities and contributions of the locator within the <span class="No-Break">build process.</span></p>
			<h3>Address relocation and the locator</h3>
			<p>The output <a id="_idIndexMarker322"/>file produced by the linker is not immediately suitable for use on a target microcontroller. This is because the addresses assigned to different sections during the linking process do not necessarily correspond to the actual memory layout of the target device. Therefore, these addresses must be relocated to match the target’s memory space accurately. This is the job of <span class="No-Break">the locator.</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B21914_04_3.jpg" alt="Figure 4.3: The build process, highlighting the relationship between the relocatable file, the locator, and the final executable output" width="1071" height="427"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: The build process, highlighting the relationship between the relocatable file, the locator, and the final executable output</p>
			<p>In the GNU toolchain, the locator<a id="_idIndexMarker323"/> functionality is integrated into the linker, streamlining the process of address relocation. This capability ensures that the final executable is correctly mapped to the microcontroller’s memory, making it ready <span class="No-Break">for execution.</span></p>
			<p>In this section, we examined the build process. From this, we observed that the process of linking object files in embedded systems development involves meticulous organization of code and data sections, symbol resolution, and <span class="No-Break">address relocation.</span></p>
			<p>In the next section, we shall explore the key components of the linker script in detail. This exploration will offer additional insights and deepen our understanding of the core elements discussed in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor134"/>Key components of the linker script</h2>
			<p>The key components of a linker script include the <strong class="bold">memory layout</strong>, <strong class="bold">section</strong><strong class="bold"> </strong><strong class="bold">definitions</strong>, <strong class="bold">options</strong>, and <strong class="bold">symbols</strong>, each playing a unique role in ensuring that the firmware is correctly placed and executed within the <span class="No-Break">micr<a id="_idTextAnchor135"/>ocontroller’s memory.</span></p>
			<h3>Memory layout</h3>
			<p>This part of the linker <a id="_idIndexMarker324"/>script<a id="_idIndexMarker325"/> specifies the various memory types available in the microcontroller, such as flash memory and SRAM. It includes their start addresses and sizes, for instance, flash starting at <strong class="source-inline">0x08000000</strong> or SRAM <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">0x20000000</strong></span><span class="No-Break">.</span></p>
			<h3>Section definitions</h3>
			<p>A critical aspect of the <a id="_idIndexMarker326"/>linker script is<a id="_idIndexMarker327"/> defining how and where different sections of the program are placed. The <strong class="source-inline">.text</strong> section, containing the program code, is usually positioned at the beginning of flash memory. Following <a id="_idIndexMarker328"/>this, the <strong class="bold">Block Started by Symbol</strong> (<strong class="source-inline">.bss</strong>) and <strong class="source-inline">.data</strong> sections are allocated in SRAM. The linker script also ensures proper alignment of these sections for efficient memory access and <span class="No-Break">program execution:</span></p>
			<ul>
				<li><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">text</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Purpose</strong>: The <strong class="source-inline">.text</strong> section<a id="_idIndexMarker329"/> holds the executable instructions of our program. It’s where the actual code that the processor <span class="No-Break">executes resides.</span></li><li><strong class="bold">Characteristics</strong>: This section is read-only and typically resides in the microcontroller’s flash memory, ensuring that the program code is preserved even when the device is <span class="No-Break">powered off.</span></li><li><strong class="bold">Size and location</strong>: The size of the <strong class="source-inline">.text</strong> section varies based on the amount of code in your program. In STM32 microcontrollers, it generally starts at a predefined memory address, often in the lower region of the flash memory. For example, <strong class="source-inline">0x00000000</strong> and then relocated <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0x08000000</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">bss</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Purpose</strong>: The <strong class="source-inline">.bss</strong> section is <a id="_idIndexMarker330"/>used for uninitialized global and static variables. Variables in this section don’t have initial values when the <span class="No-Break">program starts.</span></li><li><strong class="bold">Characteristics</strong>: This section is in the SRAM and is also read-write. It’s typically 0-initialized at startup, meaning all variables start with a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li></ul></li>
				<li><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Purpose</strong>: The <strong class="source-inline">.data</strong> section contains initialized global and static variables. Unlike variables in <strong class="source-inline">.bss</strong>, these variables have initial values specified in <span class="No-Break">our code.</span></li><li><strong class="bold">Characteristics</strong>: It’s a read-write section. At runtime, the values in the <strong class="source-inline">.data</strong> section are typically copied from flash memory to SRAM to allow faster access <span class="No-Break">and modification.</span></li><li><strong class="bold">Management</strong>: The process of copying these values from flash memory to SRAM is handled by the startup code, executed before the main function of <span class="No-Break">our program.</span></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Other sections</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">.rodata</strong>: This section is used for constant data, such as string literals and constant arrays. It’s read-only and usually stored in <span class="No-Break">flash memory.</span></li><li><strong class="source-inline">.heap</strong> and <strong class="source-inline">.stack</strong> are sections used for dynamic memory allocation (<strong class="source-inline">malloc</strong>, <strong class="source-inline">free</strong>) and function call stacks, respectively. They are part of SRAM and are crucial for runtime <span class="No-Break">memory management.</span></li></ul></li>
			</ul>
			<p>The following table<a id="_idIndexMarker331"/> summarizes the<a id="_idIndexMarker332"/> key sections and their placement <span class="No-Break">in memory.</span></p>
			<table id="table001-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Section</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Placed in</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">text</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds executable <span class="No-Break">program instructions.</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">FLASH</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">bss</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds uninitialized <span class="No-Break">global/static variables.</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">SRAM</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">data</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds initialized global/static variables with <span class="No-Break">initial values.</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">FLASH</strong> (<strong class="source-inline">SRAM</strong> <span class="No-Break">at runtime)</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">rodata</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds constant data (string literals, <span class="No-Break">constant arrays).</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">FLASH</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1: Linker script sections and their placement in memory</p>
			<p>Understanding the characteristics of these sections is important for having a properly <span class="No-Break">functioning executable.</span></p>
			<h3>Options and symbols</h3>
			<p><strong class="bold">Options</strong> in linker<a id="_idIndexMarker333"/> scripts<a id="_idIndexMarker334"/> are commands or directives that influence the behavior of the linker. A typical linker script includes directives for setting the entry point of the program and directives for defining the <span class="No-Break">memory layout.</span></p>
			<p>Symbols in <a id="_idIndexMarker335"/>linker scripts <a id="_idIndexMarker336"/>are identifiers that act as placeholders or references to specific memory locations, values, or addresses within the microcontroller’s memory space. Symbols can be used to represent the start or end addresses of memory sections or specific variables in the program. For example, a symbol might be defined to represent the beginning of the flash memory or the start of the SRAM region. We can also use symbols to define important constants or values that are used throughout the firmware (such as source code files). These might include hardware addresses, configuration values, or size limits. By using symbols, the code becomes more readable and maintainable, as these values can be changed in one place (the linker script), rather than in multiple locations throughout <span class="No-Break">the code.</span></p>
			<p>Now that we are familiar with the key components of linker scripts, we will proceed to learn about some of the essential directives within these scripts. Each directive in a linker script instructs the linker on how to process and organize the input object files into the <span class="No-Break">final executable.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor136"/>Linker script directives</h2>
			<p>In this section, we learn about the essential directives of linker scripts. These directives dictate the memory layout and how various sections—code, data, and others—are allocated within the target microcontroller’s memory. We will explore the key directives, their functionality, and how they influence the overall structure and efficiency of the compiled firmware. Let’s start with the <span class="No-Break"><strong class="source-inline">MEMORY</strong></span><span class="No-Break"> directi<a id="_idTextAnchor137"/>ve.</span></p>
			<h3>Memory directive (MEMORY)</h3>
			<p>The <strong class="source-inline">MEMORY</strong> directive<a id="_idIndexMarker337"/> delineates the<a id="_idIndexMarker338"/> microcontroller’s memory regions. Each defined block within the <strong class="source-inline">MEMORY</strong> section represents a distinct area of memory, characterized by its name, start address, and size. This directive allows us to define the memory layout of the target device, specifying different memory regions and their attributes. It plays an important role in guiding the linker on how to allocate sections of the program (code, data, etc.) across the microcontroller’s <span class="No-Break">physical me<a id="_idTextAnchor138"/>mory.</span></p>
			<h4>Usage template</h4>
			<p>The general syntax for <a id="_idIndexMarker339"/>the <strong class="source-inline">MEMORY</strong> directive is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
MEMORY
{
  name (attributes) : ORIGIN = origin, LENGTH = length
}</pre>			<ul>
				<li><strong class="source-inline">name</strong>: An identifier we give to the <span class="No-Break">memory region</span></li>
				<li><strong class="source-inline">attributes</strong>: This specifies the access permissions for the region, such as read, write, and <span class="No-Break">execute permissions</span></li>
				<li><strong class="source-inline">ORIGIN</strong>: This defines the start address of the <span class="No-Break">memory region</span></li>
				<li><strong class="source-inline">LENGTH</strong>: This<a id="_idIndexMarker340"/> specifies the size of the <span class="No-Break">memory </span><span class="No-Break"><a id="_idIndexMarker341"/></span><span class="No-Break">region</span></li>
			</ul>
			<h4>Usage example</h4>
			<p>Consider <a id="_idIndexMarker342"/>a microcontroller<a id="_idIndexMarker343"/> with flash memory for storing executable code and SRAM for data storage. A linker script might define these memory regions <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 256K
  SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 64K
}</pre>			<p>In this example, two memory regions are defined: <strong class="source-inline">FLASH</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">FLASH</strong> is marked with read (<strong class="source-inline">r</strong>) and execute (<strong class="source-inline">x</strong>) permissions (<strong class="source-inline">rx</strong>), indicating that this region can store executable code but is not writable during program execution. It starts at the <strong class="source-inline">0x08000000</strong> address and extends for <span class="No-Break"><strong class="source-inline">256K</strong></span><span class="No-Break"> bytes.</span></li>
				<li><strong class="source-inline">SRAM</strong> is given read (<strong class="source-inline">r</strong>), write (<strong class="source-inline">w</strong>), and execute (<strong class="source-inline">x</strong>) permissions (<strong class="source-inline">rwx</strong>), allowing it to store data and executable code that can be modified during runtime. It begins at the <strong class="source-inline">0x20000000</strong> address and extends for <span class="No-Break"><strong class="source-inline">64K</strong></span><span class="No-Break"> bytes.</span></li>
			</ul>
			<p>The <strong class="source-inline">MEMORY</strong> directive, with its comprehensive definition of memory regions and attributes, lays the foundation for efficient and effective memory management in firmware development. Before moving on to the next directive, let’s examine all the attributes that can be specified to detail the characteristics and <a id="_idIndexMarker344"/>permissions of the <span class="No-Break">memory </span><span class="No-Break"><a id="_idIndexMarker345"/></span><span class="No-Break">sections:</span></p>
			<ul>
				<li><strong class="source-inline">r</strong>: This attribute allows memory to be read. It is important for sections of memory containing executable code or constants that the program needs to read <span class="No-Break">during execution.</span></li>
				<li><strong class="source-inline">w</strong>: This attribute permits data to be written to the memory. It is important for memory areas where the program stores data dynamically <span class="No-Break">during execution.</span></li>
				<li><strong class="source-inline">x</strong>: This attribute allows the execution of code from the specified memory region. It is typically assigned to flash memory where the program <span class="No-Break">code resides.</span></li>
				<li><strong class="source-inline">rw</strong>: This is a combination of read and write permissions, allowing both operations in the specified memory region. It’s commonly used for sections such as SRAM where temporary data and variables are stored <span class="No-Break">and modified.</span></li>
				<li><strong class="source-inline">rx</strong>: This combines read and execute permissions. It’s often used for flash memory to indicate that the region contains executable code that the processor can read <span class="No-Break">and execute.</span></li>
				<li><strong class="source-inline">rwx</strong>: This attribute combines all three permissions, making the memory region fully accessible for reading, writing, and executing. This is less commonly used due to security and system stability considerations but might be applicable in certain development or <span class="No-Break">debug scenarios.</span></li>
				<li><strong class="source-inline">empty</strong>: If no attribute is specified, the memory region does not grant any access permissions by default. This might be used in special cases where permissions are controlled or modified by other means within <span class="No-Break">the firmware.</span></li>
			</ul>
			<p>Now, let’s examine the <span class="No-Break"><strong class="source-inline">ENTRY</strong></span><span class="No-Break"> directive.</span></p>
			<h3>The entry directive (ENTRY)</h3>
			<p>This <a id="_idIndexMarker346"/>directive specifies the entry point of the <a id="_idIndexMarker347"/>program, which is the first piece of code to execu<a id="_idTextAnchor139"/>te <span class="No-Break">upon reset.</span></p>
			<p>Here is the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
ENTRY(SymbolName)</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
ENTRY(Reset_Handler)</pre>			<p>In this example, <strong class="source-inline">Reset_Handler</strong> is designated as the entry point of the program, meaning, the first function to execute. In firmware development, <strong class="source-inline">Reset_Handler</strong> takes care <a id="_idIndexMarker348"/>of initializing<a id="_idIndexMarker349"/> the system and jumping to the <span class="No-Break">main program.</span></p>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">SECTIONS</strong></span><span class="No-Break"> directive.</span></p>
			<h3>The sections directive (SECTIONS)</h3>
			<p>This directive defines the <a id="_idIndexMarker350"/>mapping and <a id="_idIndexMarker351"/>ordering of sections from input files into the <span class="No-Break">output file.</span></p>
			<h4>Usage example</h4>
			<p>Let’s see<a id="_idIndexMarker352"/> a template <span class="No-Break">of it:</span></p>
			<pre class="source-code">
SECTIONS
{
  .output_section_name address :
  {
    input_section_information
  } &gt;memory_region [AT&gt;load_address] [ALIGN(expression)] [:phdr_
    expression] [=fill_expression]
}</pre>			<p>The parameters are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">output_section_name</strong>: This is<a id="_idIndexMarker353"/> the name given to the output section being defined. Common names include <strong class="source-inline">.text</strong> for executable code, <strong class="source-inline">.data</strong> for initialized data, and <strong class="source-inline">.bss</strong> for <span class="No-Break">uninitialized data.</span></li>
				<li><strong class="source-inline">address</strong>: This is optional and specifies the start address of the section in memory. This is often left to the linker to determine, based on the order of sections and <a id="_idIndexMarker354"/>memory regions defined in <span class="No-Break">the script.</span></li>
				<li><strong class="source-inline">input_section_information</strong>: This determines which input sections (from the compiled object files) should be included in this output section. Wildcards such as <strong class="source-inline">*(.text)</strong> can be used to include all <strong class="source-inline">.text</strong> sections from all <span class="No-Break">input files.</span></li>
				<li><strong class="source-inline">&gt;memory_region</strong>: This assigns the section to a specific memory region defined in the <strong class="source-inline">MEMORY</strong> block of the linker script. We use this to tell the linker where in the target’s memory map this section should reside, for example, <strong class="source-inline">FLASH</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">[AT&gt;load_address]</strong>: This is optional and specifies the load address of the section. This is used in scenarios where the execution address differs from the <span class="No-Break">load address.</span></li>
				<li><strong class="source-inline">[ALIGN(expression)]</strong>: This is optional and aligns the start of the section to an address that is a multiple of the value specified by <strong class="source-inline">expression</strong>. This is particularly useful for ensuring that sections begin at addresses that meet specific alignment requirements, which can enhance access speed <span class="No-Break">and compatibility.</span></li>
				<li><strong class="source-inline">[:phdr_expression]</strong>: This<a id="_idIndexMarker355"/> is optional and associates the section with a program header. Program headers are part of <a id="_idIndexMarker356"/>the <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) file structure; they provide the system loader with information about how to load and run different segments of <span class="No-Break">a program.</span></li>
				<li><strong class="source-inline">[=fill_expression]</strong>: This is optional and specifies a byte value to fill gaps between sections or at the end of sections to reach a certain alignment. This can be useful for initializing memory regions to a <span class="No-Break">known state.</span></li>
			</ul>
			<h4>Usage example</h4>
			<p>Let’s see an example of<a id="_idIndexMarker357"/> the <strong class="source-inline">SECTIONS</strong> directive <span class="No-Break">in </span><span class="No-Break"><a id="_idIndexMarker358"/></span><span class="No-Break">action:</span></p>
			<pre class="source-code">
SECTIONS
{
  .text 0x08000000 :
  {
    *(.text)
  } &gt;FLASH
}</pre>			<p>In this example, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">SECTIONS</strong>: This keyword begins the section of the linker script where output sections are defined. Output sections are areas of memory that hold the code and data from the input files <span class="No-Break">being linked.</span></li>
				<li><strong class="source-inline">.text 0x08000000</strong>: This line defines an output section named <strong class="source-inline">.text</strong> and sets its starting address to <strong class="source-inline">0x08000000</strong>. The <strong class="source-inline">.text</strong> section typically <a id="_idTextAnchor140"/>contains <span class="No-Break">executable code.</span></li>
				<li><strong class="source-inline">{ *(.text) }</strong>: This line specifies what goes into the <strong class="source-inline">.text</strong> output section. The <strong class="source-inline">*(.text)</strong> syntax means all <strong class="source-inline">.text</strong> sections from all <span class="No-Break">input files.</span></li>
				<li><strong class="source-inline">&gt;FLASH</strong>: This directive tells the linker to place the <strong class="source-inline">.text</strong> section in a memory region named <strong class="source-inline">FLASH</strong>. The <strong class="source-inline">FLASH</strong> region will be defined in the <strong class="source-inline">MEMORY</strong> <span class="No-Break">directive block.</span></li>
			</ul>
			<p>To understand the<a id="_idIndexMarker359"/> importance <a id="_idIndexMarker360"/>of the <strong class="source-inline">*(.text)</strong> syntax, let’s examine the process of <span class="No-Break">merging sections.</span></p>
			<h3>Sections merging</h3>
			<p>As we learned earlier, the <a id="_idIndexMarker361"/>assembler generates an object file for each source file, with each containing its <strong class="source-inline">.text</strong>, <strong class="source-inline">.data</strong>, <strong class="source-inline">.bss</strong>, and other sections. These sections from all object files are then merged by the linker into unified <strong class="source-inline">.text</strong>, <strong class="source-inline">.data</strong>, and <strong class="source-inline">.bss</strong> sections for the <span class="No-Break">final executable.</span></p>
			<p>Consider a firmware project with two source files, <strong class="source-inline">main.c</strong> and <strong class="source-inline">delay.c</strong>. The assembly process yields <strong class="source-inline">main.o</strong> and <strong class="source-inline">delay.o</strong>, each with its own sections. The linker’s task is to consolidate these into a single set of sections for the <span class="No-Break">final executable.</span></p>
			<p>The following figure depicts this process. Note that merging is <em class="italic">not</em> performed through an addition process; this is merely a visual aid to enhance <span class="No-Break">your understanding.</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B21914_04_4.jpg" alt="Figure 4.4: The merging process involving two source files: main.c and delay.c, resulting in the production of the final executable, final.elf" width="1503" height="564"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: The merging process involving two source files: main.c and delay.c, resulting in the production of the final executable, final.elf</p>
			<p>Now, let’s explore the purpose of the <strong class="source-inline">AT &gt;</strong> directive. To do this, it is essential to revisit the concepts of the LMA <span class="No-Break">and VMA.</span></p>
			<h3>A closer look at the LMA and VMA</h3>
			<p>As we learned earlier, each allocatable and loadable output section in a binary output file is associated with two types of addresses: the LMA and the VMA. These addresses are crucial for defining how and where a section of the binary is processed during the system’s startup and its subsequent <span class="No-Break">runtime operations:</span></p>
			<ul>
				<li><strong class="bold">LMA</strong>: This is the <a id="_idIndexMarker362"/>physical address in the binary image where the section is stored before program execution begins. It determines from where the system will load the section into memory when the <span class="No-Break">program starts.</span></li>
				<li><strong class="bold">VMA</strong>: In <a id="_idIndexMarker363"/>contrast, the VMA is the address where the section is intended to be accessed during the program’s execution. This is the “runtime” address used by the system to refer to data or instructions in that section. For systems, particularly microcontrollers, that do not employ<a id="_idIndexMarker364"/> a <strong class="bold">memory management unit</strong> (<strong class="bold">MMU</strong>), the VMA usually matches the section’s physical memory <span class="No-Break">address directly.</span></li>
			</ul>
			<h3>Why are LMA and VMA important?</h3>
			<p>The distinction between <a id="_idIndexMarker365"/>LMA and VMA allows for a flexible memory management <a id="_idIndexMarker366"/>approach where data can be stored in one location (such as flash memory) but run from another (such as SRAM). For example, initialized global and static variables (typically placed in the <strong class="source-inline">.data</strong> section) can be stored in flash memory but need to be copied to SRAM for faster access and to allow modification <span class="No-Break">at runtime.</span></p>
			<p>To fully understand this, let’s consider the following snippet from a linker script generated by <span class="No-Break">the STM32CubeIDE:</span></p>
			<pre class="source-code">
  .data :
  {
    . = ALIGN(4);
    _sdata = .;  /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */
    *(.RamFunc)        /* .RamFunc sections */
    *(.RamFunc*)       /* .RamFunc* sections */
    . = ALIGN(4);
    _edata = .;  /* define<a id="_idTextAnchor141"/> a global symbol at data end */
  } &gt;SRAM AT&gt; FLASH</pre>			<p>In this script, the last line, <strong class="source-inline">&gt;SRAM AT&gt; FLASH</strong>, incorporates two <span class="No-Break">important directives:</span></p>
			<ul>
				<li><strong class="source-inline">&gt;SRAM</strong> indicates that the output <strong class="source-inline">.data</strong> section is placed in the <strong class="source-inline">SRAM</strong> section of the memory during program <span class="No-Break">execution (VMA).</span></li>
				<li><strong class="source-inline">AT&gt; FLASH</strong> specifies that although the section resides in SRAM when executed, it should initially be loaded into<a id="_idIndexMarker367"/> memory (<strong class="bold">LMA</strong>) at the corresponding address in <strong class="source-inline">FLASH</strong>. This is common for initialized data, which is stored in flash memory and then copied to SRAM at startup by the microcontroller’s <span class="No-Break">initialization code.</span></li>
			</ul>
			<p>This detailed management of memory addresses highlights the critical role of LMA and VMA<a id="_idIndexMarker368"/> in maximizing the efficiency of resource-constrained microcontrollers. Through the effective use of LMA and VMA, we can ensure that even with limited memory resources, our microcontrollers operate reliably and efficiently, optimizing both storage and <span class="No-Break">execution efficiency.</span></p>
			<p>Before moving to explore the other features of the linker script, let’s familiarize ourselves with some other commonly <span class="No-Break">used directives.</span></p>
			<h3>Other commonly used directives</h3>
			<p>Some other commonly used directives include the <strong class="source-inline">KEEP</strong>, <strong class="source-inline">ALIGN</strong>, <strong class="source-inline">PROVIDE</strong>, <strong class="source-inline">&gt;region</strong>, and <strong class="source-inline">AT</strong> directives. Let’s <span class="No-Break">examine them.</span></p>
			<h4>The KEEP directive</h4>
			<p>The <strong class="source-inline">KEEP</strong> directive ensures<a id="_idIndexMarker369"/> that specified sections or symbols are not eliminated by the linker during the optimization process, even if they appear unused. This is crucial for interrupt vector tables and initialization functions that m<a id="_idTextAnchor142"/>ust be present in the <span class="No-Break">final binary.</span></p>
			<p>Here i<a id="_idTextAnchor143"/>s the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
KEEP(section)</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
KEEP(*(.isr_vector))</pre>			<p>In this example, we <a id="_idIndexMarker370"/>are <em class="italic">keeping</em> the interrupt vector section. Next, let’s see the region <span class="No-Break">placement directive.</span></p>
			<h4>The &gt;region directive</h4>
			<p>The <strong class="source-inline">(&gt;region)</strong> region placement <a id="_idIndexMarker371"/>directive tells the linker to place a particular section into a specific memory region. The available memory regions must be defined in the <strong class="source-inline">MEMORY</strong> directive block of the <span class="No-Break">linker script.</span></p>
			<p>Here is the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
section &gt;region</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
.data :
{
  *(.data)
} &gt;SRAM</pre>			<p>In this example, we are placing the <strong class="source-inline">.data</strong> section in the <strong class="source-inline">SRAM</strong> <span class="No-Break">memory region.</span></p>
			<h4>The ALIGN directive</h4>
			<p>The <strong class="source-inline">ALIGN</strong> directive plays a <a id="_idIndexMarker372"/>crucial role in the linker script by adjusting the location counter to align with specified memory boundaries. <strong class="bold">The location counter</strong> tracks the <a id="_idIndexMarker373"/>current memory address allocated by the linker for placing sections or parts of the output file <span class="No-Break">during linking.</span></p>
			<p><strong class="bold">The location counter</strong> is a <a id="_idIndexMarker374"/>built-in variable that represents the current address in memory where the linker is placing sections or parts of the output file during the linking process. It is denoted by a dot (<strong class="source-inline">.</strong>) in <span class="No-Break">linker scripts.</span></p>
			<p>As the linker processes the script, it assigns memory addresses to code and data sections according to the script’s directives, with the location counter monitoring the progress. To ensure efficient memory access and adherence to hardware architecture requirements, sections and variables often need to be aligned to specific boundaries. The <strong class="source-inline">ALIGN</strong> directive allows us to achieve this by rounding up the location counter to the nearest <a id="_idIndexMarker375"/>address that matches the specified<a id="_idTextAnchor144"/> alignment, which must be a power <span class="No-Break">of two.</span></p>
			<p>Here is the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
. = ALIGN(expression);</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
. = ALIGN(4);</pre>			<p>In this example, we are aligning the current location to a <span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">-byte boundary.</span></p>
			<p>Next, let’s see the <span class="No-Break"><strong class="source-inline">PROVIDE</strong></span><span class="No-Break"> directive.</span></p>
			<h4>The PROVIDE directive</h4>
			<p>The <strong class="source-inline">PROVIDE</strong> directive allows us <a id="_idIndexMarker376"/>to define symbols that the linker will include in the output file if they are not already defined. This can be used to set default values for symbols that may <a id="_idTextAnchor145"/>be optionally overridden by <span class="No-Break">other modules.</span></p>
			<p>Here is the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
PROVIDE(symbol = expression);</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
PROVIDE(_stack_end = ORIGIN(RAM) + LENGTH(RAM));</pre>			<p>In this example, we are <em class="italic">providing</em> a default stack <span class="No-Break">end address.</span></p>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">AT</strong></span><span class="No-Break"> directive.</span></p>
			<h4>AT Directive</h4>
			<p>The <strong class="source-inline">AT</strong> directive<a id="_idIndexMarker377"/> specifies LMA for a section when it needs to be different from the section’s VMA. This is commonly used for sections that need to be loaded into a different memory area during initialization before being moved to their <span class="No-Break">runtime location.</span></p>
			<p>Here is the <span class="No-Break">usage template:</span></p>
			<pre class="source-code">
section AT&gt; lma_region</pre>			<p>Here is a <span class="No-Break">usage example:</span></p>
			<pre class="source-code">
.data : AT&gt; FLASH
{
  *(.data)
} &gt;SRAM</pre>			<p>In this example, the <strong class="source-inline">.data</strong> section is intended to reside in SRAM during the program’s execution. However, it is initially loaded from <strong class="source-inline">FLASH</strong>, as indicated by <span class="No-Break"><strong class="source-inline">AT&gt; FLASH</strong></span><span class="No-Break">.</span></p>
			<p>In the next section, we will explore another key aspect of linker scri<a id="_idTextAnchor146"/>pts: the expression of <span class="No-Break">numerical constants.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor147"/>Understanding constants in linker scripts</h2>
			<p>When <a id="_idIndexMarker378"/>writing our linker script, we must keep in mind the interpretation of numerical <a id="_idIndexMarker379"/>prefixes and suffixes by <span class="No-Break">the linker.</span></p>
			<p>Firstly, let’s clarify how the linker perceives integers with specific prefixes. An integer prefixed with <strong class="source-inline">0</strong> is read as an octal number by the linker. On the other hand, an integer starting with <strong class="source-inline">0x</strong> is recognized as a hexadecimal value. This distinction is important for accurately defining memory addresses <span class="No-Break">and sizes.</span></p>
			<p>The use of the <strong class="source-inline">K</strong> and <strong class="source-inline">M</strong> suffixes introduces another layer of convenience, allowing us to denote large numbers succinctly. The <strong class="source-inline">K</strong> suffix multiplies the preceding number by <strong class="source-inline">1024</strong>, while <strong class="source-inline">M</strong> expands the number by 1,024 twice over. Therefore, <strong class="source-inline">4K</strong> translates to 4 times 1024, and <strong class="source-inline">4M</strong> expands to 4 times <span class="No-Break">1,024 squared.</span></p>
			<p>To put these principles into practice, let’s explore an example that showcases the versatility of these notations. Imagine you need to specify a memory size of 4K. You could straightforwardly use <strong class="source-inline">4K</strong>, or opt for its decimal equivalent, <strong class="source-inline">4096</strong>, which results from multiplying 1,024 by 4. Alternatively, this quantity can be expressed in hexadecimal form <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">0x1000</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Table 4.2</em> summarizes <a id="_idIndexMarker380"/>the key points to remember about using constants in linker<a id="_idIndexMarker381"/> scripts. It highlights the prefixes and suffixes that modify the base value, which offers a clear reference for interpreting and using these notations effectively in your <span class="No-Break">linker script.</span></p>
			<table id="table002-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Notation</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Meaning</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Equivalent </strong><span class="No-Break"><strong class="bold">Decimal</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Hexadecimal </strong><span class="No-Break"><strong class="bold">Notation</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">0</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Octal prefix</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">010</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>-</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Hexadecimal prefix</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x10</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">16</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>-</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">K</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Multiplies <span class="No-Break">by 1,024</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">4K</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">4096</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x1000</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">M</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Multiplies by 1,024 <span class="No-Break">twice (squared)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">4M</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">4194304</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x400000</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2: Examples of linker script numerical prefixes and suffixes</p>
			<p>In the next section, we shall learn about linker script symbols, further enhancing our understanding of <span class="No-Break">linker scripts.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor148"/>Linker script symbols</h2>
			<p>Linker symbols, also known simply <a id="_idIndexMarker382"/>as <strong class="bold">symbols</strong>, are fundamental elements in the <a id="_idIndexMarker383"/>process of converting source code into executable programs. At its core, a linker symbol comprises two essential components: a name and a value. These symbols are assigned integer values, representing memory addresses where variables, functions, or other program elements are stored in the <span class="No-Break">microcontroller’s memory.</span></p>
			<p>Previously, we learned that after the assembly stage, the source code is transformed into object files. These object files contain machine code and unresolved references to variables and functions. The linker’s primary task is to merge these object files, resolve these unresolved symbols, and generate a complete executable file ready <span class="No-Break">for execution.</span></p>
			<p>In the context of linker symbols, the value assigned to a symbol represents the memory address where<a id="_idIndexMarker384"/> the corresponding <a id="_idIndexMarker385"/>variable or <span class="No-Break">function resides.</span></p>
			<p class="callout-heading">For example: X = 3500 means the memory address of X is 3500</p>
			<p class="callout">A symbol named <strong class="source-inline">X</strong> might be assigned a value of <strong class="source-inline">3500</strong>, indicating its memory address. It’s crucial to note that in contrast to the variable’s value in the source code, the <strong class="source-inline">X</strong> linker symbol represents its <span class="No-Break">memory address.</span></p>
			<table id="table003-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Value (Memory </strong><span class="No-Break"><strong class="bold">Address)</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">X</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Symbol</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">3500</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where an <strong class="source-inline">X</strong> variable <span class="No-Break">is stored.</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">Y</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Symbol</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x3000</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <strong class="source-inline">Y</strong> variable <span class="No-Break">is stored.</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">foo()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Symbol</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x4000</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <strong class="source-inline">foo()</strong> function <span class="No-Break">is located.</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">bar()</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Symbol</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0x5000</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <strong class="source-inline">bar()</strong> function <span class="No-Break">is located.</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">x</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Variable</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">3500</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the value of a C variable <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">y</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Variable</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">4500</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the value of a C variable <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3: Comparison of linker symbols and C source code variables assignments</p>
			<p>Linker symbols can undergo various operations, such as those we use in C assignments. These operations include straightforward assignment (<strong class="source-inline">=</strong>), addition (<strong class="source-inline">+=</strong>), and subtraction (<strong class="source-inline">-=</strong>), <span class="No-Break">among others.</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B21914_04_5.jpg" alt="Figure 4.5: Examples of linker symbol operations" width="630" height="489"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Examples of linker symbol operations</p>
			<p>During the<a id="_idIndexMarker386"/> linking process, a symbol table is created, mapping each symbol to its <a id="_idIndexMarker387"/>corresponding address in memory. This table serves as a crucial reference for the linker to resolve symbol references and ensure proper linking of <span class="No-Break">program components.</span></p>
			<p>Let’s consider a scenario where we have a <strong class="source-inline">main.c</strong> file and at the top of this file; we declare a variable named <strong class="source-inline">X</strong>, assigning it a value of <strong class="source-inline">568</strong>. Additionally, within this file, there’s a function named <strong class="source-inline">blink</strong>. Inside the <strong class="source-inline">blink</strong> function, there are operations to turn on an LED, wait, and then turn it off. This is depicted in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></p>
			<p>Now, let’s take this <strong class="source-inline">main.c</strong> file and pass it through the build process to generate the <strong class="source-inline">main.o</strong> object file. During this process, a symbol table is generated. Each symbol in this table is associated with <span class="No-Break">an address.</span></p>
			<p>For instance, the <strong class="source-inline">X</strong> symbol would be assigned an address of <strong class="source-inline">0x20000000</strong>, and similarly, the <strong class="source-inline">blink</strong> function would also be assigned its address. In the following figure, the <strong class="source-inline">blink</strong> function is assigned the <span class="No-Break"><strong class="source-inline">0x08000000</strong></span><span class="No-Break"> address.</span></p>
			<p>Essentially, just like in the C programming language, each variable has its value. In the object file, each symbol has its value, which essentially represents the address of the corresponding variable or function <span class="No-Break">in C.</span></p>
			<p>So, when referring<a id="_idIndexMarker388"/> to <strong class="source-inline">X</strong> in the object file, it wouldn’t give us <strong class="source-inline">568</strong>; rather, it would provide the<a id="_idIndexMarker389"/> address of <strong class="source-inline">X</strong>. This process of assigning values to symbols and associating them with addresses constructs the <span class="No-Break">symbol table.</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B21914_04_6.jpg" alt="Figure 4.6: Representation of functions and variables from the source file in the symbol table of the output object file" width="1213" height="424"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Representation of functions and variables from the source file in the symbol table of the output object file</p>
			<p>In this section, we delved deep into linker scripts, highlighting key components and directives. We carefully explored each directive, providing practical usage examples. Additionally, we distinguished between the LMA and VMA and also emphasized their important roles in guiding the linker on how to place sections. In the next section, we will learn how to write our own linker script and startup file from scratch, equipping you with another important skill in bare-metal <span class="No-Break">firmware development.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor149"/>Writing the linker script and startup file</h1>
			<p>Now that we have a good understanding of linker scripts and their essential components, we’re prepared to write our own. However, before diving into writing the script, it’s crucial to revisit the memory map of the microcontroller and gain insight into the <strong class="source-inline">positions</strong> load memory for various sections within the <span class="No-Break">object file.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor150"/>Understanding the load memory of different sections</h2>
			<p>As discussed earlier in this chapter, the output object file is structured into sections such as <strong class="source-inline">.data</strong>, <strong class="source-inline">.rodata</strong>, <strong class="source-inline">.text</strong>, and <strong class="source-inline">.bss</strong>. Together with the sections created by the assembler, we must define our own section to accommodate the vector table for <strong class="bold">interrupt service routines</strong> (<strong class="bold">ISRs</strong>). We will <a id="_idIndexMarker390"/>name this <span class="No-Break">section </span><span class="No-Break"><strong class="source-inline">.isr_vector_tbl</strong></span><span class="No-Break">.</span></p>
			<p>Each of these sections plays an important role in organizing the memory layout of the microcontroller, contributing to the functionality and efficiency of the <span class="No-Break">final executable.</span></p>
			<p><span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">4</em></span><em class="italic">.7</em> shows a zoomed-in view of the<a id="_idIndexMarker391"/> flash memory area, showing the required order for placing the different sections within the flash memory. Each section represents the combination of identical sections from all input files. For instance, the <strong class="source-inline">.text</strong> section depicted is a unified <strong class="source-inline">.text</strong> section, formed by merging all <strong class="source-inline">.text</strong> sections from the <span class="No-Break">input files.</span></p>
			<p>The diagram indicates that the placement must start with the <strong class="source-inline">.isr_vector_tbl</strong> section at the beginning of the flash memory. Following this, we must place the <strong class="source-inline">.text</strong> section, then the <strong class="source-inline">.rodata</strong> section, and finally, the <strong class="source-inline">.data</strong> section. The diagram does not show the placement of the <strong class="source-inline">.bss</strong> section, as we will place the <strong class="source-inline">.bss</strong> section directly in the SRAM. Additionally, during the startup code implementation, we must copy the content of the <strong class="source-inline">.data</strong> section from the flash memory to <span class="No-Break">the SRAM.</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B21914_04_7.jpg" alt="Figure 4.7: The flash memory area showing the order in which sections should be placed" width="1628" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: The flash memory area showing the order in which sections should be placed</p>
			<p>Before we proceed, however, let’s understand the concept of interrupts and the <span class="No-Break">vector table.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor151"/>Interrupts and the vector table</h2>
			<p>Interrupts are a fundamental concept in computing. They act as a powerful mechanism for managing how a computer or a microcontroller handles tasks and responds to external and <span class="No-Break">internal events.</span></p>
			<p>At its core, an <strong class="bold">interrupt</strong> is a<a id="_idIndexMarker392"/> signal to the processor from a hardware device or an internal software condition that temporarily halts the current operations. This signal indicates that immediate attention is required. When the processor receives an interrupt, it pauses its current tasks, saves its state, and executes a function known as an ISR to address the interrupt. Upon completing the ISR, the processor resumes its previous tasks, ensuring that critical signals receive prompt and <span class="No-Break">efficient handling.</span></p>
			<p><em class="italic">What are the types </em><span class="No-Break"><em class="italic">of interrupts?</em></span></p>
			<p>We can broadly classify interrupts into two categories: hardware interrupts and <span class="No-Break">software interrupts:</span></p>
			<ul>
				<li><strong class="bold">Hardware interrupts</strong>: These <a id="_idIndexMarker393"/>originate from external devices, such as <a id="_idIndexMarker394"/>switches, network adapters, or any peripheral that needs to communicate with the processor. For example, pressing a push button may trigger a hardware interrupt that informs the processor to start <span class="No-Break">a motor.</span></li>
				<li><strong class="bold">Software interrupts</strong>: Unlike <a id="_idIndexMarker395"/>hardware interrupts, software interrupts<a id="_idIndexMarker396"/> are triggered by software instructions. These are used by programs to interrupt the current process flow and execute a <span class="No-Break">specific routine.</span></li>
			</ul>
			<p><em class="italic">What is the role of the interrupt </em><span class="No-Break"><em class="italic">vector table?</em></span></p>
			<p>The interrupt vector table serves as an essential lookup table, guiding the processor to the correct ISR for each interrupt. An ISR is simply a function designed to address and manage the specific needs triggered by an interrupt. The table itself is <strong class="bold">organized as an array of pointers</strong>, with each pointer directing the system to the designated ISR for a given interrupt. Upon the occurrence of an interrupt, the system references this table to locate the exact memory address of the ISR required for handling the interrupt. This efficient mechanism enables the system to promptly respond to various events, such as external inputs, timer expirations, and changes in the <span class="No-Break">internal state.</span></p>
			<p>With this in mind, we are finally ready to write our <span class="No-Break">linker script.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor152"/>Writing the linker script</h2>
			<p>In our workspace folder, let’s <a id="_idIndexMarker397"/>make a new folder named <strong class="source-inline">3_LinkerscriptAndStartup</strong>. In this folder, create a file called <strong class="source-inline">stm32_ls.ld</strong> and make sure its extension is <strong class="source-inline">.ld</strong>. If you’re using Windows and it asks if you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor such <span class="No-Break">as Notepad++.</span></p>
			<p>Our objectives<a id="_idIndexMarker398"/> with the linker script can be summarized <span class="No-Break">as<a id="_idTextAnchor153"/> follows:</span></p>
			<ul>
				<li>Specifying the firmware’s <span class="No-Break">entry point</span></li>
				<li>Detailing the <span class="No-Break">available memory</span></li>
				<li>Specifying the necessary heap and <span class="No-Break">stack sizes</span></li>
				<li>Defining <span class="No-Break">output<a id="_idTextAnchor154"/> sections</span></li>
			</ul>
			<p>This is our complete linker script, the contents of the <span class="No-Break"><strong class="source-inline">stm32_ls.ld</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
/*Specifying the firmware's entry point*/
ENTRY(Reset_Handler)
/*Detailing the available memory*/
MEMORY
{
    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K
    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K
}
_estack = ORIGIN(SRAM)+LENGTH(SRAM);
/*Specifying the necessary heap and stack sizes*/
__max_heap_size = 0x200;
__max_stack_size = 0x400;
/*Defining output sections*/
SECTIONS
{
    .text :
    {
     . = ALIGN(4);
      *(.isr_vector_tbl)
      *(.text)
      *(.rodata)
      . = ALIGN(4);
     _etext = .;
    }&gt;FLASH
    .data :
    {
     . = ALIGN(4);
    _sdata = .;
      *(.data)
     . = ALIGN(4);
    _edata = .;
    } &gt; SRAM AT&gt; FLASH  /*&gt;(vma) AT&gt; (lma)*/
        .bss :
    {
     . = ALIGN(4);
    _sbss = .;
    *(.bss)
     . = ALIGN(4);
    _ebss = .;
    <a id="_idTextAnchor155"/>}&gt; SRAM
}</pre>			<p>Let’s break <span class="No-Break">it down.</span></p>
			<h3>Specifying the firmware’s entry point</h3>
			<pre class="source-code">
ENTRY(Reset_Handler)</pre>			<p>As we learned<a id="_idIndexMarker399"/> earlier, the <strong class="source-inline">ENTRY</strong> directive specifies the entry point of the firmware, which is the first piece of code that gets executed when the firmware starts. In this case, the entry point is the function named <strong class="source-inline">Reset_Handler</strong>. We shall implement this function in the <span class="No-Break">sta<a id="_idTextAnchor156"/>rtup file.</span></p>
			<h3>Detailing the available memory</h3>
			<pre class="source-code">
MEMORY
{
    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K
    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K
}</pre>			<p>Our script<a id="_idIndexMarker400"/> specifies two memory regions: <strong class="source-inline">FLASH</strong> and <strong class="source-inline">SRAM</strong>. The <strong class="source-inline">FLASH</strong> memory, with read and execute permissions (<strong class="source-inline">rx</strong>), starts at the <strong class="source-inline">0x08000000</strong> address and has a length of <strong class="source-inline">512K</strong>. The SRAM memory, with read, write, and execute permissions (<strong class="source-inline">rwx</strong>), starts at the <strong class="source-inline">0x20000000</strong> address and has a length <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">128K</strong></span><span class="No-Break">.</span></p>
			<h3>Symbol creation</h3>
			<pre class="source-code">
_estack = ORIGIN(SRAM)+LENGTH(SRAM);</pre>			<p>Over here, we <a id="_idIndexMarker401"/>create a symbol called <strong class="source-inline">_estack</strong> and we set it to the end of the <strong class="source-inline">SRAM</strong> memory region. We will use this symbol to initialize the <span class="No-Break">stack pointer.</span></p>
			<p>The <strong class="bold">stack pointer</strong> is <a id="_idIndexMarker402"/>an important register within our microcontroller that keeps track of the top of the stack. When a function is called, the address of the next instruction (return address) and the function’s local variables are pushed onto the stack. The stack pointer is then adjusted to reflect the addition of these new items. Conversely, when a function returns, the stack pointer helps to pop the return address and the local variables off the stack, reverting it to its state before the function is called. The stack grows downward (from high memory to low memory addresses in most architectures), so setting the stack<a id="_idIndexMarker403"/> pointer to the end of <strong class="source-inline">SRAM</strong> ensures that it starts at the maximum available address, utilizing the <strong class="source-inline">SRAM</strong> space efficiently for <span class="No-Break">stack operations.</span></p>
			<p>The next lines of code in our linker script specify the heap and <span class="No-Break">stack sizes.</span></p>
			<h3>Specifying the necessary heap and stack sizes</h3>
			<pre class="source-code">
__max_heap_size = 0x200;
__max_stack_size = 0x400;</pre>			<p>These lines <a id="_idIndexMarker404"/>define the maximum sizes for the heap (<strong class="source-inline">0x200</strong> bytes) and stack (<strong class="source-inline">0x400</strong> bytes). These sizes are important for dynamic memory allocation and function call <span class="No-Break">management, respectively.</span></p>
			<p>The next segment defines the <span class="No-Break">output sections.</span></p>
			<h3>Defining output sections</h3>
			<p>In this section, we <a id="_idIndexMarker405"/>will go through the <span class="No-Break">output sections.</span></p>
			<h4>The .text output section</h4>
			<p>This segment of <a id="_idIndexMarker406"/>our linker script shows the <strong class="source-inline">.text</strong> <span class="No-Break">output section:</span></p>
			<pre class="source-code">
.text :
{
  . = ALIGN(4);
  *(.isr_vector_tbl)  /*merge all .isr_vector_tbl sections of input 
  files*/
  *(.text)   /*merge all .text sections of input files*/
  *(.rodata) /*merge all .rodata sections of input files*/
  . = ALIGN(4);
 _etext = .;  /*Create a global symbol to hold end of text section*/
}&gt;FLASH</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">. = </strong><span class="No-Break"><strong class="source-inline">ALIGN(4);</strong></span><span class="No-Break">:</span><p class="list-inset">This directive aligns <a id="_idIndexMarker407"/>the start of the <strong class="source-inline">.text</strong> section on a <strong class="source-inline">4</strong>-byte boundary. This enhances memory access efficiency, which is a critical consideration for processors fetching instructions in <span class="No-Break">word-sized chunks.</span></p></li>
				<li><strong class="source-inline">*(<a id="_idTextAnchor157"/>.</strong><span class="No-Break"><strong class="source-inline">isr_vector_tbl)</strong></span><span class="No-Break"> :</span><p class="list-inset">This directive pulls in all sections named <strong class="source-inline">.isr_vector_tbl</strong> from the input files into the current location in <a id="_idTextAnchor158"/>the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">text</strong></span><span class="No-Break"> section.</span></p></li>
				<li><strong class="source-inline">*(.</strong><span class="No-Break"><strong class="source-inline">text)</strong></span><span class="No-Break">:</span><p class="list-inset">This directive pulls in all sections named <strong class="source-inline">.text</strong> from the input files into the current location in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">text</strong></span><span class="No-Break"> section.</span></p></li>
				<li><strong class="source-inline">*(.</strong><span class="No-Break"><strong class="source-inline">rodata)</strong></span><span class="No-Break">:</span><p class="list-inset">This directive pulls in all sections named <strong class="source-inline">.rodata</strong> from the input files into the current location in <a id="_idTextAnchor159"/>the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">text</strong></span><span class="No-Break"> section.</span></p></li>
				<li><strong class="source-inline">. = </strong><span class="No-Break"><strong class="source-inline">ALIGN(4);</strong></span><span class="No-Break">:</span><p class="list-inset">Again, this line ensures that the end of the section is aligned to a <strong class="source-inline">4</strong>-byte boundary. Over here, we use it to align the end of a section, ensuring that the next section starts on an <span class="No-Break">aligned boun<a id="_idTextAnchor160"/>dary.</span></p></li>
				<li><strong class="source-inline">_etext = .;</strong>:<p class="list-inset">Over here, we define a symbol called <strong class="source-inline">_etext</strong> at the current location. This symbol marks the end of the <strong class="source-inline">.text</strong> section. We will use this symbol as a pointer to the end of the <strong class="source-inline">.text</strong> section in our <span class="No-Break">startup file.</span></p></li>
				<li><strong class="source-inline">}&gt;</strong><span class="No-Break"><strong class="source-inline">FLASH</strong></span><span class="No-Break">:</span><p class="list-inset">This directive<a id="_idIndexMarker408"/> specifies that the <strong class="source-inline">.text</strong> section should be placed in the <strong class="source-inline">FLASH</strong> memory segment as defined earlier in the <strong class="source-inline">MEMORY</strong> block of<a id="_idTextAnchor161"/> the <span class="No-Break">linker script.</span></p></li>
			</ul>
			<p>This segment shows the <strong class="source-inline">.data</strong> <span class="No-Break">output section:</span></p>
			<pre class="source-code">
    .data :
    {
     . = ALIGN(4);
    _sdata = .;   /*Create a global symbol to hold start of data 
    section*/
      *(.data)
     . = ALIGN(4);
    _edata = .;   /*Create a global symbol to hold end of data 
    section*/
    } &gt; SRAM AT&gt; FLASH  /*&gt;(VMA) AT&gt; (LMA)*/</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline"> = </strong><span class="No-Break"><strong class="source-inline">ALIGN(4);</strong></span><span class="No-Break">:</span><p class="list-inset">This directive aligns the start of the <strong class="source-inline">.data</strong> section on a <span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">-byte bou<a id="_idTextAnchor162"/>ndary.</span></p></li>
				<li><strong class="source-inline">_sdata = .;</strong>:<p class="list-inset">Over here, we create a symbol named <strong class="source-inline">_sdata</strong> to represent the start of the <strong class="source-inline">.data</strong> section by setting it to the current location counter. We will use this symbol as a pointer to the start of the <strong class="source-inline">.data</strong> section in our <span class="No-Break">startup file.</span></p></li>
				<li><strong class="source-inline">*(.</strong><span class="No-Break"><strong class="source-inline">data)</strong></span><span class="No-Break">:</span><p class="list-inset">This directive pulls in all sections named <strong class="source-inline">.data</strong> from the input files into the current location in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> section.</span></p></li>
				<li><strong class="source-inline">. = </strong><span class="No-Break"><strong class="source-inline">ALIGN(4);</strong></span><span class="No-Break">:</span><p class="list-inset">This line<a id="_idIndexMarker409"/> ensures that the end of the section is aligned to a <span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">-byte boundary.</span></p></li>
				<li><span class="No-Break"><strong class="source-inline">_edata= .;</strong></span><span class="No-Break">:</span><p class="list-inset">Similar to what we have done previously, we create a symbol named <strong class="source-inline">_edata</strong> to represent the end of the <strong class="source-inline">.data</strong> section by setting it to the current location counter. We will use this symbol in our <span class="No-Break">startup file.</span></p></li>
				<li><strong class="source-inline">&gt; SRAM </strong><span class="No-Break"><strong class="source-inline">AT&gt; FLASH</strong></span><span class="No-Break">:</span><p class="list-inset">This directive specifies the LMA and the VMA of the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> section.</span></p><p class="list-inset"><strong class="source-inline">&gt; SRAM</strong> indicates that the section should be located in SRAM, allowing read and write access <span class="No-Break">at runtime.</span></p><p class="list-inset"><strong class="source-inline">AT&gt; FLASH</strong> tells the linker that although the section is placed in <strong class="source-inline">SRAM</strong> for execution, its initial values should be stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">FLASH</strong></span><span class="No-Break">.</span></p></li>
			</ul>
			<p>This segment shows the <strong class="source-inline">.bss</strong> <span class="No-Break">output section:</span></p>
			<pre class="source-code">
.bss :
{
 . = ALIGN(4);
_sbss = .;
*(.bss)
 . = ALIGN(4);
_ebss = .;
}&gt; SRAM</pre>			<p>This is the final output section of our <span class="No-Break">linker script.</span></p>
			<p>As we learned earlier, the <strong class="source-inline">.bss</strong> section holds uninitialized global and static variables that we will be initialized to zero in our startup file. This zero-initialization ensures that all variables in this section begin with a known state, contributing to our firmware’s stability <span class="No-Break">and predictability.</span></p>
			<p>Similar to other sections, we begin by aligning the section to a <strong class="source-inline">4</strong>-byte boundary for efficient memory access, and then we define the <strong class="source-inline">_sbss</strong> and <strong class="source-inline">_ebss</strong> symbols to mark the start and end of the section, respectively. These symbols facilitate the calculation of the section’s size and its initialization process. Finally, we place the section in the SRAM, emphasizing that, although it doesn’t occupy space in the binary file on disk, it requires runtime allocation <span class="No-Break">in memory.</span></p>
			<p>With our linker script finalized, we’ll move on to implementing the startup file. This shall be the focus of the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor163"/>Writing the startup file</h2>
			<p>The startup file is essential for initializing<a id="_idIndexMarker410"/> the firmware and it performs several critical tasks to ensure the system operates correctly from the moment it is <span class="No-Break">powered on.</span></p>
			<p>These tasks include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Implementing the vector table</strong>: This involves defining the vector table that maps interrupts to their handlers, ensuring the system can respond to various <span class="No-Break">events efficiently.</span></li>
				<li><strong class="bold">Creating interrupt handlers</strong>: For each interrupt listed in the vector table, an interrupt handler must be implemented to define how the system responds to that <span class="No-Break">particular event.</span></li>
				<li><strong class="bold">Establishing the firmware’s entry point</strong>: This refers to implementing <strong class="source-inline">Reset_Handler</strong>, as specified in the linker script, which acts as the initial entry point of the firmware. This function is executed immediately after reset and is responsible for setting up the environment for the <span class="No-Break">main application.</span></li>
				<li><strong class="bold">Transferring the .data section</strong>: This involves copying the <strong class="source-inline">.data</strong> section from <strong class="source-inline">FLASH</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Zeroing the .bss section</strong>: This involves initializing the <strong class="source-inline">.bss</strong> section to zero, ensuring that all uninitialized global and static variables start with a known state fo<a id="_idTextAnchor164"/>r <span class="No-Break">reliable operation.</span></li>
			</ul>
			<p>In the current folder <a id="_idIndexMarker411"/>containing the linker script, create a file called <strong class="source-inline">stm32f411_startup.c</strong> and make sure its extension is <strong class="source-inline">.c</strong>. If you’re using Windows and it asks if you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor such <span class="No-Break">as Notepad++.</span></p>
			<p>Let’s analyze the complete <span class="No-Break">startup code.</span></p>
			<p>The following is our complete startup code written in C, the contents of the <strong class="source-inline">stm32f411_startup.c</strong> file. In the following snippet, we are not showing all the function prototypes of all the interrupts in the vector table. The complete source code can be found in the resources accompanying <span class="No-Break">the book:</span></p>
			<pre class="source-code">
extern uint32_t _estack;
extern uint32_t _etext;
extern uint32_t _sdata;
extern uint32_t _edata;
extern uint32_t _sbss;
extern uint32_t _ebss;
void Reset_Handler(void);
int main(void);
void NMI_Handler(void)__attribute__((weak,
alias("Default_Handler")));
void HardFault_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
void MemManage_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
.
.
.
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl"))) = {
    (uint32_t)&amp;_estack,
    (uint32_t)&amp;Reset_Handler,
    (uint32_t)&amp;NMI_Handler,
    (uint32_t)&amp;HardFault_Handler,
    (uint32_t)&amp;MemManage_Handler,
.
.
.
};
void Default_Handler(void) {
    while(1) {
    }
}
void Reset_Handler(void)
{
    // Calculate the sizes of the .data and .bss sections
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;
    // Initialize pointers to the source and destination of the .data 
    // section
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;
    /*Copy .data section from FLASH to SRAM*/
    for(uint32_t i = 0; i &lt; data_mem_size; i++  )
    {
         *p_dest_mem++ = *p_src_mem++;
    }
    // Initialize the .bss section to zero in SRAM
    p_dest_mem =  (uint32_t *)&amp;_sbss;
    for(uint32_t i = 0; i &lt; bss_mem_size; i++)
    {
         /*Set bss section to zero*/
        *p_dest_mem++ = 0;
    }
        // Call the application's main function.
    main();
}</pre>			<p>Let’s break <span class="No-Break">it down.</span></p>
			<p>We start by declaring <span class="No-Break">external symbols.</span></p>
			<h3>External symbol declarations</h3>
			<pre class="source-code">
extern uint32_t _estack;
extern uint32_t _etext;
extern uint32_t _sdata;
extern uint32_t _edata;
extern uint32_t _sbss;
extern uint32_t _ebss;</pre>			<p>These lines declare the <a id="_idIndexMarker412"/>external symbols that we defined in the linker script. Each symbol represents an important memory address used during the <span class="No-Break">startup process:</span></p>
			<ul>
				<li><strong class="source-inline">_estack</strong>: This is the initial top of the stack. This value is loaded into the main stack pointer register early in the <span class="No-Break">startup process.</span></li>
				<li><strong class="source-inline">_etext:</strong> This marks the end of the executable code section and the beginning of the data sections stored in flash memory. We use this as a reference point for copying initialized data from <strong class="source-inline">FLASH</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">_sdata</strong> and <strong class="source-inline">_edata</strong> represent the start and end addresses of the initialized data section in SRAM, respectively. We use them to determine the size and destination for data copying from <strong class="source-inline">FLASH</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RAM</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">_sbss</strong> and <strong class="source-inline">_ebss</strong> mark the start and end of the uninitialized data section (BSS section) in SRAM. We use these symbols to clear this section, setting it <span class="No-Break">to zero.</span></li>
			</ul>
			<p>Next in our snippet, we have the function prototypes and <span class="No-Break">their attributes.</span></p>
			<h3>Function prototypes and attributes</h3>
			<pre class="source-code">
void Reset_Handler(void);
int main(void);
void NMI_Handler(void)__attribute__((weak,
alias("Default_Handler")));
void HardFault_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
void MemManage_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
.
.
.</pre>			<p>At this part of the<a id="_idIndexMarker413"/> startup file, we declare the prototype for the <strong class="source-inline">Reset_Handler</strong> function, the application’s <strong class="source-inline">main</strong> function, and several interrupt handlers with <span class="No-Break">specific attributes:</span></p>
			<p><strong class="source-inline">__attribute__((weak, alias("Default_Handler"))):</strong> This attribute makes each handler weakly linked and aliases it to a function named <strong class="source-inline">Default_Handler</strong>. It allows these handlers to be overridden by explicitly defined handlers with the same name elsewhere in <span class="No-Break">the application.</span></p>
			<p>Let’s break down the statement further to understand <span class="No-Break">its significance:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">__attribute__</strong></span><span class="No-Break">:</span><p class="list-inset">We use this keyword to tell the compiler that the declaration it’s applied to has certain properties that affect how it’s treated by the linker and, potentially, at runtime. Attributes can be used to control optimizations, code generation, alignment, and, relevant to our discussion, <span class="No-Break">linkage characteristics.</span></p></li>
				<li><span class="No-Break"><strong class="source-inline">weak</strong></span><span class="No-Break">:</span><p class="list-inset">Declaring a function or variable as <strong class="source-inline">weak</strong> means that it does not prevent the linker from using another symbol of the same name with a stronger linkage. We use this to specify default implementations that can <span class="No-Break">be overridden.</span></p><p class="list-inset">In the context of our interrupt handlers, marking them as <strong class="source-inline">weak</strong> allows us to define default handlers in our startup file, which application-specific handlers can override without modifying the <span class="No-Break">startup file.</span></p></li>
				<li><span class="No-Break"><strong class="source-inline">alias("Default_Handler")</strong></span><span class="No-Break">:</span><p class="list-inset">This part of the attribute creates an alias for another symbol, in this case, <strong class="source-inline">Default_Handler</strong>. It means that the symbol (e.g., <strong class="source-inline">NMI_Handler</strong>) is not just weak, but it is also an alias for the <span class="No-Break"><strong class="source-inline">Default_Handler</strong></span><span class="No-Break"> function.</span></p><p class="list-inset">This means that when an interrupt occurs, and a specific handler (such as <strong class="source-inline">NMI_Handler</strong>) has not been defined elsewhere in the application with stronger linkage (non-weak), the program will use <strong class="source-inline">Default_Handler</strong> in its place. This ensures<a id="_idIndexMarker414"/> that all interrupts have a handler, preventing the system from crashing due to <span class="No-Break">unhandled events.</span></p></li>
			</ul>
			<p>Next, we have the vector <span class="No-Break">table array.</span></p>
			<h3>Vector table definition</h3>
			<pre class="source-code">
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl"))) = {
    (uint32_t)&amp;_estack,
    (uint32_t)&amp;Reset_Handler,
    (uint32_t)&amp;NMI_Handler,
    (uint32_t)&amp;HardFault_Handler,
    (uint32_t)&amp;MemManage_Handler,
…
};</pre>			<p>This array defines the <a id="_idIndexMarker415"/>microcontroller’s interrupt vector table, placed in the <strong class="source-inline">.isr_vector_tbl</strong> section we defined in the <span class="No-Break">linker script.</span></p>
			<p>We set the <strong class="source-inline">&amp;_estack</strong> symbol as the first element of the vector table to define the initial top of the stack in memory. In ARM Cortex microcontrollers, such as our STM32F411, the first word (32 bits) of the vector table must contain the initial value of the <strong class="bold">main stack pointer</strong> (<strong class="bold">MSP</strong>). Upon<a id="_idIndexMarker416"/> reset, the processor loads this value into the MSP register to set up the stack pointer correctly before executing <span class="No-Break">any code.</span></p>
			<p>Following this, we specify the address of <strong class="source-inline">Reset_Handler</strong>, then we proceed to list the addresses for <strong class="source-inline">NMI_Handler</strong> and other subsequent interrupt handlers in sequence. The precise placement of these handlers is crucial, as each must reside in a specific memory location to ensure correct functionality. This arrangement is detailed on <em class="italic">page 201</em> of the RM0383 document. Within the fully defined vector table in our <strong class="source-inline">stm32f411_startup.c</strong> file, you’ll notice that there are zeros strategically placed among the interrupt handler addresses. These zeros act as placeholders for the positions corresponding to interrupts not supported by our specific microcontroller variant (STM32F411). The ARM Cortex-M core architecture is designed to support a comprehensive set of interrupts, yet not all interrupts are implemented across every microcontroller variant. By inserting zeros for these unsupported interrupts in the vector table, we maintain the required alignment with the architecture’s specifications, ensuring the system <span class="No-Break">operates correctly.</span></p>
			<p>Let’s take a closer look at the <span class="No-Break">array declaration:</span></p>
			<pre class="source-code">
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl")))={…}</pre>			<ul>
				<li><span class="No-Break"><strong class="source-inline">uint32_t vector_tbl[]</strong></span><span class="No-Break">:</span><p class="list-inset">This specifies that each element of the <strong class="source-inline">vector_tbl</strong> array is an unsigned 32-bit integer. We chose this type because addresses in ARM Cortex-M microcontrollers are 32 bits in length, and the vector table consists of memory addresses pointing to the start of <span class="No-Break">ISR handlers.</span></p></li>
				<li><span class="No-Break"><strong class="source-inline">__attribute__((section(".isr_vector_tbl")))</strong></span><span class="No-Break">:</span><p class="list-inset">This attribute instructs the linker to place the <strong class="source-inline">vector_tbl</strong> array in a specific section of the<a id="_idIndexMarker417"/> output file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">.isr_vector_tbl</strong></span><span class="No-Break">.</span></p></li>
			</ul>
			<p>Next, we have our default <span class="No-Break">handler function.</span></p>
			<h3>Default dandler</h3>
			<pre class="source-code">
void Default_Handler(void) {
    while(1) {
        // Infinite loop
    }
}</pre>			<p>This function serves as a <a id="_idIndexMarker418"/>universal fallback for any interrupt request for which a specific handler has not been implemented. Engaging in an infinite loop effectively prevents the program from proceeding into an undefined state following such <span class="No-Break">an event.</span></p>
			<p>It is linked to all interrupt handlers marked as <strong class="source-inline">weak</strong> and aliased to <strong class="source-inline">Default_Handler</strong> within the application. This strategy ensures a uniform and secure response throughout the system to any interrupt requests that lack a dedicated handler, thus upholding system stability <span class="No-Break">and integrity.</span></p>
			<p>Finally, we have our <span class="No-Break"><strong class="source-inline">Reset_Handler</strong></span><span class="No-Break"> function.</span></p>
			<h3>Reset handler implementation</h3>
			<pre class="source-code">
void Reset_Handler(void) {
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;
    for(uint32_t i = 0; i &lt; data_mem_size; i++  ) {
        *p_dest_mem++ = *p_src_mem++;
    }
    p_dest_mem =  (uint32_t *)&amp;_sbss;
    for(uint32_t i = 0; i &lt; bss_mem_size; i++) {
        *p_dest_mem++ = 0;
    }
    main();
}</pre>			<p>The job of <strong class="source-inline">Reset_Handler</strong> is to <a id="_idIndexMarker419"/>prepare the system before executing the <span class="No-Break">main application.</span></p>
			<p>In the function, we start by calculating the sizes of the <strong class="source-inline">.data</strong> and <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">bss</strong></span><span class="No-Break"> sections:</span></p>
			<pre class="source-code">
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;</pre>			<p>Here is <span class="No-Break">a breakdown:</span></p>
			<ul>
				<li>Calculate the size of the <strong class="source-inline">.data</strong> section by subtracting the address of the start of the section (<strong class="source-inline">_sdata</strong>) from the address of the end (<strong class="source-inline">_edata</strong>). This size is used to copy initialized data from <strong class="source-inline">FLASH</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">.</span></li>
				<li>Calculate the size of the <strong class="source-inline">.bss</strong> section in a similar manner, using the start (<strong class="source-inline">_sbss</strong>) and end (<strong class="source-inline">_ebss</strong>) addresses. This size is used to zero out the <strong class="source-inline">.bss</strong> section <span class="No-Break">in SRAM.</span><p class="list-inset">Next, in the function, we initialize pointers for copying the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> section:</span></p><pre class="source-code">
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;</pre></li>			</ul>
			<p>Here is <span class="No-Break">the breakdown:</span></p>
			<ul>
				<li>Initialize a source pointer (<strong class="source-inline">p_src_mem</strong>) to the address where initialized data is stored in flash memory, marked <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">_etext</strong></span><span class="No-Break">.</span></li>
				<li>Initialize a destination pointer (<strong class="source-inline">p_dest_mem</strong>) to the start of the <strong class="source-inline">.data</strong> section in <span class="No-Break">SRAM (</span><span class="No-Break"><strong class="source-inline">_sdata</strong></span><span class="No-Break">).</span><p class="list-inset">Then, we copy the <strong class="source-inline">.data</strong> section from <strong class="source-inline">FLASH</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SRAM</strong></span><span class="No-Break">:</span></p><pre class="source-code">
    for(uint32_t i = 0; i &lt; data_mem_size; i++  ) {
        *p_dest_mem++ = *p_src_mem++;
    }</pre></li>			</ul>
			<p><span class="No-Break">The </span><span class="No-Break"><a id="_idIndexMarker420"/></span><span class="No-Break">breakdown:</span></p>
			<ul>
				<li>Copy the <strong class="source-inline">.data</strong> section from <strong class="source-inline">FLASH</strong> to <strong class="source-inline">SRAM</strong> word (32-bit) by word. For each iteration, the content pointed to by <strong class="source-inline">p_src_mem</strong> is copied to the location pointed to by <strong class="source-inline">p_dest_mem</strong>, and then both pointers are incremented to the <span class="No-Break">next word.</span></li>
			</ul>
			<p>Next, we initialize the pointer for the <strong class="source-inline">.bss</strong> <span class="No-Break">section zeroing:</span></p>
			<pre class="source-code">
    p_dest_mem =  (uint32_t *)&amp;_sbss;</pre>			<p>We simply reset the destination pointer (<strong class="source-inline">p_dest_mem</strong>) to the start of the <strong class="source-inline">.bss</strong> section in SRAM (<strong class="source-inline">_sbss</strong>), preparing it <span class="No-Break">for zeroing.</span></p>
			<p>We then zero out the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">bss</strong></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
    for(uint32_t i = 0; i &lt; bss_mem_size; i++) {
        *p_dest_mem++ = 0;
    }</pre>			<p>This block zeroes out the <strong class="source-inline">.bss</strong> section in <strong class="source-inline">SRAM</strong> word by word. For each iteration, the location pointed to by <strong class="source-inline">p_dest_mem</strong> is set to <strong class="source-inline">0</strong>, and then <strong class="source-inline">p_dest_mem</strong> is incremented to the <span class="No-Break">next word.</span></p>
			<p>Finally, we call the <strong class="source-inline">main()</strong> function located in the <strong class="source-inline">main.c</strong> file of our <span class="No-Break">source code:</span></p>
			<pre class="source-code">
    main();</pre>			<p>After initializing<a id="_idIndexMarker421"/> the <strong class="source-inline">.data</strong> and <strong class="source-inline">.bss</strong> sections, this line calls the <strong class="source-inline">main</strong> function, transferring control to the main application code. This marks the end of the system initialization process and the beginning of the <span class="No-Break">application execution.</span></p>
			<p>Now that we have completed both our linker script and startup file, it is time to test our implementation by building the firmware using just our <strong class="source-inline">main.c</strong> source file, the <strong class="source-inline">stm32_ls.ld</strong> linker script, and the <strong class="source-inline">stm32f411_startup.c</strong> <span class="No-Break">startup file.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor165"/>Testing our linker script and startup file</h2>
			<p>Before diving<a id="_idIndexMarker422"/> into the <a id="_idIndexMarker423"/>command line, it’s important to ensure that our linker script and startup file are correctly placed. Let’s set up our project directory and add som<a id="_idTextAnchor166"/>e modification to our <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li><strong class="bold">Create a new directory</strong>: Create a new folder named <strong class="source-inline">3_LinkerAndStartup</strong> in <span class="No-Break">your workspace.</span></li>
				<li><strong class="bold">Transfer </strong><span class="No-Break"><strong class="bold">required files</strong></span><span class="No-Break">:</span><ul><li>Locate the <strong class="source-inline">main.c</strong> file from the previous project (<strong class="source-inline">2_RegisterManipulation</strong>), which includes the foundational <span class="No-Break">application code.</span></li><li>Additionally, locate <strong class="source-inline">stm32_ls.ld</strong> (linker script) and <strong class="source-inline">stm32f411_startup.c</strong> (<span class="No-Break">startup file).</span></li><li>Copy and paste these files (<strong class="source-inline">stm32_ls.ld, stm32f411_startup.c</strong>, and <strong class="source-inline">main.c</strong>) into the <span class="No-Break"><strong class="source-inline">3_LinkerAndStartup</strong></span><span class="No-Break"> folder.</span></li></ul></li>
				<li><strong class="bold">Modify the main application code</strong>: To visually confirm the successful execution of our latest firmware, let’s adjust the LED blink rate within the <strong class="source-inline">main.c</strong> file from fast <span class="No-Break">to slow:</span><ul><li><strong class="bold">Open the main.c file for editing</strong>: Right-click on the <strong class="source-inline">main.c</strong> file within the <strong class="source-inline">3_LinkerAndStartup</strong> folder and select the option to open it with a simple text editor, such <span class="No-Break">as Notepad++.</span></li><li><strong class="bold">Change the blink rate</strong>: Search for the code segment that controls the toggling of PA5 (<strong class="source-inline">LED_PIN</strong>). Adjust the delay intervals within this section to change<a id="_idIndexMarker424"/> the LED’s blink rate from its current rapid pace to a<a id="_idIndexMarker425"/> slower one. Th<a id="_idTextAnchor167"/>e current one should look <span class="No-Break">like this:</span><pre class="source-code">
        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; 100000; i++){}</pre></li></ul><p class="list-inset">Replace the current code with the following snippet to toggle the state of PA5 at a <span class="No-Break">slower rate:</span></p><pre class="source-code">        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; <strong class="bold">5000000</strong>; i++){}</pre><p class="list-inset">We are simply changing the loop iteration from 100,000 <span class="No-Break">to 5,000,000.</span></p><ul><li><strong class="bold">Save the changes</strong>: After updating the code, save the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></li></ul></li>			</ol>
			<p>Now, let’s access our new folder through the Command Prompt following the steps we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. My favorite method for Windows users is the context <span class="No-Break">menu method:</span></p>
			<p>Navigate to the <strong class="source-inline">3_LinkerAndStartup</strong> folder in Windows Explorer. Once there, hold down the <em class="italic">Shift</em> key, <em class="italic">right-click</em> in a space within the folder, and select <strong class="bold">Open Command Window Here</strong>. This action will open a Command Prompt window directly in the <span class="No-Break"><strong class="source-inline">3_LinkerAndStartup</strong></span><span class="No-Break"> folder.</span></p>
			<p>In the Command<a id="_idIndexMarker426"/> Prompt, we start by compiling the <strong class="source-inline">main.c</strong> file, and we do this<a id="_idIndexMarker427"/> by executing <span class="No-Break">the following:</span></p>
			<pre class="console">
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -o mai<a id="_idTextAnchor168"/>n.o</pre>			<p>Then, we execute our <span class="No-Break">startup file:</span></p>
			<pre class="console">
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c -o stm32f411_startup.o</pre>			<p>Once our <strong class="source-inline">main.o</strong> and <strong class="source-inline">stm32f411_startup.o</strong> object files are ready, we go ahead and link all objec<a id="_idTextAnchor169"/>t files (<strong class="source-inline">*.o</strong>) using our <span class="No-Break">linker script:</span></p>
			<pre class="console">
arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o 3_LinkerAndStartup.elf.elf</pre>			<p>This process produces the <span class="No-Break"><strong class="source-inline">3_LinkerAndStartup.elf</strong></span><span class="No-Break"> executable.</span></p>
			<p>Next, we launch <strong class="source-inline">openocd</strong> to begin the <span class="No-Break">uploading process:</span></p>
			<pre class="console">
openocd -f board/st_nucleo_f4.cfg</pre>			<p>With OpenOCD running, the next step involves using <a id="_idIndexMarker428"/>the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) to upload the firmware to the microcontroller. Let’s access another Command Prompt window (as OpenOCD should keep running in the first one) and enter the following command to start <span class="No-Break">the GDB:</span></p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once GDB is open, we establish a connection to our microcontroller <span class="No-Break">by running:</span></p>
			<pre class="console">
target remote localhost:3333</pre>			<p>Let’s reset and initialize the board as we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> using the <span class="No-Break">following command:</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Next, we load the firmware onto the microcontroller using the <span class="No-Break">following command:</span></p>
			<pre class="console">
monitor flash write_image erase 3_LinkerAndStartup.elf</pre>			<p>After successfully loading the firmware, we reset the board again with the same <span class="No-Break">reset command:</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Finally, we resume the execution of the firmware on the microcontroller with <span class="No-Break">the following:</span></p>
			<pre class="console">
monitor resume</pre>			<p>There you have it; you should see the LED blinking at a slower rate, indicating the successful upload and execution of our <span class="No-Break">new firmware.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we deeply explored the core components of embedded bare-metal programming, focusing on the microcontroller’s memory model, writing linker scripts, and startup files. We began by exploring the STM32 microcontroller’s memory layout, emphasizing the importance of flash memory and SRAM for storing executable code and <span class="No-Break">runtime data.</span></p>
			<p>We then dedicated a significant portion of the chapter to constructing and understanding linker scripts. Through this, we understood these scripts’ critical role in the firmware build process by mapping the compiled firmware sections to the microcontroller’s specific memory regions to ensure the executable operates correctly. We learned about the various directives within a linker script, such as <strong class="source-inline">MEMORY</strong> and <strong class="source-inline">SECTIONS</strong>. These directives are crucial for defining the memory layout and specifying where and how program sections are placed <span class="No-Break">in memory.</span></p>
			<p>Our discussion on linker scripts extended to the practicalities of defining memory regions, aligning sections, and managing section attributes for optimal memory utilization. We gave special attention to the LMA and VMA, which are essential for efficient program loading <span class="No-Break">and execution.</span></p>
			<p>Transitioning to the startup file, we meticulously outlined the startup file’s role, covering the initialization of the vector table, setting up <strong class="source-inline">Reset_Handler</strong>, and preparing the system for the execution of the main application. We learned the procedures for copying the <strong class="source-inline">.data</strong> section from <strong class="source-inline">FLASH</strong> to <strong class="source-inline">SRAM</strong> and zeroing the <strong class="source-inline">.bss</strong> section, ensuring a predictable start for <span class="No-Break">our firmware.</span></p>
			<p>In the next chapter, we will explore build systems, highlighting the essential role of the <strong class="source-inline">Make</strong> tool. This knowledge will enable us to streamline our build process by automating it, instead of manually entering each command in the <span class="No-Break">command line.</span></p>
		</div>
	</div>
</div>
</body></html>