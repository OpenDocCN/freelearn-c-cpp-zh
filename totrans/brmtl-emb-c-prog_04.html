<html><head></head><body>
<div><div><div><h1 id="_idParaDest-76" class="chapter-number"><a id="_idTextAnchor118"/>4</h1>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor119"/>Developing the Linker Script and Startup File</h1>
			<p><a id="_idTextAnchor120"/>In this chapter, we undertake an in-depth exploration of the core components of embedded <strong class="bold">bare-metal programming</strong>, focusing on three critical areas: the microcontroller memory model, the writing of the linker script, and the startup file.</p>
			<p>First, we’ll explore the microcontroller memory model to understand how memory is organized and utilized. This knowledge is important for accurately allocating program code and data sections within the microcontroller memory. Next, we’ll go through the intricacies of writing linker scripts. These scripts are essential for correctly mapping our program to the appropriate sections of the microcontroller’s memory, ensuring that the executable runs as intended.</p>
			<p>Finally, we will learn about the startup file and then proceed to write our own, focusing on initializing the vector table and configuring <code>Reset_Handler</code>.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor121"/>Understanding the memory model</li>
				<li>The linker scripts</li>
				<li><a id="_idTextAnchor122"/>Writing the linker script and startup file</li>
			</ul>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor123"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor124"/>Understanding the STM32 memory model</h1>
			<p>While the <a id="_idIndexMarker285"/>STM32 memory map consists of various memory areas, our primary focus in developing the linker script and startup file revolves around two critical areas: <strong class="bold">flash memory</strong> and <strong class="bold">static random access memory</strong> (<strong class="bold">SRAM</strong>). These areas<a id="_idIndexMarker286"/> are <a id="_idIndexMarker287"/>of utmost<a id="_idIndexMarker288"/> importance<a id="_idIndexMarker289"/> because they are directly involved in program storage. In the initial parts of this section, we will learn about the characteristics of these memory areas and the distinct roles they play.</p>
			<p><em class="italic">Figure 4</em><em class="italic">.1</em> shows a section of the <a id="_idIndexMarker290"/>stm32f411 memory map, highlighting the flash memory and SRAM.</p>
			<div><div><img src="img/B21914_04_1.jpg" alt="Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory and SRAM areas" width="603" height="444"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory and SRAM areas</p>
			<p>Let’s start with flash mem<a id="_idTextAnchor125"/>ory.</p>
			<h2 id="_idParaDest-80">Flash me<a id="_idTextAnchor126"/>mory</h2>
			<p>One of the primary advantages of flash memory<a id="_idIndexMarker291"/> is its non-volatile <a id="_idIndexMarker292"/>nature. This means that data stored in flash memory remains intact even when the power supply is disconnected. In STM32 microcontrollers (as well as other microcontrollers), flash memory is typically where the executable code is stored and is read-only during normal operation. Flash memory starts at the <code>0x08000000</code> address. However, its size varies depending on the specific STM32 microcontroller model.</p>
			<p>STM32 microcontrollers come in various series and models, offering a range of flash memory densities to accommodate different application requirements.</p>
			<p class="callout-heading">What is memory density?</p>
			<p class="callout"><strong class="bold">Memory density</strong> refers<a id="_idIndexMarker293"/> to the concentration of memory storage within a given physical space or component. Memory density is often expressed in terms of bits or bytes stored per unit of physical area, such as bits per square millimeter or bytes per square centimeter. It measures how densely or compactly data can be stored within that space. Higher memory density means that we can store more data than we can in a smaller physical space.</p>
			<p class="callout">Memory size, on the <a id="_idIndexMarker294"/>other hand, refers to the total amount of memory (storage capacity) available in a given storage<a id="_idIndexMarker295"/> device. It is typically measured<a id="_idIndexMarker296"/> in units such as bytes, <strong class="bold">kilobytes</strong> (<strong class="bold">KB</strong>), <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>), <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>), etc.</p>
			<p>Now, let’s talk about some operational nuances of flash memory.</p>
			<p>Flash memory, including<a id="_idIndexMarker297"/> STM32 flash memory, has a limited <a id="_idIndexMarker298"/>number of program and erase cycles. Each time we write (program) or erase, it consumes one of these cycles. It is important to consider these limitations when designing applications that frequently write to or erase data from flash memory.</p>
			<p>STM32 microcontrollers are known for their low power consumption, and this extends to their flash memory operations. Efficient power management ensures that the microcontroller can operate on minimal power while reading from or writing to flash memory, making STM32 devices suitable for battery-powered applications.</p>
			<p>To ensure data integrity, STM32 flash memory often includes built-in error correction mechanisms. These mechanisms help identify and correct errors that may occur during data storage and retrieval, enhancing the reliability of the stor<a id="_idTextAnchor127"/>ed firmware.</p>
			<p>The following are some key attributes<a id="_idIndexMarker299"/> of the STM32 flash memory:</p>
			<ul>
				<li><strong class="bold">Read-only nature</strong>: Primarily used for storing program code</li>
				<li><code>0x08000000</code></li>
				<li><strong class="bold">Variable size</strong>: Dependent on the specific STM32 microcontroller model</li>
				<li><code>0x08000004</code></li>
			</ul>
			<p>Let’s take a look at the other primary memory areas relevant to writing our linker script and <a id="_idTextAnchor128"/>startup file.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor129"/>SRAM</h2>
			<p><strong class="bold">SRAM</strong> is a <a id="_idIndexMarker300"/>type of volatile memory, meaning it loses its<a id="_idIndexMarker301"/> contents when the power supply is disconnected. It is used in STM32 microcontrollers for temporary data storage during program execution. Unlike flash memory, which is used for long-term storage of program code, SRAM is designed for high-speed access and low latency, making it ideal for storing variables, intermediate data, and managing the stack during runtime.</p>
			<p>Like flash memory, the STM32 microcontrollers feature varying sizes of SRAM, tailored to the needs of different applications. The size of the SRAM determines the amount of runtime data that can be handled and affects the overall performance of the microcontroller in handling complex tasks or multitasking. The SRAM in STM32 microcontrollers starts at the <code>0x20000000</code> address. Like flash memory, its size varies depending on the specific STM32 microcontroller model.</p>
			<p>The following are the key attributes of the <a id="_idIndexMarker302"/>STM32 SRAM:</p>
			<ul>
				<li><strong class="bold">Read and write</strong>: Variables and the stack are stored here</li>
				<li><code>0x20000000</code></li>
				<li><strong class="bold">Variable size</strong>: Dependent on the specific STM32 microcontroller model</li>
			</ul>
			<p>Before moving on to introduce the linker script, let’s touch on one other memory area that is not relevant to the linker script, but is still relevant to our understanding of the memory layout of our microcontroller.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor130"/>Peripheral memory</h2>
			<p><strong class="bold">Peripheral memory</strong> is <a id="_idIndexMarker303"/>dedicated to managing and interfacing with the <a id="_idIndexMarker304"/>microcontroller’s onboard peripherals. These peripherals include components such as timers, communication interfaces (UART, SPI, I2C), <a id="_idIndexMarker305"/>and <strong class="bold">analog-to-digital converters</strong> (<strong class="bold">ADCs</strong>). Peripheral memory is made up of registers that are used to configure and manage these peripherals.</p>
			<p>An important aspect of <a id="_idIndexMarker306"/>microcontroller architecture is the use of <strong class="bold">memory-mapped input/output</strong> (<strong class="bold">I/O</strong>). Memory-mapped I/O is a technique where peripheral registers are assigned specific addresses in the system’s memory space. This approach allows firmware to interact with hardware peripherals by reading from or writing to these memory addresses, just as it would with regular memory. The peripheral memory area of the STM32 memory map is the memory-mapped area for the <a id="_idIndexMarker307"/>peripheral registers.</p>
			<p>Now that we are familiar with the major memory areas, we are ready to learn about the linker script.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor131"/>The linker script</h1>
			<p>Linker scripts play <a id="_idIndexMarker308"/>an important role in the build process, especially in defining the memory layout and allocating various memory sections used by the firmware. They specify where different sections of the firmware, such as code, data, and uninitialized data, are to be placed in the microcontroller’s memory.</p>
			<p>While linker scripts set up the structure and boundaries for these sections, it is important to note that they do not populate these sections with data. The actual process of initializing data with specific values is handled by the startup code, which runs when the microcontroller boots up. We provide these linker scripts to the linker to effectively guide the organization of memory during the linking phase.</p>
			<div><div><img src="img/B21914_04_2.jpg" alt="Figure 4.2: The build process with the linker highlighted" width="1035" height="432"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: The build process with the linker highlighted</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor132"/>Understanding the linking process</h2>
			<p>In the build process, the linking of <a id="_idIndexMarker309"/>object files is an important step that transforms individual pieces of code into functional firmware. The assembler generates object files from source code, each containing code and data sections necessary for the firmware. However, these object files often have unresolved internal references to variables and functions, making them incomplete on their own. For instance, an object file may contain a reference to an <code>adc_value</code> variable that is defined elsewhere. It is the linker’s job to amalgamate these object files, systematically resolving all such unresolved symbols to create a cohesive output file. To fully appreciate the meticulous work of the linker, we have to understand the attributes assigned to each section by the linker.</p>
			<h3>Section attributes and their implications</h3>
			<p>Each<a id="_idIndexMarker310"/> section within an <a id="_idIndexMarker311"/>object file is identified by a unique name and size, with specific attributes that dictate how they should be treated:</p>
			<ul>
				<li><strong class="bold">Loadable sections</strong>: These <a id="_idIndexMarker312"/>sections contain content that must be loaded into memory at<a id="_idIndexMarker313"/> runtime. They are essential for the execution of the program and include executable code and initialized data.</li>
				<li><strong class="bold">Allocatable sections</strong>: These <a id="_idIndexMarker314"/>sections do not carry content by themselves. Instead, they <a id="_idIndexMarker315"/>signal that a certain area of memory should be reserved, typically for uninitialized data that will be defined at runtime.</li>
				<li><strong class="bold">Non-loadable, non-allocatable sections</strong>: Often, a section that is neither loadable nor allocatable contains <a id="_idIndexMarker316"/>debugging information or <a id="_idIndexMarker317"/>metadata that helps in the development process but is not require<a id="_idTextAnchor133"/>d for the program’s execution.</li>
			</ul>
			<p>A crucial aspect of the linking process is the determination of two types of addresses for each allocatable and loadable output<a id="_idIndexMarker318"/> section: the <strong class="bold">virtual memory address</strong> (<strong class="bold">VMA</strong>) and <a id="_idIndexMarker319"/>the <strong class="bold">load memory </strong><strong class="bold">address</strong> (<strong class="bold">LMA</strong>).</p>
			<p>These are the roles of these two addresses:</p>
			<ul>
				<li><strong class="bold">VMA</strong>: This<a id="_idIndexMarker320"/> address represents where the section will reside in memory during the execution of the output file. It is the runtime address used by the system to access the section’s data or instructions.</li>
				<li><strong class="bold">LMA</strong>: Conversely, the <a id="_idIndexMarker321"/>LMA is the address where the section is physically loaded into memory.</li>
			</ul>
			<p class="callout-heading">In most scenarios, the VMA and LMA are identical</p>
			<p class="callout">A notable exception occurs when a data section is initially loaded into flash memory but then copied to SRAM upon startup.</p>
			<p>To provide a clearer and more comprehensive understanding of the latter stages of the build process, it’s essential to delve into another fundamental aspect of our discussion: the specific responsibilities and contributions of the locator within the build process.</p>
			<h3>Address relocation and the locator</h3>
			<p>The output <a id="_idIndexMarker322"/>file produced by the linker is not immediately suitable for use on a target microcontroller. This is because the addresses assigned to different sections during the linking process do not necessarily correspond to the actual memory layout of the target device. Therefore, these addresses must be relocated to match the target’s memory space accurately. This is the job of the locator.</p>
			<div><div><img src="img/B21914_04_3.jpg" alt="Figure 4.3: The build process, highlighting the relationship between the relocatable file, the locator, and the final executable output" width="1071" height="427"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: The build process, highlighting the relationship between the relocatable file, the locator, and the final executable output</p>
			<p>In the GNU toolchain, the locator<a id="_idIndexMarker323"/> functionality is integrated into the linker, streamlining the process of address relocation. This capability ensures that the final executable is correctly mapped to the microcontroller’s memory, making it ready for execution.</p>
			<p>In this section, we examined the build process. From this, we observed that the process of linking object files in embedded systems development involves meticulous organization of code and data sections, symbol resolution, and address relocation.</p>
			<p>In the next section, we shall explore the key components of the linker script in detail. This exploration will offer additional insights and deepen our understanding of the core elements discussed in this section.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor134"/>Key components of the linker script</h2>
			<p>The key components of a linker script include the <strong class="bold">memory layout</strong>, <strong class="bold">section</strong><strong class="bold"> </strong><strong class="bold">definitions</strong>, <strong class="bold">options</strong>, and <strong class="bold">symbols</strong>, each playing a unique role in ensuring that the firmware is correctly placed and executed within the micr<a id="_idTextAnchor135"/>ocontroller’s memory.</p>
			<h3>Memory layout</h3>
			<p>This part of the linker <a id="_idIndexMarker324"/>script<a id="_idIndexMarker325"/> specifies the various memory types available in the microcontroller, such as flash memory and SRAM. It includes their start addresses and sizes, for instance, flash starting at <code>0x08000000</code> or SRAM at <code>0x20000000</code>.</p>
			<h3>Section definitions</h3>
			<p>A critical aspect of the <a id="_idIndexMarker326"/>linker script is<a id="_idIndexMarker327"/> defining how and where different sections of the program are placed. The <code>.text</code> section, containing the program code, is usually positioned at the beginning of flash memory. Following <a id="_idIndexMarker328"/>this, the <code>.bss</code>) and <code>.data</code> sections are allocated in SRAM. The linker script also ensures proper alignment of these sections for efficient memory access and program execution:</p>
			<ul>
				<li><code>.</code><code>text</code>:<ul><li><code>.text</code> section<a id="_idIndexMarker329"/> holds the executable instructions of our program. It’s where the actual code that the processor executes resides.</li><li><code>.text</code> section varies based on the amount of code in your program. In STM32 microcontrollers, it generally starts at a predefined memory address, often in the lower region of the flash memory. For example, <code>0x00000000</code> and then relocated to <code>0x08000000</code>.</li></ul></li>
				<li><code>.</code><code>bss</code>:<ul><li><code>.bss</code> section is <a id="_idIndexMarker330"/>used for uninitialized global and static variables. Variables in this section don’t have initial values when the program starts.</li><li><code>0</code>.</li></ul></li>
				<li><code>.</code><code>data</code>:<ul><li><code>.data</code> section contains initialized global and static variables. Unlike variables in <code>.bss</code>, these variables have initial values specified in our code.</li><li><code>.data</code> section are typically copied from flash memory to SRAM to allow faster access and modification.</li><li><strong class="bold">Management</strong>: The process of copying these values from flash memory to SRAM is handled by the startup code, executed before the main function of our program.</li></ul></li>
				<li><code>.rodata</code>: This section is used for constant data, such as string literals and constant arrays. It’s read-only and usually stored in flash memory.</li><li><code>.heap</code> and <code>.stack</code> are sections used for dynamic memory allocation (<code>malloc</code>, <code>free</code>) and function call stacks, respectively. They are part of SRAM and are crucial for runtime memory management.</li></ul></li>
			</ul>
			<p>The following table<a id="_idIndexMarker331"/> summarizes the<a id="_idIndexMarker332"/> key sections and their placement in memory.</p>
			<table id="table001-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Section</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Purpose</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Placed in</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>.</code><code>text</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds executable program instructions.</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>FLASH</code></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>.</code><code>bss</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds uninitialized global/static variables.</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>SRAM</code></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>.</code><code>data</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds initialized global/static variables with initial values.</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>FLASH</code> (<code>SRAM</code> at runtime)</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>.</code><code>rodata</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Holds constant data (string literals, constant arrays).</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>FLASH</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1: Linker script sections and their placement in memory</p>
			<p>Understanding the characteristics of these sections is important for having a properly functioning executable.</p>
			<h3>Options and symbols</h3>
			<p><strong class="bold">Options</strong> in linker<a id="_idIndexMarker333"/> scripts<a id="_idIndexMarker334"/> are commands or directives that influence the behavior of the linker. A typical linker script includes directives for setting the entry point of the program and directives for defining the memory layout.</p>
			<p>Symbols in <a id="_idIndexMarker335"/>linker scripts <a id="_idIndexMarker336"/>are identifiers that act as placeholders or references to specific memory locations, values, or addresses within the microcontroller’s memory space. Symbols can be used to represent the start or end addresses of memory sections or specific variables in the program. For example, a symbol might be defined to represent the beginning of the flash memory or the start of the SRAM region. We can also use symbols to define important constants or values that are used throughout the firmware (such as source code files). These might include hardware addresses, configuration values, or size limits. By using symbols, the code becomes more readable and maintainable, as these values can be changed in one place (the linker script), rather than in multiple locations throughout the code.</p>
			<p>Now that we are familiar with the key components of linker scripts, we will proceed to learn about some of the essential directives within these scripts. Each directive in a linker script instructs the linker on how to process and organize the input object files into the final executable.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor136"/>Linker script directives</h2>
			<p>In this section, we learn about the essential directives of linker scripts. These directives dictate the memory layout and how various sections—code, data, and others—are allocated within the target microcontroller’s memory. We will explore the key directives, their functionality, and how they influence the overall structure and efficiency of the compiled firmware. Let’s start with the <code>MEMORY</code> directi<a id="_idTextAnchor137"/>ve.</p>
			<h3>Memory directive (MEMORY)</h3>
			<p>The <code>MEMORY</code> directive<a id="_idIndexMarker337"/> delineates the<a id="_idIndexMarker338"/> microcontroller’s memory regions. Each defined block within the <code>MEMORY</code> section represents a distinct area of memory, characterized by its name, start address, and size. This directive allows us to define the memory layout of the target device, specifying different memory regions and their attributes. It plays an important role in guiding the linker on how to allocate sections of the program (code, data, etc.) across the microcontroller’s physical me<a id="_idTextAnchor138"/>mory.</p>
			<h4>Usage template</h4>
			<p>The general syntax for <a id="_idIndexMarker339"/>the <code>MEMORY</code> directive is as follows:</p>
			<pre class="source-code">
MEMORY
{
  name (attributes) : ORIGIN = origin, LENGTH = length
}</pre>			<ul>
				<li><code>name</code>: An identifier we give to the memory region</li>
				<li><code>attributes</code>: This specifies the access permissions for the region, such as read, write, and execute permissions</li>
				<li><code>ORIGIN</code>: This defines the start address of the memory region</li>
				<li><code>LENGTH</code>: This<a id="_idIndexMarker340"/> specifies the size of the memory <a id="_idIndexMarker341"/>region</li>
			</ul>
			<h4>Usage example</h4>
			<p>Consider <a id="_idIndexMarker342"/>a microcontroller<a id="_idIndexMarker343"/> with flash memory for storing executable code and SRAM for data storage. A linker script might define these memory regions as follows:</p>
			<pre class="source-code">
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 256K
  SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 64K
}</pre>			<p>In this example, two memory regions are defined: <code>FLASH</code> and <code>SRAM</code>:</p>
			<ul>
				<li><code>FLASH</code> is marked with read (<code>r</code>) and execute (<code>x</code>) permissions (<code>rx</code>), indicating that this region can store executable code but is not writable during program execution. It starts at the <code>0x08000000</code> address and extends for <code>256K</code> bytes.</li>
				<li><code>SRAM</code> is given read (<code>r</code>), write (<code>w</code>), and execute (<code>x</code>) permissions (<code>rwx</code>), allowing it to store data and executable code that can be modified during runtime. It begins at the <code>0x20000000</code> address and extends for <code>64K</code> bytes.</li>
			</ul>
			<p>The <code>MEMORY</code> directive, with its comprehensive definition of memory regions and attributes, lays the foundation for efficient and effective memory management in firmware development. Before moving on to the next directive, let’s examine all the attributes that can be specified to detail the characteristics and <a id="_idIndexMarker344"/>permissions of the memory <a id="_idIndexMarker345"/>sections:</p>
			<ul>
				<li><code>r</code>: This attribute allows memory to be read. It is important for sections of memory containing executable code or constants that the program needs to read during execution.</li>
				<li><code>w</code>: This attribute permits data to be written to the memory. It is important for memory areas where the program stores data dynamically during execution.</li>
				<li><code>x</code>: This attribute allows the execution of code from the specified memory region. It is typically assigned to flash memory where the program code resides.</li>
				<li><code>rw</code>: This is a combination of read and write permissions, allowing both operations in the specified memory region. It’s commonly used for sections such as SRAM where temporary data and variables are stored and modified.</li>
				<li><code>rx</code>: This combines read and execute permissions. It’s often used for flash memory to indicate that the region contains executable code that the processor can read and execute.</li>
				<li><code>rwx</code>: This attribute combines all three permissions, making the memory region fully accessible for reading, writing, and executing. This is less commonly used due to security and system stability considerations but might be applicable in certain development or debug scenarios.</li>
				<li><code>empty</code>: If no attribute is specified, the memory region does not grant any access permissions by default. This might be used in special cases where permissions are controlled or modified by other means within the firmware.</li>
			</ul>
			<p>Now, let’s examine the <code>ENTRY</code> directive.</p>
			<h3>The entry directive (ENTRY)</h3>
			<p>This <a id="_idIndexMarker346"/>directive specifies the entry point of the <a id="_idIndexMarker347"/>program, which is the first piece of code to execu<a id="_idTextAnchor139"/>te upon reset.</p>
			<p>Here is the usage template:</p>
			<pre class="source-code">
ENTRY(SymbolName)</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
ENTRY(Reset_Handler)</pre>			<p>In this example, <code>Reset_Handler</code> is designated as the entry point of the program, meaning, the first function to execute. In firmware development, <code>Reset_Handler</code> takes care <a id="_idIndexMarker348"/>of initializing<a id="_idIndexMarker349"/> the system and jumping to the main program.</p>
			<p>Next, we have the <code>SECTIONS</code> directive.</p>
			<h3>The sections directive (SECTIONS)</h3>
			<p>This directive defines the <a id="_idIndexMarker350"/>mapping and <a id="_idIndexMarker351"/>ordering of sections from input files into the output file.</p>
			<h4>Usage example</h4>
			<p>Let’s see<a id="_idIndexMarker352"/> a template of it:</p>
			<pre class="source-code">
SECTIONS
{
  .output_section_name address :
  {
    input_section_information
  } &gt;memory_region [AT&gt;load_address] [ALIGN(expression)] [:phdr_
    expression] [=fill_expression]
}</pre>			<p>The parameters are as follows:</p>
			<ul>
				<li><code>output_section_name</code>: This is<a id="_idIndexMarker353"/> the name given to the output section being defined. Common names include <code>.text</code> for executable code, <code>.data</code> for initialized data, and <code>.bss</code> for uninitialized data.</li>
				<li><code>address</code>: This is optional and specifies the start address of the section in memory. This is often left to the linker to determine, based on the order of sections and <a id="_idIndexMarker354"/>memory regions defined in the script.</li>
				<li><code>input_section_information</code>: This determines which input sections (from the compiled object files) should be included in this output section. Wildcards such as <code>*(.text)</code> can be used to include all <code>.text</code> sections from all input files.</li>
				<li><code>&gt;memory_region</code>: This assigns the section to a specific memory region defined in the <code>MEMORY</code> block of the linker script. We use this to tell the linker where in the target’s memory map this section should reside, for example, <code>FLASH</code> or <code>SRAM</code>.</li>
				<li><code>[AT&gt;load_address]</code>: This is optional and specifies the load address of the section. This is used in scenarios where the execution address differs from the load address.</li>
				<li><code>[ALIGN(expression)]</code>: This is optional and aligns the start of the section to an address that is a multiple of the value specified by <code>expression</code>. This is particularly useful for ensuring that sections begin at addresses that meet specific alignment requirements, which can enhance access speed and compatibility.</li>
				<li><code>[:phdr_expression]</code>: This<a id="_idIndexMarker355"/> is optional and associates the section with a program header. Program headers are part of <a id="_idIndexMarker356"/>the <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>) file structure; they provide the system loader with information about how to load and run different segments of a program.</li>
				<li><code>[=fill_expression]</code>: This is optional and specifies a byte value to fill gaps between sections or at the end of sections to reach a certain alignment. This can be useful for initializing memory regions to a known state.</li>
			</ul>
			<h4>Usage example</h4>
			<p>Let’s see an example of<a id="_idIndexMarker357"/> the <code>SECTIONS</code> directive in <a id="_idIndexMarker358"/>action:</p>
			<pre class="source-code">
SECTIONS
{
  .text 0x08000000 :
  {
    *(.text)
  } &gt;FLASH
}</pre>			<p>In this example, we have the following:</p>
			<ul>
				<li><code>SECTIONS</code>: This keyword begins the section of the linker script where output sections are defined. Output sections are areas of memory that hold the code and data from the input files being linked.</li>
				<li><code>.text 0x08000000</code>: This line defines an output section named <code>.text</code> and sets its starting address to <code>0x08000000</code>. The <code>.text</code> section typically <a id="_idTextAnchor140"/>contains executable code.</li>
				<li><code>{ *(.text) }</code>: This line specifies what goes into the <code>.text</code> output section. The <code>*(.text)</code> syntax means all <code>.text</code> sections from all input files.</li>
				<li><code>&gt;FLASH</code>: This directive tells the linker to place the <code>.text</code> section in a memory region named <code>FLASH</code>. The <code>FLASH</code> region will be defined in the <code>MEMORY</code> directive block.</li>
			</ul>
			<p>To understand the<a id="_idIndexMarker359"/> importance <a id="_idIndexMarker360"/>of the <code>*(.text)</code> syntax, let’s examine the process of merging sections.</p>
			<h3>Sections merging</h3>
			<p>As we learned earlier, the <a id="_idIndexMarker361"/>assembler generates an object file for each source file, with each containing its <code>.text</code>, <code>.data</code>, <code>.bss</code>, and other sections. These sections from all object files are then merged by the linker into unified <code>.text</code>, <code>.data</code>, and <code>.bss</code> sections for the final executable.</p>
			<p>Consider a firmware project with two source files, <code>main.c</code> and <code>delay.c</code>. The assembly process yields <code>main.o</code> and <code>delay.o</code>, each with its own sections. The linker’s task is to consolidate these into a single set of sections for the final executable.</p>
			<p>The following figure depicts this process. Note that merging is <em class="italic">not</em> performed through an addition process; this is merely a visual aid to enhance your understanding.</p>
			<div><div><img src="img/B21914_04_4.jpg" alt="Figure 4.4: The merging process involving two source files: main.c and delay.c, resulting in the production of the final executable, final.elf" width="1503" height="564"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: The merging process involving two source files: main.c and delay.c, resulting in the production of the final executable, final.elf</p>
			<p>Now, let’s explore the purpose of the <code>AT &gt;</code> directive. To do this, it is essential to revisit the concepts of the LMA and VMA.</p>
			<h3>A closer look at the LMA and VMA</h3>
			<p>As we learned earlier, each allocatable and loadable output section in a binary output file is associated with two types of addresses: the LMA and the VMA. These addresses are crucial for defining how and where a section of the binary is processed during the system’s startup and its subsequent runtime operations:</p>
			<ul>
				<li><strong class="bold">LMA</strong>: This is the <a id="_idIndexMarker362"/>physical address in the binary image where the section is stored before program execution begins. It determines from where the system will load the section into memory when the program starts.</li>
				<li><strong class="bold">VMA</strong>: In <a id="_idIndexMarker363"/>contrast, the VMA is the address where the section is intended to be accessed during the program’s execution. This is the “runtime” address used by the system to refer to data or instructions in that section. For systems, particularly microcontrollers, that do not employ<a id="_idIndexMarker364"/> a <strong class="bold">memory management unit</strong> (<strong class="bold">MMU</strong>), the VMA usually matches the section’s physical memory address directly.</li>
			</ul>
			<h3>Why are LMA and VMA important?</h3>
			<p>The distinction between <a id="_idIndexMarker365"/>LMA and VMA allows for a flexible memory management <a id="_idIndexMarker366"/>approach where data can be stored in one location (such as flash memory) but run from another (such as SRAM). For example, initialized global and static variables (typically placed in the <code>.data</code> section) can be stored in flash memory but need to be copied to SRAM for faster access and to allow modification at runtime.</p>
			<p>To fully understand this, let’s consider the following snippet from a linker script generated by the STM32CubeIDE:</p>
			<pre class="source-code">
  .data :
  {
    . = ALIGN(4);
    _sdata = .;  /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */
    *(.RamFunc)        /* .RamFunc sections */
    *(.RamFunc*)       /* .RamFunc* sections */
    . = ALIGN(4);
    _edata = .;  /* define<a id="_idTextAnchor141"/> a global symbol at data end */
  } &gt;SRAM AT&gt; FLASH</pre>			<p>In this script, the last line, <code>&gt;SRAM AT&gt; FLASH</code>, incorporates two important directives:</p>
			<ul>
				<li><code>&gt;SRAM</code> indicates that the output <code>.data</code> section is placed in the <code>SRAM</code> section of the memory during program execution (VMA).</li>
				<li><code>AT&gt; FLASH</code> specifies that although the section resides in SRAM when executed, it should initially be loaded into<a id="_idIndexMarker367"/> memory (<code>FLASH</code>. This is common for initialized data, which is stored in flash memory and then copied to SRAM at startup by the microcontroller’s initialization code.</li>
			</ul>
			<p>This detailed management of memory addresses highlights the critical role of LMA and VMA<a id="_idIndexMarker368"/> in maximizing the efficiency of resource-constrained microcontrollers. Through the effective use of LMA and VMA, we can ensure that even with limited memory resources, our microcontrollers operate reliably and efficiently, optimizing both storage and execution efficiency.</p>
			<p>Before moving to explore the other features of the linker script, let’s familiarize ourselves with some other commonly used directives.</p>
			<h3>Other commonly used directives</h3>
			<p>Some other commonly used directives include the <code>KEEP</code>, <code>ALIGN</code>, <code>PROVIDE</code>, <code>&gt;region</code>, and <code>AT</code> directives. Let’s examine them.</p>
			<h4>The KEEP directive</h4>
			<p>The <code>KEEP</code> directive ensures<a id="_idIndexMarker369"/> that specified sections or symbols are not eliminated by the linker during the optimization process, even if they appear unused. This is crucial for interrupt vector tables and initialization functions that m<a id="_idTextAnchor142"/>ust be present in the final binary.</p>
			<p>Here i<a id="_idTextAnchor143"/>s the usage template:</p>
			<pre class="source-code">
KEEP(section)</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
KEEP(*(.isr_vector))</pre>			<p>In this example, we <a id="_idIndexMarker370"/>are <em class="italic">keeping</em> the interrupt vector section. Next, let’s see the region placement directive.</p>
			<h4>The &gt;region directive</h4>
			<p>The <code>(&gt;region)</code> region placement <a id="_idIndexMarker371"/>directive tells the linker to place a particular section into a specific memory region. The available memory regions must be defined in the <code>MEMORY</code> directive block of the linker script.</p>
			<p>Here is the usage template:</p>
			<pre class="source-code">
section &gt;region</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
.data :
{
  *(.data)
} &gt;SRAM</pre>			<p>In this example, we are placing the <code>.data</code> section in the <code>SRAM</code> memory region.</p>
			<h4>The ALIGN directive</h4>
			<p>The <code>ALIGN</code> directive plays a <a id="_idIndexMarker372"/>crucial role in the linker script by adjusting the location counter to align with specified memory boundaries. <strong class="bold">The location counter</strong> tracks the <a id="_idIndexMarker373"/>current memory address allocated by the linker for placing sections or parts of the output file during linking.</p>
			<p><code>.</code>) in linker scripts.</p>
			<p>As the linker processes the script, it assigns memory addresses to code and data sections according to the script’s directives, with the location counter monitoring the progress. To ensure efficient memory access and adherence to hardware architecture requirements, sections and variables often need to be aligned to specific boundaries. The <code>ALIGN</code> directive allows us to achieve this by rounding up the location counter to the nearest <a id="_idIndexMarker375"/>address that matches the specified<a id="_idTextAnchor144"/> alignment, which must be a power of two.</p>
			<p>Here is the usage template:</p>
			<pre class="source-code">
. = ALIGN(expression);</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
. = ALIGN(4);</pre>			<p>In this example, we are aligning the current location to a <code>4</code>-byte boundary.</p>
			<p>Next, let’s see the <code>PROVIDE</code> directive.</p>
			<h4>The PROVIDE directive</h4>
			<p>The <code>PROVIDE</code> directive allows us <a id="_idIndexMarker376"/>to define symbols that the linker will include in the output file if they are not already defined. This can be used to set default values for symbols that may <a id="_idTextAnchor145"/>be optionally overridden by other modules.</p>
			<p>Here is the usage template:</p>
			<pre class="source-code">
PROVIDE(symbol = expression);</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
PROVIDE(_stack_end = ORIGIN(RAM) + LENGTH(RAM));</pre>			<p>In this example, we are <em class="italic">providing</em> a default stack end address.</p>
			<p>Next, we have the <code>AT</code> directive.</p>
			<h4>AT Directive</h4>
			<p>The <code>AT</code> directive<a id="_idIndexMarker377"/> specifies LMA for a section when it needs to be different from the section’s VMA. This is commonly used for sections that need to be loaded into a different memory area during initialization before being moved to their runtime location.</p>
			<p>Here is the usage template:</p>
			<pre class="source-code">
section AT&gt; lma_region</pre>			<p>Here is a usage example:</p>
			<pre class="source-code">
.data : AT&gt; FLASH
{
  *(.data)
} &gt;SRAM</pre>			<p>In this example, the <code>.data</code> section is intended to reside in SRAM during the program’s execution. However, it is initially loaded from <code>FLASH</code>, as indicated by <code>AT&gt; FLASH</code>.</p>
			<p>In the next section, we will explore another key aspect of linker scri<a id="_idTextAnchor146"/>pts: the expression of numerical constants.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor147"/>Understanding constants in linker scripts</h2>
			<p>When <a id="_idIndexMarker378"/>writing our linker script, we must keep in mind the interpretation of numerical <a id="_idIndexMarker379"/>prefixes and suffixes by the linker.</p>
			<p>Firstly, let’s clarify how the linker perceives integers with specific prefixes. An integer prefixed with <code>0</code> is read as an octal number by the linker. On the other hand, an integer starting with <code>0x</code> is recognized as a hexadecimal value. This distinction is important for accurately defining memory addresses and sizes.</p>
			<p>The use of the <code>K</code> and <code>M</code> suffixes introduces another layer of convenience, allowing us to denote large numbers succinctly. The <code>K</code> suffix multiplies the preceding number by <code>1024</code>, while <code>M</code> expands the number by 1,024 twice over. Therefore, <code>4K</code> translates to 4 times 1024, and <code>4M</code> expands to 4 times 1,024 squared.</p>
			<p>To put these principles into practice, let’s explore an example that showcases the versatility of these notations. Imagine you need to specify a memory size of 4K. You could straightforwardly use <code>4K</code>, or opt for its decimal equivalent, <code>4096</code>, which results from multiplying 1,024 by 4. Alternatively, this quantity can be expressed in hexadecimal form as <code>0x1000</code>.</p>
			<p><em class="italic">Table 4.2</em> summarizes <a id="_idIndexMarker380"/>the key points to remember about using constants in linker<a id="_idIndexMarker381"/> scripts. It highlights the prefixes and suffixes that modify the base value, which offers a clear reference for interpreting and using these notations effectively in your linker script.</p>
			<table id="table002-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Notation</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Meaning</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Example</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Equivalent </strong><strong class="bold">Decimal</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Hexadecimal </strong><strong class="bold">Notation</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>0</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Octal prefix</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>010</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>8</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>-</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>0x</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Hexadecimal prefix</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x10</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>16</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>-</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>K</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Multiplies by 1,024</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>4K</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>4096</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x1000</code></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>M</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Multiplies by 1,024 twice (squared)</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>4M</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>4194304</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x400000</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2: Examples of linker script numerical prefixes and suffixes</p>
			<p>In the next section, we shall learn about linker script symbols, further enhancing our understanding of linker scripts.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor148"/>Linker script symbols</h2>
			<p>Linker symbols, also known simply <a id="_idIndexMarker382"/>as <strong class="bold">symbols</strong>, are fundamental elements in the <a id="_idIndexMarker383"/>process of converting source code into executable programs. At its core, a linker symbol comprises two essential components: a name and a value. These symbols are assigned integer values, representing memory addresses where variables, functions, or other program elements are stored in the microcontroller’s memory.</p>
			<p>Previously, we learned that after the assembly stage, the source code is transformed into object files. These object files contain machine code and unresolved references to variables and functions. The linker’s primary task is to merge these object files, resolve these unresolved symbols, and generate a complete executable file ready for execution.</p>
			<p>In the context of linker symbols, the value assigned to a symbol represents the memory address where<a id="_idIndexMarker384"/> the corresponding <a id="_idIndexMarker385"/>variable or function resides.</p>
			<p class="callout-heading">For example: X = 3500 means the memory address of X is 3500</p>
			<p class="callout">A symbol named <code>X</code> might be assigned a value of <code>3500</code>, indicating its memory address. It’s crucial to note that in contrast to the variable’s value in the source code, the <code>X</code> linker symbol represents its memory address.</p>
			<table id="table003-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Type</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Value (Memory </strong><strong class="bold">Address)</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>X</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Symbol</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>3500</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where an <code>X</code> variable is stored.</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>Y</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Symbol</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x3000</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <code>Y</code> variable is stored.</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>foo()</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Symbol</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x4000</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <code>foo()</code> function is located.</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>bar()</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Symbol</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>0x5000</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the memory address where a <code>bar()</code> function is located.</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>x</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Variable</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>3500</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the value of a C variable named <code>x</code>.</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><code>y</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Variable</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><code>4500</code></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>Represents the value of a C variable named <code>y</code>.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3: Comparison of linker symbols and C source code variables assignments</p>
			<p>Linker symbols can undergo various operations, such as those we use in C assignments. These operations include straightforward assignment (<code>=</code>), addition (<code>+=</code>), and subtraction (<code>-=</code>), among others.</p>
			<div><div><img src="img/B21914_04_5.jpg" alt="Figure 4.5: Examples of linker symbol operations" width="630" height="489"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Examples of linker symbol operations</p>
			<p>During the<a id="_idIndexMarker386"/> linking process, a symbol table is created, mapping each symbol to its <a id="_idIndexMarker387"/>corresponding address in memory. This table serves as a crucial reference for the linker to resolve symbol references and ensure proper linking of program components.</p>
			<p>Let’s consider a scenario where we have a <code>main.c</code> file and at the top of this file; we declare a variable named <code>X</code>, assigning it a value of <code>568</code>. Additionally, within this file, there’s a function named <code>blink</code>. Inside the <code>blink</code> function, there are operations to turn on an LED, wait, and then turn it off. This is depicted in <em class="italic">Figure 4</em><em class="italic">.6</em>.</p>
			<p>Now, let’s take this <code>main.c</code> file and pass it through the build process to generate the <code>main.o</code> object file. During this process, a symbol table is generated. Each symbol in this table is associated with an address.</p>
			<p>For instance, the <code>X</code> symbol would be assigned an address of <code>0x20000000</code>, and similarly, the <code>blink</code> function would also be assigned its address. In the following figure, the <code>blink</code> function is assigned the <code>0x08000000</code> address.</p>
			<p>Essentially, just like in the C programming language, each variable has its value. In the object file, each symbol has its value, which essentially represents the address of the corresponding variable or function in C.</p>
			<p>So, when referring<a id="_idIndexMarker388"/> to <code>X</code> in the object file, it wouldn’t give us <code>568</code>; rather, it would provide the<a id="_idIndexMarker389"/> address of <code>X</code>. This process of assigning values to symbols and associating them with addresses constructs the symbol table.</p>
			<div><div><img src="img/B21914_04_6.jpg" alt="Figure 4.6: Representation of functions and variables from the source file in the symbol table of the output object file" width="1213" height="424"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Representation of functions and variables from the source file in the symbol table of the output object file</p>
			<p>In this section, we delved deep into linker scripts, highlighting key components and directives. We carefully explored each directive, providing practical usage examples. Additionally, we distinguished between the LMA and VMA and also emphasized their important roles in guiding the linker on how to place sections. In the next section, we will learn how to write our own linker script and startup file from scratch, equipping you with another important skill in bare-metal firmware development.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor149"/>Writing the linker script and startup file</h1>
			<p>Now that we have a good understanding of linker scripts and their essential components, we’re prepared to write our own. However, before diving into writing the script, it’s crucial to revisit the memory map of the microcontroller and gain insight into the <code>positions</code> load memory for various sections within the object file.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor150"/>Understanding the load memory of different sections</h2>
			<p>As discussed earlier in this chapter, the output object file is structured into sections such as <code>.data</code>, <code>.rodata</code>, <code>.text</code>, and <code>.bss</code>. Together with the sections created by the assembler, we must define our own section to accommodate the vector table for <code>.isr_vector_tbl</code>.</p>
			<p>Each of these sections plays an important role in organizing the memory layout of the microcontroller, contributing to the functionality and efficiency of the final executable.</p>
			<p><em class="italic">Figure </em><em class="italic">4</em><em class="italic">.7</em> shows a zoomed-in view of the<a id="_idIndexMarker391"/> flash memory area, showing the required order for placing the different sections within the flash memory. Each section represents the combination of identical sections from all input files. For instance, the <code>.text</code> section depicted is a unified <code>.text</code> section, formed by merging all <code>.text</code> sections from the input files.</p>
			<p>The diagram indicates that the placement must start with the <code>.isr_vector_tbl</code> section at the beginning of the flash memory. Following this, we must place the <code>.text</code> section, then the <code>.rodata</code> section, and finally, the <code>.data</code> section. The diagram does not show the placement of the <code>.bss</code> section, as we will place the <code>.bss</code> section directly in the SRAM. Additionally, during the startup code implementation, we must copy the content of the <code>.data</code> section from the flash memory to the SRAM.</p>
			<div><div><img src="img/B21914_04_7.jpg" alt="Figure 4.7: The flash memory area showing the order in which sections should be placed" width="1628" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: The flash memory area showing the order in which sections should be placed</p>
			<p>Before we proceed, however, let’s understand the concept of interrupts and the vector table.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor151"/>Interrupts and the vector table</h2>
			<p>Interrupts are a fundamental concept in computing. They act as a powerful mechanism for managing how a computer or a microcontroller handles tasks and responds to external and internal events.</p>
			<p>At its core, an <strong class="bold">interrupt</strong> is a<a id="_idIndexMarker392"/> signal to the processor from a hardware device or an internal software condition that temporarily halts the current operations. This signal indicates that immediate attention is required. When the processor receives an interrupt, it pauses its current tasks, saves its state, and executes a function known as an ISR to address the interrupt. Upon completing the ISR, the processor resumes its previous tasks, ensuring that critical signals receive prompt and efficient handling.</p>
			<p><em class="italic">What are the types </em><em class="italic">of interrupts?</em></p>
			<p>We can broadly classify interrupts into two categories: hardware interrupts and software interrupts:</p>
			<ul>
				<li><strong class="bold">Hardware interrupts</strong>: These <a id="_idIndexMarker393"/>originate from external devices, such as <a id="_idIndexMarker394"/>switches, network adapters, or any peripheral that needs to communicate with the processor. For example, pressing a push button may trigger a hardware interrupt that informs the processor to start a motor.</li>
				<li><strong class="bold">Software interrupts</strong>: Unlike <a id="_idIndexMarker395"/>hardware interrupts, software interrupts<a id="_idIndexMarker396"/> are triggered by software instructions. These are used by programs to interrupt the current process flow and execute a specific routine.</li>
			</ul>
			<p><em class="italic">What is the role of the interrupt </em><em class="italic">vector table?</em></p>
			<p>The interrupt vector table serves as an essential lookup table, guiding the processor to the correct ISR for each interrupt. An ISR is simply a function designed to address and manage the specific needs triggered by an interrupt. The table itself is <strong class="bold">organized as an array of pointers</strong>, with each pointer directing the system to the designated ISR for a given interrupt. Upon the occurrence of an interrupt, the system references this table to locate the exact memory address of the ISR required for handling the interrupt. This efficient mechanism enables the system to promptly respond to various events, such as external inputs, timer expirations, and changes in the internal state.</p>
			<p>With this in mind, we are finally ready to write our linker script.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor152"/>Writing the linker script</h2>
			<p>In our workspace folder, let’s <a id="_idIndexMarker397"/>make a new folder named <code>3_LinkerscriptAndStartup</code>. In this folder, create a file called <code>stm32_ls.ld</code> and make sure its extension is <code>.ld</code>. If you’re using Windows and it asks if you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor such as Notepad++.</p>
			<p>Our objectives<a id="_idIndexMarker398"/> with the linker script can be summarized as<a id="_idTextAnchor153"/> follows:</p>
			<ul>
				<li>Specifying the firmware’s entry point</li>
				<li>Detailing the available memory</li>
				<li>Specifying the necessary heap and stack sizes</li>
				<li>Defining output<a id="_idTextAnchor154"/> sections</li>
			</ul>
			<p>This is our complete linker script, the contents of the <code>stm32_ls.ld</code> file:</p>
			<pre class="source-code">
/*Specifying the firmware's entry point*/
ENTRY(Reset_Handler)
/*Detailing the available memory*/
MEMORY
{
    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K
    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K
}
_estack = ORIGIN(SRAM)+LENGTH(SRAM);
/*Specifying the necessary heap and stack sizes*/
__max_heap_size = 0x200;
__max_stack_size = 0x400;
/*Defining output sections*/
SECTIONS
{
    .text :
    {
     . = ALIGN(4);
      *(.isr_vector_tbl)
      *(.text)
      *(.rodata)
      . = ALIGN(4);
     _etext = .;
    }&gt;FLASH
    .data :
    {
     . = ALIGN(4);
    _sdata = .;
      *(.data)
     . = ALIGN(4);
    _edata = .;
    } &gt; SRAM AT&gt; FLASH  /*&gt;(vma) AT&gt; (lma)*/
        .bss :
    {
     . = ALIGN(4);
    _sbss = .;
    *(.bss)
     . = ALIGN(4);
    _ebss = .;
    <a id="_idTextAnchor155"/>}&gt; SRAM
}</pre>			<p>Let’s break it down.</p>
			<h3>Specifying the firmware’s entry point</h3>
			<pre class="source-code">
ENTRY(Reset_Handler)</pre>			<p>As we learned<a id="_idIndexMarker399"/> earlier, the <code>ENTRY</code> directive specifies the entry point of the firmware, which is the first piece of code that gets executed when the firmware starts. In this case, the entry point is the function named <code>Reset_Handler</code>. We shall implement this function in the sta<a id="_idTextAnchor156"/>rtup file.</p>
			<h3>Detailing the available memory</h3>
			<pre class="source-code">
MEMORY
{
    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K
    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K
}</pre>			<p>Our script<a id="_idIndexMarker400"/> specifies two memory regions: <code>FLASH</code> and <code>SRAM</code>. The <code>FLASH</code> memory, with read and execute permissions (<code>rx</code>), starts at the <code>0x08000000</code> address and has a length of <code>512K</code>. The SRAM memory, with read, write, and execute permissions (<code>rwx</code>), starts at the <code>0x20000000</code> address and has a length of <code>128K</code>.</p>
			<h3>Symbol creation</h3>
			<pre class="source-code">
_estack = ORIGIN(SRAM)+LENGTH(SRAM);</pre>			<p>Over here, we <a id="_idIndexMarker401"/>create a symbol called <code>_estack</code> and we set it to the end of the <code>SRAM</code> memory region. We will use this symbol to initialize the stack pointer.</p>
			<p>The <code>SRAM</code> ensures that it starts at the maximum available address, utilizing the <code>SRAM</code> space efficiently for stack operations.</p>
			<p>The next lines of code in our linker script specify the heap and stack sizes.</p>
			<h3>Specifying the necessary heap and stack sizes</h3>
			<pre class="source-code">
__max_heap_size = 0x200;
__max_stack_size = 0x400;</pre>			<p>These lines <a id="_idIndexMarker404"/>define the maximum sizes for the heap (<code>0x200</code> bytes) and stack (<code>0x400</code> bytes). These sizes are important for dynamic memory allocation and function call management, respectively.</p>
			<p>The next segment defines the output sections.</p>
			<h3>Defining output sections</h3>
			<p>In this section, we <a id="_idIndexMarker405"/>will go through the output sections.</p>
			<h4>The .text output section</h4>
			<p>This segment of <a id="_idIndexMarker406"/>our linker script shows the <code>.text</code> output section:</p>
			<pre class="source-code">
.text :
{
  . = ALIGN(4);
  *(.isr_vector_tbl)  /*merge all .isr_vector_tbl sections of input 
  files*/
  *(.text)   /*merge all .text sections of input files*/
  *(.rodata) /*merge all .rodata sections of input files*/
  . = ALIGN(4);
 _etext = .;  /*Create a global symbol to hold end of text section*/
}&gt;FLASH</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><code>. = </code><code>ALIGN(4);</code>:<p class="list-inset">This directive aligns <a id="_idIndexMarker407"/>the start of the <code>.text</code> section on a <code>4</code>-byte boundary. This enhances memory access efficiency, which is a critical consideration for processors fetching instructions in word-sized chunks.</p></li>
				<li><code>*(<a id="_idTextAnchor157"/>.</code><code>isr_vector_tbl)</code> :<p class="list-inset">This directive pulls in all sections named <code>.isr_vector_tbl</code> from the input files into the current location in <a id="_idTextAnchor158"/>the <code>.</code><code>text</code> section.</p></li>
				<li><code>*(.</code><code>text)</code>:<p class="list-inset">This directive pulls in all sections named <code>.text</code> from the input files into the current location in the <code>.</code><code>text</code> section.</p></li>
				<li><code>*(.</code><code>rodata)</code>:<p class="list-inset">This directive pulls in all sections named <code>.rodata</code> from the input files into the current location in <a id="_idTextAnchor159"/>the <code>.</code><code>text</code> section.</p></li>
				<li><code>. = </code><code>ALIGN(4);</code>:<p class="list-inset">Again, this line ensures that the end of the section is aligned to a <code>4</code>-byte boundary. Over here, we use it to align the end of a section, ensuring that the next section starts on an aligned boun<a id="_idTextAnchor160"/>dary.</p></li>
				<li><code>_etext = .;</code>:<p class="list-inset">Over here, we define a symbol called <code>_etext</code> at the current location. This symbol marks the end of the <code>.text</code> section. We will use this symbol as a pointer to the end of the <code>.text</code> section in our startup file.</p></li>
				<li><code>}&gt;</code><code>FLASH</code>:<p class="list-inset">This directive<a id="_idIndexMarker408"/> specifies that the <code>.text</code> section should be placed in the <code>FLASH</code> memory segment as defined earlier in the <code>MEMORY</code> block of<a id="_idTextAnchor161"/> the linker script.</p></li>
			</ul>
			<p>This segment shows the <code>.data</code> output section:</p>
			<pre class="source-code">
    .data :
    {
     . = ALIGN(4);
    _sdata = .;   /*Create a global symbol to hold start of data 
    section*/
      *(.data)
     . = ALIGN(4);
    _edata = .;   /*Create a global symbol to hold end of data 
    section*/
    } &gt; SRAM AT&gt; FLASH  /*&gt;(VMA) AT&gt; (LMA)*/</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><code> = </code><code>ALIGN(4);</code>:<p class="list-inset">This directive aligns the start of the <code>.data</code> section on a <code>4</code>-byte bou<a id="_idTextAnchor162"/>ndary.</p></li>
				<li><code>_sdata = .;</code>:<p class="list-inset">Over here, we create a symbol named <code>_sdata</code> to represent the start of the <code>.data</code> section by setting it to the current location counter. We will use this symbol as a pointer to the start of the <code>.data</code> section in our startup file.</p></li>
				<li><code>*(.</code><code>data)</code>:<p class="list-inset">This directive pulls in all sections named <code>.data</code> from the input files into the current location in the <code>.</code><code>data</code> section.</p></li>
				<li><code>. = </code><code>ALIGN(4);</code>:<p class="list-inset">This line<a id="_idIndexMarker409"/> ensures that the end of the section is aligned to a <code>4</code>-byte boundary.</p></li>
				<li><code>_edata= .;</code>:<p class="list-inset">Similar to what we have done previously, we create a symbol named <code>_edata</code> to represent the end of the <code>.data</code> section by setting it to the current location counter. We will use this symbol in our startup file.</p></li>
				<li><code>&gt; SRAM </code><code>AT&gt; FLASH</code>:<p class="list-inset">This directive specifies the LMA and the VMA of the <code>.</code><code>data</code> section.</p><p class="list-inset"><code>&gt; SRAM</code> indicates that the section should be located in SRAM, allowing read and write access at runtime.</p><p class="list-inset"><code>AT&gt; FLASH</code> tells the linker that although the section is placed in <code>SRAM</code> for execution, its initial values should be stored in <code>FLASH</code>.</p></li>
			</ul>
			<p>This segment shows the <code>.bss</code> output section:</p>
			<pre class="source-code">
.bss :
{
 . = ALIGN(4);
_sbss = .;
*(.bss)
 . = ALIGN(4);
_ebss = .;
}&gt; SRAM</pre>			<p>This is the final output section of our linker script.</p>
			<p>As we learned earlier, the <code>.bss</code> section holds uninitialized global and static variables that we will be initialized to zero in our startup file. This zero-initialization ensures that all variables in this section begin with a known state, contributing to our firmware’s stability and predictability.</p>
			<p>Similar to other sections, we begin by aligning the section to a <code>4</code>-byte boundary for efficient memory access, and then we define the <code>_sbss</code> and <code>_ebss</code> symbols to mark the start and end of the section, respectively. These symbols facilitate the calculation of the section’s size and its initialization process. Finally, we place the section in the SRAM, emphasizing that, although it doesn’t occupy space in the binary file on disk, it requires runtime allocation in memory.</p>
			<p>With our linker script finalized, we’ll move on to implementing the startup file. This shall be the focus of the next section.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor163"/>Writing the startup file</h2>
			<p>The startup file is essential for initializing<a id="_idIndexMarker410"/> the firmware and it performs several critical tasks to ensure the system operates correctly from the moment it is powered on.</p>
			<p>These tasks include the following:</p>
			<ul>
				<li><strong class="bold">Implementing the vector table</strong>: This involves defining the vector table that maps interrupts to their handlers, ensuring the system can respond to various events efficiently.</li>
				<li><strong class="bold">Creating interrupt handlers</strong>: For each interrupt listed in the vector table, an interrupt handler must be implemented to define how the system responds to that particular event.</li>
				<li><code>Reset_Handler</code>, as specified in the linker script, which acts as the initial entry point of the firmware. This function is executed immediately after reset and is responsible for setting up the environment for the main application.</li>
				<li><code>.data</code> section from <code>FLASH</code> to <code>SRAM</code>.</li>
				<li><code>.bss</code> section to zero, ensuring that all uninitialized global and static variables start with a known state fo<a id="_idTextAnchor164"/>r reliable operation.</li>
			</ul>
			<p>In the current folder <a id="_idIndexMarker411"/>containing the linker script, create a file called <code>stm32f411_startup.c</code> and make sure its extension is <code>.c</code>. If you’re using Windows and it asks if you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor such as Notepad++.</p>
			<p>Let’s analyze the complete startup code.</p>
			<p>The following is our complete startup code written in C, the contents of the <code>stm32f411_startup.c</code> file. In the following snippet, we are not showing all the function prototypes of all the interrupts in the vector table. The complete source code can be found in the resources accompanying the book:</p>
			<pre class="source-code">
extern uint32_t _estack;
extern uint32_t _etext;
extern uint32_t _sdata;
extern uint32_t _edata;
extern uint32_t _sbss;
extern uint32_t _ebss;
void Reset_Handler(void);
int main(void);
void NMI_Handler(void)__attribute__((weak,
alias("Default_Handler")));
void HardFault_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
void MemManage_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
.
.
.
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl"))) = {
    (uint32_t)&amp;_estack,
    (uint32_t)&amp;Reset_Handler,
    (uint32_t)&amp;NMI_Handler,
    (uint32_t)&amp;HardFault_Handler,
    (uint32_t)&amp;MemManage_Handler,
.
.
.
};
void Default_Handler(void) {
    while(1) {
    }
}
void Reset_Handler(void)
{
    // Calculate the sizes of the .data and .bss sections
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;
    // Initialize pointers to the source and destination of the .data 
    // section
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;
    /*Copy .data section from FLASH to SRAM*/
    for(uint32_t i = 0; i &lt; data_mem_size; i++  )
    {
         *p_dest_mem++ = *p_src_mem++;
    }
    // Initialize the .bss section to zero in SRAM
    p_dest_mem =  (uint32_t *)&amp;_sbss;
    for(uint32_t i = 0; i &lt; bss_mem_size; i++)
    {
         /*Set bss section to zero*/
        *p_dest_mem++ = 0;
    }
        // Call the application's main function.
    main();
}</pre>			<p>Let’s break it down.</p>
			<p>We start by declaring external symbols.</p>
			<h3>External symbol declarations</h3>
			<pre class="source-code">
extern uint32_t _estack;
extern uint32_t _etext;
extern uint32_t _sdata;
extern uint32_t _edata;
extern uint32_t _sbss;
extern uint32_t _ebss;</pre>			<p>These lines declare the <a id="_idIndexMarker412"/>external symbols that we defined in the linker script. Each symbol represents an important memory address used during the startup process:</p>
			<ul>
				<li><code>_estack</code>: This is the initial top of the stack. This value is loaded into the main stack pointer register early in the startup process.</li>
				<li><code>_etext:</code> This marks the end of the executable code section and the beginning of the data sections stored in flash memory. We use this as a reference point for copying initialized data from <code>FLASH</code> to <code>SRAM</code>.</li>
				<li><code>_sdata</code> and <code>_edata</code> represent the start and end addresses of the initialized data section in SRAM, respectively. We use them to determine the size and destination for data copying from <code>FLASH</code> to <code>RAM</code>.</li>
				<li><code>_sbss</code> and <code>_ebss</code> mark the start and end of the uninitialized data section (BSS section) in SRAM. We use these symbols to clear this section, setting it to zero.</li>
			</ul>
			<p>Next in our snippet, we have the function prototypes and their attributes.</p>
			<h3>Function prototypes and attributes</h3>
			<pre class="source-code">
void Reset_Handler(void);
int main(void);
void NMI_Handler(void)__attribute__((weak,
alias("Default_Handler")));
void HardFault_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
void MemManage_Handler (void) __attribute__ ((weak, alias("Default_Handler")));
.
.
.</pre>			<p>At this part of the<a id="_idIndexMarker413"/> startup file, we declare the prototype for the <code>Reset_Handler</code> function, the application’s <code>main</code> function, and several interrupt handlers with specific attributes:</p>
			<p><code>__attribute__((weak, alias("Default_Handler"))):</code> This attribute makes each handler weakly linked and aliases it to a function named <code>Default_Handler</code>. It allows these handlers to be overridden by explicitly defined handlers with the same name elsewhere in the application.</p>
			<p>Let’s break down the statement further to understand its significance:</p>
			<ul>
				<li><code>__attribute__</code>:<p class="list-inset">We use this keyword to tell the compiler that the declaration it’s applied to has certain properties that affect how it’s treated by the linker and, potentially, at runtime. Attributes can be used to control optimizations, code generation, alignment, and, relevant to our discussion, linkage characteristics.</p></li>
				<li><code>weak</code>:<p class="list-inset">Declaring a function or variable as <code>weak</code> means that it does not prevent the linker from using another symbol of the same name with a stronger linkage. We use this to specify default implementations that can be overridden.</p><p class="list-inset">In the context of our interrupt handlers, marking them as <code>weak</code> allows us to define default handlers in our startup file, which application-specific handlers can override without modifying the startup file.</p></li>
				<li><code>alias("Default_Handler")</code>:<p class="list-inset">This part of the attribute creates an alias for another symbol, in this case, <code>Default_Handler</code>. It means that the symbol (e.g., <code>NMI_Handler</code>) is not just weak, but it is also an alias for the <code>Default_Handler</code> function.</p><p class="list-inset">This means that when an interrupt occurs, and a specific handler (such as <code>NMI_Handler</code>) has not been defined elsewhere in the application with stronger linkage (non-weak), the program will use <code>Default_Handler</code> in its place. This ensures<a id="_idIndexMarker414"/> that all interrupts have a handler, preventing the system from crashing due to unhandled events.</p></li>
			</ul>
			<p>Next, we have the vector table array.</p>
			<h3>Vector table definition</h3>
			<pre class="source-code">
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl"))) = {
    (uint32_t)&amp;_estack,
    (uint32_t)&amp;Reset_Handler,
    (uint32_t)&amp;NMI_Handler,
    (uint32_t)&amp;HardFault_Handler,
    (uint32_t)&amp;MemManage_Handler,
…
};</pre>			<p>This array defines the <a id="_idIndexMarker415"/>microcontroller’s interrupt vector table, placed in the <code>.isr_vector_tbl</code> section we defined in the linker script.</p>
			<p>We set the <code>&amp;_estack</code> symbol as the first element of the vector table to define the initial top of the stack in memory. In ARM Cortex microcontrollers, such as our STM32F411, the first word (32 bits) of the vector table must contain the initial value of the <strong class="bold">main stack pointer</strong> (<strong class="bold">MSP</strong>). Upon<a id="_idIndexMarker416"/> reset, the processor loads this value into the MSP register to set up the stack pointer correctly before executing any code.</p>
			<p>Following this, we specify the address of <code>Reset_Handler</code>, then we proceed to list the addresses for <code>NMI_Handler</code> and other subsequent interrupt handlers in sequence. The precise placement of these handlers is crucial, as each must reside in a specific memory location to ensure correct functionality. This arrangement is detailed on <em class="italic">page 201</em> of the RM0383 document. Within the fully defined vector table in our <code>stm32f411_startup.c</code> file, you’ll notice that there are zeros strategically placed among the interrupt handler addresses. These zeros act as placeholders for the positions corresponding to interrupts not supported by our specific microcontroller variant (STM32F411). The ARM Cortex-M core architecture is designed to support a comprehensive set of interrupts, yet not all interrupts are implemented across every microcontroller variant. By inserting zeros for these unsupported interrupts in the vector table, we maintain the required alignment with the architecture’s specifications, ensuring the system operates correctly.</p>
			<p>Let’s take a closer look at the array declaration:</p>
			<pre class="source-code">
uint32_t vector_tbl[] __attribute__((section(".isr_vector_tbl")))={…}</pre>			<ul>
				<li><code>uint32_t vector_tbl[]</code>:<p class="list-inset">This specifies that each element of the <code>vector_tbl</code> array is an unsigned 32-bit integer. We chose this type because addresses in ARM Cortex-M microcontrollers are 32 bits in length, and the vector table consists of memory addresses pointing to the start of ISR handlers.</p></li>
				<li><code>__attribute__((section(".isr_vector_tbl")))</code>:<p class="list-inset">This attribute instructs the linker to place the <code>vector_tbl</code> array in a specific section of the<a id="_idIndexMarker417"/> output file named <code>.isr_vector_tbl</code>.</p></li>
			</ul>
			<p>Next, we have our default handler function.</p>
			<h3>Default dandler</h3>
			<pre class="source-code">
void Default_Handler(void) {
    while(1) {
        // Infinite loop
    }
}</pre>			<p>This function serves as a <a id="_idIndexMarker418"/>universal fallback for any interrupt request for which a specific handler has not been implemented. Engaging in an infinite loop effectively prevents the program from proceeding into an undefined state following such an event.</p>
			<p>It is linked to all interrupt handlers marked as <code>weak</code> and aliased to <code>Default_Handler</code> within the application. This strategy ensures a uniform and secure response throughout the system to any interrupt requests that lack a dedicated handler, thus upholding system stability and integrity.</p>
			<p>Finally, we have our <code>Reset_Handler</code> function.</p>
			<h3>Reset handler implementation</h3>
			<pre class="source-code">
void Reset_Handler(void) {
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;
    for(uint32_t i = 0; i &lt; data_mem_size; i++  ) {
        *p_dest_mem++ = *p_src_mem++;
    }
    p_dest_mem =  (uint32_t *)&amp;_sbss;
    for(uint32_t i = 0; i &lt; bss_mem_size; i++) {
        *p_dest_mem++ = 0;
    }
    main();
}</pre>			<p>The job of <code>Reset_Handler</code> is to <a id="_idIndexMarker419"/>prepare the system before executing the main application.</p>
			<p>In the function, we start by calculating the sizes of the <code>.data</code> and <code>.</code><code>bss</code> sections:</p>
			<pre class="source-code">
    uint32_t data_mem_size =  (uint32_t)&amp;_edata - (uint32_t)&amp;_sdata;
    uint32_t bss_mem_size  =   (uint32_t)&amp;_ebss - (uint32_t)&amp;_sbss;</pre>			<p>Here is a breakdown:</p>
			<ul>
				<li>Calculate the size of the <code>.data</code> section by subtracting the address of the start of the section (<code>_sdata</code>) from the address of the end (<code>_edata</code>). This size is used to copy initialized data from <code>FLASH</code> to <code>SRAM</code>.</li>
				<li>Calculate the size of the <code>.bss</code> section in a similar manner, using the start (<code>_sbss</code>) and end (<code>_ebss</code>) addresses. This size is used to zero out the <code>.bss</code> section in SRAM.<p class="list-inset">Next, in the function, we initialize pointers for copying the <code>.</code><code>data</code> section:</p><pre class="source-code">
    uint32_t *p_src_mem =  (uint32_t *)&amp;_etext;
    uint32_t *p_dest_mem = (uint32_t *)&amp;_sdata;</pre></li>			</ul>
			<p>Here is the breakdown:</p>
			<ul>
				<li>Initialize a source pointer (<code>p_src_mem</code>) to the address where initialized data is stored in flash memory, marked by <code>_etext</code>.</li>
				<li>Initialize a destination pointer (<code>p_dest_mem</code>) to the start of the <code>.data</code> section in SRAM (<code>_sdata</code>).<p class="list-inset">Then, we copy the <code>.data</code> section from <code>FLASH</code> to <code>SRAM</code>:</p><pre class="source-code">
    for(uint32_t i = 0; i &lt; data_mem_size; i++  ) {
        *p_dest_mem++ = *p_src_mem++;
    }</pre></li>			</ul>
			<p>The <a id="_idIndexMarker420"/>breakdown:</p>
			<ul>
				<li>Copy the <code>.data</code> section from <code>FLASH</code> to <code>SRAM</code> word (32-bit) by word. For each iteration, the content pointed to by <code>p_src_mem</code> is copied to the location pointed to by <code>p_dest_mem</code>, and then both pointers are incremented to the next word.</li>
			</ul>
			<p>Next, we initialize the pointer for the <code>.bss</code> section zeroing:</p>
			<pre class="source-code">
    p_dest_mem =  (uint32_t *)&amp;_sbss;</pre>			<p>We simply reset the destination pointer (<code>p_dest_mem</code>) to the start of the <code>.bss</code> section in SRAM (<code>_sbss</code>), preparing it for zeroing.</p>
			<p>We then zero out the <code>.</code><code>bss</code> section:</p>
			<pre class="source-code">
    for(uint32_t i = 0; i &lt; bss_mem_size; i++) {
        *p_dest_mem++ = 0;
    }</pre>			<p>This block zeroes out the <code>.bss</code> section in <code>SRAM</code> word by word. For each iteration, the location pointed to by <code>p_dest_mem</code> is set to <code>0</code>, and then <code>p_dest_mem</code> is incremented to the next word.</p>
			<p>Finally, we call the <code>main()</code> function located in the <code>main.c</code> file of our source code:</p>
			<pre class="source-code">
    main();</pre>			<p>After initializing<a id="_idIndexMarker421"/> the <code>.data</code> and <code>.bss</code> sections, this line calls the <code>main</code> function, transferring control to the main application code. This marks the end of the system initialization process and the beginning of the application execution.</p>
			<p>Now that we have completed both our linker script and startup file, it is time to test our implementation by building the firmware using just our <code>main.c</code> source file, the <code>stm32_ls.ld</code> linker script, and the <code>stm32f411_startup.c</code> startup file.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor165"/>Testing our linker script and startup file</h2>
			<p>Before diving<a id="_idIndexMarker422"/> into the <a id="_idIndexMarker423"/>command line, it’s important to ensure that our linker script and startup file are correctly placed. Let’s set up our project directory and add som<a id="_idTextAnchor166"/>e modification to our <code>main.c</code> file:</p>
			<ol>
				<li><code>3_LinkerAndStartup</code> in your workspace.</li>
				<li><code>main.c</code> file from the previous project (<code>2_RegisterManipulation</code>), which includes the foundational application code.</li><li>Additionally, locate <code>stm32_ls.ld</code> (linker script) and <code>stm32f411_startup.c</code> (startup file).</li><li>Copy and paste these files (<code>stm32_ls.ld, stm32f411_startup.c</code>, and <code>main.c</code>) into the <code>3_LinkerAndStartup</code> folder.</li></ul></li>
				<li><code>main.c</code> file from fast to slow:<ul><li><code>main.c</code> file within the <code>3_LinkerAndStartup</code> folder and select the option to open it with a simple text editor, such as Notepad++.</li><li><code>LED_PIN</code>). Adjust the delay intervals within this section to change<a id="_idIndexMarker424"/> the LED’s blink rate from its current rapid pace to a<a id="_idIndexMarker425"/> slower one. Th<a id="_idTextAnchor167"/>e current one should look like this:<pre class="source-code">
        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; 100000; i++){}</pre></li></ul><p class="list-inset">Replace the current code with the following snippet to toggle the state of PA5 at a slower rate:</p><pre class="source-code">        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; <code>main.c</code> file.</li></ul></li>			</ol>
			<p>Now, let’s access our new folder through the Command Prompt following the steps we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>. My favorite method for Windows users is the context menu method:</p>
			<p>Navigate to the <code>3_LinkerAndStartup</code> folder in Windows Explorer. Once there, hold down the <em class="italic">Shift</em> key, <em class="italic">right-click</em> in a space within the folder, and select <code>3_LinkerAndStartup</code> folder.</p>
			<p>In the Command<a id="_idIndexMarker426"/> Prompt, we start by compiling the <code>main.c</code> file, and we do this<a id="_idIndexMarker427"/> by executing the following:</p>
			<pre class="console">
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -o mai<a id="_idTextAnchor168"/>n.o</pre>			<p>Then, we execute our startup file:</p>
			<pre class="console">
arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c -o stm32f411_startup.o</pre>			<p>Once our <code>main.o</code> and <code>stm32f411_startup.o</code> object files are ready, we go ahead and link all objec<a id="_idTextAnchor169"/>t files (<code>*.o</code>) using our linker script:</p>
			<pre class="console">
arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o 3_LinkerAndStartup.elf.elf</pre>			<p>This process produces the <code>3_LinkerAndStartup.elf</code> executable.</p>
			<p>Next, we launch <code>openocd</code> to begin the uploading process:</p>
			<pre class="console">
openocd -f board/st_nucleo_f4.cfg</pre>			<p>With OpenOCD running, the next step involves using <a id="_idIndexMarker428"/>the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) to upload the firmware to the microcontroller. Let’s access another Command Prompt window (as OpenOCD should keep running in the first one) and enter the following command to start the GDB:</p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once GDB is open, we establish a connection to our microcontroller by running:</p>
			<pre class="console">
target remote localhost:3333</pre>			<p>Let’s reset and initialize the board as we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a> using the following command:</p>
			<pre class="console">
monitor reset init</pre>			<p>Next, we load the firmware onto the microcontroller using the following command:</p>
			<pre class="console">
monitor flash write_image erase 3_LinkerAndStartup.elf</pre>			<p>After successfully loading the firmware, we reset the board again with the same reset command:</p>
			<pre class="console">
monitor reset init</pre>			<p>Finally, we resume the execution of the firmware on the microcontroller with the following:</p>
			<pre class="console">
monitor resume</pre>			<p>There you have it; you should see the LED blinking at a slower rate, indicating the successful upload and execution of our new firmware.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we deeply explored the core components of embedded bare-metal programming, focusing on the microcontroller’s memory model, writing linker scripts, and startup files. We began by exploring the STM32 microcontroller’s memory layout, emphasizing the importance of flash memory and SRAM for storing executable code and runtime data.</p>
			<p>We then dedicated a significant portion of the chapter to constructing and understanding linker scripts. Through this, we understood these scripts’ critical role in the firmware build process by mapping the compiled firmware sections to the microcontroller’s specific memory regions to ensure the executable operates correctly. We learned about the various directives within a linker script, such as <code>MEMORY</code> and <code>SECTIONS</code>. These directives are crucial for defining the memory layout and specifying where and how program sections are placed in memory.</p>
			<p>Our discussion on linker scripts extended to the practicalities of defining memory regions, aligning sections, and managing section attributes for optimal memory utilization. We gave special attention to the LMA and VMA, which are essential for efficient program loading and execution.</p>
			<p>Transitioning to the startup file, we meticulously outlined the startup file’s role, covering the initialization of the vector table, setting up <code>Reset_Handler</code>, and preparing the system for the execution of the main application. We learned the procedures for copying the <code>.data</code> section from <code>FLASH</code> to <code>SRAM</code> and zeroing the <code>.bss</code> section, ensuring a predictable start for our firmware.</p>
			<p>In the next chapter, we will explore build systems, highlighting the essential role of the <code>Make</code> tool. This knowledge will enable us to streamline our build process by automating it, instead of manually entering each command in the command line.</p>
		</div>
	</div>
</div>
</body></html>