- en: 2 Getting Started with Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to do the first steps with Vulkan so that
    we can deal with swapchains, shaders, and pipelines. The recipes of this chapter
    will help you to get your first triangle on screen using Vulkan. The underlying
    Vulkan implementation is based on an open-source library, *LightweightVK* ([https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)),
    which we are going to explore in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a Vulkan instance and graphical device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a Vulkan swapchain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Vulkan debugging capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vulkan command buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Vulkan shader modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Vulkan pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the recipes from this chapter, you have to use a Windows or Linux computer
    with a video card and drivers supporting Vulkan 1.3\. Read *Chapter 1*, *Establishing
    a Build Environment*, to learn how to configure it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a Vulkan instance and graphical device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vulkan API is much more verbose compared to OpenGL, so we have to split
    the creation of our first graphical demo apps into a series of separate small
    recipes. In this recipe, we will learn how to create a Vulkan instance, enumerate
    all the physical devices in the system that are capable of 3D graphics rendering,
    and initialize one of these devices to create a window with an attached surface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are completely new to Vulkan, we recommend starting with some beginner
    Vulkan books, such as *The Modern Vulkan Cookbook* by Preetish Kakkar and Mauricio
    Maurer, or *Vulkan Programming Guide: The Official Guide to Learning Vulkan* by
    Graham Sellers.'
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part in transitioning from OpenGL to Vulkan, or any similar modern
    graphics API, is getting used to the amount of explicit code necessary to set
    up the rendering process, which, thankfully, needs to be done only once. It is
    also useful to get a grasp of Vulkan’s object model. As a good starting point,
    we recommend reading [https://gpuopen.com/understanding-vulkan-objects](https://gpuopen.com/understanding-vulkan-objects)
    by Adam Sawicki as a reference. For the further recipes in this chapter, we set
    our goal to start rendering 3D scenes with the bare minimum amount of setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'All our Vulkan recipes use the LightweightVK library, which can be downloaded
    from [https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)
    using the following Bootstrap snippet. This library implements all the low-level
    Vulkan wrapper classes that we will discuss in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The complete Vulkan example for this recipe can be found in `Chapter02/01_Swapchain`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we jump into the actual implementation, let’s explore some scaffolding
    code that makes debugging Vulkan backends a bit easier. Let us start with some
    error-checking facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any function call from a complex API may fail. To handle failure, or at least
    to let the developer know the exact location of the failure, *LightweightVK* wraps
    most of the Vulkan calls in the `VK_ASSERT()` and `VK_ASSERT_RETURN()` macros,
    which check the results of Vulkan operations. When starting to write a new Vulkan
    implementation from scratch, it will be helpful to have something similar right
    from the get-go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VK_ASSERT_RETURN()` macro is very similar and returns the control to the
    calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start creating our first Vulkan application. Let’s explore what
    is going on in the sample application `Chapter02/01_Swapchain`, which creates
    a window, a Vulkan instance, and a device together with a Vulkan swapchain, which
    will be explained shortly. The application code is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the logger library and create a GLFW window, as we discussed
    in the recipe *Using the GLFW library* from *Chapter 1*. All the Vulkan initialization
    magic happens in the `lvk::createVulkanContextWithSwapchain()` helper function,
    which we will explore shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The application main loop updates the framebuffer size if the size of the window
    changes, acquires a command buffer, submits it, and presents the current swapchain
    image, or texture as it is called in *LightweightVK*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The shutdown code is standard. We should destroy the `IDevice` object before
    destroying the GLFW window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The application should render an empty black window, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1: The main loop and swapchain](img/file11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The main loop and swapchain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore `lvk::createVulkanContextWithSwapchain()` and take a sneak peek
    at its implementation. Again, we skip most of the error checking in the book text
    where it does not contribute to the understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This helper function calls *LightweightVK* to create a *VulkanContext* object,
    based on the GLFW window and display properties for our operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we enumerate Vulkan physical devices and choose the most preferred one.
    Try to choose a discrete GPU first, and if there’s none, choose an integrated
    GPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a physical device is chosen, call `VulkanContext::initContext()`, and
    it will create all Vulkan and *LightweightVK* internal data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we have a non-empty viewport, initialize a Vulkan swapchain. The swapchain
    creation process will be explained in detail in the next recipe, *Initializing
    a Vulkan swapchain*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need to do regarding the high-level code. Let’s dig deeper and
    look at the internals of *LightweightVK* to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple functions involved to get Vulkan up and running. It all starts
    with the creation of a Vulkan instance in `VulkanContext::createInstance()`. Using
    the Vulkan instance, we can later acquire a list of physical devices with the
    required properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to specify the names of all Vulkan instance extensions required
    to run our Vulkan graphics backend. We need `VK_KHR_surface` and another platform-specific
    extension that takes an OS window handle and attaches a rendering surface to it.
    On Linux, we only support the creation of a libXCB-based window. Similarly, the
    Wayland protocol can also be supported but is out of the scope of this book. Here
    is how Wayland was added to LightweightVK, [https://github.com/corporateshark/lightweightvk/pull/13](https://github.com/corporateshark/lightweightvk/pull/13):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We disable `VK_EXT_validation_features` when validation is not required, for
    example, in release builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After constructing the list of surface-related extensions, we should fill in
    some mandatory information about our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To create a `VkInstance` object, we should populate the `VkInstanceCreateInfo`
    structure. We use a pointer to the aforementioned `appInfo` constant and the list
    of extensions in the member fields of `VkInstanceCreateInfo`. We use a list of
    so-called layers stored in a global variable, `kDefaultValidationLayers[]`, which
    will later allow us to enable debugging output for every Vulkan call. The only
    layer we use in our book is the Khronos validation layer, `VK_LAYER_KHRONOS_validation`.
    The same list of validation layers will be used to create a Vulkan device. Then,
    we use the *Volk* library to load all instance-related Vulkan functions for the
    created `VkInstance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Volk is a meta-loader for Vulkan. It allows you to dynamically load entry points
    required to use Vulkan without linking to `vulkan-1.dll` or statically linking
    the Vulkan loader. Volk simplifies the use of Vulkan extensions by automatically
    loading all associated entry points. Besides that, Volk can load Vulkan entry
    points directly from the driver, which can increase performance by skipping loader
    dispatch overhead: [https://github.com/zeux/volk](https://github.com/zeux/volk).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, let’s print a nicely formatted list of all available Vulkan
    instance extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created a Vulkan instance, we can access the list of Vulkan physical
    devices that are necessary to continue setting up our Vulkan backend. Here’s how
    we can enumerate Vulkan physical devices and choose a suitable one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `vkEnumeratePhysicalDevices()` is called twice. The first time
    is to get the number of available physical devices and allocate `std::vector`
    storage for it. The second time is to retrieve the actual physical device data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the vector of devices to retrieve their properties and filter
    out non-suitable ones. The function `convertVulkanDeviceTypeToIGL()` converts
    a Vulkan enum, `VkPhysicalDeviceType`, into a `LightweightVK` enum, `HWDeviceType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have selected a suitable Vulkan physical device, we can create a logical
    representation of a GPU `VkDevice`. We can think of Vulkan devices as essentially
    a collection of queues and memory heaps. To use a device for rendering, we need
    to specify a queue that is capable of executing graphics-related commands and
    a physical device that has such a queue. Let’s explore *LightweightVK* and some
    parts of the function `VulkanContext::initContext()`, which, among many other
    things we will cover later, detects suitable queue families and creates a Vulkan
    device. Once again, most of the error checking will be omitted here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do in `VulkanContext::initContext()` is print some information
    related to the physical device we have just selected earlier and the Vulkan driver.
    This is very useful for debugging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s enumerate and print all the extensions available on this Vulkan physical
    device, which is very helpful for debugging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before creating a Vulkan device, we need to find queue family indices and create
    queues. This code block creates one or two device queues, graphical and compute,
    based on the actual queue availability on the provided physical device. The `lvk::findQueueFamilyIndex()`
    helper function, which is implemented in `lvk/vulkan/VulkanUtils.cpp`, returns
    the first dedicated queue family index that matches the requested queue flag.
    If you look into it, you can see how it ensures you select dedicated queues first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Vulkan, `queueFamilyIndex` is the index of the queue family to which the
    queue belongs. A queue family is a collection of Vulkan queues with similar properties
    and functionality. Here, `deviceQueues_` is a member field holding a structure
    with queue information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, especially on mobile GPUs, graphics and compute queues might be
    the same. Here, we take care of such corner cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '5\. A list of extensions that our logical device is required to support. A
    device has to support a swapchain object, which allows us to present rendered
    frames on the screen. We use Vulkan 1.3, which contains all other necessary functionality,
    so no extra extensions are required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s request all the necessary *Vulkan 1.0*–*1.3* features we are going to
    use in our backend. The most important features are descriptor indexing from *Vulkan
    1.2* and dynamic rendering from *Vulkan 1.3*, which we will discuss in subsequent
    chapters. Take a look at the other features we are going to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Descriptor indexing is a set of Vulkan 1.2 features that enable applications
    to access all of their resources and select from them those with dynamic indexes
    in shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic rendering is a Vulkan 1.3 feature that allows applications to render
    directly into images without needing to create render pass objects or framebuffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more steps before we create an actual device, such as checking
    our list of requested extensions against the list of available extensions and
    printing all the missing extensions in the log and terminating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should check all the requested Vulkan features against the actual
    available features. With the help of C-macros, we can do this easily. This code
    is useful, so we have printed it here in almost its entirety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we are missing some Vulkan features, this code will print a nicely formatted
    list of missing features marked by a corresponding Vulkan version. This is invaluable
    for debugging and making your Vulkan backend adjustable to fit different devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to create a Vulkan device, load all related Vulkan functions
    with *Volk*, and get the actual device queues based on the queue family indices
    we selected earlier in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Vulkan device is now ready to be used, but the initialization of the Vulkan
    rendering pipeline is far from complete. The next thing we need to do is create
    a swapchain object. Let’s follow the next recipe to learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a Vulkan swapchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, each frame is rendered into an offscreen image. After the rendering
    process is finished, the offscreen image should be made visible or “presented.”
    A **swapchain** is an object that holds a collection of available offscreen images,
    or, more specifically, a queue of rendered images waiting to be presented on the
    screen. In OpenGL, presenting an offscreen buffer to the visible area of a window
    is performed using system-dependent functions, namely `wglSwapBuffers()` on Windows,
    `eglSwapBuffers()` on OpenGL ES-embedded systems, and `glXSwapBuffers()` on Linux
    or automatically on macOS. Vulkan gives us much more fine-grained control. We
    need to select a presentation mode for swapchain images.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to create a Vulkan swapchain object using the
    Vulkan instance and device initialized in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Revisit the previous recipe, *Initializing a Vulkan instance and graphical device*,
    which discusses the initial steps necessary to initialize Vulkan. The source code
    discussed in this recipe is implemented in the class `lvk::VulkanSwapchain`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous recipe, we started learning how Vulkan instances and devices
    are created by exploring the helper function `lvk::createVulkanContextWithSwapchain()`.
    It lead us to the function `VulkanContext::initContext()`, which we discussed
    in detail in the previous recipe. Let’s continue our journey and explore `VulkanContext::initSwapchain()`
    and a related class `VulkanSwapchain` from *LightweightVK*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us take a look at a function that retrieves various surface format
    support capabilities and stores them in the member fields of `VulkanContext`.
    The function checks depth format support as well, but only those depth formats
    that might be used by *LightweightVK*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All the surface capabilities and surface formats are retrieved and stored.
    First, get the number of supported formats. Then, allocate the storage to hold
    them and read the actual properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we store the surface present modes as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing all supported color surface formats, we can choose a suitable one for
    our swapchain. Let’s take a look at the `chooseSwapSurfaceFormat()` helper function
    on how to do it. The function takes in a list of available formats and a desired
    color space:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it picks a preferred surface format, based on the desired color space
    and RGB/BGR native swapchain image format. RGB or BGR is decided by going through
    all available color formats, returned by Vulkan, and picking one format, RGB or
    BGR, whichever is closer to the beginning of the list. If BGR is encountered earlier,
    it will be the format of choice. Once the preferred image format and color space
    are selected, we can go through the list of supported formats and try to find
    an exact match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you cannot find both a matching format and color space, try matching only
    the format. If you cannot match the format, default to the first available format.
    On many systems, it will be `VK_FORMAT_R8G8B8A8_UNORM` or a similar format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is called from the constructor of `VulkanSwapchain`. Once the
    format has been selected, we need to do a few more checks before we can create
    an actual Vulkan swapchain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first check is to ensure that the selected format supports presentation
    operation on the graphics queue family used to create the swapchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second check is necessary to choose usage flags for swapchain images. Usage
    flags define if swapchain images can be used as color attachments, in transfer
    operations, or as storage images to allow compute shaders to operate directly
    on them. Different devices have different capabilities, and storage images are
    not always supported, especially on mobile GPUs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should select the presentation mode. The preferred presentation mode
    is `VK_PRESENT_MODE_MAILBOX_KHR`, which specifies that the Vulkan presentation
    system should wait for the next vertical blanking period to update the current
    image. Visual tearing will not be observed in this case. However, this presentation
    mode is not guaranteed to be supported. In this situation, we can try picking
    `VK_PRESENT_MODE_IMMEDIATE_KHR` for the fastest frames per second without V-sync,
    or we can always fall back to `VK_PRESENT_MODE_FIFO_KHR`. The differences between
    all possible presentation mode are described in the Vulkan specification at [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last helper function we need will choose the number of images in the swapchain
    object. It is based on the surface capabilities we retrieved earlier. Instead
    of using `minImageCount` directly, we request one additional image to make sure
    we are not waiting for the GPU to complete any operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go back to the constructor `VulkanSwapchain::VulkanSwapchain()` and explore
    how it uses all the aforementioned helper functions to create a Vulkan swapchain
    object. The code here becomes rather short and consists only of filling in the
    `VkSwapchainCreateInfoKHR` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After the swapchain object has been created, we can retrieve swapchain images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The retrieved `VkImage` objects can be used to create textures and attachments.
    This topic will be discussed in the recipe *Using texture data in Vulkan* in *Chapter
    3*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have initialized Vulkan and can actually run our first application,
    *Chapter02/01_Swapchain*. In the next recipe, we will learn how to use Vulkan’s
    built-in debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Vulkan debugging capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created a Vulkan instance, we can start tracking all possible errors
    and warnings produced by the validation layers. To do so, we use the extension
    `VK_EXT_debug_utils` to create a callback function and register it with the Vulkan
    instance. In this recipe, we will learn how to set up and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please revisit the first recipe, *Initializing a Vulkan instance and graphical
    device*, for details on how to initialize Vulkan in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have to provide a callback function to Vulkan to catch the debug output.
    In *LightweightVK*, it is called `vulkanDebugCallback()`. Here’s how it can be
    passed into Vulkan to intercept logs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a debug messenger that will pass along debug messages to an application-supplied
    callback, `vulkanDebugCallback()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback itself is more elaborate and can provide information about a Vulkan
    object causing an error or warning. We do not cover tagged object allocation and
    associating used data. Some performance warnings are silenced to make the debug
    output more readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is sufficient to get you started with reading the validation layer
    messages and debugging your Vulkan applications. Also, please note that the destruction
    of the validation layer callbacks should be performed right before the Vulkan
    instance destruction. Check the full source code for all the details: [https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp](https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp).'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The extension `VK_EXT_debug_utils` provides you with the ability to identify
    specific Vulkan objects, using a textual name or tag to improve Vulkan object
    tracking and the debugging experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *LightweightVK*, we can assign a name to our `VkDevice` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This helper function is implemented in `lvk/vulkan/VulkanUtils.cpp` and looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using Vulkan command buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipes, we learned how to create a Vulkan instance, a device
    for rendering, and a swapchain. In this recipe, we will learn how to manage **command
    buffers** and submit them using **command queues**, which will bring us a bit
    closer to rendering our first image with Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan command buffers are used to record Vulkan commands that can be then submitted
    to a device queue for execution. Command buffers are allocated from pools that
    allow the Vulkan implementation to amortize the cost of resource creation across
    multiple command buffers. Command pools are **externally synchronized**, which
    means one command pool should not be used between multiple threads. Let’s learn
    how to make a convenient user-friendly wrapper on top of Vulkan command buffers
    and pools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to explore the command buffers management code from the LightweightVK
    library. Take a look at the class `VulkanImmediateCommands` from `lvk/vulkan/VulkanClasses.h`.
    In the previous edition of our book, we used very rudimentary command buffers
    management code, which did not suppose any synchronization because every frame
    was “synchronized” with `vkDeviceWaitIdle()`. Here, we are going to explore a
    more pragmatic solution with some facilities for synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our demo application from the recipe *Initializing a Vulkan
    swapchain*, which renders a black empty window, *Chapter02/01_Swapchain*. The
    main loop of the application looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we acquire a next command buffer and then submit it without writing any
    commands into it, allowing `LightweightVK` to run its swapchain presentation code
    and render a black window. Let’s dive deep into the implementation and learn how
    `lvk::VulkanImmediateCommands` does all the heavy lifting behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need a helper, `struct SubmitHandle`, to identify previously submitted
    command buffers. This is going to be necessary to implement synchronization when
    someone wants to schedule some work, which depends on the results of a previously
    submitted command buffer. It contains an internal ID of the submitted buffer and
    an integer ID of the submit. Handles can be converted to and from 64-bit integers
    for convenience:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helper struct `CommandBufferWrapper` is necessary to encapsulate all
    Vulkan objects associated with one command buffer. Here, we store the originally
    allocated and the currently active command buffers. The most recent submit handle
    is associated with this command buffer. A Vulkan fence and a Vulkan semaphore
    are associated with this command buffer. The fence is used to implement GPU-CPU
    synchronization. The semaphore is necessary to ensure that command buffers are
    processed by the GPU in sequence, as `LightweightVK` enforces all the command
    buffers to be processed in the order in which they were submitted. It simplifies
    many things in terms of rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at the interface of `lvk::VulkanImmediateCommands`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vulkan command buffers are preallocated and used in a round-robin fashion.
    The number of command buffers that are preallocated is `kMaxCommandBuffers`. If
    we run out of buffers, `VulkanImmediateCommands` will wait until an existing command
    buffer becomes available by waiting on a fence. `64` command buffers ensure a
    non-blocking operation in most situations. The constructor takes the value of
    `queueFamilyIdx` to retrieve an appropriate Vulkan queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `acquire()` method returns the next available command buffer. If all command
    buffers are busy, it will wait on a fence until one command buffer becomes available.
    The `submit()` method submits a command buffer to the assigned Vulkan queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two methods provide GPU-GPU synchronization mechanics. The first method,
    `waitSemaphore()`, makes the current command buffer wait on a given semaphore
    before running. A typical use case for this is to get an “acquire semaphore” from
    a `VulkanSwapchain` object, which waits to acquire a swapchain image, and make
    sure the command buffer will wait on it before starting to render into a swapchain
    image. The second method, `acquireLastSubmitSemaphore()`, returns and resets the
    semaphore, which is signaled when the last submitted command buffer is completed.
    This semaphore can be used by the swapchain before presentation to ensure the
    image rendering is completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next group of methods governs GPU-CPU synchronization. As we will see later
    in this recipe, submit handles are implemented using Vulkan fences and can be
    used to wait for specific GPU operations to be completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The private section of the class holds all the local state, including an array
    of pre-allocated `CommandBufferWrapper` objects `buffers_`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `VulkanImmediateCommands` class is really central to the entire operation
    of our Vulkan backend, so let’s explore its implementation in detail, one method
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the class constructor and destructor. The constructor pre-allocates
    all command buffers. Error checking and debugging code will be skipped here in
    the text; please refer to the *LightweightVK* library source code for full details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should retrieve a Vulkan device queue and allocate a command pool.
    We use the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag to specify that
    any command buffers allocated from this pool can be individually reset to the
    initial state using the Vulkan function `vkResetCommandBuffer()`. To specify that
    command buffers allocated from this pool will be short-lived, we use the flag
    `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`, meaning that they will be reset or freed
    in a relatively short timeframe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pre-allocate all the command buffers from the command pool. Besides
    that, we create one semaphore and one fence per command buffer to enable our synchronization
    machinery:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor is trivial. All we have to do is wait for all command buffers
    to be processed before destroying the command pool, fences, and semaphores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at the implementation of our most important functions,
    `acquire()`. All the error-checking code is omitted again to simplify understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can find an available command buffer, we have to be sure there is
    one. This busy-wait loop checks the number of currently available command buffers
    and calls the `purge()` function, which recycles processed command buffers and
    resets them to their initial state, until we get at least one buffer available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Once we know there’s at least one command buffer available, we can find it by
    going through the array of all the buffers and picking the first one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we decrement `numAvailableCommandBuffers`. This is to make sure
    we busy-wait properly the next time we call `acquire()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `isEncoding` member field is used to safeguard against the reuse of the
    currently encoded, but not yet submitted, command buffer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have done all the bookkeeping on the library side, we can call the
    Vulkan API to begin recording the current command buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explore the next series of functions, let’s take a look inside a
    short helper function, `purge()`, which was mentioned above in `acquire()`. This
    function calls `vkWaitForFences()` with a Vulkan fence and the `timeout` value
    of `0`, which returns the current status of the fence without waiting. If the
    fence is signaled, we can reset the command buffer and increment `numAvailableCommandBuffers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very important function is `submit()`, which submits a command buffer
    to a queue. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we should call `vkEndCommandBuffer()` to finish recording a command buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should prepare semaphores. We can set two optional semaphores to be
    waited on before the GPU processes our command buffer. The first one is the semaphore
    we inject with the `waitSemaphore()` function. It can be an “acquire semaphore”
    from a swapchain or any other user-provided semaphore if we want to organize a
    frame graph of some sort. The second semaphore, `lastSubmitSemaphore_`, is the
    semaphore signaled by a previously submitted command buffer. This ensures that
    all command buffers are processed sequentially one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have all the data in place, a call to `vkQueueSubmit()` is trivial.
    We set `pSignalSemaphores` to the semaphore store in the current `CommandBufferWrapper`
    object so that we can wait on it in the next `submit()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `waitSemaphore_` object is used, drop it. It should be used only with
    exactly one command buffer. The submit counter is used to set the `submitId` value
    in `SubmitHandle`. There’s one trick we can do here. `SubmitHandle` is considered
    empty when its command buffer and `submitId` are zero. One easy way to do it is
    to always skip the zero value of `submitCounter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is already sufficient to organize command buffer management in an
    application. However, let’s inspect other methods of `VulkanImmediateCommands`
    that make the work with Vulkan fences much easier by hiding them behind `SubmitHandle`.
    The next most useful method is `isReady()`, which is our high-level equivalent
    of `vkWaitForFences()`, with the timeout set to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we do a trivial check for an empty submit handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we inspect an actual command buffer wrapper and check if its command
    buffer has already been recycled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Another situation is when a command buffer has been recycled and then reused
    again. In this case, `submitId` values would be different. Only after this comparison
    can we invoke the Vulkan API to get the status of our `VkFence` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This `isReady()` method provides a simple interface to Vulkan fences that can
    be exposed to applications using *LightweightVK*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a pair of similar methods that allow us to wait for command buffers
    or on a specific handle or `VkFence`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is `wait()`, which waits for a single fence to be signaled. There
    are two important things to mention here. We can detect a wait operation on a
    not-submitted command buffer using the `isEncoding_` flag. Also, we call `purge()`
    at the end of the function because we are sure there is now at least one command
    buffer to be reclaimed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function waits for all command buffers to be completed, which is
    handy when we want to delete all resources, for example, in the destructor. The
    implementation is straightforward, and we call `purge()` again to reclaim all
    the completed command buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Those are all the details about the low-level implementation. Now, let’s take
    a look at how this code works with our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go all the way back to our demo application and its main loop. We call
    the function `VulkanContext::acquireCommandBuffer()`, which returns a reference
    to some high-level interface, `lvk::ICommandBuffer`. Then, we call `VulkanContext::submit()`
    to submit that command buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what is going on inside those functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function, `VulkanContext::acquireCommandBuffer()`, is very simple.
    It creates a `lvk::CommandBuffer` object and returns a referent to it. This object
    implements the `lvk::ICommandBuffer` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `VulkanContext::submit()` is more elaborate. Besides submitting
    a command buffer, it takes an optional argument of a swapchain texture to be presented.
    We will skip this part here and focus only on the command buffer submission part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we inject `acquireSemaphore_` from the swapchain into the `VulkanImmediateCommands`
    object so that we wait for it to be signaled before starting rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the aforementioned `VulkanImmediateCommands::submit()` and use
    its last submit semaphore to tell the swapchain to wait until the rendering is
    completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'On every submit operation, we process so-called deferred tasks. A deferred
    task is a `std::packaged_task` that should be run only when an associated `SubmitHandle`
    (a.k.a. `VkFence`) is ready. This mechanism is very helpful to manage or deallocate
    resources and will be discussed in subsequent chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a working subsystem to wrangle Vulkan command buffers and expose
    `VkFence` objects to user applications in a clean and straightforward way. We
    did not cover the `ICommandBuffer` interface in this recipe, but we will do it
    shortly in this chapter while doing our first Vulkan rendering demo. Before we
    can do rendering, let’s learn how to deal with compiled SPIR-V shaders from the
    recipe *Compiling Vulkan shaders at runtime* in *Chapter 1*.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend referring to *Vulkan Cookbook* by Pawel Lapinski for in-depth coverage
    of swapchain creation and command queue management.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Vulkan shader modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vulkan API consumes shaders in the form of compiled SPIR-V binaries. In one
    of the previous recipes in *Chapter 1*, *Compiling Vulkan shaders at runtime*,
    we learned how to compile shaders from GLSL source code to SPIR-V, using the open-source
    `glslang` compiler from Khronos. In this recipe, we will learn how to use GLSL
    shaders and precompiled binaries in Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend reading the recipe *Compiling Vulkan shaders at runtime* from *Chapter
    1* before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at our next demo application, `Chapter02/02_HelloTriangle`,
    to learn the high-level *LightweightVK* API for shader modules. As we will see,
    there’s a `createShaderModule()` method in `IContext` that does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a pointer to `IContext`, Vulkan shader modules can be created from GLSL
    shaders in the following way, where `codeVS` and `codeFS` are null-terminated
    strings holding the vertex and fragment shader source code, respectively. Note
    that these values are used to initialize a structure passed into `createShaderModule()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter of `createShaderModule()` is a structure, `ShaderModuleDesc`,
    containing all the properties required to create a Vulkan shader module. If the
    `dataSize` member field is non-zero, the `data` field is treated as a binary SPIR-V
    blob. If `dataSize` is zero, `data` is treated as a null-terminated string containing
    GLSL source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `VulkanContext::createShaderModule()`, we do the branching for textual
    GLSL and binary SPIR-V shaders. An actual `VkShaderModule` object is stored in
    a pool, which we will discuss in subsequent chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of a Vulkan shader module from a binary SPIR-V blob looks as follows.
    Error checking is omitted for simplicity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now, Vulkan shader modules are ready to be used inside Vulkan pipelines. Let’s
    learn how to do so in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Vulkan pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Vulkan pipeline is an implementation of an abstract graphics pipeline, which
    is a sequence of operations to transform vertices and rasterize the resulting
    image. In essence, the idea is similar to a single snapshot of a “frozen” OpenGL
    state. Vulkan pipelines are mostly immutable, which means multiple Vulkan pipelines
    should be created to allow different data paths through the graphics pipeline.
    In this recipe, we will learn how to create a Vulkan pipeline suitable to render
    a colorful triangle, and we will explore how low-level and verbose Vulkan can
    be wrapped into a simple high-level interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get all the basic information about Vulkan pipelines, we recommend reading
    *Vulkan Cookbook* by Pawel Lapinski, which was published by Packt, or the *Vulkan
    Tutorial* series by Alexander Overvoorde: [https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on descriptor set layouts, check out the chapter
    at [https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer](https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer).
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan pipelines require Vulkan shader modules. Check out the previous recipe,
    *Initializing Vulkan shader modules*, before going through this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us dive deep into how to create and configure a Vulkan pipeline suitable
    for our application. Due to the extreme verbosity of Vulkan API, this recipe will
    be the longest. We will start from the high-level code in our demo application,
    `Chapter02/02_HelloTriangle`, and go all the way to the internals of *LightweightVK*.
    In the subsequent chapters, we will go into more detail, such as dynamic states,
    multisampling, vertex input, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the initialization and main loop of `Chapter02/02_HelloTriangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a Vulkan context, as described in the previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a rendering pipeline. *LightweightVK* uses opaque handles
    to work with resources, so here, `lvk::RenderPipelineHandle` is an opaque handle
    that manages a collection of `VkPipeline` objects, and `lvk::Holder` is an RAII
    wrapper to automatically dispose of handles that go out of scope. The method `createRenderPipeline()`
    accepts a structure, `RenderPipelineDesc`, that contains data necessary to configure
    a rendering pipeline. For our first triangle demo, we want to be as minimalistic
    as possible, so we set vertex and fragment shaders and define the format of a
    color attachment. This is the absolute minimum we need to render something into
    a swapchain image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the main loop, we acquire a command buffer, as described in the recipe
    *Using Vulkan command buffers*, and issue some drawing commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The member function `cmdBeginRendering()` wraps the Vulkan 1.3 dynamic rendering
    functionality, which enables rendering directly into Vulkan images without explicitly
    creating any render passes or framebuffer objects. It takes a description of a
    render pass, `lvk::RenderPass`, and a description of a framebuffer, `lvk::Framebuffer`.
    We will explore it in more detail in subsequent chapters. Here, we use the current
    swapchain texture as the first color attachment and clear it to while color before
    rendering, using the attachment load operation `LoadOp_Clear`, which corresponds
    to `VK_ATTACHMENT_LOAD_OP_CLEAR` in Vulkan. The store operation is set to `StoreOp_Store`
    by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The render pipeline can be bound to the command buffer in one line. Then, we
    can issue a drawing command, `cmdDraw()`, which is a wrapper on top of `vkCmdDraw()`.
    You may have noticed that we did not use any index or vertex buffers at all. We
    will see why in a moment when we look at GLSL shaders. The command `cmdEndRendering()`
    corresponds to `vkCmdEndRendering()` from Vulkan 1.3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the GLSL shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we do not provide any vertex input, the vertex shader has to generate vertex
    data for a triangle. We use the built-in variable `gl_VertexIndex`, which gets
    incremented automatically for every subsequent vertex, returning hardcoded values
    for positions and vertex colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader is trivial and just outputs the interpolated color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The application should render a colorful triangle, as shown in the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Hello triangle](img/file12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Hello triangle'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to draw a triangle with Vulkan using *LightweightVK*. It is time
    to look under the hood and find out how this high-level render pipeline management
    interface is implemented via Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To explore the underlying Vulkan implementation, we have to peel back a few
    layers one by one. When we want to create a graphics pipeline in our application,
    we call the member function `IContext::createRenderPipeline()`, which is implemented
    in `VulkanContext`. This function takes in a structure, `lvk::RenderPipelineDesc`,
    which describes our rendering pipeline. Let’s take a closer look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure contains a subset of information necessary to create a valid
    graphics `VkPipeline` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum number of color attachments is set to `4`. We do not store the
    number of used attachments here. Instead, we use a helper function to calculate
    how many attachments we actually have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Other member fields represent a typical rendering state with a cull mode, face
    winding, polygon mode, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `VulkanContext::createRenderPipeline()`, all it does is do some
    sanity checks on `RenderPipelineDesc` and store all the values in the `RenderPipelineState`
    struct. As we already mentioned, *LightweightVK* pipelines cannot be directly
    one-to-one mapped to `VkPipeline` objects. The reason for this is that `RenderPipelineDesc`
    provides a more dynamic state than un-extended Vulkan 1.3 can support. For example,
    *LightweightVK* manages descriptor set layouts automatically. Vulkan requires
    a descriptor set layout to be specified for a pipeline object. To lift this limitation,
    the data stored in `RenderPipelineState` is used to lazily create actual `VkPipeline`
    objects in a function, `VulkanContext::getVkPipeline()`. Let’s take a look at
    this mechanism. Error checking and some unimportant details are omitted to simplify
    understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor requires `VulkanContext` and `RenderPipelineDesc`. It does
    some preparation work but does not create actual `VkPipeline` objects. We will
    look into its implementation shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Pre-cache some useful values so that we do not reinitialize them every time
    we create a new Vulkan pipeline object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'With all data structures in place, we are now ready to go through the implementation
    code of `VulkanContext::createRenderPipeline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor iterates over vertex input attributes and pre-caches all necessary
    data into Vulkan structures for further use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate and cache the vertex input bindings and attributes. Vertex buffer bindings
    are tracked in `bufferAlreadyBound`. Everything else is very trivial conversion
    code from our high-level data structures to Vulkan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create actual Vulkan pipelines. Well, almost. A couple of very
    long code snippets await us. These are the longest functions in the entire book,
    but we have to go through them at least once. That said, error checking is skipped
    to simplify things a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getVkPipeline()` function retrieves a `RenderPipelineState` struct associated
    with a provided pipeline handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we check if a descriptor set layout used to create a pipeline layout
    for this `VkPipeline` object has changed. Our implementation uses descriptor indexing
    to manage all textures in a huge descriptor set and creates a descriptor set layout
    to store all the textures. Once new textures are loaded, there might not be enough
    space to store them, and a new descriptor set layout would have to be created.
    Every time this happens, we have to delete the old `VkPipeline` and `VkPipelineLayout`
    objects and create new ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is already a valid graphics pipeline compatible with the current descriptor
    set layout, we can just return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s prepare to build a new Vulkan pipeline object. Not all color attachments
    are valid. We need to create color blend attachments only for active color attachments.
    Helper functions, such as `formatToVkFormat()`, convert *LightweightVK* enumerations
    to Vulkan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up blending states for color attachments is tedious but very simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve `VkShaderModule` objects from the pool using opaque handles. We will
    discuss how pools work in the next chapters. Here, all we have to know is that
    they allow fast conversion of an integer handle into the actual data associated
    with it. The geometry shader is optional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a `VkSpecializationInfo` structure to describe specialization constants
    for this graphics pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a suitable `VkPipelineLayout` object for this pipeline. Use the current
    descriptor set layout stored in `VulkanContext`. Here, one descriptor set layout,
    `vkDSL_`, is duplicated multiple times to create a pipeline layout. This is necessary
    to ensure compatibility with MoltenVK, which does not allow the aliasing of different
    descriptor types. Push constant sizes are retrieved from precompiled shader modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a snippet to retrieve push constant sizes from shader modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'As we peel back more and more implementation layers, here is yet another level
    to peel. However, it is the last one. For convenience, the creation of actual
    `VkPipeline` objects is encapsulated into `VulkanPipelineBuilder`, which provides
    reasonable default values for all the numerous Vulkan data members that we do
    not want to set. Those familiar with Java will recognize some form of a typical
    *Builder* design pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Shader modules are provided one by one. Only a vertex and a fragment shader
    are mandatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `VulkanPipelineBuilder::build()` method, which creates
    a `VkPipeline` object that we can store in our `RenderPipelineState` structure,
    together with the pipeline layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method we want to explore here is `VulkanPipelineBuilder::build()`,
    which is pure Vulkan. Let’s take a look at it to conclude the pipeline creation
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we put the provided dynamic states into `VkPipelineDynamicStateCreateInfo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vulkan specifications say that the viewport and scissor can be `nullptr`
    if the viewport and scissor states are dynamic. We are definitely happy to make
    the most of this opportunity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the color blend states and attachments that we prepared earlier in this
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Put everything together into `VkGraphicsPipelineCreateInfo` and call `vkCreateGraphicsPipelines()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This code concludes the pipeline creation process. Besides the very simple example,
    `Chapter02/02_HelloTriangle`, we created a slightly more elaborate app to demonstrate
    how to use multiple render pipelines, rendering a rotating cube with a wireframe
    overlay that uses the GLM library for matrix math. Check it out in `Chapter02/03_GLM`,
    and see how it uses `cmdPushConstants()` to animate the cube. It should look like
    the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: GLM usage example](img/file13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: GLM usage example'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with older versions of Vulkan, you might have noticed that
    in this recipe, we completely left out any references to render passes. They are
    also not mentioned in any of the data structures. The reason for this is that
    we use Vulkan 1.3’s dynamic rendering functionality, which allows `VkPipeline`
    objects to not require a render pass.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to implement a similar wrapper for older versions of Vulkan without
    using the *VK_KHR_dynamic_rendering* extension, you can maintain a “global” collection
    of render passes in an array inside `VulkanContext` and add an integer index of
    a corresponding render pass as a data member to `RenderPipelineDynamicState`.
    Since we can use only a very restricted number of distinct rendering passes—let’s
    say a maximum of 256—the index can be saved as `uint8_t`. This would enable the
    hash key to remain within the `uint32_t` size.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore an actual working implementation of this approach, take
    a look at Meta’s IGL library at [https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h](https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h),
    and check out how `renderPassIndex` is handled there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s jump to the next chapter, *Working with Vulkan objects*, to learn
    how to use Vulkan in a user-friendly way to build more interesting examples.
  prefs: []
  type: TYPE_NORMAL
