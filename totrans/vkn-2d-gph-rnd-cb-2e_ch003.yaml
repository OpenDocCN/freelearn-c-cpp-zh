- en: 2 Getting Started with Vulkan
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to do the first steps with Vulkan so that
    we can deal with swapchains, shaders, and pipelines. The recipes of this chapter
    will help you to get your first triangle on screen using Vulkan. The underlying
    Vulkan implementation is based on an open-source library, *LightweightVK* ([https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)),
    which we are going to explore in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a Vulkan instance and graphical device
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a Vulkan swapchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Vulkan debugging capabilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vulkan command buffers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Vulkan shader modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing Vulkan pipelines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the recipes from this chapter, you have to use a Windows or Linux computer
    with a video card and drivers supporting Vulkan 1.3\. Read *Chapter 1*, *Establishing
    a Build Environment*, to learn how to configure it properly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a Vulkan instance and graphical device
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Vulkan API is much more verbose compared to OpenGL, so we have to split
    the creation of our first graphical demo apps into a series of separate small
    recipes. In this recipe, we will learn how to create a Vulkan instance, enumerate
    all the physical devices in the system that are capable of 3D graphics rendering,
    and initialize one of these devices to create a window with an attached surface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are completely new to Vulkan, we recommend starting with some beginner
    Vulkan books, such as *The Modern Vulkan Cookbook* by Preetish Kakkar and Mauricio
    Maurer, or *Vulkan Programming Guide: The Official Guide to Learning Vulkan* by
    Graham Sellers.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part in transitioning from OpenGL to Vulkan, or any similar modern
    graphics API, is getting used to the amount of explicit code necessary to set
    up the rendering process, which, thankfully, needs to be done only once. It is
    also useful to get a grasp of Vulkan’s object model. As a good starting point,
    we recommend reading [https://gpuopen.com/understanding-vulkan-objects](https://gpuopen.com/understanding-vulkan-objects)
    by Adam Sawicki as a reference. For the further recipes in this chapter, we set
    our goal to start rendering 3D scenes with the bare minimum amount of setup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'All our Vulkan recipes use the LightweightVK library, which can be downloaded
    from [https://github.com/corporateshark/lightweightvk](https://github.com/corporateshark/lightweightvk)
    using the following Bootstrap snippet. This library implements all the low-level
    Vulkan wrapper classes that we will discuss in this book:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The complete Vulkan example for this recipe can be found in `Chapter02/01_Swapchain`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we jump into the actual implementation, let’s explore some scaffolding
    code that makes debugging Vulkan backends a bit easier. Let us start with some
    error-checking facilities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实际实现之前，让我们探索一些使调试 Vulkan 后端变得更容易的脚手架代码。让我们从一些错误检查设施开始：
- en: 'Any function call from a complex API may fail. To handle failure, or at least
    to let the developer know the exact location of the failure, *LightweightVK* wraps
    most of the Vulkan calls in the `VK_ASSERT()` and `VK_ASSERT_RETURN()` macros,
    which check the results of Vulkan operations. When starting to write a new Vulkan
    implementation from scratch, it will be helpful to have something similar right
    from the get-go:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从复杂的 API 中调用的任何函数都可能失败。为了处理失败，或者至少让开发者知道失败的确切位置，*LightweightVK* 将大多数 Vulkan
    调用包装在 `VK_ASSERT()` 和 `VK_ASSERT_RETURN()` 宏中，这些宏检查 Vulkan 操作的结果。当从头开始编写新的 Vulkan
    实现时，这将非常有帮助：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `VK_ASSERT_RETURN()` macro is very similar and returns the control to the
    calling code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_ASSERT_RETURN()` 宏非常相似，并将控制权返回给调用代码：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can start creating our first Vulkan application. Let’s explore what
    is going on in the sample application `Chapter02/01_Swapchain`, which creates
    a window, a Vulkan instance, and a device together with a Vulkan swapchain, which
    will be explained shortly. The application code is very simple:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建我们的第一个 Vulkan 应用程序。让我们探索示例应用程序 `Chapter02/01_Swapchain` 中正在发生的事情，该应用程序创建了一个窗口、一个
    Vulkan 实例和一个设备，以及一个 Vulkan 交换链，这将在接下来的食谱中解释。应用程序代码非常简单：
- en: 'We initialize the logger library and create a GLFW window, as we discussed
    in the recipe *Using the GLFW library* from *Chapter 1*. All the Vulkan initialization
    magic happens in the `lvk::createVulkanContextWithSwapchain()` helper function,
    which we will explore shortly:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化日志库并创建一个 GLFW 窗口，正如我们在第 1 章的食谱 *使用 GLFW 库* 中讨论的那样。所有 Vulkan 初始化魔法都发生在 `lvk::createVulkanContextWithSwapchain()`
    辅助函数中，我们将在稍后探索：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The application main loop updates the framebuffer size if the size of the window
    changes, acquires a command buffer, submits it, and presents the current swapchain
    image, or texture as it is called in *LightweightVK*:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序主循环在窗口大小改变时更新帧缓冲区大小，获取一个命令缓冲区，提交它，并呈现当前的交换链图像，或者在 *LightweightVK* 中称为纹理：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The shutdown code is standard. We should destroy the `IDevice` object before
    destroying the GLFW window:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭代码是标准的。在销毁 GLFW 窗口之前，我们应该销毁 `IDevice` 对象：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The application should render an empty black window, as shown in the following
    screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应该渲染一个空的黑窗口，如下面的截图所示：
- en: '![Figure 2.1: The main loop and swapchain](img/file11.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：主循环和交换链](img/file11.png)'
- en: 'Figure 2.1: The main loop and swapchain'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：主循环和交换链
- en: 'Let’s explore `lvk::createVulkanContextWithSwapchain()` and take a sneak peek
    at its implementation. Again, we skip most of the error checking in the book text
    where it does not contribute to the understanding:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `lvk::createVulkanContextWithSwapchain()` 并窥视其实现。同样，我们跳过了书中文本中的大多数错误检查，因为这些错误检查并不有助于理解：
- en: 'This helper function calls *LightweightVK* to create a *VulkanContext* object,
    based on the GLFW window and display properties for our operating system:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个辅助函数调用 *LightweightVK* 来创建一个基于 GLFW 窗口和操作系统显示属性的 *VulkanContext* 对象：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we enumerate Vulkan physical devices and choose the most preferred one.
    Try to choose a discrete GPU first, and if there’s none, choose an integrated
    GPU:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们枚举 Vulkan 物理设备并选择最偏好的一个。首先尝试选择一个离散 GPU，如果没有，则选择一个集成 GPU：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once a physical device is chosen, call `VulkanContext::initContext()`, and
    it will create all Vulkan and *LightweightVK* internal data structures:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了一个物理设备，就调用 `VulkanContext::initContext()`，它将创建所有 Vulkan 和 *LightweightVK*
    内部数据结构：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we have a non-empty viewport, initialize a Vulkan swapchain. The swapchain
    creation process will be explained in detail in the next recipe, *Initializing
    a Vulkan swapchain*.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个非空的视口，初始化一个 Vulkan 交换链。交换链创建过程将在下一道食谱中详细解释，*初始化 Vulkan 交换链*。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That is all we need to do regarding the high-level code. Let’s dig deeper and
    look at the internals of *LightweightVK* to see how it works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于高级代码，我们只需做这些。让我们深入挖掘，看看 *LightweightVK* 的内部结构，看看它是如何工作的。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are multiple functions involved to get Vulkan up and running. It all starts
    with the creation of a Vulkan instance in `VulkanContext::createInstance()`. Using
    the Vulkan instance, we can later acquire a list of physical devices with the
    required properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个函数涉及将 Vulkan 启动并运行。一切始于在 `VulkanContext::createInstance()` 中创建 Vulkan 实例。使用
    Vulkan 实例，我们可以在以后获取具有所需属性的一组物理设备。
- en: 'First, we need to specify the names of all Vulkan instance extensions required
    to run our Vulkan graphics backend. We need `VK_KHR_surface` and another platform-specific
    extension that takes an OS window handle and attaches a rendering surface to it.
    On Linux, we only support the creation of a libXCB-based window. Similarly, the
    Wayland protocol can also be supported but is out of the scope of this book. Here
    is how Wayland was added to LightweightVK, [https://github.com/corporateshark/lightweightvk/pull/13](https://github.com/corporateshark/lightweightvk/pull/13):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要指定所有运行我们的 Vulkan 图形后端所需的 Vulkan 实例扩展的名称。我们需要 `VK_KHR_surface` 以及另一个平台特定的扩展，该扩展接受操作系统窗口句柄并将其附加到渲染表面。在
    Linux 上，我们只支持基于 libXCB 的窗口创建。同样，Wayland 协议也可以支持，但超出了本书的范围。以下是 Wayland 被添加到 LightweightVK
    的方式，[https://github.com/corporateshark/lightweightvk/pull/13](https://github.com/corporateshark/lightweightvk/pull/13)：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We disable `VK_EXT_validation_features` when validation is not required, for
    example, in release builds:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不需要验证时，我们禁用 `VK_EXT_validation_features`，例如，在发布构建中：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After constructing the list of surface-related extensions, we should fill in
    some mandatory information about our application:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建与表面相关的扩展列表之后，我们应该填写一些关于我们应用程序的必要信息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To create a `VkInstance` object, we should populate the `VkInstanceCreateInfo`
    structure. We use a pointer to the aforementioned `appInfo` constant and the list
    of extensions in the member fields of `VkInstanceCreateInfo`. We use a list of
    so-called layers stored in a global variable, `kDefaultValidationLayers[]`, which
    will later allow us to enable debugging output for every Vulkan call. The only
    layer we use in our book is the Khronos validation layer, `VK_LAYER_KHRONOS_validation`.
    The same list of validation layers will be used to create a Vulkan device. Then,
    we use the *Volk* library to load all instance-related Vulkan functions for the
    created `VkInstance`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个 `VkInstance` 对象，我们应该填充 `VkInstanceCreateInfo` 结构。我们使用上述 `appInfo` 常量的指针以及
    `VkInstanceCreateInfo` 成员字段中的扩展列表。我们使用存储在全局变量 `kDefaultValidationLayers[]` 中的所谓层列表，这将允许我们为每个
    Vulkan 调用启用调试输出。我们书中使用的唯一层是 Khronos 验证层，`VK_LAYER_KHRONOS_validation`。相同的验证层列表将用于创建
    Vulkan 设备。然后，我们使用 *Volk* 库加载为创建的 `VkInstance` 相关的所有实例相关 Vulkan 函数。
- en: 'Volk is a meta-loader for Vulkan. It allows you to dynamically load entry points
    required to use Vulkan without linking to `vulkan-1.dll` or statically linking
    the Vulkan loader. Volk simplifies the use of Vulkan extensions by automatically
    loading all associated entry points. Besides that, Volk can load Vulkan entry
    points directly from the driver, which can increase performance by skipping loader
    dispatch overhead: [https://github.com/zeux/volk](https://github.com/zeux/volk).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Volk 是 Vulkan 的元加载器。它允许你在不链接到 `vulkan-1.dll` 或静态链接 Vulkan 加载器的情况下动态加载使用 Vulkan
    所需的入口点。Volk 通过自动加载所有相关入口点简化了 Vulkan 扩展的使用。除此之外，Volk 可以直接从驱动程序加载 Vulkan 入口点，这可以通过跳过加载器调度开销来提高性能：[https://github.com/zeux/volk](https://github.com/zeux/volk)。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Last but not least, let’s print a nicely formatted list of all available Vulkan
    instance extensions:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们打印出所有可用的 Vulkan 实例扩展的格式化列表：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once we have created a Vulkan instance, we can access the list of Vulkan physical
    devices that are necessary to continue setting up our Vulkan backend. Here’s how
    we can enumerate Vulkan physical devices and choose a suitable one:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 Vulkan 实例，我们就可以访问必要的 Vulkan 物理设备列表，以继续设置我们的 Vulkan 后端。以下是我们可以枚举 Vulkan
    物理设备并选择一个合适设备的方法：
- en: 'The function `vkEnumeratePhysicalDevices()` is called twice. The first time
    is to get the number of available physical devices and allocate `std::vector`
    storage for it. The second time is to retrieve the actual physical device data:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `vkEnumeratePhysicalDevices()` 被调用两次。第一次是为了获取可用物理设备的数量并为它分配 `std::vector`
    存储空间。第二次是为了检索实际的物理设备数据：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We iterate through the vector of devices to retrieve their properties and filter
    out non-suitable ones. The function `convertVulkanDeviceTypeToIGL()` converts
    a Vulkan enum, `VkPhysicalDeviceType`, into a `LightweightVK` enum, `HWDeviceType`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历设备向量以检索它们的属性并过滤掉不合适的设备。函数`convertVulkanDeviceTypeToIGL()`将Vulkan枚举`VkPhysicalDeviceType`转换为`LightweightVK`枚举`HWDeviceType`：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have selected a suitable Vulkan physical device, we can create a logical
    representation of a GPU `VkDevice`. We can think of Vulkan devices as essentially
    a collection of queues and memory heaps. To use a device for rendering, we need
    to specify a queue that is capable of executing graphics-related commands and
    a physical device that has such a queue. Let’s explore *LightweightVK* and some
    parts of the function `VulkanContext::initContext()`, which, among many other
    things we will cover later, detects suitable queue families and creates a Vulkan
    device. Once again, most of the error checking will be omitted here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个合适的Vulkan物理设备，我们就可以创建一个GPU的逻辑表示`VkDevice`。我们可以将Vulkan设备视为本质上是一组队列和内存堆。为了使用设备进行渲染，我们需要指定一个能够执行图形相关命令的队列和一个具有此类队列的物理设备。让我们探索*LightweightVK*和函数`VulkanContext::initContext()`的一些部分，该函数在后续章节中我们将讨论的许多其他事情中，检测合适的队列家族并创建一个Vulkan设备。再次提醒，这里将省略大部分错误检查：
- en: 'The first thing we do in `VulkanContext::initContext()` is print some information
    related to the physical device we have just selected earlier and the Vulkan driver.
    This is very useful for debugging:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VulkanContext::initContext()`中，我们首先打印出与我们之前选择的物理设备和Vulkan驱动程序相关的信息。这对于调试非常有用：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s enumerate and print all the extensions available on this Vulkan physical
    device, which is very helpful for debugging:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列举并打印出这个Vulkan物理设备上可用的所有扩展，这对调试非常有帮助：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before creating a Vulkan device, we need to find queue family indices and create
    queues. This code block creates one or two device queues, graphical and compute,
    based on the actual queue availability on the provided physical device. The `lvk::findQueueFamilyIndex()`
    helper function, which is implemented in `lvk/vulkan/VulkanUtils.cpp`, returns
    the first dedicated queue family index that matches the requested queue flag.
    If you look into it, you can see how it ensures you select dedicated queues first.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Vulkan设备之前，我们需要找到队列家族索引并创建队列。此代码块根据提供的物理设备上的实际队列可用性创建一个或两个设备队列，图形和计算队列。`lvk::findQueueFamilyIndex()`辅助函数，该函数在`lvk/vulkan/VulkanUtils.cpp`中实现，返回第一个匹配请求队列标志的专用队列家族索引。如果你深入研究，你可以看到它是如何确保你首先选择专用队列的。
- en: 'In Vulkan, `queueFamilyIndex` is the index of the queue family to which the
    queue belongs. A queue family is a collection of Vulkan queues with similar properties
    and functionality. Here, `deviceQueues_` is a member field holding a structure
    with queue information:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，`queueFamilyIndex`是队列所属的队列家族的索引。队列家族是一组具有相似属性和功能的Vulkan队列。在这里，`deviceQueues_`是一个成员字段，它包含一个包含队列信息的结构：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sometimes, especially on mobile GPUs, graphics and compute queues might be
    the same. Here, we take care of such corner cases:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，尤其是在移动GPU上，图形和计算队列可能是相同的。在这里，我们处理这样的边缘情况：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '5\. A list of extensions that our logical device is required to support. A
    device has to support a swapchain object, which allows us to present rendered
    frames on the screen. We use Vulkan 1.3, which contains all other necessary functionality,
    so no extra extensions are required:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 我们逻辑设备必须支持的一组扩展列表。设备必须支持swapchain对象，这允许我们在屏幕上呈现渲染的帧。我们使用包含所有其他必要功能的Vulkan
    1.3，因此不需要额外的扩展：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s request all the necessary *Vulkan 1.0*–*1.3* features we are going to
    use in our backend. The most important features are descriptor indexing from *Vulkan
    1.2* and dynamic rendering from *Vulkan 1.3*, which we will discuss in subsequent
    chapters. Take a look at the other features we are going to use.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们请求我们将在后端使用所有必要的*Vulkan 1.0*至*1.3*功能。最重要的功能是从*Vulkan 1.2*开始的描述符索引和从*Vulkan
    1.3*开始的动态渲染，我们将在后续章节中讨论。看看我们将使用的其他功能。
- en: Descriptor indexing is a set of Vulkan 1.2 features that enable applications
    to access all of their resources and select from them those with dynamic indexes
    in shaders.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符索引是一组Vulkan 1.2功能，它使应用程序能够访问它们的所有资源，并在着色器中选择具有动态索引的那些资源。
- en: Dynamic rendering is a Vulkan 1.3 feature that allows applications to render
    directly into images without needing to create render pass objects or framebuffers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 动态渲染是Vulkan 1.3的一个特性，它允许应用程序直接将图像渲染到图像中，而不需要创建渲染通道对象或帧缓冲区。
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are a few more steps before we create an actual device, such as checking
    our list of requested extensions against the list of available extensions and
    printing all the missing extensions in the log and terminating:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建实际设备之前，还有一些步骤，比如检查我们请求的扩展列表与可用扩展列表的对比，并在日志中打印所有缺失的扩展，然后终止：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we should check all the requested Vulkan features against the actual
    available features. With the help of C-macros, we can do this easily. This code
    is useful, so we have printed it here in almost its entirety:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该将所有请求的Vulkan特性与实际可用的特性进行核对。借助C宏，我们可以轻松地做到这一点。这段代码很有用，所以我们几乎将其全部打印在这里：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we are missing some Vulkan features, this code will print a nicely formatted
    list of missing features marked by a corresponding Vulkan version. This is invaluable
    for debugging and making your Vulkan backend adjustable to fit different devices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们缺少一些Vulkan特性时，这段代码将打印出一个格式良好的缺失特性列表，并用相应的Vulkan版本标记。这对于调试和使你的Vulkan后端适应不同设备非常有价值。
- en: 'Now, we are ready to create a Vulkan device, load all related Vulkan functions
    with *Volk*, and get the actual device queues based on the queue family indices
    we selected earlier in this recipe:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建Vulkan设备，使用*Volk*加载所有相关的Vulkan函数，并根据我们在本配方中之前选择的队列家族索引获取实际的设备队列：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Vulkan device is now ready to be used, but the initialization of the Vulkan
    rendering pipeline is far from complete. The next thing we need to do is create
    a swapchain object. Let’s follow the next recipe to learn how to do it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Vulkan设备已经准备好使用，但Vulkan渲染管道的初始化还远未完成。接下来我们需要做的是创建一个swapchain对象。让我们跟随下一个配方来学习如何做到这一点。
- en: Initializing a Vulkan swapchain
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化Vulkan swapchain
- en: Normally, each frame is rendered into an offscreen image. After the rendering
    process is finished, the offscreen image should be made visible or “presented.”
    A **swapchain** is an object that holds a collection of available offscreen images,
    or, more specifically, a queue of rendered images waiting to be presented on the
    screen. In OpenGL, presenting an offscreen buffer to the visible area of a window
    is performed using system-dependent functions, namely `wglSwapBuffers()` on Windows,
    `eglSwapBuffers()` on OpenGL ES-embedded systems, and `glXSwapBuffers()` on Linux
    or automatically on macOS. Vulkan gives us much more fine-grained control. We
    need to select a presentation mode for swapchain images.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每一帧都会渲染到一个离屏图像中。渲染过程完成后，离屏图像应该变得可见或“呈现”。**swapchain**是一个包含一组可用离屏图像的对象，或者更具体地说，是一个等待在屏幕上呈现的已渲染图像队列。在OpenGL中，将离屏缓冲区呈现到窗口的可视区域是通过系统依赖的函数来完成的，即Windows上的`wglSwapBuffers()`，OpenGL
    ES嵌入式系统上的`eglSwapBuffers()`，以及Linux上的`glXSwapBuffers()`或自动在macOS上。Vulkan为我们提供了更细粒度的控制。我们需要为swapchain图像选择一个呈现模式。
- en: In this recipe, we will show how to create a Vulkan swapchain object using the
    Vulkan instance and device initialized in the previous recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将展示如何使用之前配方中初始化的Vulkan实例和设备创建一个Vulkan swapchain对象。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Revisit the previous recipe, *Initializing a Vulkan instance and graphical device*,
    which discusses the initial steps necessary to initialize Vulkan. The source code
    discussed in this recipe is implemented in the class `lvk::VulkanSwapchain`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前的配方，*初始化Vulkan实例和图形设备*，它讨论了初始化Vulkan所需的初始步骤。本配方中讨论的源代码在`lvk::VulkanSwapchain`类中实现。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the previous recipe, we started learning how Vulkan instances and devices
    are created by exploring the helper function `lvk::createVulkanContextWithSwapchain()`.
    It lead us to the function `VulkanContext::initContext()`, which we discussed
    in detail in the previous recipe. Let’s continue our journey and explore `VulkanContext::initSwapchain()`
    and a related class `VulkanSwapchain` from *LightweightVK*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们通过探索辅助函数`lvk::createVulkanContextWithSwapchain()`开始学习如何创建Vulkan实例和设备。它引导我们到`VulkanContext::initContext()`函数，我们在之前的配方中对其进行了详细讨论。让我们继续我们的旅程，并探索来自*LightweightVK*的`VulkanContext::initSwapchain()`和相关类`VulkanSwapchain`：
- en: 'First, let us take a look at a function that retrieves various surface format
    support capabilities and stores them in the member fields of `VulkanContext`.
    The function checks depth format support as well, but only those depth formats
    that might be used by *LightweightVK*:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个检索各种表面格式支持能力并将它们存储在`VulkanContext`成员字段中的函数。该函数还检查深度格式支持，但仅限于可能被*LightweightVK*使用的深度格式：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All the surface capabilities and surface formats are retrieved and stored.
    First, get the number of supported formats. Then, allocate the storage to hold
    them and read the actual properties:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有表面能力和表面格式都被检索并存储。首先，获取支持的格式数量。然后，分配存储空间来保存它们并读取实际的属性：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a similar way, we store the surface present modes as well:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，我们也存储当前表面的模式：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Knowing all supported color surface formats, we can choose a suitable one for
    our swapchain. Let’s take a look at the `chooseSwapSurfaceFormat()` helper function
    on how to do it. The function takes in a list of available formats and a desired
    color space:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 知道所有支持的颜色表面格式后，我们可以为我们的交换链选择一个合适的格式。让我们看看`chooseSwapSurfaceFormat()`辅助函数是如何做到这一点的。该函数接受一个可用格式的列表和一个所需的颜色空间：
- en: First, it picks a preferred surface format, based on the desired color space
    and RGB/BGR native swapchain image format. RGB or BGR is decided by going through
    all available color formats, returned by Vulkan, and picking one format, RGB or
    BGR, whichever is closer to the beginning of the list. If BGR is encountered earlier,
    it will be the format of choice. Once the preferred image format and color space
    are selected, we can go through the list of supported formats and try to find
    an exact match.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它选择一个首选的表面格式，基于所需的颜色空间和RGB/BGR原生交换链图像格式。RGB或BGR是通过遍历Vulkan返回的所有可用颜色格式，并选择一个格式，RGB或BGR，
    whichever is closer to the beginning of the list。如果BGR出现在列表的更前面，它将成为选择的格式。一旦选择了首选的图像格式和颜色空间，我们就可以遍历支持的格式列表，并尝试找到一个完全匹配的格式。
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you cannot find both a matching format and color space, try matching only
    the format. If you cannot match the format, default to the first available format.
    On many systems, it will be `VK_FORMAT_R8G8B8A8_UNORM` or a similar format:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您找不到匹配的格式和颜色空间，尝试只匹配格式。如果无法匹配格式，则默认为第一个可用的格式。在许多系统中，它将是`VK_FORMAT_R8G8B8A8_UNORM`或类似的格式：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function is called from the constructor of `VulkanSwapchain`. Once the
    format has been selected, we need to do a few more checks before we can create
    an actual Vulkan swapchain:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从`VulkanSwapchain`的构造函数中调用。一旦选择了格式，我们还需要进行一些额外的检查，然后才能创建实际的Vulkan交换链：
- en: 'The first check is to ensure that the selected format supports presentation
    operation on the graphics queue family used to create the swapchain:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次检查是为了确保所选格式支持用于创建交换链的图形队列家族上的呈现操作：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second check is necessary to choose usage flags for swapchain images. Usage
    flags define if swapchain images can be used as color attachments, in transfer
    operations, or as storage images to allow compute shaders to operate directly
    on them. Different devices have different capabilities, and storage images are
    not always supported, especially on mobile GPUs:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二次检查是必要的，用于选择交换链图像的使用标志。使用标志定义了交换链图像是否可以用作颜色附件、在传输操作中使用，或者作为存储图像以允许计算着色器直接在它们上操作。不同的设备有不同的能力，并且存储图像并不总是被支持，尤其是在移动GPU上：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we should select the presentation mode. The preferred presentation mode
    is `VK_PRESENT_MODE_MAILBOX_KHR`, which specifies that the Vulkan presentation
    system should wait for the next vertical blanking period to update the current
    image. Visual tearing will not be observed in this case. However, this presentation
    mode is not guaranteed to be supported. In this situation, we can try picking
    `VK_PRESENT_MODE_IMMEDIATE_KHR` for the fastest frames per second without V-sync,
    or we can always fall back to `VK_PRESENT_MODE_FIFO_KHR`. The differences between
    all possible presentation mode are described in the Vulkan specification at [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该选择呈现模式。首选的呈现模式是`VK_PRESENT_MODE_MAILBOX_KHR`，它指定Vulkan呈现系统应等待下一个垂直空白期来更新当前图像。在这种情况下不会观察到视觉撕裂。然而，这个呈现模式并不保证会被支持。在这种情况下，我们可以尝试选择`VK_PRESENT_MODE_IMMEDIATE_KHR`以获得最快的帧率而不使用V-sync，或者我们可以始终回退到`VK_PRESENT_MODE_FIFO_KHR`。所有可能的呈现模式之间的区别在Vulkan规范中描述，见[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.xhtml)：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last helper function we need will choose the number of images in the swapchain
    object. It is based on the surface capabilities we retrieved earlier. Instead
    of using `minImageCount` directly, we request one additional image to make sure
    we are not waiting for the GPU to complete any operations:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的最后一个辅助函数将选择swapchain对象中的图像数量。它基于我们之前检索到的表面能力。我们不是直接使用`minImageCount`，而是请求一个额外的图像，以确保我们不会等待GPU完成任何操作：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s go back to the constructor `VulkanSwapchain::VulkanSwapchain()` and explore
    how it uses all the aforementioned helper functions to create a Vulkan swapchain
    object. The code here becomes rather short and consists only of filling in the
    `VkSwapchainCreateInfoKHR` structure:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到构造函数`VulkanSwapchain::VulkanSwapchain()`，并探索它是如何使用所有上述辅助函数来创建一个Vulkan swapchain对象的。这里的代码变得相当简短，仅包括填充`VkSwapchainCreateInfoKHR`结构体：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After the swapchain object has been created, we can retrieve swapchain images:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在swapchain对象创建后，我们可以检索swapchain图像：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The retrieved `VkImage` objects can be used to create textures and attachments.
    This topic will be discussed in the recipe *Using texture data in Vulkan* in *Chapter
    3*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 检索到的`VkImage`对象可以用来创建纹理和附件。这个主题将在第3章的食谱*在Vulkan中使用纹理数据*中讨论。
- en: Now, we have initialized Vulkan and can actually run our first application,
    *Chapter02/01_Swapchain*. In the next recipe, we will learn how to use Vulkan’s
    built-in debugging capabilities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经初始化了Vulkan，并且实际上可以运行我们的第一个应用程序，*Chapter02/01_Swapchain*。在下一个食谱中，我们将学习如何使用Vulkan的内置调试功能。
- en: Setting up Vulkan debugging capabilities
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Vulkan调试功能
- en: Once we have created a Vulkan instance, we can start tracking all possible errors
    and warnings produced by the validation layers. To do so, we use the extension
    `VK_EXT_debug_utils` to create a callback function and register it with the Vulkan
    instance. In this recipe, we will learn how to set up and use them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个Vulkan实例，我们就可以开始跟踪所有可能的错误和警告，这些错误和警告是由验证层产生的。为了做到这一点，我们使用扩展`VK_EXT_debug_utils`来创建一个回调函数，并将其注册到Vulkan实例上。在这个食谱中，我们将学习如何设置和使用它们。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please revisit the first recipe, *Initializing a Vulkan instance and graphical
    device*, for details on how to initialize Vulkan in your applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请重新查看第一个食谱，*初始化Vulkan实例和图形设备*，以了解如何在您的应用程序中初始化Vulkan的详细信息。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have to provide a callback function to Vulkan to catch the debug output.
    In *LightweightVK*, it is called `vulkanDebugCallback()`. Here’s how it can be
    passed into Vulkan to intercept logs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供一个回调函数给Vulkan以捕获调试输出。在*LightweightVK*中，它被称为`vulkanDebugCallback()`。以下是它是如何传递给Vulkan以拦截日志的：
- en: 'Let’s create a debug messenger that will pass along debug messages to an application-supplied
    callback, `vulkanDebugCallback()`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个调试消息传递器，它将调试消息传递给一个由应用程序提供的回调函数，`vulkanDebugCallback()`：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The callback itself is more elaborate and can provide information about a Vulkan
    object causing an error or warning. We do not cover tagged object allocation and
    associating used data. Some performance warnings are silenced to make the debug
    output more readable:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调本身更为详细，可以提供有关导致错误或警告的Vulkan对象的信息。我们不涵盖标记对象分配和关联使用的数据。一些性能警告被静音，以使调试输出更易于阅读：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code is sufficient to get you started with reading the validation layer
    messages and debugging your Vulkan applications. Also, please note that the destruction
    of the validation layer callbacks should be performed right before the Vulkan
    instance destruction. Check the full source code for all the details: [https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp](https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码足以让您开始阅读验证层消息并调试您的Vulkan应用程序。此外，请注意，应在销毁Vulkan实例之前立即执行验证层回调的销毁。查看完整源代码以获取所有详细信息：[https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp](https://github.com/corporateshark/lightweightvk/blob/master/lvk/vulkan/VulkanClasses.cpp)。
- en: There’s more…
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The extension `VK_EXT_debug_utils` provides you with the ability to identify
    specific Vulkan objects, using a textual name or tag to improve Vulkan object
    tracking and the debugging experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`VK_EXT_debug_utils`为您提供了使用文本名称或标签识别特定Vulkan对象的能力，以改进Vulkan对象跟踪和调试体验。
- en: 'In *LightweightVK*, we can assign a name to our `VkDevice` object:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *LightweightVK* 中，我们可以为我们的 `VkDevice` 对象分配一个名称：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This helper function is implemented in `lvk/vulkan/VulkanUtils.cpp` and looks
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助函数在 `lvk/vulkan/VulkanUtils.cpp` 中实现，如下所示：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using Vulkan command buffers
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vulkan命令缓冲区
- en: In the previous recipes, we learned how to create a Vulkan instance, a device
    for rendering, and a swapchain. In this recipe, we will learn how to manage **command
    buffers** and submit them using **command queues**, which will bring us a bit
    closer to rendering our first image with Vulkan.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们学习了如何创建Vulkan实例、用于渲染的设备以及swapchain。在本菜谱中，我们将学习如何管理**命令缓冲区**并使用**命令队列**提交它们，这将使我们更接近使用Vulkan渲染第一张图像。
- en: Vulkan command buffers are used to record Vulkan commands that can be then submitted
    to a device queue for execution. Command buffers are allocated from pools that
    allow the Vulkan implementation to amortize the cost of resource creation across
    multiple command buffers. Command pools are **externally synchronized**, which
    means one command pool should not be used between multiple threads. Let’s learn
    how to make a convenient user-friendly wrapper on top of Vulkan command buffers
    and pools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan命令缓冲区用于记录Vulkan命令，然后可以提交到设备队列以执行。命令缓冲区从允许Vulkan实现将资源创建的成本分摊到多个命令缓冲区的池中分配。命令池是**外部同步的**，这意味着一个命令池不应在多个线程之间使用。让我们学习如何在Vulkan命令缓冲区和池的上方创建一个方便的用户友好包装器。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to explore the command buffers management code from the LightweightVK
    library. Take a look at the class `VulkanImmediateCommands` from `lvk/vulkan/VulkanClasses.h`.
    In the previous edition of our book, we used very rudimentary command buffers
    management code, which did not suppose any synchronization because every frame
    was “synchronized” with `vkDeviceWaitIdle()`. Here, we are going to explore a
    more pragmatic solution with some facilities for synchronization.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索LightweightVK库中的命令缓冲区管理代码。查看 `lvk/vulkan/VulkanClasses.h` 中的 `VulkanImmediateCommands`
    类。在本书的前一版中，我们使用了非常基础的命令缓冲区管理代码，它没有假设任何同步，因为每一帧都是通过 `vkDeviceWaitIdle()` 来“同步”的。在这里，我们将探索一个更实际的解决方案，并提供一些同步功能。
- en: 'Let’s go back to our demo application from the recipe *Initializing a Vulkan
    swapchain*, which renders a black empty window, *Chapter02/01_Swapchain*. The
    main loop of the application looks as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的演示应用程序，该应用程序来自菜谱 *初始化Vulkan swapchain*，它渲染一个黑色的空窗口，*第二章/01_Swapchain*。应用程序的主循环如下所示：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we acquire a next command buffer and then submit it without writing any
    commands into it, allowing `LightweightVK` to run its swapchain presentation code
    and render a black window. Let’s dive deep into the implementation and learn how
    `lvk::VulkanImmediateCommands` does all the heavy lifting behind the scenes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取一个下一个命令缓冲区，然后提交它而不向其中写入任何命令，允许`LightweightVK`运行其swapchain展示代码并渲染一个黑色窗口。让我们深入了解实现，了解`lvk::VulkanImmediateCommands`如何在幕后完成所有繁重的工作。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we need a helper, `struct SubmitHandle`, to identify previously submitted
    command buffers. This is going to be necessary to implement synchronization when
    someone wants to schedule some work, which depends on the results of a previously
    submitted command buffer. It contains an internal ID of the submitted buffer and
    an integer ID of the submit. Handles can be converted to and from 64-bit integers
    for convenience:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个辅助结构体 `struct SubmitHandle` 来标识之前提交的命令缓冲区。这将是在有人想要安排一些工作，这些工作依赖于之前提交的命令缓冲区的结果时实现同步所必需的。它包含提交缓冲区的内部
    ID 和提交的整数 ID。句柄可以方便地转换为和从 64 位整数转换。
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another helper struct `CommandBufferWrapper` is necessary to encapsulate all
    Vulkan objects associated with one command buffer. Here, we store the originally
    allocated and the currently active command buffers. The most recent submit handle
    is associated with this command buffer. A Vulkan fence and a Vulkan semaphore
    are associated with this command buffer. The fence is used to implement GPU-CPU
    synchronization. The semaphore is necessary to ensure that command buffers are
    processed by the GPU in sequence, as `LightweightVK` enforces all the command
    buffers to be processed in the order in which they were submitted. It simplifies
    many things in terms of rendering:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个辅助结构体 `CommandBufferWrapper` 是必要的，用于封装与一个命令缓冲区相关联的所有 Vulkan 对象。在这里，我们存储最初分配的和当前活动的命令缓冲区。最近的提交句柄与这个命令缓冲区相关联。一个
    Vulkan 栅栏和一个 Vulkan 信号量与这个命令缓冲区相关联。栅栏用于实现 GPU-CPU 同步。信号量是必要的，以确保命令缓冲区按顺序由 GPU
    处理，因为 `LightweightVK` 强制所有命令缓冲区按照它们提交的顺序进行处理。这在渲染方面简化了许多事情：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let’s take a look at the interface of `lvk::VulkanImmediateCommands`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `lvk::VulkanImmediateCommands` 的接口：
- en: 'Vulkan command buffers are preallocated and used in a round-robin fashion.
    The number of command buffers that are preallocated is `kMaxCommandBuffers`. If
    we run out of buffers, `VulkanImmediateCommands` will wait until an existing command
    buffer becomes available by waiting on a fence. `64` command buffers ensure a
    non-blocking operation in most situations. The constructor takes the value of
    `queueFamilyIdx` to retrieve an appropriate Vulkan queue:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vulkan 命令缓冲区是预分配的，并以循环方式使用。预分配的命令缓冲区数量是 `kMaxCommandBuffers`。如果我们用完了缓冲区，`VulkanImmediateCommands`
    将会等待，直到一个现有的命令缓冲区通过等待栅栏变得可用。`64` 个命令缓冲区确保在大多数情况下非阻塞操作。构造函数接受 `queueFamilyIdx`
    的值以检索适当的 Vulkan 队列：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `acquire()` method returns the next available command buffer. If all command
    buffers are busy, it will wait on a fence until one command buffer becomes available.
    The `submit()` method submits a command buffer to the assigned Vulkan queue:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`acquire()` 方法返回下一个可用的命令缓冲区。如果所有命令缓冲区都忙碌，它将等待在栅栏（fence）上，直到有一个命令缓冲区变得可用。`submit()`
    方法将命令缓冲区提交到分配的 Vulkan 队列：'
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next two methods provide GPU-GPU synchronization mechanics. The first method,
    `waitSemaphore()`, makes the current command buffer wait on a given semaphore
    before running. A typical use case for this is to get an “acquire semaphore” from
    a `VulkanSwapchain` object, which waits to acquire a swapchain image, and make
    sure the command buffer will wait on it before starting to render into a swapchain
    image. The second method, `acquireLastSubmitSemaphore()`, returns and resets the
    semaphore, which is signaled when the last submitted command buffer is completed.
    This semaphore can be used by the swapchain before presentation to ensure the
    image rendering is completed:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个方法提供了 GPU-GPU 同步机制。第一个方法 `waitSemaphore()` 使得当前命令缓冲区在运行之前等待在给定的信号量上。这个方法的典型用例是从
    `VulkanSwapchain` 对象获取一个“获取信号量”，它等待获取一个交换链图像，并确保命令缓冲区在开始渲染到交换链图像之前会等待它。第二个方法 `acquireLastSubmitSemaphore()`
    返回并重置信号量，该信号量在最后一个提交的命令缓冲区完成时被触发。这个信号量可以在交换链展示之前被交换链使用，以确保图像渲染完成：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next group of methods governs GPU-CPU synchronization. As we will see later
    in this recipe, submit handles are implemented using Vulkan fences and can be
    used to wait for specific GPU operations to be completed:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的一组方法控制 GPU-CPU 同步。正如我们将在后面的食谱中看到的那样，提交句柄是通过 Vulkan 栅栏实现的，并且可以用来等待特定的 GPU
    操作完成：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The private section of the class holds all the local state, including an array
    of pre-allocated `CommandBufferWrapper` objects `buffers_`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的私有部分包含所有局部状态，包括一个预分配的 `CommandBufferWrapper` 对象数组 `buffers_`。
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `VulkanImmediateCommands` class is really central to the entire operation
    of our Vulkan backend, so let’s explore its implementation in detail, one method
    at a time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`VulkanImmediateCommands`类对于我们的整个Vulkan后端操作至关重要，因此让我们逐个详细探讨其实现，一次一个方法。'
- en: 'Let’s start with the class constructor and destructor. The constructor pre-allocates
    all command buffers. Error checking and debugging code will be skipped here in
    the text; please refer to the *LightweightVK* library source code for full details:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类构造函数和析构函数开始。构造函数预分配所有命令缓冲区。文本中省略了错误检查和调试代码；请参阅*LightweightVK*库源代码以获取完整细节：
- en: 'First, we should retrieve a Vulkan device queue and allocate a command pool.
    We use the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag to specify that
    any command buffers allocated from this pool can be individually reset to the
    initial state using the Vulkan function `vkResetCommandBuffer()`. To specify that
    command buffers allocated from this pool will be short-lived, we use the flag
    `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`, meaning that they will be reset or freed
    in a relatively short timeframe:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该检索一个Vulkan设备队列并分配一个命令池。我们使用`VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`标志来指定从这个池中分配的任何命令缓冲区都可以使用Vulkan函数`vkResetCommandBuffer()`单独重置到初始状态。为了指定从这个池中分配的命令缓冲区将是短暂的，我们使用标志`VK_COMMAND_POOL_CREATE_TRANSIENT_BIT`，这意味着它们将在相对较短的时间内重置或释放：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can pre-allocate all the command buffers from the command pool. Besides
    that, we create one semaphore and one fence per command buffer to enable our synchronization
    machinery:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从命令池中预分配所有命令缓冲区。除此之外，我们为每个命令缓冲区创建一个信号量和一个栅栏，以启用我们的同步机制：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The destructor is trivial. All we have to do is wait for all command buffers
    to be processed before destroying the command pool, fences, and semaphores:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数很简单。我们只需要在销毁命令池、栅栏和信号量之前等待所有命令缓冲区被处理：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let’s take a look at the implementation of our most important functions,
    `acquire()`. All the error-checking code is omitted again to simplify understanding:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们最重要的函数`acquire()`的实现。这里省略了所有错误检查代码以简化理解：
- en: 'Before we can find an available command buffer, we have to be sure there is
    one. This busy-wait loop checks the number of currently available command buffers
    and calls the `purge()` function, which recycles processed command buffers and
    resets them to their initial state, until we get at least one buffer available:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够找到一个可用的命令缓冲区之前，我们必须确保有一个。这个忙等待循环检查当前可用的命令缓冲区数量，并调用`purge()`函数，该函数回收已处理的命令缓冲区并将它们重置到初始状态，直到我们至少有一个缓冲区可用：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once we know there’s at least one command buffer available, we can find it by
    going through the array of all the buffers and picking the first one.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道至少有一个命令缓冲区可用，我们可以通过遍历所有缓冲区的数组并选择第一个来找到它。
- en: At this point, we decrement `numAvailableCommandBuffers`. This is to make sure
    we busy-wait properly the next time we call `acquire()`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们减少`numAvailableCommandBuffers`。这是为了确保我们下一次调用`acquire()`时正确地忙等待。
- en: 'The `isEncoding` member field is used to safeguard against the reuse of the
    currently encoded, but not yet submitted, command buffer:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`isEncoding`成员字段用于防止当前已编码但尚未提交的命令缓冲区的重复使用：'
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After we have done all the bookkeeping on the library side, we can call the
    Vulkan API to begin recording the current command buffer:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在库的这一侧完成所有账目之后，我们可以调用Vulkan API来开始记录当前的命令缓冲区：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before we explore the next series of functions, let’s take a look inside a
    short helper function, `purge()`, which was mentioned above in `acquire()`. This
    function calls `vkWaitForFences()` with a Vulkan fence and the `timeout` value
    of `0`, which returns the current status of the fence without waiting. If the
    fence is signaled, we can reset the command buffer and increment `numAvailableCommandBuffers`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们探索下一系列函数之前，让我们看看上面提到的`acquire()`中的一个简短辅助函数`purge()`。这个函数使用Vulkan栅栏和`timeout`值为`0`调用`vkWaitForFences()`，这将在不等待的情况下返回栅栏的当前状态。如果栅栏被触发，我们可以重置命令缓冲区并增加`numAvailableCommandBuffers`：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another very important function is `submit()`, which submits a command buffer
    to a queue. Let’s take a look:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的函数是`submit()`，它将命令缓冲区提交到队列。让我们看看：
- en: First, we should call `vkEndCommandBuffer()` to finish recording a command buffer.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该调用`vkEndCommandBuffer()`来完成命令缓冲区的记录。
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we should prepare semaphores. We can set two optional semaphores to be
    waited on before the GPU processes our command buffer. The first one is the semaphore
    we inject with the `waitSemaphore()` function. It can be an “acquire semaphore”
    from a swapchain or any other user-provided semaphore if we want to organize a
    frame graph of some sort. The second semaphore, `lastSubmitSemaphore_`, is the
    semaphore signaled by a previously submitted command buffer. This ensures that
    all command buffers are processed sequentially one by one:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该准备信号量。我们可以在GPU处理我们的命令缓冲区之前设置两个可选的信号量进行等待。第一个是使用`waitSemaphore()`函数注入的信号量。如果我们想组织某种类型的帧图，它可以是来自交换链的“获取信号量”或任何其他用户提供的信号量。第二个信号量，`lastSubmitSemaphore_`，是由先前提交的命令缓冲区发出的信号量。这确保了所有命令缓冲区都是顺序逐个处理的：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once we have all the data in place, a call to `vkQueueSubmit()` is trivial.
    We set `pSignalSemaphores` to the semaphore store in the current `CommandBufferWrapper`
    object so that we can wait on it in the next `submit()` call:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了所有数据，调用`vkQueueSubmit()`就变得简单。我们将`pSignalSemaphores`设置为当前`CommandBufferWrapper`对象中的信号量存储，这样我们就可以在下一个`submit()`调用中等待它：
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once the `waitSemaphore_` object is used, drop it. It should be used only with
    exactly one command buffer. The submit counter is used to set the `submitId` value
    in `SubmitHandle`. There’s one trick we can do here. `SubmitHandle` is considered
    empty when its command buffer and `submitId` are zero. One easy way to do it is
    to always skip the zero value of `submitCounter`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦使用`waitSemaphore_`对象，就丢弃它。它应该仅与一个命令缓冲区一起使用。提交计数器用于在`SubmitHandle`中设置`submitId`值。这里有一个技巧我们可以做。当命令缓冲区和`submitId`为零时，`SubmitHandle`被认为是空的。一个简单的方法是始终跳过`submitCounter`的零值：
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This code is already sufficient to organize command buffer management in an
    application. However, let’s inspect other methods of `VulkanImmediateCommands`
    that make the work with Vulkan fences much easier by hiding them behind `SubmitHandle`.
    The next most useful method is `isReady()`, which is our high-level equivalent
    of `vkWaitForFences()`, with the timeout set to `0`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码已经足够组织应用程序中的命令缓冲区管理。然而，让我们检查`VulkanImmediateCommands`的其他方法，这些方法通过在`SubmitHandle`后面隐藏它们，使得使用Vulkan栅栏的工作变得更加容易。最有用的下一个方法是`isReady()`，它是我们的高级等价于`vkWaitForFences()`，超时设置为`0`：
- en: 'First, we do a trivial check for an empty submit handle:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们进行一个简单的检查，检查提交句柄是否为空：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we inspect an actual command buffer wrapper and check if its command
    buffer has already been recycled:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查一个实际的命令缓冲区包装器，并检查其命令缓冲区是否已经被回收：
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another situation is when a command buffer has been recycled and then reused
    again. In this case, `submitId` values would be different. Only after this comparison
    can we invoke the Vulkan API to get the status of our `VkFence` object:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种情况是当命令缓冲区被回收后再次使用。在这种情况下，`submitId`值将不同。只有在这个比较之后，我们才能调用Vulkan API来获取我们的`VkFence`对象的状态：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This `isReady()` method provides a simple interface to Vulkan fences that can
    be exposed to applications using *LightweightVK*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`isReady()`方法提供了一个简单的接口，用于Vulkan栅栏，可以被使用*LightweightVK*的应用程序所使用。
- en: 'There is a pair of similar methods that allow us to wait for command buffers
    or on a specific handle or `VkFence`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有成对类似的方法允许我们等待命令缓冲区或特定的句柄或`VkFence`：
- en: 'The first one is `wait()`, which waits for a single fence to be signaled. There
    are two important things to mention here. We can detect a wait operation on a
    not-submitted command buffer using the `isEncoding_` flag. Also, we call `purge()`
    at the end of the function because we are sure there is now at least one command
    buffer to be reclaimed:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个是`wait()`，它等待单个栅栏被发出信号。这里有两点重要的事情要提一下。我们可以使用`isEncoding_`标志检测未提交命令缓冲区的等待操作。此外，我们在函数的末尾调用`purge()`，因为我们确信现在至少有一个命令缓冲区需要回收：
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The second function waits for all command buffers to be completed, which is
    handy when we want to delete all resources, for example, in the destructor. The
    implementation is straightforward, and we call `purge()` again to reclaim all
    the completed command buffers:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数等待所有命令缓冲区完成，这在我们要删除所有资源时很有用，例如在析构函数中。实现很简单，我们再次调用`purge()`来回收所有完成的命令缓冲区：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Those are all the details about the low-level implementation. Now, let’s take
    a look at how this code works with our demo application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是关于低级实现的详细信息。现在，让我们看看这段代码是如何与我们的演示应用程序一起工作的。
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let’s go all the way back to our demo application and its main loop. We call
    the function `VulkanContext::acquireCommandBuffer()`, which returns a reference
    to some high-level interface, `lvk::ICommandBuffer`. Then, we call `VulkanContext::submit()`
    to submit that command buffer:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们追溯到我们的演示应用程序及其主循环。我们调用函数 `VulkanContext::acquireCommandBuffer()`，它返回一个对某些高级接口的引用，`lvk::ICommandBuffer`。然后，我们调用
    `VulkanContext::submit()` 来提交该命令缓冲区：
- en: '[PRE65]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here’s what is going on inside those functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数内部正在发生的事情。
- en: 'The first function, `VulkanContext::acquireCommandBuffer()`, is very simple.
    It creates a `lvk::CommandBuffer` object and returns a referent to it. This object
    implements the `lvk::ICommandBuffer` interface:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个函数，`VulkanContext::acquireCommandBuffer()`，非常简单。它创建一个 `lvk::CommandBuffer`
    对象并返回对其的引用。此对象实现了 `lvk::ICommandBuffer` 接口：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The function `VulkanContext::submit()` is more elaborate. Besides submitting
    a command buffer, it takes an optional argument of a swapchain texture to be presented.
    We will skip this part here and focus only on the command buffer submission part:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `VulkanContext::submit()` 更加详细。除了提交命令缓冲区之外，它还接受一个可选的参数，即要呈现的交换链纹理。在这里我们将跳过这部分，只关注命令缓冲区提交部分：
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we inject `acquireSemaphore_` from the swapchain into the `VulkanImmediateCommands`
    object so that we wait for it to be signaled before starting rendering:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将从交换链注入 `acquireSemaphore_` 到 `VulkanImmediateCommands` 对象中，以便在开始渲染之前等待其被信号：
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we call the aforementioned `VulkanImmediateCommands::submit()` and use
    its last submit semaphore to tell the swapchain to wait until the rendering is
    completed:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用上述 `VulkanImmediateCommands::submit()` 并使用其最后一个提交信号量来告诉交换链等待渲染完成：
- en: '[PRE69]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'On every submit operation, we process so-called deferred tasks. A deferred
    task is a `std::packaged_task` that should be run only when an associated `SubmitHandle`
    (a.k.a. `VkFence`) is ready. This mechanism is very helpful to manage or deallocate
    resources and will be discussed in subsequent chapters:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次提交操作中，我们处理所谓的延迟任务。延迟任务是一个 `std::packaged_task`，它仅在关联的 `SubmitHandle`（即 `VkFence`）就绪时运行。这种机制非常有帮助于管理或释放资源，将在后续章节中讨论：
- en: '[PRE70]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, we have a working subsystem to wrangle Vulkan command buffers and expose
    `VkFence` objects to user applications in a clean and straightforward way. We
    did not cover the `ICommandBuffer` interface in this recipe, but we will do it
    shortly in this chapter while doing our first Vulkan rendering demo. Before we
    can do rendering, let’s learn how to deal with compiled SPIR-V shaders from the
    recipe *Compiling Vulkan shaders at runtime* in *Chapter 1*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个工作子系统来处理 Vulkan 命令缓冲区并以干净直接的方式向用户应用程序暴露 `VkFence` 对象。我们没有在本菜谱中涵盖 `ICommandBuffer`
    接口，但我们将在本章中简要介绍，同时进行我们的第一个 Vulkan 渲染演示。在我们能够进行渲染之前，让我们学习如何处理来自 *第1章* 中 *在运行时编译
    Vulkan 着色器* 菜单的编译好的 SPIR-V 着色器：
- en: See also…
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见…
- en: We recommend referring to *Vulkan Cookbook* by Pawel Lapinski for in-depth coverage
    of swapchain creation and command queue management.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您参考 Pawel Lapinski 的 *Vulkan 烹饪书*，以深入了解交换链创建和命令队列管理。
- en: Initializing Vulkan shader modules
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 Vulkan 着色器模块
- en: Vulkan API consumes shaders in the form of compiled SPIR-V binaries. In one
    of the previous recipes in *Chapter 1*, *Compiling Vulkan shaders at runtime*,
    we learned how to compile shaders from GLSL source code to SPIR-V, using the open-source
    `glslang` compiler from Khronos. In this recipe, we will learn how to use GLSL
    shaders and precompiled binaries in Vulkan.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 以编译好的 SPIR-V 二进制文件的形式消耗着色器。在 *第1章* 中的一个先前菜谱 *在运行时编译 Vulkan 着色器* 中，我们学习了如何使用
    Khronos 的开源 `glslang` 编译器将 GLSL 着色器从源代码编译成 SPIR-V。在本菜谱中，我们将学习如何在 Vulkan 中使用 GLSL
    着色器和预编译的二进制文件。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: We recommend reading the recipe *Compiling Vulkan shaders at runtime* from *Chapter
    1* before you proceed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们建议您阅读 *第1章* 中的 *在运行时编译 Vulkan 着色器* 菜单。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s take a look at our next demo application, `Chapter02/02_HelloTriangle`,
    to learn the high-level *LightweightVK* API for shader modules. As we will see,
    there’s a `createShaderModule()` method in `IContext` that does the work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的下一个演示应用程序，`Chapter02/02_HelloTriangle`，以了解着色器模块的高级 *LightweightVK* API。正如我们将看到的，在
    `IContext` 中有一个 `createShaderModule()` 方法来完成这项工作：
- en: 'Given a pointer to `IContext`, Vulkan shader modules can be created from GLSL
    shaders in the following way, where `codeVS` and `codeFS` are null-terminated
    strings holding the vertex and fragment shader source code, respectively. Note
    that these values are used to initialize a structure passed into `createShaderModule()`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`IContext`的指针，可以通过以下方式从GLSL着色器创建Vulkan着色器模块，其中`codeVS`和`codeFS`是空终止字符串，分别持有顶点和片段着色器源代码。请注意，这些值用于初始化传递给`createShaderModule()`的结构体：
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The first parameter of `createShaderModule()` is a structure, `ShaderModuleDesc`,
    containing all the properties required to create a Vulkan shader module. If the
    `dataSize` member field is non-zero, the `data` field is treated as a binary SPIR-V
    blob. If `dataSize` is zero, `data` is treated as a null-terminated string containing
    GLSL source code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createShaderModule()`的第一个参数是一个结构体，名为`ShaderModuleDesc`，它包含创建Vulkan着色器模块所需的所有属性。如果`dataSize`成员字段非零，则`data`字段被视为二进制SPIR-V
    blob。如果`dataSize`为零，则`data`被视为包含GLSL源代码的空终止字符串：'
- en: '[PRE72]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Inside `VulkanContext::createShaderModule()`, we do the branching for textual
    GLSL and binary SPIR-V shaders. An actual `VkShaderModule` object is stored in
    a pool, which we will discuss in subsequent chapters:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VulkanContext::createShaderModule()`内部，我们对文本GLSL和二进制SPIR-V着色器进行分支。实际的`VkShaderModule`对象存储在一个池中，我们将在随后的章节中讨论：
- en: '[PRE73]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The creation of a Vulkan shader module from a binary SPIR-V blob looks as follows.
    Error checking is omitted for simplicity:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从二进制SPIR-V blob创建Vulkan着色器模块的过程如下。为了简单起见，省略了错误检查：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, Vulkan shader modules are ready to be used inside Vulkan pipelines. Let’s
    learn how to do so in the next recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Vulkan着色器模块已准备好在Vulkan管道中使用。让我们在下一个菜谱中学习如何这样做。
- en: Initializing Vulkan pipelines
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化Vulkan管道
- en: A Vulkan pipeline is an implementation of an abstract graphics pipeline, which
    is a sequence of operations to transform vertices and rasterize the resulting
    image. In essence, the idea is similar to a single snapshot of a “frozen” OpenGL
    state. Vulkan pipelines are mostly immutable, which means multiple Vulkan pipelines
    should be created to allow different data paths through the graphics pipeline.
    In this recipe, we will learn how to create a Vulkan pipeline suitable to render
    a colorful triangle, and we will explore how low-level and verbose Vulkan can
    be wrapped into a simple high-level interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan管道是抽象图形管道的实现，它是一系列操作，用于转换顶点并光栅化生成的图像。本质上，这个想法与“冻结”的OpenGL状态的单一快照类似。Vulkan管道基本上是不可变的，这意味着应该创建多个Vulkan管道以允许不同的数据路径通过图形管道。在这个菜谱中，我们将学习如何创建一个适合渲染彩色三角形的Vulkan管道，并探索如何将低级和冗长的Vulkan封装到简单的通用接口中。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get all the basic information about Vulkan pipelines, we recommend reading
    *Vulkan Cookbook* by Pawel Lapinski, which was published by Packt, or the *Vulkan
    Tutorial* series by Alexander Overvoorde: [https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关Vulkan管道的所有基本信息，我们建议阅读Pawel Lapinski的*Vulkan Cookbook*，由Packt出版，或者Alexander
    Overvoorde的*Vulkan Tutorial*系列：[https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction](https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction)。
- en: For additional information on descriptor set layouts, check out the chapter
    at [https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer](https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关描述符集布局的更多信息，请查看[https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer](https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer)章节。
- en: Vulkan pipelines require Vulkan shader modules. Check out the previous recipe,
    *Initializing Vulkan shader modules*, before going through this recipe.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan管道需要Vulkan着色器模块。在进入这个菜谱之前，请查看之前的菜谱，*初始化Vulkan着色器模块*。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us dive deep into how to create and configure a Vulkan pipeline suitable
    for our application. Due to the extreme verbosity of Vulkan API, this recipe will
    be the longest. We will start from the high-level code in our demo application,
    `Chapter02/02_HelloTriangle`, and go all the way to the internals of *LightweightVK*.
    In the subsequent chapters, we will go into more detail, such as dynamic states,
    multisampling, vertex input, and others.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何创建和配置适合我们应用程序的Vulkan管道。由于Vulkan API的极端冗长，这个菜谱将是最长的。我们将从我们的演示应用程序中的高级代码开始，即`Chapter02/02_HelloTriangle`，然后深入到*LightweightVK*的内部。在随后的章节中，我们将更详细地介绍，例如动态状态、多采样、顶点输入等。
- en: 'Let’s take a look at the initialization and main loop of `Chapter02/02_HelloTriangle`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Chapter02/02_HelloTriangle` 的初始化和主循环：
- en: 'First, we create a Vulkan context, as described in the previous recipes:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 Vulkan 上下文，如前几道菜谱中所述：
- en: '[PRE75]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we need to create a rendering pipeline. *LightweightVK* uses opaque handles
    to work with resources, so here, `lvk::RenderPipelineHandle` is an opaque handle
    that manages a collection of `VkPipeline` objects, and `lvk::Holder` is an RAII
    wrapper to automatically dispose of handles that go out of scope. The method `createRenderPipeline()`
    accepts a structure, `RenderPipelineDesc`, that contains data necessary to configure
    a rendering pipeline. For our first triangle demo, we want to be as minimalistic
    as possible, so we set vertex and fragment shaders and define the format of a
    color attachment. This is the absolute minimum we need to render something into
    a swapchain image:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个渲染管线。*LightweightVK* 使用不透明的句柄来处理资源，因此在这里，`lvk::RenderPipelineHandle`
    是一个不透明的句柄，它管理着一组 `VkPipeline` 对象，而 `lvk::Holder` 是一个 RAII 包装器，用于自动处理超出作用域的句柄。`createRenderPipeline()`
    方法接受一个结构体，`RenderPipelineDesc`，它包含配置渲染管线所需的数据。对于我们的第一个三角形演示，我们希望尽可能简约，因此我们设置了顶点和片段着色器，并定义了颜色附加的格式。这是我们渲染到交换链图像所需的最小数据集：
- en: '[PRE76]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Inside the main loop, we acquire a command buffer, as described in the recipe
    *Using Vulkan command buffers*, and issue some drawing commands:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环内部，我们获取一个命令缓冲区，如 *使用 Vulkan 命令缓冲区* 菜谱中所述，并发出一些绘图命令：
- en: '[PRE77]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The member function `cmdBeginRendering()` wraps the Vulkan 1.3 dynamic rendering
    functionality, which enables rendering directly into Vulkan images without explicitly
    creating any render passes or framebuffer objects. It takes a description of a
    render pass, `lvk::RenderPass`, and a description of a framebuffer, `lvk::Framebuffer`.
    We will explore it in more detail in subsequent chapters. Here, we use the current
    swapchain texture as the first color attachment and clear it to while color before
    rendering, using the attachment load operation `LoadOp_Clear`, which corresponds
    to `VK_ATTACHMENT_LOAD_OP_CLEAR` in Vulkan. The store operation is set to `StoreOp_Store`
    by default:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员函数 `cmdBeginRendering()` 包装了 Vulkan 1.3 的动态渲染功能，它允许直接将渲染输出到 Vulkan 图像，而不需要显式创建任何渲染通道或帧缓冲区对象。它接受一个渲染通道的描述，`lvk::RenderPass`，和一个帧缓冲区的描述，`lvk::Framebuffer`。我们将在后续章节中更详细地探讨它。在这里，我们使用当前交换链纹理作为第一个颜色附加，并在渲染前将其清除为白色，使用附加加载操作
    `LoadOp_Clear`，这对应于 Vulkan 中的 `VK_ATTACHMENT_LOAD_OP_CLEAR`。存储操作默认设置为 `StoreOp_Store`：
- en: '[PRE78]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The render pipeline can be bound to the command buffer in one line. Then, we
    can issue a drawing command, `cmdDraw()`, which is a wrapper on top of `vkCmdDraw()`.
    You may have noticed that we did not use any index or vertex buffers at all. We
    will see why in a moment when we look at GLSL shaders. The command `cmdEndRendering()`
    corresponds to `vkCmdEndRendering()` from Vulkan 1.3:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在一行中将渲染管线绑定到命令缓冲区。然后，我们可以发出一个绘图命令，`cmdDraw()`，这是 `vkCmdDraw()` 之上的包装器。你可能已经注意到我们没有使用任何索引或顶点缓冲区。当我们查看
    GLSL 着色器时，我们将会看到原因。命令 `cmdEndRendering()` 对应于 Vulkan 1.3 中的 `vkCmdEndRendering()`：
- en: '[PRE79]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let’s take a look at the GLSL shaders:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 GLSL 着色器：
- en: 'As we do not provide any vertex input, the vertex shader has to generate vertex
    data for a triangle. We use the built-in variable `gl_VertexIndex`, which gets
    incremented automatically for every subsequent vertex, returning hardcoded values
    for positions and vertex colors:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有提供任何顶点输入，顶点着色器必须为三角形生成顶点数据。我们使用内置变量 `gl_VertexIndex`，它为每个后续顶点自动递增，并返回硬编码的位置和顶点颜色值：
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The fragment shader is trivial and just outputs the interpolated color:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器很简单，只是输出插值后的颜色：
- en: '[PRE81]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The application should render a colorful triangle, as shown in the following
    figure.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该渲染一个彩色三角形，如图所示。
- en: '![Figure 2.2: Hello triangle](img/file12.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：你好，三角形](img/file12.png)'
- en: 'Figure 2.2: Hello triangle'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：你好，三角形
- en: We learned how to draw a triangle with Vulkan using *LightweightVK*. It is time
    to look under the hood and find out how this high-level render pipeline management
    interface is implemented via Vulkan.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 *LightweightVK* 使用 Vulkan 绘制三角形。现在是时候揭开盖子，看看这个高级渲染管线管理接口是如何通过 Vulkan
    实现的。
- en: How it works…
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To explore the underlying Vulkan implementation, we have to peel back a few
    layers one by one. When we want to create a graphics pipeline in our application,
    we call the member function `IContext::createRenderPipeline()`, which is implemented
    in `VulkanContext`. This function takes in a structure, `lvk::RenderPipelineDesc`,
    which describes our rendering pipeline. Let’s take a closer look at it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索底层的 Vulkan 实现，我们必须一层层地剥开。当我们想在应用程序中创建图形管道时，我们调用成员函数 `IContext::createRenderPipeline()`，该函数在
    `VulkanContext` 中实现。这个函数接收一个结构体，`lvk::RenderPipelineDesc`，它描述了我们的渲染管道。让我们更仔细地看看它。
- en: 'The structure contains a subset of information necessary to create a valid
    graphics `VkPipeline` object:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该结构体包含创建有效的图形 `VkPipeline` 对象所需的信息子集：
- en: '[PRE82]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The maximum number of color attachments is set to `4`. We do not store the
    number of used attachments here. Instead, we use a helper function to calculate
    how many attachments we actually have:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 颜色附件的最大数量设置为 `4`。我们在这里不存储使用的附件数量。相反，我们使用一个辅助函数来计算我们实际上有多少个附件：
- en: '[PRE83]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Other member fields represent a typical rendering state with a cull mode, face
    winding, polygon mode, and so on.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他成员字段代表一个典型的渲染状态，包括剔除模式、面顺时针方向、多边形模式等。
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When we call `VulkanContext::createRenderPipeline()`, all it does is do some
    sanity checks on `RenderPipelineDesc` and store all the values in the `RenderPipelineState`
    struct. As we already mentioned, *LightweightVK* pipelines cannot be directly
    one-to-one mapped to `VkPipeline` objects. The reason for this is that `RenderPipelineDesc`
    provides a more dynamic state than un-extended Vulkan 1.3 can support. For example,
    *LightweightVK* manages descriptor set layouts automatically. Vulkan requires
    a descriptor set layout to be specified for a pipeline object. To lift this limitation,
    the data stored in `RenderPipelineState` is used to lazily create actual `VkPipeline`
    objects in a function, `VulkanContext::getVkPipeline()`. Let’s take a look at
    this mechanism. Error checking and some unimportant details are omitted to simplify
    understanding:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `VulkanContext::createRenderPipeline()` 时，它所做的只是对 `RenderPipelineDesc`
    进行一些合理性检查，并将所有值存储在 `RenderPipelineState` 结构体中。正如我们之前提到的，*LightweightVK* 管道不能直接一对一映射到
    `VkPipeline` 对象。这样做的原因是 `RenderPipelineDesc` 提供的状态比未扩展的 Vulkan 1.3 支持的更动态。例如，*LightweightVK*
    自动管理描述符集布局。Vulkan 需要为管道对象指定一个描述符集布局。为了克服这个限制，存储在 `RenderPipelineState` 中的数据用于在函数
    `VulkanContext::getVkPipeline()` 中延迟创建实际的 `VkPipeline` 对象。让我们看看这个机制。为了简化理解，省略了错误检查和一些不重要的细节：
- en: 'The constructor requires `VulkanContext` and `RenderPipelineDesc`. It does
    some preparation work but does not create actual `VkPipeline` objects. We will
    look into its implementation shortly:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数需要 `VulkanContext` 和 `RenderPipelineDesc`。它做一些准备工作但不会创建实际的 `VkPipeline`
    对象。我们很快就会查看其实现：
- en: '[PRE85]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Pre-cache some useful values so that we do not reinitialize them every time
    we create a new Vulkan pipeline object:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预缓存一些有用的值，这样我们就不必每次创建新的 Vulkan 管道对象时都重新初始化它们：
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With all data structures in place, we are now ready to go through the implementation
    code of `VulkanContext::createRenderPipeline()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有数据结构就绪后，我们现在可以查看 `VulkanContext::createRenderPipeline()` 的实现代码：
- en: 'The constructor iterates over vertex input attributes and pre-caches all necessary
    data into Vulkan structures for further use:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数遍历顶点输入属性，并将所有必要的数据预先缓存到 Vulkan 结构体中，以供后续使用：
- en: '[PRE87]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Iterate and cache the vertex input bindings and attributes. Vertex buffer bindings
    are tracked in `bufferAlreadyBound`. Everything else is very trivial conversion
    code from our high-level data structures to Vulkan:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历并缓存顶点输入绑定和属性。顶点缓冲区绑定在 `bufferAlreadyBound` 中跟踪。其他一切都是从我们的高级数据结构到 Vulkan 的非常简单的转换代码：
- en: '[PRE88]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we can create actual Vulkan pipelines. Well, almost. A couple of very
    long code snippets await us. These are the longest functions in the entire book,
    but we have to go through them at least once. That said, error checking is skipped
    to simplify things a bit:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建实际的 Vulkan 管道。嗯，几乎是这样。一些非常长的代码片段在等待我们。这些是整本书中最长的函数，但我们至少要过一遍。话虽如此，错误检查被省略以简化事情：
- en: 'The `getVkPipeline()` function retrieves a `RenderPipelineState` struct associated
    with a provided pipeline handle:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getVkPipeline()` 函数检索与提供的管道句柄关联的 `RenderPipelineState` 结构体：'
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we check if a descriptor set layout used to create a pipeline layout
    for this `VkPipeline` object has changed. Our implementation uses descriptor indexing
    to manage all textures in a huge descriptor set and creates a descriptor set layout
    to store all the textures. Once new textures are loaded, there might not be enough
    space to store them, and a new descriptor set layout would have to be created.
    Every time this happens, we have to delete the old `VkPipeline` and `VkPipelineLayout`
    objects and create new ones:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查用于为这个`VkPipeline`对象创建管线布局的描述符集布局是否已更改。我们的实现使用描述符索引来管理一个巨大的描述符集中的所有纹理，并创建一个描述符集布局来存储所有纹理。一旦新纹理被加载，可能没有足够的空间来存储它们，就必须创建一个新的描述符集布局。每次发生这种情况时，我们必须删除旧的`VkPipeline`和`VkPipelineLayout`对象，并创建新的：
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If there is already a valid graphics pipeline compatible with the current descriptor
    set layout, we can just return it:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经存在一个与当前描述符集布局兼容的有效图形管线，我们只需返回它：
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let’s prepare to build a new Vulkan pipeline object. Not all color attachments
    are valid. We need to create color blend attachments only for active color attachments.
    Helper functions, such as `formatToVkFormat()`, convert *LightweightVK* enumerations
    to Vulkan:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们准备构建一个新的Vulkan管线对象。并非所有颜色附件都是有效的。我们只需要为活动的颜色附件创建颜色混合附件。辅助函数，如`formatToVkFormat()`，将*LightweightVK*枚举转换为Vulkan：
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Setting up blending states for color attachments is tedious but very simple:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置颜色附件的混合状态既繁琐又简单：
- en: '[PRE93]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Retrieve `VkShaderModule` objects from the pool using opaque handles. We will
    discuss how pools work in the next chapters. Here, all we have to know is that
    they allow fast conversion of an integer handle into the actual data associated
    with it. The geometry shader is optional:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不透明的句柄从池中检索`VkShaderModule`对象。我们将在下一章讨论池的工作原理。在这里，我们只需要知道它们允许快速将整数句柄转换为与之关联的实际数据。几何着色器是可选的：
- en: '[PRE94]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Prepare a `VkSpecializationInfo` structure to describe specialization constants
    for this graphics pipeline:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个`VkSpecializationInfo`结构来描述此图形管线的专用常量：
- en: '[PRE95]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a suitable `VkPipelineLayout` object for this pipeline. Use the current
    descriptor set layout stored in `VulkanContext`. Here, one descriptor set layout,
    `vkDSL_`, is duplicated multiple times to create a pipeline layout. This is necessary
    to ensure compatibility with MoltenVK, which does not allow the aliasing of different
    descriptor types. Push constant sizes are retrieved from precompiled shader modules:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此管线创建一个合适的`VkPipelineLayout`对象。使用存储在`VulkanContext`中的当前描述符集布局。在这里，一个描述符集布局`vkDSL_`被复制多次以创建管线布局。这是必要的，以确保与MoltenVK的兼容性，MoltenVK不允许不同描述符类型的别名。推送常量大小从预编译的着色器模块中检索：
- en: '[PRE96]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here’s a snippet to retrieve push constant sizes from shader modules:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个片段，用于从着色器模块中检索推送常量大小：
- en: '[PRE97]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'As we peel back more and more implementation layers, here is yet another level
    to peel. However, it is the last one. For convenience, the creation of actual
    `VkPipeline` objects is encapsulated into `VulkanPipelineBuilder`, which provides
    reasonable default values for all the numerous Vulkan data members that we do
    not want to set. Those familiar with Java will recognize some form of a typical
    *Builder* design pattern:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们逐步剥离更多的实现层，这里还有另一个层级可以剥离。然而，这是最后一个层级。为了方便起见，实际`VkPipeline`对象的创建被封装进`VulkanPipelineBuilder`中，它为所有我们不希望设置的众多Vulkan数据成员提供了合理的默认值。熟悉Java的人会认出一种典型的*Builder*设计模式：
- en: '[PRE98]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Shader modules are provided one by one. Only a vertex and a fragment shader
    are mandatory:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器模块逐个提供。只有顶点和片段着色器是必需的：
- en: '[PRE99]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Finally, we call the `VulkanPipelineBuilder::build()` method, which creates
    a `VkPipeline` object that we can store in our `RenderPipelineState` structure,
    together with the pipeline layout:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`VulkanPipelineBuilder::build()`方法，该方法创建一个`VkPipeline`对象，我们可以将其存储在我们的`RenderPipelineState`结构中，连同管线布局一起：
- en: '[PRE100]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The last method we want to explore here is `VulkanPipelineBuilder::build()`,
    which is pure Vulkan. Let’s take a look at it to conclude the pipeline creation
    process:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想要探索的最后一个方法是`VulkanPipelineBuilder::build()`，这是纯Vulkan。让我们看看它以总结管线创建过程：
- en: 'First, we put the provided dynamic states into `VkPipelineDynamicStateCreateInfo`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将提供的动态状态放入`VkPipelineDynamicStateCreateInfo`：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The Vulkan specifications say that the viewport and scissor can be `nullptr`
    if the viewport and scissor states are dynamic. We are definitely happy to make
    the most of this opportunity:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vulkan规范说明，如果视口和裁剪状态是动态的，则视口和裁剪可以设置为`nullptr`。我们当然很高兴充分利用这个机会：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Use the color blend states and attachments that we prepared earlier in this
    recipe:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在本菜谱中准备的颜色混合状态和附件：
- en: '[PRE103]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Put everything together into `VkGraphicsPipelineCreateInfo` and call `vkCreateGraphicsPipelines()`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容组合到`VkGraphicsPipelineCreateInfo`中，并调用`vkCreateGraphicsPipelines()`：
- en: '[PRE104]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This code concludes the pipeline creation process. Besides the very simple example,
    `Chapter02/02_HelloTriangle`, we created a slightly more elaborate app to demonstrate
    how to use multiple render pipelines, rendering a rotating cube with a wireframe
    overlay that uses the GLM library for matrix math. Check it out in `Chapter02/03_GLM`,
    and see how it uses `cmdPushConstants()` to animate the cube. It should look like
    the following screenshot.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完成了管道创建过程。除了非常简单的示例`Chapter02/02_HelloTriangle`之外，我们还创建了一个稍微复杂一些的应用程序，以展示如何使用多个渲染管道，通过使用GLM库进行矩阵数学，渲染一个带有线框覆盖的旋转立方体。在`Chapter02/03_GLM`中查看它，看看它是如何使用`cmdPushConstants()`来动画化立方体的。它应该看起来像下面的截图。
- en: '![Figure 2.3: GLM usage example](img/file13.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：GLM使用示例](img/file13.png)'
- en: 'Figure 2.3: GLM usage example'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：GLM使用示例
- en: There’s more…
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you are familiar with older versions of Vulkan, you might have noticed that
    in this recipe, we completely left out any references to render passes. They are
    also not mentioned in any of the data structures. The reason for this is that
    we use Vulkan 1.3’s dynamic rendering functionality, which allows `VkPipeline`
    objects to not require a render pass.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Vulkan的旧版本，你可能会注意到，在这个菜谱中，我们完全省略了任何关于渲染通道的引用。它们也没有在任何数据结构中提及。这样做的原因是我们使用了Vulkan
    1.3的动态渲染功能，这使得`VkPipeline`对象不需要渲染通道。
- en: If you want to implement a similar wrapper for older versions of Vulkan without
    using the *VK_KHR_dynamic_rendering* extension, you can maintain a “global” collection
    of render passes in an array inside `VulkanContext` and add an integer index of
    a corresponding render pass as a data member to `RenderPipelineDynamicState`.
    Since we can use only a very restricted number of distinct rendering passes—let’s
    say a maximum of 256—the index can be saved as `uint8_t`. This would enable the
    hash key to remain within the `uint32_t` size.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在没有使用`*VK_KHR_dynamic_rendering*`扩展的情况下为Vulkan的旧版本实现类似的包装器，你可以在`VulkanContext`内部数组的“全局”渲染通道集合中维护一个渲染通道的整数索引，并将相应的渲染通道的整数索引作为一个数据成员添加到`RenderPipelineDynamicState`中。由于我们只能使用非常有限数量的不同渲染通道——比如说最多256个——索引可以保存为`uint8_t`。这将使哈希键保持在`uint32_t`大小内。
- en: If you want to explore an actual working implementation of this approach, take
    a look at Meta’s IGL library at [https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h](https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h),
    and check out how `renderPassIndex` is handled there.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索这个方法的实际工作实现，请查看Meta的IGL库在[https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h](https://github.com/facebook/igl/blob/main/src/igl/vulkan/RenderPipelineState.h)，并查看那里是如何处理`renderPassIndex`的。
- en: Now, let’s jump to the next chapter, *Working with Vulkan objects*, to learn
    how to use Vulkan in a user-friendly way to build more interesting examples.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到下一章，*与Vulkan对象一起工作*，学习如何以用户友好的方式使用Vulkan构建更有趣的示例。
