- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Writing Generic Containers with Allocator Support
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分配器支持编写泛型容器
- en: We have come a long way since the beginning of this book. Recent chapters examined
    how one can write memory-efficient containers, describing how to do so when memory
    management is done explicitly (in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172))
    and when it is done implicitly, through smart pointers (in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)).
    Choosing a memory management approach is not an either/or proposition; each one
    is useful in its own way and solves real-life use cases depending on one’s application
    domain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自本书开始以来，我们已经走得很远了。最近几章探讨了如何编写内存高效的容器，描述了在显式进行内存管理时（在[*第 12 章*](B21071_12.xhtml#_idTextAnchor172)）以及通过智能指针隐式进行内存管理时（在[*第
    13 章*](B21071_13.xhtml#_idTextAnchor187)）如何做到这一点。选择内存管理方法不是非此即彼的问题；每种方法都有其自身的用途，并解决根据应用领域而定的实际用例。
- en: However, none of the approaches we have covered so far match what standard library
    containers do. Indeed, standard library containers (as well as many other standard
    library types that can dynamically allocate memory) are `std::vector` whose memory
    comes from an arena (see [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153)) or
    from a fixed-capacity buffer on the stack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们之前所介绍的所有方法都不符合标准库容器的做法。实际上，标准库容器（以及许多其他可以动态分配内存的标准库类型）都是来自一个区域（参见[*第 10
    章*](B21071_10.xhtml#_idTextAnchor153)）或来自堆栈上的固定容量缓冲区的 `std::vector`。
- en: Allocators officially came to the C++ language, along with the standard library
    containers, in C++98, but they evolved and diversified themselves over time. Writing
    an allocator became significantly simpler with C++11, and C++17 introduced an
    entirely new approach to memory allocation with **polymorphic memory resource**
    (**PMR**) allocators and containers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器在 C++98 中随着标准库容器一起正式成为 C++ 语言的一部分，但它们随着时间的推移而发展和多样化。使用 C++11，编写分配器变得显著简单，而
    C++17 通过引入具有 **多态内存资源**（**PMR**）分配器和容器的全新内存分配方法。
- en: 'In this chapter, you will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将执行以下操作：
- en: Understand and use traditional allocators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用传统分配器
- en: Write a traditional allocator for a specialized application domain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定应用领域编写传统分配器
- en: Learn how to manage the allocator lifetime when a container is moved or copied
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在容器移动或复制时管理分配器的生命周期
- en: Clone an allocator’s type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆分配器的类型
- en: Understand and use PMR allocators and containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用 PMR 分配器和容器
- en: Equipped with a knowledge of allocators and how they interact with containers,
    this chapter will enrich your memory management toolbox and open up new ways to
    combine data organization with the way storage is obtained. Understanding allocators
    might even make writing new containers less of a necessity; sometimes, instead
    of trying to create an entirely new container, the solution is just a matter of
    combining the right data organization strategy with the right storage management
    approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有分配器和它们如何与容器交互的知识，本章将丰富您的内存管理工具箱，并开辟将数据组织与存储获取方式相结合的新途径。理解分配器甚至可能使编写新容器变得不那么必要；有时，与其尝试创建一个全新的容器，不如将合适的数据组织策略与合适的存储管理方法结合起来。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本书中该章节的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter14).
- en: A word about the examples in this chapter
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章示例的一些建议
- en: As was the case with [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187), this
    chapter will show incomplete examples to avoid redundancy with the excerpts found
    earlier, particularly those in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172).
    Allocators change the way in which containers interact with memory management
    facilities, but they do not require rewriting containers entirely, so a lot of
    code written for a given container remains stable regardless of how memory is
    managed. The code you will find in the GitHub repository is, of course, complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与[*第 13 章*](B21071_13.xhtml#_idTextAnchor187)的情况一样，本章将展示不完整的示例，以避免与之前找到的摘录重复，尤其是那些在[*第
    12 章*](B21071_12.xhtml#_idTextAnchor172)中的。分配器改变了容器与内存管理设施交互的方式，但它们不需要完全重写容器，因此为给定容器编写的代码在内存管理方式如何的情况下仍然保持稳定。您在
    GitHub 仓库中找到的代码当然是完整的。
- en: Also note that this chapter discusses allocators in the context of containers,
    but the idea can be extended to many types that need to dynamically allocate memory.
    It is sometimes difficult to do so; for example, support for allocators in `std::function`
    was removed in C++17 as no known standard library implementation had managed to
    make it work. Still, allocators can be seen as a general idea, not something that
    is limited to containers, and you can envision using allocators in other contexts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，本章在容器的背景下讨论分配器，但这一想法可以扩展到许多需要动态分配内存的类型。有时这样做很困难；例如，C++17中移除了`std::function`中的分配器支持，因为没有任何已知的标准库实现能够使其工作。尽管如此，分配器可以被视为一个通用概念，而不仅仅是局限于容器，您可以在其他上下文中设想使用分配器。
- en: Why allocators?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要分配器？
- en: Allocators tend to scare people, including some experts, but you will not be
    scared as you are already in possession of significant memory management knowledge
    and skills (and you are probably curious to know more about the topic given the
    fact that you are reading this book). Knowing this, the first question we need
    to address, before even expressing what an allocator is, is “Why do allocators
    exist?”. Why would we concern ourselves with an additional layer of complexity
    in our memory management code?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器往往会让人感到害怕，包括一些专家在内，但您不会感到害怕，因为您已经掌握了大量的内存管理知识和技能（鉴于您正在阅读这本书，您可能对这一主题有更多的好奇心）。了解这一点后，我们首先需要解决的问题，甚至在表达分配器是什么之前，就是“为什么分配器存在？”。我们为什么要关心内存管理代码中额外的复杂性层次？
- en: 'Well, this is C++, and C++ is all about giving users *control*, so that’s where
    our explanation begins. To make an analogy, think about iterators: why they are
    useful, and how they make your life as a programmer better. They decouple iterating
    over elements of a sequence from how the elements are organized in that sequence,
    such that you can write code that computes something such as the sum of the values
    in `std::list<int>` or `std::vector<short>` without having to know that in the
    first case, you are navigating through nodes linked to one another by pointers
    and in the second case, you are iterating through objects stored in contiguous
    memory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是C++，C++的一切都是关于给用户提供*控制*，所以我们的解释从这里开始。为了做一个类比，想想迭代器：为什么它们有用，以及它们如何使程序员的编程生活变得更好。它们将遍历序列元素的方式与元素在序列中的组织方式解耦，这样您就可以编写代码来计算诸如`std::list<int>`或`std::vector<short>`中值的总和，而无需知道在第一种情况下，您正在通过指针相互链接的节点进行导航，在第二种情况下，您正在遍历存储在连续内存中的对象。
- en: The beauty of iterators is this decoupling between iteration and data organization.
    Similarly, allocators decouple data organization from the way the underlying storage
    is obtained or freed. This allows us to reason about the properties of containers
    independently from the properties of memory management and makes containers useful
    in even more situations than they would otherwise be.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的美妙之处在于迭代和数据组织之间的解耦。同样，分配器将数据组织与底层存储的获取或释放方式解耦。这使得我们可以独立于内存管理的属性来推理容器的属性，从而使容器在更多情况下变得有用。
- en: A very, very thin layer…
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 非常，非常薄的一层…
- en: To a container, an allocator (at least those in the “traditional” model that
    we are about to discuss) represents a thin (*very* thin) layer of abstraction
    over the hardware. To a container, an allocator expresses such things as “What
    is an address?”, “How does one put an object somewhere?”, “How does one destroy
    an object at some location?”, and so on. In a way, for a container, the allocator
    essentially *is* the hardware.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器来说，分配器（至少是我们即将讨论的“传统”模型中的那些）代表了对硬件的薄薄（非常薄）一层抽象。对于容器来说，分配器表达了诸如“地址是什么？”，“如何将对象放在某个地方？”，“如何销毁某个位置的对象？”等问题。从某种意义上说，对于容器来说，分配器本质上就是硬件。
- en: Traditional allocators
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统分配器
- en: As mentioned already, allocators have been a mainstay of C++ for decades now,
    but they have existed in a few different guises and shapes. In this chapter, we
    will adopt a sort of chronological approach, starting from the earlier (and more
    complicated) allocator types and progressing toward the simpler (and more versatile)
    ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，分配器已经成为了C++几十年的支柱，但它们以几种不同的形式和形状存在。在本章中，我们将采用一种类似时间顺序的方法，从较早（更复杂）的分配器类型开始，逐步过渡到更简单（更灵活）的类型。
- en: To understand this chapter, one key idea to keep in mind is that a container
    type such as `std::vector<T>` does not really exist. What does exist is the `std::vector<T,A>`
    type where, by default, `A` is `std::allocator<T>`, which allocates through `::operator new()`
    and deallocates through `::operator delete()`. By **traditional allocator**, we
    mean an allocator type that is part of the type of a container (this is not the
    only possible approach to writing allocators today, as we will see when we discuss
    PMR allocators later in this chapter).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一章，一个关键的想法是记住，容器类型如 `std::vector<T>` 并不存在。真正存在的是 `std::vector<T,A>` 类型，其中默认情况下
    `A` 是 `std::allocator<T>`，它通过 `::operator new()` 分配内存，通过 `::operator delete()`
    释放内存。我们所说的 **传统分配器** 指的是容器类型的一部分的分配器类型（这并不是今天编写分配器的唯一可能方法，正如我们在本章后面讨论 PMR 分配器时将会看到的）。
- en: We will first examine what was required to write an allocator before C++11,
    and how a container such as `std::vector<T,A>` could use an object of the `A`
    type to abstract away its memory allocation tasks. Improvements to the way allocators
    are expressed will follow in later sections of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查在 C++11 之前编写分配器所需的内容，以及容器如 `std::vector<T,A>` 如何使用 `A` 类型的对象来抽象其内存分配任务。分配器表达方式的改进将在本章后面的部分中讨论。
- en: Before C++11
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++11 之前
- en: Traditional allocators written before C++11 had to implement a wide array of
    members, which made the task of writing allocators seem daunting to many. Consider
    what one had to write in those days, and please note that not all of what follows
    remains true as of this writing since the API of allocators has evolved over time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前编写的传统分配器必须实现一系列成员，这使得编写分配器的任务对许多人来说似乎很艰巨。考虑一下那些日子人们需要编写的内容，并请注意，以下内容并非全部在撰写本文时仍然有效，因为分配器的
    API 随时间而演变。
- en: On the difficulty of tracking an evolving API
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪不断演变的 API 的难度
- en: What is required of allocators changed with every version of C++ since C++03,
    and these days, it is not always easy (or relevant) to write examples that compile
    for C++11\. For this reason, the examples we will write in a detailed manner will
    use C++11 allocators, to show what that actually meant, but will compile with
    the C++17 standard to make the code more pleasant to read (and write).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对分配器的要求随着 C++03 以来每个版本的 C++ 而变化，如今，编写编译为 C++11 的示例并不总是容易（或相关）。因此，我们将详细编写的示例将使用
    C++11 分配器，以展示这实际上意味着什么，但将使用 C++17 标准编译，以便代码更易于阅读（和编写）。
- en: We will examine such an allocator, `small_allocator<T>`, and implement it in
    a way that resembles `std::allocator<T>` in order to highlight what it meant to
    write an allocator in the C++11 era, and then compare that with an equivalent
    expressed for a more recent version of the standard. We will use C++17 features
    in our implementation as we do not want to introduce unnecessary complexity in
    an already subtle topic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查这样一个分配器，`small_allocator<T>`，并以类似于 `std::allocator<T>` 的方式实现它，以突出在 C++11
    时代编写分配器的意义，然后将其与标准更近版本的表达式进行比较。在我们的实现中，我们将使用 C++17 特性，因为我们不希望在已经微妙的话题中引入不必要的复杂性。
- en: After introducing `small_allocator<T>`, we will show how `Vector<T>` from [*Chapter
    12*](B21071_12.xhtml#_idTextAnchor172) and [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    can be enhanced and become `Vector<T,A>`, and how `A` can be `std::allocator<T>`,
    `small_allocator<T>`, or any other conforming allocator type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 `small_allocator<T>` 之后，我们将展示如何将来自 [*第 12 章*](B21071_12.xhtml#_idTextAnchor172)
    和 [*第 13 章*](B21071_13.xhtml#_idTextAnchor187) 的 `Vector<T>` 进行增强，并成为 `Vector<T,A>`，以及
    `A` 可以是 `std::allocator<T>`、`small_allocator<T>` 或任何其他符合规范的分配器类型。
- en: Type aliases
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: An allocator of the `T` type had to expose type aliases for `value_type`, `size_type`,
    `difference_type` (the type one would get from subtracting two `pointer` objects),
    `pointer`, `const_pointer`, `reference`, and `const_reference`. One way to think
    about this is that to a container, the allocator represents the underlying memory
    and consequently defines the types that best describe these low-level ideas. Containers
    could then map their own aliases to those of their allocator for conformity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 类型的分配器必须公开 `value_type`、`size_type`、`difference_type`（从两个 `pointer` 对象相减得到的结果类型）、`pointer`、`const_pointer`、`reference`
    和 `const_reference` 的类型别名。可以这样理解：对于一个容器来说，分配器代表底层内存，从而定义了最佳描述这些底层概念的类型。容器可以将自己的别名映射到分配器的别名上，以保持一致性。'
- en: 'In our `small_allocator<T>` type, this would translate to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `small_allocator<T>` 类型中，这会转化为以下内容：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In practice, for an allocator of `T`, one could expect these type aliases to
    correspond to those shown here for `small_allocator<T>` in all but the strangest
    cases: as long as `value_type` is defined, we can almost always infer the others.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于 `T` 类型的分配器，我们可以在所有但最奇怪的情况下期望这些类型别名与 `small_allocator<T>` 中显示的类型别名相对应：只要
    `value_type` 被定义，我们几乎总能推断出其他类型。
- en: Member functions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员函数
- en: An allocator of the `T` type had to expose a member function, `max_size()`,
    that was supposed to return the size of the largest block that this allocator
    could actually allocate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 类型的分配器必须公开一个成员函数 `max_size()`，该函数应该返回分配器实际可以分配的最大块的大小。'
- en: 'In practice, that often proved to be unimplementable as, with some operating
    systems, allocation always succeeds (but usage of the allocated memory may fail
    if the program is over-allocated) so that function usually turned out to be implemented
    on a best-effort basis on a given platform. A possible implementation would be
    the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这通常证明是不可实现的，因为对于某些操作系统，分配总是成功的（但如果程序分配过多，分配的内存的使用可能会失败），因此该函数通常在给定平台上以尽力而为的方式实现。一个可能的实现如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An allocator of the `T` type also had to expose two overloads of a function
    that uses all the words this author’s students “love” in a single signature (appreciate
    the irony!). Consider `pointer address(reference r)` as well as the equivalent
    for `const` objects, which is `const_pointer address(const_reference r)`. The
    intent here is to abstract the ways in which one would get the address of an object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 类型的分配器还必须公开两个函数重载，这些函数使用了作者的学生们“喜欢”的词汇（欣赏这种讽刺！）。考虑 `pointer address(reference
    r)` 以及 `const` 对象的等效函数，即 `const_pointer address(const_reference r)`。这里的意图是抽象出获取对象地址的方式。'
- en: It would be tempting to implement each of these functions as `return &r;` but
    in practice, this is perilous as users are allowed to overload the unary `operator&()`
    for their types, and this means such an implementation would call arbitrary code,
    a scary prospect indeed… Avoid overloading something as fundamental as “taking
    the address of an object” unless you really, *really* have a good reason to do
    so, and even then, consider alternative approaches to solving your problem!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些函数为 `return &r;` 可能很有诱惑力，但在实践中，这是危险的，因为用户被允许为他们自己的类型重载一元 `operator&()`，这意味着这种实现会调用任意代码，这确实是一个令人恐惧的前景……除非你真的、真的有很好的理由这样做，否则请考虑解决你问题的其他替代方法！
- en: 'A better implementation technique is to express these functions through `return std::addressof(r);`
    where `std::addressof()` is a “magical” standard library function from `<memory>`
    (that is, `constexpr`) and returns the address of an object without going through
    an overloadable facility:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的实现技术是通过 `return std::addressof(r);` 来表达这些函数，其中 `std::addressof()` 是来自 `<memory>`
    的一个“神奇”标准库函数（即 `constexpr`），它返回对象的地址，而不通过可重载的设施：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Obviously, an allocator needs to expose member functions to perform the actual
    memory allocation. The signatures for these are `allocate(size_type n)` and `deallocate(pointer p, size_type n)`.
    A simple implementation of these two functions could be the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，分配器需要公开成员函数来执行实际的内存分配。这些函数的签名是 `allocate(size_type n)` 和 `deallocate(pointer
    p, size_type n)`。这两个函数的简单实现可能如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `allocate()` member function used to take a second argument of the `void*`
    type named `hint`, which was initialized to `nullptr` by default. This argument
    was meant to inform the allocator of a location that could be used to provide
    storage, in case the container knew of such a location. That feature seemed rarely
    (if ever) used in practice, and was deprecated in C++17 and then removed in C++20.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate()` 成员函数过去接受一个名为 `hint` 的 `void*` 类型的第二个参数，默认初始化为 `nullptr`。这个参数的目的是通知分配器一个可能用于提供存储的位置，如果容器知道这样的位置。这个特性在实践中的使用似乎很少（如果有的话），并在
    C++17 中被弃用，然后在 C++20 中被移除。'
- en: 'These two functions are the essence of why allocators exist: `allocate()` returns
    a chunk of memory big enough to hold `n` contiguous elements of `value_type`,
    throwing `bad_alloc` on failure, and `deallocate()` deallocates a chunk of memory
    big enough to hold `n` contiguous elements of `value_type`. When one writes an
    allocator, one usually seeks to provide an answer to this specific problem.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是分配器存在本质的原因：`allocate()` 返回足够容纳 `n` 个连续 `value_type` 元素的内存块，在失败时抛出 `bad_alloc`，而
    `deallocate()` 释放足够容纳 `n` 个连续 `value_type` 元素的内存块。当编写一个分配器时，通常寻求为这个特定问题提供答案。
- en: Bytes or objects
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 字节或对象
- en: Interestingly, contrary to `operator new()`, which takes a number of *bytes*
    as argument, `allocate()` and `deallocate()` both take as argument a number of
    *objects*. That is because traditional allocators are type-aware (they are allocators
    of some type `T` after all), whereas `operator new()` and friends are (mostly)
    type-agnostic. You will notice later in this chapter that PMR allocators (which
    one might call “a step back”) use memory resources that are type-agnostic such
    as `malloc()` or `operator new()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与接受字节数作为参数的 `operator new()` 相反，`allocate()` 和 `deallocate()` 都接受对象的数量作为参数。这是因为传统的分配器是类型感知的（毕竟它们是某种类型
    `T` 的分配器），而 `operator new()` 和其相关函数（主要）是无类型感知的。你会在本章后面注意到，PMR 分配器（人们可能会称之为“退一步”）使用无类型感知的内存资源，如
    `malloc()` 或 `operator new()`。
- en: 'Both `allocate()` and `deallocate()` deliberately lie to client code: they
    trade in raw memory and neither create nor destroy objects of type `T`, yet `allocate()`
    returns a `pointer` (a `T*`, essentially) and `deallocate()` accepts a `pointer`
    as argument even though all `T` objects are assumed to have been destroyed beforehand.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate()` 和 `deallocate()` 都故意向客户端代码撒谎：它们交易的是原始内存，既不创建也不销毁类型 `T` 的对象，但 `allocate()`
    返回一个 `pointer`（本质上是一个 `T*`），而 `deallocate()` 接受一个 `pointer` 作为参数，尽管假设所有 `T` 对象在此之前都已销毁。'
- en: The fact that these functions lie to the type system is a good thing in a way,
    as it relieves the container from the task of doing so. Of course, the container
    has to be aware of what these functions do and should not assume the presence
    of objects in memory returned by `allocate()` or passed to `deallocate()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数欺骗类型系统在某种程度上是好事，因为它减轻了容器执行此操作的负担。当然，容器必须了解这些函数的作用，并且不应该假设 `allocate()` 返回或传递给
    `deallocate()` 的内存中存在对象。
- en: 'Finally, an allocator had to expose member functions to turn raw memory into
    objects and conversely. The `construct(pointer p,const_reference r)` and `destroy(pointer p)`
    functions are respectively meant to construct a copy of `r` at location `p` (which
    is assumed to have been allocated beforehand), and destroy the object at location
    `p` (without deallocating the underlying storage):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分配器必须公开成员函数以将原始内存转换为对象，反之亦然。`construct(pointer p,const_reference r)` 和 `destroy(pointer p)`
    函数分别用于在位置 `p`（假设之前已分配）处构造 `r` 的副本，并销毁位置 `p` 处的对象（不释放底层存储）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One can expect that most implementations will do essentially what the preceding
    code does. There are alternatives, but they are rarely met in practice.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以预期大多数实现将基本上做前面代码所做的事情。有其他选择，但在实践中很少遇到。
- en: 'Again, these functions lie to the type system: `construct()` takes a `pointer`
    (a `T*`, in practice) as argument but when the function is called, that pointer
    points to raw memory, not to an object of type `T`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些函数欺骗了类型系统：`construct()` 接受一个 `pointer`（实践中是一个 `T*`）作为参数，但函数被调用时，该指针指向的是原始内存，而不是类型
    `T` 的对象。
- en: What about rebind?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那重绑定（rebind）呢？
- en: You will notice that we did not discuss the `rebind` public template type, but
    that is only because the idea behind this type is easier to understand when facing
    the kind of problem it is meant to solve. We will face such a situation when discussing
    allocator-aware node-based containers through our `ForwardList<T,A>` class later
    in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们没有讨论 `rebind` 公共模板类型，但这仅仅是因为当面对这个类型旨在解决的问题时，这个类型背后的想法更容易理解。我们将在本章后面通过我们的
    `ForwardList<T,A>` 类讨论分配器感知的基于节点的容器时遇到这种情况。
- en: 'Past this point, the requirement for an allocator is to define whether two
    allocator objects of different types are equal or not. A possible implementation
    would be the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 超过这一点，对分配器的需求是定义不同类型的两个分配器对象是否相等。一个可能的实现如下：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Expressed otherwise, two `small_allocator` specializations for distinct types
    describe the same strategy and are thus considered equal. “But wait!” you say,
    “Where do you take into account the state of the allocators in this computation?”.
    But here’s a revelation: pre-C++11 allocators were essentially assumed to be *stateless*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，两个针对不同类型的`small_allocator`特化描述了相同的策略，因此被认为是相等的。“但是等等！”你说，“在这个计算中你是如何考虑分配器的状态的？”但是这里有一个启示：C++11之前的分配器基本上被认为是*无状态的*。
- en: Well, they were not, but it was unclear what would happen to an allocator if
    it was associated with a container object and that object was copied. You see,
    if an allocator has *state*, we have to know what to do with that state when the
    allocator is copied. Is the state copied? Is it shared? In the pre-C++11 era,
    we did not know what to do in such a situation, so unless a container was used
    in a context where it would not be copied, as in the case of a vector local to
    a function and associated with an allocator that uses stack space as storage,
    most people avoided stateful allocators altogether.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它们并不是，但如果一个分配器与一个容器对象相关联，并且该对象被复制，那么会发生什么并不清楚。你看，如果一个分配器有*状态*，我们必须知道在分配器被复制时如何处理这个状态。这个状态是被复制了吗？是被共享了吗？在C++11之前，我们不知道在这种情况下应该怎么做，所以除非容器被用于不会复制的上下文中，比如函数局部向量以及与使用栈空间作为存储的分配器相关联的情况，否则大多数人完全避免使用有状态的分配器。
- en: But what about stateful allocators?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但有状态的分配器又如何呢？
- en: As hinted, stateful allocators were a possibility back then (they existed, and
    they were used in practice). How is one expected to define allocator equality
    for stateful allocators (and for allocators in general)? The general idea is that
    two allocators should compare equally if memory allocated from one can be deallocated
    from the other. With an allocator that delegates allocation tasks to free functions
    such as `std::malloc()` or `::operator new()`, equality is trivially `true`, but
    stateful allocators require us to think about how to define this relation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如暗示的那样，当时有状态的分配器是可能的（它们存在，并且在实际中得到了应用）。人们预期如何定义有状态分配器的分配器相等性（以及分配器的一般相等性）呢？一般想法是，如果从其中一个分配器分配的内存可以从另一个分配器释放，那么两个分配器应该相等。对于将分配任务委托给如`std::malloc()`或`::operator new()`等自由函数的分配器，相等性是显而易见的`true`，但有状态的分配器要求我们思考如何定义这种关系。
- en: Before we look at how we could write allocator-aware containers, we will take
    a step back and see how we could adapt some of the uninitialized memory algorithms
    used in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172) and [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    to use the services of an allocator. This will reduce the refactoring effort required
    later in the process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何编写分配器感知容器之前，我们将退一步看看如何将[*第12章*](B21071_12.xhtml#_idTextAnchor172)和[*第13章*](B21071_13.xhtml#_idTextAnchor187)中使用的某些未初始化内存算法适应以使用分配器的服务。这将减少在后续过程中所需的重构工作量。
- en: Some allocator-aware support algorithms
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些分配器感知支持算法
- en: Since we are using allocators to bridge the gap between raw storage and objects,
    we will not be able to use the raw memory algorithms seen in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172)
    and [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187) in our allocator-aware implementations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用分配器来弥合原始存储和对象之间的差距，因此我们无法在我们的分配器感知实现中使用在[*第12章*](B21071_12.xhtml#_idTextAnchor172)和[*第13章*](B21071_13.xhtml#_idTextAnchor187)中看到的原始内存算法。
- en: We have the option of writing our own versions of these algorithms in detail
    at each call site within our containers, but that would be tedious (and bug-prone).
    Instead, we will write somewhat simplified versions of these low-level memory
    management algorithms and make these simplified versions use an allocator passed
    as an argument. In so doing, we will reduce the impact of making containers allocator-aware
    on our implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有选择在每个容器调用点详细编写这些算法的版本，但这会很繁琐（并且容易出错）。相反，我们将编写这些低级内存管理算法的简化版本，并使这些简化版本使用作为参数传递的分配器。通过这样做，我们将减少容器分配器感知对实现的影响。
- en: 'The first three of these algorithms will be allocator-aware versions of algorithms
    that initialize a range of values, as well as one that destroys such a range.
    To minimize the impact on the existing implementations, we will essentially use
    the same signature as their non-allocator-aware counterpart, but with an added
    argument that is a reference to the allocator. For the algorithm that fills a
    block of raw memory with some value, we have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个算法中的前三个将是初始化值范围的分配器感知版本的算法，以及一个销毁此类范围的算法。为了最小化对现有实现的影响，我们将基本上使用与它们的非分配器感知对应版本相同的签名，但添加一个引用分配器的参数。对于用某个值填充原始内存块块的算法，我们有以下内容：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, for the algorithm that copies a sequence of values to a block of raw
    memory, we have the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于将值序列复制到原始内存块块的算法，我们有以下内容：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the algorithm that moves a sequence of values to a block of raw memory,
    we have the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将值序列移动到原始内存块块的算法，我们有以下内容：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, for the algorithm that transforms a sequence of objects into a block
    of raw memory, we have the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于将对象序列转换为原始内存块块的算法，我们有以下内容：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that in each case, the implementation would be more conformant if, when
    an exception occurs, objects were destroyed in reverse order of construction.
    Feel free to implement this slight adjustment; it’s not difficult but it would
    introduce some noise in our example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，如果发生异常，则对象将按照构造的相反顺序销毁，这将使实现更加符合规范。请随意实现这个小的调整；这并不困难，但会在我们的示例中引入一些噪音。
- en: 'The other standard facility we will rewrite is `cmp_less()`, which allows comparing
    a signed value with an unsigned value without getting caught by the integer promotion
    rules of the C language. It’s not directly memory-related, but we need it in our
    `Vector<T>` implementation, and it’s a C++20 feature, which makes it unavailable
    when we compile for C++17:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要重写的另一个标准设施是`cmp_less()`，它允许在不被C语言的整数提升规则捕获的情况下比较有符号值和无符号值。它与内存直接相关，但我们需要它在我们的`Vector<T>`实现中，并且这是一个C++20特性，这使得在为C++17编译时不可用：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both the `std::is_signed<T>` trait as well as the `std::make_unsigned<T>()`
    function can be found in header `<type_traits>`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_signed<T>`特性以及`std::make_unsigned<T>()`函数都可以在头文件`<type_traits>`中找到。'
- en: Conditional compilation and feature test macros
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译和特征测试宏
- en: As an aside, if you find yourself having to maintain code where a feature such
    as `std::cmp_less()` might or might not be available, such as a source file that
    is sometimes compiled for C++20 and sometimes compiled for C++17, consider conditional
    inclusion of your “homemade workaround” version by testing the associated feature
    test macro.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，如果你发现自己必须维护代码，其中可能或可能没有`std::cmp_less()`这样的功能，例如有时为C++20编译有时为C++17编译的源文件，考虑通过测试相关的特征测试宏条件包含你的“自制解决方案”版本。
- en: For this specific case, one could wrap the definition of our personal version
    of `cmp_less()` with `#ifndef __cpp_lib_integer_comparison_functions` to make
    sure it is only provided if there is no version provided by one’s standard library
    implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的情况，可以通过使用`#ifndef __cpp_lib_integer_comparison_functions`将我们个人版本的`cmp_less()`函数定义包裹起来，以确保只有在没有标准库实现提供版本的情况下才提供它。
- en: Now, let’s see how these allocators and our support algorithms can be used by
    a container, first with a container that uses contiguous storage (our `Vector<T,A>`
    class) and then with a node-based container (our `ForwardList<T,A>` class).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些分配器和我们的支持算法如何被容器使用，首先是一个使用连续存储的容器（我们的`Vector<T,A>`类），然后是一个基于节点的容器（我们的`ForwardList<T,A>`类）。
- en: An allocator-aware Vector<T,A> class
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配器感知的`Vector<T,A>`类
- en: We are now ready to look at how introducing allocator awareness in a container
    that uses contiguous memory (more specifically, our `Vector<T>` class) impacts
    the implementation of that container. Note that we will use the explicit memory
    management approach from [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172) as a
    baseline in this case since we want to explore the impact of allocator awareness
    and this will help us make the implementation changes more apparent. Feel free
    to adapt the code in this chapter with an implicit approach to memory management
    if you are so inclined.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备看看在连续内存使用的容器（更具体地说，我们的`Vector<T>`类）中引入分配器意识如何影响该容器的实现。请注意，我们将使用第[*第12章*](B21071_12.xhtml#_idTextAnchor172)中明确的内存管理方法作为基准，因为我们想探索分配器意识的影响，这将帮助我们更明显地做出实现更改。如果你愿意，可以自由地根据隐式内存管理方法调整本章中的代码。
- en: 'Starting with the template’s signature itself, we now have a two-type template
    with `T` being the type of the elements and `A` being the type for the allocator,
    but with a reasonable default type for `A` such that casual users will not need
    to worry about such technical details:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从模板的签名本身开始，我们现在有一个双类型模板，其中`T`是元素类型，`A`是分配器类型，但为`A`提供了一个合理的默认类型，这样普通用户就不需要担心这样的技术细节：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note some techniques here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下技术：
- en: Since we expect `A` to be stateless, we used private inheritance and made `A`
    a base class of `Vector<T,A>`, enabling the empty base optimization. Alternatively,
    we could also have used a data member of type `A` inside each `Vector<T,A>` object
    (perhaps incurring a small size penalty).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们期望`A`是无状态的，我们使用了私有继承，并使`A`成为`Vector<T,A>`的基类，从而实现了空基优化。或者，我们也可以在每个`Vector<T,A>`对象内部使用类型为`A`的数据成员（可能带来轻微的大小惩罚）。
- en: We deduced the type aliases of the container from those of its allocator. This
    probably changes nothing in practice with respect to the aliases we used in previous
    chapters, but `A` might be doing some “fancy tricks” (one can never be too careful).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从其分配器的类型别名推导出容器的类型别名。在实践中，这可能与我们在前几章中使用的别名没有太大变化，但`A`可能在进行一些“花哨的技巧”（永远不能太过小心）。
- en: In a private section of our class, we expose some selected members of our base
    class as our own. This will make the code less verbose later on, allowing us to
    write `allocate(n)` instead of `this->A::allocate(n)`, for example.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们类的私有部分，我们将基类的一些选定成员公开为我们的成员。这将使代码在以后变得更加简洁，例如，我们可以编写`allocate(n)`而不是`this->A::allocate(n)`。
- en: The non-allocating members of our class do not change, unsurprisingly. Data
    members stay the same, and so do basic accessors such as `size()`, `empty()`,
    `begin()`, `end()`, `front()`, `operator[]`, and so on. Even the default constructor
    remains unchanged since it does not allocate memory and so does not need to interact
    with its allocator.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中非分配成员没有变化，这是预料之中的。数据成员保持不变，基本访问器如`size()`、`empty()`、`begin()`、`end()`、`front()`、`operator[]`等也是如此。默认构造函数也没有变化，因为它不分配内存，因此不需要与它的分配器交互。
- en: 'There is a new constructor needed, one that accepts as argument an allocator.
    This one is particularly useful in the case of stateful allocators:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个新的构造函数，它接受一个分配器作为参数。这个构造函数在状态化分配器的情况下特别有用：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Of course, when reaching the constructors that do need to allocate memory,
    the situation becomes more interesting. Take, for example, the constructor that
    takes as argument a number of elements and an initial value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当遇到需要分配内存的构造函数时，情况变得更加有趣。以一个接受元素数量和初始值的构造函数为例：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is a lot to say here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多要说的：
- en: The memory block that will serve as the underlying storage for our container
    is allocated through a call to our base class’s `allocate()` member function.
    Remember that even though this yields a `pointer` (a `T*`), that is a lie and
    there are no `T` objects in the newly allocated block.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将作为我们容器底层存储的内存块是通过调用基类的`allocate()`成员函数分配的。记住，尽管这产生了一个`指针`（一个`T*`），但这是一种谎言，新分配的块中没有`T`对象。
- en: 'We fill that uninitialized memory block with `T` objects through our homemade
    allocator-aware version of `std::uninitialized_fill()` (see the `_with_allocator`
    suffix). Note how we pass the allocator as an argument to the algorithm: the inheritance
    relationship between `Vector<T,A>` and `A` is `private`, but the derived class
    is aware of it and can use that information through `static_cast`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过我们自制的分配器感知版本的`std::uninitialized_fill()`（见`_with_allocator`后缀）来填充那个未初始化的内存块，用`T`对象填充。注意我们如何将分配器作为参数传递给算法：`Vector<T,A>`和`A`之间的继承关系是`private`，但派生类知道这一点，并且可以通过`static_cast`使用这些信息。
- en: If one of the constructors used in the process of initializing that memory block
    throws, the algorithm destroys the objects it had created, as usual (no one else
    really could do it anyway), after which we intercept that exception and deallocate
    the storage before re-throwing said exception in the interest of exception neutrality.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在初始化该内存块的过程中使用的任何一个构造函数抛出异常，算法将像往常一样销毁它所创建的对象，然后我们拦截该异常，在重新抛出该异常之前释放存储，以实现异常中立。
- en: 'Similar maneuvers are used in other allocating constructors, with different
    algorithms used to initialize the allocated storage. The move constructor and
    the `swap()` member function do not allocate memory and, for that reason, remain
    unchanged, and the same goes for the assignment operators: they are built from
    other member functions and do not need to allocate or deallocate memory by themselves.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他分配构造函数中，也使用了类似的操作，但用于初始化分配存储的算法不同。移动构造函数和`swap()`成员函数不分配内存，因此保持不变，赋值运算符也是如此：它们是由其他成员函数构建的，并且不需要自己分配或释放内存。
- en: 'As you probably suspected already, the destructor of our container will use
    the allocator to destroy the objects and deallocate the underlying storage:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，我们容器的析构函数将使用分配器来销毁对象并释放底层存储：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `push_back()` and `emplace_back()` member functions do not allocate by
    themselves, delegating to our private `grow()` member function, which, in turn,
    delegates to `reserve()` for the allocation, but they do need to `construct()`
    an object at the end of the container:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`push_back()`和`emplace_back()`成员函数本身不分配内存，而是委托给我们的私有`grow()`成员函数，该函数反过来委托给`reserve()`进行分配，但它们确实需要在容器的末尾`construct()`一个对象：'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The principal tools for memory allocation in our class are probably `reserve()`
    and `resize()`. In both cases, the algorithm remains as it was, but the low-level
    memory management tasks are delegated to the allocator. For `reserve()`, this
    leads us to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中内存分配的主要工具可能是`reserve()`和`resize()`。在这两种情况下，算法保持不变，但底层内存管理任务被委托给分配器。对于`reserve()`，这导致以下情况：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Whereas, for `resize()`, we now have the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于`resize()`，我们现在有以下情况：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In previous implementations of the `Vector<T>` class, we had implemented one
    version each of `insert()` and `erase()`, as implementing the whole set of these
    functions would make this book unreasonably large. Since both functions meddle
    with initialized and uninitialized memory, they need to be adapted to use the
    services of the allocator rather than doing their own memory management.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vector<T>`类的先前实现中，我们为`insert()`和`erase()`各自实现了一个版本，因为实现所有这些函数会使这本书变得过于庞大。由于这两个函数都涉及已初始化和未初始化的内存，它们需要调整以使用分配器的服务而不是进行自己的内存管理。
- en: 'In the case of `insert()`, the key aspects of the function that need to be
    adjusted are those that copy or move objects into raw memory:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insert()`的情况下，需要调整函数的关键方面是那些将对象复制或移动到原始内存中的方面：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the case of `erase()`, what we do is copy all objects after the erased one
    “to the left” by one position; the object at the end of the sequence after this
    copying has been performed has to be destroyed, and for this, we need to use the
    allocator’s services. An example follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`erase()`的情况下，我们执行的操作是将被删除对象之后的所有对象“向左”移动一个位置；在此复制操作完成后，序列末尾的对象必须被销毁，为此，我们需要使用分配器的服务。以下是一个示例：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you have probably gathered at this point, we could optimize or simplify
    these functions in numerous ways, such as the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您此时可能已经收集到的，我们可以以多种方式优化或简化这些函数，例如以下方式：
- en: There is a common core functionality between `reserve()` and `resize()`, so
    we could essentially claim that `resize()` is in large part like `reserve()` followed
    by an uninitialized fill and express it as such.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserve()` 和 `resize()` 之间存在共同的核心功能，因此我们可以说 `resize()` 在很大程度上类似于 `reserve()`
    后跟一个未初始化的填充，并以此表达。'
- en: In the case of `erase()`, at compile time, we could test the value of the `std::is_nothrow_move_assignable_v<T>`
    trait and, if that condition holds, replace the call to `std::copy()` with a call
    to `std::move()`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `erase()` 的情况下，在编译时，我们可以测试 `std::is_nothrow_move_assignable_v<T>` 特性的值，如果该条件成立，则将
    `std::copy()` 的调用替换为 `std::move()` 的调用。
- en: We could make `insert()` and `erase()` more exception-safe than they are, although
    this would make the code a bit long for a book such as this one.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使 `insert()` 和 `erase()` 比现在更异常安全，尽管这会使这本书的代码稍微长一些。
- en: At this point, we have an allocator-aware container that manages contiguous
    memory. It will now be interesting to see what the impacts of allocator awareness
    will be on a node-based container, something we will address through an allocator-aware
    version of the `ForwardList<T>` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个分配器感知的容器，它管理连续内存。现在将很有趣地看到分配器感知对基于节点的容器的影响，我们将通过 `ForwardList<T>`
    类的分配器感知版本来解决这个问题。
- en: An allocator-aware ForwardList<T,A> class
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个分配器感知的 `ForwardList<T,A>` 类
- en: 'A funny thing happens when writing allocator-aware node-based containers. Pay
    attention to the beginning of our `ForwardList<T,A>` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写分配器感知的基于节点的容器时，会发生一件有趣的事情。请注意我们的 `ForwardList<T,A>` 类的开始部分：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Did you notice something interesting about type `A`? Think about it…
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到类型 `A` 的有趣之处了吗？想想看…
- en: 'Yes, that’s it: `A` *is the wrong type*! A node-based container such as `ForwardList<T,A>`
    never allocates objects of type `T`: it allocates *nodes* that (most probably)
    contain `T` objects and other things such as, in this case, a pointer to the next
    `Node` in the sequence.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样：`A` *是错误类型*！像 `ForwardList<T,A>` 这样的基于节点的容器永远不会分配类型 `T` 的对象：它分配 *节点*，这些节点（很可能）包含
    `T` 对象和其他东西，例如，在这种情况下，指向序列中下一个 `Node` 的指针。
- en: Knowing this, if we were supplied some allocator `A` that modeled a size-aware
    allocation strategy akin to what we used in our arena for `Orc` objects in [*Chapter
    10*](B21071_10.xhtml#_idTextAnchor153), making the allocator aware of `T` (and
    thus, of `sizeof(T)`) would lead to an arena that manages objects of the wrong
    size. This is not good!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，如果我们提供了一些类似于我们在 [*第10章*](B21071_10.xhtml#_idTextAnchor153) 中用于 `Orc`
    对象的竞技场分配策略的 `A` 分配器，使分配器了解 `T`（因此，了解 `sizeof(T)`），这将导致管理错误大小对象的竞技场。这可不是什么好事！
- en: 'We are faced with an interesting conundrum: user code provides us with an allocator
    because it wants our container to put an *allocation strategy* to good use. That
    allocation strategy appears as a template parameter of our container, which is
    why it is associated with the type of its elements (we do not know what the nodes
    will be at this point in the definition of our container class). Only later, when
    we have defined what a node will be for our container, are we really ready to
    say what will need to be allocated, but then `A` already exists and is already
    associated to `T`, not to the type we really need, which is `ForwardList<T,A>::Node`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临一个有趣的困境：用户代码提供给我们一个分配器，因为它希望我们的容器能够充分利用 *分配策略*。这种分配策略作为容器模板参数出现，这就是为什么它与元素的类型相关联（在我们容器类的定义这一点上，我们不知道节点将是什么）。只有在我们定义了容器中的节点是什么之后，我们才能真正地说出需要分配什么，但那时
    `A` 已经存在，并且已经与 `T` 相关联，而不是我们真正需要的类型，即 `ForwardList<T,A>::Node`。
- en: Note that we have instantiated type `A` but have not constructed any object
    of that type. Lucky for us, as that would have been wasteful (we would never use
    it!). What we do need is a type that is just like `A`, but able to allocate objects
    of our `Node` type instead of objects of type `T`. We need a way to *clone the
    allocation strategy* described by `A` and apply it to another type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经实例化了类型 `A`，但尚未构造该类型的任何对象。幸运的是，那样会非常浪费（我们永远不会使用它！）。我们真正需要的是一个与 `A` 类似的类型，但能够分配我们的
    `Node` 类型对象，而不是类型 `T` 的对象。我们需要一种方法来 *克隆 `A` 描述的分配策略* 并将其应用于另一个类型。
- en: 'This is exactly what `rebind` is for. Remember that we mentioned this template
    type when writing `small_allocator<T>` earlier but said we would return to it
    when we could put it to good use? There we are, dear reader. As a reminder, in
    the context of an allocator, `rebind` presents itself as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `rebind` 的用途。记住，我们在之前编写 `small_allocator<T>` 时提到了这个模板类型，但说我们会等到可以用到它的时候再回来？现在我们就在这里，亲爱的读者。作为提醒，在分配器的上下文中，`rebind`
    表现如下：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see `rebind` as some kind of weird code poetry: it is a way for the
    allocator to say “If you want the same type as myself but applied to some `U`
    type instead of `T`, here’s what that type would be.”'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `rebind` 视为某种奇怪的诗意代码：这是分配器说“如果你想要与我相同类型但应用于某些 `U` 类型而不是 `T`，那么这个类型会是什么样子”的一种方式。
- en: 'Returning to our `ForwardList<T,A>` class, now that we know what `rebind` is
    for, we can create our own internal allocator type, `Alloc`. This will be “like
    the allocator type `A` but applied to `Node`, not to `T`” and create an object
    of that type (incidentally named `alloc` in our implementation), which we will
    use to perform the memory management tasks in our container:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的 `ForwardList<T,A>` 类，既然我们已经知道了 `rebind` 的用途，我们就可以创建我们自己的内部分配器类型，`Alloc`。这将类似于分配器类型
    `A`，但应用于 `Node` 而不是 `T`，并创建一个该类型的对象（在我们的实现中偶然命名为 `alloc`），我们将使用它来执行容器中的内存管理任务：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It’s a nice trick, isn’t it? Remember that we cloned the *strategy*, the type,
    not an actual object so any state some hypothetical `A` object would have had
    would not necessarily be part of our new `Alloc` type (at least not without performing
    some non-trivial acrobatics). This is yet another reminder that with traditional
    allocators as they were originally designed, copying and moving allocator state
    was a complex problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的技巧，不是吗？记住，我们克隆的是 *策略*，即类型，而不是一个实际的对象，所以一些假设的 `A` 对象可能拥有的任何状态不一定是我们新的 `Alloc`
    类型的一部分（至少不是不进行一些非平凡的杂技表演的情况下）。这又是另一个提醒，按照传统的分配器设计，复制和移动分配器状态是一个复杂的问题。
- en: 'As was the case for the transformation from `Vector<T>` to `Vector<T,A>`, a
    significant portion of our `List<T>` implementation involved no memory allocation
    and thus needs not change with `List<T,A>`. This includes the `size()`, `empty()`,
    `begin()`, `end()`, `swap()`, `front()`, and `operator==()` member functions,
    among others, as well as most of the `List<T,A>::Iterator<U>` class definition.
    As our implementation of `ForwardList<T,A>` will need to access private data member
    `cur` of its iterators on occasion, we give it `friend` privileges over `Iterator<U>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从 `Vector<T>` 转换到 `Vector<T,A>` 一样，我们的大部分 `List<T>` 实现涉及不到内存分配，因此不需要随着 `List<T,A>`
    而改变。这包括 `size()`、`empty()`、`begin()`、`end()`、`swap()`、`front()` 和 `operator==()`
    成员函数，以及其他许多 `List<T,A>::Iterator<U>` 类定义。由于我们的 `ForwardList<T,A>` 实现有时需要访问迭代器的私有数据成员
    `cur`，我们给它 `friend` 权限：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are, of course, member functions of `ForwardList<T,A>` that use memory
    allocation mechanisms. One of them is `clear()`, whose role is to destroy the
    nodes in the container. The destruction and deallocation of `Node` objects have
    to be performed through the allocator, replacing the call to `operator delete()`
    with a pair of function calls:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ForwardList<T,A>` 有一些使用内存分配机制的成员函数。其中之一是 `clear()`，其作用是销毁容器中的节点。`Node` 对象的销毁和重新分配必须通过分配器执行，用一对函数调用替换对
    `operator delete()` 的调用：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In `ForwardList<T>`, we made all of the allocating constructors converge toward
    a single sequence constructor that accepted a pair of iterators (type `It`) as
    arguments. This localizes the changes required for constructors in `ForwardList<T,A>`
    to that single function, something that simplifies our task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ForwardList<T>` 中，我们将所有分配构造函数汇聚到一个接受一对迭代器（类型 `It`）作为参数的单个序列构造函数中。这将 `ForwardList<T,A>`
    中构造函数所需的变化局部化到那个单一函数中，这简化了我们的任务。
- en: In `ForwardList<T>`, we had constrained template parameter `It` by the `std::forward_iterator`
    concept, but concepts are a C++20 feature and we are compiling this implementation
    in C++17 so we will (sadly) let go of this constraint for the time being.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ForwardList<T>` 中，我们通过 `std::forward_iterator` 概念约束了模板参数 `It`，但概念是 C++20
    的特性，而我们在这个实现中编译的是 C++17，所以（遗憾的是）我们将暂时放弃这个约束。
- en: 'Having to perform allocation and construction in separate steps complicates
    our implementation a little, but I think you esteemed readers, will not find this
    to be unsurmountable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 必须分步骤执行分配和构造使我们的实现稍微复杂一些，但我认为你们尊贵的读者不会觉得这是不可逾越的：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also had written insertion member functions for `ForwardList<T>`, so these
    will also need to be adapted to use allocators in `ForwardList<T,A>`. We had two
    overloads of `push_front()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为 `ForwardList<T>` 编写了插入成员函数，因此这些函数也需要适应使用 `ForwardList<T,A>` 中的分配器。我们有两个
    `push_front()` 的重载版本：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also had two overloads of `insert_after()`, one that inserted a single value
    and one that inserted the elements in a half-open range. In the latter case, we
    will need to put aside the `std::forward_iterator` constraint on type `It` again
    as we are compiling for C++17:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为 `insert_after()` 提供了两个重载版本，一个用于插入单个值，另一个用于插入半开区间内的元素。在后一种情况下，由于我们正在为 C++17
    编译，我们需要再次放宽对类型 `It` 的 `std::forward_iterator` 约束：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `erase_after()` member function is similarly adjusted:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `erase_after()` 成员函数也进行了类似的调整：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That concludes our transformation of `ForwardList<T>` into an allocator-aware
    `ForwardList<T,A>` class. I hope, dear reader, that this was not as difficult
    as some might have feared: given our understanding of the principles and fundamental
    techniques presented in this book, integrating allocator awareness in a container
    should make some sort of sense to most of us at this point.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们将 `ForwardList<T>` 转换为分配器感知的 `ForwardList<T,A>` 类型的转换。我希望，亲爱的读者，这个过程并没有像一些人担心的那样困难：鉴于我们对本书中提出的原理和基本技术的理解，在这个阶段，将分配器感知集成到容器中应该对大多数人来说是有意义的。
- en: Now that we have seen how to write a “traditional” iterator as well as examples
    of how one can make a container allocator-aware, you might be wondering about
    the benefits of using allocators. We know that allocators give use code control
    over the ways in which containers manage memory, but what can we gain from that
    control?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何编写“传统”迭代器，以及如何使容器分配器感知的示例，你可能想知道使用分配器的优点。我们知道分配器让我们能够控制容器管理内存的方式，但我们可以从这种控制中获得什么？
- en: Example usage – a sequential buffer allocator
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例用法 – 顺序缓冲区分配器
- en: A classical example of allocator usage is one that, instead of allocating memory
    from the free store, manages a pre-allocated chunk of memory. That memory does
    not have to come from the execution stack of a thread, but that’s often what is
    done in practice, so that’s what our example code will do.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器使用的经典例子是，不是从自由存储中分配内存，而是管理预分配的内存块。这些内存不必来自线程的执行栈，但在实践中通常是这样做的，所以我们的示例代码也将这样做。
- en: 'What you need to know before reading the following example is this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读以下示例之前，你需要知道的是：
- en: This sort of allocator is a specialized tool for specialized users. We expect
    users to know what they are doing.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种类型的分配器是专门为特定用户设计的工具。我们期望用户知道自己在做什么。
- en: The pre-allocated buffer that will be managed by the allocator in our example
    has to be properly aligned for the objects that will be stored therein. If you
    want to adapt this example to handle memory allocation for any naturally aligned
    object, some additional effort will be required (you will want the allocator to
    yield addresses aligned on a `std::max_align_t` boundary, something our example
    allocator does not do).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的例子中，由分配器管理的预分配缓冲区必须适当地对齐以存储其中的对象。如果你想要将这个例子修改为处理任何自然对齐对象的内存分配，需要做额外的工作（你希望分配器提供
    `std::max_align_t` 边界对齐的地址，而我们的示例分配器并不这样做）。
- en: Some care will need to be taken if client code tries to “,over-allocate,” asking
    for more memory than what the managed buffer could provide. In this example, we
    will throw `std::bad_alloc` as usual, but alternatives exist.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端代码尝试“过度分配”，请求比管理缓冲区能提供的更多内存，那么需要特别注意。在这个例子中，我们将像往常一样抛出 `std::bad_alloc`，但存在其他替代方案。
- en: When bad_alloc is not an option…
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当 bad_alloc 不是一个选项时…
- en: For some applications, throwing or otherwise failing to allocate is not an option.
    The fact that a specialized allocator cannot meet an allocation request should
    not, for these applications, result in throwing an exception as throwing means
    “I cannot meet the postconditions of this function.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，抛出异常或其他方式失败分配不是一种选择。对于这些应用，如果专门的分配器无法满足分配请求，不应该抛出异常，因为抛出异常意味着“我无法满足这个函数的后置条件。”
- en: One thing that some applications do when a sequential buffer allocator runs
    out of memory is simply call `::operator new()` and take the indeterministic allocation
    time “hit” but leave a trace somewhere (a log, maybe) that this happened. This
    means the program will leak memory, but for some applications (say, a stock market
    exchange program that is restarted every day), one can expect those leaks to be
    relatively low in number, and the fact that there is a trace that something leaked
    will let programmers look at the problem and (hopefully) fix it before the next
    day. The “lesser of two evils,” as some might say.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当顺序缓冲区分配器耗尽内存时，一些应用程序会简单地调用`::operator new()`并承受不确定的分配时间“打击”，但会在某个地方留下痕迹（可能是日志），表明发生了这种情况。这意味着程序将泄漏内存，但对于某些应用程序（比如每天都会重新启动的股票市场交易程序），可以预期这些泄漏的数量相对较少，而且有痕迹表明发生了泄漏将让程序员在第二天之前查看问题并（希望）修复它。“两害相权取其轻”，正如有些人所说。
- en: 'Our sequential buffer allocator will look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顺序缓冲区分配器将看起来像这样：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the state for this allocator resembles what we did for the
    size-based arena in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153): we know
    where the buffer to manage starts (`buf`), how big it is (`cap`), and where we
    are at in our sequential allocation process (`cur`).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个分配器的状态类似于我们在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中为基于大小的区域所做的：我们知道要管理的缓冲区从哪里开始（`buf`），有多大（`cap`），以及我们在顺序分配过程中的位置（`cur`）。
- en: We make `cur` a `pointer`-type object to simplify computation later, in the
    `allocate()`member function, but it’s a convenience, not a necessity.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`cur`设为一个`pointer`类型的对象，以便在之后的`allocate()`成员函数中简化计算，但这只是一个便利，并非必需。
- en: The `allocate()` member function is very simple in the sense that it performs
    a constant-time computation, returning contiguously allocated objects from the
    underlying storage without even having to reuse that memory after it has been
    deallocated. Part of the work done in `allocate()` requires avoiding over-allocating,
    and to do this, we will compare pointers, but we might have to compare a pointer
    within the allocated memory block with one that is not within that block (it all
    depends on the value of our arguments). This would lead us into undefined behavior,
    something we need to avoid, so we cast our pointers to `std::intptr_t` objects
    and compare the resulting integral values instead.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，`allocate()`成员函数非常简单，因为它执行的是常数时间的计算，从底层存储中返回连续分配的对象，甚至在内存释放后也不需要重新使用该内存。`allocate()`中完成的部分工作需要避免过度分配，为此，我们将比较指针，但可能需要比较分配内存块内的指针与块外的指针（这完全取决于我们的参数值）。这可能会导致未定义的行为，这是我们想要避免的，因此我们将指针转换为`std::intptr_t`对象，并比较得到的整数值。
- en: What if std::intptr_t is not offered on my platform?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的平台上没有提供`std::intptr_t`呢？
- en: Types `std::intptr_t` and `std::uintptr_t` are conditionally supported in C++,
    which means that there might be vendors that do not offer these type aliases.
    If you find yourself in this unlikely but not impossible situation, you can simply
    keep track of the number of objects allocated and compare this with the `cap`
    data member to achieve the same effect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`std::intptr_t`和`std::uintptr_t`类型是条件支持的，这意味着可能存在不提供这些类型别名的供应商。如果你发现自己处于这种不太可能但并非不可能的情况，你可以简单地跟踪分配的对象数量，并将其与`cap`数据成员进行比较，以达到相同的效果。
- en: 'We end up with the following `allocate()` implementation, accompanied by the
    corresponding `deallocate()` member function, which is, in this case, effectively
    a no-op:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到以下`allocate()`实现，伴随着相应的`deallocate()`成员函数，在这种情况下，实际上是一个空操作：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As this allocator is stateful, we need to give some thought to allocator equality.
    What we will do in this case is the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个分配器是有状态的，我们需要考虑分配器的等价性。在这种情况下，我们将这样做：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These equality operators make sense at a specific moment in time only, but then
    this allocator type is not really meant to be copied in practice; if you plan
    to use a buffer such as this and share its internal state, you will need to give
    some thought to the way the original and the copy share their internal state and
    remain coherent with one another – something we do not need to do in this case.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些等价运算符只在特定时刻有意义，但这个分配器类型实际上并不打算在实践中进行复制；如果你计划使用这样的缓冲区并共享其内部状态，你需要考虑原始副本和副本之间如何共享内部状态并保持一致性——在这种情况下我们不需要这样做。
- en: 'As you can see, we test for overflow on allocation and throw `std::bad_alloc`
    if an allocation request would lead to a buffer overflow, but that’s only one
    option among others, as we have discussed earlier in this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在分配时测试溢出，如果分配请求会导致缓冲区溢出，则抛出`std::bad_alloc`，但这只是我们之前在本章中讨论的多种选择之一：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are a few things you might want to note at this point:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能需要注意以下几点：
- en: The test code is the same irrespective of the chosen allocator.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码无论选择哪种分配器都是相同的。
- en: When using a stateful allocator, we need to use a parametric constructor that
    accepts the allocator as argument.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用有状态的分配器时，我们需要使用一个参数化构造函数，该构造函数接受分配器作为参数。
- en: The responsibility with respect to the size and alignment of the buffer used
    by the `seq_buf_allocator<T>` falls on the (metaphorical) shoulders of user code.
    Again, remember that this is a specialized tool, so users are expected to know
    what they are doing.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`seq_buf_allocator<T>`时，缓冲区的大小和对齐的责任落在用户代码的（隐喻性）肩膀上。再次提醒，这是一个专业工具，因此预期用户知道自己在做什么。
- en: If you run this test on a conforming compiler, you might notice interesting
    performances with the sequential buffer allocator, and you might notice that `Vector<T,A>`
    outperforms `std::vector<T,A>`, but `Vector<T,A>` is not as complete and rigorous
    as its `std::` counterpart. Prefer the standard facilities in practice.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个符合规范的编译器上运行这个测试，你可能会注意到顺序缓冲区分配器的一些有趣的性能，你可能会注意到`Vector<T,A>`比`std::vector<T,A>`表现更好，但`Vector<T,A>`并不像它的`std::`对应物那样完整和严谨。在实践中，请优先使用标准设施。
- en: There are limitations to the size of the buffer provided to a sequential buffer
    allocator as stack space is a limited resource (often one or two megabytes overall,
    so we have less than this to work with). Still, this technique is useful and used
    in practice in low-latency systems.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于堆栈空间是一种有限的资源（通常总共有一到两个兆字节，所以我们可用的空间少于这个），提供给顺序缓冲区分配器的缓冲区大小有限制。尽管如此，这项技术是有用的，并且在实践中被用于低延迟系统中。
- en: If you apply this sort of allocator with a node-based container list `ForwardList<T,A>`,
    remember that there is a size overhead to each node so plan the size of the buffer
    to provide accordingly.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用基于节点的容器列表`ForwardList<T,A>`来应用这种分配器，请记住，每个节点都有一个大小开销，因此请相应地计划缓冲区的大小。
- en: Of course, that was an implementation that respects C++17 standards. What has
    changed with respect to allocators since then?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那是一个遵守C++17标准的实现。自那时以来，关于分配器的变化有哪些？
- en: Traditional allocators with contemporary standards
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统分配器与当代标准
- en: As mentioned already, the traditional approach of ensconcing the allocator type
    in the associated container type still exists as of this writing, but the way
    allocators themselves are expressed has changed over time, and the allocators
    from the previous section, whether `small_allocator<T>` or `seq_buf_allocator<T>`,
    do not compile as written on a C++20 compiler. Before thinking this is sad, know
    that we can still write these allocators, but we have to write them in a simpler
    manner. Whew!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将分配器类型封装在相关容器类型中的传统方法仍然存在，但分配器本身的表达方式随着时间的推移而发生了变化，并且上一节中的分配器，无论是`small_allocator<T>`还是`seq_buf_allocator<T>`，在C++20编译器上按原样编写是无法编译的。在认为这是令人难过的事情之前，要知道我们仍然可以编写这些分配器，但我们必须以更简单的方式编写它们。呼！
- en: Simplification and the advent of a traits-based implementation
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化与基于特质的实现的出现
- en: The first step in a simplification effort of allocators was the recognition
    that in most cases, a significant part of the code written in an allocator is
    what we call “boilerplate code,” code that is the same from class to class and
    could be qualified as “noise.”
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器简化工作的第一步是认识到，在大多数情况下，分配器中编写的代码中很大一部分是我们所说的“样板代码”，即从类到类相同的代码，可以被认为是“噪音”。
- en: To that effect, C++11 introduced `std::allocator_traits<A>`. The idea is that
    given some `typename A::value_type` type, one can generate a reasonable and efficient
    default implementation for most allocator services (including type aliases such
    as `pointer` or `size_type`) as long as one provides implementations for `allocate()`
    and `deallocate()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，C++11引入了`std::allocator_traits<A>`。其想法是，给定某些`typename A::value_type`类型，只要提供了`allocate()`和`deallocate()`的实现，就可以为大多数分配器服务（包括类型别名，如`pointer`或`size_type`）生成合理且高效的默认实现。
- en: 'Using `small_allocator<T>` as an illustration, we would now be able to simply
    express that entire allocator type with the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以`small_allocator<T>`为例，我们现在可以用以下方式简单地表达整个分配器类型：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, this is quite a simplification! This way, a container such as
    `Vector<T,A>` could now use `std::allocator_traits<A>` instead of `A` directly
    when referring to some allocator `A`’s members. With traits being this very thin
    layer of abstraction that brings no runtime cost to speak of, what they do for
    some member `M` is essentially “If `A` exposes member “`M`, then use `A::M`; otherwise,
    here is some reasonable default implementation instead.” Of course, there will
    be no branching here in practice as everything is determined at compile time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个相当简化的表示！这样，一个容器如`Vector<T,A>`现在可以在引用某些分配器`A`的成员时使用`std::allocator_traits<A>`而不是直接使用`A`。由于特性是一个非常薄的抽象层，几乎不带来任何运行时成本，它们对某些成员`M`所做的是“如果`A`公开了成员`M`，则使用`A::M`；否则，这里有一些合理的默认实现。”当然，在实践中这里不会有分支，因为所有内容都是在编译时确定的。
- en: For example, based on our previous `small_allocator<T>` type, given that `small_allocator<T>::allocate()`
    returns `T*`, then we can determine that `std::allocator_traits<small_allocator<T>>::pointer`
    will be equivalent to `T*`, and a container such as `Vector<T,A>` will make its
    `pointer` type alias correspond to the type expressed by `std::allocator_traits<A>::pointer`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于我们之前的`small_allocator<T>`类型，考虑到`small_allocator<T>::allocate()`返回`T*`，那么我们可以确定`std::allocator_traits<small_allocator<T>>::pointer`将等同于`T*`，并且一个容器如`Vector<T,A>`将使其`pointer`类型别名对应于`std::allocator_traits<A>::pointer`所表示的类型。
- en: 'For another example, `seq_buf_allocator<T>` would now be expressed as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，`seq_buf_allocator<T>`现在可以这样表示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, even though it was not necessary, type `seq_buf_allocator<T>`
    exposes the `pointer` and `size_type` aliases, which means that for this type,
    the `std::allocator_traits` will use the allocator-provided versions instead of
    trying to synthesize an alternative. As you can see, the contemporary traits-based
    approach to allocators is very convenient.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使不是必需的，类型`seq_buf_allocator<T>`也公开了`pointer`和`size_type`别名，这意味着对于此类型，`std::allocator_traits`将使用分配器提供的版本，而不是尝试合成一个替代方案。正如你所看到的，当代基于特性的分配器方法非常方便。
- en: 'What services does type `std::allocator_traits<A>` provide exactly? Well, as
    could be expected, this type exposes the usual type aliases of `value_type` (itself
    being an alias for `A::value_type`), `pointer`, `const_pointer`, `size_type`,
    and `difference_type`. For convenience, it also exposes aliases `allocator_type`
    (equivalent to `A`): `void_pointer` and `const_void_pointer` (respectively equivalent
    to `void*` and `const void*` in most cases). Remember that traits can be specialized,
    and for that reason, these seemingly evident type aliases could map to more exotic
    constructs on occasion.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`std::allocator_traits<A>`究竟提供了哪些服务？嗯，正如预期的那样，此类型公开了`value_type`的常用类型别名（它本身是`A::value_type`的别名），`pointer`，`const_pointer`，`size_type`和`difference_type`。为了方便，它还公开了别名`allocator_type`（相当于`A`）：`void_pointer`和`const_void_pointer`（在大多数情况下分别相当于`void*`和`const
    void*`）。记住，特性可以被特化，因此，这些看似明显的类型别名有时可能会映射到更复杂的结构。
- en: 'Type `std::allocator_traits<A>` also exposes the traditional services of an
    allocator, but in the form of `static` member functions that take the allocator
    as first argument, including `construct()`, `destroy()`, `allocate()`, `deallocate()`,
    and `max_size()`. C++23 adds another `static` member function to this set: `allocate_at_least()`.
    This function returns a `std::allocation_result` object made of the allocated
    pointer and the actual size of the allocated chunk, expressed as a number of objects
    (even though, as usual, there is no object in that memory block after allocation
    has completed).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`std::allocator_traits<A>`还公开了分配器的传统服务，但以`static`成员函数的形式，这些函数将分配器作为第一个参数，包括`construct()`，`destroy()`，`allocate()`，`deallocate()`和`max_size()`。C++23向这个集合中添加了另一个`static`成员函数：`allocate_at_least()`。此函数返回一个由分配的指针和实际分配的块的大小（以对象数量表示）组成的`std::allocation_result`对象，尽管在分配完成后，该内存块中没有对象。
- en: 'The `rebind` mechanism is expressed through types `std::rebind_alloc<A>` and
    `std::rebind_traits<T>`. When cloning an allocation strategy (for node containers,
    mostly), the equivalent of `typename A::rebind<T>::other` through these facilities
    is somewhat more verbose:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`rebind`机制通过类型`std::rebind_alloc<A>`和`std::rebind_traits<T>`来表示。当克隆一个分配策略（对于节点容器来说主要是这样）时，通过这些设施提供的`typename
    A::rebind<T>::other`的等效表示有些冗长：'
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note the presence of the `template` keyword required for grammatical disambiguation
    Yes, I know what you are thinking now: what a complex language! But we rarely
    need to use that keyword in practice, and only in those strange situations where
    the compiler would get confused looking at the following `<` and not knowing whether
    it’s part of a template signature or whether it’s the less-than operator.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到存在`template`关键字，这是为了语法歧义。是的，我知道你现在在想什么：这是一个多么复杂的语言！但在实践中，我们很少需要使用这个关键字，只有在那些编译器会混淆地看到后面的`<`而不知道它是模板签名的一部分还是小于运算符的情况下。
- en: 'There are also new facilities that come with `std::allocator_traits<A>` and
    deal with allocator lifetime management, something we learned to do over the years:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::allocator_traits<A>`带来的新功能外，还有一些处理分配器生命周期管理的新功能，这是我们多年来学会做的：
- en: Three type aliases that inform containers as to what should be done with the
    allocator at key moments in the container’s life. These types are `propagate_on_container_copy_assignment`
    (also known as `propagate_on_container_move_assignment` (also known as `propagate_on_container_swap`
    (also known as `constexpr` functions that yield `true` or `false` (they are equivalent
    to `std::false_type` by default as, by default, allocators are not meant to be
    copied or moved). For example, if an allocator exposes type alias POCMA equivalent
    to `std::true_type`, then a container with that allocator should move the allocator
    along with the allocated data. Note that in all three cases, this trait being
    equivalent to `std::true_type` implies a `noexcept` copy, move, or swap (respectively)
    operation for the allocator.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个类型别名，告知容器在容器生命周期的关键时刻应该对分配器做什么。这些类型是`propagate_on_container_copy_assignment`（也称为`propagate_on_container_move_assignment`，也称为`propagate_on_container_swap`，也称为`constexpr`函数，返回`true`或`false`（默认情况下，它们等同于`std::false_type`，因为默认情况下，分配器不应该被复制或移动）。例如，如果一个分配器公开类型别名POCMA，等同于`std::true_type`，那么使用该分配器的容器应该将分配器与分配的数据一起移动。请注意，在这三种情况下，此特性等同于`std::true_type`意味着分配器的复制、移动或交换操作（分别）是`noexcept`的。
- en: Type alias `is_always_equal`; which means that allocators of that type will
    compare equally irrespective of the type of object to allocate (this alleviates
    the need for `operator==()` and `operator!=()`, which compare two allocators of
    the same template but different `value_type` aliases). Don’t spend too much time
    on this one though; it has been deprecated in C++23 and will most likely be removed
    in C++26.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名`is_always_equal`；这意味着该类型的分配器将不考虑要分配的对象类型进行比较（这减轻了对`operator==()`和`operator!=()`的需求，它们比较相同模板但不同`value_type`别名的两个分配器）。不过，不要在这个问题上花费太多时间；它已经在C++23中被弃用，并且很可能会在C++26中被移除。
- en: The `select_on_container_copy_construction()` member function. This is a `static`
    member function that takes an allocator and copies it if its allocator traits
    express that this is the right thing to do, or returns the original allocator
    otherwise.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select_on_container_copy_construction()`成员函数。这是一个`static`成员函数，它接受一个分配器，如果其分配器特性表明这是正确的事情，则复制它，否则返回原始分配器。'
- en: Okay, this allocator lifetime management is new and might be surprising. What
    do we do with this information?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这种分配器生命周期管理是新的，可能令人惊讶。我们该如何处理这些信息？
- en: Managing traditional allocator lifetime
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理传统分配器生命周期
- en: What should a container do with allocators within a move or a copy operation?
    Well, here are the details.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在移动或复制操作中应该对分配器做什么？好吧，这里有一些细节。
- en: 'In a container’s copy constructor, the best thing to do is probably to use
    `select_on_container_copy_construction()`. It is that function’s purpose, after
    all. Please do not use that function elsewhere: it is really meant for the copy
    constructor of a container. Once the container under construction has obtained
    its allocator, this allocator can be used to perform the remainder of the memory
    allocation tasks.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的复制构造函数中，最好的做法可能是使用`select_on_container_copy_construction()`。毕竟，这是该函数的目的。请勿在其他地方使用该函数：它真正适用于容器的复制构造函数。一旦正在构建的容器获得了其分配器，就可以使用该分配器来执行剩余的内存分配任务。
- en: In a container’s move constructor, the thing to do is move construct the allocator
    and steal the resources from the source container.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的移动构造函数中，要做的就是移动构造分配器，并从源容器中窃取资源。
- en: In a container’s copy assignment operator, if type alias `propagate_on_container_copy_assignment`
    is equivalent to `std::true_type` and both allocators compare unequally, the destination
    container first has to deallocate all memory (that might not be possible later
    on in the process). Past this point, if `propagate_on_container_copy_assignment`
    is equivalent to `std::true_type`, then the allocators should be copy-assigned.
    Only once this is all done should the elements be copied.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的复制赋值运算符中，如果类型别名`propagate_on_container_copy_assignment`等同于`std::true_type`并且两个分配器比较不等，目标容器首先必须释放所有内存（这可能在后续过程中不可能）。超过这个点，如果`propagate_on_container_copy_assignment`等同于`std::true_type`，那么分配器应该被复制赋值。只有完成所有这些，元素才应该被复制。
- en: 'The container’s move assignment operator is trickier (remember that *move*
    is an optimization, and we want it to pay off!). The options we face are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的移动赋值运算符更复杂（记住，*移动*是一种优化，我们希望它能带来回报！）我们面临的选择如下：
- en: Type alias `propagate_on_container_move_assignment` is equivalent to `std::true_type`.
    In this situation, the steps to perform are (a) ensure that the destination container
    deallocates all memory under its responsibility (it might not be able to do so
    later on), (b) move-assign the allocator, and then (c) transfer memory ownership
    from the source container to the destination container.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名`propagate_on_container_move_assignment`等同于`std::true_type`。在这种情况下，要执行的步骤是（a）确保目标容器释放其责任下的所有内存（它可能无法在稍后做到这一点），（b）移动赋值分配器，然后（c）从源容器将内存所有权转移到目标容器。
- en: Type alias `propagate_on_container_move_assignment` is equivalent to `std::false_type`
    and the allocators compare equally. In this situation, you can do the same steps
    as in the previous case but do not move the container.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名`propagate_on_container_move_assignment`等同于`std::false_type`并且分配器比较相等。在这种情况下，你可以执行与上一个案例相同的步骤，但不要移动容器。
- en: Type alias `propagate_on_container_move_assignment` is equivalent to `std::false_type`
    and the allocators compare unequally. In this case, ownership cannot really be
    transferred, so the best one can do is move the objects themselves from the source
    container to the destination container.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名`propagate_on_container_move_assignment`等同于`std::false_type`并且分配器比较不等。在这种情况下，实际上无法转移所有权，所以最好的办法是将对象本身从源容器移动到目标容器。
- en: Luckily, all of these allocator properties can be tested at compile time so
    the decision-making process does not need to incur any runtime cost.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有这些分配器属性都可以在编译时进行测试，因此决策过程不需要产生任何运行时成本。
- en: Things we do for concision…
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了简洁所做的事情...
- en: You will notice our `Vector<T,A>` and `ForwardList<T,A>` types do not do the
    entire “allocator lifetime management dance” in order to keep our examples reasonably
    short, and because the way in which we manage allocator copy and movement is an
    interesting design aspect that would require adding at least one chapter to this
    already rather big book. Please be tolerant, dear reader.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的`Vector<T,A>`和`ForwardList<T,A>`类型没有执行整个“分配器生命周期管理舞蹈”，以使我们的示例保持合理长度，并且因为我们对分配器复制和移动的管理方式是一个有趣的设计方面，这可能会要求在这本已经相当大的书中至少增加一章。请读者宽容，亲爱的读者。
- en: Using traits-based allocators in allocator-aware containers
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在分配器感知容器中使用基于特质的分配器
- en: 'The remaining question with traditional allocators in a traits-based approach
    is: how do containers use them?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于特质的传统分配器中，剩余的问题是：容器如何使用它们？
- en: 'The first thing we will need to do is to adapt our allocator-aware adaptation
    of the standard uninitialized memory algorithms. For example, our personal adaptation
    of `std::uninitialized_copy()` becomes the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是调整我们对标准未初始化内存算法的分配器感知适配。例如，我们个人对`std::uninitialized_copy()`的适配如下：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we are now using `std::allocator_traits<A>` instead of `A` directly,
    opening up customization opportunities, and passing the allocator as first argument
    since the `std::allocator_traits<A>` member functions are all `static`. The same
    adjustment can be applied to the other allocator-aware versions of the algorithms
    we wrote, with the same calling pattern and passing the allocator as first argument.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们现在使用`std::allocator_traits<A>`而不是直接使用`A`，这为定制提供了机会，并且由于`std::allocator_traits<A>`的成员函数都是静态的，所以将分配器作为第一个参数传递。相同的调整可以应用于我们编写的其他分配器感知算法的版本，具有相同的调用模式和将分配器作为第一个参数传递。
- en: 'Then, we reach our `Vector<T,A>` type. How do we adjust its implementation
    to use the contemporary traits-based allocators? The first thing to do is to adjust
    the source of the container’s type aliases:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们到达了`Vector<T,A>`类型。我们如何调整其实现以使用基于特性的现代分配器？首先要做的事情是调整容器的类型别名来源：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might be surprised that type aliases `reference` and `const_reference` are
    not taken from `std::allocator_traits<A>`, but there is a reason for this. In
    C++, as in this writing, we can design types that behave like “smart pointers”
    (we have even done so in this book; see [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096)),
    so an abstraction is useful in case the allocator provides pointers that are not
    raw pointers, but there is no known way to write “smart references” (that would
    require being able to overload `operator.()` and proposals to that effect have
    so far failed to be accepted).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶，类型别名`reference`和`const_reference`并不是从`std::allocator_traits<A>`中获取的，但这是有原因的。在C++中，正如本文所述，我们可以设计出类似“智能指针”的行为的类型（我们甚至在这本书中也这样做过；参见[*第6章*](B21071_06.xhtml#_idTextAnchor096)），因此抽象在分配器提供非原始指针的情况下是有用的，但目前还没有已知的方法来编写“智能引用”（这将需要能够重载`operator.()`，并且关于这一点的提案至今未能被接受）。
- en: The only reference type that behaves like a reference to `T` is… well, `T&`.
    For that reason, these type aliases were deprecated in C++17 and removed in C++20\.
    We can still provide them to clarify our type’s member function signatures, but
    they are no longer required by the standard.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的行为类似于`T`的引用类型的类型是…嗯，`T&`。因此，这些类型别名在C++17中被弃用，并在C++20中被移除。我们仍然可以提供它们来澄清我们的类型成员函数签名，但它们不再是标准所要求的。
- en: 'As far as the member functions of `Vector<T,A>` go, the general idea is that
    all calls to member functions of `A` are replaced with calls to `static` member
    functions of `std::allocator_traits<A>` that take a reference to the `A` object
    as argument (remember that in our `Vector<T,A>` implementation, `A` is a `private`
    base class of the container). Here is an example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Vector<T,A>`的成员函数而言，一般思路是将对`A`成员函数的所有调用替换为对`std::allocator_traits<A>`的`static`成员函数的调用，该函数以对`A`对象的引用作为参数（记住，在我们的`Vector<T,A>`实现中，`A`是容器的`private`基类）。以下是一个示例：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you feel discomfort with the use of `*this` in the data member initializers,
    you can relax as we are only using the `A` part of `*this` and that base class
    sub-object has been fully initialized at that point. It’s a safe part of `*this`
    to use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于在数据成员初始化器中使用`*this`感到不适，你可以放心，因为我们只使用了`*this`的`A`部分，并且在那个点上基类子对象已经被完全初始化。这是`*this`的一个安全部分来使用。
- en: The same adjustment has to be applied throughout the container (in dozens of
    places) and obviously makes the source code more verbose, but the good news is
    that this has gained us a zero-cost-at-runtime layer of abstraction and helped
    everyone who actually writes allocators.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的调整必须应用于整个容器（在数十个地方）并且显然会使源代码更加冗长，但好消息是这为我们获得了一个零运行时成本的抽象层，并帮助了所有实际编写分配器的开发者。
- en: 'For a node-based container such as `ForwardList<T,A>`, the situation is similar
    yet slightly different. For one thing, the type aliases are tricky; some of them
    are meant for user code and should be expressed with respect to the `value_type`
    of the container, and others should be based on the types of the allocator as
    expressed through its traits:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`ForwardList<T,A>`这样的基于节点的容器，情况类似但略有不同。一方面，类型别名很棘手；其中一些是为用户代码设计的，应该根据容器的`value_type`来表示，而其他则应该基于通过其特性表示的分配器类型：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Within the container, we need to rebind `A` to an allocator of our internal
    `Node` type:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部，我们需要将`A`重新绑定到我们内部`Node`类型的分配器：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Past this point, what we will do to perform memory management tasks is use
    `static` member functions from the `std::allocator_traits<Alloc>` type, passing
    the `alloc` data member as argument, as in this example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，我们将使用`std::allocator_traits<Alloc>`类型的`static`成员函数来执行内存管理任务，将`alloc`数据成员作为参数传递，如下例所示：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The same technique needs to be applied throughout the container, of course,
    but the complexity remains the same.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，同样的技术需要应用于整个容器，但复杂性保持不变。
- en: Now that we have seen how traditional allocators, ensconced in the type of their
    container, have evolved from their original (rather involved) contract to their
    contemporary traits-based and simplified implementation (with somewhat more verbose
    containers), it’s tempting to think that we have reached some form of optimality.
    This is both right and wrong.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到，传统的分配器，其位于容器的类型中，已经从其原始的（相当复杂）合同演变为当代基于特性和简化的实现（容器有些冗长），这让人想到我们已经达到了某种形式的优化。这是对也是错。
- en: Irritants with traditional allocators
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统分配器的烦恼
- en: The traditional approach to allocators is optimal at runtime in the sense that
    the services of such an allocator can be called without any overhead, and if an
    allocator is stateless, the introduction of an allocator in a container can be
    achieved without any costs in terms of space. Not bad!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法在运行时对分配器是最佳的，因为可以无开销地调用这种分配器的服务，如果分配器是无状态的，那么在容器中引入分配器在空间上没有成本。还不错！
- en: 'Of course, the absence of runtime costs is not the absence of costs altogether:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有运行时成本并不意味着没有成本：
- en: A container’s implementation can become somewhat complex due to the additional
    (compile-time) layering, and there is a cost to writing, understanding, and maintaining
    source code. This sort of expertise is not universal; you have it, of course,
    dear reader, but others do not necessarily share that upside with you.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于额外的（编译时）分层，容器的实现可能会变得相当复杂，编写、理解和维护源代码都有成本。这种专业知识并非普遍存在；当然，亲爱的读者，您拥有它，但其他人并不一定与您分享这种优势。
- en: Two containers that are identical in essentially every respect but differ in
    the way they manage memory (two containers that use different allocators) will
    in practice be different types, which might slow down compile times in programs
    that have multiple container-allocator combinations.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本质上几乎在所有方面都相同，但在管理内存的方式上不同的两个容器（使用不同分配器的两个容器）在实践中将是不同类型，这可能会在具有多个容器-分配器组合的程序中减慢编译时间。
- en: Some operations that should probably be simple become more complicated. For
    example, if one seeks to compare containers `v0` and `v1` for equality, and if
    `v0` is a `Vector<T,A0>` while `v1` is a `Vector<T,A1>`, then one needs to write
    an `operator==()` function that deals with two different types… even though the
    allocator of a container is probably not one of its salient properties and, as
    such, should not be a concern when comparing two containers with respect to their
    sizes and values.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些可能应该是简单的操作变得更为复杂。例如，如果试图比较容器`v0`和`v1`的相等性，并且如果`v0`是`Vector<T,A0>`而`v1`是`Vector<T,A1>`，那么就需要编写一个`operator==()`函数来处理两种不同的类型……即使容器的分配器可能不是其显著属性之一，并且在这种情况下，在比较两个容器的大小和值时，分配器不应该是关注的焦点。
- en: 'The same reasoning goes for many other container-related operations: an allocator
    is (traditionally) part of its container’s type with the traditional approach,
    but many operations are `value_type`-related and have nothing to do with allocators.
    We are runtime optimal, but we have additional costs with respect to code generation
    complexity (which might lead to bigger binaries, which might have runtime speed
    impacts), and increasing the maintenance effort (including understanding code
    from its source) has a price.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的推理也适用于许多其他与容器相关的操作：在传统方法中，分配器（allocator）是容器类型的一部分，但许多操作与`value_type`相关，与分配器无关。我们是运行时最优的，但我们在代码生成复杂性方面有额外的成本（这可能导致更大的二进制文件，可能会影响运行速度），并且增加维护工作量（包括理解代码的源代码）也有代价。
- en: Even something as seemingly simple as making allocators type-aware (traditional
    allocators are allocators of `T` for some type `T` after all) is sometimes controversial.
    Low-level memory allocation functions such as `std::malloc()` or `::operator new()`
    deal in raw bytes after all, so is it a sign that our traditional allocator model
    is perfectible?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 即使像使分配器类型感知（毕竟，传统的分配器是某些类型`T`的分配器`T`）这样看似简单的事情有时也是具有争议的。毕竟，低级内存分配函数如`std::malloc()`或`::operator
    new()`是在处理原始字节，所以这是否意味着我们的传统分配器模型是可完善的？
- en: Polymorphic memory resource allocators
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态内存资源分配器
- en: With C++17, the C++ language added so-called PMR allocators. A PMR container
    stores allocator information as a runtime value, not as a compile-time part of
    its type. In this model, a PMR container holds a pointer to a PMR allocator, reducing
    the number of types required but adding virtual function calls whenever using
    memory allocation services.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，C++ 语言添加了所谓的 PMR 分配器。PMR 容器将分配器信息存储为运行时值，而不是其类型的编译时部分。在这个模型中，PMR 容器包含一个指向
    PMR 分配器的指针，减少了所需的类型数量，但在使用内存分配服务时增加了虚拟函数调用。
- en: 'This is again not a no-cost decision, and there are trade-offs with the traditional
    model:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次不是无成本的决策，并且与传统模型相比存在权衡：
- en: This new allocator model supposes that containers store a pointer to an allocation
    strategy, which generally (not always) makes PMR containers larger than their
    non-PMR counterparts. Interestingly, it also means that a `std::pmr::vector<T>`
    is a different container from a `std::vector<T>`, which sometimes causes very
    real annoyances. For example, there is no implicit way to copy the contents of
    a `std::pmr::string` into a `std::string`, but luckily, writing such a function
    is very easy.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种新的分配器模型假设容器存储一个指向分配策略的指针，这通常（但不总是）使得 PMR 容器比它们的非 PMR 对应物更大。有趣的是，这也意味着 `std::pmr::vector<T>`
    与 `std::vector<T>` 是不同的容器，这有时会导致非常真实的不便。例如，没有隐式的方法可以将 `std::pmr::string` 的内容复制到
    `std::string` 中，但幸运的是，编写这样的函数非常简单。
- en: Every allocation or deallocation service call incurs a polymorphic indirection
    cost. This will be minor to unnoticeable in programs where the called function
    performs some significant computation, but the same costs can be painful when
    the called function performs little computation.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次分配或释放服务调用都会产生多态间接成本。在调用函数执行一些重要计算的程序中，这可能是微不足道的，但当调用函数执行的计算很少时，相同的成本可能会很痛苦。
- en: PMR containers are parameterized on memory resources, and PMR memory resources
    trade in bytes, not in objects. It’s unclear whether this is a good thing or a
    bad thing (it’s probably a matter of perspective), as both approaches work, but
    trading in bytes (the simplest common denominator) makes it easier to reduce the
    number of types in a program.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMR 容器在内存资源上参数化，PMR 内存资源以字节为单位进行交易，而不是以对象为单位。这不清楚这是好事还是坏事（这可能是视角的问题），但两种方法都有效，但以字节（最简单的共同分母）进行交易使得减少程序中的类型数量更容易。
- en: 'There are also advantages to the PMR approach:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: PMR 方法也有其优势：
- en: The type of a container is not influenced by the type of its allocator. All
    PMR containers simply hold a pointer to the base class of all PMR memory resources
    named `std::pmr::memory_resource`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的类型不受其分配器类型的影响。所有 PMR 容器仅持有指向所有 PMR 内存资源基类 `std::pmr::memory_resource` 的指针。
- en: The work required to implement a PMR allocator is very small as one only needs
    to override three virtual member functions. This opens up avenues to express reusable
    allocator libraries, for example.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 PMR 分配器所需的工作非常小，因为只需要重写三个虚拟成员函数。这为表达可重用分配器库开辟了途径，例如。
- en: Under the PMR model, a `std::pmr::polymorphic_allocator<T>` object uses a `std::pmr::memory_resource*`
    to determine how memory is managed. In most cases, when designing a memory allocation
    strategy, what one does is write a class that specializes `std::memory_resource`
    and determines what it means to allocate or deallocate memory with that strategy.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PMR 模型下，一个 `std::pmr::polymorphic_allocator<T>` 对象使用一个 `std::pmr::memory_resource*`
    来确定内存是如何管理的。在大多数情况下，当设计内存分配策略时，你所做的是编写一个专门化 `std::memory_resource` 的类，并确定使用该策略分配或释放内存的含义。
- en: 'Let’s look at a simple example of a PMR container with a sequential buffer
    memory resource, as we just implemented such a mechanism with traditional allocators:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 PMR 容器示例，它具有顺序缓冲区内存资源，正如我们刚刚使用传统分配器实现了这样的机制：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That’s quite simple, isn’t it? You might want to pay attention to the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，不是吗？你可能需要注意以下几点：
- en: This program aims to “allocate” objects in a byte buffer located on the thread’s
    execution stack. With these objects being of type `int`, we ensure that buffer
    `buf` is appropriately aligned and is of sufficient size to hold the objects that
    are meant to be stored therein.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序旨在在线程执行栈上的字节数组中“分配”对象。由于这些对象是 `int` 类型，我们确保缓冲区 `buf` 适当对齐，并且足够大，可以容纳要存储的对象。
- en: A `std::pmr::monotonic_buffer_resource` object named `res` knows where the buffer
    to manage starts and how big it is. It represents a perspective on contiguous
    memory.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `res` 的 `std::pmr::monotonic_buffer_resource` 对象知道要管理的缓冲区从哪里开始以及有多大。它代表了对连续内存的视角。
- en: The `std::pmr::vector<int>` used in this program knows about `res` and uses
    that resource to allocate and deallocate memory.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个程序中使用的 `std::pmr::vector<int>` 了解 `res` 并使用该资源来分配和释放内存。
- en: That’s all there is to it. In practice, this program does not allocate even
    a single byte from the free store in order to store the `int` objects. Compared
    to what we had to do to achieve similar effects in the past, this might seem rejoiceful
    somewhat. At the end of the program, iterating through the byte buffer and iterating
    through the container yield the same results.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。实际上，这个程序甚至没有从自由存储中分配一个字节来存储 `int` 对象。与过去为了达到类似效果所必须做的事情相比，这可能会让人感到有些欣慰。在程序结束时，遍历字节数组和遍历容器会产生相同的结果。
- en: That works nicely and requires very little coding effort, but what if we wanted
    to express something like a vector of `string` objects but wanted both the vector
    and the `string` objects it stores to use the same allocation strategy?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，并且几乎不需要编写代码，但如果我们想表达类似 `string` 对象的向量，同时希望向量和它存储的 `string` 对象都使用相同的分配策略怎么办？
- en: Nested allocators
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套分配器
- en: 'Well, it so happens that PMR allocators propagate allocation strategies by
    default. Consider the following example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，碰巧 PMR 分配器默认会传播分配策略。考虑以下示例：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This example also uses a buffer on the stack, but that buffer is used both for
    the `std::pmr::vector` object and its metadata and for the `std::string` objects
    therein. Propagation of the allocation strategy from the enclosing container to
    the enclosed containers is implicit.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也使用堆栈上的缓冲区，但该缓冲区既用于 `std::pmr::vector` 对象及其元数据，也用于其中的 `std::string` 对象。从封装容器到封装容器的分配策略传播是隐式的。
- en: Do note that the `make_str` lambda expression in that program is used to convert
    `std::string` (formatted to end with an integer) to a `std::pmr::string`. As mentioned
    earlier, the integration of types from namespace `std` and types from namespace
    `std::pmr` sometimes requires a little bit of effort, but the APIs of classes
    in these namespaces are sufficiently similar for this effort to remain reasonable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该程序中的 `make_str` lambda 表达式用于将格式化后以整数结尾的 `std::string` 转换为 `std::pmr::string`。如前所述，从
    `std` 命名空间和 `std::pmr` 命名空间中集成类型有时需要一点努力，但这两个命名空间中类的 API 足够相似，使得这种努力仍然是合理的。
- en: If you use this program, you will notice that the `std::pmr::string` objects
    contain the expected text, but you will also probably notice from the last loop
    that buffer `buf` contains (among other things) the text in the strings. That’s
    because our strings are rather short and, in most standard library implementations,
    the `std::pmr::string` instead of being allocated separately. This shows clearly
    that the same allocation strategy, represented by our object of type `std::pmr::monotonic_buffer_resource`,
    has propagated from the `std::pmr::vector` object to the enclosed `std::pmr::string`
    objects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这个程序，你会注意到 `std::pmr::string` 对象包含预期的文本，但你也许也会从最后一个循环中注意到缓冲区 `buf` 包含（以及其他事物）字符串中的文本。这是因为我们的字符串相当短，并且在大多数标准库实现中，`std::pmr::string`
    并不是单独分配的。这清楚地表明，由我们的 `std::pmr::monotonic_buffer_resource` 类型的对象表示的相同分配策略已经从 `std::pmr::vector`
    对象传播到了封装的 `std::pmr::string` 对象。
- en: Scoped allocators and the traditional model
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域分配器和传统模型
- en: It is possible to use a scoped allocator system with the traditional allocator
    approach, even though we did not do so in this book. If you are curious, feel
    free to explore type `std::scoped_allocator_adapter` for more information.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这本书中没有这样做，但使用传统的分配器方法，仍然可以使用作用域分配器系统。如果你好奇，可以自由地探索类型 `std::scoped_allocator_adapter`
    以获取更多信息。
- en: We will now look at one last example that uses allocators to track the memory
    allocation process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看最后一个示例，该示例使用分配器来跟踪内存分配过程。
- en: Allocators and data collection
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配器和数据收集
- en: As we saw in [*Chapter 8*](B21071_08.xhtml#_idTextAnchor128) when we wrote our
    own humble yet functional leak detector, memory management tools are often used
    to gather information. For a non-exhaustive list, know that some companies use
    them to track memory fragmentation or otherwise assess where objects are placed
    in memory, maybe in a quest to optimize cache usage. Others want to evaluate when
    and where allocations occur in the course of program execution to know whether
    a reorganization of the code could lead to better performances. Of course, detecting
    leaks is useful, but we already knew that.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第8章*](B21071_08.xhtml#_idTextAnchor128)中编写我们自己的谦逊但功能性的泄漏检测器时所看到的，内存管理工具通常用于收集信息。对于非详尽的列表，要知道一些公司使用它们来跟踪内存碎片化或评估对象在内存中的位置，可能是在寻求优化缓存使用。其他人想要评估在程序执行过程中何时何地发生分配，以了解代码重组是否可能导致更好的性能。当然，检测泄漏是有用的，但我们已经知道了这一点。
- en: 'As our third and last example of PMR allocation usage, we will implement a
    *tracing resource*, in the sense that we will track allocation and deallocation
    requests from a container to understand some implementation choices made by that
    container. For the sake of this example, we will use a standard library’s `std::pmr::vector`
    and try to understand its approach to increasing its capacity when trying to insert
    objects into a full container. Remember that the standard mandates an amortized
    constant complexity for operations such as `push_back()`, meaning that capacity
    should grow rarely and most insert-at-end operations should take constant time.
    However, it does not impose a specific growth policy: for example, one implementation
    could grow by a factor of 2, another by a factor of 1.5, and another could prefer
    1.67\. Other options exist; each one has trade-offs, and each library makes its
    own choices.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PMR分配使用的第三个也是最后一个示例，我们将实现一个*跟踪资源*，也就是说，我们将跟踪容器从分配和释放请求，以了解该容器所做的某些实现选择。为了这个示例，我们将使用标准库的`std::pmr::vector`并尝试理解它在尝试向满容器插入对象时增加其容量的方法。记住，标准要求操作如`push_back()`具有摊销常数复杂度，这意味着容量应该很少增长，并且大多数插入操作应该花费常数时间。然而，它并没有强制特定的增长策略：例如，一个实现可能以2的倍数增长，另一个可能以1.5的倍数增长，另一个可能更倾向于1.67。其他选项也存在；每个选项都有其权衡，每个库都做出自己的选择。
- en: 'We will express this tool as class `tracing_resource`, which derives from `std::pmr::memory_resource`
    as expected by `std::pmr` containers. This lets us show how easy it is to add
    a memory resource type to this framework:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个工具表示为类`tracing_resource`，它从`std::pmr::memory_resource`派生，正如`std::pmr`容器所期望的那样。这使得我们能够展示如何轻松地将内存资源类型添加到这个框架中：
- en: 'The base class exposes three member functions that we need to override: `do_allocate()`,
    which is meant to perform an allocation request, `do_deallocate()`, whose role
    is, unsurprisingly, to deallocate memory that is presumed to have been allocated
    through `do_allocate()`, and `do_is_equal()`, which is meant to let user code
    test two memory resources for equality. Note that “equality” in this sense means
    that memory allocated from one could be deallocated from the other.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类公开了三个需要重写的成员函数：`do_allocate()`，它旨在执行分配请求，`do_deallocate()`，其角色是，不出所料，释放通过`do_allocate()`分配的内存，以及`do_is_equal()`，它旨在让用户代码测试两个内存资源是否相等。请注意，在这种意义上的“相等”意味着从一个分配的内存可以从另一个中释放。
- en: Since we want to trace allocation requests but do not want to implement an actual
    memory allocation strategy ourselves, we will use an `upstream` resource that
    will do the allocation and deallocation for us. In our test implementation, that
    resource will be a global resource obtained from `std::pmr::new_delete_resource()`
    that calls `::operator new()` and `::operator delete()` to achieve this objective.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们想要跟踪分配请求，但又不想自己实现实际的内存分配策略，我们将使用一个`upstream`资源，它会为我们进行分配和释放。在我们的测试实现中，这个资源将是一个全局资源，通过`std::pmr::new_delete_resource()`获得，该资源调用`::operator
    new()`和`::operator delete()`来实现这一目标。
- en: For this reason, our allocation functions will simply “log” (in our case, print)
    the requested allocation and deallocation sizes, then delegate the allocation
    work to the `upstream` resource.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们的分配函数将简单地“记录”（在我们的情况下，打印）请求的分配和释放大小，然后将分配工作委托给`upstream`资源。
- en: 'A complete implementation follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的实现如下：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you run this very simple program, you will develop an intuition for the growth
    strategy of your standard library `std::pmr::vector` implementation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个非常简单的程序，你将能够对标准库 `std::pmr::vector` 实现的增长策略有一个直观的认识。
- en: Upsides and costs
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和成本
- en: As we have seen, there’s a lot to love about the PMR model. It is simple to
    use, relatively simple to understand, and easy to extend. In many application
    domains, it is fast enough to meet most programmers’ needs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，PMR 模型有很多值得称赞的地方。它使用简单，相对容易理解，并且易于扩展。在许多应用领域，它的速度足够快，可以满足大多数程序员的需。
- en: 'There are, of course, also domains that need the increased control over execution
    time and runtime behavior that the traditional allocator model allows: no indirection
    that stems from the model, no overhead in terms of object size… Sometimes, you
    just need all the control you can get. This means that both models work and have
    their own valid reasons for being.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些领域需要传统分配器模型提供的对执行时间和运行时行为的增加控制：没有来自模型的间接引用，没有对象大小方面的开销……有时，你只需要尽可能多的控制。这意味着这两种模型都有效，并且都有其存在的合理理由。
- en: 'One very real benefit of PMR allocators is that they make it easier to build
    allocator and resource libraries that one can combine and build from. The standard
    library offers a few useful examples from the `<``memory_resource>` header:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: PMR 分配器的一个非常实际的优点是，它们使得构建可以组合和构建的分配器和资源库变得更容易。标准库从 `<memory_resource>` 头文件提供了一些有用的示例：
- en: We have already seen function `std::pmr::new_delete_resource()`, which provides
    a system-wide resource where allocation and deallocation are implemented through
    `::operator new()` and `::operator delete()`, just as we have seen class `std::pmr::monotonic_buffer_resource`,
    which formalizes the process of sequential allocation within an existing buffer.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了函数 `std::pmr::new_delete_resource()`，它提供了一个系统范围内的资源，其中分配和释放是通过 `::operator new()`
    和 `::operator delete()` 实现的，就像我们看到的 `std::pmr::monotonic_buffer_resource` 类，它正式化了在现有缓冲区内部进行顺序分配的过程。
- en: The `std::pmr::synchronized_pool_resource` and `std::pmr::unsynchronized_pool_resource`
    classes model the allocation of objects from pools of blocks of some sizes. Use
    the synchronized one for multithreaded code, of course.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::pmr::synchronized_pool_resource` 和 `std::pmr::unsynchronized_pool_resource`
    类模拟从某些大小的块池中分配对象。当然，对于多线程代码，使用同步的版本。'
- en: There are `std::pmr::get_default_resource()` and `std::pmr::set_default_resource()`
    functions that respectively obtain or replace the default memory resource of a
    program. The default memory resource is, as could be expected, the same as what
    is returned by function `std::pmr::new_delete_resource()`.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有 `std::pmr::get_default_resource()` 和 `std::pmr::set_default_resource()` 函数，分别获取或替换程序的默认内存资源。默认内存资源，正如预期的那样，与
    `std::pmr::new_delete_resource()` 函数返回的内容相同。
- en: 'There is also a function `std::pmr::null_memory_resource()` that returns a
    resource that never allocates (its `do_allocate()` member function, when called,
    throws `std::bad_alloc`). This is interesting as an “upstream” measure: consider
    a sequential buffer allocator system implemented through `std::pmr::monotonic_buffer_resource`
    in which a request for memory allocation leads to a possible buffer overflow.
    Since, by default, the `upstream` of a memory resource uses another resource that
    calls `::operator new()` and `::operator delete()`, this potential overflow will
    lead to an actual allocation, which could have an undesirable impact on performance.
    Choosing a `std::pmr::null_memory_resource` for the `upstream` resource ensures
    no such allocation will occur.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个函数 `std::pmr::null_memory_resource()`，它返回一个永远不会分配资源的对象（其 `do_allocate()`
    成员函数在调用时抛出 `std::bad_alloc` 异常）。这作为一个“上游”措施是很有趣的：考虑一个通过 `std::pmr::monotonic_buffer_resource`
    实现的顺序缓冲区分配器系统，其中对内存分配的请求可能导致缓冲区溢出。由于默认情况下，内存资源的“上游”使用另一个调用 `::operator new()`
    和 `::operator delete()` 的资源，这种潜在的溢出将导致实际的分配，这可能会对性能产生不良影响。为“上游”资源选择 `std::pmr::null_memory_resource`
    确保不会发生此类分配。
- en: As we have seen and done, it is simple to add to this small set of memory resources
    and customize the behavior of your containers to suit your needs with the PMR
    model.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到和执行的，通过 PMR 模型添加到这个小集合的内存资源并定制容器的行为以适应你的需求是很容易的。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This has been an eventful chapter, has it not? After venturing into explicit
    and implicit memory allocation implementations in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172)
    and [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187), this chapter explored allocators
    and how these facilities let us customize the behavior of memory allocation in
    containers to match our needs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个充满事件的一章，不是吗？在[*第12章*](B21071_12.xhtml#_idTextAnchor172)和[*第13章*](B21071_13.xhtml#_idTextAnchor187)中探讨了显式和隐式内存分配实现之后，本章探讨了分配器以及这些设施如何让我们定制容器中内存分配的行为以满足我们的需求。
- en: We saw how a traditional allocator, ensconced in the type of its enclosing container,
    can be implemented and used. We did so with a container that trades in contiguous
    memory as well as with a node-based container. We also looked at how the task
    of writing (and using) such allocators evolved through the years to become the
    contemporary traits-based allocators that implicitly synthesize default implementations
    for most allocator services.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一个传统的分配器，它嵌入在其封装容器的类型中，是如何实现和使用的。我们使用了一个以连续内存为交易条件的容器，以及一个基于节点的容器。我们还探讨了编写（和使用）此类分配器的任务是如何随着时间演变，最终成为当代基于特性的分配器，这些分配器隐式地综合了大多数分配器服务的默认实现。
- en: We then looked at the more recent PMR allocator model that represents a different
    take on memory allocation and discussed its upsides and downsides. Equipped with
    the knowledge in this chapter, you should have ideas of ways in which containers
    can be customized to meet your needs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后研究了较新的PMR分配器模型，它代表了内存分配的不同观点，并讨论了其优点和缺点。凭借本章的知识，你应该有了关于如何定制容器以满足你需求的想法。
- en: We are nearing the end of our journey. In our next (and last) chapter, we will
    look at some contemporary problems of memory allocation in C++ and start to think
    about what awaits us in the near future.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程即将结束。在下一章（也是最后一章）中，我们将探讨C++中内存分配的一些当代问题，并开始思考近未来等待我们的是什么。
