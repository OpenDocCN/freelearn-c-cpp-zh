<html><head></head><body>
  <div id="_idContainer024">
   <h1 class="chapter-number" id="_idParaDest-36">
    <a id="_idTextAnchor035">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     2
    </span>
   </h1>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor036">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Processes, Threads, and Services
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Asynchronous programming involves initiating operations without waiting for them to complete before moving on to the next task.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     This non-blocking behavior allows for developing highly responsive and efficient applications, capable of handling numerous operations simultaneously without unnecessary delays or wasting computational resources waiting for tasks to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      be finished.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Asynchronous programming is very important, especially in the development of networked applications, user interfaces, and systems programming.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     It enables developers to
    </span>
    <a id="_idIndexMarker087">
    </a>
    <span class="koboSpan" id="kobo.6.1">
     create applications that can manage high volumes of requests, perform
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      Input/Output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     ) operations, or execute concurrent tasks efficiently, thereby significantly enhancing user experience and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      application performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     The Linux operating system (in this book, we will focus on development on the Linux operating system when the code cannot be platform-independent), with its robust process management, native support for threading, and advanced I/O capabilities, is an ideal environment for developing high-performance asynchronous applications.
    </span>
    <span class="koboSpan" id="kobo.12.2">
     These systems offer
    </span>
    <a id="_idIndexMarker088">
    </a>
    <span class="koboSpan" id="kobo.13.1">
     a rich set of features such as powerful APIs for process and thread management, non-blocking I/O, and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.14.1">
      Inter-Process Communication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.15.1">
     (
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.16.1">
       IPC
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      ) mechanisms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     This chapter is an introduction to the fundamental concepts and components essential for asynchronous programming within the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      Linux environment.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     We will explore the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      Processes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       in Linux
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Services
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       and daemons
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Threads
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       and concurrency
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     By the end of this chapter, you will possess a foundational understanding of the asynchronous programming landscape in Linux, setting the stage for deeper exploration and practical application in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      subsequent chapters.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-38">
    <a id="_idTextAnchor037">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     Processes in Linux
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.31.1">
     A process can be defined as an instance of a running program.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     It includes the program’s code, all the
    </span>
    <a id="_idIndexMarker089">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     threads belonging to this process (which are represented by the program counter), the stack (which is an area of memory containing temporary data such as function parameters, return addresses, and local variables), the heap, for memory allocated dynamically, and its data section containing global variables and initialized variables.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     Each process operates within its own virtual address space and is isolated from other processes, ensuring that its operations do not interfere directly with those
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      of others.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-39">
    <a id="_idTextAnchor038">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     Process life cycle – creation, execution, and termination
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.35.1">
     The life cycle
    </span>
    <a id="_idIndexMarker090">
    </a>
    <span class="koboSpan" id="kobo.36.1">
     of a process can be broken down into three primary stages: creation, execution,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      and termination:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.38.1">
       Creation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.39.1">
      : A new
     </span>
     <a id="_idIndexMarker091">
     </a>
     <span class="koboSpan" id="kobo.40.1">
      process is created using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.41.1">
       fork()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.42.1">
      system call, which creates a new process by duplicating an existing one.
     </span>
     <span class="koboSpan" id="kobo.42.2">
      The parent process is the one that calls
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.43.1">
       fork()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.44.1">
      , and the newly created process is the child.
     </span>
     <span class="koboSpan" id="kobo.44.2">
      This mechanism is essential for the execution of new programs within the system and is a precursor to executing different
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.45.1">
       tasks concurrently.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.46.1">
       Execution
      </span>
     </strong>
     <span class="koboSpan" id="kobo.47.1">
      : After
     </span>
     <a id="_idIndexMarker092">
     </a>
     <span class="koboSpan" id="kobo.48.1">
      creation, the child process may execute the same code as the parent or use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.49.1">
       exec()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.50.1">
      family of system calls to load and run a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.51.1">
       different program.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.52.1">
       If the parent process has more than one thread of execution, only the thread calling
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.53.1">
        fork()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.54.1">
       is duplicated in the child process.
      </span>
      <span class="koboSpan" id="kobo.54.2">
       Consequently, the child process contains a single thread: the one that executed the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.55.1">
        fork()
       </span>
      </strong>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.56.1">
        system call.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.57.1">
       Since only the thread that called
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.58.1">
        fork()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.59.1">
       is copied to the child, any
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.60.1">
        Mutual Exclusions
       </span>
      </strong>
      <span class="koboSpan" id="kobo.61.1">
       (
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.62.1">
        mutexes
       </span>
      </strong>
      <span class="koboSpan" id="kobo.63.1">
       ), condition variables, or other synchronization primitives
      </span>
      <a id="_idIndexMarker093">
      </a>
      <span class="koboSpan" id="kobo.64.1">
       that were held by other threads at the time of the fork remain in their then-current state in the parent but do not carry over to the child.
      </span>
      <span class="koboSpan" id="kobo.64.2">
       This can lead to complex synchronization issues, as mutexes
      </span>
      <a id="_idIndexMarker094">
      </a>
      <span class="koboSpan" id="kobo.65.1">
       that were locked by other threads (which do not exist in the child) might remain in a locked state, potentially causing deadlocks if the child tries to unlock or wait on
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.66.1">
        these primitives.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.67.1">
       At this stage, the process performs its designated operations such as reading from or writing to files and communicating with
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.68.1">
        other processes.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.69.1">
       Termination
      </span>
     </strong>
     <span class="koboSpan" id="kobo.70.1">
      : A
     </span>
     <a id="_idIndexMarker095">
     </a>
     <span class="koboSpan" id="kobo.71.1">
      process terminates either voluntarily, by calling the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.72.1">
       exit()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.73.1">
      system call, or involuntarily, due to receiving a signal from another process that causes it to stop.
     </span>
     <span class="koboSpan" id="kobo.73.2">
      Upon termination, the process returns an exit status to its parent process and releases its resources back to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.74.1">
       the system.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     The process life cycle is integral to asynchronous operations as it enables the concurrent execution of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      multiple tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Each process is
    </span>
    <a id="_idIndexMarker096">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     uniquely identified by a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.79.1">
      Process ID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.81.1">
      PID
     </span>
    </strong>
    <span class="koboSpan" id="kobo.82.1">
     ), an integer that the kernel uses to manage processes.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     PIDs are used to control and monitor processes.
    </span>
    <span class="koboSpan" id="kobo.82.3">
     Parent processes also use PIDs to communicate with or control the execution of child processes, such as waiting for them to terminate or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      sending signals.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     Linux provides mechanisms for process control and signaling, allowing processes to be managed and communicated with asynchronously.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     Signals are one of the primary means of IPC, enabling processes to interrupt or to be notified of events.
    </span>
    <span class="koboSpan" id="kobo.84.3">
     For example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      kill
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     command can send signals to stop a process or to prompt it to reload its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      configuration files.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     Process scheduling is how the Linux kernel allocates CPU time to processes.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     The scheduler determines which process runs at any given time, based on scheduling algorithms and policies that aim to optimize for factors such as responsiveness and efficiency.
    </span>
    <span class="koboSpan" id="kobo.88.3">
     Processes can be in various states, such as running, waiting, or stopped, and the scheduler transitions them between these states to manage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.89.1">
      execution efficiently.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor039">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     Exploring IPC
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     In the Linux operating system, processes operate in isolation, meaning that they cannot directly
    </span>
    <a id="_idIndexMarker097">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     access the memory space of other processes.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     This isolated nature of processes presents challenges when multiple processes
    </span>
    <a id="_idIndexMarker098">
    </a>
    <span class="koboSpan" id="kobo.93.1">
     need to communicate and synchronize their actions.
    </span>
    <span class="koboSpan" id="kobo.93.2">
     To address these challenges, the Linux kernel provides a versatile set of IPC mechanisms.
    </span>
    <span class="koboSpan" id="kobo.93.3">
     Each IPC mechanism is tailored to suit different scenarios and requirements, enabling developers to build complex, high-performance applications that leverage asynchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      processing effectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     Understanding these IPC techniques is crucial for developers aiming to create scalable and efficient applications.
    </span>
    <span class="koboSpan" id="kobo.95.2">
     IPC allows processes to exchange data, share resources, and coordinate their activities, facilitating smooth and reliable communication between different components of a software system.
    </span>
    <span class="koboSpan" id="kobo.95.3">
     By utilizing the appropriate IPC mechanism, developers can achieve improved throughput, reduced latency, and enhanced concurrency in their applications, leading to better performance and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.96.1">
      user experiences.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     In a multitasking environment, where multiple processes run concurrently, IPC plays a vital role in enabling the efficient and coordinated execution of tasks.
    </span>
    <span class="koboSpan" id="kobo.97.2">
     For example, consider a web server application that handles multiple concurrent requests from clients.
    </span>
    <span class="koboSpan" id="kobo.97.3">
     The web server process might use IPC to communicate with the child processes responsible for processing each request.
    </span>
    <span class="koboSpan" id="kobo.97.4">
     This approach allows the web server to handle multiple requests simultaneously, improving the overall performance and scalability of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     Another common scenario where IPC is essential is in distributed systems or microservice architectures.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     In such environments, multiple independent processes or services need to communicate and collaborate to achieve a common goal.
    </span>
    <span class="koboSpan" id="kobo.99.3">
     IPC mechanisms
    </span>
    <a id="_idIndexMarker099">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     such as message queues and sockets or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.101.1">
      Remote Procedure Calls
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.103.1">
      RPCs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     ) enable these processes to exchange messages, invoke methods on remote objects, and synchronize their actions, ensuring seamless and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      reliable IPC.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     By leveraging the IPC mechanisms provided by the Linux kernel, developers can design systems where multiple processes can work together harmoniously.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     This enables the creation of complex, high-performance applications that utilize system resources efficiently, handle concurrent tasks effectively, and scale to meet increasing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      demands effortlessly.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.108.1">
     IPC mechanisms in Linux
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     Linux supports several IPC mechanisms, each with its unique characteristics and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      use cases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     The
    </span>
    <a id="_idIndexMarker100">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     fundamental IPC mechanisms supported by the Linux operating system include shared memory, which is commonly employed for process communication on a single server, and sockets, which facilitate inter-server communication.
    </span>
    <span class="koboSpan" id="kobo.112.2">
     There are other mechanisms (which are briefly described here), but shared memory and sockets are the most
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      commonly used:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.114.1">
       Pipes and named pipes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.115.1">
      : Pipes
     </span>
     <a id="_idIndexMarker101">
     </a>
     <span class="koboSpan" id="kobo.116.1">
      are one of the simplest forms of IPC, allowing for
     </span>
     <a id="_idIndexMarker102">
     </a>
     <span class="koboSpan" id="kobo.117.1">
      unidirectional communication between
     </span>
     <a id="_idIndexMarker103">
     </a>
     <span class="koboSpan" id="kobo.118.1">
      processes.
     </span>
     <span class="koboSpan" id="kobo.118.2">
      A named pipe, or
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.119.1">
       First-in-First-out
      </span>
     </strong>
     <span class="koboSpan" id="kobo.120.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.121.1">
       FIFO
      </span>
     </strong>
     <span class="koboSpan" id="kobo.122.1">
      ), extends this concept by providing a pipe that is accessible via a name in the filesystem, allowing unrelated processes
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.123.1">
       to communicate.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.124.1">
       Signals
      </span>
     </strong>
     <span class="koboSpan" id="kobo.125.1">
      : Signals
     </span>
     <a id="_idIndexMarker104">
     </a>
     <span class="koboSpan" id="kobo.126.1">
      are a form of software interrupt that can be sent to a process to notify it of events.
     </span>
     <span class="koboSpan" id="kobo.126.2">
      While they are not a method for transferring data, signals are useful for controlling process behavior and triggering actions
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.127.1">
       within processes.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.128.1">
       Message queues
      </span>
     </strong>
     <span class="koboSpan" id="kobo.129.1">
      : Message
     </span>
     <a id="_idIndexMarker105">
     </a>
     <span class="koboSpan" id="kobo.130.1">
      queues allow processes to exchange messages in a FIFO manner.
     </span>
     <span class="koboSpan" id="kobo.130.2">
      Unlike pipes, message queues support asynchronous communication, whereby messages are stored in a queue and can be retrieved by the receiving process at
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.131.1">
       its convenience.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.132.1">
       Semaphores
      </span>
     </strong>
     <span class="koboSpan" id="kobo.133.1">
      : Semaphores are used for synchronization, helping processes manage
     </span>
     <a id="_idIndexMarker106">
     </a>
     <span class="koboSpan" id="kobo.134.1">
      access to shared resources.
     </span>
     <span class="koboSpan" id="kobo.134.2">
      They prevent race conditions by ensuring that only a specified number of processes can access a resource at any
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.135.1">
       given time.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.136.1">
       Shared memory
      </span>
     </strong>
     <span class="koboSpan" id="kobo.137.1">
      : Shared
     </span>
     <a id="_idIndexMarker107">
     </a>
     <span class="koboSpan" id="kobo.138.1">
      memory is a fundamental concept in IPC that enables multiple processes to access and manipulate the same segment of physical memory.
     </span>
     <span class="koboSpan" id="kobo.138.2">
      It offers a blazing-fast method for exchanging data between different processes, reducing the need for time-consuming data copying operations.
     </span>
     <span class="koboSpan" id="kobo.138.3">
      This technique is particularly advantageous when dealing with large datasets or requiring high-speed communication.
     </span>
     <span class="koboSpan" id="kobo.138.4">
      The mechanism of shared memory involves creating a shared memory segment, which is a dedicated portion of physical memory accessible by multiple processes.
     </span>
     <span class="koboSpan" id="kobo.138.5">
      This shared memory segment is treated as a common workspace, allowing processes to read, write, and collaboratively modify data.
     </span>
     <span class="koboSpan" id="kobo.138.6">
      To ensure data integrity and prevent conflicts, shared memory requires synchronization mechanisms such as semaphores or mutexes.
     </span>
     <span class="koboSpan" id="kobo.138.7">
      These mechanisms regulate access to the shared memory segment, preventing multiple processes from simultaneously modifying the same data.
     </span>
     <span class="koboSpan" id="kobo.138.8">
      This coordination is crucial to maintain data consistency and avoid overwriting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.139.1">
       or corruption.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.140.1">
       Shared
      </span>
      <a id="_idIndexMarker108">
      </a>
      <span class="koboSpan" id="kobo.141.1">
       memory is often the preferred IPC mechanism in single-server environments where performance is paramount.
      </span>
      <span class="koboSpan" id="kobo.141.2">
       Its primary advantage lies in its speed.
      </span>
      <span class="koboSpan" id="kobo.141.3">
       Since data is directly shared in physical memory without the need for intermediate copying or context switching, it significantly reduces communication overhead and
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.142.1">
        minimizes latency.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.143.1">
       However, shared memory also comes with certain considerations.
      </span>
      <span class="koboSpan" id="kobo.143.2">
       It requires careful management to prevent race conditions and memory leaks.
      </span>
      <span class="koboSpan" id="kobo.143.3">
       Processes accessing shared memory must adhere to well-defined protocols to ensure data integrity and avoid deadlocks.
      </span>
      <span class="koboSpan" id="kobo.143.4">
       Additionally, shared memory is typically implemented as a system-level feature, requiring specific operating system support and potentially introducing
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.144.1">
        platform-specific dependencies.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.145.1">
       Despite these considerations, shared memory remains a powerful and widely used IPC technique, particularly in applications where speed and performance are
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.146.1">
        critical factors.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.147.1">
       Sockets
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      : Sockets are
     </span>
     <a id="_idIndexMarker109">
     </a>
     <span class="koboSpan" id="kobo.149.1">
      a fundamental mechanism for IPC in operating systems.
     </span>
     <span class="koboSpan" id="kobo.149.2">
      They provide a way for processes to communicate with each other, either within the same machine or across networks.
     </span>
     <span class="koboSpan" id="kobo.149.3">
      Sockets are used to establish and maintain connections between processes, and they support both
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.150.1">
       connection-oriented
      </span>
     </strong>
     <span class="koboSpan" id="kobo.151.1">
      and
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.152.1">
        connectionless communication
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       .
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.154.1">
       Connection-oriented communication is a type of communication in which a reliable
      </span>
      <a id="_idIndexMarker110">
      </a>
      <span class="koboSpan" id="kobo.155.1">
       connection is established between two processes before any data is transferred.
      </span>
      <span class="koboSpan" id="kobo.155.2">
       This type of communication
      </span>
      <a id="_idIndexMarker111">
      </a>
      <span class="koboSpan" id="kobo.156.1">
       is often used for applications such as file transfer and remote login, where it is important to ensure that all data is delivered reliably and in the correct order.
      </span>
      <span class="koboSpan" id="kobo.156.2">
       Connectionless communication is a type of communication in which no reliable connection is established between two processes before data is transferred.
      </span>
      <span class="koboSpan" id="kobo.156.3">
       This type of communication is often used for applications such as streaming media and real-time gaming, where it is more important to have low latency than to guarantee reliable delivery of
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.157.1">
        all data.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.158.1">
       Sockets are the backbone of networked applications.
      </span>
      <span class="koboSpan" id="kobo.158.2">
       They are used by a wide variety
      </span>
      <a id="_idIndexMarker112">
      </a>
      <span class="koboSpan" id="kobo.159.1">
       of applications, including web browsers, email clients, and file-sharing applications.
      </span>
      <span class="koboSpan" id="kobo.159.2">
       Sockets are also used by many
      </span>
      <a id="_idIndexMarker113">
      </a>
      <span class="koboSpan" id="kobo.160.1">
       operating system services, such as the
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.161.1">
        Network File System
       </span>
      </strong>
      <span class="koboSpan" id="kobo.162.1">
       (
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.163.1">
        NFS
       </span>
      </strong>
      <span class="koboSpan" id="kobo.164.1">
       ) and the
      </span>
      <strong class="bold">
       <span class="koboSpan" id="kobo.165.1">
        Domain Name
       </span>
      </strong>
      <span class="No-Break">
       <strong class="bold">
        <span class="koboSpan" id="kobo.166.1">
         System
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.167.1">
        (
       </span>
      </span>
      <span class="No-Break">
       <strong class="bold">
        <span class="koboSpan" id="kobo.168.1">
         DNS
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.169.1">
        ).
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.170.1">
       Here are some of the key benefits of
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.171.1">
        using sockets:
       </span>
      </span>
     </p>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.172.1">
         Reliability
        </span>
       </strong>
       <span class="koboSpan" id="kobo.173.1">
        : Sockets
       </span>
       <a id="_idIndexMarker114">
       </a>
       <span class="koboSpan" id="kobo.174.1">
        provide a reliable way to communicate between processes, even when those processes are located on
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.175.1">
         different machines.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.176.1">
         Scalability
        </span>
       </strong>
       <span class="koboSpan" id="kobo.177.1">
        : Sockets
       </span>
       <a id="_idIndexMarker115">
       </a>
       <span class="koboSpan" id="kobo.178.1">
        can be used to support a large number of concurrent connections, making them ideal for applications that need to handle a lot
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.179.1">
         of traffic.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.180.1">
         Flexibility
        </span>
       </strong>
       <span class="koboSpan" id="kobo.181.1">
        : Sockets
       </span>
       <a id="_idIndexMarker116">
       </a>
       <span class="koboSpan" id="kobo.182.1">
        can be used to implement a wide variety of communication protocols, making them suitable for a wide range
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.183.1">
         of applications.
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.184.1">
         Use in IPC
        </span>
       </strong>
       <span class="koboSpan" id="kobo.185.1">
        : Sockets
       </span>
       <a id="_idIndexMarker117">
       </a>
       <span class="koboSpan" id="kobo.186.1">
        are a powerful tool for IPC.
       </span>
       <span class="koboSpan" id="kobo.186.2">
        They are used by a wide variety of applications and are essential for building scalable, reliable, and flexible
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.187.1">
         networked applications.
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     Microservices-based applications are an example of asynchronous programming using different processes communicating between them in an asynchronous way.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     A simple example would be a log processor.
    </span>
    <span class="koboSpan" id="kobo.188.3">
     Different processes generate log entries and send them to
    </span>
    <a id="_idIndexMarker118">
    </a>
    <span class="koboSpan" id="kobo.189.1">
     another process for further processing such as special formatting, deduplication, and statistics.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     The producers just send the lines of the log without waiting for any reply from the process they are sending to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      the log.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     In this section, we saw processes in Linux, their life cycles, and how IPC is implemented by the operating system.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     In the next section, we will introduce a special kind of Linux process
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.193.1">
       daemons
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor040">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     Services and daemons in Linux
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     In the realm of Linux operating systems, daemons are a fundamental component that runs quietly
    </span>
    <a id="_idIndexMarker119">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     in the background, silently executing essential tasks without the direct involvement of an interactive user.
    </span>
    <span class="koboSpan" id="kobo.197.2">
     These processes are traditionally
    </span>
    <a id="_idIndexMarker120">
    </a>
    <span class="koboSpan" id="kobo.198.1">
     identified by their names ending with the letter
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.199.1">
      d
     </span>
    </em>
    <span class="koboSpan" id="kobo.200.1">
     , such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.201.1">
      sshd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     for the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.203.1">
      Secure Shell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.205.1">
      SSH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     ) daemon and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      httpd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     for the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.209.1">
      web server daemon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     .
    </span>
    <span class="koboSpan" id="kobo.210.2">
     They
    </span>
    <a id="_idIndexMarker121">
    </a>
    <span class="koboSpan" id="kobo.211.1">
     play a vital role in handling system-level tasks crucial for both the operating system and the applications running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      on it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     Daemons serve
    </span>
    <a id="_idIndexMarker122">
    </a>
    <span class="koboSpan" id="kobo.214.1">
     an array of purposes, ranging from file serving, web serving, and network communications to logging and monitoring services.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     They are designed to be autonomous and resilient, starting at system boot and running continuously until the system is shut down.
    </span>
    <span class="koboSpan" id="kobo.214.3">
     Unlike regular processes initiated and controlled
    </span>
    <a id="_idIndexMarker123">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     by users, daemons possess
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.216.1">
      distinct characteristics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.217.1">
        Background operation
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.218.1">
       :
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.219.1">
        Daemons operate in
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.220.1">
         the background
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.221.1">
        They lack a controlling terminal for direct
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.222.1">
         user interaction
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.223.1">
        They do not require a user interface or manual intervention to perform
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.224.1">
         their tasks
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.225.1">
        User independence
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.226.1">
       :
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.227.1">
        Daemons operate independently of
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.228.1">
         user sessions
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.229.1">
        They
       </span>
       <a id="_idIndexMarker124">
       </a>
       <span class="koboSpan" id="kobo.230.1">
        function autonomously without direct
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.231.1">
         user involvement
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.232.1">
        They wait for system events or specific requests to trigger
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.233.1">
         their actions
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.234.1">
        Task-oriented focus
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.235.1">
       :
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.236.1">
        Each daemon is tailored to execute a specific task or a set
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.237.1">
         of tasks
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.238.1">
        They are designed to handle specific functions or listen for particular events
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.239.1">
         or requests
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.240.1">
        This ensures efficient
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.241.1">
         task execution
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     Creating a
    </span>
    <a id="_idIndexMarker125">
    </a>
    <span class="koboSpan" id="kobo.243.1">
     daemon process involves more than merely running a process in the background.
    </span>
    <span class="koboSpan" id="kobo.243.2">
     To ensure effective operation as a daemon, developers
    </span>
    <a id="_idIndexMarker126">
    </a>
    <span class="koboSpan" id="kobo.244.1">
     must consider several
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      key steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.246.1">
       Detaching from the terminal
      </span>
     </strong>
     <span class="koboSpan" id="kobo.247.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.248.1">
       fork()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.249.1">
      system call is employed to detach the daemon from the terminal.
     </span>
     <span class="koboSpan" id="kobo.249.2">
      The parent process exits after the fork, leaving the child process running in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.250.1">
       the background.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.251.1">
       Session creation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       setsid()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      system call creates a new session and designates the calling process as the leader of both the session and the process group.
     </span>
     <span class="koboSpan" id="kobo.254.2">
      This step is crucial for complete detachment from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       the terminal.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.256.1">
       Working directory change
      </span>
     </strong>
     <span class="koboSpan" id="kobo.257.1">
      : To prevent blocking the unmounting of the filesystem, daemons typically change their working directory to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.258.1">
       root directory.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.259.1">
       File descriptor handling
      </span>
     </strong>
     <span class="koboSpan" id="kobo.260.1">
      : Inherited file descriptors are closed by daemons, and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.261.1">
       stdin
      </span>
     </strong>
     <span class="koboSpan" id="kobo.262.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.263.1">
       stdout
      </span>
     </strong>
     <span class="koboSpan" id="kobo.264.1">
      , and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.265.1">
       stderr
      </span>
     </strong>
     <span class="koboSpan" id="kobo.266.1">
      are often redirected
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.267.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.268.1">
        /dev/null
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.269.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.270.1">
       Signal handling
      </span>
     </strong>
     <span class="koboSpan" id="kobo.271.1">
      : Proper handling of signals, such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.272.1">
       SIGHUP
      </span>
     </strong>
     <span class="koboSpan" id="kobo.273.1">
      for configuration
     </span>
     <a id="_idIndexMarker127">
     </a>
     <span class="koboSpan" id="kobo.274.1">
      reloading or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.275.1">
       SIGTERM
      </span>
     </strong>
     <span class="koboSpan" id="kobo.276.1">
      for graceful shutdown, is essential for effective
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.277.1">
       daemon management.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     Daemons communicate with other processes or daemons through various
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      IPC mechanisms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     Daemons are integral to the architecture of many asynchronous systems, providing essential services without direct user interaction.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     Some prominent use cases of daemons
    </span>
    <a id="_idIndexMarker128">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     include
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.283.1">
       Web servers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.284.1">
      : Daemons such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.285.1">
       httpd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.286.1">
      and nginx serve web pages in response to client requests, handling multiple requests concurrently and ensuring seamless
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.287.1">
       web browsing.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.288.1">
       Database servers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.289.1">
      : Daemons such as mysqld and postgresql manage database services, allowing for asynchronous access and manipulation of databases by
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.290.1">
       various applications.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.291.1">
       File servers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.292.1">
      : Daemons such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.293.1">
       smbd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.294.1">
      and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.295.1">
       nfsd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.296.1">
      provide networked file services, enabling asynchronous file sharing and access across
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.297.1">
       different systems.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.298.1">
       Logging and monitoring
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      : Daemons such as
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.300.1">
       syslogd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.301.1">
      and
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.302.1">
       snmpd
      </span>
     </strong>
     <span class="koboSpan" id="kobo.303.1">
      collect and log system events, providing asynchronous monitoring of system health
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.304.1">
       and performance.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     In summary, daemons are essential components of Linux systems, silently performing critical
    </span>
    <a id="_idIndexMarker129">
    </a>
    <span class="koboSpan" id="kobo.306.1">
     tasks in the background to ensure smooth system operation and efficient application execution.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     Their autonomous nature and resilience make them indispensable for maintaining system stability and providing essential services to users
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      and applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     We have seen processes and demons, a special type of process.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     A process can have one or more threads of execution.
    </span>
    <span class="koboSpan" id="kobo.308.3">
     In the next section, we will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.309.1">
      introducing threads.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor041">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     Threads
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.311.1">
     Processes and threads represent two fundamental ways of executing code concurrently, but they
    </span>
    <a id="_idIndexMarker130">
    </a>
    <span class="koboSpan" id="kobo.312.1">
     differ significantly in their operation and resource management.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     A process is an instance of a running program that owns its private set of resources, including memory, file descriptors, and execution context.
    </span>
    <span class="koboSpan" id="kobo.312.3">
     Processes are isolated from each other, providing robust stability across the system since the failure of one process generally does not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      affect others.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Threads are a fundamental concept in computer science, representing a lightweight and efficient way to execute multiple tasks within a single process.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     In contrast to processes, which are independent entities with their own private memory space and resources, threads are closely intertwined with the process they belong to.
    </span>
    <span class="koboSpan" id="kobo.314.3">
     This intimate relationship allows threads to share the same memory space and resources, including file descriptors, heap memory, and any other global data structures allocated by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      the process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     One of the key advantages of threads is their ability to communicate and share data efficiently.
    </span>
    <span class="koboSpan" id="kobo.316.2">
     Since all threads within a process share the same memory space, they can directly access and modify common variables without the need for complex IPC mechanisms.
    </span>
    <span class="koboSpan" id="kobo.316.3">
     This shared environment enables rapid data exchange and facilitates the implementation of concurrent algorithms and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      data structures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.318.1">
     However, sharing the same memory space also introduces the challenge of managing access to shared resources.
    </span>
    <span class="koboSpan" id="kobo.318.2">
     To prevent data corruption and ensure the integrity of shared data, threads must employ synchronization mechanisms such as locks, semaphores, or mutexes.
    </span>
    <span class="koboSpan" id="kobo.318.3">
     These mechanisms enforce rules and protocols for accessing shared resources, ensuring that only one thread can access a particular resource at any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.319.1">
      given time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     Effective synchronization is crucial in multithreaded programming to avoid race conditions, deadlocks, and other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      concurrency-related issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     To address these challenges, various synchronization primitives and techniques have been developed.
    </span>
    <span class="koboSpan" id="kobo.322.2">
     These include mutexes, which provide exclusive access to a shared resource, semaphores, which allow for controlled access to a limited number of resources, and condition variables, which enable threads to wait for specific conditions to be met
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      before proceeding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     By carefully managing synchronization and employing appropriate concurrency patterns, developers can harness the power of threads to achieve high performance and scalability in their applications.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     Threads are particularly well-suited for tasks that can be parallelized, such as image processing, scientific simulations, and web servers, where multiple independent computations can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      executed concurrently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Threads, as described previously, are system threads.
    </span>
    <span class="koboSpan" id="kobo.326.2">
     This means that they are created and managed
    </span>
    <a id="_idIndexMarker131">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     by the kernel.
    </span>
    <span class="koboSpan" id="kobo.327.2">
     However, there are scenarios, which we will explore in depth in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.328.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.329.1">
     , where we will require a multitude of threads.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     In such cases, the system might not have sufficient resources to create numerous system threads.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     The solution to this
    </span>
    <a id="_idIndexMarker132">
    </a>
    <span class="koboSpan" id="kobo.330.1">
     problem is the use of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.331.1">
      user threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     .
    </span>
    <span class="koboSpan" id="kobo.332.2">
     One approach to implementing user threads is through
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.333.1">
      coroutines
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     , which have been included in the C++ standard
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      since C++20.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     Coroutines are a relatively
    </span>
    <a id="_idIndexMarker133">
    </a>
    <span class="koboSpan" id="kobo.337.1">
     new feature in C++.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     Coroutines can be defined as functions that can be paused and resumed at specific points, allowing for cooperative multitasking within a single thread.
    </span>
    <span class="koboSpan" id="kobo.337.3">
     Unlike standard functions that run from start to finish without interruption, coroutines can suspend their execution and yield control back to the caller, which can later resume the coroutine from the point it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      was paused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     Coroutines are much more lightweight than system threads.
    </span>
    <span class="koboSpan" id="kobo.339.2">
     This means that they can be created and destroyed much more quickly, and that they require
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      less overhead.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     Coroutines are cooperative, which means that they must explicitly yield control to the caller in order to switch execution context.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     This can be a disadvantage in some cases, but it can also be an advantage, as it gives the user program more control over the execution
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      of coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     Coroutines can be used to create a variety of different concurrency patterns.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     For example, coroutines can be used to implement tasks, which are lightweight work units that can be scheduled and run concurrently.
    </span>
    <span class="koboSpan" id="kobo.343.3">
     Coroutines can also be used to implement channels, which are communication channels that can pass data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      between them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     Coroutines can be classified into stackful and stackless categories.
    </span>
    <span class="koboSpan" id="kobo.345.2">
     C++20 coroutines are stackless.
    </span>
    <span class="koboSpan" id="kobo.345.3">
     We will see these concepts in depth in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.346.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.347.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Overall, coroutines are a powerful tool for creating concurrent programs in C++.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     They are lightweight, cooperative, and can be used to implement a variety of different concurrency patterns.
    </span>
    <span class="koboSpan" id="kobo.348.3">
     They cannot be used to implement parallelism entirely because coroutines still need CPU execution context, which can be only provided by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      a thread.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor042">
    </a>
    <span class="koboSpan" id="kobo.350.1">
     Thread life cycle
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     The life cycle
    </span>
    <a id="_idIndexMarker134">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     of a system thread, often referred to as a lightweight process, encompasses the stages from its creation until its termination.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     Each stage plays a crucial role in managing and utilizing threads in a concurrent
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.353.1">
      programming environment:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.354.1">
       Creation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.355.1">
      : This phase begins when a new thread is created in the system.
     </span>
     <span class="koboSpan" id="kobo.355.2">
      The creation process involves using the function, which takes several parameters.
     </span>
     <span class="koboSpan" id="kobo.355.3">
      One critical parameter is the thread’s attributes, such as its scheduling policy, stack size, and priority.
     </span>
     <span class="koboSpan" id="kobo.355.4">
      Another essential parameter is the function that the thread will execute, known as the start routine.
     </span>
     <span class="koboSpan" id="kobo.355.5">
      Upon its successful creation, the thread is allocated its own stack and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.356.1">
       other resources.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.357.1">
       Execution
      </span>
     </strong>
     <span class="koboSpan" id="kobo.358.1">
      : After creation, the thread starts executing its assigned start routine.
     </span>
     <span class="koboSpan" id="kobo.358.2">
      During execution, the thread can perform various tasks independently or interact with other threads if necessary.
     </span>
     <span class="koboSpan" id="kobo.358.3">
      Threads can also create and manage their own local variables and data structures, making them self-contained and capable of performing specific
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.359.1">
       tasks concurrently.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.360.1">
       Synchronization
      </span>
     </strong>
     <span class="koboSpan" id="kobo.361.1">
      : To ensure orderly access to shared resources and prevent data corruption, threads employ synchronization mechanisms.
     </span>
     <span class="koboSpan" id="kobo.361.2">
      Common synchronization primitives include locks, semaphores, and barriers.
     </span>
     <span class="koboSpan" id="kobo.361.3">
      Proper synchronization allows threads to coordinate their activities, avoiding race conditions, deadlocks, and other issues that can arise in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.362.1">
       concurrent programming.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.363.1">
       Termination
      </span>
     </strong>
     <span class="koboSpan" id="kobo.364.1">
      : A thread can terminate in several ways.
     </span>
     <span class="koboSpan" id="kobo.364.2">
      It can explicitly call the function to terminate itself.
     </span>
     <span class="koboSpan" id="kobo.364.3">
      It can also terminate by returning from its start routine.
     </span>
     <span class="koboSpan" id="kobo.364.4">
      In some cases, a thread can be canceled by another thread using the function.
     </span>
     <span class="koboSpan" id="kobo.364.5">
      Upon termination, the system reclaims the resources allocated to the thread, and any pending operations or locks held by the thread
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.365.1">
       are released.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     Understanding the life cycle of a system thread is essential for designing and implementing concurrent programs.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     By carefully managing thread creation, execution, synchronization, and termination, developers can create efficient and scalable applications that leverage the benefits
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      of concurrency.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor043">
    </a>
    <span class="koboSpan" id="kobo.368.1">
     Thread scheduling
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     System threads, managed by the operating system kernel’s scheduler, are scheduled preemptively.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     The scheduler decides when to switch execution between threads based on factors
    </span>
    <a id="_idIndexMarker135">
    </a>
    <span class="koboSpan" id="kobo.370.1">
     such as thread priority, allocated time, or mutex blocking.
    </span>
    <span class="koboSpan" id="kobo.370.2">
     This context switch, controlled by the kernel, can incur significant overhead.
    </span>
    <span class="koboSpan" id="kobo.370.3">
     The high cost of context switches, coupled with the resource usage of each thread (such as its own stack), makes coroutines a more efficient alternative for some applications because we can run more than one coroutine in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      single thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.372.1">
     Coroutines offer several advantages.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     First, they reduce the overhead associated with context switches.
    </span>
    <span class="koboSpan" id="kobo.372.3">
     Since context switching on coroutine yield or await is handled by the user space code rather than the kernel, the process is more lightweight and efficient.
    </span>
    <span class="koboSpan" id="kobo.372.4">
     This results in significant performance gains, especially in scenarios where frequent context
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      switching occurs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     Coroutines also provide greater control over thread scheduling.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     Developers can define custom scheduling policies based on the specific requirements of their application.
    </span>
    <span class="koboSpan" id="kobo.374.3">
     This flexibility allows for fine-tuned thread management, resource utilization optimization, and desired performance
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      characteristics achievement.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     Another important feature of coroutines is that they are generally more lightweight compared to system threads.
    </span>
    <span class="koboSpan" id="kobo.376.2">
     Coroutines don’t maintain their own stack, which is a great resource consumption advantage, making them suitable for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.377.1">
      resource-constrained environments.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.378.1">
     Overall, coroutines offer a more efficient and flexible approach to thread management, particularly in situations where frequent context switching is required or where fine-grained control over thread scheduling is essential.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     Threads can access the memory process and this memory is shared among all the threads, so we need to be careful and control memory access.
    </span>
    <span class="koboSpan" id="kobo.378.3">
     This control is achieved by different mechanisms called
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.379.1">
      synchronization primitives.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor044">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     Synchronization primitives
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.381.1">
     Synchronization primitives are essential tools for managing concurrent access to shared resources
    </span>
    <a id="_idIndexMarker136">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     in multithreaded programming.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     There are several synchronization primitives, each with its own specific purpose
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      and characteristics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.384.1">
       Mutexes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.385.1">
      : Mutexes
     </span>
     <a id="_idIndexMarker137">
     </a>
     <span class="koboSpan" id="kobo.386.1">
      are used to enforce
     </span>
     <a id="_idIndexMarker138">
     </a>
     <span class="koboSpan" id="kobo.387.1">
      exclusive access to critical sections of code.
     </span>
     <span class="koboSpan" id="kobo.387.2">
      A mutex can be locked by a thread, preventing other threads from entering the protected section until the mutex is unlocked.
     </span>
     <span class="koboSpan" id="kobo.387.3">
      Mutexes guarantee that only one thread can execute the critical section at any given time, ensuring data integrity and preventing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.388.1">
       race conditions.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.389.1">
       Semaphores
      </span>
     </strong>
     <span class="koboSpan" id="kobo.390.1">
      : Semaphores are more versatile than mutexes and can be used for a
     </span>
     <a id="_idIndexMarker139">
     </a>
     <span class="koboSpan" id="kobo.391.1">
      wider range of synchronization tasks, including signaling between threads.
     </span>
     <span class="koboSpan" id="kobo.391.2">
      A semaphore maintains
     </span>
     <a id="_idIndexMarker140">
     </a>
     <span class="koboSpan" id="kobo.392.1">
      an integer counter that can be incremented (signaling) or decremented (waiting) by threads.
     </span>
     <span class="koboSpan" id="kobo.392.2">
      Semaphores allow for more complex coordination patterns, such as counting semaphores (for resource allocation) and binary semaphores (similar
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.393.1">
       to mutexes).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.394.1">
       Condition variables
      </span>
     </strong>
     <span class="koboSpan" id="kobo.395.1">
      : Condition variables are used for thread synchronization based
     </span>
     <a id="_idIndexMarker141">
     </a>
     <span class="koboSpan" id="kobo.396.1">
      on specific conditions.
     </span>
     <span class="koboSpan" id="kobo.396.2">
      Threads can block (wait on) a condition variable until a particular condition
     </span>
     <a id="_idIndexMarker142">
     </a>
     <span class="koboSpan" id="kobo.397.1">
      becomes true.
     </span>
     <span class="koboSpan" id="kobo.397.2">
      Other threads can signal the condition variable, causing waiting threads to wake up and continue execution.
     </span>
     <span class="koboSpan" id="kobo.397.3">
      Condition variables are often used in conjunction with mutexes to achieve more fine-grained synchronization and avoid
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.398.1">
       busy waiting.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.399.1">
       Additional synchronization primitives
      </span>
     </strong>
     <span class="koboSpan" id="kobo.400.1">
      : In addition to the core synchronization primitives discussed previously, there are several other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.401.1">
       synchronization mechanisms:
      </span>
     </span>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.402.1">
         Barriers
        </span>
       </strong>
       <span class="koboSpan" id="kobo.403.1">
        : Barriers
       </span>
       <a id="_idIndexMarker143">
       </a>
       <span class="koboSpan" id="kobo.404.1">
        allow a group of threads to synchronize their execution, ensuring that all threads reach a certain point before
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.405.1">
         proceeding further
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.406.1">
         Read-write locks
        </span>
       </strong>
       <span class="koboSpan" id="kobo.407.1">
        : Read-write
       </span>
       <a id="_idIndexMarker144">
       </a>
       <span class="koboSpan" id="kobo.408.1">
        locks provide a way to control concurrent access to shared data, allowing multiple readers but only a single writer at
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.409.1">
         a time
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.410.1">
         Spinlocks
        </span>
       </strong>
       <span class="koboSpan" id="kobo.411.1">
        : Spinlocks
       </span>
       <a id="_idIndexMarker145">
       </a>
       <span class="koboSpan" id="kobo.412.1">
        are a type of mutex that involves busy waiting, continuously checking a memory location until it
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.413.1">
         becomes available
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     In
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.415.1">
      Chapters 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.416.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.417.1">
      5
     </span>
    </em>
    <span class="koboSpan" id="kobo.418.1">
     , we
    </span>
    <a id="_idIndexMarker146">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     will see the synchronization primitives implemented in the C++
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.420.1">
      Standard Template Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.422.1">
      STL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     ) in depth and examples of how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      use them.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor045">
    </a>
    <span class="koboSpan" id="kobo.425.1">
     Choosing the right synchronization primitive
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     The choice
    </span>
    <a id="_idIndexMarker147">
    </a>
    <span class="koboSpan" id="kobo.427.1">
     of the appropriate synchronization primitive depends on the specific requirements of the application and the nature of the shared resources being accessed.
    </span>
    <span class="koboSpan" id="kobo.427.2">
     Here are some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      general guidelines:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.429.1">
       Mutexes
      </span>
     </strong>
     <span class="koboSpan" id="kobo.430.1">
      : Use
     </span>
     <a id="_idIndexMarker148">
     </a>
     <span class="koboSpan" id="kobo.431.1">
      mutexes when exclusive access to a critical section is required to ensure data integrity and prevent
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.432.1">
       race conditions
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.433.1">
       Semaphores
      </span>
     </strong>
     <span class="koboSpan" id="kobo.434.1">
      : Use
     </span>
     <a id="_idIndexMarker149">
     </a>
     <span class="koboSpan" id="kobo.435.1">
      semaphores when more complex coordination patterns are needed, such as resource allocation or signaling
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.436.1">
       between threads
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.437.1">
       Condition variables
      </span>
     </strong>
     <span class="koboSpan" id="kobo.438.1">
      : Use
     </span>
     <a id="_idIndexMarker150">
     </a>
     <span class="koboSpan" id="kobo.439.1">
      condition variables when threads need to wait for a specific condition to become true
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.440.1">
       before proceeding
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     Effective use of synchronization primitives is crucial for developing safe and efficient multithreaded programs.
    </span>
    <span class="koboSpan" id="kobo.441.2">
     By understanding the purpose and characteristics of different synchronization mechanisms, developers can choose the most suitable primitives for their specific needs and achieve reliable and predictable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.442.1">
      concurrent execution.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-47">
    <a id="_idTextAnchor046">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     Common problems when using multiple threads
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     Threading
    </span>
    <a id="_idIndexMarker151">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     introduces several challenges that must be managed to ensure application correctness and performance.
    </span>
    <span class="koboSpan" id="kobo.445.2">
     These challenges arise from the inherent concurrency and non-deterministic nature of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      multithreaded programming.
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.447.1">
       Race conditions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.448.1">
      occur when multiple threads access and modify shared data concurrently.
     </span>
     <span class="koboSpan" id="kobo.448.2">
      The outcome of a race condition depends on the non-deterministic sequencing of threads’ operations, which can lead to unpredictable and inconsistent results.
     </span>
     <span class="koboSpan" id="kobo.448.3">
      For example, consider two threads that are updating a shared counter.
     </span>
     <span class="koboSpan" id="kobo.448.4">
      If the threads increment the counter concurrently, the final value may be incorrect due to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.449.1">
       race condition.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.450.1">
       Deadlocks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.451.1">
      occur when two or more threads wait indefinitely for resources held by each other.
     </span>
     <span class="koboSpan" id="kobo.451.2">
      This creates a cycle of dependencies that cannot be resolved, causing the threads to become permanently blocked.
     </span>
     <span class="koboSpan" id="kobo.451.3">
      For instance, consider two threads that are waiting for each other to release locks on shared resources.
     </span>
     <span class="koboSpan" id="kobo.451.4">
      If neither thread releases the lock it holds, a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.452.1">
       deadlock occurs.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.453.1">
       Starvation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.454.1">
      occurs when a thread is perpetually denied access to resources it needs to make progress.
     </span>
     <span class="koboSpan" id="kobo.454.2">
      This can happen when other threads continuously acquire and hold resources, leaving the starved thread unable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.455.1">
       to execute.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.456.1">
       Livelocks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.457.1">
      are like deadlocks, but instead of being permanently blocked, the threads remain active and repeatedly try to acquire resources, only without making
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.458.1">
       any progress.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     Several
    </span>
    <a id="_idIndexMarker152">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     techniques can be used to manage the challenges of threading, including
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.462.1">
       Synchronization mechanisms
      </span>
     </strong>
     <span class="koboSpan" id="kobo.463.1">
      : As described previously, synchronization primitives such as locks and mutexes can be used to control access to shared data and ensure that only one thread can access the data at
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.464.1">
       a time.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.465.1">
       Deadlock prevention and detection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.466.1">
      : Deadlock prevention algorithms can be used to avoid deadlocks, while deadlock detection algorithms can be used to identify and resolve deadlocks when
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.467.1">
       they occur.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.468.1">
       Thread scheduling
      </span>
     </strong>
     <span class="koboSpan" id="kobo.469.1">
      : Thread scheduling algorithms can be used to determine which
     </span>
     <a id="_idIndexMarker153">
     </a>
     <span class="koboSpan" id="kobo.470.1">
      thread should run at any given time, as well as which can help to prevent starvation and improve application performance.
     </span>
     <span class="koboSpan" id="kobo.470.2">
      We will see the different solutions to multithreading issues in much
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.471.1">
       more detail.
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-48">
    <a id="_idTextAnchor047">
    </a>
    <span class="koboSpan" id="kobo.472.1">
     Strategies for effective thread management
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     There
    </span>
    <a id="_idIndexMarker154">
    </a>
    <span class="koboSpan" id="kobo.474.1">
     are different ways to handle threads to avoid multithreading issues.
    </span>
    <span class="koboSpan" id="kobo.474.2">
     The following are some of the most common ways to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.475.1">
      handle threads:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.476.1">
       Minimize shared state
      </span>
     </strong>
     <span class="koboSpan" id="kobo.477.1">
      : Designing threads to operate on private data as much as possible significantly reduces the need for synchronization.
     </span>
     <span class="koboSpan" id="kobo.477.2">
      By allocating memory for thread-specific data using thread-local storage, the need for global variables is eliminated, further reducing the potential for data contention.
     </span>
     <span class="koboSpan" id="kobo.477.3">
      Careful management of shared data access through synchronization primitives is essential to ensure data integrity.
     </span>
     <span class="koboSpan" id="kobo.477.4">
      This approach enhances the efficiency and correctness of multithreaded applications by minimizing the need for synchronization and ensuring that shared data is accessed in a controlled and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.478.1">
       consistent manner.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.479.1">
       Lock hierarchy
      </span>
     </strong>
     <span class="koboSpan" id="kobo.480.1">
      : Establishing a well-defined lock hierarchy is crucial for preventing deadlocks in multithreaded programming.
     </span>
     <span class="koboSpan" id="kobo.480.2">
      A lock hierarchy dictates the order in which locks are acquired and released, ensuring a consistent locking pattern across threads.
     </span>
     <span class="koboSpan" id="kobo.480.3">
      By acquiring locks in a hierarchical manner, from the coarsest to the finest granularity, the possibility of deadlocks is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.481.1">
       significantly reduced.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.482.1">
       The coarsest level of granularity refers to locks that control access to a large portion of the shared resource, while the finest granularity locks are used for specific, fine-grained parts of the resource.
      </span>
      <span class="koboSpan" id="kobo.482.2">
       By acquiring the coarse-grained lock first, threads can gain exclusive access to a larger section of the resource, reducing the likelihood of conflicts with other threads attempting to access the same resource.
      </span>
      <span class="koboSpan" id="kobo.482.3">
       Once the coarse-grained lock is acquired, finer-grained locks can be obtained to control access to specific parts of the resource, providing more granular control and reducing the waiting time for
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.483.1">
        other threads.
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.484.1">
       In some cases, lock-free data structures can be employed to eliminate the need for locks
      </span>
      <a id="_idIndexMarker155">
      </a>
      <span class="koboSpan" id="kobo.485.1">
       altogether.
      </span>
      <span class="koboSpan" id="kobo.485.2">
       Lock-free data structures are designed to provide concurrent access to shared resources without explicit locks.
      </span>
      <span class="koboSpan" id="kobo.485.3">
       Instead, they rely on atomic operations and non-blocking algorithms to ensure data integrity and consistency.
      </span>
      <span class="koboSpan" id="kobo.485.4">
       By utilizing lock-free data structures, the overhead associated with lock acquisition and release is eliminated, resulting in improved performance and scalability in
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.486.1">
        multithreaded applications:
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.487.1">
       Timeouts
      </span>
     </strong>
     <span class="koboSpan" id="kobo.488.1">
      : To prevent threads from waiting indefinitely when trying to acquire a lock, it is important to set timeouts for lock acquisition.
     </span>
     <span class="koboSpan" id="kobo.488.2">
      This ensures that if a thread cannot acquire the lock within the specified timeout period, it will automatically give up and try again later.
     </span>
     <span class="koboSpan" id="kobo.488.3">
      This helps prevent deadlocks and ensures that no thread is left
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.489.1">
       waiting indefinitely.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.490.1">
       Thread pools
      </span>
     </strong>
     <span class="koboSpan" id="kobo.491.1">
      : Managing a pool of reusable threads is a key technique for optimizing the performance of multithreaded applications.
     </span>
     <span class="koboSpan" id="kobo.491.2">
      By creating and destroying threads dynamically, the overhead of thread creation and termination can be reduced significantly.
     </span>
     <span class="koboSpan" id="kobo.491.3">
      The size of the thread pool should be tuned based on the application’s workload and resource constraints.
     </span>
     <span class="koboSpan" id="kobo.491.4">
      A too-small pool may result in tasks waiting for available threads, while a too-large pool may waste resources.
     </span>
     <span class="koboSpan" id="kobo.491.5">
      Work queues are used to manage tasks and assign them to available threads in the pool.
     </span>
     <span class="koboSpan" id="kobo.491.6">
      Tasks are added to the queue and processed by the threads in a FIFO order.
     </span>
     <span class="koboSpan" id="kobo.491.7">
      This ensures fairness and prevents the starvation of tasks.
     </span>
     <span class="koboSpan" id="kobo.491.8">
      The use of work queues also allows for load balancing, as tasks can be distributed evenly across the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.492.1">
       available threads.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.493.1">
       Synchronization primitives
      </span>
     </strong>
     <span class="koboSpan" id="kobo.494.1">
      : Understand the different types of synchronization primitives, such as mutexes, semaphores, and condition variables.
     </span>
     <span class="koboSpan" id="kobo.494.2">
      Choose the appropriate primitive based on the synchronization requirements of the specific scenario.
     </span>
     <span class="koboSpan" id="kobo.494.3">
      Use synchronization primitives correctly to avoid race conditions
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.495.1">
       and deadlocks.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.496.1">
       Testing and debugging
      </span>
     </strong>
     <span class="koboSpan" id="kobo.497.1">
      : Test multi-threaded applications thoroughly to identify and fix threading issues.
     </span>
     <span class="koboSpan" id="kobo.497.2">
      Use tools such as thread sanitizers and profilers to detect
     </span>
     <a id="_idIndexMarker156">
     </a>
     <span class="koboSpan" id="kobo.498.1">
      data races and performance bottlenecks.
     </span>
     <span class="koboSpan" id="kobo.498.2">
      Employ debugging techniques such as step-by-step execution and thread dumps to analyze and resolve threading problems.
     </span>
     <span class="koboSpan" id="kobo.498.3">
      We will see testing and debugging in
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.499.1">
       Chapters 11
      </span>
     </em>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.500.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.501.1">
        12
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.503.1">
       Scalability and performance considerations
      </span>
     </strong>
     <span class="koboSpan" id="kobo.504.1">
      : Design thread-safe data structures and algorithms to ensure scalability and performance.
     </span>
     <span class="koboSpan" id="kobo.504.2">
      Balance the number of threads with the available resources to avoid over-subscription.
     </span>
     <span class="koboSpan" id="kobo.504.3">
      Monitor system metrics such as CPU utilization and thread contention to identify potential
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.505.1">
       performance bottlenecks.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.506.1">
       Communication and collaboration
      </span>
     </strong>
     <span class="koboSpan" id="kobo.507.1">
      : Foster collaboration among developers working on multi-threaded code to ensure consistency and correctness.
     </span>
     <span class="koboSpan" id="kobo.507.2">
      Establish coding guidelines and best practices for thread management to maintain code quality and readability.
     </span>
     <span class="koboSpan" id="kobo.507.3">
      Regularly review and update the threading strategy as the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.508.1">
       application evolves.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.509.1">
     Threading is a powerful tool that can be used to improve the performance and scalability of applications.
    </span>
    <span class="koboSpan" id="kobo.509.2">
     However, it is important to understand the challenges of threading and to use appropriate techniques to manage these challenges.
    </span>
    <span class="koboSpan" id="kobo.509.3">
     By doing so, developers can create multithreaded applications that are correct, efficient,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      and reliable.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor048">
    </a>
    <span class="koboSpan" id="kobo.511.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.512.1">
     In this chapter, we explored the concept of processes in operating systems.
    </span>
    <span class="koboSpan" id="kobo.512.2">
     Processes are fundamental entities that execute programs and manage resources on the computer.
    </span>
    <span class="koboSpan" id="kobo.512.3">
     We delved into the process life cycle, examining the various stages a process goes through from creation to termination.
    </span>
    <span class="koboSpan" id="kobo.512.4">
     Additionally, we discussed IPC, which is crucial for processes to interact and exchange information with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.513.1">
      each other.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.514.1">
     Furthermore, we introduced daemons in the context of Linux operating systems.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     Daemons are special types of processes that run in the background as services and perform specific tasks such as managing system resources, handling network connections, or providing other essential services to the system.
    </span>
    <span class="koboSpan" id="kobo.514.3">
     We also explored the concepts of system and user threads, which are lightweight processes that share the same address space as the parent process.
    </span>
    <span class="koboSpan" id="kobo.514.4">
     We discussed the advantages of multithreaded applications, including improved performance and responsiveness, as well as the challenges associated with managing and synchronizing multiple threads within a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.515.1">
      single process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     Knowing the different issues created by multithreading is fundamental to understanding how to fix them.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     In the next chapter, we will see how to create threads, and then in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.517.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.518.1">
     and
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.519.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.520.1">
     , we will study the different synchronization primitives the standard C++ offers and their different applications
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      in depth.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-50">
    <a id="_idTextAnchor049">
    </a>
    <span class="koboSpan" id="kobo.522.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.523.1">
      [Butenhof, 1997] David R.
     </span>
     <span class="koboSpan" id="kobo.523.2">
      Butenhof,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.524.1">
       Programming with POSIX Threads
      </span>
     </em>
     <span class="koboSpan" id="kobo.525.1">
      , Addison
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.526.1">
       Wesley, 1997.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.527.1">
      [Kerrisk, 2010] Michael Kerrisk,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.528.1">
       The Linux Programming Interface
      </span>
     </em>
     <span class="koboSpan" id="kobo.529.1">
      , No Starch
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.530.1">
       Press, 2010.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.531.1">
      [Stallings, 2018] William Stallings,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.532.1">
       Operating Systems Internals and Design Principles
      </span>
     </em>
     <span class="koboSpan" id="kobo.533.1">
      , Ninth Edition, Pearson
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.534.1">
       Education 2018.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.535.1">
      [Williams, 2019] Anthony Williams,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.536.1">
       C++ Concurrency in Action
      </span>
     </em>
     <span class="koboSpan" id="kobo.537.1">
      , Second Edition,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.538.1">
       Manning 2019.
      </span>
     </span>
    </li>
   </ul>
  </div>
 

  <div class="Content" id="_idContainer025">
   <h1 id="_idParaDest-51" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor050">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 2: Advanced Thread  Management and Synchronization Techniques
    </span>
   </h1>
  </div>
  <div id="_idContainer026">
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In this part, we build upon the foundational knowledge of parallel programming and dive deeper into advanced techniques for managing threads and synchronizing concurrent operations.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     We will explore essential concepts such as thread creation and management, exception handling across threads, and efficient thread coordination, acquiring a solid understanding of key synchronization primitives, including mutexes, semaphores, condition variables, and atomic operations.
    </span>
    <span class="koboSpan" id="kobo.2.3">
     All this knowledge will equip us with the tools needed to implement both lock-based and lock-free multithreaded solutions, offering a glimpse into high-performance concurrent systems, and providing the skills necessary to avoid common pitfalls such as race conditions, deadlocks, and livelocks when managing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.3.1">
      multithreaded systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.4.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22219_03.xhtml#_idTextAnchor051">
      <em class="italic">
       <span class="koboSpan" id="kobo.6.1">
        Chapter 3
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.7.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.8.1">
       How to Create and Manage Threads in C++
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_04.xhtml#_idTextAnchor074">
      <em class="italic">
       <span class="koboSpan" id="kobo.9.1">
        Chapter 4
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.10.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.11.1">
       Thread Synchronization with Locks
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_05.xhtml#_idTextAnchor097">
      <em class="italic">
       <span class="koboSpan" id="kobo.12.1">
        Chapter 5
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.13.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.14.1">
       Atomic Operations
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer027">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer028">
   </div>
  </div>
 </body></html>