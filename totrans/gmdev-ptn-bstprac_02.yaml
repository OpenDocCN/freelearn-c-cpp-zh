- en: One Instance to Rule Them All - Singletons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一统天下的单例 - 单例模式
- en: Now that we've learned what a design pattern is, as well as why we'd want to
    use them, let's first talk about a design pattern that most people learn, the
    Singleton pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是设计模式，以及为什么我们想要使用它们，让我们首先谈谈大多数人学习的设计模式，即单例模式。
- en: The Singleton pattern is probably the most well-known pattern and it is also
    the one out there that is most often misused. It definitely has the most controversy
    surrounding it, so when discussing this pattern it is as important (or even more
    important) to know when not to apply it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式可能是最著名的模式，也是最常被误用的模式。它确实围绕它有很多争议，所以在讨论这个模式时，了解何时不应用它同样重要（甚至更重要）。
- en: Chapter overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: In this chapter, we will explain about the pattern and many arguments for and
    against it. We will describe how and why core systems within the Mach5 engine
    such as the Graphics Engine and Object Manager are utilized as Singletons. Finally,
    we will explain a number of different ways to implement this in C++, along with
    the pros and cons of each choice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释关于这种模式的优缺点，以及为什么Mach5引擎中的核心系统，如图形引擎和对象管理器，被用作单例。最后，我们将解释在C++中实现这一点的多种不同方法，以及每种选择的优缺点。
- en: Your objective
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为多个主题。它将包含一个从开始到结束的简单分步过程。以下是我们的任务大纲：
- en: An overview of class access specifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类访问修饰符概述
- en: Pros and cons of global access
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局访问的优缺点
- en: Understanding the `static` keyword
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`static`关键字
- en: What is a Singleton?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是单例？
- en: Learning about templates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模板
- en: Templatizing Singletons
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例的模板化
- en: The advantages and disadvantages of only one instance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一实例的优点和缺点
- en: 'The Singleton in action: the `Application` class'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式的应用：`Application`类
- en: Design decisions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计决策
- en: An overview on class access specifiers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类访问修饰符概述
- en: 'When using an object-oriented programming language, one of the most important
    features included is the ability to hide data, preventing classes from accessing
    properties and functions of another class type by default. By using access specifiers
    such as `public`, `private`, and `protected`, we can dictate specifically how
    the data and/or functions can be accessed from other classes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用面向对象编程语言时，最重要的特性之一是能够隐藏数据，通过使用`public`、`private`和`protected`等访问修饰符，我们可以具体指定数据或函数如何被其他类访问：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A class can have unlimited variables or functions that are `public`, `private`,
    or `protected` and can even control access to entire sections of the class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有无限数量的变量或函数，可以是`public`、`private`或`protected`，甚至可以控制对类中整个部分的访问：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you place a labelled section with an access modifier's name and a `:` next
    to it, until there is another section label, all of the parts of the class that
    are listed will use that specific one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在带有访问修饰符名称的标签部分旁边放置一个冒号`:`，直到出现另一个部分标签，所有列出的类部分都将使用该特定的一个。
- en: When we use the `public` access modifier, we are saying that this variable or
    function can be used or accessed from anywhere within our program, even outside
    of the class we've created. Declaring a variable outside of a function or class,
    or marking a variable as `public` and `static`, is often referred to as being
    a global variable. We will be talking about global variables in the next section,
    but for right now, let's go over the other access specifiers as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`public`访问修饰符时，我们表示这个变量或函数可以在我们的程序中的任何地方使用或访问，甚至可以在我们创建的类之外。在函数或类之外声明变量，或将变量标记为`public`和`static`，通常被称为全局变量。我们将在下一节讨论全局变量，但就目前而言，让我们也过一下其他访问修饰符。
- en: When `private` is used, we are restricting the usage of our variable or function
    to being allowed only inside of the class, or from `friend` functions. By default,
    all of the variables and functions in a class are `private`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`private`时，我们限制我们的变量或函数的使用，只允许在类内部或从`friend`函数中使用。默认情况下，类中的所有变量和函数都是`private`的。
- en: For more information on friend functions, check out [http://en.cppreference.com/w/cpp/language/friend](http://en.cppreference.com/w/cpp/language/friend).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于`friend`函数的信息，请查看[http://en.cppreference.com/w/cpp/language/friend](http://en.cppreference.com/w/cpp/language/friend)。
- en: The third type, `protected`, is the same as a `private` type except that it
    can still be accessed by child (or derived) classes. This can be quite useful
    when using inheritance so you can still access those variables and/or functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型，`protected`，与`private`类型相同，只不过它仍然可以被子类（或派生类）访问。这在使用继承时非常有用，这样你仍然可以访问那些变量和/或函数。
- en: The static keyword
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态关键字
- en: 'Another thing that is important to know before diving into the Singleton pattern
    is what the `static` keyword means, as it''s something that we will be using the
    functionality of when building this pattern. When we use the `static` keyword,
    there are three main contexts that it''ll be used in:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究单例模式之前，了解`static`关键字的意义是很重要的，因为当我们构建这个模式时，我们将使用其功能。当我们使用`static`关键字时，它将在三个主要上下文中使用：
- en: Inside a function
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内部
- en: Inside a class definition
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类定义内部
- en: In front of a global variable in a program with multiple files
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有多个文件的程序中的全局变量前
- en: Static keyword inside a function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数内的静态关键字
- en: 'The first one, being used inside of a function, basically means that once the
    variable has been initialized, it will stay in the computer''s memory until the
    end of the program, keeping the value that it has through multiple runs of the
    function. A simple example would be something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，在函数内部使用，基本上意味着一旦变量被初始化，它将保留在计算机的内存中，直到程序结束，保持它在多次函数运行中的值。一个简单的例子可能如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now if we were to call this, it would look something like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用它，看起来会像以下这样：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And when we call it, the following would be displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用它时，以下内容会被显示：
- en: '![](img/00019.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: As you can see, the value continues to exist, and we can access and/or modify
    its contents as we see fit in the function. This could be used for a number of
    things, such as maybe needing to know what happened the last time that you called
    this function, or to store any kind of data between any calls. It's also worth
    noting that static variables are shared by all instances of the class, and due
    to that, if we had two variables of type `StaticExamples`, they would both display
    the same `enemyCount`. We will utilize the fact that, if an object is created
    this way, it will always be available later on in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，值继续存在，我们可以根据需要访问和/或修改其内容。这可以用于许多事情，比如可能需要知道上一次调用此函数时发生了什么，或者存储任何类型的数据。还值得注意的是，静态变量被类的所有实例共享，因此，如果我们有两个类型为`StaticExamples`的变量，它们都会显示相同的`enemyCount`。我们将利用这样一个事实，即如果以这种方式创建一个对象，它将始终在本章的后续部分可用。
- en: Static keyword in class definitions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类定义中的静态关键字
- en: 'The second way is by having a variable or function in a class being defined
    as `static`. Normally, when you create an instance of a class, the compiler has
    to set aside additional memory for each variable that is contained inside of the
    class in consecutive blocks of memory. When we declare something as `static`,
    instead of creating a new variable to hold data, a single variable is shared by
    all of the instances of the class. In addition, since it''s shared by all of the
    copies, you don''t need to have an instance of the class to call it. Take a look
    at the following bolded code to create our variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是将类中的变量或函数定义为`static`。通常情况下，当你创建一个类的实例时，编译器必须为类中包含的每个变量在连续的内存块中预留额外的内存。当我们声明某个变量为`static`时，而不是创建一个新的变量来存储数据，一个变量被所有类的实例共享。此外，由于它是所有副本共享的，因此你不需要类的实例就可以调用它。请看以下加粗的代码来创建我们的变量：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in the preceding code we define a variable and a function, but this isn''t
    all the prep work we need to do. When creating a static variable, you cannot initialize
    it from within the class, and instead need to do it in a `.cpp` file instead of
    the `.h` file we could use for the class definition. You''ll get errors if you
    do not initialize it, so it''s a good idea to do that. In our case, it''d look
    like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在先前的代码中我们定义了一个变量和一个函数，但这并不是我们需要做的所有准备工作。当创建静态变量时，你无法在类内部初始化它，而需要在`.cpp`文件中初始化，而不是我们可以用于类定义的`.h`文件。如果你不初始化它，你会得到错误，所以这是一个好主意。在我们的例子中，它看起来会像以下这样：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that, when we initialize, we also need to include the type, but we use
    the `ClassName::variableName` template similar to how you define functions in
    `.cpp` files. Now that everything''s set up, let''s see how we can access them
    inside our normal code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们初始化时，我们还需要包括类型，但我们使用`ClassName::variableName`模板，类似于你在`.cpp`文件中定义函数的方式。现在一切都已经设置好了，让我们看看我们如何在正常代码中访问它们：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that instead of accessing it via creating a variable, we can instead just
    use the class name followed by the scope operator (`::`) and then select which
    static variable or function we''d like to use. When we run it, it''ll look like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要通过创建一个变量来访问它，而是可以直接使用类名后跟作用域运算符（`::`），然后选择我们想要使用的静态变量或函数。当我们运行它时，它看起来会是这样：
- en: '![](img/00020.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00020.jpeg)'
- en: As you can see, it works perfectly!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它工作得非常完美！
- en: Static as a file global variable
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为文件全局变量的静态
- en: As you may be aware, C++ is a programming language closely related to the C
    programming language. C++ was designed to have most of the same functionality
    that C had and then added more things to it. C was not object-oriented, and so,
    when it created the `static` keyword, it was used to indicate that source code
    in other files that are part of your project cannot access the variable, and that
    only code inside of your file can use it. This was designed to create class-like
    behavior in C. Since we have classes in C++ we don't typically use it, but I felt
    I should mention it for completeness.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，C++是一种与C编程语言紧密相关的编程语言。C++被设计成具有与C相同的大部分功能，并在此基础上添加了更多功能。C不是面向对象的，因此当它创建`static`关键字时，它被用来指示项目中的其他文件（作为项目的一部分）不能访问该变量，而只有文件内部的代码可以使用它。这是为了在C中创建类似类的行为。由于C++中有类，我们通常不使用它，但我认为为了完整性，我应该提到这一点。
- en: Pros and cons of global variables
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量的优缺点
- en: To reiterate, a global variable is a variable that is declared outside of a
    function or class. Doing this makes our variable accessible in every function,
    hence us calling it global. When being taught programming in school, we were often
    told that global variables are a bad thing or at least, that modifying global
    variables in a function is considered to be poor programming practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，全局变量是在函数或类外部声明的变量。这样做使得我们的变量在所有函数中都是可访问的，因此我们称之为全局变量。在学校学习编程时，我们经常被告知全局变量是坏事，或者至少，在函数中修改全局变量被认为是不良的编程实践。
- en: 'There are numerous reasons why using global variables is a bad idea:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量有很多原因是不好的：
- en: Source code is the easiest to understand when the scope of the elements used
    is limited. Adding in global variables that can be read or modified anywhere in
    the program makes it much harder to keep track of where things are being done,
    as well as making it harder to comprehend when bringing on new developers.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用的元素作用域有限时，源代码最容易理解。在程序中添加可以在任何地方读取或修改的全局变量会使跟踪事物所在位置变得更加困难，同时也会使新开发者理解起来更加困难。
- en: Since a global variable can be modified anywhere, we lose any control over being
    able to confirm that the data contained in the variable is valid. For instance,
    you may only want to support up to a certain number, but as a global variable
    this is impossible to stop. Generally, we advise using `getter`/`setter` functions
    instead for this reason.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于全局变量可以在任何地方被修改，我们失去了对确认变量中包含的数据是否有效的任何控制。例如，你可能只想支持一定数量的值，但作为一个全局变量，这是不可能阻止的。通常，我们建议出于这个原因使用`getter`/`setter`函数。
- en: Using global variables tightens how coupled our programs are, making it difficult
    to reuse aspects of our projects as we need to grab from a lot of different places
    to make things work. Grouping things that are connected to each other tends to
    improve projects.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局变量使得我们的程序耦合度更高，这使得在我们需要从很多不同地方获取信息以使事物正常工作时，很难重用项目中的某些方面。将相互关联的事物分组通常可以改善项目。
- en: When working with the linker, if your global variable names are common, you'll
    often have issues when compiling your project. Thankfully, you'll get an error
    and have to fix the issue in this case. Unfortunately, you may also have an issue
    where you are trying to use a locally scoped variable in a project but  end up
    selecting the global version due to mistyping the name or relying too heavily
    on intelligence and selecting the first thing you see, which I see students doing
    on multiple occasions.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与链接器一起工作时，如果你的全局变量名称常见，在编译项目时你经常会遇到问题。幸运的是，你会得到一个错误，并需要修复这个问题。不幸的是，你也可能遇到一个问题，即你试图在一个项目中使用局部作用域的变量，但由于拼写错误或过度依赖智能提示而选择了全局版本，我看到学生在多次场合这样做。
- en: As the size of projects grow, it becomes much harder to do maintenance and/or
    make changes to/on global variables, as you may need to modify many parts of your
    code to have it adjust correctly.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着项目规模的扩大，维护和/或对全局变量进行更改变得更加困难，因为你可能需要修改代码的许多部分才能正确调整。
- en: 'This isn''t to say that global access is entirely bad. There are some reasons
    why one would consider using it in their projects:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说全局访问完全没有坏处。有一些原因会让人们考虑在他们的项目中使用它：
- en: Not knowing what a local variable is
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不了解局部变量的概念
- en: Not understanding how to create classes
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不了解如何创建类
- en: Wanting to save keystrokes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要节省按键次数
- en: Not wanting to pass around variables all the time to functions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不想总是将变量传递给函数
- en: Not knowing where to declare a variable, so making it global means anyone can
    get it
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不知如何声明变量，所以将其设置为全局变量意味着任何人都可以访问它
- en: To simplify our project for components that need to be accessible anywhere within
    the project
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化项目中需要任何地方都可以访问的组件
- en: Aside from the last point, those issues are really bad reasons for wanting to
    use global variables, as they may save you some time up front, but as your projects
    get larger and larger it'll be a lot more difficult to read your code. In addition,
    once you make something global it's going to be a lot more difficult to convert
    it to not be global down the road. Think that, instead of using global variables,
    you could instead pass parameters to different functions as needed, making it
    easier to understand what each function does and what it needs to work with to
    facilitate its functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一点，那些问题真的是想要使用全局变量的糟糕理由，因为它们可能会在你一开始节省一些时间，但随着你的项目越来越大，阅读代码会变得困难得多。此外，一旦你将某物设置为全局，将来将其转换为非全局将变得更加困难。想想看，与其使用全局变量，不如根据需要将参数传递给不同的函数，这样更容易理解每个函数做什么以及它需要与什么一起工作以实现其功能。
- en: That's not to say that there isn't any time when using a global variable is
    a reasonable or even a good idea. When global variables represent components that
    truly need to be available throughout your project, the use of global variables
    simplifies the code of your project, which is similar to what we are aiming to
    accomplish.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说在某个时候使用全局变量是不合理甚至是一个好主意。当全局变量代表在整个项目中真正需要可用的组件时，使用全局变量简化了项目的代码，这与我们想要实现的目标相似。
- en: '*Norm Matloff* also has an article explaining times that he feels like global
    variables are necessary when writing code. If you want to hear an alternative
    take, check out [http://heather.cs.ucdavis.edu/~matloff/globals.html](http://heather.cs.ucdavis.edu/~matloff/globals.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*Norm Matloff* 也有一篇文章解释了他认为在编写代码时有必要使用全局变量的情况。如果你想听一个不同的观点，请查看[http://heather.cs.ucdavis.edu/~matloff/globals.html](http://heather.cs.ucdavis.edu/~matloff/globals.html)。'
- en: Basically, always limit your variables to the minimal scope needed for the project
    and not any more. This especially comes to mind when you only ever need one of
    something, but plan to use that one object with many different things. That's
    the general idea of the Singleton design pattern and is the reason why it's important
    that we understand the general usage before moving onwards.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，总是将变量限制在项目所需的最小作用域内，不要更多。这尤其在你只需要一个东西，但计划用这个对象做很多不同的事情时，会想到这一点。这就是Singleton设计模式的一般想法，也是为什么在继续前进之前理解其一般用法很重要的原因。
- en: What is a Singleton?
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Singleton？
- en: The Singleton pattern in a nutshell is where you have a class that you can access
    anywhere within your project, due to the fact that only one object (instance)
    of that class is created (instantiated). The pattern provides a way for programmers
    to give access to a class's information globally by creating a single instance
    of an object in your game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton模式简而言之，就是你在项目中可以访问的类，因为只有一个对象（实例）被创建（实例化）。该模式提供了一种方式，让程序员可以通过创建游戏中的一个对象的单例来全局访问类的信息。
- en: Whereas there are quite a few issues with using global variables, you can think
    of a Singleton as an *improved* global variable due to the fact that you cannot
    create more than one. With this in mind, the Singleton pattern is an attractive
    choice for classes that only have a unique instance in your game project, such
    as your graphics pipeline and input libraries, as having more than one of these
    in your projects doesn't make sense.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用全局变量存在很多问题，但你可以将Singleton视为一种*改进的*全局变量，因为你不可以创建多个。考虑到这一点，Singleton模式对于在游戏项目中只有唯一实例的类来说是一个吸引人的选择，例如你的图形管道和输入库，因为在你项目中拥有多个这些类是没有意义的。
- en: This single object uses a static variable and static functions to be able to
    access the object without having to pass it through all of our code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一对象使用静态变量和静态函数来能够在不通过所有代码传递的情况下访问对象。
- en: In the Mach5 engine, Singletons are used for the application's, input, graphics,
    and physics engines. They are also used for the resource manager, object manager,
    and the game state manager. We will be taking a much closer look at one of the
    more foundational ones in the engine, the `Application` class, later on in this
    chapter. But before we get to it, let's dive into how we can actually create one
    of our very own.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mach5引擎中，Singleton用于应用程序、输入、图形和物理引擎。它们还用于资源管理器、对象管理器和游戏状态管理器。我们将在本章后面更深入地研究引擎中更基础的一个，即`Application`类。但在我们到达那里之前，让我们深入了解我们如何实际上创建我们自己的Singleton。
- en: There are multiple ways to implement the Singleton pattern or to get Singleton-like
    behavior. We'll go over some of the commonly seen versions and their pros and
    cons before moving to our final version, which is how the Mach5 engine uses it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Singleton模式或获得类似Singleton的行为有多种方式。在介绍我们最终的版本之前，我们将讨论一些常见的版本及其优缺点，这个最终版本是Mach5引擎使用的方式。
- en: 'One very common way of implementing the functionality of the Singleton pattern
    would look something like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Singleton模式功能的一种非常常见的方式可能看起来像以下这样：
- en: '![](img/00021.gif)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.gif)'
- en: 'Through code, it will look a little something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代码，它看起来可能有点像这样：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this class, we have a function called `GetInstance` and a single property
    called `instance`. Note that we are using pointers in this instance, and only
    allocating memory to create our Singleton if we are actually using it. The instance
    property represents the one and only version of our class, hence it being made
    `static.` As it is private though, there is no way for others to access its data
    unless we give them access to it. In order to give this access, we created the
    `GetInstance` function. This function will first check whether instance exists
    and if it doesn't yet, it will dynamically allocate the memory to create one,
    set instance to it, and then return the object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们有一个名为`GetInstance`的函数和一个名为`instance`的单个属性。请注意，我们在这个实例中使用指针，并且只有在实际使用时才分配内存来创建我们的Singleton。实例属性代表我们类的唯一版本，因此它被设置为`static`。尽管它是私有的，但其他人无法访问其数据，除非我们给他们提供访问权限。为了提供这种访问权限，我们创建了`GetInstance`函数。这个函数首先检查实例是否存在，如果不存在，它将动态分配内存来创建一个，将实例设置为它，然后返回对象。
- en: This will only work if instance is properly set to `0` or `nullptr` when initialized,
    which thankfully is the default behavior of static pointers in C++.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在初始化时将实例正确地设置为`0`或`nullptr`时才有效，幸运的是，这是C++中静态指针的默认行为。
- en: Keeping the single in Singleton
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Singleton中保持单一性
- en: 'As we''ve mentioned previously, one of the most important parts of the Singleton
    pattern is the fact that there is only one of those objects. That causes some
    issues with the original code that we''ve written, namely that with some simple
    usage of C++ it is quite easy to have more than one of these classes created by
    other programmers on your team. First and most obviously, they can just create
    a `Singleton` variable (a variable of type `Singleton`) like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，单例模式最重要的部分之一是只有一个这样的对象。这导致了一些与我们所编写的原始代码相关的问题，即在使用一些简单的C++时，其他程序员在您的团队中创建此类类的多个实例相当容易。首先也是最明显的是，他们可以创建一个`Singleton`变量（`Singleton`类型的变量），如下所示：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition, as a higher-level programming language, C++ will try to do some
    things automatically for you when creating classes to eliminate some of the busy
    work that would be involved otherwise. One of these things is automatically creating
    some functionality between classes to enable you to create or copy objects of
    a custom class that we refer to as a constructor and copy constructor. In our
    case, you can also create a copy of your current object in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为高级编程语言，C++在创建类时会尝试自动为您做一些事情，以消除一些否则可能需要手动处理的工作。其中之一是自动在类之间创建一些功能，以便您能够创建或复制自定义类的对象，我们称之为构造函数和复制构造函数。在我们的例子中，您也可以以下方式创建当前对象的副本：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The compiler will also create a default destructor and an assignment operator,
    moving the data from one object to the other.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会创建默认析构函数和赋值运算符，将数据从一个对象移动到另一个对象。
- en: 'Thankfully, that''s a simple enough thing to fix. If we create these functions
    ourselves (declaring an explicit version), C++ notes that we want to do something
    special, so it will not create the defaults. So to fix our problem, we will just
    need to add an assignment operator and some constructors that are private, which
    you can see in the bold code that we''ve changed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个简单的问题。如果我们自己创建这些函数（声明一个显式版本），C++会注意到我们想要做一些特殊的事情，因此它不会创建默认的。因此，为了解决这个问题，我们只需要添加一个赋值运算符和一些私有构造函数，您可以在我们更改的粗体代码中看到这些：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are using C++ 11 or above, it is also possible for us to instead mark
    the functions we don''t want to use as deleted, which would look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是C++ 11或更高版本，我们还可以选择将我们不希望使用的函数标记为已删除，其外观如下：
- en: '`Singleton() = delete;`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton() = delete;`'
- en: '`~Singleton() = delete;`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`~Singleton() = delete;`'
- en: '`Singleton(const Singleton &) = delete;`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton(const Singleton &) = delete;`'
- en: '`Singleton& operator=(const Singleton&) = delete;`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Singleton& operator=(const Singleton&) = delete;`'
- en: For more information on the delete keyword, check out [http://www.stroustrup.com/C++11FAQ.html#default](http://www.stroustrup.com/C++11FAQ.html#default).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于删除关键字（delete）的更多信息，请查看[http://www.stroustrup.com/C++11FAQ.html#default](http://www.stroustrup.com/C++11FAQ.html#default)。
- en: 'Another thing that may possibly be an issue is that instance is a pointer.
    This is because, as a pointer, our users have the ability to call delete on it
    and we want to make sure that the object will always be available for our users
    to access. To minimize this issue, we could change our pointer to be a reference,
    instead, by changing the function to the following (note the return type and that
    we use `*instance` now on the last line):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能成为问题的情况是实例是一个指针。这是因为，作为一个指针，我们的用户有权限调用delete操作，而我们希望确保对象始终可供用户访问。为了最小化这个问题，我们可以通过将函数更改为以下形式（注意返回类型，以及我们在最后一行现在使用`*instance`）来将我们的指针改为引用：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Programmers are used to working with references as aliases for objects that
    exist somewhere else in our project. People would be surprised if they ever saw
    something like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员习惯于使用引用作为项目中其他地方存在的对象的别名。如果他们看到类似以下内容，可能会感到惊讶：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While technically doable, programmers won't expect to ever use delete on the
    address of a reference. The nice thing about using references is that, when you
    need them in code, you know that they exist because they're managed somewhere
    else in the code--and you don't need to worry about how they are used.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可行，但程序员不会期望在引用的地址上使用delete。使用引用的好处是，当您在代码中需要它们时，您知道它们存在，因为它们在代码的某个地方被管理着——您不需要担心它们是如何被使用的。
- en: Deleting our object correctly
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确删除我们的对象
- en: People also are used to looking for memory leaks with pointers and not references,
    so that perhaps leaves us with an issue as, in our current code, we allocate memory
    but don't actually delete it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 人们也习惯于使用指针而不是引用来查找内存泄露，这也许会给我们留下一个问题，即在我们当前的代码中，我们分配了内存但并没有真正删除它。
- en: Now, technically, we haven't created a memory leak. Memory leaks appear when
    you allocate data and lose all of your references to it. Also, modern operating
    systems take care of deallocating a process's memory when our project is quit.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从技术上讲，我们并没有创建内存泄露。内存泄露出现在你分配数据并失去了对它的所有引用时。此外，现代操作系统会在我们的项目退出时负责释放进程的内存。
- en: That's not to say that it's a good thing though. Depending on what information
    the Singleton class uses, we could have references to things that no longer exist
    at some point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不意味着这是一件好事。根据单例类使用的信息，我们可能会在某个时刻引用不再存在的东西。
- en: To have our object delete itself correctly, we need to destroy the Singleton
    when our game shuts down. The only issue is we need to make sure that we do it
    only when we are sure no one will be using the Singleton afterwards.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要让我们的对象正确地删除自己，我们需要在游戏关闭时销毁单例。唯一的问题是，我们需要确保在确定没有人会之后使用单例时才这样做。
- en: 'However, as we want to talk about best practices, it''s much better for us
    to actually solve this issue by removing resource leaks whenever we see them.
    A solution to this very problem was created by *Scott Meyers* in his book *More
    Effective C++*, which uses some of the features of the compiler, namely that a
    static variable located in a function will exist throughout our program''s running
    time. For instance, let''s take the following function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，既然我们要讨论最佳实践，那么在看到资源泄露时实际解决这一问题会更好。针对这个问题的解决方案是由*斯科特·梅耶斯*在他的书《More Effective
    C++》中提出的，他利用了编译器的一些特性，即位于函数中的静态变量将在我们程序的整个运行时间内存在。例如，让我们看看以下函数：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `numberOfEnemies` variable is created and has been initialized before any
    code in the project has been executed, most likely when the game was being loaded.
    Then, once `SpawnEnemy` is called for the first time, it will have already been
    set to `0` (or `nullptr`). Conveniently, as the object is not allocated dynamically,
    the compiler will also create code so that, when the game exists, it will call
    the deconstructor for our object automatically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`numberOfEnemies`变量是在项目中的任何代码执行之前创建和初始化的，很可能是当游戏正在加载时。然后，一旦第一次调用`SpawnEnemy`，它就已经被设置为`0`（或`nullptr`）。方便的是，由于对象不是动态分配的，编译器也会生成代码，以便当游戏退出时，它会自动调用我们的对象的析构函数。'
- en: 'With that in mind, we can modify our Singleton class to the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以将我们的单例类修改如下：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specifically note the changes we've made to the `GetInstance` function and the
    removal of our class instance variable. This method provides the simplest way
    to destroy the `Singleton` class automatically and it works fine for most purposes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意我们对`GetInstance`函数所做的更改以及我们类实例变量的移除。这种方法提供了自动销毁`Singleton`类最简单的方式，并且对于大多数用途来说效果良好。
- en: Learning about templates
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习模板
- en: Another technique to add to your toolbox of programming concepts that we will
    use in the next section is the idea of templates. **Templates** are a way for
    you to be able to create generic classes that can be extended to have the same
    functionality for different datatypes. It's another form of abstraction, letting
    you define a base set of behavior for a class without knowing what type of data
    will be used on it. If you've used the STL before, you've already been using templates,
    perhaps without knowing it. That's why the list class can contain any kind of
    object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种要添加到你的编程概念工具箱中的技术，我们将在下一节中使用，是模板的概念。**模板**是一种让你能够创建泛型类的方法，这些类可以扩展以对不同数据类型具有相同的功能。它是抽象的另一种形式，让你能够为类定义一组基本行为，而无需知道将使用哪种类型的数据。如果你之前使用过STL，那么你已经在使用模板，可能没有意识到。这就是为什么列表类可以包含任何类型的对象。
- en: 'Here''s an example of a simple templated class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的模板类的例子：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we created our `TemplateExample` class and it has three functions.
    The constructor and deconstructor look normal, but then I have this `TemplateFunction`
    function which takes in an object of type `T`, and returns an object of type `T`.
    This `T` comes from the first line of our example code with the template `<class
    T>` section of our code. Anywhere that there is a `T` it will be replaced with
    whatever class we want to use this template with.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了`TemplateExample`类，它有三个函数。构造函数和析构函数看起来很正常，但我有这个`TemplateFunction`函数，它接受一个类型为`T`的对象，并返回一个类型为`T`的对象。这个`T`来自我们示例代码中的第一行，即模板`<class
    T>`部分。任何有`T`的地方都将被替换为我们想要使用此模板的任何类。
- en: 'Now, unlike regular functions, we have to define templated functions within
    our `.h` file, so that, when we need to create an object using this template,
    it will know what the functions will do. In addition to this, the syntax is also
    a bit different:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与常规函数不同，我们必须在我们的`.h`文件中定义模板函数，这样当我们需要使用这个模板创建对象时，它就会知道函数将做什么。此外，语法也有所不同：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, I'm just printing out text to display when a certain functionality
    is called, but I also want to point out the usage of `std::cout` and that using
    it will require you to add `#include <iostream>` to the top of your file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我只是打印出文本以显示当调用特定功能时的显示内容，但我还想指出`std::cout`的使用，使用它需要在文件顶部添加`#include <iostream>`。
- en: We are using the standard library's `cout` function in this instance, instead
    of the `printf` that we have been using, because `cout` allows us to feed in `obj`--no
    matter what its type is--to display something, which isn't possible with `printf`
    by default.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用标准库的`cout`函数，而不是我们之前使用的`printf`，因为`cout`允许我们输入`obj`（无论其类型如何）来显示某些内容，而默认情况下`printf`是无法做到这一点的。
- en: 'Once that''s finished, we can go ahead and use this inside of our project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之后，我们就可以在我们的项目中使用它了：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, this will create three different kinds of `TemplateExample`
    class objects using different types. When we call the `TemplatedFunction` function,
    it will print out exactly the way we were hoping:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这将创建三种不同类型的`TemplateExample`类对象，使用不同的类型。当我们调用`TemplatedFunction`函数时，它将按照我们期望的方式打印出来：
- en: '![](img/00022.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: Later on, when we learn about abstract types, we can use templates with them
    to handle any kind of data. In our case right now, we are going to use this functionality
    to allow us to make as many Singletons as we'd like!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们学习到抽象类型时，我们可以使用模板与它们一起处理任何类型的数据。就我们目前的情况而言，我们将利用这一功能来允许我们创建尽可能多的单例（Singletons）！
- en: Templatizing Singletons
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化单例
- en: 'Now, assuming we get our Singleton working just the way that we want it to,
    you may wish to create more Singletons in the future. You could create them all
    from scratch, but a better thing to do is instead create a consistent approach,
    creating templates and inheritance to create a single implementation that you
    can use for any class. At the same time, we can also learn about an alternative
    way of creating a `Singleton` class, which will look something like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的单例（Singleton）工作得正如我们所期望的那样，你可能会希望在将来创建更多的单例。你可以从头开始创建它们，但更好的做法是创建一个一致的方法，通过创建模板和继承来创建一个单一的实施方案，这样我们就可以为任何类使用它。同时，我们还可以了解创建`Singleton`类的一种替代方法，它看起来可能如下所示：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll notice that most of the differences have to do with the class itself.
    The very first line in our code above uses the `template` keyword which tells
    the compiler that we are creating a template, and `typename T` tells the compiler
    that, when we create a new object using this, the type `T` will be replaced with
    whatever the class we want it to be based on is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，大部分差异都与类本身有关。我们代码中的第一行使用了`template`关键字，这告诉编译器我们正在创建一个模板，而`typename T`告诉编译器，当我们使用这个模板创建新对象时，类型`T`将被替换为我们想要它基于的任何类。
- en: I also want to point out the use of a static cast to convert our Singleton pointer
    to a `T`. `static_cast` is used in code generally when you want to reverse an
    implicit conversion. It's important to note that `static_cast` performs no runtime
    checks for if it's correct or not. This should be used if you know that you refer
    to an object of a specific type, and thus a check would be unnecessary. In our
    case, it is safe because we will be casting from a Singleton object to the type
    that we've derived from it (`T`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出使用静态转换将我们的单例指针转换为`T`的使用。在代码中通常使用`static_cast`来逆转隐式转换。需要注意的是，`static_cast`不会对是否正确执行运行时检查。如果你知道你引用的是特定类型的对象，那么检查是不必要的。在我们的情况下，这是安全的，因为我们将从单例对象转换为从它派生出的类型（`T`）。
- en: 'Of course, it may be useful to see an example of this being used, so let''s
    create an example of a class that we could use as a Singleton, perhaps something
    to manage the high scores for our game:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，看到这个例子被使用可能很有用，所以让我们创建一个可以作为单例使用的类的例子，比如用来管理我们游戏的高分：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice here that, when we declare our `HighScoreManager` class, we say that
    it's derived from the `Singleton` class and, in turn, we pass the `HighScoreManager`
    class to the `Singleton` template. This pattern is known as the curiously recurring
    template pattern.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，当我们声明我们的`HighScoreManager`类时，我们说它继承自`Singleton`类，并且反过来，我们将`HighScoreManager`类传递给`Singleton`模板。这种模式被称为“好奇地重复出现的模板模式”。
- en: For more information on the curiously recurring template pattern, check out
    [https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“好奇地重复出现的模板模式”的更多信息，请查看[https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)。
- en: 'After defining the class, let''s go ahead and add in an example implementation
    for the function we''ve created for this class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了类之后，让我们继续添加我们为这个类创建的函数的示例实现：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By using the templatized version of our class, we don't need to create the same
    materials as in the preceding class. We can just focus on the stuff that is particular
    to what this class needs to do. In this case, it's checking our current high score,
    and setting it to whatever we pass in if we happen to beat it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们类的模板化版本，我们不需要创建与上一个类相同的材料。我们只需关注这个类需要做的特定事情。在这种情况下，它是检查我们的当前最高分，并在我们打破它时将其设置为传递给我们的任何值。
- en: 'Of course, it''s great to see our code in action, and in this case I used the
    `SplashStage` class, which is located in the Mach5 `EngineTest` project, under
    `SpaceShooter/Stages/SplashStage.cpp`. To do so, I added the following bolded
    lines to the `Init` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，看到我们的代码在运行中是件好事，在这种情况下，我使用了位于Mach5 `EngineTest`项目下的`SpaceShooter/Stages/SplashStage.cpp`中的`SplashStage`类。为此，我在`Init`函数中添加了以下加粗的行：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, our instance has been created by us creating a new `HighScoreManager`.
    If that is not done, then our project could potentially crash when calling `GetInstance`,
    so it''s very important to call it. Then call our `CheckHighScore` functions a
    number of times to verify that the functionality works correctly. Then, in the
    `Shutdown` function, add the following bolded line to make sure the Singleton
    is removed correctly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的实例是通过创建一个新的`HighScoreManager`来创建的。如果没有这样做，那么当调用`GetInstance`时，我们的项目可能会崩溃，所以非常重要的一点是要调用它。然后多次调用我们的`CheckHighScore`函数以验证功能是否正确工作。然后，在`Shutdown`函数中，添加以下加粗的行以确保单例被正确删除：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With all of that gone, go ahead, save the file, and run the game. The output
    will be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都完成之后，保存文件，并运行游戏。输出将如下所示：
- en: '![](img/00023.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: As you can see, our code works correctly!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的代码运行正确！
- en: Note that this has the same disadvantages we discussed with our initial version
    of the script, with the fact that we have to manually create the object and remove
    it; but it takes away a lot of the busy work when creating a number of Singletons
    in your project. If you're going to be creating a number of them in your project,
    this could be a good method to look into.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与我们最初脚本版本中讨论的缺点相同，即我们必须手动创建对象并删除它；但它减少了在项目中创建多个单例时的许多繁琐工作。如果你打算在项目中创建多个，这可能是一个值得考虑的方法。
- en: Advantages/disadvantages of using only one instance
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个实例的优点/缺点
- en: There is the possibility that as you continue your project, something that looks
    at the time to be a thing that you'll only need one of will suddenly turn into
    something you need more of down the road. In games, one of the easiest examples
    would be that of a player. When starting the game, you may think you're only going
    to have one player, but maybe later you decide to add co-op. Depending on what
    you did before, that can be a small or huge change to the project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能在你继续你的项目过程中，原本看起来只需要一个实例的东西，突然变成你需要更多实例的情况。在游戏中，一个最简单的例子就是玩家。当你开始游戏时，你可能认为你只会有一个玩家，但也许后来你决定添加合作模式。根据你之前所做的，这可能对项目造成小的或巨大的变化。
- en: Finally, one of the more common mistakes we see once programmers learn about
    Singletons, is to create managers for everything, and then make the managers all
    Singletons.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦程序员了解了单例模式，我们经常看到的一个更常见的错误是，为每一件事都创建管理器，然后让所有管理器都成为单例。
- en: The Singleton in action - the Application class
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式在实际中的应用 - 应用程序类
- en: The Singleton pattern achieves its ability to be accessible anywhere easily
    by having a special function that we use to get the `Singleton` object. When this
    function is called, we will check whether that object has been created yet. If
    it has, then we will simple return a reference to the object. If not, we will
    create it, and then return a reference to the newly created object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式通过拥有一个特殊函数来实现其易于在任何地方访问的能力。我们使用这个函数来获取 `Singleton` 对象。当这个函数被调用时，我们将检查该对象是否已经被创建。如果已经创建，我们将简单地返回对该对象的引用。如果没有，我们将创建它，然后返回对新创建对象的引用。
- en: Now, in addition to having this way to access it, we also want to block off
    our user from being able to create them, so we will need to define our class constructors
    to be private.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除了有这种访问方式之外，我们还想阻止用户创建它们，因此我们需要将我们的类构造函数定义为私有的。
- en: Now that we have an understanding of some implementations of the Singleton,
    we have one other version, which is what we actually used within the Mach5 engine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单例模式的一些实现方式，我们还有一个版本，这是我们实际上在 Mach5 引擎中使用的版本。
- en: In Mach5, the only Singletons that are included are aspects of the engine code.
    The engine code is designed to work with any game, meaning there is nothing gameplay-specific
    about it, which means that it doesn't need to have instances since they're just
    instructions. Building the engine in this way makes it much easier in the future
    to bring this to other games, since it's been removed from anything that's game-specific.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mach5 中，包含的单例只有引擎代码的方面。引擎代码被设计成可以与任何游戏一起工作，这意味着它没有任何游戏特定的内容，这意味着它不需要有实例，因为它们只是指令。以这种方式构建引擎使得将来将其带到其他游戏中变得更加容易，因为它已经从任何特定于游戏的内容中分离出来。
- en: 'In this case, let''s open up the `M5App.h` file which is in the `EngineTest`
    project under `Core/Singletons/App` and take a look at the class itself:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，让我们打开位于 `EngineTest` 项目下的 `Core/Singletons/App` 目录中的 `M5App.h` 文件，看看类本身：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the Mach5 engine follows the Singleton pattern. However, it is done in
    a different way from the others that we've looked at so far. You may notice in
    the class definition that every single function and variable that was created
    was made static.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Mach5 引擎遵循单例模式。然而，它的实现方式与之前我们所看到的有所不同。你可能注意到在类定义中，每个创建的函数和变量都被设置为静态的。
- en: This provides us with some unique benefits, namely that we don't need to worry
    about the user creating multiple versions of the class, because they'll only be
    restricted to using static properties and variables that are shared by everything.
    This means we don't need to worry about all of those fringe cases we mentioned
    in the previous examples that we've seen. This is possibly due to the fact that
    the Mach5 engine classes have no need to have child classes; there's no need for
    us to create a pointer or even call a `GetInstance` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一些独特的优势，即我们不需要担心用户创建类的多个版本，因为他们将仅限于使用静态属性和变量，这些属性和变量被一切共享。这意味着我们不需要担心之前提到的那些边缘情况。这可能是因为
    Mach5 引擎的类不需要有子类；我们不需要创建指针，甚至不需要调用 `GetInstance` 函数。
- en: 'You''ll also notice the `Init`, `Update`, and `Shutdown` functions mentioned
    previously. We mentioned before that it was a disadvantage to manually have to
    create and destroy our `singleton` classes, but there are some distinct benefits
    to having this control. In the previous examples we had, the order in which classes
    were created was up to the compiler as we couldn''t control the order. However,
    with our game engine it makes sense to create our Application (`M5App`) before
    we start up the graphics library (`M5Gfx`) and the only way we can make sure that
    happens is by telling our engine to do so, which you can look at if you open up
    the `Main.cpp` file and look at the `WinMain` function, which is what opens first
    when we create our project. I''ve gone ahead and bolded the uses of `M5App`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到之前提到的 `Init`、`Update` 和 `Shutdown` 函数。我们之前提到，手动创建和销毁我们的 `singleton` 类是一个缺点，但有一些明显的优势。在之前的例子中，类的创建顺序由编译器决定，因为我们无法控制顺序。然而，在我们的游戏引擎中，在启动图形库
    (`M5Gfx`) 之前创建我们的应用程序 (`M5App`) 是有意义的，而我们确保这一点的唯一方法就是告诉我们的引擎这样做，您可以查看 `Main.cpp`
    文件中的 `WinMain` 函数，这是我们在创建项目时首先打开的。我已经提前将 `M5App` 的使用加粗：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Afterwards, we can look at the `Init` function of `M5App` and see that it will
    initialize the other Singletons in our project:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以查看 `M5App` 的 `Init` 函数，并看到它将初始化我们项目中的其他单例：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By having this control, our users have a much better idea as to the flow and
    order that things will be created. But, of course, with that great power comes
    great responsibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种控制，我们的用户对事物创建的流程和顺序有了更好的了解。但当然，有了这种巨大的力量，也伴随着巨大的责任。
- en: The Singleton pattern is used only for single-threaded applications. Should
    you be developing a multithreaded game, you'll want to use the Double-Checked
    Locking pattern instead, which was created by *Doug Schmidt* and *Tim Harrison*.
    If you're interested in learning more about it, check out [https://en.wikipedia.org/wiki/Double-checked_locking](https://en.wikipedia.org/wiki/Double-checked_locking).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式仅适用于单线程应用程序。如果您正在开发一个多线程游戏，您将希望使用由 *Doug Schmidt* 和 *Tim Harrison* 创建的双重检查锁定模式，您可以查看更多关于它的信息：[https://en.wikipedia.org/wiki/Double-checked_locking](https://en.wikipedia.org/wiki/Double-checked_locking)。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have demystified a lot of programming concepts in a quick
    refresher. We also started learning about our first design pattern, the Singleton,
    which is intended to allow us to always have access to a class's functions and
    variables due to the fact that there will only ever be one of these objects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速回顾了许多编程概念，并开始学习我们的第一个设计模式——单例，它旨在使我们始终能够访问类的函数和变量，因为将只有一个这样的对象。
- en: We discussed some of the typical downfalls of using the Singleton pattern, such
    as the possibility that objects could have multiple copies of them in the future,
    even if this is unlikely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用单例模式的一些典型缺陷，例如，即使这种情况不太可能，对象未来可能会有多个副本。
- en: We learned about three different kinds of method for creating Singletons, starting
    off with the *Singleton*, then extending it and templating parts of it to create
    the curiously reoccurring template pattern, and then we saw a final all-static
    version of getting the same effect with minimal hassle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了创建单例的三种不同方法，从 *Singleton* 开始，然后扩展它并对其部分进行模板化以创建奇特重复的模板模式，然后我们看到了一个最终的无缝静态版本，以最小的麻烦达到相同的效果。
- en: 'Each of these methods has their own pros and cons, and we hope that you use
    them effectively, where they are relevant. Now that we''ve touched on the design
    pattern everyone is familiar with, we can move towards our next challenge: learning
    about how to deal with logic that is specific to each of our individual games.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法各有优缺点，我们希望您能有效地使用它们，在相关的地方使用。现在我们已经触及了大家熟悉的模式设计，我们可以转向下一个挑战：学习如何处理我们每个游戏特有的逻辑。
