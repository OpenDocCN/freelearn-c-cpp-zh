- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing the Raptor Engine and Hydra
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Raptor 引擎和 Hydra
- en: When we set out to write this book, we decided our goal was to start where a
    traditional Vulkan tutorial might end. There are plenty of great resources, both
    in print and on the web, that help beginners discover and understand the Vulkan
    API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写本书时，我们决定我们的目标是开始于一个传统的 Vulkan 教程可能结束的地方。无论是印刷品还是网络上的资源，都有很多很好的资源可以帮助初学者发现和理解
    Vulkan API。
- en: We decided to write this book as we felt there was a gap between these introductory
    tutorials and some of the more advanced material. Some of these topics might be
    covered in articles and blog posts, but we couldn’t find a resource that organized
    them in a single and cohesive format.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定编写这本书，因为我们感觉到这些入门教程和更高级的材料之间存在差距。其中一些主题可能在文章和博客文章中有所涉及，但我们找不到一个资源能够将它们组织成一个单一和连贯的格式。
- en: While we assume some familiarity with Vulkan, in this chapter, we take the opportunity
    to go over some of the basic concepts that we will build upon throughout the remainder
    of the book. We will present the code organization and the classes and libraries
    that we use throughout the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们假设您对 Vulkan 有一定的了解，但在本章中，我们有机会回顾一些我们将贯穿本书剩余部分的基本概念。我们将展示本书中使用的代码组织、类和库。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: How to read this book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何阅读本书
- en: Understanding the code structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码结构
- en: Understanding the glTF scene format
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 glTF 场景格式
- en: Physically based rendering in a nutshell
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理渲染概述
- en: A word on GPU debugging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 GPU 调试的一些建议
- en: By the end of this chapter, you will be familiar with the Raptor Engine and
    the rendering framework we developed for this book. You will have also learned
    the structure of the glTF model format and the base concepts behind physically
    based rendering.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将熟悉 Raptor 引擎和本书中开发的渲染框架。您还将了解 glTF 模型格式的结构和物理渲染背后的基本概念。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a GPU that supports at least Vulkan 1.1\. At the time of writing,
    Vulkan 1.3 had just been announced and many vendors, such as AMD and Nvidia, have
    provided day-one support. We have kept the lower requirements to allow as many
    people as possible to follow along.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个至少支持 Vulkan 1.1 的 GPU。在本书编写时，Vulkan 1.3 刚刚发布，许多厂商，如 AMD 和 Nvidia，都提供了第一天支持。我们保留了较低的要求，以便尽可能多的人能够跟随学习。
- en: Some of the later chapters will make use of hardware features that might not
    be available on some of the older graphics cards. Wherever possible, we will provide
    an alternative software solution. If it’s not feasible, we try to focus more on
    the generic aspects of the implementation and less on the API details.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后续章节将使用一些较老显卡可能不具备的硬件功能。 wherever possible, we will provide an alternative
    software solution. If it’s not feasible, we try to focus more on the generic aspects
    of the implementation and less on the API details.
- en: The complete code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter1](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter1](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter1)。
- en: Windows
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: The code has been tested on Windows with Visual Studio 2019 16.11 and the Vulkan
    SDK version 1.2.198.1 (this might change as we write the book).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已在 Windows 系统上使用 Visual Studio 2019 16.11 和 Vulkan SDK 版本 1.2.198.1 进行了测试（在编写本书时，这可能会发生变化）。
- en: 'To install the Vulkan SDK on Windows, you will need to download and run the
    following executable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上安装 Vulkan SDK，您需要下载并运行以下可执行文件：
- en: '[https://sdk.lunarg.com/sdk/download/1.2.198.1/windows/VulkanSDK-1.2.198.1-Installer.exe](https://sdk.lunarg.com/sdk/download/1.2.198.1/windows/VulkanSDK-1.2.198.1-Installer.exe%0D)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sdk.lunarg.com/sdk/download/1.2.198.1/windows/VulkanSDK-1.2.198.1-Installer.exe](https://sdk.lunarg.com/sdk/download/1.2.198.1/windows/VulkanSDK-1.2.198.1-Installer.exe%0D)'
- en: After installing the Vulkan SDK, make sure you can run the `vulkaninfoSDK.exe`
    program in the `Bin` folder to confirm that the SDK has been installed correctly
    and that your graphics drivers support Vulkan.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Vulkan SDK 后，请确保您可以在“Bin”文件夹中运行 `vulkaninfoSDK.exe` 程序，以确认 SDK 已正确安装，并且您的图形驱动程序支持
    Vulkan。
- en: Please check the official documentation ([https://vulkan.lunarg.com/doc/sdk/latest/windows/getting_started.xhtml](https://vulkan.lunarg.com/doc/sdk/latest/windows/getting_started.xhtml))
    should you need further details on the installation process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于安装过程的更多详细信息，请参考官方文档([https://vulkan.lunarg.com/doc/sdk/latest/windows/getting_started.xhtml](https://vulkan.lunarg.com/doc/sdk/latest/windows/getting_started.xhtml))。
- en: We have provided a Visual Studio solution that contains the full code for the
    book and that allows you to easily build the executable for each chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个包含本书全部代码的Visual Studio解决方案，它允许你轻松地为每一章构建可执行文件。
- en: 'Once the solution has been built, set the `Chapter1` project as the run target
    and run the program. Here’s what you should be seeing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决方案构建完成，将`Chapter1`项目设置为运行目标并运行程序。你应该看到以下内容：
- en: '![Figure 1.1 – The rendering result](img/B18395_01_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 渲染结果](img/B18395_01_01.jpg)'
- en: Figure 1.1 – The rendering result
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 渲染结果
- en: Linux
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: For Linux, we have used Visual Studio Code, GCC 9 or above, and CMake 3.22.1\.
    The version of the Vulkan SDK matches the one on Windows. We tested both on Debian
    11 and Ubuntu 20.04.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，我们使用了Visual Studio Code、GCC 9或更高版本以及CMake 3.22.1。Vulkan SDK的版本与Windows上的版本相匹配。我们在Debian
    11和Ubuntu 20.04上进行了测试。
- en: We have used CMake to support different build systems, but we have only tested
    with Makefile.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了CMake来支持不同的构建系统，但我们只测试了Makefile。
- en: 'To install the Vulkan SDK, you will need to download this file: [https://sdk.lunarg.com/sdk/download/1.2.198.1/linux/vulkansdk-linux-x86_64-1.2.198.1.tar.gz](https://sdk.lunarg.com/sdk/download/1.2.198.1/linux/vulkansdk-linux-x86_64-1.2.198.1.tar.gz).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Vulkan SDK，你需要下载此文件：[https://sdk.lunarg.com/sdk/download/1.2.198.1/linux/vulkansdk-linux-x86_64-1.2.198.1.tar.gz](https://sdk.lunarg.com/sdk/download/1.2.198.1/linux/vulkansdk-linux-x86_64-1.2.198.1.tar.gz)。
- en: 'Assuming you have downloaded it in the `~/Downloads` folder, extract the package
    by running the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经将它下载到了`~/Downloads`文件夹中，通过运行以下命令来解压该包：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create the `1.2.198.1` top-level folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`1.2.198.1`顶级文件夹。
- en: 'There are two options to make the SDK available to build the code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使SDK可用于构建代码：
- en: 'You can add the following environment variables to your `~/.bashrc` file (or
    the main configuration file of your shell if you are not using Bash). Please note
    that you might have to create this file:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将以下环境变量添加到你的`~/.bashrc`文件中（或者如果你不使用Bash，那么是你的shell的主要配置文件）。请注意，你可能需要创建此文件：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The other option is to add the following to your `~/.``bashrc` file:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是将以下内容添加到你的`~/.bashrc`文件中：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After you have edited the `~/.bashrc` file, restart your Terminal. You should
    now be able to run `vulkaninfo`. If that’s not the case, try to follow the previous
    steps again. Please refer to the official LunarG guide ([https://vulkan.lunarg.com/doc/sdk/latest/linux/getting_started.xhtml](https://vulkan.lunarg.com/doc/sdk/latest/linux/getting_started.xhtml))
    should you need more details on the installation process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编辑了`~/.bashrc`文件之后，重启你的终端。现在你应该能够运行`vulkaninfo`了。如果不行，请再次尝试前面的步骤。如果你需要关于安装过程的更多详细信息，请参考官方LunarG指南([https://vulkan.lunarg.com/doc/sdk/latest/linux/getting_started.xhtml](https://vulkan.lunarg.com/doc/sdk/latest/linux/getting_started.xhtml))。
- en: 'To generate the build files, you need to run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成构建文件，你需要运行以下命令：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you’d like to create a release build, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个发布版本，请运行以下命令：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create the build files in the `build` folder. You can, of course,
    use a different name for the folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`build`文件夹中创建构建文件。当然，你也可以为文件夹使用不同的名称。
- en: 'To build the code for this chapter, run the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这一章构建代码，请运行以下命令：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The number after `-j` tells the compiler how many threads to use to compile
    the code in parallel. The recommended value is to use the number of cores your
    processor has.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j`后面的数字告诉编译器使用多少线程并行编译代码。建议使用处理器核心数作为数值。'
- en: After the build has completed, the `Chapter1` executable has been created and
    is ready to run!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，`Chapter1`可执行文件已经创建并准备好运行！
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Both Windows and Linux builds have been tested throughout the writing of the
    book by our technical reviewers and beta readers, but some issues might have gone
    unnoticed. If you have questions or if you would like to report an issue, please
    open a GitHub issue or reach out to us on Twitter: `@marco_castorina` and `@GabrielSassone`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的编写过程中，我们的技术审查员和Beta读者对Windows和Linux的构建进行了测试，但可能有一些问题未被注意到。如果你有任何问题或想要报告问题，请打开GitHub问题或通过Twitter联系我们：`@marco_castorina`和`@GabrielSassone`。
- en: macOS
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS
- en: Vulkan is not natively available on macOS but is provided through a translation
    layer into Metal, the graphics API developed by Apple. This translation layer
    is provided by the Vulkan SDK with the MoltenVK library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 在 macOS 上不是原生可用的，但通过苹果开发的图形 API Metal 的转换层提供。这个转换层由 Vulkan SDK 和 MoltenVK
    库提供。
- en: Because of this indirection, not all features and extensions are available on
    macOS. Given that we are going to make use of some advanced features such as ray
    tracing in this book, we didn’t want to provide a partially working version of
    our code for macOS. For the time being, this platform is not supported.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种间接性，并非所有功能和扩展都在 macOS 上可用。鉴于我们将在本书中使用一些高级功能，如光线追踪，我们不希望为 macOS 提供一个部分工作的代码版本。目前，这个平台不受支持。
- en: How to read this book
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何阅读本书
- en: We have organized the content of this book to gradually build on more advanced
    features. Advanced chapters in this book will rely on topics exposed earlier in
    the book. For this reason, we suggest that you read the book in order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经组织了本书的内容，以便逐步构建更高级的功能。本书的高级章节将依赖于本书早期暴露的主题。因此，我们建议你按顺序阅读本书。
- en: However, some of the later chapters on ray tracing could be read in any order
    as they cover topics that can be developed independently. If you are already familiar
    with the topic in one of the chapters, we still recommend that you skim through
    it as you might still find some valuable information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于光线追踪的一些后续章节可以按任何顺序阅读，因为它们涵盖了可以独立发展的主题。如果你已经在某个章节中对这个主题有所了解，我们仍然建议你快速浏览一下，因为你可能还会找到一些有价值的信息。
- en: Understanding the code structure
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码结构
- en: In this section, we will deep dive into the foundational code used throughout
    the book and we will explain the rationale behind some of the decisions we made.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨本书中使用的底层代码，并解释我们做出的一些决策背后的原因。
- en: 'When we started thinking about the code to be used, the objective was clear:
    there was the need for something lightweight, simple, and basic enough to give
    us the possibility to build upon it. A fully fledged library would have been too
    much.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始考虑要使用的代码时，目标很明确：我们需要一个轻量级、简单且足够基础的代码，以便我们能够在此基础上进行构建。一个功能齐全的库会过于复杂。
- en: Also, we needed something that we were familiar with to make the development
    process smoother and give us confidence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一些我们熟悉的东西来使开发过程更加顺利并增强我们的信心。
- en: There are different great libraries out there, such as Sokol ([https://github.com/floooh/sokol](https://github.com/floooh/sokol))
    or BGFX ([https://github.com/bkaradzic/bgfx](https://github.com/bkaradzic/bgfx)),
    and a few more, but they all have some drawbacks that seemed problematic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有多个优秀的库，例如 Sokol ([https://github.com/floooh/sokol](https://github.com/floooh/sokol))
    或 BGFX ([https://github.com/bkaradzic/bgfx](https://github.com/bkaradzic/bgfx))，以及其他一些库，但它们都有一些缺点，似乎存在问题。
- en: Sokol, for example, even though it is a great library, does not support the
    Vulkan API, and has an interface still based on older graphics APIs (such as OpenGL
    and D3D11).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Sokol 虽然是一个优秀的库，但它不支持 Vulkan API，并且其接口仍然基于较旧的图形 API（如 OpenGL 和 D3D11）。
- en: BGFX is a more complete library, but it is a little too generic and feature-fledged
    to give us the possibility to build upon it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: BGFX 是一个更完整的库，但它过于通用且功能丰富，以至于我们无法在此基础上进行构建。
- en: After some research, we leaned toward the Hydra Engine – a library that Gabriel
    developed in the last couple of years as code to experiment with and write articles
    on rendering.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番研究，我们倾向于选择 Hydra 引擎——这是一个加布里埃尔在过去几年中开发，用于实验和撰写关于渲染文章的代码库。
- en: 'Here are some advantages of starting from the Hydra Engine ([https://github.com/JorenJoestar/DataDrivenRendering](https://github.com/JorenJoestar/DataDrivenRendering))
    and evolving it into the Raptor Engine:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Hydra 引擎（[https://github.com/JorenJoestar/DataDrivenRendering](https://github.com/JorenJoestar/DataDrivenRendering)）并逐步将其发展成为
    Raptor 引擎的一些优势：
- en: Code familiarity
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码熟悉度
- en: Small and simple code base
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小巧简单的代码库
- en: Vulkan-based API
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Vulkan 的 API
- en: No advanced features, but strong building blocks
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有高级功能，但强大的构建块
- en: The Hydra Engine seemed perfect, being small but usable and familiar. From an
    API design perspective, it was a clear advantage compared to other libraries that
    both authors had used in the past.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Hydra 引擎看起来完美，小巧但可用且熟悉。从 API 设计的角度来看，与其他两位作者过去使用的库相比，它具有明显的优势。
- en: Being designed from scratch by Gabriel, evolving the code through this book
    is done with the full knowledge of the underlying architecture.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Gabriel从头开始设计，通过本书演变代码时，对底层架构有全面了解。
- en: Starting from the Hydra Engine, we changed some code to be more Vulkan-focused,
    and thus the Raptor Engine was born. In the following sections, we will have a
    brief look at the code architecture to familiarize you with the building blocks
    that will be used throughout all the chapters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从Hydra引擎开始，我们对一些代码进行了修改，使其更加专注于Vulkan，因此诞生了Raptor引擎。在接下来的章节中，我们将简要地看一下代码架构，以便您熟悉将在所有章节中使用的构建块。
- en: We will also look at the glTF data format used to import meshes, textures, and
    materials into the Raptor Engine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看用于将网格、纹理和材料导入Raptor引擎的glTF数据格式。
- en: Layers of code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码层
- en: The Raptor Engine is created with a layer-based mentality for code, in which
    a layer can interact only with lower ones.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Raptor引擎是以基于层的思维方式创建的，其中一层只能与较低层交互。
- en: This choice was made to simplify communication between layers and simplify the
    API design and the expected behavior for the final user.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择是为了简化层之间的通信，简化API设计和最终用户期望的行为。
- en: 'There are three layers in Raptor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Raptor有三个层：
- en: Foundation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础
- en: Graphics
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形
- en: Application
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: The `source/raptor`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`source/raptor`。'
- en: Each chapter has its own implementation of the `source/chapter1/graphics`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都有自己的`source/chapter1/graphics`实现。
- en: While developing the Raptor Engine, we enforced the communication direction
    based on the layer we were on, so that a layer could interact with the code within
    the same layer and the bottom layer only.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Raptor引擎时，我们根据所在的层强制执行通信方向，以便一层只能与同一层内的代码和底层交互。
- en: In this case, the foundation layer can interact only with the other code inside
    the layer, the graphics layer can interact with the foundation layer, and the
    application layer interacts with all the layers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，基础层只能与层内的其他代码交互，图形层可以与基础层交互，应用层与所有层交互。
- en: There will be possible situations where we need to have some communication from
    a bottom layer to an upper layer, and the solution to that is to create code in
    the upper layer to drive the communication between the lower layers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有需要从底层到上层进行通信的情况，解决这个问题的方法是，在上层创建代码来驱动底层之间的通信。
- en: For example, the `Camera` class is defined in the foundation layer, and it is
    a class that contains all the mathematical code to drive a rendering camera.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Camera`类定义在基础层，它是一个包含所有驱动渲染相机的数学代码的类。
- en: What if we need user input to move the camera, say with a mouse or gamepad?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要用户输入来移动相机，比如用鼠标或游戏手柄，怎么办？
- en: Based on this decision, we created `GameCamera` in the application layer, which
    contains the input code, takes the user input, and modifies the camera as needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个决定，我们在应用层创建了`GameCamera`，它包含输入代码，接收用户输入，并根据需要修改相机。
- en: This upper layer bridging will be used in other areas of the code and will be
    explained when needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种上层桥接将在代码的其他区域使用，并在需要时进行解释。
- en: The following sections will give you an overview of the main layers and some
    of their fundamental code so that you will be familiar with all the available
    building blocks that will be used throughout the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将为您概述主要层和一些基本代码，以便您熟悉将在整本书中使用的所有可用构建块。
- en: Foundation layer
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础层
- en: The foundation layer is a set of different classes that behave as fundamental
    bricks for everything needed in the framework.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基础层是一组不同的类，它们作为框架中所需一切的基本砖块。
- en: The classes are very specialized and cover different types of needs, but they
    are required to build the rendering code written in this book. They range from
    data structures to file operations, logging, and string processing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类非常专业化，覆盖了不同的需求类型，但它们是构建本书中编写的渲染代码所必需的。它们包括数据结构、文件操作、日志记录和字符串处理。
- en: While similar data structures are provided by the C++ standard library, we have
    decided to write our own as we only need a subset of functionality in most cases.
    It also allows us to carefully control and track memory allocations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++标准库提供了类似的数据结构，但我们决定自己编写，因为在大多数情况下我们只需要功能子集。这也允许我们仔细控制和跟踪内存分配。
- en: We traded some comfort (that is, automatic release of memory on destruction)
    for more fine-tuned control over memory lifetime and better compile times. These
    all-important data structures are used for separate needs and will be used heavily
    in the graphics layer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了获得对内存生命周期更精细的控制和更好的编译时间，牺牲了一些舒适度（即自动释放内存）。这些至关重要的数据结构用于不同的需求，将在图形层中被大量使用。
- en: We will briefly go over each foundational block to help you get accustomed to
    them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地回顾每个基础模块，以帮助您熟悉它们。
- en: Memory management
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存管理
- en: Let’s start with `source/raptor/foundation/memory.hpp`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`source/raptor/foundation/memory.hpp`）开始。
- en: One key API decision made here is to have an explicit allocation model, so for
    any dynamically allocated memory, an allocator will be needed. This is reflected
    in all classes through the code base.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里做出的一个关键API决策是采用显式分配模型，因此对于任何动态分配的内存，都需要一个分配器。这一点在代码库中的所有类中都有体现。
- en: This foundational brick defines the main allocator API used by the different
    allocators that can be used throughout the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础模块定义了不同分配器使用的主要分配器API。
- en: There is `HeapAllocator`, based on the `tlsf` allocator, a fixed-size linear
    allocator, a malloc-based allocator, a fixed-size stack allocator, and a fixed-size
    double stack allocator.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有`HeapAllocator`，基于`tlsf`分配器，一个固定大小的线性分配器，一个基于malloc的分配器，一个固定大小的栈分配器，以及一个固定大小的双栈分配器。
- en: While we will not cover memory management techniques here, as it is less relevant
    to the purpose of this book, you can glimpse a more professional memory management
    mindset in the code base.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在这里介绍内存管理技术，因为它与本书的目的不太相关，但您可以在代码库中窥见更专业的内存管理思维。
- en: Arrays
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组
- en: Next, we will look at `source/raptor/foundation/array.hpp`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`source/raptor/foundation/array.hpp`）。
- en: Probably the most fundamental data structure of all software engineering, arrays
    are used to represent contiguous and dynamically allocated data, with an interface
    similar to the better-known `std::vector` ([https://en.cppreference.com/w/cpp/container/vector](https://en.cppreference.com/w/cpp/container/vector)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是所有软件工程中最基本的数据结构，数组用于表示连续和动态分配的数据，其接口类似于更为人所知的`std::vector` ([https://en.cppreference.com/w/cpp/container/vector](https://en.cppreference.com/w/cpp/container/vector))。
- en: The code is simpler compared to the `std`) implementation and requires an explicit
    allocator to be initialized.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std`实现相比，代码更简单，需要显式初始化分配器。
- en: The only notable difference from `std::vector` can be seen in the methods, such
    as `push_use()`, which grows the array and returns the newly allocated element
    to be filled, and the `delete_swap()` method, which removes an element and swaps
    it with the last element.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::vector`相比，唯一的显著区别可能在于方法，例如`push_use()`，它扩展数组并返回新分配的元素以便填充，以及`delete_swap()`方法，它删除一个元素并将其与最后一个元素交换。
- en: Hash maps
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希表
- en: '`source/raptor/foundation/hash_map.hpp`) are another fundamental data structure,
    as they boost search operation performance, and they are used extensively in the
    code base: every time there is the need to quickly find an object based on some
    simple search criteria (*search the texture by name*), then a hash map is the
    de facto standard data structure.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`source/raptor/foundation/hash_map.hpp`)是另一种基本的数据结构，因为它们提高了搜索操作的性能，并且在代码库中被广泛使用：每当需要根据一些简单的搜索标准（*按名称搜索纹理*）快速查找对象时，哈希表就是事实上的标准数据结构。'
- en: 'The sheer volume of information about hash maps is huge and out of the scope
    of this book, but recently a good all-round implementation of hash maps was documented
    and shared by Google inside their Abseil library (code available here: [https://github.com/abseil/abseil-cpp](https://github.com/abseil/abseil-cpp)).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哈希表的信息量巨大，超出了本书的范围，但最近谷歌在其Abseil库中记录并共享了一个良好的哈希表全面实现（代码在此处可用：[https://github.com/abseil/abseil-cpp](https://github.com/abseil/abseil-cpp)）。
- en: The Abseil hash map is an evolution of the SwissTable hash map, storing some
    extra metadata per entry to quickly reject elements, using linear probing to insert
    elements, and finally, using Single Instruction Multiple Data (SIMD) instructions
    to quickly test more entries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Abseil哈希表是SwissTable哈希表的演变，每个条目存储一些额外的元数据以快速拒绝元素，使用线性探测插入元素，最后使用单指令多数据（SIMD）指令快速测试更多条目。
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For a good overview of the ideas behind the Abseil hash map implementation,
    there are a couple of nice articles that can be read. They can be found here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Article** **1**: [https://gankra.github.io/blah/hashbrown-tldr/](https://gankra.github.io/blah/hashbrown-tldr/%0D)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Article** **2**: [https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/](https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*Article 1* is a good overview of the topic and *Article 2* goes a little more
    in-depth about the implementation.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we will look at `source/raptor/foundation/file.hpp`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Another common set of operations performed in an engine is file handling, for
    example, to read a texture, a shader, or a text file from the hard drive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: These operations follow a similar pattern to the C file APIs, such as `file_open`
    being similar to the `fopen` function ([https://www.cplusplus.com/reference/cstdio/fopen/](https://www.cplusplus.com/reference/cstdio/fopen/)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In this set of functions, there are also the ones needed to create and delete
    a folder, or some utilities such as extrapolating the filename or the extension
    of a path.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For example, to create a texture, you need to first open the texture file in
    memory, then send it to the graphics layer to create a Vulkan representation of
    it to be properly usable by the GPU.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`source/raptor/foundation/blob_serialization.hpp`), the process of converting
    human-readable files to a binary counterpart, is also present here.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The topic is vast, and there is not as much information as it deserves, but
    a good starting point is the article [https://yave.handmade.network/blog/p/2723-how_media_molecule_does_serialization](https://yave.handmade.network/blog/p/2723-how_media_molecule_does_serialization),
    or [https://jorenjoestar.github.io/post/serialization_for_games](https://jorenjoestar.github.io/post/serialization_for_games).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We will use serialization to process some human-readable files (mostly JSON
    files) into more custom files as they are needed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The process is done to speed up loading files, as human-readable formats are
    great for expressing things and can be modified, but binary files can be created
    to suit the application’s needs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This is a fundamental step in any game-related technology, also called **asset
    baking**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this code, we will use a minimal amount of serialization,
    but as with memory management, it is a topic to have in mind when designing any
    performant code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`source/raptor/foundation/log.hpp`) is the process of writing some user-defined
    text to both help understand the flow of the code and debug the application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: It can be used to write the initialization steps of a system or to report some
    error with additional information so it can be used by the user.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Provided with the code is a simple logging service, providing the option of
    adding user-defined callbacks and intercepting any message.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: An example of logging usage is the Vulkan debug layer, which will output any
    warning or error to the logging service when needed, giving the user instantaneous
    feedback on the application’s behavior.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 日志使用的一个例子是Vulkan调试层，当需要时，它将任何警告或错误输出到日志服务，为用户提供关于应用程序行为的即时反馈。
- en: String processing
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串处理
- en: Next, we will look at `source/raptor/foundation/string.hpp`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`source/raptor/foundation/string.hpp`)。
- en: Strings are arrays of characters used to store text. Within the Raptor Engine,
    the need to have clean control of memory and a simple interface added the need
    for custom-written string code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是用于存储文本的字符数组。在Raptor引擎中，需要干净地控制内存和简单的接口，这增加了编写自定义字符串代码的需求。
- en: 'The main class provided is the `StringBuffer` class, which lets the user allocate
    a maximum fixed amount of memory, and within that memory, perform typical string
    operations: concatenation, formatting, and substrings.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的主要类是`StringBuffer`类，它允许用户分配最大固定数量的内存，并在该内存中执行典型的字符串操作：连接、格式化和子字符串。
- en: A second class provided is the `StringArray` class, which allows the user to
    efficiently store and track different strings inside a contiguous chunk of memory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的第二种类型是`StringArray`类，它允许用户在连续的内存块中高效地存储和跟踪不同的字符串。
- en: This is used, for example, when retrieving a list of files and folders. A final
    utility string class is the `StringView` class, used for read-only access to a
    string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当检索文件和文件夹列表时，这被使用。最后一个实用工具字符串类是`StringView`类，用于只读访问字符串。
- en: Time management
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时间管理
- en: Next is `source/raptor/foundation/time.hpp`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`source/raptor/foundation/time.hpp`)）。
- en: When developing a custom engine, timing is very important, and having some functions
    to help calculate different timings is what the time management functions do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发自定义引擎时，时间管理非常重要，而拥有一些帮助计算不同时间间隔的函数正是时间管理函数的作用。
- en: For example, any application needs to calculate a time difference, used to advance
    time and calculations in various aspects, often known as **delta time**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何应用程序都需要计算时间差，用于推进时间和各种方面的计算，通常被称为**delta time**。
- en: This will be manually calculated in the application layer, but it uses the time
    functions to do it. It can be also used to measure CPU performance, for example,
    to pinpoint slow code or gather statistics when performing some operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用层手动计算，但使用时间函数来完成。它也可以用来测量CPU性能，例如，定位慢速代码或在执行某些操作时收集统计数据。
- en: Timing methods conveniently allow the user to calculate time durations in different
    units, from seconds down to milliseconds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 定时方法方便地允许用户以不同的单位计算时间间隔，从秒到毫秒。
- en: Process execution
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程执行
- en: One last utility area is `source/raptor/foundation/process.hpp`) – defined as
    running any external program from within our own code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个实用工具区域是`source/raptor/foundation/process.hpp`)）——定义为在我们的代码中运行任何外部程序。
- en: In the Raptor Engine, one of the most important usages of external processes
    is the execution of Vulkan’s shader compiler to convert GLSL shaders to SPIR-V
    format, as seen at [https://www.khronos.org/registry/SPIR-V/specs/1.0/SPIRV.xhtml](https://www.khronos.org/registry/SPIR-V/specs/1.0/SPIRV.xhtml).
    The Khronos specification is needed for shaders to be used by Vulkan.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raptor引擎中，外部进程最重要的用途之一是执行Vulkan的着色器编译器，将GLSL着色器转换为SPIR-V格式，如[https://www.khronos.org/registry/SPIR-V/specs/1.0/SPIRV.xhtml](https://www.khronos.org/registry/SPIR-V/specs/1.0/SPIRV.xhtml)所示。Khronos规范是着色器能够被Vulkan使用的必要条件。
- en: We have been through all the different utilities building blocks (many seemingly
    unrelated) that cover the basics of a modern rendering engine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了所有不同的实用工具构建块（许多看似无关），它们涵盖了现代渲染引擎的基础。
- en: These basics are not graphics related by themselves, but they are required to
    build a graphical application that gives the final user full control of what is
    happening and represents a watered-down mindset of what modern game engines do
    behind the scenes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基础本身与图形无关，但它们是构建一个允许最终用户完全控制所发生情况的图形应用程序所必需的，这代表了现代游戏引擎幕后所做工作的简化心态。
- en: Next, we will introduce the graphics layer, where some of the foundational bricks
    can be seen in action and represent the most important part of the code base developed
    for this book.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍图形层，在那里可以看到一些基础组件的实际应用，并代表为本书开发的代码库中最重要的一部分。
- en: Graphics layer
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形层
- en: The most important architectural layer is the graphics layer, which will be
    the main focus of this book. Graphics will include all the Vulkan-related code
    and abstractions needed to draw anything on the screen using the GPU.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的架构层是图形层，这将是本书的主要焦点。图形将包括所有用于在屏幕上使用GPU绘制任何内容的Vulkan相关代码和抽象。
- en: 'There is a caveat in the organization of the source code: having the book divided
    into different chapters and having one GitHub repository, there was the need to
    have a snapshot of the graphics code for each chapter; thus, graphics code will
    be duplicated and evolved in each chapter’s code throughout the game.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的组织中存在一个注意事项：由于本书分为不同的章节并且有一个GitHub仓库，因此需要对每个章节的图形代码进行快照；因此，图形代码将在每个章节的代码中重复并演变，贯穿整个游戏。
- en: We expect the code to grow in this folder as this book progresses after each
    chapter, and not only here, as we will develop shaders and use other data resources
    as well, but it is fundamental to know where we are starting from or where we
    were at a specific time in the book.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的进展，我们预计这个文件夹中的代码将增长，而不仅限于这里，因为我们还将开发着色器并使用其他数据资源，但了解我们从哪里开始或特定时间在书中的位置是基本的。
- en: 'Once again, the API design comes from Hydra as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，API设计来自Hydra如下：
- en: Graphics resources are created using a `creation` struct containing all the
    necessary parameters
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含所有必要参数的`creation`结构创建图形资源
- en: Resources are externally passed as handles, so they are easily copiable and
    safe to pass around
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源作为句柄外部传递，因此它们易于复制并且安全传递
- en: 'The main class in this layer is the `GpuDevice` class, which is responsible
    for the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层的主要类是`GpuDevice`类，它负责以下内容：
- en: Vulkan API abstractions and usage
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan API抽象和用法
- en: Creation, destruction, and update of graphics resources
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形资源的创建、销毁和更新
- en: Swapchain creation, destruction, resize, and update
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、销毁、调整大小和更新交换链
- en: Command buffer requests and submission to the GPU
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令缓冲区请求和提交到GPU
- en: GPU timestamps management
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU时间戳管理
- en: GPU-CPU synchronization
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU-CPU同步
- en: 'We define graphics resources as anything residing on the GPU, such as the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图形资源定义为任何位于GPU上的东西，例如以下内容：
- en: '**Textures**: Images to read and write from'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：用于读取和写入的图像'
- en: '**Buffers**: Arrays of homogeneous or heterogeneous data'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区**：同质或异质数据的数组'
- en: '**Samplers**: Converters from raw GPU memory to anything needed from the shaders'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样器**：从原始GPU内存转换为着色器所需的任何内容'
- en: '**Shaders**: SPIR-V compiled GPU executable code'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器**：SPIR-V编译的GPU可执行代码'
- en: '**Pipeline**: An almost complete snapshot of GPU state'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管线**：GPU状态的几乎完整快照'
- en: The usage of graphics resources is the core of any type of rendering algorithm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资源的使用是任何类型渲染算法的核心。
- en: Therefore, `GpuDevice` (`source/chapter1/graphics/gpu_device.hpp`) is the gateway
    to creating rendering algorithms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`GpuDevice` (`source/chapter1/graphics/gpu_device.hpp`) 是创建渲染算法的入口。
- en: 'Here is a snippet of the `GpuDevice` interface for resources:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`GpuDevice`接口资源的一个片段：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an example of the creation and destruction to create `VertexBuffer`,
    taken from the Raptor `ImGUI` (`source/chapter1/graphics/raptor_imgui.hpp`) backend:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建和销毁`VertexBuffer`的示例，取自Raptor的`ImGUI`（`source/chapter1/graphics/raptor_imgui.hpp`）后端：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the Raptor Engine, graphics resources (`source/chapter1/graphics/gpu_resources.hpp`)
    have the same granularity as Vulkan but are enhanced to help the user write simpler
    and safer code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Raptor Engine中，图形资源（`source/chapter1/graphics/gpu_resources.hpp`）与Vulkan具有相同的粒度，但增强了以帮助用户编写更简单、更安全的代码。
- en: 'Let’s have a look at the `Buffer` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Buffer`类：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the `Buffer` struct contains quite a few extra pieces of information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Buffer`结构包含相当多的额外信息。
- en: First of all, `VkBuffer` is the main Vulkan struct used by the API. Then there
    are some members related to memory allocations on the GPU, such as device memory
    and size.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`VkBuffer`是API中使用的Vulkan主要结构。然后有一些与GPU上内存分配相关的成员，例如设备内存和大小。
- en: Note that there is a utility class used in the Raptor Engine called **Virtual
    Memory Allocator** (**VMA**) ([https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator)),
    which is the de facto standard utility library to write Vulkan code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Raptor Engine中使用的实用类称为**虚拟内存分配器**（**VMA**）（[https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator)），这是编写Vulkan代码的事实上标准实用库。
- en: Here, it is reflected in the `vma_allocation` member variable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它体现在 `vma_allocation` 成员变量中。
- en: Furthermore, there are usage flags – size and offset, as well as global offsets
    – current buffer handle and parent handle (we will see their usage later in the
    book), as well as a human-readable string for easier debugging. This `Buffer`
    can be seen as the blueprint of how other abstractions are created in the Raptor
    Engine, and how they help the user to write simpler and safer code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些使用标志——大小和偏移量，以及全局偏移量——当前缓冲区句柄和父句柄（我们将在本书后面的章节中看到它们的用法），以及一个便于调试的易读字符串。这个
    `Buffer` 可以被视为 Raptor 引擎中其他抽象创建的蓝图，以及它们如何帮助用户编写更简单、更安全的代码。
- en: They still respect Vulkan’s design and philosophy but can hide some implementation
    details that can be less important once the focus of the user is exploring rendering
    algorithms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仍然尊重 Vulkan 的设计和哲学，但可以隐藏一些在用户关注渲染算法时可能不那么重要的实现细节。
- en: We had a brief overview of the graphics layer, the most important part of the
    code in this book. We will evolve its code after each chapter, and we will dwell
    deeper on design choices and implementation details throughout the book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对图形层进行了简要概述，这是本书代码中最重要的一部分。我们将在每一章之后更新其代码，并在整本书中深入探讨设计选择和实现细节。
- en: Next, there is the application layer, which works as the final step between
    the user and the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是应用层，它是用户与应用程序之间的最终步骤。
- en: The application layer
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: The application layer is responsible for handling the actual application side
    of the engine – from window creation and update based on the operating system
    to gathering user input from the mouse and keyboard.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层负责处理引擎的实际应用方面——从基于操作系统的窗口创建和更新到从鼠标和键盘收集用户输入。
- en: In the layer is also included a very handy backend for ImGui ([https://github.com/ocornut/imgui](https://github.com/ocornut/imgui)),
    an amazing library to design the UI to enhance user interaction with the application
    so that it is much easier to control its behavior.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一层还包括一个非常实用的 ImGui 后端（[https://github.com/ocornut/imgui](https://github.com/ocornut/imgui)），这是一个设计
    UI 的惊人库，可以增强用户与应用程序的交互，使其更容易控制其行为。
- en: There is an application class that will be the blueprint for any demo application
    that will be created in the book so that the user can focus more on the graphics
    side of the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个应用类，它将成为本书中创建的任何演示应用程序的蓝图，以便用户可以更多地关注应用程序的图形方面。
- en: The foundation and application layers’ code is in the `source/raptor` folder.
    This code will be almost constant throughout the book, but as we are writing mainly
    a graphics system, this is put in a shared folder between all the chapters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基础层和应用层的代码位于 `source/raptor` 文件夹中。这本书中，这段代码几乎保持不变，但因为我们主要编写的是图形系统，所以它被放在所有章节之间的共享文件夹中。
- en: 'In this section, we have explained the structure of the code and presented
    the three main layers of the Raptor Engine: foundation, graphics, and application.
    For each of these layers, we highlighted some of the main classes, how to use
    them, and the reasoning and inspiration behind the choices we have made.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了代码的结构，并展示了 Raptor 引擎的三个主要层：基础层、图形层和应用层。对于这些层中的每一个，我们都突出了一些主要类，如何使用它们，以及我们做出选择背后的推理和灵感。
- en: In the next section, we are going to present the file format we selected to
    load 3D data from and how we have integrated it into the engine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍我们选择的文件格式，以及我们如何将其集成到引擎中。
- en: Understanding the glTF scene format
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 glTF 场景格式
- en: Many 3D file formats have been developed over the years, and for this book,
    we chose to use glTF. It has become increasingly popular in recent years; it has
    an open specification, and it supports a **physically based rendering** (**PBR**)
    model by default.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年已经开发了许多 3D 文件格式，对于这本书，我们选择使用 glTF。近年来，它变得越来越受欢迎；它有一个开放的规范，并且默认支持基于物理的渲染（**PBR**）模型。
- en: We chose this format because of its open specification and easy-to-understand
    structure. We can use several models provided by Khronos on GitHub to test our
    implementation and compare our results with other frameworks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这个格式是因为它的开放规范和易于理解的结构。我们可以使用 Khronos 在 GitHub 上提供的几个模型来测试我们的实现，并将我们的结果与其他框架进行比较。
- en: It is a JSON-based format and we built a custom parser for this book. The JSON
    data will be deserialized into a C++ class, which we are going to use to drive
    the rendering.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个基于 JSON 的格式，我们为本书构建了一个自定义解析器。JSON 数据将被反序列化为一个 C++ 类，我们将使用它来驱动渲染。
- en: 'We now provide an overview of the main sections of the glTF format. At its
    root, we have a list of scenes, and each scene can have multiple nodes. You can
    see this in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在概述 glTF 格式的主体部分。在其根目录下，我们有一个场景列表，每个场景可以有多个节点。您可以在以下代码中看到这一点：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each node contains an index that is present in the `mesh` array:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都包含一个在 `mesh` 数组中存在的索引：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The data for the scene is stored in one or more buffers, and each section of
    the buffer is described by a buffer view:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的数据存储在一个或多个缓冲区中，每个缓冲区的部分由一个缓冲区视图描述：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each buffer view references the buffer that contains the actual data and its
    size. An accessor points into a buffer view by defining the type, offset, and
    size of the data:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缓冲区视图引用包含实际数据的缓冲区及其大小。访问器通过定义数据类型、偏移量和大小来指向缓冲区视图：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `mesh` array contains a list of entries, and each entry is composed of
    one or more mesh primitives. A mesh primitive contains a list of attributes that
    point into the accessors array, the index of the indices accessor, and the index
    of the material:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`mesh` 数组包含一个条目列表，每个条目由一个或多个网格原语组成。网格原语包含指向访问器数组的属性列表、索引访问器的索引以及材质的索引：'
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `materials` object defines which textures are used (diffuse color, normal
    map, roughness, and so on) and other parameters that control the rendering of
    the material:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`materials` 对象定义了哪些纹理被使用（漫反射颜色、法线贴图、粗糙度等）以及控制材质渲染的其他参数：'
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each texture is specified as a combination of an image and a sampler:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个纹理都指定为一个图像和一个采样器的组合：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The glTF format can specify many other details, including animation data and
    cameras. Most of the models that we are using in this book don’t make use of these
    features, but we will highlight them when that’s the case.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: glTF 格式可以指定许多其他细节，包括动画数据和相机。我们在这本书中使用的模型大多数不使用这些功能，但当我们使用这些功能时，我们将突出显示它们。
- en: 'The JSON data is deserialized into a C++ class, which is then used for rendering.
    We omitted glTF extensions in the resulting object as they are not used in this
    book. We are now going through a code example that shows how to read a glTF file
    using our parser. The first step is to load the file into a `glTF` object:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据被反序列化为一个 C++ 类，然后用于渲染。我们省略了结果对象中的 glTF 扩展，因为它们在本书中未使用。我们现在正在通过一个代码示例来展示如何使用我们的解析器读取
    glTF 文件。第一步是将文件加载到一个 `glTF` 对象中：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have a glTF model loaded into the `scene` variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 glTF 模型加载到 `scene` 变量中。
- en: 'The next step is to upload the buffers, textures, and samplers that are part
    of our model to the GPU for rendering. We start by processing textures and samplers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将模型中作为渲染一部分的缓冲区、纹理和采样器上传到 GPU 进行渲染。我们首先处理纹理和采样器：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each resource is stored in an array. We go through each entry in the array and
    create the corresponding GPU resource. We then store the resources we just created
    in a separate array that will be used in the rendering loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都存储在一个数组中。我们遍历数组中的每个条目并创建相应的 GPU 资源。然后，我们将刚刚创建的资源存储在一个单独的数组中，该数组将在渲染循环中使用。
- en: 'Now let’s see how we process the buffers and buffer views, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何处理缓冲区和缓冲区视图，如下所示：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we read the full buffer data into CPU memory. Then, we iterate through
    each buffer view and create its corresponding GPU resource. We store the newly
    created resource in an array that will be used in the rendering loop.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将完整的缓冲区数据读入 CPU 内存。然后，我们遍历每个缓冲区视图并创建其对应的 GPU 资源。我们将新创建的资源存储在一个数组中，该数组将在渲染循环中使用。
- en: 'Finally, we read the mesh definition to create its corresponding draw data.
    The following code provides a sample for reading the position buffer. Please refer
    to the code in `chapter1/main.cpp` for the full implementation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们读取网格定义以创建其对应的绘制数据。以下代码提供了一个读取位置缓冲区的示例。请参阅 `chapter1/main.cpp` 中的代码以获取完整实现：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have grouped all the GPU resources needed to render a mesh into a `MeshDraw`
    data structure. We retrieve the buffers and textures as defined by the `Accessor`
    object and store them in a `MeshDraw` object to be used in the rendering loop.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染一个网格所需的全部 GPU 资源组合到一个 `MeshDraw` 数据结构中。我们检索由 `Accessor` 对象定义的缓冲区和纹理，并将它们存储在一个
    `MeshDraw` 对象中，以便在渲染循环中使用。
- en: 'In this chapter, we load a model at the beginning of the application, and it’s
    not going to change. Thanks to this constraint, we can create all of our descriptor
    sets only once before we start rendering:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在应用程序开始时加载一个模型，并且它不会改变。得益于这个约束，我们可以在开始渲染之前只创建所有描述符集：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For each resource type, we call the relative method on the `DescriptorSetCreation`
    object. This object stores the data that is going to be used to create the descriptor
    set through the Vulkan API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种资源类型，我们在`DescriptorSetCreation`对象上调用相对方法。此对象存储将要用于通过Vulkan API创建描述符集的数据。
- en: 'We have now defined all the objects we need for rendering. In our render loop,
    we simply have to iterate over all meshes, bind each mesh buffer and descriptor
    set, and call `draw`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们需要的所有渲染对象。在我们的渲染循环中，我们只需遍历所有网格，绑定每个网格缓冲区和描述符集，然后调用`draw`：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are going to evolve this code over the course of the book, but it’s already
    a great starting point for you to try and load a different model or to experiment
    with the shader code (more on this in the next section).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的整个过程中逐步完善此代码，但这对您尝试加载不同的模型或实验着色器代码（下一节将详细介绍）已经是一个很好的起点。
- en: There are several tutorials online about the glTF format, some of which are
    linked in the *Further reading* section. The glTF spec is also a great source
    of details and is easy to follow. We recommend you refer to it if something about
    the format is not immediately clear from reading the book or the code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有关于glTF格式的几个教程，其中一些链接在*进一步阅读*部分。glTF规范也是一个很好的细节来源，并且易于理解。我们建议您在阅读书籍或代码时，如果对格式的某些内容不太清楚，可以参考它。
- en: In this section, we have analyzed the glTF format and we have presented examples
    of the JSON objects most relevant to our renderer. We then demonstrated how to
    use the glTF parser, which we added to our framework, and showed you how to upload
    geometry and texture data to the GPU. Finally, we have shown how to use this data
    to draw the meshes that make up a model.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了glTF格式，并展示了与我们渲染器最相关的JSON对象示例。然后我们演示了如何使用我们添加到框架中的glTF解析器，并展示了如何将几何和纹理数据上传到GPU。最后，我们展示了如何使用这些数据绘制构成模型的网格。
- en: In the next section, we explain how the data we just parsed and uploaded to
    the GPU is used to render our model using a physically-based rendering implementation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释我们刚刚解析并上传到GPU的数据是如何用于使用基于物理的渲染实现来渲染我们的模型的。
- en: PBR in a nutshell
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PBR概述
- en: PBR is at the heart of many rendering engines. It was originally developed for
    offline rendering, but thanks to the advances in hardware capabilities and research
    efforts by the graphics community, it can now be used for real-time rendering
    as well.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: PBR是许多渲染引擎的核心。它最初是为离线渲染开发的，但得益于硬件能力的进步和图形社区的研究努力，现在也可以用于实时渲染。
- en: As the name implies, this technique aims at modeling the physical interactions
    of light and matter and, in some implementations, ensuring that the amount of
    energy in the system is preserved.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这种技术旨在模拟光和物质的物理相互作用，并且在某些实现中，确保系统中的能量量保持不变。
- en: There are plenty of in-depth resources available that describe PBR in great
    detail. Nonetheless, we want to give a brief overview of our implementation for
    reference. We have followed the implementation presented in the glTF spec.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多深入的资源可以详细描述PBR。尽管如此，我们仍想简要概述我们的实现，供参考。我们遵循了glTF规范中提出的实现。
- en: To compute the final color of our surface, we have to determine the diffuse
    and specular components. The amount of specular reflection in the real world is
    determined by the roughness of the surface. The smoother the surface, the greater
    the amount of light that is reflected. A mirror reflects (almost) all the light
    it receives.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算我们表面的最终颜色，我们必须确定漫反射和镜面反射成分。现实世界中镜面反射的量由表面的粗糙度决定。表面越光滑，反射的光量就越大。镜子（几乎）反射它接收到的所有光线。
- en: The roughness of the surface is modeled through a texture. In the glTF format,
    this value is packed with the metalness and the occlusion values in a single texture
    to optimize resource use. We distinguish materials between conductors (or metallic)
    and dielectric (non-metallic) surfaces.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表面粗糙度通过纹理进行建模。在glTF格式中，这个值与金属度和遮挡值打包在单个纹理中，以优化资源使用。我们在导体（或金属）和介电（非金属）表面之间区分材料。
- en: A metallic material has only a specular term, while a non-metallic material
    has both diffuse and specular terms. To model materials that have both metallic
    and non-metallic components, we use the metalness term to interpolate between
    the two.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 金属材料只有镜面项，而非金属材料则同时具有漫反射和镜面项。为了模拟同时具有金属和非金属成分的材料，我们使用金属度项在两者之间进行插值。
- en: An object made of wood will likely have a metalness of 0, plastic will have
    a mix of both metalness and roughness, and the body of a car will be dominated
    by the metallic component.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由木材制成的物体可能具有金属度为0，塑料将具有金属度和粗糙度的混合，而汽车的主体将由金属成分主导。
- en: As we are modeling the real-world response of a material, we need a function
    that takes the view and light direction and returns the amount of light that is
    reflected. This function is called the **bi-directional distribution** **function**
    (**BRDF**).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在模拟材料的真实世界响应，我们需要一个函数，该函数接受视图和光方向，并返回反射的光量。这个函数被称为**双向分布函数**（**BRDF**）。
- en: 'We use the Trowbridge-Reitz/GGX distribution for the specular BRDF, and it
    is implemented as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Trowbridge-Reitz/GGX分布来模拟镜面BRDF，其实现如下：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we compute the distribution and visibility terms according to the formula
    presented in the glTF specification. Then, we multiply them to obtain the specular
    BRDF term.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据glTF规范中提供的公式计算分布和可见性项。然后，我们将它们相乘以获得镜面BRDF项。
- en: There are other approximations that can be used, and we encourage you to experiment
    and replace ours with a different one!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用其他近似方法，我们鼓励你进行实验，用不同的方法替换我们的实现！
- en: 'We then compute the diffuse BDRF, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式计算漫反射BDRF：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now introduce the Fresnel term. This determines the color of the reflection
    based on the viewing angle and the index of refraction of the material. Here is
    the implementation of the Schlick approximation, both for the metallic and dielectric
    components:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍菲涅耳项。它根据观察角度和材料的折射率确定反射的颜色。以下是Schlick近似法的实现，适用于金属和非介电成分：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we compute the Fresnel term for both the conductor and the dielectric components
    according to the formula in the glTF specification.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据glTF规范中的公式计算导体和介电成分的菲涅耳项。
- en: 'Now that we have computed all the components of the model, we interpolate between
    them, based on the metalness of the material, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了模型的全部组件，我们将根据材料的金属度在它们之间进行插值，如下所示：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The occlusion term is not used as it only affects indirect light, which we haven’t
    implemented yet.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡项没有被使用，因为它只影响间接光，而我们还没有实现这一点。
- en: We realize this is a very quick introduction, and we skipped over a lot of the
    theory that makes these approximations work. However, it should provide a good
    starting point for further study.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到这只是一个非常简短的介绍，我们跳过了许多使这些近似方法生效的理论。然而，它应该为更深入的研究提供了一个良好的起点。
- en: We have added links to some excellent resources in the *Further reading* section
    if you’d like to experiment and modify our base implementation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进行实验并修改我们的基本实现，我们在*进一步阅读*部分添加了一些链接。
- en: In the next section, we are going to introduce a debugging tool that we rely
    on whenever we have a non-trivial rendering issue. It has helped us many times
    while writing this book!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个调试工具，每当遇到非平凡的渲染问题时，我们都会依赖它。在撰写本书的过程中，它已经帮了我们很多次！
- en: A word on GPU debugging
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于GPU调试的一些建议
- en: No matter how much experience you have in graphics programming, there will come
    a time when you need to debug an issue. Understanding exactly what the GPU is
    doing when it executes your program is not as immediate as on the CPU. Thankfully,
    GPU debugging tools have come a long way to help us when our program doesn’t behave
    as expected.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在图形编程方面有多少经验，总会有需要调试问题时的时候。当GPU执行你的程序时，理解GPU正在做什么并不像在CPU上那样直接。幸运的是，GPU调试工具已经取得了长足的进步，帮助我们处理程序不符合预期的情况。
- en: 'GPU vendors provide great tools to debug and profile your shaders: Nvidia has
    developed Nsight graphics, and AMD has a suite of tools that includes the Radeon
    GPU analyzer and Radeon GPU profiler.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: GPU供应商提供了出色的工具来调试和性能分析你的着色器：Nvidia开发了Nsight图形工具，AMD则提供了一套包括Radeon GPU分析器和Radeon
    GPU分析器的工具集。
- en: For this book, we have primarily used RenderDoc (available at [https://renderdoc.org/](https://renderdoc.org/)).
    It is a staple tool of the graphics programming community as it allows you to
    capture a frame and record all the Vulkan API calls that have been issued during
    that frame.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们主要使用了RenderDoc（可在[https://renderdoc.org/](https://renderdoc.org/)找到）。它是图形编程社区的标准工具，因为它允许你捕获帧并记录在该帧期间发出的所有Vulkan
    API调用。
- en: 'Using RenderDoc is really simple. You start by providing the path to your application,
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RenderDoc非常简单。你首先提供应用程序的路径，如下所示：
- en: '![Figure 1.2 – Setting the application path in RenderDoc](img/B18395_01_02.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 在RenderDoc中设置应用程序路径](img/B18395_01_02.jpg)'
- en: Figure 1.2 – Setting the application path in RenderDoc
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 在RenderDoc中设置应用程序路径
- en: You then start the application by clicking **Launch**, and you will notice an
    overlay reporting the frame time and the number of frames rendered. If you press
    *F12*, RenderDoc will record the current frame. You can now close your application,
    and the recorded frame will automatically load.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过点击**启动**来启动应用程序，你会注意到一个报告帧时间和渲染帧数的覆盖层。如果你按下*F12*，RenderDoc将记录当前帧。现在你可以关闭你的应用程序，记录的帧将自动加载。
- en: 'On the left, you have the list of API calls grouped in render passes. This
    view also lists the **event ID** (**EID**), which is a progressive number defined
    by RenderDoc. This is useful for comparing events across multiple frames:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你有API调用列表，这些调用按渲染通道分组。此视图还列出了**事件ID**（**EID**），这是RenderDoc定义的递增数字。这对于比较多个帧中的事件很有用：
- en: '![Figure 1.3 – The list of Vulkan API calls for the captured frame](img/B18395_01_03.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 捕获帧的Vulkan API调用列表](img/B18395_01_03.jpg)'
- en: Figure 1.3 – The list of Vulkan API calls for the captured frame
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 捕获帧的Vulkan API调用列表
- en: On the right side of the application window, you have multiple tabs that allow
    you to inspect which textures are bound when a draw call is made, the buffer content,
    and the state of the pipeline.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序窗口的右侧，你有多个标签页，允许你在绘制调用时检查哪些纹理被绑定，缓冲区内容以及管道的状态。
- en: 'The following figure shows the **Texture Viewer** tab. It shows the rendering
    output after a given draw and which input textures were bound:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了**纹理查看器**标签页。它显示了给定绘制后的渲染输出以及哪些输入纹理被绑定：
- en: '![Figure 1.4 – RenderDoc texture viewer](img/B18395_01_04.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – RenderDoc纹理查看器](img/B18395_01_04.jpg)'
- en: Figure 1.4 – RenderDoc texture viewer
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – RenderDoc纹理查看器
- en: If you right-click on a pixel in the **Texture Viewer** tab, you can inspect
    the history of that pixel to understand which draws affected it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键点击**纹理查看器**标签页中的一个像素，你可以检查该像素的历史记录以了解哪些绘制影响了它。
- en: There is also a debug feature that allows you to step through the shader code
    and analyze intermediate values. Be careful when using this feature, as we have
    noticed that the values are not always accurate.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个调试功能，允许你逐步查看着色器代码并分析中间值。使用此功能时要小心，因为我们注意到这些值并不总是准确的。
- en: This was a quick overview of RenderDoc and its functionality. You have learned
    how to capture a frame in RenderDoc when running a graphics application. We presented
    a breakdown of the main panels, their functionality, and how to use them to understand
    how the final image is rendered.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对RenderDoc及其功能性的快速概述。你学习了如何在运行图形应用程序时在RenderDoc中捕获帧。我们展示了主要面板的分解、它们的功能以及如何使用它们来理解最终图像是如何渲染的。
- en: We encourage you to run the code from this chapter under RenderDoc to better
    understand how the frame is built.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在RenderDoc下运行本章的代码，以更好地理解帧是如何构建的。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we laid the foundations for the rest of the book. By now, you
    should be familiar with how the code is structured and how to use it. We introduced
    the Raptor Engine, and we have provided an overview of the main classes and libraries
    that are going to be used throughout the book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为本书的其余部分奠定了基础。到现在为止，你应该熟悉代码的结构和使用方法。我们介绍了Raptor引擎，并提供了本书中将使用的主要类和库的概述。
- en: We have presented the glTF format of the 3D models and how we parse this format
    into objects that will be used for rendering. We gave a brief introduction to
    PBR modeling and our implementation of it. Finally, we introduced RenderDoc and
    how it can be used to debug rendering issues or to understand how a frame is built.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了3D模型的glTF格式以及如何将此格式解析成用于渲染的对象。我们简要介绍了PBR建模及其实现。最后，我们介绍了RenderDoc以及如何使用它来调试渲染问题或了解帧是如何构建的。
- en: In the next chapter, we are going to look at how to improve our resource management!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何改进我们的资源管理！
- en: Further reading
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We have only skimmed the surface of the topics we have presented. Here, we provide
    links to resources you can use to get more information on the concepts exposed
    in this chapter, which will be useful throughout the book.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是对所讨论的主题进行了初步探讨。在此，我们提供了您可以使用的资源链接，以获取本章中展示的概念的更多信息，这些信息将在整本书中都有用。
- en: While we have written our own standard library replacement, there are other
    options if you are starting your own project. We highly recommend looking into
    [https://github.com/electronicarts/EASTL](https://github.com/electronicarts/EASTL),
    developed by EA.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经编写了自己的标准库替代品，但如果您正在启动自己的项目，还有其他选择。我们强烈建议您考虑EA开发的[https://github.com/electronicarts/EASTL](https://github.com/electronicarts/EASTL)。
- en: '**The Vulkan** **specification**: [https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.xhtml](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.xhtml%0D)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vulkan** **规范**：[https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.xhtml](https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/vkspec.xhtml%0D)'
- en: '**The** **glTF format**:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**glTF** **格式**：'
- en: '[https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml)'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml)'
- en: '[https://github.com/KhronosGroup/glTF-Sample-Viewer](https://github.com/KhronosGroup/glTF-Sample-Viewer%0D)'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/KhronosGroup/glTF-Sample-Viewer](https://github.com/KhronosGroup/glTF-Sample-Viewer%0D)'
- en: '**glTF libraries**: We have written our own parser for educational purposes.
    If you are starting your own project, we suggest evaluating these libraries:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**glTF库**：出于教育目的，我们编写了自己的解析器。如果您正在启动自己的项目，我们建议评估以下库：'
- en: '[https://github.com/jkuhlmann/cgltf](https://github.com/jkuhlmann/cgltf)'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/jkuhlmann/cgltf](https://github.com/jkuhlmann/cgltf)'
- en: '[https://github.com/code4game/libgltf](https://github.com/code4game/libgltf)'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/code4game/libgltf](https://github.com/code4game/libgltf)'
- en: '[https://github.com/syoyo/tinygltfloader](https://github.com/syoyo/tinygltfloader)'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/syoyo/tinygltfloader](https://github.com/syoyo/tinygltfloader)'
- en: '**Resources** **on PBR**:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PBR** **资源**：'
- en: '[https://google.github.io/filament/Filament.xhtml](https://google.github.io/filament/Filament.xhtml)'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://google.github.io/filament/Filament.xhtml](https://google.github.io/filament/Filament.xhtml)'
- en: '[https://blog.selfshadow.com/publications/s2012-shading-course/](https://blog.selfshadow.com/publications/s2012-shading-course/)'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.selfshadow.com/publications/s2012-shading-course/](https://blog.selfshadow.com/publications/s2012-shading-course/)'
- en: '[https://pbr-book.org/](https://pbr-book.org/)'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pbr-book.org/](https://pbr-book.org/)'
