<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer070">
<h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor743"/>17</h1>
<h1 id="_idParaDest-274"><a id="_idTextAnchor744"/>Applying the Factory Pattern</h1>
<p><a id="_idTextAnchor745"/>This chapter will continue our pursuit to expand your C++ programming repertoire beyond core OOP concepts, with the goal of enabling you to solve recurring types of coding problems utilizing common design patterns. We know that incorporating design patterns can enhance code maintenance and provide avenues for potential code reuse.</p>
<p>Continuing to demonstrate and explain popular design patterns and idioms and learning how to implement them effectively in C++, we continue our quest with the Factory pattern, more precisely known as the <strong class="bold">Factory Method pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Factory Method pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Factory Method pattern with and without an Object Factory, and comparing an Object Factory to an Abstract Factory</li>
</ul>
<p>By the end of this chapter, you will understand the popular Factory Method pattern. We will see two example implementations of this pattern in C++. Adding additional core design patterns to your programming repertoire will enable you to become a more sophisticated and valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Factory Method pattern.</p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor746"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter17</strong> in a file named <strong class="source-inline">Chp17-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3QOmCC1">https://bit.ly/3QOmCC1</a>.</p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor747"/><a id="_idTextAnchor748"/><a id="_idTextAnchor749"/>Understanding the Factory Method pattern</h1>
<p>The <strong class="bold">Factory pattern</strong>, or <strong class="bold">Factory Method pattern</strong>, is a creational design pattern that allows the creation of <a id="_idIndexMarker1100"/>objects without needing to specify the exact (derived) class that will be instantiated. A Factory Method pattern provides an interface for creating an object, yet allows details within the creation method to decide which (derived) class to instantiate.</p>
<p>A Factory Method pattern is also known as a <strong class="bold">virtual constructor</strong>. Much as a virtual destructor has the <a id="_idIndexMarker1101"/>specific destructor (which is the entry point of the destruction sequence) determined at runtime through dynamic binding, the concept of a virtual constructor is such that the desired object to instantiate is uniformly determined at runtime.</p>
<p>We cannot always anticipate the specific mix of related derived class objects needed in an application. A Factory Method (or virtual constructor) can create, upon request, an instance of one of many related derived class types, based on the input provided. A derived class object will be returned as its base class type by the Factory Method, allowing objects to be both created and stored more generically. Polymorphic operations can be applied to the newly created (upcasted) instances, allowing relevant derived class behaviors to shine through. A Factory Method promotes loose coupling with client code by removing the need to bind specific derived class types in the client code itself. The client merely utilizes the Factory Method to create and provide appropriate instances. </p>
<p>With a Factory Method pattern, we will specify an abstract class (or interface) for collecting and specifying the general behaviors of derived classes we wish to create. The abstract class or interface in this pattern is known as <strong class="bold">Product</strong>. We then create the derived classes that we may <a id="_idIndexMarker1102"/>want to instantiate, overriding any necessary abstract <a id="_idIndexMarker1103"/>methods. The various concrete derived classes are known as <strong class="bold">Concrete Products</strong>. </p>
<p>We then specify a Factory Method whose purpose is to host an interface for uniformly creating instances of Concrete Products. The Factory Method can either be placed in the abstract Product class or in a separate Object Factory class; an <strong class="bold">Object Factory</strong> represents a class with the <a id="_idIndexMarker1104"/>task of creating Concrete Products. This Factory (creation) Method will be static if placed within the abstract Product class and optionally static if instead placed within an Object Factory class. The Factory Method will decide which specific Concrete Product to manufacture, based on a consistent list of <a id="_idIndexMarker1105"/>input parameters. The Factory Method will return a generalized Product pointer to the Concrete Product. Polymorphic methods can be applied to the newly created object to elicit its specific behav<a id="_idTextAnchor750"/>ior. </p>
<p>The Factory Method pattern will include the following:</p>
<ul>
<li>An abstract <strong class="bold">Product</strong> class (or interface).</li>
<li>Multiple <strong class="bold">Concrete Product</strong> derived classes.</li>
<li>A <strong class="bold">Factory Method</strong> in either the abstract Product class or in a separate <strong class="bold">Object Factory</strong> class. The Factory Method will <a id="_idIndexMarker1106"/>have a uniform interface to create an instance of any of the Concrete Product types. </li>
<li>Concrete Products will be returned by the Factory Method as generalized Product instances.</li>
</ul>
<p>Keep in mind that a Factory Method (regardless of whether it is in an Object Factory) produces Products. A Factory Method provides a uniform manner for producing many related Product types. Multiple Factory Methods can exist to produce unique Product lines; each Factory Method can be distinguished by a meaningful name, even if their signatures happen to be the same. </p>
<p>Let’s move forward to see two sample implementations of the Factory Method pattern.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor751"/>Implementing the Factory Method pattern</h1>
<p>We will explore <a id="_idIndexMarker1107"/>two common implementations of the Factory Method pattern. Each will have design trade-offs, certainly worthy of disc<a id="_idTextAnchor752"/>ussion!</p>
<p>Let’s start with the technique in which the Factory Method is placed in the abstract Product<a id="_idTextAnchor753"/><a id="_idTextAnchor754"/><a id="_idTextAnchor755"/> class.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor756"/>Including the Factory Method in the Product class</h2>
<p>To implement <a id="_idIndexMarker1108"/>the Factory Method <a id="_idIndexMarker1109"/>pattern, we will first need to create our abstract Product class as well as our Concrete Product classes. These class definitions will begin the foundation on which to build our pattern.</p>
<p>In our example, we will create our Product using a class we are accustomed to seeing – <strong class="source-inline">Student</strong>. We will then create Concrete Product classes, namely <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong>. We will include a Factory Method in our Product (<strong class="source-inline">Student</strong>) class with a consistent interface to create any of the derived Product types. </p>
<p>The components we will model complement our framework for our existing <strong class="source-inline">Student</strong> application by adding classes to differentiate students based on their educational degree goals. The new components provide the basis for a university matriculation (new <strong class="source-inline">Student</strong> admission) system. </p>
<p>Let us assume that rather than instantiating a <strong class="source-inline">Student</strong>, our application will instantiate various types of <strong class="source-inline">Student</strong> – <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, or <strong class="source-inline">NonDegreeStudent</strong> – based on their learning goals. The <strong class="source-inline">Student</strong> class will include an abstract polymorphic <strong class="source-inline">Graduate()</strong> operation; each derived class will override this method with <a id="_idIndexMarker1110"/>varying implementations. For <a id="_idIndexMarker1111"/>example, a <strong class="source-inline">GradStudent</strong> seeking a Ph.D. may have more degree-related criteria to satisfy in the <strong class="source-inline">GradStudent::Graduate()</strong> method than other specializations of <strong class="source-inline">Student</strong>. They may require credit hours to be verified, a passing grade point average to be verified, and verification that their dissertation has been accepted. In contrast, an <strong class="source-inline">UnderGradStudent</strong> might only have their credit hours and overall grade point average to be corroborated.</p>
<p>The abstract Product class will include a static method, <strong class="source-inline">MatriculateStudent()</strong>, as the Factory Method to create various types of students (the Concrete Product types). </p>
<h3>Defining the abstract Product class</h3>
<p>Let’s first take <a id="_idIndexMarker1112"/>a look at the mechanics for the implementation <a id="_idIndexMarker1113"/>of our Factory Method, beginning by examining the definition for our abstract Product class, <strong class="source-inline">Student</strong>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">class Student</strong>: public Person  // Notice that Student is now
{                             // an abstract class
private:
    float gpa = 0.0;  // in-class initialization
    string currentCourse;
    const string studentId;
    static int numStudents;
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // virtual destructor
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    string IsA() const override { return "Student"; }
    <strong class="bold">virtual void Graduate() = 0;</strong>  // Student is abstract
    // Create a derived Student type based on degree sought
    <strong class="bold">static Student *MatriculateStudent(const string &amp;,</strong>
       <strong class="bold">const string &amp;, const string &amp;, char, </strong>
<strong class="bold">       const string &amp;,</strong> <strong class="bold">float, const string &amp;, </strong>
<strong class="bold">       const string &amp;);</strong>
    static int GetNumStudents() { return numStudents; }
};
// Assume all the usual Student member functions exist </pre>
<p>In the previous class definition, we introduce our abstract <strong class="source-inline">Student</strong> class, which is derived from <strong class="source-inline">Person</strong> (a concrete and hence instantiable class). This has been accomplished with the introduction of the abstract method <strong class="source-inline">virtual void Graduate() = 0;</strong>. In our student matriculation example, we will be following the design decision that <a id="_idIndexMarker1114"/>only specific types of students <a id="_idIndexMarker1115"/>should be instantiated, that is, derived class types <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, or <strong class="source-inline">NonDegreeStudent</strong>. </p>
<p>In the preceding class definition, notice our Factory Method, with the prototype <strong class="source-inline">static Student *MatriculateStudent();</strong>. This method will use a uniform interface and will provide the means for the creation of various derived class types of <strong class="source-inline">Student</strong>. We will examine this method in detail once we have seen the class definitions for the derived classes.  </p>
<h3>Defining the Concrete <a id="_idTextAnchor757"/><a id="_idTextAnchor758"/>Product classes</h3>
<p>Now, let’s take a <a id="_idIndexMarker1116"/>look at our Concrete Product classes, starting <a id="_idTextAnchor759"/><a id="_idIndexMarker1117"/>with <strong class="source-inline">GradStudent</strong>:</p>
<pre class="source-code">
<strong class="bold">class GradStudent</strong>: public Student
{
private:
    string degree;  // PhD, MS, MA, etc.
public:
    GradStudent() = default;// default constructor
    GradStudent(const string &amp;, const string &amp;, 
       const string &amp;, char, const string &amp;, float, 
       const string &amp;, c<a id="_idTextAnchor760"/>onst string &amp;);
    // Prototyping default copy constructor isn't necessary
    // GradStudent(const GradStuden<a id="_idTextAnchor761"/>t &amp;) = default;
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~GradStudent() override = default; // virtual dtor
    void EarnPhD();
    string IsA() const <a id="_idTextAnchor762"/>override { return "GradStudent"; }
    <strong class="bold">void Graduat<a id="_idTextAnchor763"/>e() override;</strong>
};
// Assume alternate constructor is implemented
// as expected. See online code for full implementation.
void GradStudent::EarnPhD()
{
    if (!degree.compare("PhD")) // only PhD candidates can 
        ModifyTitle("Dr.");     // EarnPhd(), not MA and MS 
}                               // candidates
<strong class="bold">void GradStudent::Graduate()</strong>
{   // Here, we can check that the required num of credits
    // have been met with a passing gpa, and that their 
    // doctoral or master's thesis has been completed.
    EarnPhD(); // Will change title only if a PhD candidate
    cout &lt;&lt; "GradStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>In the aforementioned <strong class="source-inline">GradStudent</strong> class definition, we add a <strong class="source-inline">degree</strong> data member to ind<a id="_idTextAnchor764"/>icate a degree of <strong class="source-inline">"PhD"</strong>, <strong class="source-inline">"MS"</strong>, or <strong class="source-inline">"MA"</strong>, and adjust the constructors and destructor, as necessary. We have moved <strong class="source-inline">EarnPhD()</strong> to <strong class="source-inline">GradStudent</strong>, as this method is not applicable to all <strong class="source-inline">Student</strong> instances. Instead, <strong class="source-inline">EarnPhD()</strong> is applicable to a subset of <strong class="source-inline">GradStudent</strong> instances; we will award the title of <strong class="source-inline">"Dr."</strong> only to the Ph.D. candidates. </p>
<p>In this class, we have <a id="_idIndexMarker1118"/>overridden <strong class="source-inline">IsA()</strong> to return <strong class="source-inline">"GradStudent"</strong>. We <a id="_idIndexMarker1119"/>have also overridden <strong class="source-inline">Graduate()</strong> to go through the graduation checklist that is applicable for graduate students, calling <strong class="source-inline">EarnPhD()</strong> if those checklist i<a id="_idTextAnchor765"/>tems have been met.</p>
<p>Now, let’s take a look at our next Concrete Product class, <strong class="source-inline">UnderGradStudent</strong>:</p>
<pre class="source-code">
<strong class="bold">class UnderGradStudent</strong>: public Student
{
private:
    string degree;  // BS, BA, etc
public:
    UnderGradStudent() = default;// default constructor
    UnderGradStudent(const string &amp;, const string &amp;, 
       const string &amp;, char, const string &amp;, float, 
       const string &amp;, const string &amp;);
    // Prototyping default copy constructor isn't necessary
    // UnderGradStudent(const UnderGradStud<a id="_idTextAnchor766"/>ent &amp;) =default; 
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~UnderGradStudent() override = default; // virt dtor
    string IsA() const overri<a id="_idTextAnchor767"/>de 
       { retu<a id="_idTextAnchor768"/>rn "UnderGradStudent"; }
    <strong class="bold">void Graduate() override;</strong>
};
// Assume alternate constructor is implemented
// as expected. See online code for full implementation.
<strong class="bold">void UnderGradStudent::Graduate()</strong>
{   // Verify that num of credits and gpa requirements have
    // been met for major and any minors or concentrations.
    // Have all applicable university fees been paid?
    cout &lt;&lt; "UnderGradStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>Quickly taking a look at the previously defined <strong class="source-inline">UnderGradStudent</strong> class, we notice that it is very similar to <strong class="source-inline">GradStudent</strong>. This class even includes a <strong class="source-inline">degree</strong> data member. Keep in mind that not all <strong class="source-inline">Student</strong> instances will receive degrees, so we don’t want to <a id="_idIndexMarker1120"/>generalize this attribute by defining it in <strong class="source-inline">Student</strong>. Though <a id="_idIndexMarker1121"/>we could have introduced a shared base class of <strong class="source-inline">DegreeSeekingStudent</strong> for <strong class="source-inline">UnderGradStudent</strong> and <strong class="source-inline">GradStudent</strong> to collect this commonality, that fine level of granularization would add an additional layer almost unnecessarily. The duplication here is a design trade-off. </p>
<p>The key difference between these two sibling classes is the overridden <strong class="source-inline">Graduate()</strong> method. We <a id="_idIndexMarker1122"/>can imagine that <a id="_idIndexMarker1123"/>the checklist for an undergraduate student for graduation may be quite different from that of a graduate student. For this reason, we can reasonably differentiate the two classes. Otherwise, they are very much the same.</p>
<p>Now, let’s take a look at our next Concrete Product class, <strong class="source-inline">NonDegreeStudent</strong>:</p>
<pre class="source-code">
<strong class="bold">class NonDegreeStudent</strong>: public Student
{
public:
    NonDegreeStudent() = default;  // default constructor
    NonDegreeStudent(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    // Prototyping default copy constructor isn't necessary
    // NonDegreeStudent(const NonDegreeStudent &amp;s)
    //     =default;
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~NonDegreeStudent() override = default; // virt dtor
    string IsA() const override  
       { return "NonDegreeStudent"; }
    <strong class="bold">void Graduate() override;</strong>
};
// Assume alternate constructor is implemented as expected.
// See online code for full implementation.
void NonDegreeStudent::Graduate()
{   // Check if applicable tuition has been paid. 
    // There is no credit or gpa requirement.
    cout &lt;&lt; "NonDegreeStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>Taking a comparably quick look at the aforementioned <strong class="source-inline">NonDegreeStudent</strong> class, we notice that this Concrete Product is similar to its sibling classes. However, there is no <strong class="source-inline">degree</strong> data <a id="_idIndexMarker1124"/>member within this class. Also, the <a id="_idIndexMarker1125"/>overridden <strong class="source-inline">Graduate()</strong> method has less verification to undertake than in the overridden versions of this method for either the <strong class="source-inline">GradStudent</strong> or <strong class="source-inline">UnderGradStudent</strong> classes.</p>
<h3>Examining the Factory Method definition</h3>
<p>Next, let’s take a look <a id="_idIndexMarker1126"/>at our Factory Method, a static method in our Product (<strong class="source-inline">Student</strong>) class:</p>
<pre class="source-code">
// Creates a Student based on the degree they seek
// This is a static Student method (keyword in prototype)
<strong class="bold">Student *Student::MatriculateStudent(const string &amp;degree, </strong>
    <strong class="bold">const string &amp;fn, const string &amp;ln, char mi, </strong>
    <strong class="bold">const string &amp;t, float avg, const string &amp;course, </strong>
    <strong class="bold">const string &amp;id)</strong>
{
    if (!degree.compare("PhD") || !degree.compare("MS") 
        || !degree.compare("MA"))
        return new <strong class="bold">GradStudent</strong>(degree, fn, ln, mi, t, avg,
                               course, id);
    else if (!degree.compare("BS") || 
             !degree.compare("BA"))
        return new <strong class="bold">UnderGradStudent</strong>(degree, fn, ln, mi, t,
                                    avg, course, id);
    else if (!degree.compare("None"))
        return new <strong class="bold">NonDegreeStudent</strong>(fn, ln, mi, t, avg,
                                    course, id);
}</pre>
<p>The aforementioned static method of <strong class="source-inline">Student</strong>, <strong class="source-inline">MatriculateStudent()</strong>, represents the Factory Method to create various Products (concrete <strong class="source-inline">Student</strong> instances). Here, based on the degree type that the <strong class="source-inline">Student</strong> seeks, one of <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong> will be instantiated. Notice that the signature of <strong class="source-inline">MatriculateStudent()</strong> can handle the parameter <a id="_idIndexMarker1127"/>requirements for any of the derived class constructors. Also notice that any of these specialized instance types will be returned as a base class pointer of the abstract Product type (<strong class="source-inline">Student</strong>). </p>
<p>An interesting option within the Factory Method, <strong class="source-inline">MatriculateStudent()</strong>, is that this method is not obligated to instantiate a new derived class instance. Instead, it may recycle a previous instance that may still be available. For example, imagine a <strong class="source-inline">Student</strong> is temporarily unregistered in the university (due to late payment), yet has been kept available on a list of <em class="italic">pending students</em>. The <strong class="source-inline">MatriculateStudent()</strong> method may instead choose to return a pointer to such an existing <strong class="source-inline">Student</strong>. <em class="italic">Recycling</em> is an alternative within a Factory Method!</p>
<h3>Bringing the pattern components together</h3>
<p>Finally, let’s now <a id="_idIndexMarker1128"/>bring all of our various components together by taking a look at our <strong class="source-inline">main()</strong> function to see how our Factory Method pattern is orchestrated:</p>
<pre class="source-code">
int main()
{
    Student *scholars[MAX] = { }; // init. to nullptrs
    // Student is now abstract; cannot instantiate directly
    // Use Factory Method to make derived types uniformly
    scholars[0] = <strong class="bold">Student::MatriculateStudent("PhD", </strong>
<strong class="bold">       "Sara", "Kato", 'B', "Ms.", 3.9, "C++", "272PSU");</strong>
    scholars[1] = <strong class="bold">Student::MatriculateStudent("BS", </strong>
<strong class="bold">       "Ana", "Sato", 'U', "Ms.", 3.8, "C++", "178PSU");</strong>
    scholars[2] = <strong class="bold">Student::MatriculateStudent("None", </strong>
<strong class="bold">       "Elle", "LeBrun", 'R', "Miss", 3.5, "C++", "111BU");</strong>
    for (auto *oneStudent : scholars)
    {
       oneStudent-&gt;Graduate();
       oneStudent-&gt;Print();
    }
    for (auto *oneStudent : scholars)
       delete oneStudent;   // engage virt dtor sequence
    return 0;
}</pre>
<p>Reviewing our aforementioned <strong class="source-inline">main()</strong> function, we first create an array of pointers for potentially specialized <strong class="source-inline">Student</strong> instances in their generalized <strong class="source-inline">Student</strong> form. Next, we invoke the static Factory Method <strong class="source-inline">Student::MatriculateStudent()</strong>, within the abstract Product class, to create the appropriate Concrete Product (derived <strong class="source-inline">Student</strong> class type). We create one of each of the derived <strong class="source-inline">Student</strong> types – <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong>.</p>
<p>We then loop <a id="_idIndexMarker1129"/>through our generalized collection, calling <strong class="source-inline">Graduate()</strong> and then <strong class="source-inline">Print()</strong> for each instance. For students earning a Ph.D. (<strong class="source-inline">GradStudent</strong> instances), their title will be changed to <strong class="source-inline">"Dr."</strong> by the <strong class="source-inline">GradStudent::Graduate()</strong> method. Finally, we iterate through another loop to deallocate each instance’s memory. Thankfully, <strong class="source-inline">Student</strong> has included a virtual destructor so that the destruction sequenc<a id="_idTextAnchor769"/><a id="_idTextAnchor770"/>e starts at the proper level.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">GradStudent::Graduate()</p>
<p class="source-code">  Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">UnderGradStudent::Graduate()</p>
<p class="source-code">  Ms. Ana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">NonDegreeStudent::Graduate()</p>
<p class="source-code">  Miss Elle R. LeBrun with id: 111BU GPA:  3.5 Course: C++</p>
<p>An advantage of the preceding implementation is that it is very straightforward. However, we <a id="_idIndexMarker1130"/>can see a close coupling exists between the abstract Product, containing the Factory Method (which constructs the derived class types), and the derived Concrete Products. Yet in OOP, a base class will ideally have no knowledge of any descendent types. </p>
<p>A disadvantage to this closely coupled implementation is that the abstract Product class must include a means for instantiation for each of its descendants in its static creation method, <strong class="source-inline">MatriculateStudent()</strong>. Adding new derived classes now affects the abstract base class definition – it needs to be recompiled. What if we don’t have access to the source code for this base class? Is there a way to decouple the dependencies that exist between the Factory Method and the Products that the Factory Method will create? Yes, there is an alternate implementation.</p>
<p>Let us now take a look at an alternate implementation of the Factory Method pattern. We will instead use an Object Factory class to encapsulate our Factory Method of <strong class="source-inline">MatriculateStudent()</strong>, rather than including this method in the abstract Product class.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor771"/>Creating an Object Factory class to encapsulate the Factory Method </h2>
<p>For our alternative <a id="_idIndexMarker1131"/>implementation <a id="_idIndexMarker1132"/>of the Factory Method pattern, we will create our abstract Product class with a slight deviation from its previous definition. We will, however, create our concrete Product classes as before. These class definitions, collectively, will again begin the framework on which to base our pattern.</p>
<p>In our revised example, we will define our Product again as the <strong class="source-inline">Student</strong> class. We will also again derive Concrete Product classes of <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong>. This time, however, we will not include a Factory Method in our Product (<strong class="source-inline">Student</strong>) class. Instead, we will create a separate Object Factory class that will include <a id="_idIndexMarker1133"/>the Factory Method. As before, the Factory Method will have a uniform interface to create any <a id="_idIndexMarker1134"/>of the derived Product types. The Factory Method need not be static, as it was in our last implementation.</p>
<p>Our Object Factory class will include <strong class="source-inline">MatriculateStudent()</strong> as the Factory Method to create various types of <strong class="source-inline">Student</strong> instances (the Concrete Product types). </p>
<h3>Defining the abstract Product class without the Factory Method</h3>
<p>Let’s take a <a id="_idIndexMarker1135"/>look at the <a id="_idIndexMarker1136"/>mechanics for our alternate implementation of the Factory Method pattern, beginning by examining the definition for our abstract Product class, <strong class="source-inline">Student</strong>. This example can be found, as a complete program, in our GitHub repository at the following URL:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-C<span id="_idTextAnchor772"/>PP/blob/main/Chapter17/Chp17-Ex2.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">class Student</strong>: public Person   // Notice Student is 
{                              // an abstract class
private:
    float gpa = 0.0;   // in-class initialization
    string currentCourse;
    const string studentId;
    static int numStudents; // Remember, static data mbrs 
                // are also shared by all derived instances
public:          
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    string IsA() const override { return "Student"; }
    <strong class="bold">virtual void Graduate() = 0;</strong>  // Student is abstract
    static int GetNumStudents() { return numStudents; }
};</pre>
<p>In our aforementioned class definition for <strong class="source-inline">Student</strong>, the key difference from our prior implementation <a id="_idIndexMarker1137"/>is that this <a id="_idIndexMarker1138"/>class no longer contains a static <strong class="source-inline">MatriculateStudent()</strong> method to serve as the Factory Method. <strong class="source-inline">Student</strong> is merely an abstract base class. Remember, all graduate students, undergraduate students, and non-degree students are all specializations of <strong class="source-inline">Student</strong>, therefore <strong class="source-inline">static int numStudents</strong> is a shared, collective count of all types of <strong class="source-inline">Student</strong>.</p>
<h3>Defining the Concrete Product classes</h3>
<p>With that <a id="_idIndexMarker1139"/>in mind, let’s take a look at <a id="_idTextAnchor773"/>the derived (Concrete Product) classes:</p>
<pre class="source-code">
<strong class="bold">class GradStudent</strong>: public Student
{   // Implemented as in our last example
};
<strong class="bold">c<a id="_idTextAnchor774"/>lass UnderGradStudent</strong>: public Student
{   // Implemented as in our last example
};
<strong class="bold">class NonDegreeStudent</strong>: public Student
{   // Implemented as in our last example
};</pre>
<p>In our previously listed class definitions, we can see that our Concrete derived Product classes are identical to our implementation for<a id="_idTextAnchor775"/> these classes as in our first example.</p>
<h3>Adding the Object Factory class with the Factory Method</h3>
<p>Next, let us <a id="_idIndexMarker1140"/>introduce an Object <a id="_idIndexMarker1141"/>Factory class that includes our Factory Method:</p>
<pre class="source-code">
<strong class="bold">class StudentFactory</strong>    // Object Factory class
{
public:   
   // Factory Method creates Student based on degree sought
    <strong class="bold">Student *MatriculateStudent(const string &amp;degree,</strong> 
       <strong class="bold">const string &amp;fn, const string &amp;ln, char mi, </strong>
<strong class="bold">       const string &amp;t,</strong> <strong class="bold">float avg, const string &amp;course, </strong>
<strong class="bold">       const string &amp;id)</strong>
    {
        if (!degree.compare("PhD") || !degree.compare("MS") 
            || !degree.compare("MA"))
            return new GradStudent(degree, fn, ln, mi, t, 
                                   avg, course, id);
        else if (!degree.compare("BS") || 
                 !degree.compare("BA"))
            return new UnderGradStudent(degree, fn, ln, mi,
                                       t, avg, course, id);
        else if (!degree.compare("None"))
            return new NonDegreeStudent(fn, ln, mi, t, avg,
                                        course, id);
    }
};</pre>
<p>In the <a id="_idIndexMarker1142"/>aforementioned Object Factory <a id="_idIndexMarker1143"/>class definition (the <strong class="source-inline">StudentFactory</strong> class), we minimally include the Factory Method specification, namely, <strong class="source-inline">MatriculateStudent()</strong>. The method is very similar to that in our prior example. However, by capturing the creation of Concrete Products in an Object Factory, we have decoupled the relationship between the abstract Product and the Factory Method.</p>
<h3>Bringing the pattern components together</h3>
<p>Next, let’s compare <a id="_idIndexMarker1144"/>our <strong class="source-inline">main()</strong> function to that of our original example to visualize how our revised components implement the Factory Method pattern:</p>
<pre class="source-code">
int main()
{
    Student *scholars[MAX] = { }; // init. to nullptrs
  <a id="_idTextAnchor776"/>  // Create an Object Factory for Students
    <strong class="bold">StudentFactory *UofD = new StudentFactory();</strong>
    // Student is now abstract, cannot instantiate directly
    // Ask the Object Factory to create a Student
    scholars[0] = <strong class="bold">UofD-&gt;MatriculateStudent("PhD", "Sara",</strong> 
               <strong class="bold">"Kato", 'B', "Ms.", 3.9, "C++", "272PSU");</strong>
    scholars[1] = <strong class="bold">UofD-&gt;MatriculateStudent("BS", "Ana", </strong>
<strong class="bold">               "Sato", 'U', "Dr.", 3.8, "C++", "178PSU");</strong>
    scholars[2] = <strong class="bold">UofD-&gt;MatriculateStudent("None", "Elle",</strong>
               <strong class="bold">"LeBrun", 'R', "Miss", 3.5, "C++", "111BU");</strong>
    for (auto *oneStudent : scholars)
    {
       oneStudent-&gt;Graduate();
       oneStudent-&gt;Print();
    }
    for (auto *oneStudent : scholars)
       delete oneStudent;   // engage virt dtor sequence
    delete UofD; // delete factory that created various 
    return 0;    // types of students
}</pre>
<p>Considering our previously listed <strong class="source-inline">main()</strong> function, we see that we have again created an array of <a id="_idIndexMarker1145"/>pointers to the abstract Product type (<strong class="source-inline">Student</strong>). We have then instantiated an Object Factory that can create various <strong class="source-inline">Student</strong> instances of Concrete Product types with <strong class="source-inline">StudentFactory *UofD = new StudentFactory();</strong>. As with the previous example, one instance of each derived type <strong class="source-inline">GradStudent</strong>, <strong class="source-inline">UnderGradStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong> is created by the Object Factory based upon the degree type sought by each student. The remainder of the code in <strong class="source-inline">main()</strong> is as found in our prior example. </p>
<p>Our output will be the same as our last example.</p>
<p>The advantage of the Object Factory class over our prior means of implementation is that we have removed <a id="_idIndexMarker1146"/>the dependency of object creation from our abstract Product class (in the Factory Method) with knowledge of what the derived class types are. That is, should we expand our hierarchy to include new Concrete Product types, we do not have to modify the abstract Product class. Of course, we will need to have access to modify our Object Factory class, <strong class="source-inline">StudentFactory</strong>, to augment our <strong class="source-inline">MatriculateStudent()</strong> Factory Method. </p>
<p>A pattern related to this implementation, an <strong class="bold">Abstract Factory</strong>, is an additional pattern that allows individual <a id="_idIndexMarker1147"/>factories with a similar purpose to be grouped <a id="_idIndexMarker1148"/>together. An Abstract Factory can be specified to provide a means to unify similar Object Factories; it is a factory that will create factories, adding yet another level of abstraction to our original pattern.</p>
<p>We have now seen two implementations of the Factory Method pattern. We have folded the concepts of Product and Factory Method into the framework of cl<a id="_idTextAnchor777"/>asses we are accustomed to seeing, namely <strong class="source-inline">Student</strong>, and descendants of <strong class="source-inline">Student</strong>. Let’s now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor778"/>Summary</h1>
<p>In this chapter, we have continued our pursuit to become better C++ programmers by expanding our knowledge of design patterns. In particular, we have explored the Factory Method pattern, both conceptually and with two common implementations. Our first implementation included placing the Factory Method in our abstract Product class. Our second implementation removed the dependency between our Abstract Product and our Factory Method by instead adding an Object Factory class to contain our Factory Method. We also very briefly discussed the notion of an Abstract Factory.</p>
<p>Utilizing common design patterns, such as the Factory Method pattern, will help you more easily solve recurring types of programming problems in a manner understood by other programmers. By utilizing core design patterns, you will be contributing to well-understood and reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern, in <a href="B19087_18.xhtml#_idTextAnchor783"><em class="italic">Chapter 18</em></a>, <em class="italic">Implementing the Adapter Pattern</em>. Adding more patterns to our collection of skills makes us more versatile and val<a id="_idTextAnchor779"/>ued programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor780"/>Questions</h1>
<ol>
<li>Using the solution from a previous exercise (<em class="italic">Question 1</em>, <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering <a id="_idTextAnchor781"/>Abstract Classes</em>), augment your code as follows:<ol><li>Implement the Factory Method pattern to create various shapes. You will have already created an abstract base class of <strong class="source-inline">Shape</strong> and derived classes such as <strong class="source-inline">Re<a id="_idTextAnchor782"/>ctangle</strong>, <strong class="source-inline">Circle</strong>, <strong class="source-inline">Triangle</strong>, and possibly <strong class="source-inline">Square</strong>. </li><li>Choose whether to implement your Factory Method as a static method in <strong class="source-inline">Shape</strong> or as a method in a <strong class="source-inline">ShapeFactory</strong> class (introducing the latter class if necessary).</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Factory Method pattern?</li>
</ol>
</div>
</div></body></html>