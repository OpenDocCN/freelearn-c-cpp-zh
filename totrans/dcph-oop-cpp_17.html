<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor743"/>17</h1>
<h1 id="_idParaDest-274"><a id="_idTextAnchor744"/>Applying the Factory Pattern</h1>
<p><a id="_idTextAnchor745"/>This chapter will continue our pursuit to expand your C++ programming repertoire beyond core OOP concepts, with the goal of enabling you to solve recurring types of coding problems utilizing common design patterns. We know that incorporating design patterns can enhance code maintenance and provide avenues for potential code reuse.</p>
<p>Continuing to demonstrate and explain popular design patterns and idioms and learning how to implement them effectively in C++, we continue our quest with the Factory pattern, more precisely known as the <strong class="bold">Factory Method pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the Factory Method pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Factory Method pattern with and without an Object Factory, and comparing an Object Factory to an Abstract Factory</li>
</ul>
<p>By the end of this chapter, you will understand the popular Factory Method pattern. We will see two example implementations of this pattern in C++. Adding additional core design patterns to your programming repertoire will enable you to become a more sophisticated and valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the Factory Method pattern.</p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor746"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter17</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter17</code> in a file named <code>Chp17-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3QOmCC1">https://bit.ly/3QOmCC1</a>.</p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor747"/><a id="_idTextAnchor748"/><a id="_idTextAnchor749"/>Understanding the Factory Method pattern</h1>
<p>The <strong class="bold">Factory pattern</strong>, or <strong class="bold">Factory Method pattern</strong>, is a creational design pattern that allows the creation of <a id="_idIndexMarker1100"/>objects without needing to specify the exact (derived) class that will be instantiated. A Factory Method pattern provides an interface for creating an object, yet allows details within the creation method to decide which (derived) class to instantiate.</p>
<p>A Factory Method pattern is also known as a <strong class="bold">virtual constructor</strong>. Much as a virtual destructor has the <a id="_idIndexMarker1101"/>specific destructor (which is the entry point of the destruction sequence) determined at runtime through dynamic binding, the concept of a virtual constructor is such that the desired object to instantiate is uniformly determined at runtime.</p>
<p>We cannot always anticipate the specific mix of related derived class objects needed in an application. A Factory Method (or virtual constructor) can create, upon request, an instance of one of many related derived class types, based on the input provided. A derived class object will be returned as its base class type by the Factory Method, allowing objects to be both created and stored more generically. Polymorphic operations can be applied to the newly created (upcasted) instances, allowing relevant derived class behaviors to shine through. A Factory Method promotes loose coupling with client code by removing the need to bind specific derived class types in the client code itself. The client merely utilizes the Factory Method to create and provide appropriate instances. </p>
<p>With a Factory Method pattern, we will specify an abstract class (or interface) for collecting and specifying the general behaviors of derived classes we wish to create. The abstract class or interface in this pattern is known as <strong class="bold">Product</strong>. We then create the derived classes that we may <a id="_idIndexMarker1102"/>want to instantiate, overriding any necessary abstract <a id="_idIndexMarker1103"/>methods. The various concrete derived classes are known as <strong class="bold">Concrete Products</strong>. </p>
<p>We then specify a Factory Method whose purpose is to host an interface for uniformly creating instances of Concrete Products. The Factory Method can either be placed in the abstract Product class or in a separate Object Factory class; an <strong class="bold">Object Factory</strong> represents a class with the <a id="_idIndexMarker1104"/>task of creating Concrete Products. This Factory (creation) Method will be static if placed within the abstract Product class and optionally static if instead placed within an Object Factory class. The Factory Method will decide which specific Concrete Product to manufacture, based on a consistent list of <a id="_idIndexMarker1105"/>input parameters. The Factory Method will return a generalized Product pointer to the Concrete Product. Polymorphic methods can be applied to the newly created object to elicit its specific behav<a id="_idTextAnchor750"/>ior. </p>
<p>The Factory Method pattern will include the following:</p>
<ul>
<li>An abstract <strong class="bold">Product</strong> class (or interface).</li>
<li>Multiple <strong class="bold">Concrete Product</strong> derived classes.</li>
<li>A <strong class="bold">Factory Method</strong> in either the abstract Product class or in a separate <strong class="bold">Object Factory</strong> class. The Factory Method will <a id="_idIndexMarker1106"/>have a uniform interface to create an instance of any of the Concrete Product types. </li>
<li>Concrete Products will be returned by the Factory Method as generalized Product instances.</li>
</ul>
<p>Keep in mind that a Factory Method (regardless of whether it is in an Object Factory) produces Products. A Factory Method provides a uniform manner for producing many related Product types. Multiple Factory Methods can exist to produce unique Product lines; each Factory Method can be distinguished by a meaningful name, even if their signatures happen to be the same. </p>
<p>Let’s move forward to see two sample implementations of the Factory Method pattern.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor751"/>Implementing the Factory Method pattern</h1>
<p>We will explore <a id="_idIndexMarker1107"/>two common implementations of the Factory Method pattern. Each will have design trade-offs, certainly worthy of disc<a id="_idTextAnchor752"/>ussion!</p>
<p>Let’s start with the technique in which the Factory Method is placed in the abstract Product<a id="_idTextAnchor753"/><a id="_idTextAnchor754"/><a id="_idTextAnchor755"/> class.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor756"/>Including the Factory Method in the Product class</h2>
<p>To implement <a id="_idIndexMarker1108"/>the Factory Method <a id="_idIndexMarker1109"/>pattern, we will first need to create our abstract Product class as well as our Concrete Product classes. These class definitions will begin the foundation on which to build our pattern.</p>
<p>In our example, we will create our Product using a class we are accustomed to seeing – <code>Student</code>. We will then create Concrete Product classes, namely <code>GradStudent</code>, <code>UnderGradStudent</code>, and <code>NonDegreeStudent</code>. We will include a Factory Method in our Product (<code>Student</code>) class with a consistent interface to create any of the derived Product types. </p>
<p>The components we will model complement our framework for our existing <code>Student</code> application by adding classes to differentiate students based on their educational degree goals. The new components provide the basis for a university matriculation (new <code>Student</code> admission) system. </p>
<p>Let us assume that rather than instantiating a <code>Student</code>, our application will instantiate various types of <code>Student</code> – <code>GradStudent</code>, <code>UnderGradStudent</code>, or <code>NonDegreeStudent</code> – based on their learning goals. The <code>Student</code> class will include an abstract polymorphic <code>Graduate()</code> operation; each derived class will override this method with <a id="_idIndexMarker1110"/>varying implementations. For <a id="_idIndexMarker1111"/>example, a <code>GradStudent</code> seeking a Ph.D. may have more degree-related criteria to satisfy in the <code>GradStudent::Graduate()</code> method than other specializations of <code>Student</code>. They may require credit hours to be verified, a passing grade point average to be verified, and verification that their dissertation has been accepted. In contrast, an <code>UnderGradStudent</code> might only have their credit hours and overall grade point average to be corroborated.</p>
<p>The abstract Product class will include a static method, <code>MatriculateStudent()</code>, as the Factory Method to create various types of students (the Concrete Product types). </p>
<h3>Defining the abstract Product class</h3>
<p>Let’s first take <a id="_idIndexMarker1112"/>a look at the mechanics for the implementation <a id="_idIndexMarker1113"/>of our Factory Method, beginning by examining the definition for our abstract Product class, <code>Student</code>. This example can be found, as a complete program, in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex1.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">class Student</strong>: public Person  // Notice that Student is now
{                             // an abstract class
private:
    float gpa = 0.0;  // in-class initialization
    string currentCourse;
    const string studentId;
    static int numStudents;
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // virtual destructor
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    string IsA() const override { return "Student"; }
    <strong class="bold">virtual void Graduate() = 0;</strong>  // Student is abstract
    // Create a derived Student type based on degree sought
    <strong class="bold">static Student *MatriculateStudent(const string &amp;,</strong>
       <strong class="bold">const string &amp;, const string &amp;, char, </strong>
<strong class="bold">       const string &amp;,</strong> <strong class="bold">float, const string &amp;, </strong>
<strong class="bold">       const string &amp;);</strong>
    static int GetNumStudents() { return numStudents; }
};
// Assume all the usual Student member functions exist </pre>
<p>In the previous class definition, we introduce our abstract <code>Student</code> class, which is derived from <code>Person</code> (a concrete and hence instantiable class). This has been accomplished with the introduction of the abstract method <code>virtual void Graduate() = 0;</code>. In our student matriculation example, we will be following the design decision that <a id="_idIndexMarker1114"/>only specific types of students <a id="_idIndexMarker1115"/>should be instantiated, that is, derived class types <code>GradStudent</code>, <code>UnderGradStudent</code>, or <code>NonDegreeStudent</code>. </p>
<p>In the preceding class definition, notice our Factory Method, with the prototype <code>static Student *MatriculateStudent();</code>. This method will use a uniform interface and will provide the means for the creation of various derived class types of <code>Student</code>. We will examine this method in detail once we have seen the class definitions for the derived classes.  </p>
<h3>Defining the Concrete <a id="_idTextAnchor757"/><a id="_idTextAnchor758"/>Product classes</h3>
<p>Now, let’s take a <a id="_idIndexMarker1116"/>look at our Concrete Product classes, starting <a id="_idTextAnchor759"/><a id="_idIndexMarker1117"/>with <code>GradStudent</code>:</p>
<pre class="source-code">
<strong class="bold">class GradStudent</strong>: public Student
{
private:
    string degree;  // PhD, MS, MA, etc.
public:
    GradStudent() = default;// default constructor
    GradStudent(const string &amp;, const string &amp;, 
       const string &amp;, char, const string &amp;, float, 
       const string &amp;, c<a id="_idTextAnchor760"/>onst string &amp;);
    // Prototyping default copy constructor isn't necessary
    // GradStudent(const GradStuden<a id="_idTextAnchor761"/>t &amp;) = default;
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~GradStudent() override = default; // virtual dtor
    void EarnPhD();
    string IsA() const <a id="_idTextAnchor762"/>override { return "GradStudent"; }
    <strong class="bold">void Graduat<a id="_idTextAnchor763"/>e() override;</strong>
};
// Assume alternate constructor is implemented
// as expected. See online code for full implementation.
void GradStudent::EarnPhD()
{
    if (!degree.compare("PhD")) // only PhD candidates can 
        ModifyTitle("Dr.");     // EarnPhd(), not MA and MS 
}                               // candidates
<strong class="bold">void GradStudent::Graduate()</strong>
{   // Here, we can check that the required num of credits
    // have been met with a passing gpa, and that their 
    // doctoral or master's thesis has been completed.
    EarnPhD(); // Will change title only if a PhD candidate
    cout &lt;&lt; "GradStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>In the aforementioned <code>GradStudent</code> class definition, we add a <code>degree</code> data member to ind<a id="_idTextAnchor764"/>icate a degree of <code>"PhD"</code>, <code>"MS"</code>, or <code>"MA"</code>, and adjust the constructors and destructor, as necessary. We have moved <code>EarnPhD()</code> to <code>GradStudent</code>, as this method is not applicable to all <code>Student</code> instances. Instead, <code>EarnPhD()</code> is applicable to a subset of <code>GradStudent</code> instances; we will award the title of <code>"Dr."</code> only to the Ph.D. candidates. </p>
<p>In this class, we have <a id="_idIndexMarker1118"/>overridden <code>IsA()</code> to return <code>"GradStudent"</code>. We <a id="_idIndexMarker1119"/>have also overridden <code>Graduate()</code> to go through the graduation checklist that is applicable for graduate students, calling <code>EarnPhD()</code> if those checklist i<a id="_idTextAnchor765"/>tems have been met.</p>
<p>Now, let’s take a look at our next Concrete Product class, <code>UnderGradStudent</code>:</p>
<pre class="source-code">
<strong class="bold">class UnderGradStudent</strong>: public Student
{
private:
    string degree;  // BS, BA, etc
public:
    UnderGradStudent() = default;// default constructor
    UnderGradStudent(const string &amp;, const string &amp;, 
       const string &amp;, char, const string &amp;, float, 
       const string &amp;, const string &amp;);
    // Prototyping default copy constructor isn't necessary
    // UnderGradStudent(const UnderGradStud<a id="_idTextAnchor766"/>ent &amp;) =default; 
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~UnderGradStudent() override = default; // virt dtor
    string IsA() const overri<a id="_idTextAnchor767"/>de 
       { retu<a id="_idTextAnchor768"/>rn "UnderGradStudent"; }
    <strong class="bold">void Graduate() override;</strong>
};
// Assume alternate constructor is implemented
// as expected. See online code for full implementation.
<strong class="bold">void UnderGradStudent::Graduate()</strong>
{   // Verify that num of credits and gpa requirements have
    // been met for major and any minors or concentrations.
    // Have all applicable university fees been paid?
    cout &lt;&lt; "UnderGradStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>Quickly taking a look at the previously defined <code>UnderGradStudent</code> class, we notice that it is very similar to <code>GradStudent</code>. This class even includes a <code>degree</code> data member. Keep in mind that not all <code>Student</code> instances will receive degrees, so we don’t want to <a id="_idIndexMarker1120"/>generalize this attribute by defining it in <code>Student</code>. Though <a id="_idIndexMarker1121"/>we could have introduced a shared base class of <code>DegreeSeekingStudent</code> for <code>UnderGradStudent</code> and <code>GradStudent</code> to collect this commonality, that fine level of granularization would add an additional layer almost unnecessarily. The duplication here is a design trade-off. </p>
<p>The key difference between these two sibling classes is the overridden <code>Graduate()</code> method. We <a id="_idIndexMarker1122"/>can imagine that <a id="_idIndexMarker1123"/>the checklist for an undergraduate student for graduation may be quite different from that of a graduate student. For this reason, we can reasonably differentiate the two classes. Otherwise, they are very much the same.</p>
<p>Now, let’s take a look at our next Concrete Product class, <code>NonDegreeStudent</code>:</p>
<pre class="source-code">
<strong class="bold">class NonDegreeStudent</strong>: public Student
{
public:
    NonDegreeStudent() = default;  // default constructor
    NonDegreeStudent(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    // Prototyping default copy constructor isn't necessary
    // NonDegreeStudent(const NonDegreeStudent &amp;s)
    //     =default;
    // Since the most base class has virt dtor prototyped,
    // it is not necessary to prototype default destructor
    // ~NonDegreeStudent() override = default; // virt dtor
    string IsA() const override  
       { return "NonDegreeStudent"; }
    <strong class="bold">void Graduate() override;</strong>
};
// Assume alternate constructor is implemented as expected.
// See online code for full implementation.
void NonDegreeStudent::Graduate()
{   // Check if applicable tuition has been paid. 
    // There is no credit or gpa requirement.
    cout &lt;&lt; "NonDegreeStudent::Graduate()" &lt;&lt; endl;
}</pre>
<p>Taking a comparably quick look at the aforementioned <code>NonDegreeStudent</code> class, we notice that this Concrete Product is similar to its sibling classes. However, there is no <code>degree</code> data <a id="_idIndexMarker1124"/>member within this class. Also, the <a id="_idIndexMarker1125"/>overridden <code>Graduate()</code> method has less verification to undertake than in the overridden versions of this method for either the <code>GradStudent</code> or <code>UnderGradStudent</code> classes.</p>
<h3>Examining the Factory Method definition</h3>
<p>Next, let’s take a look <a id="_idIndexMarker1126"/>at our Factory Method, a static method in our Product (<code>Student</code>) class:</p>
<pre class="source-code">
// Creates a Student based on the degree they seek
// This is a static Student method (keyword in prototype)
<strong class="bold">Student *Student::MatriculateStudent(const string &amp;degree, </strong>
    <strong class="bold">const string &amp;fn, const string &amp;ln, char mi, </strong>
    <strong class="bold">const string &amp;t, float avg, const string &amp;course, </strong>
    <strong class="bold">const string &amp;id)</strong>
{
    if (!degree.compare("PhD") || !degree.compare("MS") 
        || !degree.compare("MA"))
        return new <strong class="bold">GradStudent</strong>(degree, fn, ln, mi, t, avg,
                               course, id);
    else if (!degree.compare("BS") || 
             !degree.compare("BA"))
        return new <strong class="bold">UnderGradStudent</strong>(degree, fn, ln, mi, t,
                                    avg, course, id);
    else if (!degree.compare("None"))
        return new <strong class="bold">NonDegreeStudent</strong>(fn, ln, mi, t, avg,
                                    course, id);
}</pre>
<p>The aforementioned static method of <code>Student</code>, <code>MatriculateStudent()</code>, represents the Factory Method to create various Products (concrete <code>Student</code> instances). Here, based on the degree type that the <code>Student</code> seeks, one of <code>GradStudent</code>, <code>UnderGradStudent</code>, and <code>NonDegreeStudent</code> will be instantiated. Notice that the signature of <code>MatriculateStudent()</code> can handle the parameter <a id="_idIndexMarker1127"/>requirements for any of the derived class constructors. Also notice that any of these specialized instance types will be returned as a base class pointer of the abstract Product type (<code>Student</code>). </p>
<p>An interesting option within the Factory Method, <code>MatriculateStudent()</code>, is that this method is not obligated to instantiate a new derived class instance. Instead, it may recycle a previous instance that may still be available. For example, imagine a <code>Student</code> is temporarily unregistered in the university (due to late payment), yet has been kept available on a list of <em class="italic">pending students</em>. The <code>MatriculateStudent()</code> method may instead choose to return a pointer to such an existing <code>Student</code>. <em class="italic">Recycling</em> is an alternative within a Factory Method!</p>
<h3>Bringing the pattern components together</h3>
<p>Finally, let’s now <a id="_idIndexMarker1128"/>bring all of our various components together by taking a look at our <code>main()</code> function to see how our Factory Method pattern is orchestrated:</p>
<pre class="source-code">
int main()
{
    Student *scholars[MAX] = { }; // init. to nullptrs
    // Student is now abstract; cannot instantiate directly
    // Use Factory Method to make derived types uniformly
    scholars[0] = <strong class="bold">Student::MatriculateStudent("PhD", </strong>
<strong class="bold">       "Sara", "Kato", 'B', "Ms.", 3.9, "C++", "272PSU");</strong>
    scholars[1] = <strong class="bold">Student::MatriculateStudent("BS", </strong>
<strong class="bold">       "Ana", "Sato", 'U', "Ms.", 3.8, "C++", "178PSU");</strong>
    scholars[2] = <strong class="bold">Student::MatriculateStudent("None", </strong>
<strong class="bold">       "Elle", "LeBrun", 'R', "Miss", 3.5, "C++", "111BU");</strong>
    for (auto *oneStudent : scholars)
    {
       oneStudent-&gt;Graduate();
       oneStudent-&gt;Print();
    }
    for (auto *oneStudent : scholars)
       delete oneStudent;   // engage virt dtor sequence
    return 0;
}</pre>
<p>Reviewing our aforementioned <code>main()</code> function, we first create an array of pointers for potentially specialized <code>Student</code> instances in their generalized <code>Student</code> form. Next, we invoke the static Factory Method <code>Student::MatriculateStudent()</code>, within the abstract Product class, to create the appropriate Concrete Product (derived <code>Student</code> class type). We create one of each of the derived <code>Student</code> types – <code>GradStudent</code>, <code>UnderGradStudent</code>, and <code>NonDegreeStudent</code>.</p>
<p>We then loop <a id="_idIndexMarker1129"/>through our generalized collection, calling <code>Graduate()</code> and then <code>Print()</code> for each instance. For students earning a Ph.D. (<code>GradStudent</code> instances), their title will be changed to <code>"Dr."</code> by the <code>GradStudent::Graduate()</code> method. Finally, we iterate through another loop to deallocate each instance’s memory. Thankfully, <code>Student</code> has included a virtual destructor so that the destruction sequenc<a id="_idTextAnchor769"/><a id="_idTextAnchor770"/>e starts at the proper level.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>GradStudent::Graduate()
  Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++
UnderGradStudent::Graduate()
  Ms. Ana U. Sato with id: 178PSU GPA:  3.8 Course: C++
NonDegreeStudent::Graduate()
  Miss Elle R. LeBrun with id: 111BU GPA:  3.5 Course: C++</pre>
<p>An advantage of the preceding implementation is that it is very straightforward. However, we <a id="_idIndexMarker1130"/>can see a close coupling exists between the abstract Product, containing the Factory Method (which constructs the derived class types), and the derived Concrete Products. Yet in OOP, a base class will ideally have no knowledge of any descendent types. </p>
<p>A disadvantage to this closely coupled implementation is that the abstract Product class must include a means for instantiation for each of its descendants in its static creation method, <code>MatriculateStudent()</code>. Adding new derived classes now affects the abstract base class definition – it needs to be recompiled. What if we don’t have access to the source code for this base class? Is there a way to decouple the dependencies that exist between the Factory Method and the Products that the Factory Method will create? Yes, there is an alternate implementation.</p>
<p>Let us now take a look at an alternate implementation of the Factory Method pattern. We will instead use an Object Factory class to encapsulate our Factory Method of <code>MatriculateStudent()</code>, rather than including this method in the abstract Product class.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor771"/>Creating an Object Factory class to encapsulate the Factory Method </h2>
<p>For our alternative <a id="_idIndexMarker1131"/>implementation <a id="_idIndexMarker1132"/>of the Factory Method pattern, we will create our abstract Product class with a slight deviation from its previous definition. We will, however, create our concrete Product classes as before. These class definitions, collectively, will again begin the framework on which to base our pattern.</p>
<p>In our revised example, we will define our Product again as the <code>Student</code> class. We will also again derive Concrete Product classes of <code>GradStudent</code>, <code>UnderGradStudent</code>, and <code>NonDegreeStudent</code>. This time, however, we will not include a Factory Method in our Product (<code>Student</code>) class. Instead, we will create a separate Object Factory class that will include <a id="_idIndexMarker1133"/>the Factory Method. As before, the Factory Method will have a uniform interface to create any <a id="_idIndexMarker1134"/>of the derived Product types. The Factory Method need not be static, as it was in our last implementation.</p>
<p>Our Object Factory class will include <code>MatriculateStudent()</code> as the Factory Method to create various types of <code>Student</code> instances (the Concrete Product types). </p>
<h3>Defining the abstract Product class without the Factory Method</h3>
<p>Let’s take a <a id="_idIndexMarker1135"/>look at the <a id="_idIndexMarker1136"/>mechanics for our alternate implementation of the Factory Method pattern, beginning by examining the definition for our abstract Product class, <code>Student</code>. This example can be found, as a complete program, in our GitHub repository at the following URL:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter17/Chp17-Ex2.cpp</a></p>
<pre class="source-code">
// Assume Person class exists with its usual implementation
<strong class="bold">class Student</strong>: public Person   // Notice Student is 
{                              // an abstract class
private:
    float gpa = 0.0;   // in-class initialization
    string currentCourse;
    const string studentId;
    static int numStudents; // Remember, static data mbrs 
                // are also shared by all derived instances
public:          
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
       const string &amp;, float, const string &amp;, 
       const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    string IsA() const override { return "Student"; }
    <strong class="bold">virtual void Graduate() = 0;</strong>  // Student is abstract
    static int GetNumStudents() { return numStudents; }
};</pre>
<p>In our aforementioned class definition for <code>Student</code>, the key difference from our prior implementation <a id="_idIndexMarker1137"/>is that this <a id="_idIndexMarker1138"/>class no longer contains a static <code>MatriculateStudent()</code> method to serve as the Factory Method. <code>Student</code> is merely an abstract base class. Remember, all graduate students, undergraduate students, and non-degree students are all specializations of <code>Student</code>, therefore <code>static int numStudents</code> is a shared, collective count of all types of <code>Student</code>.</p>
<h3>Defining the Concrete Product classes</h3>
<p>With that <a id="_idIndexMarker1139"/>in mind, let’s take a look at <a id="_idTextAnchor773"/>the derived (Concrete Product) classes:</p>
<pre class="source-code">
<strong class="bold">class GradStudent</strong>: public Student
{   // Implemented as in our last example
};
<strong class="bold">c<a id="_idTextAnchor774"/>lass UnderGradStudent</strong>: public Student
{   // Implemented as in our last example
};
<strong class="bold">class NonDegreeStudent</strong>: public Student
{   // Implemented as in our last example
};</pre>
<p>In our previously listed class definitions, we can see that our Concrete derived Product classes are identical to our implementation for<a id="_idTextAnchor775"/> these classes as in our first example.</p>
<h3>Adding the Object Factory class with the Factory Method</h3>
<p>Next, let us <a id="_idIndexMarker1140"/>introduce an Object <a id="_idIndexMarker1141"/>Factory class that includes our Factory Method:</p>
<pre class="source-code">
<strong class="bold">class StudentFactory</strong>    // Object Factory class
{
public:   
   // Factory Method creates Student based on degree sought
    <strong class="bold">Student *MatriculateStudent(const string &amp;degree,</strong> 
       <strong class="bold">const string &amp;fn, const string &amp;ln, char mi, </strong>
<strong class="bold">       const string &amp;t,</strong> <strong class="bold">float avg, const string &amp;course, </strong>
<strong class="bold">       const string &amp;id)</strong>
    {
        if (!degree.compare("PhD") || !degree.compare("MS") 
            || !degree.compare("MA"))
            return new GradStudent(degree, fn, ln, mi, t, 
                                   avg, course, id);
        else if (!degree.compare("BS") || 
                 !degree.compare("BA"))
            return new UnderGradStudent(degree, fn, ln, mi,
                                       t, avg, course, id);
        else if (!degree.compare("None"))
            return new NonDegreeStudent(fn, ln, mi, t, avg,
                                        course, id);
    }
};</pre>
<p>In the <a id="_idIndexMarker1142"/>aforementioned Object Factory <a id="_idIndexMarker1143"/>class definition (the <code>StudentFactory</code> class), we minimally include the Factory Method specification, namely, <code>MatriculateStudent()</code>. The method is very similar to that in our prior example. However, by capturing the creation of Concrete Products in an Object Factory, we have decoupled the relationship between the abstract Product and the Factory Method.</p>
<h3>Bringing the pattern components together</h3>
<p>Next, let’s compare <a id="_idIndexMarker1144"/>our <code>main()</code> function to that of our original example to visualize how our revised components implement the Factory Method pattern:</p>
<pre class="source-code">
int main()
{
    Student *scholars[MAX] = { }; // init. to nullptrs
  <a id="_idTextAnchor776"/>  // Create an Object Factory for Students
    <strong class="bold">StudentFactory *UofD = new StudentFactory();</strong>
    // Student is now abstract, cannot instantiate directly
    // Ask the Object Factory to create a Student
    scholars[0] = <strong class="bold">UofD-&gt;MatriculateStudent("PhD", "Sara",</strong> 
               <strong class="bold">"Kato", 'B', "Ms.", 3.9, "C++", "272PSU");</strong>
    scholars[1] = <strong class="bold">UofD-&gt;MatriculateStudent("BS", "Ana", </strong>
<strong class="bold">               "Sato", 'U', "Dr.", 3.8, "C++", "178PSU");</strong>
    scholars[2] = <strong class="bold">UofD-&gt;MatriculateStudent("None", "Elle",</strong>
               <strong class="bold">"LeBrun", 'R', "Miss", 3.5, "C++", "111BU");</strong>
    for (auto *oneStudent : scholars)
    {
       oneStudent-&gt;Graduate();
       oneStudent-&gt;Print();
    }
    for (auto *oneStudent : scholars)
       delete oneStudent;   // engage virt dtor sequence
    delete UofD; // delete factory that created various 
    return 0;    // types of students
}</pre>
<p>Considering our previously listed <code>main()</code> function, we see that we have again created an array of <a id="_idIndexMarker1145"/>pointers to the abstract Product type (<code>Student</code>). We have then instantiated an Object Factory that can create various <code>Student</code> instances of Concrete Product types with <code>StudentFactory *UofD = new StudentFactory();</code>. As with the previous example, one instance of each derived type <code>GradStudent</code>, <code>UnderGradStudent</code>, and <code>NonDegreeStudent</code> is created by the Object Factory based upon the degree type sought by each student. The remainder of the code in <code>main()</code> is as found in our prior example. </p>
<p>Our output will be the same as our last example.</p>
<p>The advantage of the Object Factory class over our prior means of implementation is that we have removed <a id="_idIndexMarker1146"/>the dependency of object creation from our abstract Product class (in the Factory Method) with knowledge of what the derived class types are. That is, should we expand our hierarchy to include new Concrete Product types, we do not have to modify the abstract Product class. Of course, we will need to have access to modify our Object Factory class, <code>StudentFactory</code>, to augment our <code>MatriculateStudent()</code> Factory Method. </p>
<p>A pattern related to this implementation, an <strong class="bold">Abstract Factory</strong>, is an additional pattern that allows individual <a id="_idIndexMarker1147"/>factories with a similar purpose to be grouped <a id="_idIndexMarker1148"/>together. An Abstract Factory can be specified to provide a means to unify similar Object Factories; it is a factory that will create factories, adding yet another level of abstraction to our original pattern.</p>
<p>We have now seen two implementations of the Factory Method pattern. We have folded the concepts of Product and Factory Method into the framework of cl<a id="_idTextAnchor777"/>asses we are accustomed to seeing, namely <code>Student</code>, and descendants of <code>Student</code>. Let’s now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor778"/>Summary</h1>
<p>In this chapter, we have continued our pursuit to become better C++ programmers by expanding our knowledge of design patterns. In particular, we have explored the Factory Method pattern, both conceptually and with two common implementations. Our first implementation included placing the Factory Method in our abstract Product class. Our second implementation removed the dependency between our Abstract Product and our Factory Method by instead adding an Object Factory class to contain our Factory Method. We also very briefly discussed the notion of an Abstract Factory.</p>
<p>Utilizing common design patterns, such as the Factory Method pattern, will help you more easily solve recurring types of programming problems in a manner understood by other programmers. By utilizing core design patterns, you will be contributing to well-understood and reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern, in <a href="B19087_18.xhtml#_idTextAnchor783"><em class="italic">Chapter 18</em></a>, <em class="italic">Implementing the Adapter Pattern</em>. Adding more patterns to our collection of skills makes us more versatile and val<a id="_idTextAnchor779"/>ued programmers. Let’s continue onward!</p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor780"/>Questions</h1>
<ol>
<li>Using the solution from a previous exercise (<em class="italic">Question 1</em>, <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering <a id="_idTextAnchor781"/>Abstract Classes</em>), augment your code as follows:<ol><li>Implement the Factory Method pattern to create various shapes. You will have already created an abstract base class of <code>Shape</code> and derived classes such as <code>Re<a id="_idTextAnchor782"/>ctangle</code>, <code>Circle</code>, <code>Triangle</code>, and possibly <code>Square</code>. </li><li>Choose whether to implement your Factory Method as a static method in <code>Shape</code> or as a method in a <code>ShapeFactory</code> class (introducing the latter class if necessary).</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Factory Method pattern?</li>
</ol>
</div>
</div></body></html>