<html><head></head><body>
<div><div><div><h1 id="_idParaDest-32" class="chapter-number"><a id="_idTextAnchor039"/>2</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor040"/>Constructing Peripheral Registers from Memory Addresses</h1>
			<p><strong class="bold">Bare-metal programming</strong> is all about<a id="_idIndexMarker064"/><a id="_idIndexMarker065"/> working directly with the registers in the microcontroller without going through a library, allowing us to gain a deeper understanding of the microcontroller’s capabilities and limitations. This approach enables us to optimize our firmware for speed and efficiency, which are two very important parameters in embedded systems where resources are often limited.</p>
			<p>In this chapter, our journey begins with an exploration of various firmware development methodologies, highlighting the different levels of abstraction each offers. We then proceed to learn how to identify the ports and pins associated with key components on our development board. This step is crucial for establishing a proper interface with the microcontroller’s peripherals.</p>
			<p>Next, we delve into defining the addresses of some peripherals using the microcontroller’s official documentation. This will allow us to create the addresses of the various registers in those peripherals.</p>
			<p>In the latter sections of the chapter, our focus shifts to practical application. We will use the register addresses that we’ve created to configure PA5 to activate <a id="_idIndexMarker066"/><a id="_idIndexMarker067"/>the user <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>) of the development board.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor041"/>The different types of firmware development</li>
				<li><a id="_idTextAnchor042"/>Locating and understanding the development board’s components</li>
				<li>Defining and creating registers through documentation insights</li>
				<li><a id="_idTextAnchor043"/>Register manipulation – from configuration to running your first firmware</li>
			</ul>
			<p>By the end of this chapter, you will have a solid foundation in both navigating and programming STM32 microcontrollers at the register level. You will be equipped to write your initial bare-metal firmware, relying solely on information gathered from the documentation<a id="_idIndexMarker068"/><a id="_idIndexMarker069"/> and the <strong class="bold">integrated development </strong><strong class="bold">environment</strong> (<strong class="bold">IDE</strong>).</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor045"/>The different types of firmware development</h1>
			<p>There are<a id="_idIndexMarker070"/><a id="_idIndexMarker071"/> several ways to develop the firmware for a particular microcontroller depending on the resources provided by the microcontroller’s manufacturer. When it comes to developing firmware for STM32 microcontrollers from <strong class="bold">STMicroelectronics</strong>, we can use<a id="_idIndexMarker072"/><a id="_idIndexMarker073"/> the following:</p>
			<ul>
				<li><strong class="bold">Hardware Abstraction Layer (HAL)</strong>: This is a <a id="_idIndexMarker074"/><a id="_idIndexMarker075"/>library provided by STMicroelectronics. It simplifies the process by offering high-level APIs for configuring every aspect of the microcontroller. What is great about HAL is its portability. We can write code for one STM32 microcontroller, and easily adapt it for another, thanks to the uniformity of their APIs.</li>
				<li><strong class="bold">Low Layer (LL)</strong>: Also from<a id="_idIndexMarker076"/><a id="_idIndexMarker077"/> STMicroelectronics, the LL library is a leaner alternative to HAL, offering a faster, more expert-oriented approach that’s closer to the hardware.</li>
				<li><strong class="bold"><a id="_idTextAnchor046"/>Bare-Metal C programming</strong>: With this<a id="_idIndexMarker078"/><a id="_idIndexMarker079"/> approach, we dive right into the hardware, accessing the microcontroller’s registers directly using the C language. It’s more involved but offers a deeper understanding of the microcontroller’s workings.</li>
				<li><strong class="bold">Assembly language</strong>: This is similar<a id="_idIndexMarker080"/><a id="_idIndexMarker081"/> to Bare-Metal C, but instead of C, we use assembly language to interact directly with the microcontroller’s registers.</li>
			</ul>
			<p>Let’s compare the four firmware development methods we’ve discussed: HAL, LL, Bare-Metal C, and assembly language. Each method has its unique style and level of abstraction, impacting how we interact with the microcontroller’s hardware. We will use the example of configuring a <strong class="bold">general-purpose input/output</strong> (<strong class="bold">GPIO</strong>) pin as an output<a id="_idIndexMarker082"/><a id="_idIndexMarker083"/> to illustrate these differences.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor047"/>HAL</h2>
			<p><a id="_idTextAnchor048"/>The following<a id="_idIndexMarker084"/><a id="_idIndexMarker085"/> code snippet demonstrates how to initialize GPIOA pin 5 as an output using HAL:</p>
			<pre class="source-code">
#include "stm32f4xx_hal.h"
GPIO_InitTypeDef GPIO_InitStruct = {0};
// Enable the GPIOA Clock
__HAL_RCC_GPIOA_CLK_ENABLE();
// Configure the GPIO pin
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</pre>			<p>Let’s analyze the snippet:</p>
			<ul>
				<li><code>#include "stm32f4xx_hal.h":</code> This line includes the HAL library specific to the STM32F4 series, providing access to the HAL functions and data structures</li>
				<li><code>GPIO_InitTypeDef GPIO_InitStruct = {0}:</code> Here, we declare and initialize an instance of the <code>GPIO_InitTypeDef</code> structure, which is used to configure the GPIO pin properties</li>
				<li><code>__HAL_RCC_GPIOA_CLK_ENABLE()</code>: This macro call enables the clock for GPIO port A, ensuring that the GPIO peripheral is powered and can function</li>
				<li><code>GPIO_InitStruct.Pin = GPIO_PIN_5:</code> This line sets the pin to be configured, in this case, pin 5 of port A</li>
				<li><code>GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP:</code> Over here, we configure the pin as an output pin</li>
				<li><code>HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct):</code> Finally, we initialize the GPIO pin (PA5) with the configuration settings specified in <code>GPIO_InitStruct</code></li>
			</ul>
			<p><a id="_idTextAnchor049"/>This snippet shows the ease and readability of the HAL approach in performing common hardware interfacing tasks. We can summarize the benefits<a id="_idIndexMarker086"/><a id="_idIndexMarker087"/> and drawbacks<a id="_idIndexMarker088"/><a id="_idIndexMarker089"/> of the HAL approach as follows:</p>
			<ul>
				<li><strong class="bold">Level of </strong><strong class="bold">abstraction</strong>: High</li>
				<li><strong class="bold">Ease of use</strong>: Easier for beginners due to its high-level abstraction</li>
				<li><strong class="bold">Code verbosity</strong>: More verbose, with several lines of code required for simple tasks</li>
				<li><strong class="bold">Portability</strong>: Excellent across different STM32 devices</li>
				<li><strong class="bold">Performance</strong>: Slightly slower due to additional abstraction layers</li>
			</ul>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor050"/>LL</h2>
			<p>This is how we initialize GPIOA<a id="_idIndexMarker090"/><a id="_idIndexMarker091"/> pin 5 as an output pin using the LL library:</p>
			<pre class="source-code">
#include "stm32f4xx_ll_bus.h"
#include "stm32f4xx_ll_gpio.h"
// Enable the GPIOA Clock
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
// Configure the GPIO pin
LL_GPIO_SetPinMode(GPIOA,LL_GPIO_PIN_5,LL_GPIO_MODE_OUTPUT);</pre>			<p>Let’s break it down, line by line:</p>
			<ul>
				<li><code>#include "stm32f4xx_ll_bus.h"</code> and <code>#include "stm32f4xx_ll_gpio.h"</code> include the necessary LL library files for handling the bus system and GPIO functionality, respectively</li>
				<li><code>LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA):</code> This function call enables the clock for GPIO port A</li>
				<li><code>LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT):</code> Finally, we set the mode of GPIOA pin 5 to output mode</li>
			</ul>
			<p>The LL library<a id="_idIndexMarker092"/><a id="_idIndexMarker093"/> provides a more direct and lower-level approach to hardware interaction compared to HAL. This is often preferred in scenarios where finer control over hardware and performance is required.</p>
			<p>The benefits<a id="_idIndexMarker094"/><a id="_idIndexMarker095"/> and drawbacks<a id="_idIndexMarker096"/><a id="_idIndexMarker097"/> of the LL approach are as follows:</p>
			<ul>
				<li><strong class="bold">Level of </strong><strong class="bold">abstraction</strong>: Medium</li>
				<li><strong class="bold">Ease of use</strong>: Moderate, with a balance between abstraction and direct control</li>
				<li><strong class="bold">Code verbosity</strong>: Less verbose than HAL, offering a more straightforward approach to hardware interaction</li>
				<li><strong class="bold">Portability</strong>: Good, but slightly less than HAL</li>
				<li><strong class="bold">Performance</strong>: Faster than HAL, as it’s closer to the hardware</li>
			</ul>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor051"/>Bare-Metal C</h2>
			<p>Let’s see how to accomplish<a id="_idIndexMarker098"/><a id="_idIndexMarker099"/> the same task using the Bare-Metal C approach:</p>
			<pre class="source-code">
#define GPIOA_MODER (*(volatile unsigned long *)(GPIOA_BASE + 0x00))
#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))
// Enable clock for GPIOA
RCC_AHB1ENR |= (1 &lt;&lt; 0);
// Set PA5 to output mode
GPIOA_MODER |= (1 &lt;&lt; 10); // Set bit 10 (MODER5[1])</pre>			<p>Let’s break down the bare-metal c snippet:</p>
			<ul>
				<li><code>#define GPIOA_MODER (*(volatile unsigned long *) (GPIOA_BASE + 0x00))</code> and <code>#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))</code> define pointers to specific registers within the microcontroller’s memory. <code>GPIOA_MODER</code> points to the GPIO port A mode register, and <code>RCC_AHB1ENR</code> points to the <strong class="bold">reset and clock control</strong> (<strong class="bold">RCC</strong>) AHB1 peripheral clock <strong class="bold">enable register</strong> (<strong class="bold">ER</strong>). The use of the volatile keyword ensures<a id="_idIndexMarker100"/><a id="_idIndexMarker101"/> that the compiler treats<a id="_idIndexMarker102"/><a id="_idIndexMarker103"/> these as memory-mapped registers, preventing optimization-related issues.</li>
				<li><code>RCC_AHB1ENR |= (1 &lt;&lt; 0)</code>: This line of code enables the clock for GPIOA. It does this by setting the first bit (bit 0) of the <code>RCC_AHB1ENR</code> register. The bitwise <code>OR</code> assignment (<code>|=</code>) ensures that only the specified bit is changed without altering other bits in the register.</li>
				<li><code>GPIOA_MODER |= (1 &lt;&lt; 10)</code>: This line sets PA5 to output mode. In the GPIO port mode register (<code>GPIOA_MODER</code>), each pin is controlled by two bits. For PA5, these are bits 10 and 11 (<code>MODER5[1:0]</code>). The code sets bit 10 to <code>1</code> (and leaves bit 11 as <code>0</code>, assuming it was already <code>0</code>), configuring PA5 as<a id="_idIndexMarker104"/><a id="_idIndexMarker105"/> a general-purpose output mode.</li>
			</ul>
			<p>With this approach, we can observe the granularity and direct control provided. By directly manipulating the microcontroller’s registers, it offers very high efficiency and performance:</p>
			<ul>
				<li><strong class="bold">Level of </strong><strong class="bold">abstraction</strong>: Low</li>
				<li><strong class="bold">Ease of use</strong>: Challenging for beginners, as it requires in-depth hardware knowledge</li>
				<li><strong class="bold">Code verbosity</strong>: Less verbose, direct</li>
				<li><strong class="bold">Portability</strong>: Limited, as the code is often specific to a particular hardware setup</li>
				<li><strong class="bold">Performance</strong>: Very high, as it allows for direct and optimized hardware manipulation</li>
			</ul>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor052"/>Assembly language</h2>
			<p>Finally, let’s analyze the assembly<a id="_idIndexMarker106"/><a id="_idIndexMarker107"/> language implementation for configuring PA5 as an output pin:</p>
			<pre class="source-code">
EQU GPIOA_MODER, 0x40020000
EQU RCC_AHB1ENR, 0x40023800
; Enable clock for GPIOA
LDR R0, =RCC_AHB1ENR
LDR R1, [R0]
ORR R1, R1, #(1 &lt;&lt; 0)
STR R1, [R0]
; Set PA5 as output
LDR R0, =GPIOA_MODER
LDR R1, [R0]
ORR R1, R1, #(1 &lt;&lt; 10)
STR R1, [R0]</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><code>EQU GPIOA_MODER</code>, <code>0x40020000</code> and <code>EQU RCC_AHB1ENR</code>,<code> 0x40023800</code> define constants for the memory addresses of the GPIOA mode register (<code>GPIOA_MODER</code>) and the RCC AHB1 peripheral clock ER (<code>RCC_AHB1ENR</code>). <code>'EQU'</code> is used in assembly to equate a label to a value or address.</li>
			</ul>
			<p>The rest of the assembly instructions<a id="_idIndexMarker108"/><a id="_idIndexMarker109"/> perform two main tasks:</p>
			<ul>
				<li>Enable the clock for GPIOA:<ul><li><code>LDR R0, =RCC_AHB1ENR</code>: Load the address of the <code>RCC_AHB1ENR</code> register into the <code>R0</code> register</li><li><code>LDR R1, [R0]</code>: Load the value of the <code>RCC_AHB1ENR</code> register into the <code>R1</code> register</li><li><code>ORR R1, R1, #(1 &lt;&lt; 0)</code>: Perform a bitwise <code>OR</code> operation to set bit<code> </code>0 of <code>R1</code>, turning on the clock for GPIOA</li><li><code>STR R1, [R0]</code>: Store the updated value back into the <code>RCC_AHB1ENR</code> register</li></ul></li>
				<li>Set PA5 as output:<ul><li><code>LDR R0, =GPIOA_MODER</code>: Load the address of the <code>GPIOA_MODER</code> register into <code>R0</code></li><li><code>LDR R1, [R0]</code>: Load the current value of the <code>GPIOA_MODER</code> register into <code>R1</code></li><li><code>ORR R1, R1, #(1 &lt;&lt; 10)</code>: Use a bitwise <code>OR</code> operation to set bit 10 of <code>R1</code>, configuring PA5 as an output</li><li><code>STR R1, [R0]</code>: Store the updated value back into the <code>GPIOA_MODER</code> register</li></ul></li>
			</ul>
			<p>The assembly language approach allows for extremely detailed and direct control over the microcontroller. We often use this in projects where high performance is crucial, and every aspect of the hardware needs to be precisely managed.</p>
			<p>The assembly language approach offers us the following:</p>
			<ul>
				<li><strong class="bold">Level of </strong><strong class="bold">abstraction</strong>: Lowest</li>
				<li><strong class="bold">Ease of use</strong>: Most challenging, requiring a thorough understanding of the microcontroller’s architecture</li>
				<li><strong class="bold">Code verbosity</strong>: Can be verbose for complex tasks, due to low-level nature</li>
				<li><strong class="bold">Portability</strong>: Very limited, as it is highly specific to the microcontroller’s architecture</li>
				<li><strong class="bold">Performance</strong>: Highest, as it allows for the most optimized and direct control possible</li>
			</ul>
			<p><a id="_idTextAnchor053"/>The following diagram shows<a id="_idIndexMarker110"/><a id="_idIndexMarker111"/> each method and its closeness to the microcontroller’s architecture:</p>
			<div><div><img src="img/B21914_02_01.jpg" alt="Figure 2.1: Firmware development methods, arranged in order of proximity  to the microcontroller’s architecture" width="610" height="301"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Firmware development methods, arranged in order of proximity to the microcontroller’s architecture</p>
			<p>Now that we have explored the diverse approaches to firmware development for STM32 microcontrollers, we are ready to delve into the realm of bare-metal C programming.</p>
			<p>We will begin our exploration by understanding how the main components of our development board are connected to specific pins of the onboard microcontroller. This initial step is crucial for gaining insight into the hardware layout and preparing us for detailed programming tasks.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor054"/>Locating and understanding the development 
board’s components</h1>
			<p>In this section, our focus is to pinpoint the specific ports and pins on the microcontroller to which the user LED, user push button, berg pins, and Arduino-compatible headers are connected on the development board. Understanding these connections is crucial for our programming tasks. To accurately identify these connections, we will consult the <em class="italic">NUCLEO-F411 </em><em class="italic">User Manual</em>.</p>
			<div><div><img src="img/B21914_02_02.jpg" alt="Figure 2.2: Development board showing components of interest" width="860" height="596"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Development board showing components of interest</p>
			<p>No<a id="_idTextAnchor055"/>w, let’s locate the microcontroller pin connected to the User LED on the development board.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor056"/>Locating the LED connection</h2>
			<p>Ou<a id="_idTextAnchor057"/>r first step is to navigate<a id="_idIndexMarker112"/><a id="_idIndexMarker113"/> through the table of contents to find the section dedicated to LEDs. This can be done quickly by locating <em class="italic">Figure 2</em><em class="italic">.3</em> in the manual, which shows the page number for the <em class="italic">LEDs</em> section and allows us to jump directly to it.</p>
			<p>Click on the page number to jump to the LEDs section.</p>
			<div><div><img src="img/B21914_02_03.jpg" alt="Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents showing the page number of the LEDs section" width="1004" height="192"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents showing the page number of the LEDs section</p>
			<p>In the <em class="italic">LEDs</em> section, we find that the User LED, labeled <strong class="bold">User LD2</strong>, is linked to the ARDUINO® signal <strong class="bold">D13</strong>. This corresponds to either pin PA5 or PB13, depending on the specific STM32 target of our board.</p>
			<p>It’s important to note the dual naming convention used in the User Manual due to the board’s compatibility with the Arduino IDE. In the Arduino naming scheme, pins are categorized as either analog (preceded by “A”) or digital (preceded by “D”). For example, digital pin 3 is denoted as D3. Conversely, the standard STM32 convention starts with a “P,” followed by a letter indicating the port and then the pin number within that port, such as PA5 for the 5th pin of port A.</p>
			<p>To determine whether pin D13 of our development board is PA5 or PB13 of the onboard microcontroller, we refer to <em class="italic">Tables 11 to 23</em> in the manual. These tables map the ARDUINO® connector pins to standard STM32 pins for each development board covered in the document. Specifically, we look at <em class="italic">Figure 2</em><em class="italic">.5</em> showing <em class="italic">Table 16</em>, which pertains to our development board model.</p>
			<p>Navigate to <em class="italic">Table 11</em> by clicking on it as shown in <em class="italic">Figure 2</em><em class="italic">.4</em>. This action will take you to the initial table in the sequence of tables. Then, scroll down until you get to <em class="italic">Table 16</em>.</p>
			<div><div><img src="img/B21914_02_04.jpg" alt="Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the two possible connections of the User LED" width="964" height="288"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the two possible connections of the User LED</p>
			<p>Upon reviewing <em class="italic">Table 16</em>, we find that D13 indeed<a id="_idIndexMarker114"/><a id="_idIndexMarker115"/> corresponds to PA5. This indicates that the User LED on our NUCLEO-F411RE development board is connected to pin PA5 of the onboard microcontroller.</p>
			<div><div><img src="img/B21914_02_05.jpg" alt="Figure 2.5: Table 16 shows that D13 corresponds to PA5" width="1421" height="185"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Table 16 shows that D13 corresponds to PA5</p>
			<p>Another useful component found on the development board is the User Push button. Let’s find the pin connection of this component.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor058"/>Locating the User Push button</h2>
			<p>The User Push button on the development<a id="_idIndexMarker116"/><a id="_idIndexMarker117"/> board is an important component for input handling in many embedded experiments, and understanding its connection to the microcontroller is crucial for effective programming and interaction.</p>
			<p>To locate the connection details of the User Push button on our board, we will navigate through the table of contents to find the section dedicated to <em class="italic">Push-buttons</em>.</p>
			<p>This can be done quickly by locating <em class="italic">Figure 2</em><em class="italic">.6</em> in the manual, which shows the page number for the <em class="italic">Push-buttons</em> section and allows us to jump directly to it by clicking on the page number.</p>
			<div><div><img src="img/B21914_02_06.jpg" alt="Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number for the Push-buttons section" width="1398" height="202"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number for the Push-buttons section</p>
			<p>Upon navigating to the <em class="italic">Push-buttons</em> section of the<a id="_idIndexMarker118"/><a id="_idIndexMarker119"/> manual, we locate the relevant information about our User Push-button, identified as <strong class="bold">B1 User</strong>. The manual tells us that this button is connected to pin <strong class="bold">PC13</strong> of the onboard microcontroller.</p>
			<h2 id="_idParaDest-43">Locati<a id="_idTextAnchor059"/>ng the berg pins and Arduino-compatible headers</h2>
			<p>In the <em class="italic">LEDs</em> sections, we learned<a id="_idIndexMarker120"/><a id="_idIndexMarker121"/> that our NUCLEO-F411 development board features two primary naming systems for its pins: the Arduino naming system and the standard STM32 naming system. While bare-metal programming primarily utilizes<a id="_idIndexMarker122"/><a id="_idIndexMarker123"/> the standard STM32 naming, the pins on the board itself are labeled according to the Arduino system. It is important to know the actual port names and pin numbers of these exposed pins so that we can properly connect and program external components such as sensors and actuators.</p>
			<p><em class="italic">Figure 2</em><em class="italic">.7</em> shows our NUCLEO-F411 development board with the columns of berg pins highlighted.</p>
			<div><div><img src="img/B21914_02_07.jpg" alt="Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted" width="823" height="524"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted</p>
			<p>The Arduino header pins of the development board are located<a id="_idIndexMarker124"/><a id="_idIndexMarker125"/> at the sides of the berg pins columns. This is highlighted in <em class="italic">Figure 2</em><em class="italic">.8</em>.</p>
			<div><div><img src="img/B21914_02_08.jpg" alt="Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted" width="943" height="520"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted</p>
			<p>Let’s start by finding the microcontroller pin connections of the Arduino header pins.</p>
			<h3>Arduino-compatible headers</h3>
			<p>To identify the standard<a id="_idIndexMarker126"/><a id="_idIndexMarker127"/> STM32 names for the pins on the Arduino header, we navigate to the section titled <em class="italic">ARDUINO® connectors</em> using the table of contents. This directs us to <em class="italic">Table 11</em>, which provides the mappings of Arduino pins to STM32 pins. For our specific NUCLEO-F411 development board, we focus on <em class="italic">Table 16</em>, which offers the relevant mapping for our model.</p>
			<p>Next, let’s locate the connections of the berg pins.</p>
			<h3>The berg pins</h3>
			<p>Similar to our approach with other<a id="_idIndexMarker128"/><a id="_idIndexMarker129"/> components, to find details about the berg pins, we again consult the table of contents in the manual and locate the section called <em class="italic">Extension connectors</em>. This section includes figures illustrating the pinouts for various NUCLEO boards. We then scroll to find the pinout corresponding to our specific NUCLEO model. Here, the pinout of our development board is presented in the standard STM32 naming system.</p>
			<p>Over here, we also discover that the manual<a id="_idIndexMarker130"/><a id="_idIndexMarker131"/> refers to the columns of male header berg pins as the ST morpho connector. This means that whenever the <em class="italic">morpho connector</em> term is used, it is referring to these male header berg pins.</p>
			<div><div><img src="img/B21914_02_09.jpg" alt="Figure 2.9: Pinout of the NUCLEO-F411 development board" width="779" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Pinout of the NUCLEO-F411 development board</p>
			<p>In this section, we learned that NUCLEO development boards use two naming systems. Firstly, the Arduino naming system, which is visibly marked on the board, and secondly, the standard STM32 naming system, detailed in the documentation. We discovered that the standard STM32 naming system is particularly relevant for our purposes, as it directly correlates to the pin names of the onboard microcontroller.</p>
			<p>The next section will guide us on how to access and manipulate the relevant memory locations of the onboard microcontroller. Our focus will be on configuring pin PA5 as an output pin. This will allow us to control the LED connected to PA5.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor060"/>Defining and creating registers through 
documentation insights</h1>
			<p>In the previous section, we established that the User LED is connected to pin PA5. This means that it is linked to pin number 5 on GPIO PORTA. In other words, to get to the LED, we have to go through PORTA and then locate pin number 5 of that port.</p>
			<p>As illustrated in <em class="italic">Figure 2</em><em class="italic">.10</em>, the microcontroller has exposed pins on all four sides. These pins are organized into distinct groups known<a id="_idIndexMarker132"/><a id="_idIndexMarker133"/> as <strong class="bold">ports</strong>. For instance, pins in PORTA are denoted with the <em class="italic">PA</em> prefix, while those in PORTB start with <em class="italic">PB</em>, and so forth. This systematic arrangement allows us to easily identify and access specific pins for programming and hardware interfacing tasks.</p>
			<div><div><img src="img/B21914_02_10.jpg" alt="Figure 2.10: STM32F411 pinout" width="793" height="682"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: STM32F411 pinout</p>
			<p>In the next section, we will go through the steps to locate the precise address of GPIO PORTA.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor061"/>Locating GPIO PORTA</h2>
			<p>To effectively interact with any part of our<a id="_idIndexMarker134"/><a id="_idIndexMarker135"/> microcontroller, it’s essential to know the memory address of that specific part. Our next step is to explore the memory map of the microcontroller. By doing so, we can locate the address of GPIO PORTA in a step-by-step manner.</p>
			<p>Since our focus is now on the onboard microcontroller rather than the development board, we need to refer to the microcontroller’s datasheet, specifically the <code>stm32f411re.pdf</code> document.</p>
			<p>Let’s start by navigating to the table of contents of the document. There, we’ll find a section entitled <em class="italic">Memory Mapping</em>. Click on the corresponding page number to jump to that section.</p>
			<p>Over here, we find a comprehensive diagram that illustrates the entire memory map of the microcontroller. A relevant excerpt of this diagram is presented in <em class="italic">Figure 2</em><em class="italic">.11</em>, which shows the overall memory layout.</p>
			<div><div><img src="img/B21914_02_11.jpg" alt="Figure 2.11: Memory map" width="237" height="604"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: Memory map</p>
			<p>The memory map<a id="_idIndexMarker136"/><a id="_idIndexMarker137"/> shows that everything inside the microcontroller is addressed from <code>0x0000 0000</code> to <code>0xFFFF FFFF</code>. We’re interested in the part about peripherals because that’s where we find GPIOA.</p>
			<p>In the context of microcontrollers, a peripheral refers to a hardware component that is not part of the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) but is connected<a id="_idIndexMarker138"/><a id="_idIndexMarker139"/> to the microcontroller to extend its capabilities. Peripherals perform specific functions and can include a wide range of components, such as the following:</p>
			<ul>
				<li><strong class="bold">GPIO ports</strong>: These are used for interfacing<a id="_idIndexMarker140"/><a id="_idIndexMarker141"/> with external devices such as LEDs, switches, and sensors. They can be programmed to either receive input signals or send output signals.</li>
				<li><strong class="bold">Communication interfaces</strong>: These include<a id="_idIndexMarker142"/><a id="_idIndexMarker143"/> serial communication<a id="_idIndexMarker144"/><a id="_idIndexMarker145"/> interfaces such as a <strong class="bold">universal asynchronous receiver-transmitter</strong> (<strong class="bold">UART</strong>), <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>), and <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>), which enable<a id="_idIndexMarker146"/><a id="_idIndexMarker147"/> the microcontroller to communicate with other devices, sensors, or even other<a id="_idIndexMarker148"/><a id="_idIndexMarker149"/> microcontrollers.</li>
				<li><strong class="bold">Timers and counters</strong>: Timers are used<a id="_idIndexMarker150"/><a id="_idIndexMarker151"/> for measuring time intervals or generating time-based events, while counters<a id="_idIndexMarker152"/><a id="_idIndexMarker153"/> can be used to count events or pulses.</li>
				<li><strong class="bold">Analog-to-digital converters (ADCs)</strong>: ADCs convert analog<a id="_idIndexMarker154"/><a id="_idIndexMarker155"/> signals (such as those from a temperature sensor) into digital values that the microcontroller can process.</li>
			</ul>
			<p>The peripherals mentioned here represent a selection of the common types found in microcontrollers. As we progress through subsequent chapters, we will delve deeper into these and other peripherals.</p>
			<p><a id="_idTextAnchor062"/>In <em class="italic">Figure 12</em><em class="italic">.11</em>, the memory map shows that the address range for all the microcontroller’s peripherals spans from <code>0x40000000</code> to <code>0x5FFFFFFF</code>. This means that GPIO PORTA’s address lies within this specified range.</p>
			<p class="callout-heading">Peripherals base address = 0x40000000</p>
			<p class="callout"><a id="_idTextAnchor063"/>Let’s note down the start of the peripheral address, which we will refer to as <code>PERIPH_BASE</code>, indicating the base address for the peripherals. We will need this for calculating the address of GPIO PORTA. <code>PERIPH_BASE</code> = <code>0x40000000</code>.</p>
			<p><em class="italic">Figure 12</em><em class="italic">.12</em> shows a zoomed-in view of the peripherals<a id="_idIndexMarker156"/><a id="_idIndexMarker157"/><a id="_idIndexMarker158"/> section in the memory map. Here, we observe that the peripheral memory is segmented into five distinct blocks: APB1, APB2, AHB1, AHB2, and the Cortex-M internal peripherals block, which is located at the top.</p>
			<div><div><img src="img/B21914_02_12.jpg" alt="Figure 2.12: Peripherals memory map" width="500" height="1390"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Peripherals memory map</p>
			<p>These blocks, except for<a id="_idIndexMarker159"/><a id="_idIndexMarker160"/> the Cortex-M internal peripherals, are named after<a id="_idIndexMarker161"/><a id="_idIndexMarker162"/> the bus systems they interface with – namely, the <strong class="bold">Advanced Peripheral Bus</strong> (<strong class="bold">APB</strong>) and the <strong class="bold">Advanced High-Performance </strong><strong class="bold">Bus</strong> (<strong class="bold">AHB</strong>):</p>
			<ul>
				<li><strong class="bold">APB1 and APB2</strong>: These buses cater to lower bandwidth peripherals, providing a more efficient means of communication for devices that do not require high-speed data transfer.</li>
				<li><strong class="bold">AHB1 and AHB2</strong>: These are designed for high-speed data transfer and are used to connect high-bandwidth peripherals. They enable faster and more efficient data, control, and address communication.</li>
			</ul>
			<p>On <em class="italic">pages 54 to 56</em> of the datasheet, we find a table delineating the boundary addresses for each bus and the associated peripherals. A segment of this table is shown in <em class="italic">Figure 2</em><em class="italic">.13</em>, where we find that GPIOA is allocated a boundary address from <code>0x40020000</code> to <code>0x4002 03FF</code> and is connected to the AHB1 bus. Therefore, this indicates that the addresses for all registers related to GPIO PORTA are encompassed within this address range.</p>
			<div><div><img src="img/B21914_02_13.jpg" alt="Figure 2.13: Boundary address and Bus of GPIOA" width="927" height="721"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: Boundary address and Bus of GPIOA</p>
			<p class="callout-heading">GP<a id="_idTextAnchor064"/>IOA base address = PERIPH_BASE + 0x20000 = 0x40020000</p>
			<p class="callout">From the table, we find that the starting address for the GPIOA boundary is <code>0x40020000</code>. This reveals that adding an offset of <code>0x20000</code> to the <code>PERIPH_BASE</code> address (which is 0x40000000) results in the base address of GPIOA, calculated as <code>0x40000000 + 0x20000 = 0x40020000</code>. The term “offset value” refers to the value added to derive a specific address from a base address. In this case, the offset value for GPIOA from the <code>PERIPH_BASE</code> address is <code>0x20000</code>.</p>
			<p>Understanding the concept of offset values is crucial for accurately calculating desired addresses in microcontroller programming. This understanding enables precise navigation and manipulation within the system’s memory map.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor065"/>Clock gating</h2>
			<p>Having identified the exact address of GPIOA, our next step is to enable clock access to it before configuring its registers. This step is necessary because, by default, the clock to all unused peripherals is disabled to conserve power.</p>
			<p>Modern microcontrollers use a power-saving technique<a id="_idIndexMarker163"/><a id="_idIndexMarker164"/> known as <strong class="bold">clock gating</strong>. In simple terms, clock gating involves selectively turning off the clock signal to certain parts of the microcontroller when they’re not in use. The clock signal is an essential part of microcontroller operations, as it drives the sequential logic by providing a regular pulse that synchronizes the activities of the microcontroller’s circuits. However, when a particular part of the microcontroller, such as a peripheral, is not actively being used, the clock signal to that part is disabled. This disabling prevents unnecessary power consumption by idle circuits. Therefore, before using any peripheral, it’s required to first enable clock access to it.</p>
			<p>As shown in <em class="italic">Figure 2</em><em class="italic">.14</em>, there’s a peripheral listed as RCC, which has a boundary address range from <code>0x40023800</code> to <code>0x40023BFF</code>. The functions of this peripheral include enabling and disabling clock access to other peripherals.</p>
			<p class="callout-heading">RC<a id="_idTextAnchor066"/>C base Address = PERIPH_BASE + 0x23800 = 0x40023800</p>
			<p class="callout">From the boundary address information, we can see that the <code>RCC _Base</code> address is obtained by adding an offset of <code>0x23800</code> to <code>PERIPH_BASE</code>.</p>
			<div><div><img src="img/B21914_02_14.jpg" alt="" role="presentation" width="809" height="629"/>
				</div>
			</div>
			<p class="callout">Figure 2.14: Boundary address and Bus of RCC</p>
			<p>Having successfully determined the base addresses<a id="_idIndexMarker165"/><a id="_idIndexMarker166"/> for the two essential peripherals needed to configure GPIOA pin 5 (which controls the connected LED), our next step involves using these base addresses to derive the specific register addresses necessary for setting the pin as an output and ultimately activating the LED.</p>
			<p>To locate the detailed information about these registers, we will refer to the reference manual (<em class="italic">RM0383</em>). This document provides comprehensive insights into all registers and their configurations.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor067"/>The AHB1 ER</h2>
			<p>Our reference <a id="_idIndexMarker167"/>manual, RM0383, is a <a id="_idIndexMarker168"/>comprehensive document spanning over 800 pages, and some STM32 reference manuals even exceed 1,500 pages. The objective is not to read the entire manual cover to cover, but rather to develop the skill to efficiently locate specific information as needed. Previously, we established that GPIOA is connected to the AHB1 bus. We also learned that activating this peripheral requires enabling clock access through the RCC peripheral.</p>
			<p>The RCC peripheral in our microcontroller includes a specific register dedicated to enabling the clock for each bus. In STM32 microcontrollers, the naming of registers follows a straightforward pattern: <em class="italic">peripheral acronym + underscore + register acronym</em>. For example, the register responsible for controlling clock access to the AHB1 bus is named <code>RCC_AHB1ENR</code>.</p>
			<p>Let’s explain this a bit more:</p>
			<ul>
				<li><strong class="bold">RCC</strong> stands<a id="_idIndexMarker169"/> for <strong class="bold">Reset and </strong><strong class="bold">Clock Control</strong></li>
				<li><strong class="bold">AHB1</strong> stands<a id="_idIndexMarker170"/> for <strong class="bold">Advanced High-Performance </strong><strong class="bold">Bus 1</strong></li>
				<li><strong class="bold">ENR</strong> stands <a id="_idIndexMarker171"/>for <strong class="bold">Enable Register</strong></li>
			</ul>
			<p>This systematic naming convention simplifies the process of identifying and accessing the appropriate registers.</p>
			<p>To find the<a id="_idIndexMarker172"/> information about the <code>RCC_AHB1ENR</code> register, we begin by opening the reference manual. Next, we navigate to the table of contents and search for the section titled <em class="italic">RCC AHB1 Peripheral Clock Enable Register (RCC_AHB1ENR)</em>. Once located, we click on the page number provided alongside this section title to directly jump to the relevant part of the document.</p>
			<p>Let’s begin by examining the details presented at the top of the page, as illustrated in <em class="italic">Figure 2</em><em class="italic">.15</em>. This section provides key information about the register, including the following:</p>
			<ul>
				<li><strong class="bold">Register name</strong>: The<a id="_idIndexMarker173"/> full name of the register is provided along with its abbreviation, namely <strong class="bold">RCC AHB1 Peripheral Clock Enable </strong><strong class="bold">Register</strong> (<strong class="bold">RCC_AHB1ENR</strong>).</li>
				<li><code>0x30</code>.</li>
				<li><code>0x00000000</code>, indicating the value the register holds upon reset. In other words, the default value of the register.</li>
				<li><strong class="bold">Access type</strong>: The register supports various access types – it can be accessed without wait states and allows word, half-word, and byte access.</li>
				<li><strong class="bold">Register diagram</strong>: A detailed diagram of the register is included, showing all 32 bits along with labels for each bit.</li>
			</ul>
			<div><div><img src="img/B21914_02_15.jpg" alt="Figure 2.15: RCC AHB1 ER" width="1444" height="544"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: RCC AH<a id="_idTextAnchor068"/>B1 ER</p>
			<p class="callout-heading">RCC_AHB1ENR Address = RCC_BASE + 0x30 = 0x40023830</p>
			<p class="callout">From this information, we can accurately calculate the address of the <code>RCC_AHB1ENR</code> register. We do this by adding the <code>RCC_AHB1ENR</code> offset to the <code>RCC_BASE address</code>. The formula is as follows: <code>RCC_BASE + RCC_AHB1ENR Offset = 0x40023800 + 0x30 = </code><code>0x40023830</code>.</p>
			<p>The same section of the reference manual also includes a detailed description of each bit within the register. We are particularly interested in the bit named <code>'GPIOAEN'</code>, which stands<a id="_idIndexMarker174"/> for <code>0</code>. Further down, at the start of the next page in the document, we find a precise description of <code>bit0</code>, as depicted in <em class="italic">Figure 2</em><em class="italic">.16</em>. This description explains that setting <code>bit0</code> to <code>0</code> disables the GPIOA clock while setting it to <code>1</code> enables the GPIOA clock.</p>
			<div><div><img src="img/B21914_02_16.jpg" alt="Figure 2.16: GPIOAEN bit" width="808" height="232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: GPIOAEN bit</p>
			<p>Having understood the steps required to enable clock access to GPIOA, our next section will focus on learning how to set and clear bits within a register.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor069"/>Setting and clearing bits in registers</h2>
			<p>In bare-metal programming, manipulating individual bits within registers is a fundamental operation. This manipulation is important for configuring hardware settings, controlling peripheral devices, and optimizing the performance of embedded systems. Let’s start by understanding bits and registers.</p>
			<p>A <code>0</code> or <code>1</code>. <strong class="bold">Registers</strong>, on the other hand, are small-sized storage locations within microcontrollers, used to store data temporarily for various operations. Registers are<a id="_idIndexMarker176"/> typically a collection of bits (such as 8-bit, 16-bit, or 32-bit registers), and each bit in a register can be manipulated individually. In bare-metal programming, the two most frequently used bit operations are setting a bit and clearing a bit.</p>
			<h3>Setting a bit</h3>
			<p>Setting a bit <a id="_idIndexMarker177"/>means changing its value to <code>1</code>. We will often use this to activate or enable a specific function within a microcontroller.</p>
			<p><code>OR</code> operation (<code>|</code>) is used for setting a bit:</p>
			<pre class="source-code">
register |= 1 &lt;&lt; bit_position;</pre>			<p>In this operation, <code>1</code> is shifted left <code>(&lt;&lt;)</code> to <code>bit_position</code> and then <code>ORed</code> with the current value of the register. The left shift operation creates a binary value where only the target bit is <code>1</code>, and all others are <code>0</code>. The <code>OR</code> operation then sets the target bit in the register to <code>1</code>, leaving the rest unchanged.</p>
			<p>Let’s <a id="_idIndexMarker178"/>assume <code>register</code> initially holds the <code>0011</code> (binary) value and we want to set the third bit (bit position 2, 0-indexed). The <em class="italic">bit-shifted value</em> would be <code>0100</code> (binary for <code>1 &lt;&lt; 2</code>). The <code>OR</code> operation is then as follows:</p>
			<pre class="source-code">
<strong class="bold">0011: original register value</strong>
<strong class="bold">(0001 &lt;&lt;2) = 0100: bit-shifted value</strong>
0011
OR
0100
------
0111 (resulting value)</pre>			<p>In this example, the <em class="italic">first</em>, <em class="italic">second</em>, and <em class="italic">fourth</em> bits of the original register value retain their value while the value of the third bit is changed to <code>1</code>.</p>
			<p>Let’s see the opposite of setting a bit.</p>
			<h3>Clearing a bit</h3>
			<p>Conversely, clearing a <a id="_idIndexMarker179"/>bit means changing its value to <code>0</code>, typically to deactivate a function.</p>
			<p><code>AND</code> (<code>&amp;</code>) and <code>NOT</code> (<code>~</code>) operations is used for clearing a bit:</p>
			<pre class="source-code">
register &amp;= ~(1 &lt;&lt; bit_position);</pre>			<p>Here, <code>1</code> is left-shifted to <code>bit_position</code>, and then a bitwise <code>NOT</code> operation is applied to create a binary number where all bits are <code>1</code>, except the target bit. The <code>AND</code> operation with the register clears the target bit, leaving others as they are.</p>
			<p>Let’s assume <code>register</code> initially holds the <code>0111</code> (binary) value and we want to clear the third bit (bit position 2, 0-indexed). <em class="italic">The bit-shifted value for the mask</em> would be <code>0100</code> (binary for <code>1 &lt;&lt; 2</code>). To clear the bit, we use the bitwise <code>AND</code> operation with the bitwise <code>NOT</code> of the bit-shifted value. The operation is as follows:</p>
			<pre class="source-code">
<strong class="bold">0111: original register value</strong>
<strong class="bold">(0001 &lt;&lt; 2) = 0100: bit-shifted value</strong>
<strong class="bold">~0100 = 1011: bitwise NOT of bit-shifted value</strong>
0111
AND
1011
----
0011 (resulting value)</pre>			<p>In this operation, the <a id="_idIndexMarker180"/>third bit of the register is cleared (changed to <code>0</code>), while the other bits retain their original values.</p>
			<p>Let’s summarize the key points from the last two sections. Firstly, we understood that enabling clock access to GPIOA requires setting <code>bit0</code> in the <code>RCC_AHB1ENR</code> register. Secondly, we explored how to set and clear bits in registers using bitwise operations. Moving forward, in the next section, we will focus on configuring GPIOA pin 5 (PA5) as an output pin. This step is crucial in our progress toward activating the LED connected to PA5. This will take us a step closer to activating the LED connec<a id="_idTextAnchor070"/>ted to PA5.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor071"/>The GPIO port mode register (GPIOx_MODER)</h2>
			<p>The <strong class="bold">GPIO port mode register</strong> in STM32 <a id="_idIndexMarker181"/>microcontrollers is a specialized register used for setting the mode of each GPIO pin. To locate information about this register, we navigate to the table of contents of the reference manual and look for the section titled <em class="italic">GPIO Port Mode Register (GPIOx_MODER)</em>. By clicking on the associated page number, we are directly taken to the section.</p>
			<p><em class="italic">Figure 2</em><em class="italic">.17</em> shows the top section of the page. Here, we can observe the follow<a id="_idTextAnchor072"/>ing details:</p>
			<ul>
				<li><code>GPIOA_MODER</code> through <code>GPIOE_MODER</code>, as well as <code>GPIOH_MODER</code>. This means the same register structure and configuration are consistent across these GPIO ports.</li>
				<li><code>MODER</code> register is located at the very beginning of the port’s memory space. Therefore, the GPIOA <code>MODE</code> register address is the same as the GPIOA base address.</li>
				<li><code>GPIOA_MODER</code> register is <code>0xA800 0000</code>. This value represents the initial configuration state of the GPIOA pins upon reset.</li><li><code>GPIOB_MODER</code> register has a default reset value of <code>0x0000 0280</code>.</li><li><code>MODER</code> registers of all other specified GPIO ports is<a id="_idTextAnchor073"/> <code>0x0000 0000</code>:</li></ul><p class="list-inset"><strong class="bold">GPIOA MODE Register Address = GPIOA_BASE = </strong><strong class="bold">0x40020000</strong></p></li>
			</ul>
			<div><div><img src="img/B21914_02_17.jpg" alt="Figure 2.17: GPIO port mode register" width="1172" height="518"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: GPIO port mode register</p>
			<p>We also observe that this is a 32-bit register, with its bits organized in pairs. For example, <code>bit0</code> and <code>bit1</code> together form a pair known as <code>MODER0</code>, <code>bit2</code> and <code>bit3</code> form <code>MODER1</code>, <code>bit4</code> and <code>bit5</code> form <code>MODER2</code>, and so on. Each of these pairs corresponds to a single pin of the GPIO port. Specifically, <code>MODER0</code> controls the configuration of <code>PIN0</code> of the corresponding port, <code>MODER1</code> controls <code>PIN1</code>, and this pattern continues similarly for the other pins.</p>
			<p>Given our<a id="_idIndexMarker183"/> objective of configuring the mode of <code>PIN5</code>, we need to focus on <code>MODER5</code>. In the register, <code>MODER5</code> comprises <code>bit10</code> and <code>bit11</code>. These two bits are the required bits for setting the operational mode of <code>PIN5</code>.</p>
			<p>The reference manual provides a truth table, illustrated in <em class="italic">Figure 2</em><em class="italic">.18</em>, which explains the combinations of the two <code>MODER</code> bits necessary to configure a pin. This table is an invaluable resource for understanding how to set the bits for the desired pin configuration, whether it’s as an input, output, or an alternate function mode.</p>
			<div><div><img src="img/B21914_02_18.jpg" alt="Figure 2.18: The MODER bits configuration" width="1354" height="300"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: The MODER bits configuration</p>
			<p>As shown in <em class="italic">Figure 2</em><em class="italic">.18</em>, the <code>MODER</code> register within the GPIO port is composed of pairs of bits, designated as <code>2y:2y+1 MODERy[1:0]</code>, where <em class="italic">y</em> ranges from 0 to 15, representing each of the 16 pins in the port (<code>PIN0</code> to <code>PIN15</code>).</p>
			<p>In this equation, <em class="italic">y</em> represents the pin number. For Pin 5, <em class="italic">y = 5</em>. Plugging this value into the equation gives us the bit positions in the <code>MODER</code> register that correspond to Pin 5:</p>
			<p>The bit positions for <code>MODER5</code> are calculated as <em class="italic">2*y</em> and <em class="italic">(</em><em class="italic">2*y) +1</em>.</p>
			<p>Substituting <em class="italic">y = 5</em>, we get the following:</p>
			<p> <em class="italic">2*5 = 10</em> and <em class="italic">2*5 + 1 = 11</em>, which are <code>10</code> and <code>11</code>, respectively.</p>
			<p>So, bits <code>10</code> and <code>11</code> in the MODER register (<code>MODER5[1:0]</code>) are the bits that control the mode of Pin 5. By setting these bits to specific values (<code>00</code>, <code>01</code>, <code>10</code>, or <code>11</code>), we can configure Pin 5 as an input, general-purpose output, alternate function, or analog mode, respectively.</p>
			<p>The GPIO <code>MODER</code> register supports four distinct bit combinations, each defining a different operational mode for the corresponding pin:</p>
			<ul>
				<li><code>00</code>: When both bits are <code>0</code>, the corresponding pin is set as an input pin. This is the standard mode for pins to receive data from external sources.</li>
				<li><code>01</code>: Setting the bits to <code>01</code> sets the pin function to general-purpose output. In this mode, the pin can send data out, for instance, to light up an LED.</li>
				<li><code>10</code>: The <code>10</code> state configures the pin for alternate functions. Each pin can serve specific additional purposes (such as PWM output and I2C communication lines), and this mode enables those functions.</li>
				<li><code>11</code>: When the bits are set to <code>11</code>, the pin operates in analog mode. This mode is typically used for ADC, useful in reading values from analog sensors.</li>
			</ul>
			<p>From this, we understand that to configure PA5 as an output, we must set bit 10 of the <code>GPIOA_MODER</code> register to <code>0</code> and bit 11 to <code>1</code>.</p>
			<p>Let’s summarize<a id="_idIndexMarker184"/> our progress toward activating the LED connected to PA5:</p>
			<ul>
				<li><code>bit0</code> of the <code>RCC_AHB1ENR</code> register to <code>1</code>. This step is essential to power the GPIOA for operation.</li>
				<li><strong class="bold">Configuring PA5 for output</strong>: We have just learned how to set PA5 as a general-purpose output pin.</li>
			</ul>
			<p>These two steps effectively configure PA5 as an output pin. The final task involves controlling the output state of the pin – setting it to either <code>1</code> or <code>0</code>, which corresponds to on or off, respectively. This translates to sending either 3.3v or 0v to PA5, thus turning the connected LED on or off. To manage the output state of a pin, we need to interact with <a id="_idIndexMarker185"/>the <strong class="bold">Output Data Register</strong> (<strong class="bold">ODR</strong>). Locating and configuring this register will be the focus of the next section.</p>
			<p>So far, we have the following information for our quest to activate the LED connected to PA5:</p>
			<ul>
				<li>We know how to enable clock access to GPIOA through the <code>RCC_AHB1ENR</code> register</li>
				<li>We know how to<a id="_idIndexMarker186"/> configure the PIN5 of GPIOA as a general-purpose output pin.</li>
			</ul>
			<p>These two steps make PA5 act as an output pin. The final step is to be able to set the output state of the pin. The state can be either <code>1</code> or <code>0</code> corresponding to on or off, corresponding to sending 3.3v or 0v to PA5, and finally corresponding to turning on or turning off the LED connected to PA5. To set the output of a pin, we need to access the ODR; this shall be the focus of the next section.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor074"/>GPIO Port Output Data Register (GPIOx_ODR)</h2>
			<p>The GPIO Port <strong class="bold">ODR</strong> in STM32<a id="_idIndexMarker187"/> microcontrollers is used for controlling the output state of each GPIO pin. To find information about this register, we refer to the table of contents in the microcontroller’s reference manual and locate the section titled <em class="italic">GPIO Port Output Data Register (GPIOx_ODR)</em>. Clicking on the page number corresponding to this section takes us straight to the required information.</p>
			<p><em class="italic">Figure 2</em><em class="italic">.19</em> displays the top part of the page, where we can observe the following details:</p>
			<ul>
				<li><code>GPIOA_ODR</code> through <code>GPIOE_ODR</code>, as well as <code>GPIOH_ODR</code>. This means the same register structure and configuration are consistent across these GPIO ports.</li>
				<li><code>0x14</code> from the base address of its respective GPIO port. This means that, for each GPIO port, the ODR register can be found at this offset from the port’s base memory address.</li>
				<li><code>0</code> upon a reset. This default state ensures that all GPIO pins are initially in a low output state.</li>
			</ul>
			<p class="callout-heading">GPIOA ODR address = GPIOA_BASE + ODR_OFFSET = 0x40020014</p>
			<p class="callout"><code>ODR_OFFSET = </code><code>0x14</code>.</p>
			<div><div><img src="img/B21914_02_19.jpg" alt="" role="presentation" width="1270" height="489"/>
				</div>
			</div>
			<p class="callout">Figure 2.19: GPIO port ODR</p>
			<p>Let’s delve into the<a id="_idIndexMarker188"/> structure of the bits:</p>
			<ul>
				<li><strong class="bold">Bits 31:16 (reserved)</strong>: These bits are reserved and should not be used for any operation.</li>
				<li><code>0</code> to <code>15</code>, correspond to each of the 16 pins in the GPIO port. They are directly programmable and can be both read and written by software. Changing the value of these bits alters the output state of the corresponding GPIO pin.</li>
			</ul>
			<p>Let’s consider our final task of activating the LED connected to PA5:</p>
			<ul>
				<li><code>5</code>) in the <code>GPIOA_ODR</code> register.</li>
				<li><code>1</code> to bit <code>5</code> of the <code>GPIOA_ODR</code> register. This can be achieved using a bitwise <code>OR</code> operation, as follows:<pre class="source-code">
GPIOA_ODR |= 1 &lt;&lt; 5;</pre></li>			</ul>
			<p>In this operation, we <a id="_idIndexMarker189"/>shift <code>1</code> left by 5 positions (resulting in a binary value where only the 6th bit is <code>1</code>) and then <code>OR</code> it with the current value of the <code>GPIOA_ODR</code> register. This action sets PA5 high without altering the state of other pins in the port.</p>
			<p>Setting PA5 high will supply voltage to the connected LED, effectively turning it on.</p>
			<p>Now that we understand how to set the state of GPIO output pins, in the next section, we will combine all the pieces of information we’ve acquired and develop our first firmware.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor075"/>Register manipulation – from configuration to running your first firmware</h1>
			<p>In this section, we will apply the <a id="_idIndexMarker190"/>knowledge acquired throughout this chapter to develop our first bare-metal firmware.</p>
			<p>We begin by creating a new project, a process we covered in <a href="B21914_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. Here is a summary of the steps:</p>
			<ol>
				<li><strong class="bold">Start a new project</strong>: Go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">STM32 Project</strong> in your IDE.</li>
				<li><strong class="bold">Select the target microcontroller</strong>: A <strong class="bold">Target Selection</strong> window will appear, prompting you to choose the microcontroller or development board for your project.</li>
				<li><strong class="bold">Use the board selector</strong>: Click on the <strong class="bold">Board </strong><strong class="bold">Selector</strong> tab.</li>
				<li><code>NUCLEO-F411</code> in the <strong class="bold">Commercial Part </strong><strong class="bold">Number</strong> field.</li>
				<li><strong class="bold">Select our board</strong>: From the list of boards that appear, choose <strong class="bold">NUCLEO-F411RE</strong> and then click <strong class="bold">Next</strong>.</li>
				<li><code>RegisterManipulation</code>.</li>
				<li><code>Empty</code> project setup.</li>
				<li><strong class="bold">Final step</strong>: Click <strong class="bold">Finish</strong> to create your project.</li>
			</ol>
			<p>Once the project is<a id="_idIndexMarker191"/> created, open the <code>main.c</code> file in your project workspace. Clear all pre-existing text in this file to start with a clean slate for our code.</p>
			<p>For a clearer understanding, we will structure our code into two distinct sections. The first section will be titled <code>Register Definitions</code>, and the second will be named <code>Main Function</code>.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor076"/>Register Definitions</h2>
			<p>This section of the <a id="_idIndexMarker192"/>code defines constants and macros for memory addresses and bit masks. Here are all the memory addresses and bit masks required for controlling the LED connected to PA5:</p>
			<pre class="source-code">
//  1: Define base address for peripherals
<strong class="bold">#define</strong> PERIPH_BASE        (0x40000000UL)
//  2: Offset for AHB1 peripheral bus
<strong class="bold">#define</strong> AHB1PERIPH_OFFSET  (0x00020000UL)
//  3: Base address for AHB1 peripherals
<strong class="bold">#define</strong> AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)
//  4: Offset for GPIOA
<strong class="bold">#define</strong> GPIOA_OFFSET       (0x0000UL)
//  5: Base address for GPIOA
<strong class="bold">#define</strong> GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)
//  6: Offset for RCC
<strong class="bold">#define</strong> RCC_OFFSET         (0x3800UL)
//  7: Base address for RCC
<strong class="bold">#define</strong> RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)
//  8: Offset for AHB1EN register
<strong class="bold">#define</strong> AHB1EN_R_OFFSET    (0x30UL)
//  9: Address of AHB1EN register
<strong class="bold">#define</strong> RCC_AHB1EN_R  (*(<strong class="bold">volatile unsigned int</strong> *)(RCC_BASE +  AHB1EN_R_OFFSET))
//  10: Offset for mode register
<strong class="bold">#define</strong> MODE_R_OFFSET      (0x00UL)
//  11: Address of GPIOA mode register
<strong class="bold">#define</strong> GPIOA_MODE_R  (*(<strong class="bold">volatile unsigned int</strong> *)(GPIOA_BASE + MODE_R_OFFSET))
//  12: Offset for output data register
<strong class="bold">#define</strong> OD_R_OFFSET   (0x14UL)
//  13: Address of GPIOA output data register
<strong class="bold">#define</strong> GPIOA_OD_R    (*(<strong class="bold">volatile unsigned int</strong> *)(GPIOA_BASE +  OD_R_OFFSET))
//  14: Bit mask for enabling GPIOA (bit 0)
<strong class="bold">#define</strong> GPIOAEN       (1U&lt;&lt;0)
//  15: Bit mask for GPIOA pin 5
<strong class="bold">#define</strong> PIN5          (1U&lt;&lt;5)
//  16: Alias for PIN5 representing LED pin
<code>UL</code> suffix at the end of each hexadecimal value as well as the use of keywords such as <code>volatile</code>. Let’s delve into the significance of these in the context of C and C++ programming.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor077"/>The UL suffix</h2>
			<p>When we see a number in the<a id="_idIndexMarker194"/> code ending with <code>UL</code>, it’s more than just a part of the number – it’s a clear instruction to the compiler about the type and size of the number:</p>
			<ul>
				<li><code>U</code> in <code>UL</code> indicates that the number is unsigned. In other words, it’s a positive number with no sign to indicate it could be negative. This designation allows the number to represent a wider range of positive values compared to a signed integer of the same size.</li>
				<li><code>L</code> signifies that the number is a long integer. This is important because the size of a long integer can vary based on the system and the compiler. Typically, a long integer is larger than a regular int – often 32 bits, but sometimes 64 bits on certain systems.</li>
			</ul>
			<p>The <code>UL</code> suffix collectively ensures that these values are treated as unsigned long integers. This is important for firmware development and other forms of low-level programming, where the exact size and “signedness” of an integer can significantly impact program behavior and memory management. Using <code>UL</code> leads to more predictable, platform-independent code, ensuring that the values behave consistently across different compilers and systems.</p>
			<h3>The use of “(*(volatile unsigned int *)”</h3>
			<p>In the context of bare-metal programming, particularly in our current code snippet, we notice that the address of each register is prefixed with <code>"(*(volatile unsigned </code><code>int *)".</code></p>
			<p>Let’s break down what each part of this notation means and why it’s used:</p>
			<ul>
				<li><code>(unsigned int *)</code> expression is a <strong class="bold">type cast</strong>. It tells the compiler <a id="_idIndexMarker195"/>to treat<a id="_idIndexMarker196"/> the subsequent address as a pointer to an unsigned integer. In C and C++, pointers are variables that store the memory address of another variable. In the context of our firmware, this casting means that we are directing the compiler to treat a certain address as the location of an unsigned integer. However, this unsigned integer is not just any number; it corresponds directly to the state of a 32-bit hardware register. Each bit in this 32-bit integer mirrors a specific bit in the register, thereby allowing direct control and monitoring of the hardware’s state through standard programming constructs.</li>
				<li><code>*</code>) in <code>*(unsigned int *)</code> is used to dereference the pointer. Dereferencing<a id="_idIndexMarker197"/> a pointer means accessing the value stored at the memory address the pointer is pointing to. Essentially, it’s not just about knowing where the data is (the address); it’s about actually accessing and using that data.</li>
				<li><code>volatile</code>: The <code>volatile</code> keyword<a id="_idIndexMarker198"/> tells the compiler that the value at the pointer can change at any time, without any action being taken by the code. This is often the case with hardware registers, where the value can change due to hardware events, external inputs, or other aspects of the system outside the program’s control.</li>
			</ul>
			<p>Without <code>volatile</code>, the compiler might optimize out certain reads and writes to these addresses under the assumption that the values don’t change unexpectedly. This is because when a compiler processes code, it looks for ways to make the program run more efficiently. This includes removing redundant operations or simplifying code paths. This process occurs during the compilation of the program before it’s run. If the compiler determines that a variable (including a memory-mapped hardware register) doesn’t change its value, it might optimize the code by eliminating repeated reads from or writes to that variable. For example, if a value is read from a register and then read again later, the compiler might assume the value hasn’t changed and use the previously read value instead of accessing the register a second time. The use of <code>volatile</code> is a directive to tell the compiler not to apply certain optimizations to accesses of the marked variable, maintaining the integrity of operations.</p>
			<p>In our code snippet, we <a id="_idIndexMarker199"/>encounter two additional terms that are very common in bare-metal<a id="_idIndexMarker200"/> programming: <strong class="bold">bit mask</strong> and <strong class="bold">alias</strong>. Let’s take a closer look at each of these concepts to gain a clearer understanding of the roles they play:</p>
			<ul>
				<li><code>AND</code>, <code>OR</code>, <code>XOR</code>) along with the mask to achieve the desired result. For example, a bit mask might be used to turn on a specific LED connected to a microcontroller pin without altering the state of other pins. A bit mask is created by setting the bits we want to manipulate to <code>1</code> while keeping others at <code>0</code>. This mask is then combined with the register value using the appropriate bitwise operation.<p class="list-inset">For example, a <code>0b00000100</code> mask used with <code>OR</code> will set the third bit of the target register.</p></li>
				<li><code>LED_PIN</code> makes the code self-explanatory. We define aliases using preprocessor directives such as <code>#define</code> in C or C++. For example, <code>#define LED_PIN (1U&lt;&lt;5)</code> creates an <code>LED_PIN</code> alias for the bit mask that represents the sixth pin (zero indexing) in a GPIO port ODR.</li>
			</ul>
			<p>Now, let’s analyze the second section of the code.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor078"/>Main Function</h2>
			<p>This <a id="_idIndexMarker203"/>section of our code outlines the primary operations for controlling the LED connected to PA5 of the microcontroller:</p>
			<pre class="source-code">
// Line 17: Start of main function
int main(void)
{
    //  18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;
    GPIOA_MODE_R |= (1U&lt;&lt;10);  //  19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); //  20: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
       // Line 22: Set PA5(LED_PIN) high
       GPIOA_OD_R |= LED_PIN;
    }  //  23: End of infinite loop
}  //  24: End of main function</pre>			<p>Let’s break <a id="_idIndexMarker204"/>down each part of the code for a clearer understanding:</p>
			<ul>
				<li><em class="italic">Line 17</em>: This marks the beginning of the main function. This is the entry point of our program where the execution starts:<pre class="source-code">
// Line 17: Start of main function
int main(void)
{</pre></li>				<li><em class="italic">Line 18</em>: This enables the clock for <code>GPIOA</code>. As we learned earlier, the <code>RCC_AHB1EN_R</code> register controls the clock to the <code>AHB1</code> bus peripherals. The <code>|= GPIOAEN</code> operation sets the bit associated with GPIOA (GPIOAEN) in the <code>RCC_AHB1EN_R</code> register, ensuring that the GPIOA peripheral has the necessary clock enabled for its operations:<pre class="source-code">
    // Line 18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;</pre></li>				<li><em class="italic">Line 19–20</em>: These lines configure <code>PA5</code> as an output pin. Setting bit 10 to <code>1</code> and bit 11 to <code>0</code> in <code>GPIOA_MODE_R</code> configures <code>PA5</code> in general-purpose output mode:<pre class="source-code">
    GPIOA_MODE_R |= (1U&lt;&lt;10);  // Line 19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); // Line 20: Set bit 11 to 0</pre></li>				<li><em class="italic">Line 21–23</em>: These<a id="_idIndexMarker205"/> lines initiate an infinite loop, which is a common practice in embedded systems for continuous operation:<pre class="source-code">
    // Line 21: Start of infinite loop
    while(1)
    {
        // Line 22: Set PA5(LED_PIN) high
        GPIOA_OD_R |= LED_PIN;
    }  // Line 23: End of infinite loop</pre><p class="list-inset">This is what is inside this loop:</p><ul><li><em class="italic">Line 22</em>: This line sets PA5 high. This is achieved by setting the respective bit in <code>GPIOA_OD_R</code>. The <code>|= LED_PIN</code> operation ensures that PA5 outputs a high signal (essentially turning the LED on).</li><li><em class="italic">Line 24</em>: This marks the end of the main function:<pre class="source-code">}  // Line 24: End of main function</pre></li></ul></li>			</ul>
			<p>Now that we have a clear understanding of each line of the code, let’s proceed to enter the entire code into the <code>main.c</code> file. Additionally, for your convenience, this complete source code is available in the GitHub repository for the book. You can find it in the folder titled <code>Chapter2</code>.</p>
			<p>This <a id="_idIndexMarker206"/>is the entire code:</p>
			<pre class="source-code">
//  1: Define base address for peripherals
#define PERIPH_BASE        (0x40000000UL)
//  2: Offset for AHB1 peripheral bus
#define AHB1PERIPH_OFFSET  (0x00020000UL)
//  3: Base address for AHB1 peripherals
#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)
//  4: Offset for GPIOA
#define GPIOA_OFFSET       (0x0000UL)
//  5: Base address for GPIOA
#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)
//  6: Offset for RCC
#define RCC_OFFSET         (0x3800UL)
//  7: Base address for RCC
#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)
//  8: Offset for AHB1EN register
#define AHB1EN_R_OFFSET    (0x30UL)
//  9: Address of AHB1EN register
#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))
//  10: Offset for mode register
#define MODE_R_OFFSET      (0x00UL)
//  11: Address of GPIOA mode register
#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))
//  12: Offset for output data register
#define OD_R_OFFSET   (0x14UL)
//  13: Address of GPIOA output data register
#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))
//  14: Bit mask for enabling GPIOA (bit 0)
#define GPIOAEN       (1U&lt;&lt;0)
//  15: Bit mask for GPIOA pin 5
#define PIN5          (1U&lt;&lt;5)
//  16: Alias for PIN5 representing LED pin
#define LED_PIN       PIN5
//  17: Start of main function
int main(void)
{
    //  18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;
    GPIOA_MODE_R |= (1U&lt;&lt;10);  //  19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); //  20: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
        //  22: Set PA5(LED_PIN) high
        GPIOA_OD_R |= LED_PIN;
    }  //  23: End of infinite loop
}  //  24: End of main function</pre>			<p>To build <a id="_idIndexMarker207"/>the project, first select it by clicking on the project name once, and then initiate the build process by clicking on the <em class="italic">build</em> icon, represented by a hammer symbol, in the IDE.</p>
			<div><div><img src="img/B21914_02_20.jpg" alt="Figure 2.20: The build and run icons" width="1091" height="669"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20: The build and run icons</p>
			<p>Once the build process is complete, the next step involves uploading the program to the microcontroller. To do this, we make sure the project is selected in the IDE, and then initiate the upload by clicking on the <em class="italic">run</em> icon, represented by a play symbol.</p>
			<p>The first time you run the program, the IDE may prompt you to edit or confirm the launch configurations. A dialog box titled <strong class="bold">Edit Configurations</strong> will appear. It’s sufficient to accept the default settings by clicking <strong class="bold">OK</strong>. <em class="italic">Figure 2</em><em class="italic">.21</em> shows the <strong class="bold">Edit Configuration</strong> dialog box.</p>
			<div><div><img src="img/B21914_02_21.jpg" alt="Figure 2.21: The Edit Configuration dialog box" width="771" height="640"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21: The Edit Configuration dialog box</p>
			<p>Following<a id="_idIndexMarker208"/> this confirmation, the IDE will commence the process of uploading your program to the microcontroller. When the upload is complete, you should see the green LED on the development board light up. This indicates that our bare-metal code is functioning as intended and successfully controlling the hardware.</p>
			<p>We have now mastered configuring PA5 to control the LED, starting from the very basics of consulting the documentation for accurate addresses, effectively typecasting these addresses for register access, and creating aliases for specific bits within the registers.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, we delved into the core of bare-metal programming, emphasizing the direct interaction with microcontroller registers. This gave us insight into some of the key registers of our microcontroller and the structure of those registers.</p>
			<p>We began by exploring various firmware development approaches, each offering a distinct level of abstraction. These approaches included the HAL, LL, Bare-Metal C programming, and the assembly language. This exploration helped us understand the trade-offs and applications of each approach in firmware development.</p>
			<p>We spent a significant part of the chapter defining addresses of some peripherals using the official documentation. This step was important in creating addresses for various registers within those peripherals. It involved gathering specific memory addresses, typecasting them for register access, and creating aliases for bits in the registers.</p>
			<p>The chapter culminated in a practical application where we configured PA5 to control the User LED on the development board. This exercise integrated the concepts discussed throughout the chapter, showcasing how theoretical knowledge can be applied in real-world firmware programming.</p>
			<p>In the upcoming chapter, we will delve into the build process. This exploration will allow us to understand the sequential stages that our source code undergoes to become an executable program capable of running on our microcontroller.</p>
		</div>
	</div>
</div>
</body></html>