<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer048">
			<h1 id="_idParaDest-32" class="chapter-number"><a id="_idTextAnchor039"/>2</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor040"/>Constructing Peripheral Registers from Memory Addresses</h1>
			<p><strong class="bold">Bare-metal programming</strong> is all about<a id="_idIndexMarker064"/><a id="_idIndexMarker065"/> working directly with the registers in the microcontroller without going through a library, allowing us to gain a deeper understanding of the microcontroller’s capabilities and limitations. This approach enables us to optimize our firmware for speed and efficiency, which are two very important parameters in embedded systems where resources are <span class="No-Break">often limited.</span></p>
			<p>In this chapter, our journey begins with an exploration of various firmware development methodologies, highlighting the different levels of abstraction each offers. We then proceed to learn how to identify the ports and pins associated with key components on our development board. This step is crucial for establishing a proper interface with the <span class="No-Break">microcontroller’s peripherals.</span></p>
			<p>Next, we delve into defining the addresses of some peripherals using the microcontroller’s official documentation. This will allow us to create the addresses of the various registers in <span class="No-Break">those peripherals.</span></p>
			<p>In the latter sections of the chapter, our focus shifts to practical application. We will use the register addresses that we’ve created to configure PA5 to activate <a id="_idIndexMarker066"/><a id="_idIndexMarker067"/>the user <strong class="bold">light-emitting diode</strong> (<strong class="bold">LED</strong>) of the <span class="No-Break">development board.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><a id="_idTextAnchor041"/>The different types of <span class="No-Break">firmware development</span></li>
				<li><a id="_idTextAnchor042"/>Locating and understanding the development <span class="No-Break">board’s components</span></li>
				<li>Defining and creating registers through <span class="No-Break">documentation insights</span></li>
				<li><a id="_idTextAnchor043"/>Register manipulation – from configuration to running your <span class="No-Break">first firmware</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid foundation in both navigating and programming STM32 microcontrollers at the register level. You will be equipped to write your initial bare-metal firmware, relying solely on information gathered from the documentation<a id="_idIndexMarker068"/><a id="_idIndexMarker069"/> and the <strong class="bold">integrated development </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IDE</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor045"/>The different types of firmware development</h1>
			<p>There are<a id="_idIndexMarker070"/><a id="_idIndexMarker071"/> several ways to develop the firmware for a particular microcontroller depending on the resources provided by the microcontroller’s manufacturer. When it comes to developing firmware for STM32 microcontrollers from <strong class="bold">STMicroelectronics</strong>, we can use<a id="_idIndexMarker072"/><a id="_idIndexMarker073"/> <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Hardware Abstraction Layer (HAL)</strong>: This is a <a id="_idIndexMarker074"/><a id="_idIndexMarker075"/>library provided by STMicroelectronics. It simplifies the process by offering high-level APIs for configuring every aspect of the microcontroller. What is great about HAL is its portability. We can write code for one STM32 microcontroller, and easily adapt it for another, thanks to the uniformity of <span class="No-Break">their APIs.</span></li>
				<li><strong class="bold">Low Layer (LL)</strong>: Also from<a id="_idIndexMarker076"/><a id="_idIndexMarker077"/> STMicroelectronics, the LL library is a leaner alternative to HAL, offering a faster, more expert-oriented approach that’s closer to <span class="No-Break">the hardware.</span></li>
				<li><strong class="bold"><a id="_idTextAnchor046"/>Bare-Metal C programming</strong>: With this<a id="_idIndexMarker078"/><a id="_idIndexMarker079"/> approach, we dive right into the hardware, accessing the microcontroller’s registers directly using the C language. It’s more involved but offers a deeper understanding of the <span class="No-Break">microcontroller’s workings.</span></li>
				<li><strong class="bold">Assembly language</strong>: This is similar<a id="_idIndexMarker080"/><a id="_idIndexMarker081"/> to Bare-Metal C, but instead of C, we use assembly language to interact directly with the <span class="No-Break">microcontroller’s registers.</span></li>
			</ul>
			<p>Let’s compare the four firmware development methods we’ve discussed: HAL, LL, Bare-Metal C, and assembly language. Each method has its unique style and level of abstraction, impacting how we interact with the microcontroller’s hardware. We will use the example of configuring a <strong class="bold">general-purpose input/output</strong> (<strong class="bold">GPIO</strong>) pin as an output<a id="_idIndexMarker082"/><a id="_idIndexMarker083"/> to illustrate <span class="No-Break">these differences.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor047"/>HAL</h2>
			<p><a id="_idTextAnchor048"/>The following<a id="_idIndexMarker084"/><a id="_idIndexMarker085"/> code snippet demonstrates how to initialize GPIOA pin 5 as an output <span class="No-Break">using HAL:</span></p>
			<pre class="source-code">
#include "stm32f4xx_hal.h"
GPIO_InitTypeDef GPIO_InitStruct = {0};
// Enable the GPIOA Clock
__HAL_RCC_GPIOA_CLK_ENABLE();
// Configure the GPIO pin
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</pre>			<p>Let’s analyze <span class="No-Break">the snippet:</span></p>
			<ul>
				<li><strong class="source-inline">#include "stm32f4xx_hal.h":</strong> This line includes the HAL library specific to the STM32F4 series, providing access to the HAL functions and <span class="No-Break">data structures</span></li>
				<li><strong class="source-inline">GPIO_InitTypeDef GPIO_InitStruct = {0}:</strong> Here, we declare and initialize an instance of the <strong class="source-inline">GPIO_InitTypeDef</strong> structure, which is used to configure the GPIO <span class="No-Break">pin properties</span></li>
				<li><strong class="source-inline">__HAL_RCC_GPIOA_CLK_ENABLE()</strong>: This macro call enables the clock for GPIO port A, ensuring that the GPIO peripheral is powered and <span class="No-Break">can function</span></li>
				<li><strong class="source-inline">GPIO_InitStruct.Pin = GPIO_PIN_5:</strong> This line sets the pin to be configured, in this case, pin 5 of <span class="No-Break">port A</span></li>
				<li><strong class="source-inline">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP:</strong> Over here, we configure the pin as an <span class="No-Break">output pin</span></li>
				<li><strong class="source-inline">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct):</strong> Finally, we initialize the GPIO pin (PA5) with the configuration settings specified <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">GPIO_InitStruct</strong></span></li>
			</ul>
			<p><a id="_idTextAnchor049"/>This snippet shows the ease and readability of the HAL approach in performing common hardware interfacing tasks. We can summarize the benefits<a id="_idIndexMarker086"/><a id="_idIndexMarker087"/> and drawbacks<a id="_idIndexMarker088"/><a id="_idIndexMarker089"/> of the HAL approach <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Level of </strong><span class="No-Break"><strong class="bold">abstraction</strong></span><span class="No-Break">: High</span></li>
				<li><strong class="bold">Ease of use</strong>: Easier for beginners due to its <span class="No-Break">high-level abstraction</span></li>
				<li><strong class="bold">Code verbosity</strong>: More verbose, with several lines of code required for <span class="No-Break">simple tasks</span></li>
				<li><strong class="bold">Portability</strong>: Excellent across different <span class="No-Break">STM32 devices</span></li>
				<li><strong class="bold">Performance</strong>: Slightly slower due to additional <span class="No-Break">abstraction layers</span></li>
			</ul>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor050"/>LL</h2>
			<p>This is how we initialize GPIOA<a id="_idIndexMarker090"/><a id="_idIndexMarker091"/> pin 5 as an output pin using the <span class="No-Break">LL library:</span></p>
			<pre class="source-code">
#include "stm32f4xx_ll_bus.h"
#include "stm32f4xx_ll_gpio.h"
// Enable the GPIOA Clock
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
// Configure the GPIO pin
LL_GPIO_SetPinMode(GPIOA,LL_GPIO_PIN_5,LL_GPIO_MODE_OUTPUT);</pre>			<p>Let’s break it down, line <span class="No-Break">by line:</span></p>
			<ul>
				<li><strong class="source-inline">#include "stm32f4xx_ll_bus.h"</strong> and <strong class="source-inline">#include "stm32f4xx_ll_gpio.h"</strong> include the necessary LL library files for handling the bus system and GPIO <span class="No-Break">functionality, respectively</span></li>
				<li><strong class="source-inline">LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA):</strong> This function call enables the clock for GPIO <span class="No-Break">port A</span></li>
				<li><strong class="source-inline">LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT):</strong> Finally, we set the mode of GPIOA pin 5 to <span class="No-Break">output mode</span></li>
			</ul>
			<p>The LL library<a id="_idIndexMarker092"/><a id="_idIndexMarker093"/> provides a more direct and lower-level approach to hardware interaction compared to HAL. This is often preferred in scenarios where finer control over hardware and performance <span class="No-Break">is required.</span></p>
			<p>The benefits<a id="_idIndexMarker094"/><a id="_idIndexMarker095"/> and drawbacks<a id="_idIndexMarker096"/><a id="_idIndexMarker097"/> of the LL approach are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Level of </strong><span class="No-Break"><strong class="bold">abstraction</strong></span><span class="No-Break">: Medium</span></li>
				<li><strong class="bold">Ease of use</strong>: Moderate, with a balance between abstraction and <span class="No-Break">direct control</span></li>
				<li><strong class="bold">Code verbosity</strong>: Less verbose than HAL, offering a more straightforward approach to <span class="No-Break">hardware interaction</span></li>
				<li><strong class="bold">Portability</strong>: Good, but slightly less <span class="No-Break">than HAL</span></li>
				<li><strong class="bold">Performance</strong>: Faster than HAL, as it’s closer to <span class="No-Break">the hardware</span></li>
			</ul>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor051"/>Bare-Metal C</h2>
			<p>Let’s see how to accomplish<a id="_idIndexMarker098"/><a id="_idIndexMarker099"/> the same task using the Bare-Metal <span class="No-Break">C approach:</span></p>
			<pre class="source-code">
#define GPIOA_MODER (*(volatile unsigned long *)(GPIOA_BASE + 0x00))
#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))
// Enable clock for GPIOA
RCC_AHB1ENR |= (1 &lt;&lt; 0);
// Set PA5 to output mode
GPIOA_MODER |= (1 &lt;&lt; 10); // Set bit 10 (MODER5[1])</pre>			<p>Let’s break down the bare-metal <span class="No-Break">c snippet:</span></p>
			<ul>
				<li><strong class="source-inline">#define GPIOA_MODER (*(volatile unsigned long *) (GPIOA_BASE + 0x00))</strong> and <strong class="source-inline">#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))</strong> define pointers to specific registers within the microcontroller’s memory. <strong class="source-inline">GPIOA_MODER</strong> points to the GPIO port A mode register, and <strong class="source-inline">RCC_AHB1ENR</strong> points to the <strong class="bold">reset and clock control</strong> (<strong class="bold">RCC</strong>) AHB1 peripheral clock <strong class="bold">enable register</strong> (<strong class="bold">ER</strong>). The use of the volatile keyword ensures<a id="_idIndexMarker100"/><a id="_idIndexMarker101"/> that the compiler treats<a id="_idIndexMarker102"/><a id="_idIndexMarker103"/> these as memory-mapped registers, preventing <span class="No-Break">optimization-related issues.</span></li>
				<li><strong class="source-inline">RCC_AHB1ENR |= (1 &lt;&lt; 0)</strong>: This line of code enables the clock for GPIOA. It does this by setting the first bit (bit 0) of the <strong class="source-inline">RCC_AHB1ENR</strong> register. The bitwise <strong class="source-inline">OR</strong> assignment (<strong class="source-inline">|=</strong>) ensures that only the specified bit is changed without altering other bits in <span class="No-Break">the register.</span></li>
				<li><strong class="source-inline">GPIOA_MODER |= (1 &lt;&lt; 10)</strong>: This line sets PA5 to output mode. In the GPIO port mode register (<strong class="source-inline">GPIOA_MODER</strong>), each pin is controlled by two bits. For PA5, these are bits 10 and 11 (<strong class="source-inline">MODER5[1:0]</strong>). The code sets bit 10 to <strong class="source-inline">1</strong> (and leaves bit 11 as <strong class="source-inline">0</strong>, assuming it was already <strong class="source-inline">0</strong>), configuring PA5 as<a id="_idIndexMarker104"/><a id="_idIndexMarker105"/> a general-purpose <span class="No-Break">output mode.</span></li>
			</ul>
			<p>With this approach, we can observe the granularity and direct control provided. By directly manipulating the microcontroller’s registers, it offers very high efficiency <span class="No-Break">and performance:</span></p>
			<ul>
				<li><strong class="bold">Level of </strong><span class="No-Break"><strong class="bold">abstraction</strong></span><span class="No-Break">: Low</span></li>
				<li><strong class="bold">Ease of use</strong>: Challenging for beginners, as it requires in-depth <span class="No-Break">hardware knowledge</span></li>
				<li><strong class="bold">Code verbosity</strong>: Less <span class="No-Break">verbose, direct</span></li>
				<li><strong class="bold">Portability</strong>: Limited, as the code is often specific to a particular <span class="No-Break">hardware setup</span></li>
				<li><strong class="bold">Performance</strong>: Very high, as it allows for direct and optimized <span class="No-Break">hardware manipulation</span></li>
			</ul>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor052"/>Assembly language</h2>
			<p>Finally, let’s analyze the assembly<a id="_idIndexMarker106"/><a id="_idIndexMarker107"/> language implementation for configuring PA5 as an <span class="No-Break">output pin:</span></p>
			<pre class="source-code">
EQU GPIOA_MODER, 0x40020000
EQU RCC_AHB1ENR, 0x40023800
; Enable clock for GPIOA
LDR R0, =RCC_AHB1ENR
LDR R1, [R0]
ORR R1, R1, #(1 &lt;&lt; 0)
STR R1, [R0]
; Set PA5 as output
LDR R0, =GPIOA_MODER
LDR R1, [R0]
ORR R1, R1, #(1 &lt;&lt; 10)
STR R1, [R0]</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">EQU GPIOA_MODER</strong>, <strong class="source-inline">0x40020000</strong> and <strong class="source-inline">EQU RCC_AHB1ENR</strong>,<strong class="source-inline"> 0x40023800</strong> define constants for the memory addresses of the GPIOA mode register (<strong class="source-inline">GPIOA_MODER</strong>) and the RCC AHB1 peripheral clock ER (<strong class="source-inline">RCC_AHB1ENR</strong>). <strong class="source-inline">'EQU'</strong> is used in assembly to equate a label to a value <span class="No-Break">or address.</span></li>
			</ul>
			<p>The rest of the assembly instructions<a id="_idIndexMarker108"/><a id="_idIndexMarker109"/> perform two <span class="No-Break">main tasks:</span></p>
			<ul>
				<li>Enable the clock <span class="No-Break">for GPIOA:</span><ul><li><strong class="source-inline">LDR R0, =RCC_AHB1ENR</strong>: Load the address of the <strong class="source-inline">RCC_AHB1ENR</strong> register into the <span class="No-Break"><strong class="source-inline">R0</strong></span><span class="No-Break"> register</span></li><li><strong class="source-inline">LDR R1, [R0]</strong>: Load the value of the <strong class="source-inline">RCC_AHB1ENR</strong> register into the <span class="No-Break"><strong class="source-inline">R1</strong></span><span class="No-Break"> register</span></li><li><strong class="source-inline">ORR R1, R1, #(1 &lt;&lt; 0)</strong>: Perform a bitwise <strong class="source-inline">OR</strong> operation to set bit<strong class="source-inline"> </strong>0 of <strong class="source-inline">R1</strong>, turning on the clock <span class="No-Break">for GPIOA</span></li><li><strong class="source-inline">STR R1, [R0]</strong>: Store the updated value back into the <span class="No-Break"><strong class="source-inline">RCC_AHB1ENR</strong></span><span class="No-Break"> register</span></li></ul></li>
				<li>Set PA5 <span class="No-Break">as output:</span><ul><li><strong class="source-inline">LDR R0, =GPIOA_MODER</strong>: Load the address of the <strong class="source-inline">GPIOA_MODER</strong> register <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">R0</strong></span></li><li><strong class="source-inline">LDR R1, [R0]</strong>: Load the current value of the <strong class="source-inline">GPIOA_MODER</strong> register <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">R1</strong></span></li><li><strong class="source-inline">ORR R1, R1, #(1 &lt;&lt; 10)</strong>: Use a bitwise <strong class="source-inline">OR</strong> operation to set bit 10 of <strong class="source-inline">R1</strong>, configuring PA5 as <span class="No-Break">an output</span></li><li><strong class="source-inline">STR R1, [R0]</strong>: Store the updated value back into the <span class="No-Break"><strong class="source-inline">GPIOA_MODER</strong></span><span class="No-Break"> register</span></li></ul></li>
			</ul>
			<p>The assembly language approach allows for extremely detailed and direct control over the microcontroller. We often use this in projects where high performance is crucial, and every aspect of the hardware needs to be <span class="No-Break">precisely managed.</span></p>
			<p>The assembly language approach offers us <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Level of </strong><span class="No-Break"><strong class="bold">abstraction</strong></span><span class="No-Break">: Lowest</span></li>
				<li><strong class="bold">Ease of use</strong>: Most challenging, requiring a thorough understanding of the <span class="No-Break">microcontroller’s architecture</span></li>
				<li><strong class="bold">Code verbosity</strong>: Can be verbose for complex tasks, due to <span class="No-Break">low-level nature</span></li>
				<li><strong class="bold">Portability</strong>: Very limited, as it is highly specific to the <span class="No-Break">microcontroller’s architecture</span></li>
				<li><strong class="bold">Performance</strong>: Highest, as it allows for the most optimized and direct <span class="No-Break">control possible</span></li>
			</ul>
			<p><a id="_idTextAnchor053"/>The following diagram shows<a id="_idIndexMarker110"/><a id="_idIndexMarker111"/> each method and its closeness to the <span class="No-Break">microcontroller’s architecture:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21914_02_01.jpg" alt="Figure 2.1: Firmware development methods, arranged in order of proximity  to the microcontroller’s architecture" width="610" height="301"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Firmware development methods, arranged in order of proximity to the microcontroller’s architecture</p>
			<p>Now that we have explored the diverse approaches to firmware development for STM32 microcontrollers, we are ready to delve into the realm of bare-metal <span class="No-Break">C programming.</span></p>
			<p>We will begin our exploration by understanding how the main components of our development board are connected to specific pins of the onboard microcontroller. This initial step is crucial for gaining insight into the hardware layout and preparing us for detailed <span class="No-Break">programming tasks.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor054"/>Locating and understanding the development 
board’s components</h1>
			<p>In this section, our focus is to pinpoint the specific ports and pins on the microcontroller to which the user LED, user push button, berg pins, and Arduino-compatible headers are connected on the development board. Understanding these connections is crucial for our programming tasks. To accurately identify these connections, we will consult the <em class="italic">NUCLEO-F411 </em><span class="No-Break"><em class="italic">User Manual</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21914_02_02.jpg" alt="Figure 2.2: Development board showing components of interest" width="860" height="596"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Development board showing components of interest</p>
			<p>No<a id="_idTextAnchor055"/>w, let’s locate the microcontroller pin connected to the User LED on the <span class="No-Break">development board.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor056"/>Locating the LED connection</h2>
			<p>Ou<a id="_idTextAnchor057"/>r first step is to navigate<a id="_idIndexMarker112"/><a id="_idIndexMarker113"/> through the table of contents to find the section dedicated to LEDs. This can be done quickly by locating <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.3</em> in the manual, which shows the page number for the <em class="italic">LEDs</em> section and allows us to jump directly <span class="No-Break">to it.</span></p>
			<p>Click on the page number to jump to the <span class="No-Break">LEDs section.</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21914_02_03.jpg" alt="Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents showing the page number of the LEDs section" width="1004" height="192"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents showing the page number of the LEDs section</p>
			<p>In the <em class="italic">LEDs</em> section, we find that the User LED, labeled <strong class="bold">User LD2</strong>, is linked to the ARDUINO® signal <strong class="bold">D13</strong>. This corresponds to either pin PA5 or PB13, depending on the specific STM32 target of <span class="No-Break">our board.</span></p>
			<p>It’s important to note the dual naming convention used in the User Manual due to the board’s compatibility with the Arduino IDE. In the Arduino naming scheme, pins are categorized as either analog (preceded by “A”) or digital (preceded by “D”). For example, digital pin 3 is denoted as D3. Conversely, the standard STM32 convention starts with a “P,” followed by a letter indicating the port and then the pin number within that port, such as PA5 for the 5th pin of <span class="No-Break">port A.</span></p>
			<p>To determine whether pin D13 of our development board is PA5 or PB13 of the onboard microcontroller, we refer to <em class="italic">Tables 11 to 23</em> in the manual. These tables map the ARDUINO® connector pins to standard STM32 pins for each development board covered in the document. Specifically, we look at <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.5</em> showing <em class="italic">Table 16</em>, which pertains to our development <span class="No-Break">board model.</span></p>
			<p>Navigate to <em class="italic">Table 11</em> by clicking on it as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>. This action will take you to the initial table in the sequence of tables. Then, scroll down until you get to <span class="No-Break"><em class="italic">Table 16</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21914_02_04.jpg" alt="Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the two possible connections of the User LED" width="964" height="288"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the two possible connections of the User LED</p>
			<p>Upon reviewing <em class="italic">Table 16</em>, we find that D13 indeed<a id="_idIndexMarker114"/><a id="_idIndexMarker115"/> corresponds to PA5. This indicates that the User LED on our NUCLEO-F411RE development board is connected to pin PA5 of the <span class="No-Break">onboard microcontroller.</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21914_02_05.jpg" alt="Figure 2.5: Table 16 shows that D13 corresponds to PA5" width="1421" height="185"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Table 16 shows that D13 corresponds to PA5</p>
			<p>Another useful component found on the development board is the User Push button. Let’s find the pin connection of <span class="No-Break">this component.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor058"/>Locating the User Push button</h2>
			<p>The User Push button on the development<a id="_idIndexMarker116"/><a id="_idIndexMarker117"/> board is an important component for input handling in many embedded experiments, and understanding its connection to the microcontroller is crucial for effective programming <span class="No-Break">and interaction.</span></p>
			<p>To locate the connection details of the User Push button on our board, we will navigate through the table of contents to find the section dedicated <span class="No-Break">to </span><span class="No-Break"><em class="italic">Push-buttons</em></span><span class="No-Break">.</span></p>
			<p>This can be done quickly by locating <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.6</em> in the manual, which shows the page number for the <em class="italic">Push-buttons</em> section and allows us to jump directly to it by clicking on the <span class="No-Break">page number.</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B21914_02_06.jpg" alt="Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number for the Push-buttons section" width="1398" height="202"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number for the Push-buttons section</p>
			<p>Upon navigating to the <em class="italic">Push-buttons</em> section of the<a id="_idIndexMarker118"/><a id="_idIndexMarker119"/> manual, we locate the relevant information about our User Push-button, identified as <strong class="bold">B1 User</strong>. The manual tells us that this button is connected to pin <strong class="bold">PC13</strong> of the <span class="No-Break">onboard microcontroller.</span></p>
			<h2 id="_idParaDest-43">Locati<a id="_idTextAnchor059"/>ng the berg pins and Arduino-compatible headers</h2>
			<p>In the <em class="italic">LEDs</em> sections, we learned<a id="_idIndexMarker120"/><a id="_idIndexMarker121"/> that our NUCLEO-F411 development board features two primary naming systems for its pins: the Arduino naming system and the standard STM32 naming system. While bare-metal programming primarily utilizes<a id="_idIndexMarker122"/><a id="_idIndexMarker123"/> the standard STM32 naming, the pins on the board itself are labeled according to the Arduino system. It is important to know the actual port names and pin numbers of these exposed pins so that we can properly connect and program external components such as sensors <span class="No-Break">and actuators.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.7</em> shows our NUCLEO-F411 development board with the columns of berg <span class="No-Break">pins highlighted.</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B21914_02_07.jpg" alt="Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted" width="823" height="524"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted</p>
			<p>The Arduino header pins of the development board are located<a id="_idIndexMarker124"/><a id="_idIndexMarker125"/> at the sides of the berg pins columns. This is highlighted in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B21914_02_08.jpg" alt="Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted" width="943" height="520"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted</p>
			<p>Let’s start by finding the microcontroller pin connections of the Arduino <span class="No-Break">header pins.</span></p>
			<h3>Arduino-compatible headers</h3>
			<p>To identify the standard<a id="_idIndexMarker126"/><a id="_idIndexMarker127"/> STM32 names for the pins on the Arduino header, we navigate to the section titled <em class="italic">ARDUINO® connectors</em> using the table of contents. This directs us to <em class="italic">Table 11</em>, which provides the mappings of Arduino pins to STM32 pins. For our specific NUCLEO-F411 development board, we focus on <em class="italic">Table 16</em>, which offers the relevant mapping for <span class="No-Break">our model.</span></p>
			<p>Next, let’s locate the connections of the <span class="No-Break">berg pins.</span></p>
			<h3>The berg pins</h3>
			<p>Similar to our approach with other<a id="_idIndexMarker128"/><a id="_idIndexMarker129"/> components, to find details about the berg pins, we again consult the table of contents in the manual and locate the section called <em class="italic">Extension connectors</em>. This section includes figures illustrating the pinouts for various NUCLEO boards. We then scroll to find the pinout corresponding to our specific NUCLEO model. Here, the pinout of our development board is presented in the standard STM32 <span class="No-Break">naming system.</span></p>
			<p>Over here, we also discover that the manual<a id="_idIndexMarker130"/><a id="_idIndexMarker131"/> refers to the columns of male header berg pins as the ST morpho connector. This means that whenever the <em class="italic">morpho connector</em> term is used, it is referring to these male header <span class="No-Break">berg pins.</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B21914_02_09.jpg" alt="Figure 2.9: Pinout of the NUCLEO-F411 development board" width="779" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Pinout of the NUCLEO-F411 development board</p>
			<p>In this section, we learned that NUCLEO development boards use two naming systems. Firstly, the Arduino naming system, which is visibly marked on the board, and secondly, the standard STM32 naming system, detailed in the documentation. We discovered that the standard STM32 naming system is particularly relevant for our purposes, as it directly correlates to the pin names of the <span class="No-Break">onboard microcontroller.</span></p>
			<p>The next section will guide us on how to access and manipulate the relevant memory locations of the onboard microcontroller. Our focus will be on configuring pin PA5 as an output pin. This will allow us to control the LED connected <span class="No-Break">to PA5.</span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor060"/>Defining and creating registers through 
documentation insights</h1>
			<p>In the previous section, we established that the User LED is connected to pin PA5. This means that it is linked to pin number 5 on GPIO PORTA. In other words, to get to the LED, we have to go through PORTA and then locate pin number 5 of <span class="No-Break">that port.</span></p>
			<p>As illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, the microcontroller has exposed pins on all four sides. These pins are organized into distinct groups known<a id="_idIndexMarker132"/><a id="_idIndexMarker133"/> as <strong class="bold">ports</strong>. For instance, pins in PORTA are denoted with the <em class="italic">PA</em> prefix, while those in PORTB start with <em class="italic">PB</em>, and so forth. This systematic arrangement allows us to easily identify and access specific pins for programming and hardware <span class="No-Break">interfacing tasks.</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B21914_02_10.jpg" alt="Figure 2.10: STM32F411 pinout" width="793" height="682"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: STM32F411 pinout</p>
			<p>In the next section, we will go through the steps to locate the precise address of <span class="No-Break">GPIO PORTA.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor061"/>Locating GPIO PORTA</h2>
			<p>To effectively interact with any part of our<a id="_idIndexMarker134"/><a id="_idIndexMarker135"/> microcontroller, it’s essential to know the memory address of that specific part. Our next step is to explore the memory map of the microcontroller. By doing so, we can locate the address of GPIO PORTA in a <span class="No-Break">step-by-step manner.</span></p>
			<p>Since our focus is now on the onboard microcontroller rather than the development board, we need to refer to the microcontroller’s datasheet, specifically the <span class="No-Break"><strong class="source-inline">stm32f411re.pdf</strong></span><span class="No-Break"> document.</span></p>
			<p>Let’s start by navigating to the table of contents of the document. There, we’ll find a section entitled <em class="italic">Memory Mapping</em>. Click on the corresponding page number to jump to <span class="No-Break">that section.</span></p>
			<p>Over here, we find a comprehensive diagram that illustrates the entire memory map of the microcontroller. A relevant excerpt of this diagram is presented in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.11</em>, which shows the overall <span class="No-Break">memory layout.</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21914_02_11.jpg" alt="Figure 2.11: Memory map" width="237" height="604"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: Memory map</p>
			<p>The memory map<a id="_idIndexMarker136"/><a id="_idIndexMarker137"/> shows that everything inside the microcontroller is addressed from <strong class="source-inline">0x0000 0000</strong> to <strong class="source-inline">0xFFFF FFFF</strong>. We’re interested in the part about peripherals because that’s where we <span class="No-Break">find GPIOA.</span></p>
			<p>In the context of microcontrollers, a peripheral refers to a hardware component that is not part of the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) but is connected<a id="_idIndexMarker138"/><a id="_idIndexMarker139"/> to the microcontroller to extend its capabilities. Peripherals perform specific functions and can include a wide range of components, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">GPIO ports</strong>: These are used for interfacing<a id="_idIndexMarker140"/><a id="_idIndexMarker141"/> with external devices such as LEDs, switches, and sensors. They can be programmed to either receive input signals or send <span class="No-Break">output signals.</span></li>
				<li><strong class="bold">Communication interfaces</strong>: These include<a id="_idIndexMarker142"/><a id="_idIndexMarker143"/> serial communication<a id="_idIndexMarker144"/><a id="_idIndexMarker145"/> interfaces such as a <strong class="bold">universal asynchronous receiver-transmitter</strong> (<strong class="bold">UART</strong>), <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>), and <strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>), which enable<a id="_idIndexMarker146"/><a id="_idIndexMarker147"/> the microcontroller to communicate with other devices, sensors, or even <span class="No-Break">other</span><span class="No-Break"><a id="_idIndexMarker148"/><a id="_idIndexMarker149"/></span><span class="No-Break"> microcontrollers.</span></li>
				<li><strong class="bold">Timers and counters</strong>: Timers are used<a id="_idIndexMarker150"/><a id="_idIndexMarker151"/> for measuring time intervals or generating time-based events, while counters<a id="_idIndexMarker152"/><a id="_idIndexMarker153"/> can be used to count events <span class="No-Break">or pulses.</span></li>
				<li><strong class="bold">Analog-to-digital converters (ADCs)</strong>: ADCs convert analog<a id="_idIndexMarker154"/><a id="_idIndexMarker155"/> signals (such as those from a temperature sensor) into digital values that the microcontroller <span class="No-Break">can process.</span></li>
			</ul>
			<p>The peripherals mentioned here represent a selection of the common types found in microcontrollers. As we progress through subsequent chapters, we will delve deeper into these and <span class="No-Break">other peripherals.</span></p>
			<p><a id="_idTextAnchor062"/>In <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.11</em>, the memory map shows that the address range for all the microcontroller’s peripherals spans from <strong class="source-inline">0x40000000</strong> to <strong class="source-inline">0x5FFFFFFF</strong>. This means that GPIO PORTA’s address lies within this <span class="No-Break">specified range.</span></p>
			<p class="callout-heading">Peripherals base address = 0x40000000</p>
			<p class="callout"><a id="_idTextAnchor063"/>Let’s note down the start of the peripheral address, which we will refer to as <strong class="source-inline">PERIPH_BASE</strong>, indicating the base address for the peripherals. We will need this for calculating the address of GPIO PORTA. <strong class="source-inline">PERIPH_BASE</strong> = <span class="No-Break"><strong class="source-inline">0x40000000</strong></span><span class="No-Break">.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.12</em> shows a zoomed-in view of the peripherals<a id="_idIndexMarker156"/><a id="_idIndexMarker157"/><a id="_idIndexMarker158"/> section in the memory map. Here, we observe that the peripheral memory is segmented into five distinct blocks: APB1, APB2, AHB1, AHB2, and the Cortex-M internal peripherals block, which is located at <span class="No-Break">the top.</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B21914_02_12.jpg" alt="Figure 2.12: Peripherals memory map" width="500" height="1390"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Peripherals memory map</p>
			<p>These blocks, except for<a id="_idIndexMarker159"/><a id="_idIndexMarker160"/> the Cortex-M internal peripherals, are named after<a id="_idIndexMarker161"/><a id="_idIndexMarker162"/> the bus systems they interface with – namely, the <strong class="bold">Advanced Peripheral Bus</strong> (<strong class="bold">APB</strong>) and the <strong class="bold">Advanced High-Performance </strong><span class="No-Break"><strong class="bold">Bus</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AHB</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">APB1 and APB2</strong>: These buses cater to lower bandwidth peripherals, providing a more efficient means of communication for devices that do not require high-speed <span class="No-Break">data transfer.</span></li>
				<li><strong class="bold">AHB1 and AHB2</strong>: These are designed for high-speed data transfer and are used to connect high-bandwidth peripherals. They enable faster and more efficient data, control, and <span class="No-Break">address communication.</span></li>
			</ul>
			<p>On <em class="italic">pages 54 to 56</em> of the datasheet, we find a table delineating the boundary addresses for each bus and the associated peripherals. A segment of this table is shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.13</em>, where we find that GPIOA is allocated a boundary address from <strong class="source-inline">0x40020000</strong> to <strong class="source-inline">0x4002 03FF</strong> and is connected to the AHB1 bus. Therefore, this indicates that the addresses for all registers related to GPIO PORTA are encompassed within this <span class="No-Break">address range.</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21914_02_13.jpg" alt="Figure 2.13: Boundary address and Bus of GPIOA" width="927" height="721"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: Boundary address and Bus of GPIOA</p>
			<p class="callout-heading">GP<a id="_idTextAnchor064"/>IOA base address = PERIPH_BASE + 0x20000 = 0x40020000</p>
			<p class="callout">From the table, we find that the starting address for the GPIOA boundary is <strong class="source-inline">0x40020000</strong>. This reveals that adding an offset of <strong class="source-inline">0x20000</strong> to the <strong class="source-inline">PERIPH_BASE</strong> address (which is 0x40000000) results in the base address of GPIOA, calculated as <strong class="source-inline">0x40000000 + 0x20000 = 0x40020000</strong>. The term “offset value” refers to the value added to derive a specific address from a base address. In this case, the offset value for GPIOA from the <strong class="source-inline">PERIPH_BASE</strong> address <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x20000</strong></span><span class="No-Break">.</span></p>
			<p>Understanding the concept of offset values is crucial for accurately calculating desired addresses in microcontroller programming. This understanding enables precise navigation and manipulation within the system’s <span class="No-Break">memory map.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor065"/>Clock gating</h2>
			<p>Having identified the exact address of GPIOA, our next step is to enable clock access to it before configuring its registers. This step is necessary because, by default, the clock to all unused peripherals is disabled to <span class="No-Break">conserve power.</span></p>
			<p>Modern microcontrollers use a power-saving technique<a id="_idIndexMarker163"/><a id="_idIndexMarker164"/> known as <strong class="bold">clock gating</strong>. In simple terms, clock gating involves selectively turning off the clock signal to certain parts of the microcontroller when they’re not in use. The clock signal is an essential part of microcontroller operations, as it drives the sequential logic by providing a regular pulse that synchronizes the activities of the microcontroller’s circuits. However, when a particular part of the microcontroller, such as a peripheral, is not actively being used, the clock signal to that part is disabled. This disabling prevents unnecessary power consumption by idle circuits. Therefore, before using any peripheral, it’s required to first enable clock access <span class="No-Break">to it.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.14</em>, there’s a peripheral listed as RCC, which has a boundary address range from <strong class="source-inline">0x40023800</strong> to <strong class="source-inline">0x40023BFF</strong>. The functions of this peripheral include enabling and disabling clock access to <span class="No-Break">other peripherals.</span></p>
			<p class="callout-heading">RC<a id="_idTextAnchor066"/>C base Address = PERIPH_BASE + 0x23800 = 0x40023800</p>
			<p class="callout">From the boundary address information, we can see that the <strong class="source-inline">RCC _Base</strong> address is obtained by adding an offset of <strong class="source-inline">0x23800</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PERIPH_BASE</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21914_02_14.jpg" alt="" role="presentation" width="809" height="629"/>
				</div>
			</div>
			<p class="callout"><span class="No-Break">Figure 2</span>.14: Boundary address and Bus <span class="No-Break">of RCC</span></p>
			<p>Having successfully determined the base addresses<a id="_idIndexMarker165"/><a id="_idIndexMarker166"/> for the two essential peripherals needed to configure GPIOA pin 5 (which controls the connected LED), our next step involves using these base addresses to derive the specific register addresses necessary for setting the pin as an output and ultimately activating <span class="No-Break">the LED.</span></p>
			<p>To locate the detailed information about these registers, we will refer to the reference manual (<em class="italic">RM0383</em>). This document provides comprehensive insights into all registers and <span class="No-Break">their configurations.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor067"/>The AHB1 ER</h2>
			<p>Our reference <a id="_idIndexMarker167"/>manual, RM0383, is a <a id="_idIndexMarker168"/>comprehensive document spanning over 800 pages, and some STM32 reference manuals even exceed 1,500 pages. The objective is not to read the entire manual cover to cover, but rather to develop the skill to efficiently locate specific information as needed. Previously, we established that GPIOA is connected to the AHB1 bus. We also learned that activating this peripheral requires enabling clock access through the <span class="No-Break">RCC peripheral.</span></p>
			<p>The RCC peripheral in our microcontroller includes a specific register dedicated to enabling the clock for each bus. In STM32 microcontrollers, the naming of registers follows a straightforward pattern: <em class="italic">peripheral acronym + underscore + register acronym</em>. For example, the register responsible for controlling clock access to the AHB1 bus is <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">RCC_AHB1ENR</strong></span><span class="No-Break">.</span></p>
			<p>Let’s explain this a <span class="No-Break">bit more:</span></p>
			<ul>
				<li><strong class="bold">RCC</strong> stands<a id="_idIndexMarker169"/> for <strong class="bold">Reset and </strong><span class="No-Break"><strong class="bold">Clock Control</strong></span></li>
				<li><strong class="bold">AHB1</strong> stands<a id="_idIndexMarker170"/> for <strong class="bold">Advanced High-Performance </strong><span class="No-Break"><strong class="bold">Bus 1</strong></span></li>
				<li><strong class="bold">ENR</strong> stands <a id="_idIndexMarker171"/>for <span class="No-Break"><strong class="bold">Enable Register</strong></span></li>
			</ul>
			<p>This systematic naming convention simplifies the process of identifying and accessing the <span class="No-Break">appropriate registers.</span></p>
			<p>To find the<a id="_idIndexMarker172"/> information about the <strong class="source-inline">RCC_AHB1ENR</strong> register, we begin by opening the reference manual. Next, we navigate to the table of contents and search for the section titled <em class="italic">RCC AHB1 Peripheral Clock Enable Register (RCC_AHB1ENR)</em>. Once located, we click on the page number provided alongside this section title to directly jump to the relevant part of <span class="No-Break">the document.</span></p>
			<p>Let’s begin by examining the details presented at the top of the page, as illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.15</em>. This section provides key information about the register, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Register name</strong>: The<a id="_idIndexMarker173"/> full name of the register is provided along with its abbreviation, namely <strong class="bold">RCC AHB1 Peripheral Clock Enable </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RCC_AHB1ENR</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Address offset</strong>: The offset from the base address is indicated <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">0x30</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Reset value</strong>: This is specified as <strong class="source-inline">0x00000000</strong>, indicating the value the register holds upon reset. In other words, the default value of <span class="No-Break">the register.</span></li>
				<li><strong class="bold">Access type</strong>: The register supports various access types – it can be accessed without wait states and allows word, half-word, and <span class="No-Break">byte access.</span></li>
				<li><strong class="bold">Register diagram</strong>: A detailed diagram of the register is included, showing all 32 bits along with labels for <span class="No-Break">each bit.</span></li>
			</ul>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21914_02_15.jpg" alt="Figure 2.15: RCC AHB1 ER" width="1444" height="544"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: RCC AH<a id="_idTextAnchor068"/>B1 ER</p>
			<p class="callout-heading">RCC_AHB1ENR Address = RCC_BASE + 0x30 = 0x40023830</p>
			<p class="callout">From this information, we can accurately calculate the address of the <strong class="source-inline">RCC_AHB1ENR</strong> register. We do this by adding the <strong class="source-inline">RCC_AHB1ENR</strong> offset to the <strong class="source-inline">RCC_BASE address</strong>. The formula is as follows: <strong class="source-inline">RCC_BASE + RCC_AHB1ENR Offset = 0x40023800 + 0x30 = </strong><span class="No-Break"><strong class="source-inline">0x40023830</strong></span><span class="No-Break">.</span></p>
			<p>The same section of the reference manual also includes a detailed description of each bit within the register. We are particularly interested in the bit named <strong class="source-inline">'GPIOAEN'</strong>, which stands<a id="_idIndexMarker174"/> for <strong class="bold">GPIOA Enable</strong>. This is identified as bit number <strong class="source-inline">0</strong>. Further down, at the start of the next page in the document, we find a precise description of <strong class="source-inline">bit0</strong>, as depicted in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.16</em>. This description explains that setting <strong class="source-inline">bit0</strong> to <strong class="source-inline">0</strong> disables the GPIOA clock while setting it to <strong class="source-inline">1</strong> enables the <span class="No-Break">GPIOA clock.</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B21914_02_16.jpg" alt="Figure 2.16: GPIOAEN bit" width="808" height="232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: GPIOAEN bit</p>
			<p>Having understood the steps required to enable clock access to GPIOA, our next section will focus on learning how to set and clear bits within <span class="No-Break">a register.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor069"/>Setting and clearing bits in registers</h2>
			<p>In bare-metal programming, manipulating individual bits within registers is a fundamental operation. This manipulation is important for configuring hardware settings, controlling peripheral devices, and optimizing the performance of embedded systems. Let’s start by understanding bits <span class="No-Break">and registers.</span></p>
			<p>A <strong class="bold">bit</strong> is the <a id="_idIndexMarker175"/>basic unit of information in computing and digital communications, which can have a value of either <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>. <strong class="bold">Registers</strong>, on the other hand, are small-sized storage locations within microcontrollers, used to store data temporarily for various operations. Registers are<a id="_idIndexMarker176"/> typically a collection of bits (such as 8-bit, 16-bit, or 32-bit registers), and each bit in a register can be manipulated individually. In bare-metal programming, the two most frequently used bit operations are setting a bit and clearing <span class="No-Break">a bit.</span></p>
			<h3>Setting a bit</h3>
			<p>Setting a bit <a id="_idIndexMarker177"/>means changing its value to <strong class="source-inline">1</strong>. We will often use this to activate or enable a specific function within <span class="No-Break">a microcontroller.</span></p>
			<p><strong class="bold">How it’s done</strong>: The bitwise <strong class="source-inline">OR</strong> operation (<strong class="source-inline">|</strong>) is used for setting <span class="No-Break">a bit:</span></p>
			<pre class="source-code">
register |= 1 &lt;&lt; bit_position;</pre>			<p>In this operation, <strong class="source-inline">1</strong> is shifted left <strong class="source-inline">(&lt;&lt;)</strong> to <strong class="source-inline">bit_position</strong> and then <strong class="source-inline">ORed</strong> with the current value of the register. The left shift operation creates a binary value where only the target bit is <strong class="source-inline">1</strong>, and all others are <strong class="source-inline">0</strong>. The <strong class="source-inline">OR</strong> operation then sets the target bit in the register to <strong class="source-inline">1</strong>, leaving the <span class="No-Break">rest unchanged.</span></p>
			<p>Let’s <a id="_idIndexMarker178"/>assume <strong class="source-inline">register</strong> initially holds the <strong class="source-inline">0011</strong> (binary) value and we want to set the third bit (bit position 2, 0-indexed). The <em class="italic">bit-shifted value</em> would be <strong class="source-inline">0100</strong> (binary for <strong class="source-inline">1 &lt;&lt; 2</strong>). The <strong class="source-inline">OR</strong> operation is then <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">0011: original register value</strong>
<strong class="bold">(0001 &lt;&lt;2) = 0100: bit-shifted value</strong>
0011
OR
0100
------
0111 (resulting value)</pre>			<p>In this example, the <em class="italic">first</em>, <em class="italic">second</em>, and <em class="italic">fourth</em> bits of the original register value retain their value while the value of the third bit is changed <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see the opposite of setting <span class="No-Break">a bit.</span></p>
			<h3>Clearing a bit</h3>
			<p>Conversely, clearing a <a id="_idIndexMarker179"/>bit means changing its value to <strong class="source-inline">0</strong>, typically to deactivate <span class="No-Break">a function.</span></p>
			<p><strong class="bold">How it’s done</strong>: The combination of bitwise <strong class="source-inline">AND</strong> (<strong class="source-inline">&amp;</strong>) and <strong class="source-inline">NOT</strong> (<strong class="source-inline">~</strong>) operations is used for clearing <span class="No-Break">a bit:</span></p>
			<pre class="source-code">
register &amp;= ~(1 &lt;&lt; bit_position);</pre>			<p>Here, <strong class="source-inline">1</strong> is left-shifted to <strong class="source-inline">bit_position</strong>, and then a bitwise <strong class="source-inline">NOT</strong> operation is applied to create a binary number where all bits are <strong class="source-inline">1</strong>, except the target bit. The <strong class="source-inline">AND</strong> operation with the register clears the target bit, leaving others as <span class="No-Break">they are.</span></p>
			<p>Let’s assume <strong class="source-inline">register</strong> initially holds the <strong class="source-inline">0111</strong> (binary) value and we want to clear the third bit (bit position 2, 0-indexed). <em class="italic">The bit-shifted value for the mask</em> would be <strong class="source-inline">0100</strong> (binary for <strong class="source-inline">1 &lt;&lt; 2</strong>). To clear the bit, we use the bitwise <strong class="source-inline">AND</strong> operation with the bitwise <strong class="source-inline">NOT</strong> of the bit-shifted value. The operation is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">0111: original register value</strong>
<strong class="bold">(0001 &lt;&lt; 2) = 0100: bit-shifted value</strong>
<strong class="bold">~0100 = 1011: bitwise NOT of bit-shifted value</strong>
0111
AND
1011
----
0011 (resulting value)</pre>			<p>In this operation, the <a id="_idIndexMarker180"/>third bit of the register is cleared (changed to <strong class="source-inline">0</strong>), while the other bits retain their <span class="No-Break">original values.</span></p>
			<p>Let’s summarize the key points from the last two sections. Firstly, we understood that enabling clock access to GPIOA requires setting <strong class="source-inline">bit0</strong> in the <strong class="source-inline">RCC_AHB1ENR</strong> register. Secondly, we explored how to set and clear bits in registers using bitwise operations. Moving forward, in the next section, we will focus on configuring GPIOA pin 5 (PA5) as an output pin. This step is crucial in our progress toward activating the LED connected to PA5. This will take us a step closer to activating the LED connec<a id="_idTextAnchor070"/>ted <span class="No-Break">to PA5.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor071"/>The GPIO port mode register (GPIOx_MODER)</h2>
			<p>The <strong class="bold">GPIO port mode register</strong> in STM32 <a id="_idIndexMarker181"/>microcontrollers is a specialized register used for setting the mode of each GPIO pin. To locate information about this register, we navigate to the table of contents of the reference manual and look for the section titled <em class="italic">GPIO Port Mode Register (GPIOx_MODER)</em>. By clicking on the associated page number, we are directly taken to <span class="No-Break">the section.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.17</em> shows the top section of the page. Here, we can observe the <span class="No-Break">follow<a id="_idTextAnchor072"/>ing details:</span></p>
			<ul>
				<li><strong class="bold">Port applicability (x = A…E and H)</strong>: This notation indicates that the register information is relevant to multiple ports. Specifically, it applies to <strong class="source-inline">GPIOA_MODER</strong> through <strong class="source-inline">GPIOE_MODER</strong>, as well as <strong class="source-inline">GPIOH_MODER</strong>. This means the same register structure and configuration are consistent across these <span class="No-Break">GPIO ports.</span></li>
				<li><strong class="bold">Address offset – 0x00</strong>: This tells us that the register’s address is the same as the base address of the corresponding GPIO port. In other words, for each GPIO port, the <strong class="source-inline">MODER</strong> register is located at the very beginning of the port’s memory space. Therefore, the GPIOA <strong class="source-inline">MODE</strong> register address is the same as the GPIOA <span class="No-Break">base address.</span></li>
				<li><span class="No-Break"><strong class="bold">Reset values</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Port A</strong>: The default value for the <strong class="source-inline">GPIOA_MODER</strong> register is <strong class="source-inline">0xA800 0000</strong>. This value represents the initial configuration state of the GPIOA pins <span class="No-Break">upon reset.</span></li><li><strong class="bold">Port B</strong>: The <strong class="source-inline">GPIOB_MODER</strong> register has a default reset value of <span class="No-Break"><strong class="source-inline">0x0000 0280</strong></span><span class="No-Break">.</span></li><li><strong class="bold">Other ports</strong>: The reset value for <a id="_idIndexMarker182"/>the <strong class="source-inline">MODER</strong> registers of all other specified GPIO ports is<a id="_idTextAnchor073"/> <span class="No-Break"><strong class="source-inline">0x0000 0000</strong></span><span class="No-Break">:</span></li></ul><p class="list-inset"><strong class="bold">GPIOA MODE Register Address = GPIOA_BASE = </strong><span class="No-Break"><strong class="bold">0x40020000</strong></span></p></li>
			</ul>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B21914_02_17.jpg" alt="Figure 2.17: GPIO port mode register" width="1172" height="518"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: GPIO port mode register</p>
			<p>We also observe that this is a 32-bit register, with its bits organized in pairs. For example, <strong class="source-inline">bit0</strong> and <strong class="source-inline">bit1</strong> together form a pair known as <strong class="source-inline">MODER0</strong>, <strong class="source-inline">bit2</strong> and <strong class="source-inline">bit3</strong> form <strong class="source-inline">MODER1</strong>, <strong class="source-inline">bit4</strong> and <strong class="source-inline">bit5</strong> form <strong class="source-inline">MODER2</strong>, and so on. Each of these pairs corresponds to a single pin of the GPIO port. Specifically, <strong class="source-inline">MODER0</strong> controls the configuration of <strong class="source-inline">PIN0</strong> of the corresponding port, <strong class="source-inline">MODER1</strong> controls <strong class="source-inline">PIN1</strong>, and this pattern continues similarly for the <span class="No-Break">other pins.</span></p>
			<p>Given our<a id="_idIndexMarker183"/> objective of configuring the mode of <strong class="source-inline">PIN5</strong>, we need to focus on <strong class="source-inline">MODER5</strong>. In the register, <strong class="source-inline">MODER5</strong> comprises <strong class="source-inline">bit10</strong> and <strong class="source-inline">bit11</strong>. These two bits are the required bits for setting the operational mode <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PIN5</strong></span><span class="No-Break">.</span></p>
			<p>The reference manual provides a truth table, illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.18</em>, which explains the combinations of the two <strong class="source-inline">MODER</strong> bits necessary to configure a pin. This table is an invaluable resource for understanding how to set the bits for the desired pin configuration, whether it’s as an input, output, or an alternate <span class="No-Break">function mode.</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B21914_02_18.jpg" alt="Figure 2.18: The MODER bits configuration" width="1354" height="300"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: The MODER bits configuration</p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.18</em>, the <strong class="source-inline">MODER</strong> register within the GPIO port is composed of pairs of bits, designated as <strong class="source-inline">2y:2y+1 MODERy[1:0]</strong>, where <em class="italic">y</em> ranges from 0 to 15, representing each of the 16 pins in the port (<strong class="source-inline">PIN0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PIN15</strong></span><span class="No-Break">).</span></p>
			<p>In this equation, <em class="italic">y</em> represents the pin number. For Pin 5, <em class="italic">y = 5</em>. Plugging this value into the equation gives us the bit positions in the <strong class="source-inline">MODER</strong> register that correspond to <span class="No-Break">Pin 5:</span></p>
			<p>The bit positions for <strong class="source-inline">MODER5</strong> are calculated as <em class="italic">2*y</em> and <em class="italic">(</em><span class="No-Break"><em class="italic">2*y) +1</em></span><span class="No-Break">.</span></p>
			<p>Substituting <em class="italic">y = 5</em>, we get <span class="No-Break">the following:</span></p>
			<p> <em class="italic">2*5 = 10</em> and <em class="italic">2*5 + 1 = 11</em>, which are <strong class="source-inline">10</strong> and <span class="No-Break"><strong class="source-inline">11</strong></span><span class="No-Break">, respectively.</span></p>
			<p>So, bits <strong class="source-inline">10</strong> and <strong class="source-inline">11</strong> in the MODER register (<strong class="source-inline">MODER5[1:0]</strong>) are the bits that control the mode of Pin 5. By setting these bits to specific values (<strong class="source-inline">00</strong>, <strong class="source-inline">01</strong>, <strong class="source-inline">10</strong>, or <strong class="source-inline">11</strong>), we can configure Pin 5 as an input, general-purpose output, alternate function, or analog <span class="No-Break">mode, respectively.</span></p>
			<p>The GPIO <strong class="source-inline">MODER</strong> register supports four distinct bit combinations, each defining a different operational mode for the <span class="No-Break">corresponding pin:</span></p>
			<ul>
				<li><strong class="source-inline">00</strong>: When both bits are <strong class="source-inline">0</strong>, the corresponding pin is set as an input pin. This is the standard mode for pins to receive data from <span class="No-Break">external sources.</span></li>
				<li><strong class="source-inline">01</strong>: Setting the bits to <strong class="source-inline">01</strong> sets the pin function to general-purpose output. In this mode, the pin can send data out, for instance, to light up <span class="No-Break">an LED.</span></li>
				<li><strong class="source-inline">10</strong>: The <strong class="source-inline">10</strong> state configures the pin for alternate functions. Each pin can serve specific additional purposes (such as PWM output and I2C communication lines), and this mode enables <span class="No-Break">those functions.</span></li>
				<li><strong class="source-inline">11</strong>: When the bits are set to <strong class="source-inline">11</strong>, the pin operates in analog mode. This mode is typically used for ADC, useful in reading values from <span class="No-Break">analog sensors.</span></li>
			</ul>
			<p>From this, we understand that to configure PA5 as an output, we must set bit 10 of the <strong class="source-inline">GPIOA_MODER</strong> register to <strong class="source-inline">0</strong> and bit 11 <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>Let’s summarize<a id="_idIndexMarker184"/> our progress toward activating the LED connected <span class="No-Break">to PA5:</span></p>
			<ul>
				<li><strong class="bold">Enabling clock access to GPIOA</strong>: We’ve learned how to enable the clock for GPIOA, by setting <strong class="source-inline">bit0</strong> of the <strong class="source-inline">RCC_AHB1ENR</strong> register to <strong class="source-inline">1</strong>. This step is essential to power the GPIOA <span class="No-Break">for operation.</span></li>
				<li><strong class="bold">Configuring PA5 for output</strong>: We have just learned how to set PA5 as a general-purpose <span class="No-Break">output pin.</span></li>
			</ul>
			<p>These two steps effectively configure PA5 as an output pin. The final task involves controlling the output state of the pin – setting it to either <strong class="source-inline">1</strong> or <strong class="source-inline">0</strong>, which corresponds to on or off, respectively. This translates to sending either 3.3v or 0v to PA5, thus turning the connected LED on or off. To manage the output state of a pin, we need to interact with <a id="_idIndexMarker185"/>the <strong class="bold">Output Data Register</strong> (<strong class="bold">ODR</strong>). Locating and configuring this register will be the focus of the <span class="No-Break">next section.</span></p>
			<p>So far, we have the following information for our quest to activate the LED connected <span class="No-Break">to PA5:</span></p>
			<ul>
				<li>We know how to enable clock access to GPIOA through the <span class="No-Break"><strong class="source-inline">RCC_AHB1ENR</strong></span><span class="No-Break"> register</span></li>
				<li>We know how to<a id="_idIndexMarker186"/> configure the PIN5 of GPIOA as a general-purpose <span class="No-Break">output pin.</span></li>
			</ul>
			<p>These two steps make PA5 act as an output pin. The final step is to be able to set the output state of the pin. The state can be either <strong class="source-inline">1</strong> or <strong class="source-inline">0</strong> corresponding to on or off, corresponding to sending 3.3v or 0v to PA5, and finally corresponding to turning on or turning off the LED connected to PA5. To set the output of a pin, we need to access the ODR; this shall be the focus of the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor074"/>GPIO Port Output Data Register (GPIOx_ODR)</h2>
			<p>The GPIO Port <strong class="bold">ODR</strong> in STM32<a id="_idIndexMarker187"/> microcontrollers is used for controlling the output state of each GPIO pin. To find information about this register, we refer to the table of contents in the microcontroller’s reference manual and locate the section titled <em class="italic">GPIO Port Output Data Register (GPIOx_ODR)</em>. Clicking on the page number corresponding to this section takes us straight to the <span class="No-Break">required information.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.19</em> displays the top part of the page, where we can observe the <span class="No-Break">following details:</span></p>
			<ul>
				<li><strong class="bold">Port applicability (x = A…E and H)</strong>: This indicates that the register information is relevant to multiple ports. Specifically, it applies to <strong class="source-inline">GPIOA_ODR</strong> through <strong class="source-inline">GPIOE_ODR</strong>, as well as <strong class="source-inline">GPIOH_ODR</strong>. This means the same register structure and configuration are consistent across these <span class="No-Break">GPIO ports.</span></li>
				<li><strong class="bold">Address offset – 0x14</strong>: This tells us that the address of the ODR register is offset by <strong class="source-inline">0x14</strong> from the base address of its respective GPIO port. This means that, for each GPIO port, the ODR register can be found at this offset from the port’s base <span class="No-Break">memory address.</span></li>
				<li><strong class="bold">Reset values – 0x00000000</strong>: This indicates that, by default, all bits in the ODR are set to <strong class="source-inline">0</strong> upon a reset. This default state ensures that all GPIO pins are initially in a low <span class="No-Break">output state.</span></li>
			</ul>
			<p class="callout-heading">GPIOA ODR address = GPIOA_BASE + ODR_OFFSET = 0x40020014</p>
			<p class="callout"><strong class="source-inline">ODR_OFFSET = </strong><span class="No-Break"><strong class="source-inline">0x14</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B21914_02_19.jpg" alt="" role="presentation" width="1270" height="489"/>
				</div>
			</div>
			<p class="callout"><span class="No-Break">Figure 2</span>.19: GPIO <span class="No-Break">port ODR</span></p>
			<p>Let’s delve into the<a id="_idIndexMarker188"/> structure of <span class="No-Break">the bits:</span></p>
			<ul>
				<li><strong class="bold">Bits 31:16 (reserved)</strong>: These bits are reserved and should not be used for <span class="No-Break">any operation.</span></li>
				<li><strong class="bold">Bits 15:0 (ODRy: port output data, y = 0..15)</strong>: These bits, ranging from <strong class="source-inline">0</strong> to <strong class="source-inline">15</strong>, correspond to each of the 16 pins in the GPIO port. They are directly programmable and can be both read and written by software. Changing the value of these bits alters the output state of the corresponding <span class="No-Break">GPIO pin.</span></li>
			</ul>
			<p>Let’s consider our final task of activating the LED connected <span class="No-Break">to PA5:</span></p>
			<ul>
				<li><strong class="bold">GPIOA_ODR bit for PA5</strong>: Given that PA5 corresponds to the 5th pin in the GPIOA port, we target the 5th bit (bit <strong class="source-inline">5</strong>) in the <span class="No-Break"><strong class="source-inline">GPIOA_ODR</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="bold">Setting PA5 high</strong>: To set PA5 high, we need to write <strong class="source-inline">1</strong> to bit <strong class="source-inline">5</strong> of the <strong class="source-inline">GPIOA_ODR</strong> register. This can be achieved using a bitwise <strong class="source-inline">OR</strong> operation, <span class="No-Break">as follows:</span><pre class="source-code">
GPIOA_ODR |= 1 &lt;&lt; 5;</pre></li>			</ul>
			<p>In this operation, we <a id="_idIndexMarker189"/>shift <strong class="source-inline">1</strong> left by 5 positions (resulting in a binary value where only the 6th bit is <strong class="source-inline">1</strong>) and then <strong class="source-inline">OR</strong> it with the current value of the <strong class="source-inline">GPIOA_ODR</strong> register. This action sets PA5 high without altering the state of other pins in <span class="No-Break">the port.</span></p>
			<p>Setting PA5 high will supply voltage to the connected LED, effectively turning <span class="No-Break">it on.</span></p>
			<p>Now that we understand how to set the state of GPIO output pins, in the next section, we will combine all the pieces of information we’ve acquired and develop our <span class="No-Break">first firmware.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor075"/>Register manipulation – from configuration to running your first firmware</h1>
			<p>In this section, we will apply the <a id="_idIndexMarker190"/>knowledge acquired throughout this chapter to develop our first <span class="No-Break">bare-metal firmware.</span></p>
			<p>We begin by creating a new project, a process we covered in <a href="B21914_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. Here is a summary of <span class="No-Break">the steps:</span></p>
			<ol>
				<li><strong class="bold">Start a new project</strong>: Go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">STM32 Project</strong> in <span class="No-Break">your IDE.</span></li>
				<li><strong class="bold">Select the target microcontroller</strong>: A <strong class="bold">Target Selection</strong> window will appear, prompting you to choose the microcontroller or development board for <span class="No-Break">your project.</span></li>
				<li><strong class="bold">Use the board selector</strong>: Click on the <strong class="bold">Board </strong><span class="No-Break"><strong class="bold">Selector</strong></span><span class="No-Break"> tab.</span></li>
				<li><strong class="bold">Search for our board</strong>: Input <strong class="source-inline">NUCLEO-F411</strong> in the <strong class="bold">Commercial Part </strong><span class="No-Break"><strong class="bold">Number</strong></span><span class="No-Break"> field.</span></li>
				<li><strong class="bold">Select our board</strong>: From the list of boards that appear, choose <strong class="bold">NUCLEO-F411RE</strong> and then <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Name our project</strong>: Assign a name to your project, for <span class="No-Break">instance, </span><span class="No-Break"><strong class="source-inline">RegisterManipulation</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Project configuration</strong>: In the project options, select an <strong class="source-inline">Empty</strong> <span class="No-Break">project setup.</span></li>
				<li><strong class="bold">Final step</strong>: Click <strong class="bold">Finish</strong> to create <span class="No-Break">your project.</span></li>
			</ol>
			<p>Once the project is<a id="_idIndexMarker191"/> created, open the <strong class="source-inline">main.c</strong> file in your project workspace. Clear all pre-existing text in this file to start with a clean slate for <span class="No-Break">our code.</span></p>
			<p>For a clearer understanding, we will structure our code into two distinct sections. The first section will be titled <strong class="source-inline">Register Definitions</strong>, and the second will be named <span class="No-Break"><strong class="source-inline">Main Function</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor076"/>Register Definitions</h2>
			<p>This section of the <a id="_idIndexMarker192"/>code defines constants and macros for memory addresses and bit masks. Here are all the memory addresses and bit masks required for controlling the LED connected <span class="No-Break">to PA5:</span></p>
			<pre class="source-code">
//  1: Define base address for peripherals
<strong class="bold">#define</strong> PERIPH_BASE        (0x40000000UL)
//  2: Offset for AHB1 peripheral bus
<strong class="bold">#define</strong> AHB1PERIPH_OFFSET  (0x00020000UL)
//  3: Base address for AHB1 peripherals
<strong class="bold">#define</strong> AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)
//  4: Offset for GPIOA
<strong class="bold">#define</strong> GPIOA_OFFSET       (0x0000UL)
//  5: Base address for GPIOA
<strong class="bold">#define</strong> GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)
//  6: Offset for RCC
<strong class="bold">#define</strong> RCC_OFFSET         (0x3800UL)
//  7: Base address for RCC
<strong class="bold">#define</strong> RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)
//  8: Offset for AHB1EN register
<strong class="bold">#define</strong> AHB1EN_R_OFFSET    (0x30UL)
//  9: Address of AHB1EN register
<strong class="bold">#define</strong> RCC_AHB1EN_R  (*(<strong class="bold">volatile unsigned int</strong> *)(RCC_BASE +  AHB1EN_R_OFFSET))
//  10: Offset for mode register
<strong class="bold">#define</strong> MODE_R_OFFSET      (0x00UL)
//  11: Address of GPIOA mode register
<strong class="bold">#define</strong> GPIOA_MODE_R  (*(<strong class="bold">volatile unsigned int</strong> *)(GPIOA_BASE + MODE_R_OFFSET))
//  12: Offset for output data register
<strong class="bold">#define</strong> OD_R_OFFSET   (0x14UL)
//  13: Address of GPIOA output data register
<strong class="bold">#define</strong> GPIOA_OD_R    (*(<strong class="bold">volatile unsigned int</strong> *)(GPIOA_BASE +  OD_R_OFFSET))
//  14: Bit mask for enabling GPIOA (bit 0)
<strong class="bold">#define</strong> GPIOAEN       (1U&lt;&lt;0)
//  15: Bit mask for GPIOA pin 5
<strong class="bold">#define</strong> PIN5          (1U&lt;&lt;5)
//  16: Alias for PIN5 representing LED pin
<strong class="bold">#define</strong> LED_PIN       PIN5</pre>			<p>In the previous sections, we gathered <a id="_idIndexMarker193"/>base addresses, offsets, and bit masks from the documentation. These remain unchanged in our code. However, a notable aspect of the code snippet is the use of the <strong class="source-inline">UL</strong> suffix at the end of each hexadecimal value as well as the use of keywords such as <strong class="source-inline">volatile</strong>. Let’s delve into the significance of these in the context of C and <span class="No-Break">C++ programming.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor077"/>The UL suffix</h2>
			<p>When we see a number in the<a id="_idIndexMarker194"/> code ending with <strong class="source-inline">UL</strong>, it’s more than just a part of the number – it’s a clear instruction to the compiler about the type and size of <span class="No-Break">the number:</span></p>
			<ul>
				<li><strong class="bold">Unsigned</strong>: The <strong class="source-inline">U</strong> in <strong class="source-inline">UL</strong> indicates that the number is unsigned. In other words, it’s a positive number with no sign to indicate it could be negative. This designation allows the number to represent a wider range of positive values compared to a signed integer of the <span class="No-Break">same size.</span></li>
				<li><strong class="bold">Long integer</strong>: The <strong class="source-inline">L</strong> signifies that the number is a long integer. This is important because the size of a long integer can vary based on the system and the compiler. Typically, a long integer is larger than a regular int – often 32 bits, but sometimes 64 bits on <span class="No-Break">certain systems.</span></li>
			</ul>
			<p>The <strong class="source-inline">UL</strong> suffix collectively ensures that these values are treated as unsigned long integers. This is important for firmware development and other forms of low-level programming, where the exact size and “signedness” of an integer can significantly impact program behavior and memory management. Using <strong class="source-inline">UL</strong> leads to more predictable, platform-independent code, ensuring that the values behave consistently across different compilers <span class="No-Break">and systems.</span></p>
			<h3>The use of “(*(volatile unsigned int *)”</h3>
			<p>In the context of bare-metal programming, particularly in our current code snippet, we notice that the address of each register is prefixed with <strong class="source-inline">"(*(volatile unsigned </strong><span class="No-Break"><strong class="source-inline">int *)".</strong></span></p>
			<p>Let’s break down what each part of this notation means and why <span class="No-Break">it’s used:</span></p>
			<ul>
				<li><strong class="bold">Type casting to a pointer</strong>: The <strong class="source-inline">(unsigned int *)</strong> expression is a <strong class="bold">type cast</strong>. It tells the compiler <a id="_idIndexMarker195"/>to treat<a id="_idIndexMarker196"/> the subsequent address as a pointer to an unsigned integer. In C and C++, pointers are variables that store the memory address of another variable. In the context of our firmware, this casting means that we are directing the compiler to treat a certain address as the location of an unsigned integer. However, this unsigned integer is not just any number; it corresponds directly to the state of a 32-bit hardware register. Each bit in this 32-bit integer mirrors a specific bit in the register, thereby allowing direct control and monitoring of the hardware’s state through standard <span class="No-Break">programming constructs.</span></li>
				<li><strong class="bold">Dereferencing the pointer</strong>: The leading asterisk (<strong class="source-inline">*</strong>) in <strong class="source-inline">*(unsigned int *)</strong> is used to dereference the pointer. Dereferencing<a id="_idIndexMarker197"/> a pointer means accessing the value stored at the memory address the pointer is pointing to. Essentially, it’s not just about knowing where the data is (the address); it’s about actually accessing and using <span class="No-Break">that data.</span></li>
				<li><strong class="source-inline">volatile</strong>: The <strong class="source-inline">volatile</strong> keyword<a id="_idIndexMarker198"/> tells the compiler that the value at the pointer can change at any time, without any action being taken by the code. This is often the case with hardware registers, where the value can change due to hardware events, external inputs, or other aspects of the system outside the <span class="No-Break">program’s control.</span></li>
			</ul>
			<p>Without <strong class="source-inline">volatile</strong>, the compiler might optimize out certain reads and writes to these addresses under the assumption that the values don’t change unexpectedly. This is because when a compiler processes code, it looks for ways to make the program run more efficiently. This includes removing redundant operations or simplifying code paths. This process occurs during the compilation of the program before it’s run. If the compiler determines that a variable (including a memory-mapped hardware register) doesn’t change its value, it might optimize the code by eliminating repeated reads from or writes to that variable. For example, if a value is read from a register and then read again later, the compiler might assume the value hasn’t changed and use the previously read value instead of accessing the register a second time. The use of <strong class="source-inline">volatile</strong> is a directive to tell the compiler not to apply certain optimizations to accesses of the marked variable, maintaining the integrity <span class="No-Break">of operations.</span></p>
			<p>In our code snippet, we <a id="_idIndexMarker199"/>encounter two additional terms that are very common in bare-metal<a id="_idIndexMarker200"/> programming: <strong class="bold">bit mask</strong> and <strong class="bold">alias</strong>. Let’s take a closer look at each of these concepts to gain a clearer understanding of the roles <span class="No-Break">they play:</span></p>
			<ul>
				<li><strong class="bold">Bit masks</strong>: A<a id="_idIndexMarker201"/> bit mask is a binary number used as a template to manipulate specific bits within another binary number, usually a register value, while leaving other bits unaffected. We use bit masks to set, clear, or toggle individual bits in a register. They work by applying bitwise operations (such as <strong class="source-inline">AND</strong>, <strong class="source-inline">OR</strong>, <strong class="source-inline">XOR</strong>) along with the mask to achieve the desired result. For example, a bit mask might be used to turn on a specific LED connected to a microcontroller pin without altering the state of other pins. A bit mask is created by setting the bits we want to manipulate to <strong class="source-inline">1</strong> while keeping others at <strong class="source-inline">0</strong>. This mask is then combined with the register value using the appropriate <span class="No-Break">bitwise operation.</span><p class="list-inset">For example, a <strong class="source-inline">0b00000100</strong> mask used with <strong class="source-inline">OR</strong> will set the third bit of the <span class="No-Break">target register.</span></p></li>
				<li><strong class="bold">Alias</strong>: An<a id="_idIndexMarker202"/> alias is simply a name given to a bit or a group of bits to make the code more readable and easier to manage. We use aliases to refer to specific hardware features or configurations represented by bits in a register. By using a descriptive name, we can make the code more understandable and maintainable. For example, naming a bit mask that controls an LED as <strong class="source-inline">LED_PIN</strong> makes the code self-explanatory. We define aliases using preprocessor directives such as <strong class="source-inline">#define</strong> in C or C++. For example, <strong class="source-inline">#define LED_PIN (1U&lt;&lt;5)</strong> creates an <strong class="source-inline">LED_PIN</strong> alias for the bit mask that represents the sixth pin (zero indexing) in a GPIO <span class="No-Break">port ODR.</span></li>
			</ul>
			<p>Now, let’s analyze the second section of <span class="No-Break">the code.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor078"/>Main Function</h2>
			<p>This <a id="_idIndexMarker203"/>section of our code outlines the primary operations for controlling the LED connected to PA5 of <span class="No-Break">the microcontroller:</span></p>
			<pre class="source-code">
// Line 17: Start of main function
int main(void)
{
    //  18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;
    GPIOA_MODE_R |= (1U&lt;&lt;10);  //  19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); //  20: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
       // Line 22: Set PA5(LED_PIN) high
       GPIOA_OD_R |= LED_PIN;
    }  //  23: End of infinite loop
}  //  24: End of main function</pre>			<p>Let’s break <a id="_idIndexMarker204"/>down each part of the code for a <span class="No-Break">clearer understanding:</span></p>
			<ul>
				<li><em class="italic">Line 17</em>: This marks the beginning of the main function. This is the entry point of our program where the <span class="No-Break">execution starts:</span><pre class="source-code">
// Line 17: Start of main function
int main(void)
{</pre></li>				<li><em class="italic">Line 18</em>: This enables the clock for <strong class="source-inline">GPIOA</strong>. As we learned earlier, the <strong class="source-inline">RCC_AHB1EN_R</strong> register controls the clock to the <strong class="source-inline">AHB1</strong> bus peripherals. The <strong class="source-inline">|= GPIOAEN</strong> operation sets the bit associated with GPIOA (GPIOAEN) in the <strong class="source-inline">RCC_AHB1EN_R</strong> register, ensuring that the GPIOA peripheral has the necessary clock enabled for <span class="No-Break">its operations:</span><pre class="source-code">
    // Line 18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;</pre></li>				<li><em class="italic">Line 19–20</em>: These lines configure <strong class="source-inline">PA5</strong> as an output pin. Setting bit 10 to <strong class="source-inline">1</strong> and bit 11 to <strong class="source-inline">0</strong> in <strong class="source-inline">GPIOA_MODE_R</strong> configures <strong class="source-inline">PA5</strong> in general-purpose <span class="No-Break">output mode:</span><pre class="source-code">
    GPIOA_MODE_R |= (1U&lt;&lt;10);  // Line 19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); // Line 20: Set bit 11 to 0</pre></li>				<li><em class="italic">Line 21–23</em>: These<a id="_idIndexMarker205"/> lines initiate an infinite loop, which is a common practice in embedded systems for <span class="No-Break">continuous operation:</span><pre class="source-code">
    // Line 21: Start of infinite loop
    while(1)
    {
        // Line 22: Set PA5(LED_PIN) high
        GPIOA_OD_R |= LED_PIN;
    }  // Line 23: End of infinite loop</pre><p class="list-inset">This is what is inside <span class="No-Break">this loop:</span></p><ul><li><em class="italic">Line 22</em>: This line sets PA5 high. This is achieved by setting the respective bit in <strong class="source-inline">GPIOA_OD_R</strong>. The <strong class="source-inline">|= LED_PIN</strong> operation ensures that PA5 outputs a high signal (essentially turning the <span class="No-Break">LED on).</span></li><li><em class="italic">Line 24</em>: This marks the end of the <span class="No-Break">main function:</span><pre class="source-code">}  // Line 24: End of main function</pre></li></ul></li>			</ul>
			<p>Now that we have a clear understanding of each line of the code, let’s proceed to enter the entire code into the <strong class="source-inline">main.c</strong> file. Additionally, for your convenience, this complete source code is available in the GitHub repository for the book. You can find it in the folder <span class="No-Break">titled </span><span class="No-Break"><strong class="source-inline">Chapter2</strong></span><span class="No-Break">.</span></p>
			<p>This <a id="_idIndexMarker206"/>is the <span class="No-Break">entire code:</span></p>
			<pre class="source-code">
//  1: Define base address for peripherals
#define PERIPH_BASE        (0x40000000UL)
//  2: Offset for AHB1 peripheral bus
#define AHB1PERIPH_OFFSET  (0x00020000UL)
//  3: Base address for AHB1 peripherals
#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)
//  4: Offset for GPIOA
#define GPIOA_OFFSET       (0x0000UL)
//  5: Base address for GPIOA
#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)
//  6: Offset for RCC
#define RCC_OFFSET         (0x3800UL)
//  7: Base address for RCC
#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)
//  8: Offset for AHB1EN register
#define AHB1EN_R_OFFSET    (0x30UL)
//  9: Address of AHB1EN register
#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))
//  10: Offset for mode register
#define MODE_R_OFFSET      (0x00UL)
//  11: Address of GPIOA mode register
#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))
//  12: Offset for output data register
#define OD_R_OFFSET   (0x14UL)
//  13: Address of GPIOA output data register
#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))
//  14: Bit mask for enabling GPIOA (bit 0)
#define GPIOAEN       (1U&lt;&lt;0)
//  15: Bit mask for GPIOA pin 5
#define PIN5          (1U&lt;&lt;5)
//  16: Alias for PIN5 representing LED pin
#define LED_PIN       PIN5
//  17: Start of main function
int main(void)
{
    //  18: Enable clock access to GPIOA
    RCC_AHB1EN_R |= GPIOAEN;
    GPIOA_MODE_R |= (1U&lt;&lt;10);  //  19: Set bit 10 to 1
    GPIOA_MODE_R &amp;= ~(1U&lt;&lt;11); //  20: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
        //  22: Set PA5(LED_PIN) high
        GPIOA_OD_R |= LED_PIN;
    }  //  23: End of infinite loop
}  //  24: End of main function</pre>			<p>To build <a id="_idIndexMarker207"/>the project, first select it by clicking on the project name once, and then initiate the build process by clicking on the <em class="italic">build</em> icon, represented by a hammer symbol, in <span class="No-Break">the IDE.</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B21914_02_20.jpg" alt="Figure 2.20: The build and run icons" width="1091" height="669"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20: The build and run icons</p>
			<p>Once the build process is complete, the next step involves uploading the program to the microcontroller. To do this, we make sure the project is selected in the IDE, and then initiate the upload by clicking on the <em class="italic">run</em> icon, represented by a <span class="No-Break">play symbol.</span></p>
			<p>The first time you run the program, the IDE may prompt you to edit or confirm the launch configurations. A dialog box titled <strong class="bold">Edit Configurations</strong> will appear. It’s sufficient to accept the default settings by clicking <strong class="bold">OK</strong>. <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.21</em> shows the <strong class="bold">Edit Configuration</strong> <span class="No-Break">dialog box.</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B21914_02_21.jpg" alt="Figure 2.21: The Edit Configuration dialog box" width="771" height="640"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21: The Edit Configuration dialog box</p>
			<p>Following<a id="_idIndexMarker208"/> this confirmation, the IDE will commence the process of uploading your program to the microcontroller. When the upload is complete, you should see the green LED on the development board light up. This indicates that our bare-metal code is functioning as intended and successfully controlling <span class="No-Break">the hardware.</span></p>
			<p>We have now mastered configuring PA5 to control the LED, starting from the very basics of consulting the documentation for accurate addresses, effectively typecasting these addresses for register access, and creating aliases for specific bits within <span class="No-Break">the registers.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, we delved into the core of bare-metal programming, emphasizing the direct interaction with microcontroller registers. This gave us insight into some of the key registers of our microcontroller and the structure of <span class="No-Break">those registers.</span></p>
			<p>We began by exploring various firmware development approaches, each offering a distinct level of abstraction. These approaches included the HAL, LL, Bare-Metal C programming, and the assembly language. This exploration helped us understand the trade-offs and applications of each approach in <span class="No-Break">firmware development.</span></p>
			<p>We spent a significant part of the chapter defining addresses of some peripherals using the official documentation. This step was important in creating addresses for various registers within those peripherals. It involved gathering specific memory addresses, typecasting them for register access, and creating aliases for bits in <span class="No-Break">the registers.</span></p>
			<p>The chapter culminated in a practical application where we configured PA5 to control the User LED on the development board. This exercise integrated the concepts discussed throughout the chapter, showcasing how theoretical knowledge can be applied in real-world <span class="No-Break">firmware programming.</span></p>
			<p>In the upcoming chapter, we will delve into the build process. This exploration will allow us to understand the sequential stages that our source code undergoes to become an executable program capable of running on <span class="No-Break">our microcontroller.</span></p>
		</div>
	</div>
</div>
</body></html>