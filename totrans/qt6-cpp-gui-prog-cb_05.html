<html><head></head><body>
<div id="_idContainer093">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.2.1">OpenGL Implementation</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will learn </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.4.1">how to use </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Open Graphics Library</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">OpenGL</span></strong><span class="koboSpan" id="kobo.8.1">), a powerful rendering </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">application program interface</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">API</span></strong><span class="koboSpan" id="kobo.12.1">), and</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.13.1"> combine it with </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Qt</span></strong><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics on screen through</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.16.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">graphics processing unit</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.19.1">GPU</span></strong><span class="koboSpan" id="kobo.20.1">) within our computer’s graphics chip. </span><span class="koboSpan" id="kobo.20.2">In this chapter, we will be learning about OpenGL 3 instead of 2 because, even though the fixed-function pipeline is easier for beginners to grasp compared to the newer programmable pipeline, it is considered legacy code and has been deprecated by most modern 3D rendering software. </span><span class="koboSpan" id="kobo.20.3">Qt 6 supports both versions, so there should be no problem switching over to OpenGL 2 if you need backward compatibility for </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">your software.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Setting up OpenGL </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">in Qt</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Hello World!</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">2D shapes</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">3D shapes</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Texturing </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">in OpenGL</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Basic lighting </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">in OpenGL</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Moving an object using </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">keyboard controls</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Qt Quick 3D </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">in QML</span></span></li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.39.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.40.1">The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and Qt Creator 12.0.2. </span><span class="koboSpan" id="kobo.40.2">All the code used in this chapter can be downloaded from the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">repository: </span></span><a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.44.1">Setting up OpenGL in Qt</span></h1>
<p><span class="koboSpan" id="kobo.45.1">In this</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.46.1"> recipe, we </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.47.1">will learn how to set up OpenGL in </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Qt 6.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.49.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.50.1">Follow these steps to learn how to set up OpenGL </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">in Qt:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.52.1">Create a new </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Qt Widgets Application</span></strong><span class="koboSpan" id="kobo.54.1"> by going to </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">File</span></strong><span class="koboSpan" id="kobo.56.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">New Project</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">Uncheck the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Generate form</span></strong><span class="koboSpan" id="kobo.60.1"> option to avoid generating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">mainwindow.ui</span></strong><span class="koboSpan" id="kobo.62.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">mainwindow.h</span></strong><span class="koboSpan" id="kobo.64.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">mainwindow.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> files.</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">Open up your project file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">.pro</span></strong><span class="koboSpan" id="kobo.69.1">) and add the OpenGL module to your project by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">opengl</span></strong><span class="koboSpan" id="kobo.71.1"> keyword behind </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">QT +=</span></strong><span class="koboSpan" id="kobo.73.1">; after that, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">qmake</span></strong><span class="koboSpan" id="kobo.75.1"> to reload the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">project modules:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.77.1">
QT += core gui opengl</span></pre></li> <li><span class="koboSpan" id="kobo.78.1">You also need to</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.79.1"> add another line in your project file so that it will load both the OpenGL and </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">OpenGL Utilities</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">GLU</span></strong><span class="koboSpan" id="kobo.83.1">) libraries during startup. </span><span class="koboSpan" id="kobo.83.2">Without these two libraries, your program will not be able </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">to run:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.85.1">
LIBS += -lopengl32 -lglu32</span></pre></li> <li><span class="koboSpan" id="kobo.86.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">main.cpp</span></strong><span class="koboSpan" id="kobo.88.1"> and replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">mainwindow.h</span></strong><span class="koboSpan" id="kobo.90.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">QtOpenGL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1"> header:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.93.1">
#include &lt;QtOpenGL&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.94.1">Remove all of the code related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">MainWindow</span></strong><span class="koboSpan" id="kobo.96.1"> class from your </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">main.cpp</span></strong><span class="koboSpan" id="kobo.98.1"> file </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.99.1">and replace it with the code that’s highlighted </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.100.1">in the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.102.1">
#include &lt;QApplication&gt;
#include &lt;QtOpenGL&gt;
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">QOpenGLWindow window;</span></strong><span class="koboSpan" id="kobo.104.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">window.setTitle("Hello World!");</span></strong><span class="koboSpan" id="kobo.106.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">window.resize(640, 480);</span></strong><span class="koboSpan" id="kobo.108.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">window.show();</span></strong><span class="koboSpan" id="kobo.110.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">return app.exec();</span></strong><span class="koboSpan" id="kobo.112.1">
}</span></pre></li> <li><span class="koboSpan" id="kobo.113.1">If you compile and run the project now, you will see an empty window with a black background. </span><span class="koboSpan" id="kobo.113.2">Don’t worry about it—your program is now running </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">on OpenGL:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 5.1 - An empty OpenGL window" src="image/B20976_05_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 5.1 - An empty OpenGL window</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.117.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.118.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">OpenGL</span></strong><span class="koboSpan" id="kobo.120.1"> module</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.121.1"> must be added to the project file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">.pro</span></strong><span class="koboSpan" id="kobo.123.1">) in order to access header files that are related to OpenGL, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">QtOpenGL</span></strong><span class="koboSpan" id="kobo.125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">QOpenGLFunctions</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">QOpenGLWindow</span></strong><span class="koboSpan" id="kobo.129.1"> class instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">QMainWindow</span></strong><span class="koboSpan" id="kobo.131.1"> for the main</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.132.1"> window because it is designed to easily create windows that perform OpenGL rendering, and it offers better performance compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">QOpenGLWidget</span></strong><span class="koboSpan" id="kobo.134.1"> due to the fact that it has no dependencies in its </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">widget module.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">We must call </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">setSurfaceType(QWindow::OpenGLSurface)</span></strong><span class="koboSpan" id="kobo.138.1"> to tell Qt we would prefer to use OpenGL to render the images to screen instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">QPainter</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">QOpenGLWindow</span></strong><span class="koboSpan" id="kobo.142.1"> class provides several virtual functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.144.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">resizeGL()</span></strong><span class="koboSpan" id="kobo.146.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">paintGL()</span></strong><span class="koboSpan" id="kobo.148.1">, and so on) for us to conveniently set up OpenGL and perform graphics rendering. </span><span class="koboSpan" id="kobo.148.2">We will be learning how to use these functions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">following example.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.150.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.151.1">OpenGL is a</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.152.1"> cross-language, cross-platform API for drawing 2D and 3D graphics </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.153.1">on screen through the GPU within our computer’s graphics chip. </span><span class="koboSpan" id="kobo.153.2">Computer graphics technology has been evolving rapidly over the years—so rapidly that the software industry can hardly keep up with </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">its pace.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">In 2008, the</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.156.1"> Khronos Group, the company that maintains and develops OpenGL, announced the release of the OpenGL 3.0 specification, which created a huge uproar and controversy throughout the industry. </span><span class="koboSpan" id="kobo.156.2">That was mainly because OpenGL 3.0 was supposed to deprecate the entire fixed-function pipeline from the OpenGL API, and it was simply an impossible task for the big players to make the sudden switch overnight from a fixed-function pipeline to a programmable pipeline. </span><span class="koboSpan" id="kobo.156.3">This resulted in two different major versions of OpenGL </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">being maintained.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">In this chapter, we will use the newer OpenGL 3 instead of the older, deprecated OpenGL 2. </span><span class="koboSpan" id="kobo.158.2">The coding style and syntax are very different between these two versions, which makes the switchover very troublesome. </span><span class="koboSpan" id="kobo.158.3">However, the performance improvement will make it worth the time it takes to switch over to </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">OpenGL 3.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.160.1">Hello World!</span></h1>
<p><span class="koboSpan" id="kobo.161.1">In this chapter, we </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.162.1">will learn how to use OpenGL 3 with Qt 6. </span><span class="koboSpan" id="kobo.162.2">Common OpenGL functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">glBegin</span></strong><span class="koboSpan" id="kobo.164.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">glVertex2f</span></strong><span class="koboSpan" id="kobo.166.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">glColor3f</span></strong><span class="koboSpan" id="kobo.168.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">glMatrixMode</span></strong><span class="koboSpan" id="kobo.170.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">glLoadIdentity</span></strong><span class="koboSpan" id="kobo.172.1"> have all been removed from OpenGL 3. </span><span class="koboSpan" id="kobo.172.2">OpenGL 3 uses </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">vertex buffer objects</span></strong><span class="koboSpan" id="kobo.174.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">VBOs</span></strong><span class="koboSpan" id="kobo.176.1">) to </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.177.1">send data to the GPU in batches instead of sending them one by one through functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">glVertex2f()</span></strong><span class="koboSpan" id="kobo.179.1">, which slows down the rendering while waiting for the CPU to submit the data one by one. </span><span class="koboSpan" id="kobo.179.2">Therefore, we will pack all of the data into VBOs and send it all in one huge package to the GPU and instruct the GPU to calculate the resulting pixels through shader programming. </span><span class="koboSpan" id="kobo.179.3">We will also be learning how to create simple </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">shader programs</span></strong><span class="koboSpan" id="kobo.181.1"> through</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.182.1"> a C-like programming</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.183.1"> language called </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">OpenGL Shading </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">Language</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.187.1">GLSL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">).</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.189.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.190.1">Let’s get started </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.191.1">by following </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.193.1">We will create a new class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">RenderWindow</span></strong><span class="koboSpan" id="kobo.195.1">, which inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">QOpenGLWindow</span></strong><span class="koboSpan" id="kobo.197.1"> class. </span><span class="koboSpan" id="kobo.197.2">Go to </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">File</span></strong><span class="koboSpan" id="kobo.199.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">New File</span></strong><span class="koboSpan" id="kobo.201.1">, then select </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">C++ Class</span></strong><span class="koboSpan" id="kobo.203.1"> under the </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Files and Classes</span></strong><span class="koboSpan" id="kobo.205.1"> category. </span><span class="koboSpan" id="kobo.205.2">Name the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">RenderWindow</span></strong><span class="koboSpan" id="kobo.207.1"> and set its base class as </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">QOpenGLWindow</span></strong><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">Then, proceed to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">C++ class:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.211.1"><img alt="Figure 5.2 – Defining your custom render window class" src="image/B20976_05_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">Figure 5.2 – Defining your custom render window class</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.213.1">Go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.215.1"> file we just created and add the following headers at the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
#include &lt;GL/glu.h&gt;
#include &lt;QtOpenGL&gt;
#include &lt;QSurfaceFormat&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLWindow&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.218.1">We need </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.219.1">to create several functions and variables that look </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
class RenderWindow : public QOpenGLWindow {
public:
    RenderWindow();
protected:
    </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">void initializeGL();</span></strong><span class="koboSpan" id="kobo.223.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">void paintGL();</span></strong><span class="koboSpan" id="kobo.225.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">void paintEvent(QPaintEvent *event);</span></strong><span class="koboSpan" id="kobo.227.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">void resizeEvent(QResizeEvent *event);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.229.1">We will continue and add some </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">private variables:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
private:
    </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">QOpenGLContext* openGLContext;</span></strong><span class="koboSpan" id="kobo.233.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">QOpenGLFunctions* openGLFunctions;</span></strong><span class="koboSpan" id="kobo.235.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">QOpenGLShaderProgram* shaderProgram;</span></strong><span class="koboSpan" id="kobo.237.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">QOpenGLVertexArrayObject* vao;</span></strong><span class="koboSpan" id="kobo.239.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">QOpenGLBuffer* vbo_vertices;</span></strong><span class="koboSpan" id="kobo.241.1">
};</span></pre></li> <li><span class="koboSpan" id="kobo.242.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">renderwindow.cpp</span></strong><span class="koboSpan" id="kobo.244.1"> and define the class constructor as follows. </span><span class="koboSpan" id="kobo.244.2">We must tell the</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.245.1"> render window to use the OpenGL surface type; enable </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">core profile</span></strong><span class="koboSpan" id="kobo.247.1"> (rather than </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">compatibility profile</span></strong><span class="koboSpan" id="kobo.249.1">) that runs version 3.2; create an OpenGL context; and, finally, apply the profile we just created into </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the context:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
RenderWindow::RenderWindow() {
    setSurfaceType(QWindow::OpenGLSurface);
    QSurfaceFormat format;
    format.setProfile(QSurfaceFormat::CoreProfile);
    format.setVersion(3, 2);
    setFormat(format);
    openGLContext = new QOpenGLContext();
    openGLContext-&gt;setFormat(format);
    openGLContext-&gt;create();
    openGLContext-&gt;makeCurrent(this);
}</span></pre></li> <li><span class="koboSpan" id="kobo.252.1">We need to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.254.1"> function as follows. </span><span class="koboSpan" id="kobo.254.2">This function will be called before the rendering starts. </span><span class="koboSpan" id="kobo.254.3">First, we</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.255.1"> define the </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">vertex shader</span></strong><span class="koboSpan" id="kobo.257.1"> and</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.258.1"> the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.259.1">fragment shader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
void RenderWindow::initializeGL() {
    openGLFunctions = openGLContext-&gt;functions();
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec2 posAttr;\n"
    "void main() {\n"
    "gl_Position = vec4(posAttr, 0.0, 1.0); }";
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    "out vec4 col;\n"
    "void main() {\n"
    "col = vec4(1.0, 0.0, 0.0, 1.0); }";</span></pre></li> <li><span class="koboSpan" id="kobo.262.1">We</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.263.1"> initiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">shaderProgram</span></strong><span class="koboSpan" id="kobo.265.1"> and declare a vertices array. </span><span class="koboSpan" id="kobo.265.2">Then, we also create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">QOpenGLVertexArrayObject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
    shaderProgram = new QOpenGLShaderProgram(this);
    shaderProgram-&gt;addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource);
    shaderProgram-&gt;addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource);
    shaderProgram-&gt;link();
// The vertex coordinates of our triangle
    GLfloat vertices[] = {
    -1.0f, -1.0f,
    1.0f, -1.0f,
    0.0f, 1.0f };
    vao = new QOpenGLVertexArrayObject();
    vao-&gt;create();
    vao-&gt;bind();</span></pre></li> <li><span class="koboSpan" id="kobo.269.1">Let’s continue to write our code by </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">defining </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">vbo_vertices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.273.1">
    vbo_vertices = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_vertices-&gt;create();
    vbo_vertices-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_vertices-&gt;bind();
    vbo_vertices-&gt;allocate(vertices, sizeof(vertices) *
    sizeof(GLfloat));
    vao-&gt;release();
}</span></pre></li> <li><span class="koboSpan" id="kobo.274.1">We will </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.275.1">start by adding some code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">paintEvent()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.278.1">
void RenderWindow::paintEvent(QPaintEvent *event) {
    Q_UNUSED(event);
    glViewport(0, 0, width(), height());
    // Clear our screen with corn flower blue color
    glClearColor(0.39f, 0.58f, 0.93f, 1.f);
    glClear(GL_COLOR_BUFFER_BIT);</span></pre></li> <li><span class="koboSpan" id="kobo.279.1">We will then bind the VAO and shader program before </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">glDrawArrays()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.283.1">
    vao-&gt;bind();
    shaderProgram-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    shaderProgram-&gt;release();
    vao-&gt;release();
}</span></pre></li> <li><span class="koboSpan" id="kobo.284.1">You can</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.285.1"> refresh the viewport whenever the render window is being resized by adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.287.1">
void RenderWindow::resizeEvent(QResizeEvent *event) {
    Q_UNUSED(event);
    glViewport(0, 0, this-&gt;width(), this-&gt;height());
    this-&gt;update();
}</span></pre></li> <li><span class="koboSpan" id="kobo.288.1">If you compile and run the project now, you should be able to see a red rectangle being drawn in front of a </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">blue background:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.290.1"><img alt="Figure 5.3 - Our first triangle rendered in OpenGL" src="image/B20976_05_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">Figure 5.3 - Our first triangle rendered in OpenGL</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.292.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.293.1">We must set the </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.294.1">OpenGL version to 3.x and the surface format to the core profile so that we can access the newer shader pipeline, which is completely different from the older, deprecated compatibility profile. </span><span class="koboSpan" id="kobo.294.2">OpenGL 2.x still exists in the compatibility profile, solely for the sake of allowing OpenGL programs to run on old hardware. </span><span class="koboSpan" id="kobo.294.3">The profile that’s created must be applied to the OpenGL context before it </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">will work.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">In OpenGL 3 and the later versions, most of the calculations are done in the GPU through shader programs, since all of the common fixed functions have now been completely deprecated. </span><span class="koboSpan" id="kobo.296.2">Therefore, we created a very simple vertex shader and fragment shader in the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">preceding example.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">A shader program consists of three different parts: </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">geometry shader</span></strong><span class="koboSpan" id="kobo.300.1"> (optional), vertex shader, and </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.301.1">fragment shader. </span><span class="koboSpan" id="kobo.301.2">The geometry shader calculates the creation of geometry before passing the data to the vertex shader; the vertex shader handles the position and motion of the vertices before passing the data to the fragment shader; and finally, the fragment shader calculates and displays the resulting pixels on </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">In the preceding example, we </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.304.1">only used vertex and fragment shaders and excluded the geometry shader since it is optional. </span><span class="koboSpan" id="kobo.304.2">You can save the GLSL code in a text file and load it into your Qt 6 program by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">addShaderFromFile()</span></strong><span class="koboSpan" id="kobo.306.1">, but since our shaders are very simple and short, we just define it directly in our C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">After that, we use the VBO to store the vertex positions in bulk before sending it to the GPU. </span><span class="koboSpan" id="kobo.308.2">We can also use the VBO to store other information such as normals, texture coordinates, and vertex colors. </span><span class="koboSpan" id="kobo.308.3">You can send anything you want to the GPU as long as it matches the input inside your shader code. </span><span class="koboSpan" id="kobo.308.4">Then, we add the VBO into a </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">vertex array object</span></strong><span class="koboSpan" id="kobo.310.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.311.1">VAO</span></strong><span class="koboSpan" id="kobo.312.1">) and</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.313.1"> send the whole VAO to the GPU for processing. </span><span class="koboSpan" id="kobo.313.2">You can add many different VBOs into the VAO since the VAO is just like any ordinary </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">C++ array.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Just like what we have learned in the previous chapters, all drawings happen within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.317.1"> function, and it will only be called by Qt when it thinks it is necessary to refresh the screen. </span><span class="koboSpan" id="kobo.317.2">To force Qt to update the screen, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">update()</span></strong><span class="koboSpan" id="kobo.319.1"> manually. </span><span class="koboSpan" id="kobo.319.2">Also, we must update the viewport whenever the window screen has been resized by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">glViewport(x, y ,</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">width, height)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.323.1">Rendering 2D shapes</span></h1>
<p><span class="koboSpan" id="kobo.324.1">Since we </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.325.1">have already learned how to draw our first rectangle on screen, we will further enhance it in this section. </span><span class="koboSpan" id="kobo.325.2">We will take the previous example and continue </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">from there.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.327.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.328.1">Let’s get started by following </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">this example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.330.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.332.1"> and add two more VBOs, one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">vbo_vertices2</span></strong><span class="koboSpan" id="kobo.334.1"> and another called </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">vbo_colors</span></strong><span class="koboSpan" id="kobo.336.1">, as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.338.1">
private:
    QOpenGLContext* openGLContext;
    QOpenGLFunctions* openGLFunctions;
    QOpenGLShaderProgram* shaderProgram;
    QOpenGLVertexArrayObject* vao;
    QOpenGLBuffer* vbo_vertices;
    </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">QOpenGLBuffer* vbo_vertices2;</span></strong><span class="koboSpan" id="kobo.340.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">QOpenGLBuffer* vbo_colors;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.342.1">Open</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.343.1"> up </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">renderwindow.cpp</span></strong><span class="koboSpan" id="kobo.345.1"> and add the following code to the shader code, as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.347.1">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec2 posAttr;\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">"layout(location = 1) in vec3 colAttr;\n"</span></strong><span class="koboSpan" id="kobo.349.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">"out vec3 fragCol;\n"</span></strong><span class="koboSpan" id="kobo.351.1">
    "void main() {\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">"fragCol = colAttr;\n"</span></strong><span class="koboSpan" id="kobo.353.1">
    "gl_Position = vec4(posAttr, 1.0, 1.0); }";</span></pre></li> <li><span class="koboSpan" id="kobo.354.1">Add the highlighted code to the fragment shader, which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">"in vec3 fragCol;\n"</span></strong><span class="koboSpan" id="kobo.358.1">
    "out vec4 col;\n"
    "void main() {\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">"col = vec4(fragCol, 1.0); }";</span></strong></pre></li> <li><span class="koboSpan" id="kobo.360.1">Change </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.361.1">the vertices array to something like the following code. </span><span class="koboSpan" id="kobo.361.2">What we’re doing here is creating three arrays that keep the vertices of two triangles and their colors so that we can pass them to the fragment shader at a </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">later stage:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
    GLfloat vertices[] = {
    -0.3f, -0.5f,
    0.8f, -0.4f,
    0.2f, 0.6f };
    GLfloat vertices2[] = {
    0.5f, 0.3f,
    0.4f, -0.8f,
    -0.6f, -0.2f };
    GLfloat colors[] = {
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f };</span></pre></li> <li><span class="koboSpan" id="kobo.364.1">Since we already initialized </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">vbo_vertices</span></strong><span class="koboSpan" id="kobo.366.1"> in the previous example, this time, we only need to initialize two other VBOs, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">vbo_vertices</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.368.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">vbo_colors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
    vbo_vertices2 = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_vertices2-&gt;create();
    vbo_vertices2-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_vertices2-&gt;bind();
    vbo_vertices2-&gt;allocate(vertices2, sizeof(vertices2) *
    sizeof(GLfloat));
    vbo_colors = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_colors-&gt;create();
    vbo_colors-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_colors-&gt;bind();
    vbo_colors-&gt;allocate(colors, sizeof(colors) * sizeof(GLfloat));</span></pre></li> <li><span class="koboSpan" id="kobo.372.1">Before </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.373.1">we start drawing the triangle using </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">glDrawArrays()</span></strong><span class="koboSpan" id="kobo.375.1">, we must also add the data of </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">vbo_colors</span></strong><span class="koboSpan" id="kobo.377.1"> into our shader’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">colAttr</span></strong><span class="koboSpan" id="kobo.379.1"> attribute. </span><span class="koboSpan" id="kobo.379.2">Make sure you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">bind()</span></strong><span class="koboSpan" id="kobo.381.1"> to set the VBO as the current active VBO, before sending the data to the shader. </span><span class="koboSpan" id="kobo.381.2">The location ID (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">0</span></strong><span class="koboSpan" id="kobo.383.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">1</span></strong><span class="koboSpan" id="kobo.385.1">) must match the location ID that’s used in </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">your shader:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.387.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">vbo_vertices-&gt;bind();</span></strong><span class="koboSpan" id="kobo.389.1">
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">vbo_colors-&gt;bind();</span></strong><span class="koboSpan" id="kobo.391.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">shaderProgram-&gt;bindAttributeLocation("colAttr", 1);</span></strong><span class="koboSpan" id="kobo.393.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">shaderProgram-&gt;enableAttributeArray(1);</span></strong><span class="koboSpan" id="kobo.395.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 3);</span></strong><span class="koboSpan" id="kobo.397.1">
    glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre></li> <li><span class="koboSpan" id="kobo.398.1">Right after the</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.399.1"> preceding code, we will send </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">vbo_vertices2</span></strong><span class="koboSpan" id="kobo.401.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">vbo_colors</span></strong><span class="koboSpan" id="kobo.403.1"> to the shader attribute and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">glDrawArrays()</span></strong><span class="koboSpan" id="kobo.405.1"> again to draw the </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">second triangle:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
    vbo_vertices2-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    vbo_colors-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("colAttr", 1);
    shaderProgram-&gt;enableAttributeArray(1);
    shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 3);
    glDrawArrays(GL_TRIANGLES, 0, 3);</span></pre></li> <li><span class="koboSpan" id="kobo.408.1">If you build the program now, you should be able to see two triangles on screen, and one of the triangles sitting on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the other:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 5.4 – Two colorful triangles overlapping each other" src="image/B20976_05_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 5.4 – Two colorful triangles overlapping each other</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.412.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.413.1">The geometric primitive</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.414.1"> types supported by OpenGL are points, lines, line strips, line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle fans. </span><span class="koboSpan" id="kobo.414.2">In this example, we drew two triangles, where each of the shapes is provided with a set of vertices and colors so that OpenGL knows how the shapes should </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">be rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">The rainbow color effect is created by giving a different color to each of the vertices. </span><span class="koboSpan" id="kobo.416.2">OpenGL will automatically interpolate the colors between each vertex and display it on screen. </span><span class="koboSpan" id="kobo.416.3">Currently, the shape that gets rendered first will appear at the back of other shapes that get rendered later. </span><span class="koboSpan" id="kobo.416.4">This is because we are rendering the shapes in a 2D space and no depth information is involved to check which shape is located at the front and so on. </span><span class="koboSpan" id="kobo.416.5">We will learn how to do depth checking in the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">following example.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.418.1">Rendering 3D shapes</span></h1>
<p><span class="koboSpan" id="kobo.419.1">We learned</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.420.1"> how to draw simple 2D shapes onscreen in the previous section. </span><span class="koboSpan" id="kobo.420.2">However, to fully utilize the OpenGL API, we also need to learn how to use it to render 3D images. </span><span class="koboSpan" id="kobo.420.3">In a nutshell, 3D images are simply illusions that are created using 2D shapes, stacked in such a way that it makes them look like </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">they’re 3D.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.422.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.423.1">The main ingredient here is the depth value, which determines which shapes should appear in front of or behind the other shapes. </span><span class="koboSpan" id="kobo.423.2">The primitive shape that is positioned behind another surface (with a shallower depth than another shape) will not be rendered (or will be partially rendered). </span><span class="koboSpan" id="kobo.423.3">OpenGL provides a simple way to </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">achieve this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.425.1">Let’s continue our project from the previous 2D example. </span><span class="koboSpan" id="kobo.425.2">Enable depth testing by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">glEnable(GL_DEPTH_TEST)</span></strong><span class="koboSpan" id="kobo.427.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.429.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">renderwindow.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.433.1">
void RenderWindow::initializeGL() {
    openGLFunctions = openGLContext-&gt;functions();
    </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">glEnable(GL_DEPTH_TEST);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.435.1">Since we have enabled </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">GL_DEPTH_TEST</span></strong><span class="koboSpan" id="kobo.437.1"> in the preceding step, we must also set the depth buffer size when setting the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">OpenGL profile:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.439.1">
    QSurfaceFormat format;
    format.setProfile(QSurfaceFormat::CoreProfile);
    format.setVersion(3, 2);
    </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">format.setDepthBufferSize(16);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.441.1">We will change our vertices array into something longer, which is the vertex information of a 3D cube shape. </span><span class="koboSpan" id="kobo.441.2">The vertex coordinates in the next code block are divided into three values per vertex coordinate, which eventually form a 3D cube. </span><span class="koboSpan" id="kobo.441.3">It’s not realistic to hardcode the vertices of complex shapes, but achievable for simple shapes like this. </span><span class="koboSpan" id="kobo.441.4">We can remove the colors array for now since you are not supplying the color information to the shader this time. </span><span class="koboSpan" id="kobo.441.5">We can also</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.442.1"> remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">vbo_colors</span></strong><span class="koboSpan" id="kobo.444.1"> VBO for the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">same reason:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.446.1">
    GLfloat vertices[] = {
     -1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f, 1.0f,
     1.0f,-1.0f,-1.0f,1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f,
     -1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f,-1.0f,
     1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f, 1.0f,
     -1.0f,-1.0f, 1.0f,1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,
     1.0f,-1.0f, 1.0f,1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f,
     -1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f,-1.0f,-1.0f,
     1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f, 1.0f,-1.0f,
     -1.0f,-1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f,-1.0f,-1.0f,
     -1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,
     1.0f,-1.0f, 1.0f,1.0f,-1.0f,-1.0f,1.0f, 1.0f,-1.0f,
     1.0f,-1.0f, 1.0f,1.0f, 1.0f,-1.0f,1.0f, 1.0f, 1.0f
 };</span></pre></li> <li><span class="koboSpan" id="kobo.447.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.449.1"> function, we must add </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">GL_DEPTH_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.451.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">glClear()</span></strong><span class="koboSpan" id="kobo.453.1"> function</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.454.1"> since we enabled depth checking in </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.456.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">previous step:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
glClear(GL_</span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">COLOR</span></strong><span class="koboSpan" id="kobo.460.1">_BUFFER_BIT | </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">GL_DEPTH_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.462.1">);</span></pre></li> <li><span class="koboSpan" id="kobo.463.1">After that, we need to send a piece of matrix information to the shader called </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">ModelView-Projection</span></strong><span class="koboSpan" id="kobo.465.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.466.1">MVP</span></strong><span class="koboSpan" id="kobo.467.1">) so that </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.468.1">the GPU knows how to render the 3D shapes on a 2D screen. </span><span class="koboSpan" id="kobo.468.2">The MVP matrix is the result of multiplication between the projection matrix, view matrix, and model matrix. </span><span class="koboSpan" id="kobo.468.3">The multiplication order is very important so that you get the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">correct result:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(0, 1, 0);
    model.rotate(45, 0, 1, 0);
    view.lookAt(QVector3D(4, 4, 0), QVector3D(0, 0, 0),
    QVector3D(0, 1, 0));
    projection.perspective(60.0f,
     ((float)this-&gt;width()/(float)this-&gt;height()), 0.1f, 100.0f);
    matrixMVP = projection * view * model;
    shaderProgram-&gt;setUniformValue("matrix", matrixMVP);</span></pre></li> <li><span class="koboSpan" id="kobo.471.1">Change the last value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">glDrawArrays()</span></strong><span class="koboSpan" id="kobo.473.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">36</span></strong><span class="koboSpan" id="kobo.475.1"> since we now have 36 triangles in the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">cube shape:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.477.1">
    glDrawArrays(GL_TRIANGLES, 0, 36);</span></pre></li> <li><span class="koboSpan" id="kobo.478.1">We have to go back to our shader code and change some parts of it, as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec3 posAttr;\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">"uniform mat4 matrix;\n"</span></strong><span class="koboSpan" id="kobo.482.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">"out vec3 fragPos;\n"</span></strong><span class="koboSpan" id="kobo.484.1">
    "void main() {\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">"fragPos = posAttr;\n"</span></strong><span class="koboSpan" id="kobo.486.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">"gl_Position = matrix * vec4(posAttr, 1.0); }";</span></strong><span class="koboSpan" id="kobo.488.1">
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">"in vec3 fragPos;\n"</span></strong><span class="koboSpan" id="kobo.490.1">
    "out vec4 col;\n"
    "void main() {\n"
    </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">"col = vec4(fragPos, 1.0); }";</span></strong></pre></li> <li><span class="koboSpan" id="kobo.492.1">If you build </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.493.1">and run the project now, you should see a colorful cube appear on the screen. </span><span class="koboSpan" id="kobo.493.2">We use the same vertices array for the color, which gives this </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">colorful result:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.495.1"><img alt="Figure 5.5 – Colorful 3D cube rendered with OpenGL" src="image/B20976_05_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.496.1">Figure 5.5 – Colorful 3D cube rendered with OpenGL</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.497.1">Even though</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.498.1"> the result looks pretty good, if we want to really show off the 3D effect, it would be by animating the cube. </span><span class="koboSpan" id="kobo.498.2">To do that, first, we need to open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.500.1"> and include the following header </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">to it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#include &lt;QElapsedTimer&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.503.1">Then, add the following variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">Note that you are allowed to initialize variables in the header file in modern C++ standard, which was not the case back in the older </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">C++ standard:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
    QElapsedTimer* time;
    int currentTime = 0;
    int oldTime = 0;
    float deltaTime = 0;
    float rotation = 0;</span></pre></li> <li><span class="koboSpan" id="kobo.508.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">renderwindow.cpp</span></strong><span class="koboSpan" id="kobo.510.1"> and add the following highlighted code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">class constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
    openGLContext = new QOpenGLContext();
    openGLContext-&gt;setFormat(format);
    openGLContext-&gt;create();
    openGLContext-&gt;makeCurrent(this);
    </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">time = new QElapsedTimer();</span></strong><span class="koboSpan" id="kobo.514.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">time-&gt;start();</span></strong></pre></li> <li><span class="koboSpan" id="kobo.516.1">After that, add</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.517.1"> the following highlighted code to the top of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.519.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">deltaTime</span></strong><span class="koboSpan" id="kobo.521.1"> is the value of the elapsed time of each frame, which is used to make animation speed consistent, regardless of frame </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">rate performance:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.523.1">
void RenderWindow::paintEvent(QPaintEvent *event) {
    Q_UNUSED(event);
    </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">// Delta time for each frame</span></strong><span class="koboSpan" id="kobo.525.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">currentTime = time-&gt;elapsed();</span></strong><span class="koboSpan" id="kobo.527.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">deltaTime = (float)(currentTime - oldTime) / 1000.0f;</span></strong><span class="koboSpan" id="kobo.529.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">oldTime = currentTime;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.531.1">Add the following highlighted code on top of your MVP matrix code and apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">rotation</span></strong><span class="koboSpan" id="kobo.533.1"> variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">rotate()</span></strong><span class="koboSpan" id="kobo.535.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.537.1">
    rotation += deltaTime * 50;
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(0, 1, 0);
    model.rotate(rotation, 0, 1, 0);</span></pre></li> <li><span class="koboSpan" id="kobo.538.1">Call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">update()</span></strong><span class="koboSpan" id="kobo.540.1"> function</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.541.1"> at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.543.1"> function so that </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.545.1"> will be called again and again at the end of each draw call. </span><span class="koboSpan" id="kobo.545.2">Since we are changing the rotation value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.547.1"> function, we can give the viewer the illusion of a </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">rotating cube:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.549.1">
    glDrawArrays(GL_TRIANGLES, 0, 36);
    shaderProgram-&gt;release();
    vao-&gt;release();
    </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">this-&gt;update();</span></strong><span class="koboSpan" id="kobo.551.1">
}</span></pre></li> <li><span class="koboSpan" id="kobo.552.1">If you compile and run the program now, you should see a spinning cube in your </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">render window!</span></span></li>
</ol>
<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.554.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.555.1">In any 3D rendering, depth is very important and hence we need to enable the depth testing feature in OpenGL by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">glEnable(GL_DEPTH_TEST)</span></strong><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">When we clear the buffer, we must also specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">GL_DEPH_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.559.1"> so that the depth information is also being cleared, in order for the next image to be </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">rendered correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">We use the MVP matrix in OpenGL so that the GPU knows how to render the 3D graphics correctly. </span><span class="koboSpan" id="kobo.561.2">In OpenGL 3 and later versions, OpenGL no longer handles this automatically through fixed functions. </span><span class="koboSpan" id="kobo.561.3">Programmers are given the freedom and flexibility to define their own matrices based on their use cases, and then simply supply it to the GPU through a shader for rendering the final image. </span><span class="koboSpan" id="kobo.561.4">The model matrix contains the transformation data of the 3D object, namely the position, rotation, and scale of the object. </span><span class="koboSpan" id="kobo.561.5">The view matrix, on the other hand, is the camera or view information. </span><span class="koboSpan" id="kobo.561.6">Lastly, the projection matrix tells the GPU which projection method to use when projecting the 3D world onto the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">2D screen.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">In our example, we used the perspective projection method, which gives a better perception of distance and depth. </span><span class="koboSpan" id="kobo.563.2">The opposite of perspective projection is </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">orthographic projection</span></strong><span class="koboSpan" id="kobo.565.1">, which</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.566.1"> makes everything look flat </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">and parallel:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.568.1"><img alt="Figure 5.6 – Differences between perspective and orthographic views" src="image/B20976_05_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.569.1">Figure 5.6 – Differences between perspective and orthographic views</span></p>
<p><span class="koboSpan" id="kobo.570.1">In this example, we used a timer to increase the rotation value by 50 by multiplying it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">deltaTime</span></strong><span class="koboSpan" id="kobo.572.1"> value. </span><span class="koboSpan" id="kobo.572.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">deltaTime</span></strong><span class="koboSpan" id="kobo.574.1"> value varies, depending on your rendering frame rate. </span><span class="koboSpan" id="kobo.574.2">However, it makes the resulting animation speed consistent across different hardware that renders at a different </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">frame rate.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">Remember to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">update()</span></strong><span class="koboSpan" id="kobo.578.1"> manually so that the screen gets refreshed, otherwise the cube will not </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">be animated.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.580.1">Texturing in OpenGL</span></h1>
<p><span class="koboSpan" id="kobo.581.1">OpenGL allows us to map an image (also referred to as a </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">texture</span></strong><span class="koboSpan" id="kobo.583.1">) to a 3D shape or polygon. </span><span class="koboSpan" id="kobo.583.2">This process is also called texture mapping. </span><span class="koboSpan" id="kobo.583.3">Qt 6 appears to be the best combination</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.584.1"> with OpenGL in this case because it provides an easy way to load images that belong to one of the common formats (</span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">BMP</span></strong><span class="koboSpan" id="kobo.586.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">JPEG</span></strong><span class="koboSpan" id="kobo.588.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">PNG</span></strong><span class="koboSpan" id="kobo.590.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">TARGA</span></strong><span class="koboSpan" id="kobo.592.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">TIFF</span></strong><span class="koboSpan" id="kobo.594.1">, and so on), and you do not have to implement it by yourself. </span><span class="koboSpan" id="kobo.594.2">We will use the previous example with a spinning cube and try to map it with </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">a texture!</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.596.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.597.1">Let’s follow</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.598.1"> these steps to learn how to use textures </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">in OpenGL:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.600.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.602.1"> and add the variables that are highlighted in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">code block:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
    QOpenGLContext* openGLContext;
    QOpenGLFunctions* openGLFunctions;
    QOpenGLShaderProgram* shaderProgram;
    QOpenGLVertexArrayObject* vao;
    QOpenGLBuffer* vbo_vertices;
    </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">QOpenGLBuffer* vbo_uvs;</span></strong><span class="koboSpan" id="kobo.606.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">QOpenGLTexture* texture;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.608.1">We must call </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">glEnable(GL_TEXTURE_2D)</span></strong><span class="koboSpan" id="kobo.610.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.612.1"> function to enable the texture </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">mapping feature:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.614.1">
void RenderWindow::initializeGL()
{
    openGLFunctions = openGLContext-&gt;functions();
    glEnable(GL_DEPTH_TEST);
    </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">glEnable(GL_TEXTURE_2D);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.616.1">We need to initialize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">texture</span></strong><span class="koboSpan" id="kobo.618.1"> variable under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">QOpenGLTexture</span></strong><span class="koboSpan" id="kobo.620.1"> class. </span><span class="koboSpan" id="kobo.620.2">We will load a texture called </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">brick.jpg</span></strong><span class="koboSpan" id="kobo.622.1"> from our application folder and flip the image by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">mirrored()</span></strong><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">OpenGL uses a different coordinate system, which is why we need to flip our texture before passing it to the shader. </span><span class="koboSpan" id="kobo.624.3">We will</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.625.1"> also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">min</span></strong><span class="koboSpan" id="kobo.627.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">max</span></strong><span class="koboSpan" id="kobo.629.1"> filters to </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">Nearest</span></strong><span class="koboSpan" id="kobo.631.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">Linear</span></strong><span class="koboSpan" id="kobo.633.1"> accordingly, </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
    texture = new QOpenGLTexture(QImage(qApp-&gt;applicationDirPath() + "/brick.jpg").mirrored());
    texture-&gt;setMinificationFilter(QOpenGLTexture::Nearest);
    texture-&gt;setMagnificationFilter(QOpenGLTexture::Linear);</span></pre></li> <li><span class="koboSpan" id="kobo.636.1">Add another </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.637.1">array called </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">uvs</span></strong><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">This is where we save the texture coordinates for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">cube</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
    GLfloat uvs[] = {
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,
     0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,
     1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f
};</span></pre></li> <li><span class="koboSpan" id="kobo.643.1">We have to amend our vertex shader so that it takes in the texture coordinates for calculating where the texture will be applied to the object’s surface. </span><span class="koboSpan" id="kobo.643.2">Here, we simply pass the texture coordinate to the fragment shader </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">without modifying:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec3 posAttr;\n"
    "layout(location = 1) in vec2 uvAttr;\n"
    "uniform mat4 matrix;\n"
    "out vec3 fragPos;\n"
    "out vec2 fragUV;\n"
    "void main() {\n"
    "fragPos = posAttr;\n"
    "fragUV = uvAttr;\n"
    "gl_Position = matrix * vec4(posAttr, 1.0); }";</span></pre></li> <li><span class="koboSpan" id="kobo.646.1">In the</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.647.1"> fragment shader, we create a</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.648.1"> texture by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">texture()</span></strong><span class="koboSpan" id="kobo.650.1"> function, which receives the texture coordinate information from </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">fragUV</span></strong><span class="koboSpan" id="kobo.652.1"> and the image sampler </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">tex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.656.1">
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    "in vec3 fragPos;\n"
    "in vec2 fragUV;\n"
    "uniform sampler2D tex;\n"
    "out vec4 col;\n"
    "void main() {\n"
    "vec4 texCol = texture(tex, fragUV);\n"
    "col = texCol; }";</span></pre></li> <li><span class="koboSpan" id="kobo.657.1">We have to initialize the VBO for the texture coordinate </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">as well:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
    vbo_uvs = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_uvs-&gt;create();
    vbo_uvs-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_uvs-&gt;bind();
    vbo_uvs-&gt;allocate(uvs, sizeof(uvs) * sizeof(GLfloat));</span></pre></li> <li><span class="koboSpan" id="kobo.660.1">In</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.661.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.663.1"> function, we</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.664.1"> must send the texture coordinate information to the shader and then bind the texture before </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">glDrawArrays()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.668.1">
    vbo_uvs-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("uvAttr", 1);
    shaderProgram-&gt;enableAttributeArray(1);
    shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 2);
    texture-&gt;bind();
    glDrawArrays(GL_TRIANGLES, 0, 36);</span></pre></li> <li><span class="koboSpan" id="kobo.669.1">If you compile and run the program now, you should see a brick cube rotating on </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the screen:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.671.1"><img alt="Figure 5.7 – Our 3D cube now looks like it was created from bricks" src="image/B20976_05_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.672.1">Figure 5.7 – Our 3D cube now looks like it was created from bricks</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.673.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.674.1">Qt 6 makes</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.675.1"> loading textures a really easy job. </span><span class="koboSpan" id="kobo.675.2">All it takes is just a single line of code to load an image file, flip it, and convert it into an </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.676.1">OpenGL-compatible texture. </span><span class="koboSpan" id="kobo.676.2">The texture coordinates are pieces of information that let OpenGL know how to stick the texture onto the object’s surface before displaying it </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">on screen.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">min</span></strong><span class="koboSpan" id="kobo.680.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">max</span></strong><span class="koboSpan" id="kobo.682.1"> filters are filters that make the texture look better when it is applied on a surface that is bigger than what its resolution can cover. </span><span class="koboSpan" id="kobo.682.2">The default setting for this is </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">GL_NEAREST</span></strong><span class="koboSpan" id="kobo.684.1">, which </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.685.1">stands for </span><strong class="bold"><span class="koboSpan" id="kobo.686.1">nearest neighbor filtering</span></strong><span class="koboSpan" id="kobo.687.1">. </span><span class="koboSpan" id="kobo.687.2">This filter tends to make textures look pixelated when viewed close up. </span><span class="koboSpan" id="kobo.687.3">Another common setting is </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">GL_LINEAR</span></strong><span class="koboSpan" id="kobo.689.1">, which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">bilinear filtering</span></strong><span class="koboSpan" id="kobo.691.1">. </span><span class="koboSpan" id="kobo.691.2">This filter takes two</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.692.1"> neighboring fragments and interpolates </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.693.1">them to create an approximated color, which looks</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.694.1"> a lot better </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">GL_NEAREST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.698.1"><img alt="Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR" src="image/B20976_05_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.699.1">Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.700.1">Basic lighting in OpenGL</span></h1>
<p><span class="koboSpan" id="kobo.701.1">In this</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.702.1"> example, we will learn how to add a simple point light to our 3D scene by using OpenGL and </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">Qt 6.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.704.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.705.1">Let’s get started</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.706.1"> by following </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.708.1">Again, we will use the previous example and add a point light near the spinning cube. </span><span class="koboSpan" id="kobo.708.2">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.710.1"> and add another variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">vbo_normals</span></strong><span class="koboSpan" id="kobo.712.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.714.1">
    QOpenGLBuffer* vbo_uvs;
    </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">QOpenGLBuffer* vbo_normals;</span></strong><span class="koboSpan" id="kobo.716.1">
    QOpenGLTexture* texture;</span></pre></li> <li><span class="koboSpan" id="kobo.717.1">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">renderwindow.cpp</span></strong><span class="koboSpan" id="kobo.719.1"> and add another array called </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">normals</span></strong><span class="koboSpan" id="kobo.721.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">initializeGL()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
    GLfloat normals[] = {
     0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,
     0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,
     0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
     -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
     0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f,
     0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f
};</span></pre></li> <li><span class="koboSpan" id="kobo.725.1">Initialize </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.726.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">vbo_normals</span></strong><span class="koboSpan" id="kobo.728.1"> VBO</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.729.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">initializeGL()</span></strong><span class="koboSpan" id="kobo.731.1"> by adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.733.1">
    vbo_normals = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_normals-&gt;create();
    vbo_normals-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_normals-&gt;bind();
    vbo_normals-&gt;allocate(normals, sizeof(normals) * sizeof(GLfloat));</span></pre></li> <li><span class="koboSpan" id="kobo.734.1">Since</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.735.1"> the shader we will be writing this</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.736.1"> time will be much longer than what we used in the previous examples, let’s move the shader code over to text files and load them into the program by </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">addShaderFromSourceFile()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
    shaderProgram = new QOpenGLShaderProgram(this);
    shaderProgram-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex,
    qApp-&gt;applicationDirPath() + "/vertex.txt");
    shaderProgram-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment,
    qApp-&gt;applicationDirPath() + "/fragment.txt");
shaderProgram-&gt;link();</span></pre></li> <li><span class="koboSpan" id="kobo.741.1">Once you are done with that, add the following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.743.1"> function to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">normals</span></strong><span class="koboSpan" id="kobo.745.1"> VBO over to </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">the shader:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
    vbo_normals-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("normalAttr", 2);
    shaderProgram-&gt;enableAttributeArray(2);
    shaderProgram-&gt;setAttributeBuffer(2, GL_FLOAT, 0, 3);</span></pre></li> <li><span class="koboSpan" id="kobo.748.1">Let’s open up the two text files we just created that contain the shader code. </span><span class="koboSpan" id="kobo.748.2">First, we need to make some changes to the vertex shader, </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
    #version 330 core
    layout(location = 0) in vec3 posAttr;
    layout(location = 1) in vec2 uvAttr;
    </span><strong class="bold"><span class="koboSpan" id="kobo.751.1">layout(location = 2) in vec3 normalAttr;</span></strong><span class="koboSpan" id="kobo.752.1">
    uniform mat4 matrix;
    out vec3 fragPos;
    out vec2 fragUV;
    </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">out vec3 fragNormal;</span></strong><span class="koboSpan" id="kobo.754.1">
void main() {
    fragPos = posAttr;
    fragUV = uvAttr;
    </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">fragNormal = normalAttr;</span></strong><span class="koboSpan" id="kobo.756.1">
    gl_Position = matrix * vec4(posAttr, 1.0);
}</span></pre></li> <li><span class="koboSpan" id="kobo.757.1">We will </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.758.1">also make some changes to the fragment</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.759.1"> shader. </span><span class="koboSpan" id="kobo.759.2">We will create a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">calcPointLight()</span></strong><span class="koboSpan" id="kobo.761.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">shader code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
    #version 330 core
    in vec3 fragPos;
    in vec2 fragUV;
    </span><strong class="bold"><span class="koboSpan" id="kobo.764.1">in vec3 fragNormal;</span></strong><span class="koboSpan" id="kobo.765.1">
    uniform sampler2D tex;
    out vec4 col;
    </span><strong class="bold"><span class="koboSpan" id="kobo.766.1">vec4 calcPointLight() {</span></strong><span class="koboSpan" id="kobo.767.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">vec4 texCol = texture(tex, fragUV);</span></strong><span class="koboSpan" id="kobo.769.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.770.1">vec3 lightPos = vec3(1.0, 2.0, 1.5);</span></strong><span class="koboSpan" id="kobo.771.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">vec3 lightDir = normalize(lightPos - fragPos);</span></strong><span class="koboSpan" id="kobo.773.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);</span></strong><span class="koboSpan" id="kobo.775.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">float lightIntensity = 1.0;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.777.1">Continuing </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.778.1">from the preceding</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.779.1"> code, we calculated the lighting using </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">calcPointLight()</span></strong><span class="koboSpan" id="kobo.781.1"> and output the resulting fragment to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">col</span></strong><span class="koboSpan" id="kobo.783.1"> variable, </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.785.1">
    // Diffuse
    float diffuseStrength = 1.0;
    float diff = clamp(dot(fragNormal, lightDir), 0.0, 1.0);
    vec4 diffuse = diffuseStrength * diff * texCol * lightColor * lightIntensity;
    return diffuse;
}
void main() {
    vec4 finalColor = calcPointLight();
    col = finalColor;
}</span></pre></li> <li><span class="koboSpan" id="kobo.786.1">If you compile and run the program now, you should see the lighting </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">in action:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.788.1"><img alt="Figure 5.9 – Our 3D cube now has shading" src="image/B20976_05_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.789.1">Figure 5.9 – Our 3D cube now has shading</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.790.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.791.1">In OpenGL 3 </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.792.1">and later versions, fixed-function lighting</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.793.1"> no longer exists. </span><span class="koboSpan" id="kobo.793.2">You can no longer call </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">glEnable(GL_LIGHT1)</span></strong><span class="koboSpan" id="kobo.795.1"> to add light to your 3D scene. </span><span class="koboSpan" id="kobo.795.2">The new method for adding light is to calculate your own lighting in the shader. </span><span class="koboSpan" id="kobo.795.3">This gives you the flexibility of creating all types of lights, depending on your needs. </span><span class="koboSpan" id="kobo.795.4">The old method has a limitation of up to 16 lights in most hardware but, with the new programmable pipeline, you can have any number of lights in the scene; however, the lighting model will need to be coded entirely by you in the shaders, which is not an </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">easy task.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">Other than that, we also need to add a surface normal value to every surface of the cube. </span><span class="koboSpan" id="kobo.797.2">Surface normal indicates where the surface is facing and is used for lighting calculations. </span><span class="koboSpan" id="kobo.797.3">The preceding example is very simplified to let you understand how lighting works in OpenGL. </span><span class="koboSpan" id="kobo.797.4">In actual use cases, you may need to pass some variables such as light intensity, light color, and light position from C++ or load it from a material file instead of hardcoding it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">shader code.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.799.1">Moving an object using keyboard controls</span></h1>
<p><span class="koboSpan" id="kobo.800.1">In this section, we </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.801.1">will be looking at how to move an object in OpenGL using keyboard controls. </span><span class="koboSpan" id="kobo.801.2">Qt provides an easy way to detect keyboard events using virtual functions, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">keyPressEvent()</span></strong><span class="koboSpan" id="kobo.803.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">keyReleaseEvent()</span></strong><span class="koboSpan" id="kobo.805.1">. </span><span class="koboSpan" id="kobo.805.2">We will be using the previous example and adding </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">to it.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.807.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.808.1">To move an </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.809.1">object using keyboard controls, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.811.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">renderwindow.h</span></strong><span class="koboSpan" id="kobo.813.1"> and declare two floating-point numbers called </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">moveX</span></strong><span class="koboSpan" id="kobo.815.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">moveZ</span></strong><span class="koboSpan" id="kobo.817.1">. </span><span class="koboSpan" id="kobo.817.2">Then, declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">QVector3D</span></strong><span class="koboSpan" id="kobo.819.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">movement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.823.1">
    QElapsedTimer* time;
    int currentTime = 0;
    int oldTime = 0;
    float deltaTime = 0;
    float rotation = 0;
    </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">float moveX = 0;</span></strong><span class="koboSpan" id="kobo.825.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">float moveZ = 0;</span></strong><span class="koboSpan" id="kobo.827.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">QVector3D movement = QVector3D(0, 0, 0);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.829.1">We will also declare two functions called </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">keyPressEvent()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.831.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">keyReleaseEvent()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.834.1">
protected:
    void initializeGL();
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *event);
    void keyPressEvent(QKeyEvent *event);
    void keyReleaseEvent(QKeyEvent *event);</span></pre></li> <li><span class="koboSpan" id="kobo.835.1">We will </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.836.1">implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">keyPressEvent()</span></strong><span class="koboSpan" id="kobo.838.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">renderwindow.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.842.1">
void RenderWindow::keyPressEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_W) { moveZ = -10; }
    if (event-&gt;key() == Qt::Key_S) { moveZ = 10; }
    if (event-&gt;key() == Qt::Key_A) { moveX = -10; }
    if (event-&gt;key() == Qt::Key_D) { moveX = 10; }
}</span></pre></li> <li><span class="koboSpan" id="kobo.843.1">We will also </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.844.1">implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">keyReleaseEvent()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.846.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.847.1">
void RenderWindow::keyReleaseEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_W) { moveZ = 0; }
    if (event-&gt;key() == Qt::Key_S) { moveZ = 0; }
    if (event-&gt;key() == Qt::Key_A) { moveX = 0; }
    if (event-&gt;key() == Qt::Key_D) { moveX = 0; }
}</span></pre></li> <li><span class="koboSpan" id="kobo.848.1">After that, we will comment out the rotation code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">paintEvent()</span></strong><span class="koboSpan" id="kobo.850.1"> and add the movement code, as highlighted in the following snippet. </span><span class="koboSpan" id="kobo.850.2">We do not want to get distracted by the rotation and just want to focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">the movement:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.852.1">
    //rotation += deltaTime * 50;
    movement.setX(movement.x() + moveX * deltaTime);
    movement.setZ(movement.z() + moveZ * deltaTime);
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(movement.x(), 1, movement.z());</span></pre></li> <li><span class="koboSpan" id="kobo.853.1">If you</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.854.1"> compile and run the program now, you should be able to move the cube around by pressing </span><em class="italic"><span class="koboSpan" id="kobo.855.1">W</span></em><span class="koboSpan" id="kobo.856.1">, </span><em class="italic"><span class="koboSpan" id="kobo.857.1">A</span></em><span class="koboSpan" id="kobo.858.1">, </span><em class="italic"><span class="koboSpan" id="kobo.859.1">S</span></em><span class="koboSpan" id="kobo.860.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.862.1">D</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">.</span></span></li>
</ol>
<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.864.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.865.1">What we did here was </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.866.1">constantly add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">moveX</span></strong><span class="koboSpan" id="kobo.868.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">moveZ</span></strong><span class="koboSpan" id="kobo.870.1"> values’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">movement</span></strong><span class="koboSpan" id="kobo.872.1"> vector’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">x</span></strong><span class="koboSpan" id="kobo.874.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">z</span></strong><span class="koboSpan" id="kobo.876.1"> values. </span><span class="koboSpan" id="kobo.876.2">When a key is pressed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">moveX</span></strong><span class="koboSpan" id="kobo.878.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">moveZ</span></strong><span class="koboSpan" id="kobo.880.1"> will become a positive or negative number, depending on which button is pressed; otherwise, it will be zero. </span><span class="koboSpan" id="kobo.880.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">keyPressEvent()</span></strong><span class="koboSpan" id="kobo.882.1"> function, we checked whether the keyboard button that was pressed was </span><em class="italic"><span class="koboSpan" id="kobo.883.1">W</span></em><span class="koboSpan" id="kobo.884.1">, </span><em class="italic"><span class="koboSpan" id="kobo.885.1">A</span></em><span class="koboSpan" id="kobo.886.1">, </span><em class="italic"><span class="koboSpan" id="kobo.887.1">S</span></em><span class="koboSpan" id="kobo.888.1">, or </span><em class="italic"><span class="koboSpan" id="kobo.889.1">D</span></em><span class="koboSpan" id="kobo.890.1">; we then set the variables accordingly. </span><span class="koboSpan" id="kobo.890.2">To get the full list of key names that are used by Qt, </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">visit </span></span><a href="http://doc.qt.io/qt-6/qt.html#Key-enum"><span class="No-Break"><span class="koboSpan" id="kobo.892.1">http://doc.qt.io/qt-6/qt.html#Key-enum</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.893.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">One way we can create movement input is by holding down the same key and not releasing it. </span><span class="koboSpan" id="kobo.894.2">Qt 6 will repeat the key press event after an interval, but it is not very fluid as modern operating systems limit the key press event to prevent double typing. </span><span class="koboSpan" id="kobo.894.3">The keyboard input interval varies between different operating systems. </span><span class="koboSpan" id="kobo.894.4">You can set the interval by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">QApplication::setKeyboardInterval()</span></strong><span class="koboSpan" id="kobo.896.1">, but this may not work on every operating system. </span><span class="koboSpan" id="kobo.896.2">Therefore, we did not go for </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">this method.</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">Instead, we only set </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">moveX</span></strong><span class="koboSpan" id="kobo.900.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">moveZ</span></strong><span class="koboSpan" id="kobo.902.1"> once when the key was pressed or released, and then we constantly apply the value to the movement vector in our game loop so that it is moving continuously without being affected by the </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">input interval.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.904.1">Qt Quick 3D in QML</span></h1>
<p><span class="koboSpan" id="kobo.905.1">In this recipe, we will learn how to render 3D images using </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">Qt 6.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.907.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.908.1">Let’s learn </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.909.1">how to use a 3D canvas in QML by following </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">this example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.911.1">Let’s start </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.912.1">this example by creating a new project in Qt Creator. </span><span class="koboSpan" id="kobo.912.2">This time around, we will go for </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">Qt Quick Application</span></strong><span class="koboSpan" id="kobo.914.1"> and not the other options that we chose in the </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">previous examples:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.916.1"><img alt="Figure 5.10 – Creating a new Qt Quick Application project" src="image/B20976_05_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.917.1">Figure 5.10 – Creating a new Qt Quick Application project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.918.1">Once the project is created, you are required to create a resource file by going to </span><strong class="bold"><span class="koboSpan" id="kobo.919.1">File</span></strong><span class="koboSpan" id="kobo.920.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.921.1">New File</span></strong><span class="koboSpan" id="kobo.922.1"> and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.923.1">Qt</span></strong><span class="koboSpan" id="kobo.924.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.925.1">Qt Resource File</span></strong><span class="koboSpan" id="kobo.926.1"> under </span><strong class="bold"><span class="koboSpan" id="kobo.927.1">Files and Classes</span></strong><span class="koboSpan" id="kobo.928.1"> and name </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">resource.qrc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.932.1"><img alt="Figure 5.11 – Creating a Qt resource file" src="image/B20976_05_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.933.1">Figure 5.11 – Creating a Qt resource file</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.934.1">Add an</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.935.1"> image file to our project resources—we will be using </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.936.1">it in this example. </span><span class="koboSpan" id="kobo.936.2">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">resource.qrc</span></strong><span class="koboSpan" id="kobo.938.1"> with Qt Creator by right-clicking on it in the </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">Projects pane</span></strong><span class="koboSpan" id="kobo.940.1"> and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">Open in Editor</span></strong><span class="koboSpan" id="kobo.942.1">. </span><span class="koboSpan" id="kobo.942.2">Once the resources file is opened by Qt Creator, click the </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">Add</span></strong><span class="koboSpan" id="kobo.944.1"> button, followed by the </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">Add File</span></strong><span class="koboSpan" id="kobo.946.1"> button, and then select the image file you want from your computer. </span><span class="koboSpan" id="kobo.946.2">In my case, I’ve added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">brick.jpg</span></strong><span class="koboSpan" id="kobo.948.1"> image, which will be used as the surface texture for our </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">3D object:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.950.1"><img alt="Figure 5.12 – Adding brick texture into the resource file" src="image/B20976_05_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.951.1">Figure 5.12 – Adding brick texture into the resource file</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.952.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">main.qml</span></strong><span class="koboSpan" id="kobo.954.1"> using Qt Creator. </span><span class="koboSpan" id="kobo.954.2">You will see that there are already a few lines of code written in the file. </span><span class="koboSpan" id="kobo.954.3">What it does is basically open up an empty window and nothing else. </span><span class="koboSpan" id="kobo.954.4">Let’s start adding our own code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Window</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.956.1"> object.</span></span></li>
<li><span class="koboSpan" id="kobo.957.1">First, import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">QtQuick3D</span></strong><span class="koboSpan" id="kobo.959.1"> module to our project and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">View3D</span></strong><span class="koboSpan" id="kobo.961.1"> object under </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.962.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">Window</span></strong><span class="koboSpan" id="kobo.964.1"> object, which we will be using to render a 3D scene </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">on it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.966.1">
import QtQuick
</span><strong class="bold"><span class="koboSpan" id="kobo.967.1">import QtQuick3D</span></strong><span class="koboSpan" id="kobo.968.1">
Window {
    width: 640
    height: 480
    visible: true
    title: qsTr("Hello World")
    </span><strong class="bold"><span class="koboSpan" id="kobo.969.1">View3D {</span></strong><span class="koboSpan" id="kobo.970.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">id: view</span></strong><span class="koboSpan" id="kobo.972.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.973.1">anchors.fill: parent</span></strong><span class="koboSpan" id="kobo.974.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">}</span></strong><span class="koboSpan" id="kobo.976.1">
}</span></pre></li> <li><span class="koboSpan" id="kobo.977.1">After </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.978.1">that, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">environment</span></strong><span class="koboSpan" id="kobo.980.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">View3D</span></strong><span class="koboSpan" id="kobo.982.1"> object as a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">SceneEnvironment</span></strong><span class="koboSpan" id="kobo.984.1"> object. </span><span class="koboSpan" id="kobo.984.2">We use this to set the background color of our 3D view to </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">sky blue:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.986.1">
environment: SceneEnvironment {
    clearColor: "skyblue"
    backgroundMode: SceneEnvironment.Color
}</span></pre></li> <li><span class="koboSpan" id="kobo.987.1">After that, we re-create the 3D cube from our previous OpenGL example by declaring a </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">Model</span></strong><span class="koboSpan" id="kobo.989.1"> object inside our 3D view and setting its source as </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">Cube</span></strong><span class="koboSpan" id="kobo.991.1">. </span><span class="koboSpan" id="kobo.991.2">We then rotate it by </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">-30</span></strong><span class="koboSpan" id="kobo.993.1"> units along the y-axis and apply a material to it. </span><span class="koboSpan" id="kobo.993.2">After that, we set the </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.994.1">texture of the material as </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">brick.jpg</span></strong><span class="koboSpan" id="kobo.996.1">. </span><span class="koboSpan" id="kobo.996.2">The keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">qrc:</span></strong><span class="koboSpan" id="kobo.998.1"> here means we are taking the texture from the resource file we </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">created earlier:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
Model {
    position: Qt.vector3d(0, 0, 0)
    source: "#Cube"
    eulerRotation.y: -30
    materials: PrincipledMaterial {
        baseColorMap: Texture {
            source: "qrc:/brick.jpg"
        }
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.1001.1">Before we’re able </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.1002.1">to see our 3D cube clearly, we must create a light source as well as a camera, which helps to render </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">our scene:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
PerspectiveCamera {
    position: Qt.vector3d(0, 200, 300)
    eulerRotation.x: -30
}
DirectionalLight {
    eulerRotation.x: -10
    eulerRotation.y: -20
}</span></pre></li> <li><span class="koboSpan" id="kobo.1005.1">Once you</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.1006.1"> are done, build and run the project. </span><span class="koboSpan" id="kobo.1006.2">You should be able to see a 3D cube with a brick texture on </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">the screen:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.1008.1"><img alt="Figure 5.13 – Re-creating the 3D demo in QtQuick3D" src="image/B20976_05_013.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1009.1">Figure 5.13 – Re-creating the 3D demo in QtQuick3D</span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.1010.1">To re-create</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.1011.1"> the spinning animation, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">NumberAnimation</span></strong><span class="koboSpan" id="kobo.1013.1"> to our </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">cube model:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1015.1">
Model {
    position: Qt.vector3d(0, 0, 0)
    source: "#Cube"
    eulerRotation.y: -30
    materials: PrincipledMaterial {
        baseColorMap: Texture {
            source: "qrc:/brick.jpg"
        }
    }
    NumberAnimation on eulerRotation.y {
        duration: 3000
        to: 360
        from: 0
        easing.type:Easing.Linear
        loops: Animation.Infinite
    }
}</span></pre></li> </ol>
<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1016.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.1017.1">Originally, Qt 5 </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.1018.1">used something called </span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">Qt Canvas 3D</span></strong><span class="koboSpan" id="kobo.1020.1"> to render 3D </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.1021.1">scenes in QML, which was based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">three.js</span></strong><span class="koboSpan" id="kobo.1023.1"> library/API that used WebGL technology to display animated 3D computer graphics in a Qt Quick window. </span><span class="koboSpan" id="kobo.1023.2">However, this feature has been completely deprecated in Qt 6 and has been since replaced by another</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.1024.1"> module called </span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">Qt </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1026.1">Quick 3D</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">Qt Quick 3D works a lot better than Qt Canvas 3D as it uses native methods for rendering 3D scenes without depending on a third-party library such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">three.js</span></strong><span class="koboSpan" id="kobo.1030.1">. </span><span class="koboSpan" id="kobo.1030.2">It also produces better performance and integrates well with any existing Qt </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">Quick components.</span></span></p>
</div>
</body></html>