- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Unreal Engine 5 and its Layers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Unreal Engine 5及其层
- en: Design patterns are a series of tools and practices by which we can learn to
    write faster and easier-to-work-with code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是一系列工具和实践，通过这些工具和实践我们可以学会编写更快、更易于协作的代码。
- en: Applying design patterns to projects developed in **Unreal Engine 5** (**UE5**)
    will allow you to make your projects more performant, easier to read, and build
    upon, as well as develop an improved understanding of how the engine works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计模式应用于在**Unreal Engine 5**（**UE5**）中开发的项目，将使你的项目性能更优，更易于阅读和构建，同时也能加深你对引擎工作原理的理解。
- en: We’re going to begin by developing an understanding of the history of Unreal
    Engine and ensuring that we are all set up to work with the engine, covering some
    basic ideas of how C++ and Unreal Engine’s visual scripting language, **Blueprint**,
    are linked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从了解Unreal Engine的历史开始，确保我们为使用该引擎做好准备，涵盖一些关于C++和Unreal Engine的视觉脚本语言**Blueprint**如何关联的基本概念。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing Unreal Engine 5
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Unreal Engine 5
- en: Installing Unreal Engine 5 and preparing your development environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Unreal Engine 5并准备你的开发环境
- en: The “Fuzzy” layer – bridging the gap from C++ to Blueprint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “模糊”层——连接C++与Blueprint的桥梁
- en: Translating back from Blueprint to C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从蓝图翻译回C++
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before embarking on this journey of discovery, know that this book will assume
    some working knowledge of C++ syntax and the Unreal Engine Editor. Familiarity
    with pointers and how to follow code in your chosen **integrated development environment**
    (**IDE**) will be key to understanding the Unreal core API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这段探索之旅之前，要知道本书将假设你对C++语法和Unreal Engine编辑器有一定的了解。熟悉指针以及如何在所选的**集成开发环境**（**IDE**）中跟踪代码，对于理解Unreal核心API至关重要。
- en: 'You will require the following software:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下软件：
- en: Unreal Engine 5 (this book has been written with version 5.0.3).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 5（本书是根据5.0.3版本编写的）。
- en: '**Visual Studio** is a decent free IDE (basic support for the engine is present,
    meaning projects may show errors and *IntelliSense* may not auto-complete some
    keywords, but the project will compile and run).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio**是一个不错的免费IDE（对引擎的基本支持是存在的，这意味着项目可能会显示错误，*IntelliSense*可能无法自动完成一些关键字，但项目可以编译和运行）。'
- en: If you have access, JetBrains Rider version 2022 or later has built-in support
    for Unreal Engine, which will make the development process a lot easier. Rider
    is an alternative IDE to Visual Studio that is often preferred among programmers
    working with Unreal. It offers improved support for working with C++ in Unreal
    Engine, including auto-complete. You can learn more about it by visiting [https://www.jetbrains.com/lp/rider-unreal/](https://www.jetbrains.com/lp/rider-unreal/).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能够访问，JetBrains Rider 2022版或更高版本内置了对Unreal Engine的支持，这将使开发过程变得更加容易。Rider是Visual
    Studio的替代IDE，通常被使用Unreal的程序员所青睐。它提供了对在Unreal Engine中使用C++的改进支持，包括自动完成。你可以通过访问[https://www.jetbrains.com/lp/rider-unreal/](https://www.jetbrains.com/lp/rider-unreal/)了解更多信息。
- en: Introducing Unreal Engine 5
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Unreal Engine 5
- en: Unreal Engine 5, or Unreal for short, is a game engine developed by *Epic Games*.
    Unreal, as with any other game engine at its core, simply processes data from
    files and instructions into data that you can see on the screen. The suite of
    tools provided are designed to assist you in creative and predictable tasks. Having
    been created for you by elite programmers and designers, it is like outsourcing
    your development to the big leagues.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 5，简称Unreal，是由*Epic Games*开发的游戏引擎。与任何其他游戏引擎一样，Unreal的核心功能仅仅是处理文件和指令中的数据，将其转换为屏幕上可见的数据。提供的工具套件旨在协助你完成创造性和可预测的任务。这些工具是由精英程序员和设计师为你量身定制的，就像将你的开发外包给顶级团队一样。
- en: However, like a high-performance racing car driven by a learner, even the best
    tools can perform badly. The experts at Epic didn’t know how you would use their
    tools. So, when we design our code architecture, we need to keep this break in
    communications in mind. This is where this book comes in, teaching the expected
    best practices when writing games in Unreal Engine 5.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像一个由新手驾驶的高性能赛车，即使是最好的工具也可能表现不佳。Epic的专家们并不了解你们会如何使用他们的工具。因此，在设计我们的代码架构时，我们需要牢记这种沟通的断裂。这正是本书的用武之地，它将教授在Unreal
    Engine 5中编写游戏时预期的最佳实践。
- en: Unreal Engine has powered an impressive list of gaming titles covering a vast
    array of genres, shipping on a multitude of platforms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine为覆盖广泛游戏类型的众多游戏作品提供了强大的支持，并在多个平台上发布。
- en: 'Unreal Engine 3 powered some of the biggest hits from the seventh generation
    of game consoles, ranging from third-person shooter games such as the *Gears of
    War* series developed by *Epic Games* themselves to fighting games such as *Injustice:
    Gods Among Us* and *Mortal Kombat* from *NetherRealm*, as well as strategy games
    including the *XCOM* series developed by *Firaxis Games*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 3推动了第七代游戏机中一些最大的热门游戏，从由*Epic Games*自己开发的第三人称射击游戏系列*战争机器*，到来自*NetherRealm*的格斗游戏*不义联盟：我们之中神*和*Mortal
    Kombat*，以及包括由*Firaxis Games*开发的*XCOM*系列在内的策略游戏。
- en: The eighth generation of consoles saw Unreal Engine 4 expand its portfolio to
    include racing titles such as the *MotoGP* games from *Milestone* and *Assetto
    Corsa Competizione* from *Kunos Simulazioni*, as well as facilitating the hugely
    popular introduction of the Battle Royale genre with *PlayerUnknowns’ Battlegrounds*
    (*PUBG Studios*), which is listed as the fifth highest-selling video game on *Wikipedia*,
    and *Epic Games*’ *Fortnite*, which transitioned to Unreal Engine 5 in December
    2021 as detailed in [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第八代游戏机见证了Unreal Engine 4的阵容扩展，包括*Milestone*的*MotoGP*游戏和*Kunos Simulazioni*的*Assetto
    Corsa Competizione*，以及通过*PlayerUnknowns’ Battlegrounds*（*PUBG Studios*）引入了广受欢迎的Battle
    Royale游戏类型，该游戏被列为*维基百科*上第五大畅销视频游戏，以及*Epic Games*的*Fortnite*，它在2021年12月过渡到Unreal
    Engine 5，如[*第3章*](B18297_03.xhtml#_idTextAnchor046)中所述。
- en: 'Unreal Engine 5 features a series of new, key technologies, including *Nanite*,
    a sub-mesh level of detail system allowing massive polycount models to render
    with even screen-space hull size at any distance, and *Lumen*, a real-time lighting
    solution that mixes mesh distance fields and atlassed local surface data progressively
    over time to create a realistic lighting effect at low cost. These new technologies
    drove the transition from 4.26/4.27 to 5.0 as part of a complete rework of Unreal’s
    rendering technology. The engine had an impactful debut with the release of *The
    Matrix Awakens: An Unreal Engine Experience*, a demo featuring photorealistic
    likenesses of Carrie-Anne Moss and Keanu Reeves, and an open-world city featuring
    impressive examples of crowd and traffic simulations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 5具备一系列新的关键技术，包括*Nanite*，一个子网格级别的细节系统，允许大规模多边形模型在任何距离上以甚至屏幕空间船体大小渲染，以及*Lumen*，一个实时光照解决方案，它通过随着时间的推移逐步混合网格距离场和图集化的局部表面数据，以低成本创建逼真的光照效果。这些新技术推动了从4.26/4.27到5.0的过渡，作为Unreal渲染技术全面重做的部分。该引擎在发布*《黑客帝国：觉醒：Unreal
    Engine体验》*时首次亮相，这是一个展示凯瑞-安·莫斯和基努·里维斯逼真形象的演示，以及一个具有令人印象深刻的群众和交通模拟的开放世界城市。
- en: Increasingly, games studios are opting to replace proprietary in-house developed
    game engines with Unreal Engine 5; studios such as *CD Projekt Red* (*The Witcher*)
    and *Crystal Dynamics* (*Tomb Raider*) have announced the decision to use Unreal
    Engine 5 in the latest installments of their game series.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的游戏工作室选择用Unreal Engine 5替换自家的专有游戏引擎；例如，*CD Projekt Red*（*巫师*）和*Crystal Dynamics*（*古墓丽影*）已经宣布决定在其游戏系列的最新版本中使用Unreal
    Engine 5。
- en: Now that we’ve covered a little about Unreal Engine’s past, pedigree, and influence
    on gaming history, we will get things set up next so that you are ready to use
    Unreal Engine 5 with C++.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了Unreal Engine的过去、血统和对游戏历史的影响，接下来我们将设置好一切，以便你准备好使用C++的Unreal Engine
    5。
- en: Installing Unreal Engine 5 and preparing your development environment
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Unreal Engine 5和准备你的开发环境
- en: Unreal Engine can be downloaded either via the Epic Games Launcher (available
    from https://unrealengine.com, which will install the engine for you) or as source
    code from GitHub (www.github.com/EpicGames), allowing users to compile the engine
    and modify it to fit their projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Epic Games启动器（从https://unrealengine.com获取，它将为你安装引擎）或从GitHub（www.github.com/EpicGames）下载Unreal
    Engine，允许用户编译引擎并修改它以适应他们的项目。
- en: To engage with the activities in this book, you won’t need to compile the engine
    from source unless you really want to. The benefits of compiling from source will
    likely come much later into your journey of working with Unreal Engine and C++.
    You will, however, need to install version 5.0.3 (or above) of the engine and
    have an IDE installed. This section covers the download, installation, and setup
    of the engine from scratch using the Unreal Launcher and installation of Visual
    Studio 2022 Community. If you already have the engine and Visual Studio installed,
    you can skip over this section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要参与本书中的活动，除非您真的想这样做，否则您不需要从源代码编译引擎。从源代码编译的好处可能会在您使用Unreal Engine和C++的旅程中晚些时候显现。然而，您需要安装引擎的5.0.3（或更高）版本，并且需要安装一个IDE。本节涵盖了使用Unreal启动器和Visual
    Studio 2022 Community安装从头开始下载、安装和设置引擎的过程。如果您已经安装了引擎和Visual Studio，您可以跳过本节。
- en: Firstly, you will need to download the Launcher from [https://unrealengine.com](https://unrealengine.com)
    by clicking the **Download** button in the top-right corner of the page and clicking
    the **Download Launcher** button on the following page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要通过点击页面右上角的**下载**按钮，然后点击下一页上的**下载启动器**按钮，从[https://unrealengine.com](https://unrealengine.com)下载启动器。
- en: Once downloaded, you will need to install the Launcher from the `.``msi`installer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，您需要从`.msi`安装程序中安装启动器。
- en: 'The Launcher is home to the Epic Games Store, your library of purchased and
    downloaded games as well as versions of Unreal Engine (4 and above). You will
    need to navigate to **Unreal Engine** and then **Library**, then click the *yellow
    plus icon* and select your engine version from the resulting engine slot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 启动器是Epic Games Store的所在地，您的购买和下载的游戏库以及Unreal Engine（4及以上版本）。您需要导航到**Unreal Engine**，然后**库**，点击*黄色加号图标*，从结果引擎槽中选择您的引擎版本：
- en: '![Figure 1.1 – The default Epic Games Launcher with no versions of the engine
    installed](img/B18297_01_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 默认的Epic Games启动器，未安装任何引擎版本](img/B18297_01_1.jpg)'
- en: Figure 1.1 – The default Epic Games Launcher with no versions of the engine
    installed
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 默认的Epic Games启动器，未安装任何引擎版本
- en: Alternatively, if you don’t have any versions of the engine installed, you can
    click the *yellow drop-down button* in the top right of the Launcher application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您还没有安装任何版本的引擎，您可以在启动器应用程序的右上角点击*黄色下拉按钮*。
- en: 'Both approaches will present you with the option of where you would like to
    install the engine. It is advisable to install the engine on an SSD if possible
    as the engine will load significantly quicker than from an HDD:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会为您提供选择安装引擎位置的选择。如果可能的话，建议在SSD上安装引擎，因为引擎从SSD加载的速度将显著快于HDD：
- en: '![Figure 1.2 – Install location options](img/B18297_01_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 安装位置选项](img/B18297_01_2.jpg)'
- en: Figure 1.2 – Install location options
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 安装位置选项
- en: 'Clicking the **Options** button will present you with a series of optional
    elements for installing the engine:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**选项**按钮，您将看到一系列可选元素，用于安装引擎：
- en: '![Figure 1.3 – Installation options for Unreal Engine 5.0.3](img/B18297_01_3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – Unreal Engine 5.0.3的安装选项](img/B18297_01_3.jpg)'
- en: Figure 1.3 – Installation options for Unreal Engine 5.0.3
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – Unreal Engine 5.0.3的安装选项
- en: We advise installing **Starter Content**, **Templates and Feature Packs**, and
    **Engine Source**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议安装**入门内容**、**模板和功能包**以及**引擎源**。
- en: '**Engine Source** will make browsing and debugging code easier but does not
    allow you to rebuild the engine; for that functionality, you will need to download
    the source from GitHub, as mentioned earlier.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**引擎源**将使浏览和调试代码更容易，但不会允许您重新构建引擎；为此功能，您需要从GitHub下载源代码，如前所述。'
- en: '**Editor symbols for debugging** allows the debugging of C++ in the Editor.
    This is not required but will prove useful to facilitate jumping from the Editor
    to engine code and allow you to explore the code behind Blueprint nodes.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑器符号用于调试**允许在编辑器中调试C++。这不是必需的，但将有助于从编辑器跳转到引擎代码，并允许您探索蓝图节点背后的代码。'
- en: 'If you decide you want to add/remove elements later, you can modify these choices
    by clicking the *down arrow* next to **Launch** on the engine slot and selecting
    **Options**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定以后要添加/删除元素，您可以通过点击引擎槽旁边的**启动**旁边的*向下箭头*来修改这些选择，并选择**选项**：
- en: '![Figure 1.4 – Location of the Options menu on an engine slot](img/B18297_01_4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 引擎槽上选项菜单的位置](img/B18297_01_4.jpg)'
- en: Figure 1.4 – Location of the Options menu on an engine slot
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 引擎槽中选项菜单的位置
- en: Enable the checkbox next to **Editor symbols for debugging** and click **Apply**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选中 **调试的编辑器符号**旁边的复选框，然后点击 **应用**。
- en: Once you have the engine installed, you can move on to installing Visual Studio.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了引擎，您就可以继续安装 Visual Studio。
- en: You will need to download the Visual Studio installer from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从 [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    下载 Visual Studio 安装程序。
- en: 'When you run the installer, select the **Game Development with C++** preset
    in the **Workloads** tab and select optional components, as shown in *Figure 1**.5*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行安装程序时，在 **工作负载**选项卡中选择 **使用 C++ 进行游戏开发**预设，并选择可选组件，如图 *图 1**.5* 所示：
- en: '![Figure 1.5 – Suggested installation options for Visual Studio Community 2022](img/B18297_01_5.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Visual Studio Community 2022 的建议安装选项](img/B18297_01_5.jpg)'
- en: Figure 1.5 – Suggested installation options for Visual Studio Community 2022
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Visual Studio Community 2022 的建议安装选项
- en: Once you have Visual Studio installed, you should be ready to go. If you want
    to further improve your experience of working in Visual Studio with Unreal Engine
    5.0.X, you can find some additional guidance from *Epic* at [https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/](https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 Visual Studio，您就应该准备就绪了。如果您想进一步改善在 Unreal Engine 5.0.X 中使用 Visual Studio
    的体验，您可以从 *Epic* 在 [https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/](https://docs.unrealengine.com/5.0/en-US/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine/)
    提供的一些额外指导中找到。
- en: Now that we’ve installed the engine and set up our IDE, we can start exploring
    the link between C++ code and Blueprint.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了引擎并设置了我们的集成开发环境，我们可以开始探索 C++ 代码与蓝图之间的联系。
- en: The “Fuzzy” layer – bridging the gap from C++ to Blueprint
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “模糊”层 – 连接 C++ 和蓝图之间的差距
- en: Most engines work on the concept of layers. Each layer has a specific job to
    do, and when stacked in the correct order, they simplify the development and maintenance
    of an engine. For example, if a new graphics language emerges that it would be
    wise to support, only the layer with the graphics pipeline needs to be changed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数引擎都基于层的概念。每个层都有特定的任务，并且当按正确的顺序堆叠时，它们简化了引擎的开发和维护。例如，如果出现一种新的图形语言，明智的做法是支持它，那么只需要更改具有图形管道的层。
- en: 'There is no hard and fast rule for the number or breakdown of layers in an
    engine, but what you will generally find is a separation that resembles *Table
    1.1*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎中层的数量或分层结构方面没有固定的规则，但您通常会找到一个类似于 *表 1.1* 的分离：
- en: '| **Tool**Full of Editor functions that speed up standard tasks. This suite
    is generally what an engine is marketed on. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **工具**充满了加快标准任务的编辑器功能。这个套件通常是引擎所宣传的。|'
- en: '| --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Gameplay**All of the custom systems created to facilitate interaction mechanics
    that will be bespoke in the built game. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **游戏玩法**为便于交互机制而创建的所有自定义系统，这些机制将在构建的游戏中是独特的。'
- en: '| --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Function**Where all automatic internal systems are handled like input capture
    and physics processing, etc. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **功能**处理所有自动内部系统的地方，如输入捕获和物理处理等。'
- en: '| --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Resource**Memory management and asset streaming are handled here. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **资源**在这里处理资源内存管理和资产流式传输。'
- en: '| --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Platform**Essentially, the graphics pipeline definition and build platform
    native integrations if the engine supports it. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **平台**基本上，图形管道定义和构建平台原生集成（如果引擎支持的话）。'
- en: '| --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| **Base**Full of core dependency libraries such as UI frameworks for the Editor
    and math libraries. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **基础**充满了核心依赖库，如用于编辑器的 UI 框架和数学库。'
- en: Table 1.1 – Common engine layers and their uses
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 常见引擎层及其用途
- en: Although Unreal may not explicitly label its layers in this way, we can see
    them in action in the relationship between how Unreal processes C++ and Blueprint
    gameplay. Functions created with certain specifiers in C++ can be accessed in
    Blueprint, but the reverse is not true. This shows there is an order to our actions
    where signals can only be passed one way. We’ll refer to this internal separation
    between gameplay layers as the *Fuzzy layer*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管虚幻引擎可能不会明确以这种方式标记其层，但我们可以通过虚幻引擎处理C++和蓝图游戏的方式看到它们在行动中的表现。使用某些指定器在C++中创建的函数可以在蓝图中被访问，但反之则不然。这表明我们的操作有一个顺序，信号只能单向传递。我们将把这个游戏层之间的内部分离称为**模糊层**。
- en: The fact that the Fuzzy layer exists places a limitation on how we design our
    systems, but in turn, we gain a separation that enables gameplay programmers to
    work alongside designers with little friction. Systems can be developed for simple
    creative use within accessible Blueprints with the more efficient C++ code hidden
    out of sight. To facilitate this construction, Unreal gives us **Property Specifiers**
    and **Function Specifiers** to define how signals will punch through.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊层存在的事实对我们设计系统的方式施加了限制，但反过来，我们获得了一种分离，使得游戏程序设计师可以与设计师并肩工作，几乎没有摩擦。可以在可访问的蓝图内为简单的创意用途开发系统，而更高效的C++代码则隐藏在视线之外。为了便于这种构建，虚幻引擎为我们提供了**属性指定器**和**函数指定器**来定义信号如何穿透。
- en: Property Specifiers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性指定器
- en: 'Property Specifiers define characteristics of C++-defined variables when viewed
    and accessed in the Blueprint layer. The Unreal docs provide a handy table explaining
    the different levels of security afforded by each, along with some more specific
    ones designed for events, collections, and replication over networks ([https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/](https://docs.unrealengine.com/5.0/en-US/unreal-engine-uproperties/)).
    The six Display Property Specifiers most commonly used are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指定器定义了在蓝图层中查看和访问时C++定义的变量的特征。虚幻引擎文档提供了一个方便的表格，解释了每个指定器提供的不同安全级别，以及一些为事件、集合和网络复制设计的更具体的指定器。以下是最常用的六个显示属性指定器：
- en: '`EditAnywhere` – The value will be changeable in all class defaults and instance
    detail panels. This specifier is generally used while prototyping as it displays
    the variable in most places, with the most options for changing its value. However,
    security is the price paid for this flexibility, allowing any designer to change
    the default and instance values, and so access should be restricted down to what
    you actually need once a system is tested as working.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditAnywhere` – 该值可以在所有类默认值和实例详细面板中更改。此指定器通常在原型设计时使用，因为它在大多数地方显示变量，并提供了更改其值的最多种选项。然而，为了这种灵活性，必须付出安全性的代价，允许任何设计师更改默认值和实例值，因此一旦系统经过测试并证明可以工作，应将访问权限限制到实际需要的范围内。'
- en: '`EditDefaultsOnly` – The value will only be changeable in class defaults. Useful
    when a variable needs to be changed for balancing and all instances are spawned
    at runtime, where you wouldn’t have access to instance detail panels anyway. Can
    also be used to ensure no spawned instance has a rogue different value if necessary
    for execution.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditDefaultsOnly` – 该值只能在类默认值中更改。当需要更改变量以进行平衡且所有实例都在运行时生成时，这很有用，因为你无论如何都无法访问实例详细面板。也可以用于确保在必要时，没有生成的实例具有不同的值。'
- en: '`EditInstanceOnly` – The value will only be changeable in instance detail panels.
    Useful for allowing designers different values on bespoke placed actors in a scene
    but restricting the default value to something that is tested as working.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditInstanceOnly` – 该值只能在实例详细面板中更改。这对于允许设计师在场景中为特定放置的演员使用不同的值很有用，但将默认值限制为经过测试并证明可以工作的值。'
- en: '`VisibleAnywhere` – The value will be visible in all class defaults and instance
    detail panels, with no option for changing it from the Editor. This is useful
    for debugging how the initialization process affects a value when it is unknown
    if the code is generally wrong or wrong at an edge case. The latter will show
    incorrect values at the instance level, whereas the former will be wrong at both
    levels.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibleAnywhere` – 该值将在所有类默认值和实例详细面板中可见，但无法从编辑器中更改它。这对于调试初始化过程如何影响值很有用，当不知道代码是否通常错误或仅在边缘情况下错误时。后者将在实例级别显示不正确的值，而前者将在两个级别都显示错误。'
- en: '`VisibleInstanceOnly` – The value will only be visible in instance detail panels.
    Useful for surface-level debugging of values in each instance without cluttering
    the screen with debug messages when you have a large number of instances spawned.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibleInstanceOnly` – 该值仅在实例详细面板中可见。当您有大量实例生成时，这对于在各个实例中调试表面级值非常有用，而不会因为调试消息而使屏幕杂乱无章。'
- en: '`VisibleDefaultsOnly` – The value will only be visible in class defaults. Useful
    for designers to reference what a functional value is and create a parity in the
    visual elements of an actor. This is the highest security level as each actor
    will display the starting value in one place.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibleDefaultsOnly` – 该值仅在类默认值中可见。对于设计师来说，这有助于参考功能值并创建一个与演员视觉元素相匹配的对等性。这是最高的安全级别，因为每个演员都将在一个地方显示起始值。'
- en: 'There are two access specifiers we need to pay attention to for now: `BlueprintReadOnly`
    and `BlueprintReadWrite`. They give child Blueprint-based classes access to either
    just the getter or both getter and setter in their graphs.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们需要注意的两个访问修饰符是：`BlueprintReadOnly` 和 `BlueprintReadWrite`。它们允许基于蓝图的孩子类在其图中访问仅获取器或获取器和设置器。
- en: Function Specifiers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数修饰符
- en: 'Function Specifiers work similarly to Property Specifiers, defining how functions
    should be seen and accessed by the Blueprint layer, with some subtleties to their
    usage. You can find a full list of Function Specifiers in the Unreal docs ([https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/](https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/)),
    but the three we are interested in are detailed next:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数修饰符的工作方式与属性修饰符类似，定义了蓝图层应该如何查看和访问函数，但它们的用法有一些细微差别。您可以在虚幻文档中找到函数修饰符的完整列表（[https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/](https://docs.unrealengine.com/5.0/en-US/ufunctions-in-unreal-engine/))，但我们接下来要详细讨论的是三个我们感兴趣的：
- en: '`BlueprintCallable` – As the name suggests, Blueprint classes can call this
    function if it is in a parent class and it has the correct encapsulation type
    (public or protected).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintCallable` – 如其名所示，如果该函数位于父类中并且具有正确的封装类型（公共或受保护），则蓝图类可以调用此函数。'
- en: '`BlueprintImplementableEvent` – The stub for this function signature is defined
    in C++ without any implementation. This allows C++ systems to call it and Blueprint
    systems to fill out its actual body. You might use this for triggering visual
    effects like a laser beam on a gun when it is fired.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintImplementableEvent` – 该函数签名的存根在 C++ 中定义，没有实现。这允许 C++ 系统调用它，而蓝图系统填充其实际体。您可能用它来触发当枪被发射时在枪上产生的激光束等视觉效果。'
- en: '`BlueprintNativeEvent` – This allows C++ to define a function that is filled
    out in Blueprint, but in this case, there can also be a *default* implementation,
    which will also be run. Unreal achieves this by generating two more function definitions
    for you: `*_Implementation()` and `Execute_*()`. The former is used for the C++
    side that must be run, and the latter is the function that must be called in C++
    to fire both implementations.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintNativeEvent` – 这允许 C++ 定义一个在蓝图中被填充的函数，但在此情况下，也可以有一个*默认*实现，它也将被执行。虚幻通过为您生成两个额外的函数定义来实现这一点：`*_Implementation()`
    和 `Execute_*()`。前者用于必须运行的 C++ 方面，后者是在 C++ 中必须调用的函数，以触发两个实现。'
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As with layering, the C++ side of `BlueprintNativeEvents` will execute before
    the Blueprint side.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与分层一样，`BlueprintNativeEvents` 的 C++ 方面将在蓝图方面之前执行。
- en: Using Property and Function Specifiers, we can make systems that cross the Fuzzy
    layer, but almost as important as routing function signals is designing inheritance
    hierarchies that smooth this process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性和函数修饰符，我们可以创建跨越模糊层的系统，但与路由函数信号一样重要的是设计继承层次结构，以使此过程更加平滑。
- en: Useful inheritance
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的继承
- en: As standard practice, it is best to make sure that anything instanced in your
    world is a Blueprint class. This helps with debugging and linking classes with
    references as you have all the visual tools built into the Editor for tracing
    executions, and if classes are renamed or if they move directories, then links
    are live instead of text-based, preventing crashes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准实践，最好确保您世界中实例化的任何内容都是蓝图类。这有助于调试，并且当您在编辑器中具有所有用于跟踪执行的视觉工具时，它有助于将类与引用链接。如果类被重命名或移动到目录中，则链接是活动的而不是基于文本的，从而防止崩溃。
- en: 'To make this inheritance strategy work, it is recommended you think about your
    system from an abstract gameplay point of view. Which classes affect the mechanics?
    These classes need to have a C++ representation for efficiency, and so a hierarchy
    can be designed. From there, we inherit Blueprint classes from the end of each
    branch. This gives us the Blueprint classes to link, create instances of, and
    add visual components to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这种继承策略生效，建议你从抽象游戏玩法的角度思考你的系统。哪些类影响机制？这些类需要有一个C++表示形式以提高效率，因此可以设计一个层次结构。从那里，我们继承蓝图类从每个分支的末端。这为我们提供了蓝图类来链接、创建实例并添加视觉组件：
- en: '![Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile
    and HitScan mechanic types](img/B18297_01_6.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 包含弹道和击中扫描机制类型的武器机制示例层次结构](img/B18297_01_6.jpg)'
- en: Figure 1.6 – Example hierarchy for a weapon mechanic that includes both Projectile
    and HitScan mechanic types
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 包含弹道和击中扫描机制类型的武器机制示例层次结构
- en: 'In *Figure 1**.6*, the C++ classes would contain all the logic for ammo, damaging
    actors, interaction handling, and so on. Then, in the Blueprint classes, components
    to display the mesh, run the kickback animations, and display the muzzle flash
    would be added. There would most likely be a function in the `Weapon` parent class
    called from somewhere in the firing logic that looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.6*中，C++类将包含所有与弹药、伤害演员、交互处理等相关逻辑。然后，在蓝图类中，将添加用于显示网格、运行后坐力动画和显示枪口闪光等组件。在发射逻辑的某个地方，很可能有一个从`Weapon`父类中调用的函数，其代码如下：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This could then be implemented in the Blueprint classes to trigger visual effects.
    Using some of the patterns we will cover later, namely the type object pattern,
    you can create a vast array of weapons from these few classes with some simple
    asset and variable changes. This shows how the artist, designer, and programmer
    can all work together on one system without getting in each other’s way while
    still benefitting from the efficiency gain in C++.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在蓝图类中实现，以触发视觉效果。使用我们稍后将要介绍的某些模式，即类型对象模式，你可以通过一些简单的资产和变量更改，从这些少数几个类中创建出大量武器。这展示了艺术家、设计师和程序员如何在一个系统上协同工作，而不会相互干扰，同时还能从C++的效率提升中受益。
- en: In theory, this process is perfect, but theory rarely translates to the real
    world. A lot of dev time is usually spent working out how to do something based
    on forum posts, documentation, and videos. It’s great that these resources exist;
    almost every problem you come across has likely been solved by someone else, but
    there is no guarantee they have been developed with the same practice. You will
    come across a situation where the fix you need is in a Blueprint tutorial/example
    and your system needs it to be in C++, so let’s have a look at the translation
    process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这个过程是完美的，但理论很少能转化为现实世界。通常，大量的开发时间都花在基于论坛帖子、文档和视频来解决问题上。这些资源的存在是很好的；你遇到的几乎所有问题都可能是别人解决过的，但没有保证它们是以相同的实践开发的。你可能会遇到这样的情况，你需要修复的问题在蓝图教程/示例中，而你的系统需要它在C++中，所以让我们看看转换过程。
- en: Translating back from Blueprint to C++
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从蓝图转换回C++
- en: 'Equipping yourself with tools to translate back from Blueprint to C++ is the
    smart thing to do, not only for the everyday fixes as mentioned previously, but
    also for the triple-A setting in a large company. A typical Unreal mechanics development
    pipeline at a large studio might follow the following process:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为自己配备从蓝图转换回C++的工具是明智之举，这不仅适用于之前提到的日常修复，也适用于大型公司中的三A级设置。大型工作室中典型的虚幻引擎机制开发流程可能遵循以下过程：
- en: A designer has an idea for a mechanic and is given time to prototype it in Blueprint
    as a **proof** **of concept**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计师有一个机制的想法，并被给予时间在蓝图中进行原型设计，作为**概念验证**。
- en: This mechanic is tested to see if it should be developed further.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个机制已经过测试，以确定是否应该进一步开发。
- en: If it receives a green light, it will be a programmer’s job to convert the prototype
    into a more robust C++ system.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果得到绿灯，那么将程序员的工作转换为将原型转换为更健壮的C++系统。
- en: 'We’ve covered the tools for designing C++ systems to work with Blueprint effectively,
    but when faced with the aforementioned situation, how do you take another person’s
    vision and translate it into something that works efficiently yet doesn’t lose
    what made it good? Well, the obvious answer is to directly translate it. Node
    for node. That process is easy, as nodes in Blueprint are quite literally just
    C++ functions that you have to find in the engine source. Let’s take a closer
    look:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了设计C++系统以与Blueprint有效工作的工具，但当面对上述情况时，你如何将另一个人的愿景转化为既高效又不失其优点的东西呢？显然的答案是直接翻译。节点对节点。这个过程很简单，因为Blueprint中的节点在字面上就是你在引擎源中必须找到的C++函数。让我们更仔细地看看：
- en: The first step is to hover the mouse over the node. Every node has a `Target`
    class, and mousing over will tell you what that is.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将鼠标悬停在节点上。每个节点都有一个`Target`类，鼠标悬停会告诉你那是什么。
- en: Next, we go to the Unreal Engine docs ([https://www.unrealengine.com/en-US/bing-search?](https://www.unrealengine.com/en-US/bing-search?))
    and search for *U< Target class name>::<Node name with* *no spaces>*.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转到Unreal Engine文档([https://www.unrealengine.com/en-US/bing-search?](https://www.unrealengine.com/en-US/bing-search?))并搜索*U<目标类名>::<无空格的节点名>*。
- en: The Unreal docs page for the function is likely to be bare, but it will give
    you the `#include` directory for the file header containing that function. Once
    a class has been included, it can be used and explored via autocompleting a dot
    accessor.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的Unreal文档页面可能很简洁，但它会给出包含该函数的文件头部的`#include`目录。一旦一个类被包含，就可以通过自动完成点访问器来使用和探索它。
- en: Important note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the target is `Actor`, then it will have an `A` instead of a `U` at the beginning,
    as shown in the example in *Figure 1**.7*. This is one of the oddities of UE5;
    each time there is one, it will be mentioned in a box like this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是`Actor`，那么它开头将有一个`A`而不是`U`，如图*图1.7*所示。这是UE5的一个奇怪之处；每次出现这种情况，都会像这样在框中提到。
- en: '![Figure 1.7 – Showing the process from node to Unreal C++ documentation](img/B18297_01_7.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 显示从节点到Unreal C++文档的过程](img/B18297_01_7.jpg)'
- en: Figure 1.7 – Showing the process from node to Unreal C++ documentation
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 显示从节点到Unreal C++文档的过程
- en: This process may seem tedious but after a while of searching different things,
    you will start to see patterns and be able to work out where functions are likely
    to be. Each node with an execution pin (the white arrow) then becomes one line
    of code with input pins forming the function arguments, and output pins are generally
    the return type (multiple of which would form a struct).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能看起来很繁琐，但经过一段时间搜索不同的事情后，你将开始看到模式，并能够找出函数可能在哪里。每个带有执行引脚（白色箭头）的节点然后成为一行代码，输入引脚形成函数参数，输出引脚通常是返回类型（多个会形成一个结构体）。
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Reading through the following headers will be useful for mastering the translation
    process as they are the most frequently used: `AActor.h`, `UGameplayStatics.h`,
    and `UkismetSystemLibrary.h`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下头文件将有助于掌握翻译过程，因为它们是最常用的：`AActor.h`、`UGameplayStatics.h`和`UkismetSystemLibrary.h`。
- en: The next question is, how do you know where to leave the line between C++ and
    Blueprints? Theoretically, you could make everything in C++, but as we’ve already
    shown, that is not a good idea for teamworking reasons. The answer has already
    been hinted at, but generally, you want everything visual or not to do with the
    gameplay mechanics to be Blueprint-based. Where that line exactly sits is up to
    interpretation and not worth agonizing over.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是如何知道在C++和Blueprint之间留下哪条线？从理论上讲，你可以用C++做所有事情，但正如我们已经展示的，出于团队合作的原因，这不是一个好主意。答案已经暗示过了，但通常，你希望所有视觉的或与游戏机制无关的东西都是Blueprint-based。这条线具体在哪里取决于解释，不值得过分纠结。
- en: Worked example
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作示例
- en: 'To cement this theory, let’s work through an example. In *Figure 1**.8*, you
    can see an example Blueprint system designed to increment an integer when it is
    overlapped by a projectile; then, once it reaches 10 overlaps, it will play a
    sound and unhide a particle effect:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固这个理论，让我们通过一个例子来工作。在*图1.8*中，你可以看到一个示例Blueprint系统，该系统设计用于在物体被投射物重叠时增加一个整数值；然后，一旦达到10次重叠，它将播放一个声音并显示一个粒子效果：
- en: '![Figure 1.8 – A series of Blueprint nodes in a basic function; this piece
    of Blueprint has been arranged using a reroute node for readability but would
    normally be laid out more linearly](img/B18297_01_8.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 基本函数中的一系列蓝图节点；这个蓝图片段使用重定向节点进行了排列以提高可读性，但通常会更线性地布局](img/B18297_01_8.jpg)'
- en: Figure 1.8 – A series of Blueprint nodes in a basic function; this piece of
    Blueprint has been arranged using a reroute node for readability but would normally
    be laid out more linearly
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 基本函数中的一系列蓝图节点；这个蓝图片段使用重定向节点进行了排列以提高可读性，但通常会更线性地布局
- en: 'First, we need a C++ class for this to inherit from, and seeing as it is called
    `BP_Target`, we can name it `Target`. The `Target` class will need some variables;
    we can tell from the event that there is some kind of collision component named
    `TargetCollision`, which has its overlap event bound to this function. As a component,
    it needs to be stored in a pointer; otherwise, we would be referencing the class,
    not an instance. We also need an integer named `TimesHit`. As discussed prior,
    mechanics are made by a team of programmers, designers, and artists. Linking the
    right particle system for user feedback is a designer’s job, so we’ll leave that
    as Blueprint for now, but we do need a way to fire the Blueprint side, so a `BlueprintImplementableEvent`
    will be needed. With that in mind, the header for our new class will look something
    like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个C++类来继承，鉴于它被命名为`BP_Target`，我们可以将其命名为`Target`。`Target`类需要一些变量；我们可以从事件中得知存在一个名为`TargetCollision`的碰撞组件，其重叠事件绑定到这个函数上。作为一个组件，它需要存储在指针中；否则，我们将引用类而不是实例。我们还需要一个名为`TimesHit`的整数。如前所述，机制是由程序员、设计师和艺术家团队制作的。将正确的粒子系统用于用户反馈是设计师的工作，所以我们现在将其作为蓝图，但我们确实需要一个方法来触发蓝图端，因此需要一个`BlueprintImplementableEvent`。考虑到这一点，我们新类的头文件看起来可能如下所示：
- en: Target.h
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Target.h
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice how the `UCLASS()` call includes the `Abstract` tag. This will stop designers
    from accidentally creating instances of your C++ classes that have not had any
    visuals set up.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`UCLASS()`调用中包含的`Abstract`标签。这将阻止设计师意外创建未设置任何视觉的C++类实例。
- en: 'The next step is to populate the function bodies:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是填充函数体：
- en: Target.cpp
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Target.cpp
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructor is going to be standard, creating the default sub-object for
    the collision component and binding the overlap function to that component’s overlap
    event (`OnTargetCollisionBeginOverlap`). In the `overlap` function, the cast node
    becomes a cast to a temporary “cache” variable with an `if` statement to check
    its value against `nullptr`. `_TimesHit` can then post increment, and the branch
    converts to an `if` statement which, if passed, will call the `BlueprintImplementableEvent`
    to pass the signal to the `Blueprint` child class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将是标准的，为碰撞组件创建默认的子对象，并将重叠函数绑定到该组件的重叠事件（`OnTargetCollisionBeginOverlap`）。在`overlap`函数中，转换节点变为对临时“缓存”变量的转换，并使用`if`语句检查其值是否为`nullptr`。然后`_TimesHit`可以递增，分支转换为`if`语句，如果通过，将调用`BlueprintImplementableEvent`将信号传递给`Blueprint`子类。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You are not required to build this example; it is here for reference only.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要构建这个示例；它仅用于参考。
- en: There will be plenty more examples of Blueprint to C++ conversion throughout
    the rest of this book, but if you would like to see some first-party examples,
    the template projects created by Epic can be loaded in both C++ and Blueprint
    versions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，将会有更多从蓝图到C++转换的示例，但如果你想看到一些第一方示例，Epic创建的模板项目可以在C++和蓝图版本中加载。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed what Unreal Engine 5 is and how to get it
    set up with a useful development environment. We also defined some of the key
    terms and tools we will be using in later chapters and shared a best practice
    strategy for building mechanics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了什么是虚幻引擎5以及如何设置一个有用的开发环境。我们还定义了一些将在后续章节中使用的术语和工具，并分享了一个构建机制的最佳实践策略。
- en: Lastly, we showed the process of translating from other practices to our new
    best practice.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了从其他实践到我们新最佳实践的转换过程。
- en: This forms the foundation for designing well-structured systems. At this point,
    you should be able to at least plan mechanics for your game and implement something
    that utilizes both C++ and Blueprint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这为设计良好结构的系统奠定了基础。到这一点，你应该至少能够为你的游戏规划机制，并实现利用C++和蓝图的功能。
- en: In the next chapter, we will cover the process of optimizing a bad project by
    implementing some of the patterns we will see later in the book. This should give
    you an understanding of why design patterns are useful before we jump into a deep
    dive of each one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现本书后面将看到的某些模式来优化一个糟糕的项目。这应该在你深入探讨每个模式之前，让你理解设计模式为什么有用。
- en: Let’s end the chapter by answering a few questions to test our knowledge and
    cement some of these practices covered in the chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回答一些问题来结束本章，以测试我们的知识并巩固本章中涵盖的一些实践。
- en: Questions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which one of these describes the implementation of `BlueprintNativeEvent`?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个描述了 `BlueprintNativeEvent` 的实现？
- en: A function that can be described in Blueprint.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在 Blueprint 中描述的函数。
- en: A function defined in C++ with both C++ and Blueprint implementations.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C++ 中定义的函数，同时具有 C++ 和 Blueprint 实现方式。
- en: An event declared in C++ but used in Blueprint with an `Execute` function.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C++ 中声明但在 Blueprint 中使用 `Execute` 函数的事件。
- en: How does Nanite work?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nanite 是如何工作的？
- en: Magic
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 魔法
- en: Mesh distance formulas
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格距离公式
- en: Sub-mesh **LOD** groups
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子网格 **LOD** 组
- en: Which one of these is not a Property Specifier?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是属性指定器？
- en: '`BlueprintWriteOnly`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BlueprintWriteOnly`'
- en: '`EditInstanceOnly`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EditInstanceOnly`'
- en: '`VisibleAnywhere`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VisibleAnywhere`'
- en: Which base class adds an `A` to the start of each of its children in C++?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个基类在 C++ 中将其每个子项的起始位置添加了 `A`？
- en: '`GameplayStatics`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GameplayStatics`'
- en: '`Actor`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Actor`'
- en: '`ActorComponents`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActorComponents`'
- en: All C++ functions should be marked as which of the following?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 C++ 函数应该标记为以下哪个？
- en: '`BuildOnly`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BuildOnly`'
- en: '`Pure`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pure`'
- en: '`Abstract`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Abstract`'
- en: Answers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: B
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
