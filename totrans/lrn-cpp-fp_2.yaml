- en: Manipulating Functions in Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about modern C++ in depth, especially about
    the new feature in C++11--the Lambda expression. As we discussed earlier, the
    Lambda expression is useful in simplifying function notation. Thus, in this chapter,
    we will apply the power of the Lambda expression again, which will be used in
    functional code, especially when we talk about currying--the technique to split
    and reduce the current function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the first-class function and higher-order function so that our functions
    can not only be invoked as a function, but also be assigned to any variable, pass
    a function, and return a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure function, to avoid side effect in our function since it no longer contacts
    an outside state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying, as mentioned at the beginning of this chapter, to reduce the multiple
    arguments function so we can evaluate a sequence of functions, with a single argument
    in each function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the first-class function in all functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first-class function is just a normal class. We can treat the first-class
    function like any other data type. However, in the language that supports the
    first-class function, we can do the following tasks without invoking the compiler
    recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as another function's parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning functions to variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing functions in collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new functions from the existing functions at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, C++ can be used to solve the preceding tasks. We will discuss it
    in depth in the following topics.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as another function's parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start to pass a function as the function parameter. We will choose one
    of four functions and invoke the function from its main function. The code will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we have four functions, and we want
    the user to choose one, and then run it. In the switch statement, we will invoke
    one of the four functions based on the choice of the user. We will pass the selected
    function to `PassingFunc()`, as we can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the input validation to prevent the user from selecting unavailable
    modes as well as inputting a non-integer value for variable `a` and `b`. The output
    we will see on the screen should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7a276f3-b116-4d3e-80fd-12b4fe9e197f.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that we select the `Multiplication` mode from
    the available modes. Then, we try to input the `r` and `e` variables for variable
    `a`. Fortunately, the program rejects it since we have had the input validation.
    Then, we give `4` to variable `a` and `2` to variable `b`. As we expect, the program
    gives us `8` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the `first_class_1.cpp` program, we use the `std::function`
    class and the `typedef` keyword to simplify the code. The `std::function` class
    is used to store, copy, and invoke any callable functions, Lambda expressions,
    or other function objects, as well as pointers to member functions and pointers
    to data members. However, the `typedef` keyword is used as an alias name for another
    type or function.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a function to a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also assign a function to the variable so we can call the function by
    calling the variable. We will refactor `first_class_1.cpp`, and it will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now assign the four functions based on the user''s choice and store
    the selected function in the `func` variable inside the switch statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `func` variable is assigned with the user''s choice, the code will
    just call the variable like it calls the function, as shown in the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And we will then obtain the same output on the console if we run the code.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a function in the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s save the function to the container. Here, we will use **vector**
    as the container. The code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we create a new vector named functions,
    then store four different functions to it. Just like we did with our two previous
    code examples, we ask the user to select the mode as well. However, now the code
    becomes simpler, since we don''t need to add the switch statement; we can select
    the function directly by selecting the vector index, as we can see in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, since the vector is a **zero-based** index, we have to adjust the index
    with the menu choice. The result will be same with our two previous code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new function from the existing functions at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's make a new function at runtime from the preexisting functions. Let's
    suppose we have two collections of functions, the first is hyperbolic functions
    and the second is the inverse of the first one. Beside these built-in functions,
    we also add one user-defined function to calculate the squared number in the first
    collection and the inverse of the squared number in the second collection. Then,
    we will implement the function composition and build a new function from two existing
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function composition** is a process to combine two or more simple functions
    to create a more complex one. The result of each function is passed as the argument
    to the next function. The final result is obtained from the last function result.
    In a mathematical approach, we usually use the following notation to function
    composition: `compose(f, g) (x) = f(g(x))`. Let''s suppose we have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`double x, y, z; // ... y = g(x); z = f(y);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to simplify the notation, we can use the function composition and have
    the following notation for *z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`z = f(g(x));`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the hyperbolic functions, then pass the result to the inverse one,
    we will see that we indeed get the original value that we passed to the hyperbolic
    function. Now, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we have two function collections--`funcs`
    and `inverseFuncs`. Moreover, as we discussed previously, the `inverseFuncs` function
    is the inverse of the `funcs` function. The `funcs` function contains three built-in
    hyperbolic functions, along with one user-defined function to calculate the squared
    number, whereas `inverseFuncs` contains three built-in inverse hyperbolic functions
    along with one user-defined function to compute the inverse of the squared number.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding `first_class_4.cpp` code, we will use individual
    classes/functions when calling the `using` keyword. Compared to the other code
    samples in this chapter, the use of the `using` keyword in individual classes/functions
    is inconsistent, since we use `using namespace std`. It's because there's a clashing
    function name in the `std` namespace, so we have to call them individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using these two collections of functions, we will construct one new function
    from them. To achieve this purpose, we will use the `transform()` function to
    combine the two functions from the two different collections. The code snippet
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a new function collection stored in the `composedFuncs` vector.
    We can iterate the collection and pass the value we have provided in the `nums`
    variable to this new function. We should obtain the following output on the console
    if we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/020e5ce8-760c-4446-82c2-7aeca8fddc1a.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding output, whatever we pass to the transforming
    function, we will get the same output as the input. Here, we can prove that C++
    programming can be used to compose a function from two or more existing functions.
  prefs: []
  type: TYPE_NORMAL
- en: On the preceding `first_class_4.cpp` code, we use `template<>` in the code.
    If you need a more detailed explanation about `template<>`, refer to [Chapter
    7](2093af96-36ce-46a4-b90f-ee9876987290.xhtml), *Running Parallel Execution Using
    Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting acquainted with three functional techniques in the higher-order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed that in the first-class function, the C++ language treats the functions
    as the value, which means we can pass them to the other functions, assign to variables,
    and so on. However, we have another term in functional programming, that is, a
    higher-order function, which are functions that work on other functions. It means
    the higher-order function can pass functions as the argument and can also return
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-order function concept can be applied to the function in general,
    like in a mathematical function, instead of the first-class function concept that
    can only be applied in the functional programming language. Now, let's examine
    the three most useful higher-order functions in functional programming--**map**,
    **filter**, and **fold**.
  prefs: []
  type: TYPE_NORMAL
- en: Executing each element list using map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We won''t talk about map as a container in the C++ language, but a feature
    in the higher-order function instead. This feature is used to apply a given function
    to each element of the list and return a list of results in the same order. We
    can use the `transform()` function to achieve this purpose. As you know, we already
    discussed this function previously. However, we can take a look at the following
    piece of code to view the use of the `transform()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in our preceding definition of map in the higher-order function, it
    will apply the given function to each element of the list. In the preceding code,
    we try to map the `v1` vector to the `v2` vector with the given function in the
    Lambda expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the code, we should get the following output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30abb408-577c-4cfd-82c7-8b1030998fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the output display, we transform `v1` into `v2` using the given
    function notating in the Lambda expression, which is doubling the input value.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data using filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filter, in a higher-order function, is a function to produce a new data structure
    from the existing one that exactly matches each element in the new data structure
    to a given predicate returning a Boolean value. In C++ language, we can apply
    the `copy_if()` function, which is added in C++11, to gain the filtering processes.
    Let''s take a look at the following piece of code to analyze the filtering process
    using the `copy_if()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we see in the preceding code, we filter the `numbers` vector into the `0`
    primes vector using the `copy_if()` function. We will pass the Lambda expression
    to decide whether or not the selected element is a prime number, as we used for
    the `lambda_multiline_func.cpp` code in [Chapter 1](58c8c3cc-432a-4664-be4d-a78917b16f15.xhtml),
    *Diving into Modern C++*. We will also use the `copy()` function to copy all elements
    in the selected vector to be printed. The result, when we run the preceding code,
    should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84a91b01-5fb5-4111-afaa-c2ca77c868ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Beside the `copy_if()` function, we can also use the `remove_copy_if()` function
    to filter the data structure. Instead of selecting the match predicate element
    from the existing data structure, using the `remove_copy_if()` function will omit
    the match predicate element, choose the unmatch one, and store it in the new data
    structure. Let''s refactor our `filter_1.cpp` code and create a new vector that
    is not a prime number. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding highlighted code, we refactor the previous
    code and use the `remove_copy_if()` function to choose non-prime numbers. As we
    expect, the console window will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0b50b7a-1cfb-48ed-b552-c4bfb806a152.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have the non-prime number instead of the prime number, like we have in
    the `filter_1.cpp` code.
  prefs: []
  type: TYPE_NORMAL
- en: Combining all elements of a list using fold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, a fold is a technique to reduce a data structure
    into a single value. There are two types of fold--left fold (`foldl`) and right
    fold (`foldr`). Let''s suppose we have a list that contains 0, 1, 2, 3, and 4\.
    Let''s use the fold technique to add all the contents of the list, first using
    `foldl` and then `foldr`. However, there is a significant difference between the
    two--`foldl` is the left associative, which means we combine the leftmost element
    then move towards the rightmost element. For instance, by the list we have, we
    will get the following parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While `foldr` is the right associative, which means we will combine the rightmost
    element then move towards the leftmost element. The parentheses will be like the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++ programming, we can apply the `fold` technique using the `accumulate()`
    function. As we can see in the preceding code, we use the forward iterator in
    `foldl` while we use the backward iterator in `foldr`. The output on the console
    should be like following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cb482af-59c6-4f00-b396-d4fbabd686c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the preceding output screenshot, we''ve got the same result
    for both, the `foldl` and `foldr` techniques. For those curious about the order
    of the sum, we can refactor the preceding code into the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we pass a new `addition()` function and pass it to the
    `accumulate()` function. From the `addition()` function, we will track the operation
    of each element. Now, let''s run the preceding code whose the output will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b662182-a4b8-4a3f-a969-29983904dcbb.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding output screenshot, we can see that, even though both `foldl`
    and `foldr` give the exact same result, they make a different operation order.
    Since we set the initial value to `0`, the addition operation starts by adding
    `0` to the first element in the `foldl` technique and to the last element in the
    `foldr` technique.
  prefs: []
  type: TYPE_NORMAL
- en: We will set the initial value to `0` because `0` is the additive identity that
    won't impact the addition result. However, in multiplication, we have to consider
    changing the initial value to `1` since `1` is the identity element for multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the side effect with pure function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **pure function** is a function that will always return the same result every
    time it is given the same input. The result doesn''t depend on any information
    or state and won''t produce a **side effect**, or a change of the system state
    outside of the function. Let''s take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we have a function named `circleArea()`
    to calculate the area of a circle based on the given radius. We then invoke the
    function five times and pass the same radius value. The output on the console
    should be like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/363316b8-632e-4346-a2f6-50003c5a8c14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, in five invocations passing the same input, the function returns
    the same output as well. So that we can say that `circleArea()` is a pure function.
    Now, let''s see how the impure function looks like in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we see that a function named `increment()` increases
    the value of the `currentState` variable. As we can see, the `increment()` function
    depends on the value of the `currentState` variable, so it''s not a pure function.
    Let''s prove it by running the preceding code. The console window should display
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0f1d544-925c-447a-9780-1ae4db9ca6f1.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the `increment()` function gives a different result even though
    we pass the same input. It's the side effect of the impure function when it depends
    on the outside state or changes the value of the outside state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been able to distinguish the pure function over the impure function.
    However, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code comes from `pure_function_1.cpp`, but we add a global state,
    `phi`. If we run the preceding code, we will definitely obtain the same result
    as `pure_function_1.cpp`. Although the function returns the same result in the
    five invocations, `circleArea()` in `im_pure_function_1.cpp` is not a pure function
    since it depends on the `phi` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The side effect is not only the change of global state that is done by the function.
    Printing to the screen is also the side effect. However, since we need to show
    the result of every code we create, we cannot avoid the existence of printing
    to screen in our codes. In the next chapter, we will also discuss the immutable
    state, which is the way we can turn an impure function into a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing a multiple arguments function with currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currying is a technique to split a function that takes multiple arguments into
    evaluating a sequence of functions, each with a single argument. In other words,
    we create other functions based on a current function by reducing the current
    function. Let''s suppose we have a function named `areaOfRectangle()`, which takes
    two parameters, `length` and `width`. The code will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have a variadic template and function
    named `curry`. We will use this template to construct a currying function. In
    a normal function invocation, we can invoke the `areaOfRectangle()` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we pass `5` and `2` as the argument
    to the `areaOfRectangle()` function. However, using the curried function, we can
    reduce the `areaOfRectangle()` function so we just have a single argument. All
    we have to do is invoke the curry function template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the `areaOfRectangle()` function having the value for the `length`
    argument named `length5`. It''s easier for us to call the function and add just
    the `width` argument as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the output we will see on the console when we run the
    preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1097f10c-3b57-448c-8d71-fc69bf9f4918.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The variadic template and function has helped us reduce the `areaOfRectangle()`
    function to become the `length5()` function. However, it can also help us reduce
    the function that has more than two arguments. Let''s suppose we have a function
    named `volumeOfRectanglular()` that passes three arguments. We will reduce the
    function as well, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have successfully passed the `length`
    and `width` arguments to the `volumeOfRectanglular()` function only, then reduced
    it as `length5width4()`. We can invoke the `length5width4()` function and just
    pass the rest argument, `height`, to it. The following is the output we will see
    on the console screen if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbbc74e9-74e1-4a84-af5e-59a4b8494f0c.png)'
  prefs: []
  type: TYPE_IMG
- en: By using the currying technique, we can partially evaluate a multiple arguments
    function by reducing the function so it will only pass a single parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed that there are some techniques to manipulate a function. We
    will gain many advantages from it. Since we can implement the first-class function
    in the C++ language, we can pass a function as another function's parameter. We
    can treat a function as a data object so we can assign it to a variable and store
    it in the container. Also, we can compose a new function from the existing one.
    Moreover, by using map, filter, and fold, we can implement the higher-order function
    in every function we create.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique we have to implement in gaining a better functional code is
    a pure function to avoid a side effect. We can refactor all the functions we have
    so it won't talk to outside variables or states and won't change and retrieve
    the value from the outside state. Also, to reduce the multiple arguments function
    so we can evaluate its sequence, we can implement the currying technique to our
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss another technique to avoid side effects.
    We will make all states in our code immutable so there's no state that will mutate
    each time the function is invoked.
  prefs: []
  type: TYPE_NORMAL
