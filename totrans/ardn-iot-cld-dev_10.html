<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-211"><a id="_idTextAnchor211"/>10</h1>
<h1 id="_idParaDest-212"><a id="_idTextAnchor212"/>Project #6 – Making Your Home Smarter with a Voice Assistant</h1>
<p>This chapter is dedicated<a id="_idIndexMarker803"/> to smart homes. <strong class="bold">Smart homes</strong> is a wide field that aims to automate everything in your home to make your life experience better and more comfortable, for example, smart light systems, smart air conditioning, smart TVs, and so on. But in this chapter, we will explore how we can build a multi-color smart bulb that is controlled by the <strong class="bold">Arduino IoT Cloud</strong> web and mobile dashboard. We’ll also add the Amazon Alexa voice assistant to control the smart bulb using voice commands.</p>
<p>Here, we will practically<a id="_idIndexMarker804"/> explore smart homes, picking up the <strong class="bold">WS2812 RGB LED</strong> ring and Seeed Studio’s newest, and very small, development board in the XIAO series, which is based on ESP32 with a lot of features. With the help of the light module, development board, and the Arduino IoT Cloud, we will build a smart light system.</p>
<p>By the end of this chapter, you will have the confidence to build smart home solutions with the help of any open source ESP32/ESP8266 or Arduino series development board using the Arduino IoT Cloud. In particular, you will learn how easy it is to integrate Amazon Alexa Voice assistant into your smart home projects to make them more convenient for end users.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Creating smarter homes with IoT</li>
<li>Essential components – sensors and development boards</li>
<li>Blueprint for your smart home IoT project</li>
<li>Initial setup – Thing, network credentials, cloud variables, and code</li>
<li>User-friendly controls – building web and mobile dashboards</li>
<li>Enhancing controls – integrating the Arduino IoT Cloud with Amazon Alexa</li>
</ul>
<h1 id="_idParaDest-213"><a id="_idTextAnchor213"/>Technical requirements</h1>
<p>The following hardware components are required to complete this chapter’s exercise:</p>
<ul>
<li>Seeed Studio XIAO ESP32C3</li>
<li>USB type-C cable for XIAO ESP32C3</li>
<li>WS2812 RGB LED ring</li>
<li>Male headers, female headers, and a veroboard</li>
<li>Jumper cables</li>
<li>Soldering iron</li>
<li>Amazon Echo Dot and the Amazon Alexa mobile app</li>
</ul>
<p>For coding, we will use the <strong class="bold">Arduino Web Editor</strong>, which includes a large collection of development boards and sensor libraries, and the Arduino IoT Cloud for the Thing and dashboard setup. To develop hardware and sensor designs, we need the <strong class="bold">Fritzing</strong> desktop software and the <strong class="bold">Arduino IDE</strong> for testing the WS2812 ring.</p>
<p>Here, we will use the <strong class="bold">Amazon Echo Dot</strong> as a voice assistant for voice commands to control the smart bulb. If you don’t have an Echo Dot, then you can use the <strong class="bold">Amazon Alexa</strong> app for Android/iOS. The chapter’s code is available in the official GitHub repository for the book by following this link: <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers</a>.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor214"/>Creating smarter homes with IoT</h1>
<p><strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) technology plays a crucial role in the development of smart<a id="_idIndexMarker805"/> homes. It enables various devices<a id="_idIndexMarker806"/> and appliances within a home to connect, communicate, and automate tasks for the convenience, comfort, and efficiency of homeowners. Here are some key aspects of IoT for smart homes:</p>
<ul>
<li><strong class="bold">Connectivity</strong>: IoT devices in a smart home are connected to the internet, allowing them to communicate<a id="_idIndexMarker807"/> with each other, as well as with the<a id="_idIndexMarker808"/> homeowner, remotely. This connectivity facilitates the control, monitoring, and automation of devices from anywhere, using smartphones, tablets, or computers.</li>
<li><strong class="bold">Home automation</strong>: IoT enables the automation of various tasks within a smart home. For example, lights can automatically turn on or off based on occupancy or the time of day. Thermostats can adjust temperature settings based on the homeowner’s preferences or presence in the house. IoT-powered automation helps optimize energy usage, enhance security, and simplify routine activities.</li>
<li><strong class="bold">Security and surveillance</strong>: IoT devices can enhance the security of a smart home. Smart locks provide keyless entry and allow remote access control. Video doorbells enable homeowners to see and communicate with visitors remotely. Surveillance cameras can be accessed and monitored from anywhere, providing an additional layer of security.</li>
<li><strong class="bold">Energy management</strong>: IoT devices help optimize energy consumption within a smart home. Smart thermostats learn user preferences and adjust temperature settings accordingly, conserving energy when rooms are unoccupied. Smart plugs and power strips can monitor and control the energy usage of appliances and electronics, helping identify energy-hungry devices and promoting efficient usage.</li>
<li><strong class="bold">Voice control</strong>: Voice assistants, such as Amazon Alexa or <strong class="bold">Google Assistant</strong>, integrated with IoT <a id="_idIndexMarker809"/>devices enable<a id="_idIndexMarker810"/> hands-free control of various functions in a smart home. Homeowners can use voice commands to control lights, adjust thermostats, play music, check the weather, and perform other tasks, enhancing convenience and accessibility.</li>
<li><strong class="bold">Health and wellness</strong>: IoT devices can contribute to health and wellness within a smart home. Wearable devices, such as fitness trackers or smartwatches, can integrate with other home devices, such as smart scales or health monitors, to provide comprehensive health data and insights. This data can be shared with healthcare professionals or used to automate certain health-related tasks.</li>
<li><strong class="bold">Appliance control</strong>: IoT enables the remote control and monitoring of various appliances in a smart home. Refrigerators, ovens, washing machines, and other appliances can be connected to the internet, allowing homeowners to check their status, receive alerts, or control their operation remotely. This connectivity adds convenience and flexibility to household chores and management.</li>
<li><strong class="bold">Integration and interoperability</strong>: A crucial aspect of IoT for smart homes is the integration and interoperability<a id="_idIndexMarker811"/> of devices<a id="_idIndexMarker812"/> from different manufacturers. Standards and protocols, such as <strong class="bold">Zigbee</strong> or <strong class="bold">Z-Wave</strong>, facilitate the seamless connection and communication between devices, ensuring that different IoT products can work together in a unified ecosystem.</li>
</ul>
<p>It’s important to note that while IoT technology brings numerous benefits to smart homes, it also introduces potential security and privacy risks. Homeowners should take measures to secure their IoT devices, such as using<a id="_idIndexMarker813"/> strong passwords, keeping firmware up to date, and ensuring proper network<a id="_idIndexMarker814"/> security configurations.</p>
<p>Here, we have discussed in detail how IoT is reshaping the lives of human beings in homes and offices. Next, we are going to talk about the hardware and components that we require to carry on with this chapter’s project.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor215"/>Essential components – sensors and development boards</h1>
<p>In the ESP32 series, we have a wide<a id="_idIndexMarker815"/> collection of development<a id="_idIndexMarker816"/> boards, which vary in size and pins. In this chapter, we are using Seeed Studio’s latest development board, the <strong class="bold">XIAO ESP32C3</strong>, as it’s very compact and smaller in size<a id="_idIndexMarker817"/> than other boards, and of course, cheaper and is suitable for 5V as well as 3.3V. The following figure is the pin layout diagram of XIAO ESP32C3.</p>
<div><div><img alt="Figure 10.1 – XIAO ESP32C pinout diagram" src="img/B19752_10_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – XIAO ESP32C pinout diagram</p>
<p>XIAO ESP32C provides multiple pins for digital input/output. In the previous ESP series board, we found only one analog pin, but on this development board, we have four analog pins, which removes the biggest hurdle while developing a solution that uses multiple analog pins. With previous ESP series boards, we used ADS1115/ADS1015 for extra analog pins, so this development board will save us some bucks as we will get four analog pins by default on the development board.</p>
<p>Besides all those features, XIAO<a id="_idIndexMarker818"/> provides a built-in battery charge module and the board<a id="_idIndexMarker819"/> is optimized for power consumption, which helps to use this board as a wearable device. For connectivity, there<a id="_idIndexMarker820"/> are both Wi-Fi and Bluetooth options available. It also supports <strong class="bold">Bluetooth Low Energy</strong> (<strong class="bold">BLE 5</strong>), which is more specific to IoT<a id="_idIndexMarker821"/> use cases. For further details, please visit <a href="https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/">https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/</a>.</p>
<p>In the current project, we need one digital pin for the WS2812 RGB LED ring. One of the good features of the development board is that we have a 5V power pin, which is not available on most of the ESP32 series development boards.</p>
<p>We are using the WS2812 16-pixel RGB ring but it comes in different pixels and shapes, such as a stick, matrix, and strip. For the lamp, we prefer the ring shape, but you guys can choose according to your preferences. WS2812 also comes in long strip cables for room decoration and computer tables – especially for gamers, hotels, and so on. There are different vendors who provide the WS2812 module, but we are using a WS2812 that we purchased from AliExpress and it’s working perfectly. You can buy it from Amazon, AdaFruit, SparkFun, or from AliExpress.</p>
<p>WS2812 comes<a id="_idIndexMarker822"/> with RGB color, and it also allows you to control the brightness<a id="_idIndexMarker823"/> of the module, which varies from 1–100%. It also allows you to control every single pixel of the LED – either on/off, or any color, which provides a broad range of use cases to develop interesting solutions and prototypes. The WS2812 RGB LED comes in different sizes and shapes. The following figure shows the RGB LED ring with both the front and back sides.</p>
<div><div><img alt="Figure 10.2 – WS2812 RGB LED ring and pinout diagram" src="img/B19752_10_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – WS2812 RGB LED ring and pinout diagram</p>
<p>The preceding diagram depicts the pinout layout of the WS2812 RGB ring. The complete configuration of the pin connections of WS2812 with XIAO ESP32C3 is shown in <em class="italic">Table 10.1</em>. <em class="italic">Pin #1</em> is a GND pin that connects with the onboard GND pin of XIAO ESP32C3. <em class="italic">Pin #2</em> is a Power 5V DC pin that works with both 3.3V and 5V. <em class="italic">Pin #3</em> is <strong class="bold">Data Input</strong>, which connects with any digital pin. <em class="italic">Pin #4</em> is <strong class="bold">Data Out</strong>, which is only used if you want to extend the WS2812 ring with another ring or stick – this pin will connect to the other ring’s data input pin as an extension. Here, I am connecting <strong class="bold">Data Input</strong> with <em class="italic">Pin #D3</em> of the board. You can solder the male headers with WS2812 or directly solder the cables without any header pins.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The WS2812 module works perfectly, but still it’s necessary to verify that all pixels of the ring/strip are working perfectly. In my case, my last pixel is not working.</p>
<p>In the current section, we have<a id="_idIndexMarker824"/> discussed the XIAO ESP32C3 and WS2812 RGH LED<a id="_idIndexMarker825"/> ring, as well as its pins. Next, we are going to discuss the project architecture in detail, which includes the project schematics and assembly.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor216"/>Blueprint for your smart home IoT project</h1>
<p>In the preceding sections, we discussed<a id="_idIndexMarker826"/> the sensors and development board in detail. Now, it’s time to cook the recipe. In hardware development, before starting to work with sensors and development boards, we need to develop the design concepts to get a better understanding of how things will be connected. There is a lot of software available to design and develop design concepts regarding electronics projects, but we are going to use Fritzing.</p>
<p>In the following two subsections, first, we will talk about the schematics and design of a project and explain how to connect the pins of the development board with soldering. Next, we will do some testing of the WS2812 to check all the colors and pixels are working.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor217"/>Schematic design and assembly</h2>
<p>The purpose of the design<a id="_idIndexMarker827"/> is to clearly understand how sensors will connect<a id="_idIndexMarker828"/> with the development board. It helps engineers to develop a prototype on a breadboard or on a veroboard by using these design files. Another major benefit of designing is that Fritzing builds hardware schematics and a <strong class="bold">Printed Circuit Board</strong> (<strong class="bold">PCB</strong>) design in the background according<a id="_idIndexMarker829"/> to your design, which could be adjusted by designers according to system requirements. The complete connection diagram of the XIAO ESP32C3 and WS2812 RGB LED ring is shown in the following figure.</p>
<div><div><img alt="Figure 10.3 – XIAO ESP32C and WS2812 system design" src="img/B19752_10_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – XIAO ESP32C and WS2812 system design</p>
<p><em class="italic">Figure 10</em><em class="italic">.3</em> illustrates the pin diagram<a id="_idIndexMarker830"/> of the whole setup, but for easy<a id="_idIndexMarker831"/> guidance, we also created <em class="italic">Table 10.1</em>, which explains, in a simple way, how to connect the pins of WS2812 to XIAO ESP32C.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-6">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">XIAO ESP32C</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">WS2812 Ring</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>A3</p>
</td>
<td class="No-Table-Style">
<p>Data Input</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>5V</p>
</td>
<td class="No-Table-Style">
<p>Power 5V DC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>Power Signal Ground</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 – XIAO ESP32C and WS2812 connection</p>
<p>The preceding design and table provide a full overview of how you can connect the sensors to the development board. According to the design, we have common 5V and GND pins from the XIAO ESP32C3 board to the WS2812 module. WS2812 is a digital module so we connected its <strong class="bold">Data Input</strong> pin to the D3 pin of the development board. The following figure shows the final prototype of the smart bulb on the veroboard.</p>
<div><div><img alt="Figure 10.4 – Final prototype" src="img/B19752_10_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Final prototype</p>
<p>After soldering cables to the module and the male header to the XIAO ESP32C3, connect the pins according to the schematic diagram. There is only one module, so there is no requirement for a veroboard. But I am developing<a id="_idIndexMarker832"/> a proper prototype<a id="_idIndexMarker833"/> this time – that’s why I used a Veroboard. Now it’s time to verify the colors and pixels of the WS2812 using ESP32C3.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor218"/>Testing the WS2812 with the Arduino IDE</h2>
<p>To install the ESP32 series development board<a id="_idIndexMarker834"/> in the Arduino IDE, first, add the board’s definition<a id="_idIndexMarker835"/> file in the preferences. To proceed further, follow these steps:</p>
<ol>
<li>Navigate to <strong class="bold">File</strong> &gt; <strong class="bold">Preferences</strong> and fill <strong class="bold">Additional Boards Manager URLs</strong> with the URL <a href="https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json</a>, as shown in the following figure.</li>
</ol>
<div><div><img alt="Figure 10.5 – ESP32 board information in the Arduino IDE" src="img/B19752_10_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – ESP32 board information in the Arduino IDE</p>
<ol>
<li value="2">Later on, navigate<a id="_idIndexMarker836"/> to <code>esp32</code> in the search box, select the latest version of <strong class="bold">esp32</strong>, and install it, as shown in the following figure.</li>
</ol>
<div><div><img alt="Figure 10.6 – ESP32 series board installation in the Arduino IDE" src="img/B19752_10_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – ESP32 series board installation in the Arduino IDE</p>
<ol>
<li value="3">Finally, select the board, navigate<a id="_idIndexMarker838"/> to <strong class="bold">Tools</strong> &gt; <strong class="bold">Board</strong> &gt; <strong class="bold">ESP32 Arduino</strong>, and select <strong class="bold">XIAO_ESP32C3</strong>. The list of boards<a id="_idIndexMarker839"/> is a little long and you need to scroll to the bottom, as shown in the following figure.<div><img alt="" role="presentation" src="img/B19752_10_07.jpg"/></div></li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – XIAO ESP32C3 board selection in the Arduino IDE</p>
<p>It’s time to install the WS2812 library. Navigate to <code>Adafruit neopixel</code> in the search bar. Here, you will get different libraries, but you need to install the specific library that matches the search query.</p>
<p>Now we are ready to proceed<a id="_idIndexMarker840"/> with the testing <a id="_idIndexMarker841"/>steps. Download the code from the official GitHub repository for the book, navigate to the <code>WS2812_Testing</code> folder, and open up the code:</p>
<pre class="source-code">
#include &lt;Adafruit_NeoPixel.h&gt;
#define LED_PIN    D3
// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 16
// Declare our NeoPixel strip object:
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
void setup() {
  strip.begin();           // INITIALIZE NeoPixel strip object (REQUIRED)
  strip.show();            // Turn OFF all pixels ASAP
  strip.setBrightness(50); // Set BRIGHTNESS to about 1/5 (max = 255)
}</pre> <p>Change the <code>LED_PIN</code> constant to <code>D3</code> or <code>D5</code>. Next, assign the number of pixels to the <code>LED_COUNT</code> constant. Right now, I have 16 pixels in the WS2812 – that’s why I am inserting <code>16</code>. After making modifications, upload the code to the board. Later, you will see the color white on the LED and a moving animation in a circular form. In the <code>setup()</code> method, we initialized <code>NeoPixel strip</code> and set the brightness to 50%:</p>
<pre class="source-code">
// loop() function -- runs repeatedly as long as board is on ---------------
void loop() {
  for(int i=0; i&lt;LED_COUNT+1; i++){
    strip.setBrightness(50);
    strip.setPixelColor(i, strip.Color(127+i, 127, 127)); //  Set pixel's color (in RAM)
    strip.show();
    delay(200);
  }
    for(int i=0; i&lt;LED_COUNT+1; i++){
    strip.setBrightness(0);
    strip.setPixelColor(i, strip.Color(0, 0, 0)); //  Set pixel's color (in RAM)
    strip.show();
  }
}</pre> <p>Later, in the <code>loop()</code> method, there<a id="_idIndexMarker842"/> are two loops. The first loop<a id="_idIndexMarker843"/> is used to assign the white color to each pixel and turn on the pixel according to the loop value, with a delay of 200 milliseconds, while in the second loop, we turn off all the pixels one by one by changing the brightness to <code>0</code> and RGB colors to <code>0</code>.</p>
<p>In this section, we have assembled <a id="_idIndexMarker844"/>the hardware component on the veroboard and used the code to verify that the WS2812 RGB LED<a id="_idIndexMarker845"/> is working. Next, we will set up the Thing and cloud variables in the Arduino IoT Cloud to make our prototype live.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor219"/>Initial setup – Thing, network credentials, cloud variables, and code</h1>
<p>After setting up the hardware, it’s time to set up Thing in the Arduino IoT Cloud. For this project, we need one cloud variable to control the LED brightness and color, and turn on/off the WS2812 ring, but I am using three different cloud variables so you will get an idea of when and why we need to use these cloud variables, and every variable connects with a specific widget. The network settings<a id="_idIndexMarker846"/> will be different from Arduino development boards due to using ESP series board.</p>
<div><div><img alt="Figure 10.8 – Air quality monitoring system Thing setup" src="img/B19752_10_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Air quality monitoring system Thing setup</p>
<p>Set up a new <code>Voice Controlled Smart Lamp</code> and follow these steps<a id="_idIndexMarker847"/> to create variables, associate a device and network configuration, and finally, write the code:</p>
<ol>
<li>Firstly, we need to set up three cloud variables for the WS2812. Complete details regarding cloud variables are available in the following section.</li>
<li>After that, we need to associate the device with the Thing. In the current project, we are using the XIAO ESP32C3, so the wizard will be different than for Arduino boards. The complete details are available in the <em class="italic">Associating a </em><em class="italic">device</em> section.</li>
<li>Finally, we need to set up the network configuration for the device, but this time we need to provide a security key for ESP series boards to make the connection secure. Arduino-compatible boards are configured by the Arduino IoT Cloud automatically during the device setup wizard.</li>
</ol>
<h2 id="_idParaDest-220"><a id="_idTextAnchor220"/>Cloud variables</h2>
<p>The following table provides all the properties<a id="_idIndexMarker848"/> of the variables that we need to use during cloud variable creation. For the WS2812, we can use the integer and bool data types, which creates a lot of mess, but thanks to the Arduino IoT Cloud’s extended group of variables, we have the <strong class="bold">Dimmed light</strong>, <strong class="bold">Color</strong>, and <strong class="bold">Colored Light</strong> type variables. Next, make sure the same variables are declared as shown in <em class="italic">Table 10.2</em>, otherwise, you’ll need to modify the example code according to your naming.</p>
<p>Here, I made the permission read and write, as this time we will send commands from the cloud dashboard or voice assistant, so it’s mandatory to give cloud variables permission to read and write.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">S#</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update </strong><strong class="bold">Policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p><code>LightBrightness</code></p>
</td>
<td class="No-Table-Style">
<p>Dimmed light</p>
</td>
<td class="No-Table-Style">
<p><code>lightBrightness</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p><code>RGBLightColor</code></p>
</td>
<td class="No-Table-Style">
<p>Color</p>
</td>
<td class="No-Table-Style">
<p><code>rGBLightColor</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p><code>TableLight</code></p>
</td>
<td class="No-Table-Style">
<p>Colored Light</p>
</td>
<td class="No-Table-Style">
<p><code>tableLight</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.2 – Cloud variables properties table</p>
<p>Previously, I mentioned that we only need one cloud variable, but I am using three different cloud variables and will explain their usage. If I start from the <code>RGBLightColor</code>, has only one option regarding the color change. But if we come to the <strong class="bold">Colored Light</strong> type cloud variable, then it provides all three options: brightness, color, and an on/off switch. This cloud variable is also compatible with Amazon Alexa and that type cloud variable will be represented as a device in the Amazon Alexa Smart Home skills portal, which is discussed<a id="_idIndexMarker849"/> in the <em class="italic">Enhancing control – Integrating Arduino IoT Cloud with Amazon </em><em class="italic">Alexa</em> section.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor221"/>Associating a device</h2>
<p>After variable<a id="_idIndexMarker850"/> creation, it’s time to add a device associated with the Thing. Before adding<a id="_idIndexMarker851"/> the device, connect the development board to the computer and open the <strong class="bold">Arduino Create Agent</strong> application. The following figure shows how to select the ESP32 and then the XIAO_ESP32C3 development board in the popup.</p>
<div><div><img alt="Figure 10.9 – Device selection wizard" src="img/B19752_10_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Device selection wizard</p>
<p>Follow these steps to associate<a id="_idIndexMarker852"/> the XIAO ESP32C3 to the Thing:</p>
<ol>
<li>Click on the <strong class="bold">Select Device</strong> button under the <strong class="bold">Associated Device</strong> section on the Thing page shown in <em class="italic">Figure 10</em><em class="italic">.8</em>.</li>
<li>A popup will appear where you can see all the devices that are already available. If you have already added your XIAO ESP32C3, select it. Otherwise, click on <strong class="bold">SET UP </strong><strong class="bold">NEW DEVICE</strong>.</li>
<li>Next, click on the <strong class="bold">Third party </strong><strong class="bold">device</strong> option.</li>
<li>Select <strong class="bold">ESP32</strong> and <strong class="bold">XIAO_ESP32C3</strong> from the dropdown and click on the <strong class="bold">CONTINUE</strong> button shown in <em class="italic">Figure 10</em><em class="italic">.9</em>.</li>
<li>Fill in <strong class="bold">Device Name</strong> and click on the <strong class="bold">Next</strong> button.</li>
<li>In the final wizard, <strong class="bold">Device ID</strong> and <strong class="bold">Secret Key</strong> will be displayed. Copy the secret key to a safe<a id="_idIndexMarker853"/> place as it will be used during the network configuration.</li>
</ol>
<p>Now, let’s move to the network configuration.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor222"/>Network</h2>
<p>After associating<a id="_idIndexMarker854"/> the device with the Thing, it is time to configure the Wi-Fi settings for device communication. The following figure shows the network configuration popup with the <strong class="bold">Wi-Fi Name</strong> and <strong class="bold">Password</strong> fields.</p>
<div><div><img alt="Figure 10.10 – Network configuration for ﻿the Thing" src="img/B19752_10_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Network configuration for the Thing</p>
<p>You will find a new field – <strong class="bold">Secret Key</strong>. Paste the secret<a id="_idIndexMarker855"/> key that we received from the system during device creation.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor223"/>Coding</h2>
<p>The chapter’s code<a id="_idIndexMarker856"/> is available at the official GitHub repository for the book. Download the <code>Voice_Controlled_Smart_Lamp_may13a</code> code from the repository and import it to the Arduino Web Editor.</p>
<p>You can download the code and put it into your Thing by navigating to the <code>delay()</code> method – it will block the <code>ArduinoCloud.update()</code> method. But before moving forward, at the start of the code, we need to change the <code>LED_PIN</code> constant to <code>5</code> and assign a value to <code>LED_COUNT</code> according to the number of pixels in the ring/strip. Here, I am assigning the value <code>16</code> as I am using a 16-pixel ring:</p>
<pre class="source-code">
#define LED_PIN   5
// How many NeoPixels are attached to the Arduino?
#define LED_COUNT 16
// Declare our NeoPixel strip object:
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);
//Sync Variables
bool swi;
float bright;
float sat;
float hue;</pre> <p>If we review the preceding code for the constant, then we will see there is one <code>NeoPixel strip</code> object and four global variables for the switch (<code>swi</code>), brightness (<code>bright</code>), saturation (<code>sat</code>), and hue that will be used later to sync the values from one widget control to another widget control to enable the synchronization between widgets.</p>
<p>After filling the preceding constants with appropriate values, it’s time to explore some other methods. If we talk about the setup, then there are only a few lines that initiate the <code>NeoPixel strip</code> object as well as the Arduino IoT Cloud and some other operations. In this project, our <code>loop()</code> method will include one line regarding an Arduino Cloud update and nothing else. Actually, in this project, code will be executed where any change happens on the widget side.</p>
<p>In the project, we have<a id="_idIndexMarker857"/> four more methods. Three are event-oriented<a id="_idIndexMarker858"/> and one is a common helper method that will be used by three <code>onLightBrightnessChange()</code>, <code>onRGBLightColorChange()</code>, and <code>onTableLightChange()</code> methods are event-oriented and the <code>ControlTheWS2812()</code> method is a <strong class="bold">common helper method</strong>. Next, we are going to explore all the methods step by step:</p>
<pre class="source-code">
void onLightBrightnessChange()  {
  // Add your code here to act upon LightBrightness change
  swi=lightBrightness.getSwitch();
  bright=lightBrightness.getBrightness();
  //Sync the values to tableLight Cloud Variable
  tableLight.setSwitch(swi);
  tableLight.setBrightness(bright);
  //Call the method for operations on WS2812
  ControlTheWS2812();
}</pre> <p>In the <code>onLightBrightnessChange()</code> method, we take brightness and switch values from the <code>lightBrightness</code> cloud variable and later assign the values with global variables. The last calling method, <code>ControlTheWS2812()</code>, performs the operation on the WS2812 ring according to global variable values:</p>
<pre class="source-code">
void onRGBLightColorChange()  {
  // Add your code here to act upon RGBLightColor change
  hue=rGBLightColor.getValue().hue;
  sat=rGBLightColor.getValue().sat;
  bright=rGBLightColor.getValue().bri;
  //Sync the values with LightBrightness &amp; tableLight widget
  tableLight.setBrightness(bright);
  tableLight.setHue(hue);
  tableLight.setSaturation(sat);
  lightBrightness.setBrightness(bright);
  //Call the method for operations on WS2812
  ControlTheWS2812();
}</pre> <p>The <code>onRGBLightColorChange()</code> method is the second method that will be called when there is any change<a id="_idIndexMarker859"/> in the color widget control. This method fetches hue, saturation, and brightness values from the <code>Color</code> type cloud variable and later assigns these values to other cloud variables as well as global variables. The last calling method, <code>ControlTheWS2812()</code>, performs the operation on the WS2812 ring according to global variable values:</p>
<pre class="source-code">
void onTableLightChange()  {
  // Add your code here to act upon TableLight change
  swi=tableLight.getSwitch();
  bright=tableLight.getBrightness();
  hue=tableLight.getHue();
  sat=tableLight.getSaturation();
  //Sync the values with LightBrightness &amp; RGBLightColor widget
  lightBrightness.setSwitch(swi);
  lightBrightness.setBrightness(bright);
  rGBLightColor= Color(hue,sat,bright);
  //Call the method for operations on WS2812
  ControlTheWS2812();
}</pre> <p>The <code>onTableLightChange()</code> method is associated<a id="_idIndexMarker860"/> with the <code>tablelight</code> cloud variable and assign these values to global variables as well to two other cloud variables for synchronization. The last calling method, <code>ControlTheWS2812()</code>, will perform the operation on the WS2812 ring according to global variable values:</p>
<pre class="source-code">
void ControlTheWS2812(){
  // declare a variable of the Color data type and define it using the HSB values of the color variable
  Color currentColor=Color(hue,sat, bright);
  byte RValue;
  byte GValue;
  byte BValue;
  currentColor.getRGB(RValue, GValue, BValue);  // the variables will contain the RGB values after the function returns
  if(swi==true){
    strip.setBrightness(bright);
    for(int i=0; i&lt;LED_COUNT+1; i++){
    strip.setPixelColor(i, strip.Color(RValue, GValue, BValue)); //  Set pixel's color (in RAM)
    strip.show();
  }
  }else{
    for(int i=0; i&lt;LED_COUNT+1; i++){
    strip.setBrightness(0);
    strip.setPixelColor(i, strip.Color(0, 0, 0)); //  Set pixel's color (in RAM)
    strip.show();
    }
  }
}</pre> <p>Finally, we have our last, common helper method, <code>ControlTheWS2812()</code>. This method will first generate RGB color from hue, saturation, and brightness. Then it will check the switch value – if it is true, then the condition will assign the brightness and color to the WS2812 ring and turn on every pixel of the ring with the help of the <code>for</code> loop. Otherwise, it will set the brightness<a id="_idIndexMarker861"/> to <code>0</code> and turn off all the pixels of the WS2812.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used different <em class="italic">naming</em> in the variable declaration, then update the code<a id="_idIndexMarker862"/> according to your naming scheme. But it’s better if you first follow all the steps according to the book and later change the cloud variable names and modify your code respectively.</p>
<p class="callout">The Arduino IoT Cloud only updates the values on the dashboard whenever a variable value is changed. For example, if the temperature is 30 and after 5 minutes it’s the same, then the Arduino IoT Cloud will not record the value. So, don’t get confused if values are not changed on the widget controls. Another benefit of this feature is you will not get duplicated data when you are exporting the content.</p>
<p>In this section, we set up the Thing, associated the XIAO ESP32C3 with the Thing, and set up cloud variables of different types to control LED operations. We also discussed the code for the device in detail, step by step, according to different methods. Now, in the next section, we will set up the dashboard.</p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor224"/>User-friendly controls – building web and mobile dashboards</h1>
<p>After uploading the code<a id="_idIndexMarker863"/> to the device, it’s time to set up a dashboard for web<a id="_idIndexMarker864"/> and mobile to visualize the data with different widgets. The following screenshot shows a visualization of light controls with different widgets.</p>
<div><div><img alt="Figure 10.11 – Thing dashboard" src="img/B19752_10_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Thing dashboard</p>
<p>We have three core functionalities<a id="_idIndexMarker865"/> of WS2812, which include RGB color, brightness, and the on/off<a id="_idIndexMarker866"/> switch. In the previous section, we created three different cloud variables, which provide different functionalities. That’s why here we have three different widget controls, which only work with these cloud variables. The first widget is <code>tableLight</code> cloud variable and capable of performing all of the operations on the WS2812, such as color change, brightness control, and switching it on and off.</p>
<p>Next, we have two more controls with limited functionalities. The second widget is <code>lightBrightness</code> cloud variable and only provides an on/off switch and brightness control, while our third widget control is <code>rGBLightColor</code> cloud variable and only provides the option to choose the color. If we compare all three widgets, then the <strong class="bold">Colored Light</strong> widget is equal to both <strong class="bold">Dimmed light</strong> and the <strong class="bold">Color</strong> widget, as the <strong class="bold">Colored Light</strong> widget has three functionalities, which include turning it on and off, color selection, and brightness control, while the <strong class="bold">Dimmed light</strong> widget control has only two options, brightness control and turning on and off functionality, and the <strong class="bold">Color</strong> widget control only has the option to choose the color.</p>
<p>So, the final conclusion is if you have a multi-color strip with a brightness control feature, then the <strong class="bold">Colored Light</strong> widget and cloud variable are good to go; otherwise, for a single-color light with brightness control, the <strong class="bold">Dimmed light</strong> widget and cloud variable are perfect. And if you have only a strip with the multi-color option without a brightness control, then a simple <strong class="bold">Color</strong> widget and cloud variable type are enough but remember the <strong class="bold">Color</strong> type cloud variable is not compatible with Amazon Alexa.</p>
<p>In this section, we have set up the dashboard<a id="_idIndexMarker867"/> with different types of widget<a id="_idIndexMarker868"/> controls, which help you to control WS2812 in different ways, such as controlling the brightness, color, and turning on and off the LED ring. Next, we are going to set up the Amazon Alexa Skill with the Arduino IoT Cloud to control our table lamp with voice commands using Amazon Alexa.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor225"/>Enhancing controls – integrating the Arduino IoT Cloud with Amazon Alexa</h1>
<p>After testing everything<a id="_idIndexMarker869"/> on the device using the Arduino IoT Cloud<a id="_idIndexMarker870"/> dashboard, it’s time to link Amazon Alexa with our thing for the voice control system. We have a physical hardware device for Alexa<a id="_idIndexMarker871"/> as well mobile apps for Android/iOS. Please visit <a href="https://alexa.amazon.com/">https://alexa.amazon.com/</a> to set up this project. I am using Amazon Echo Dot second generation, but if you don’t have access to an Alexa hardware device, then you can simply use the mobile app.</p>
<div><div><img alt="Figure 10.12 – Arduino Skill for Amazon Alexa" src="img/B19752_10_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Arduino Skill for Amazon Alexa</p>
<p>The Arduino IoT Cloud natively developed a skill for Amazon Alexa, which can be found at <a href="https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H">https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H</a>. Set up your Amazon Alexa and navigate to the preceding URL to enable a skill, which is shown in the preceding figure. When you link the account, it will automatically link the Arduino IoT cloud account that is already logged in with this Skill. So, make sure you are already logged in to the Arduino IoT Cloud. The preceding figure shows the Arduino Skill for Amazon Alexa.</p>
<div><div><img alt="Figure 10.13 – Amazon Alexa Smart Home and devices" src="img/B19752_10_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Amazon Alexa Smart Home and devices</p>
<p>After enabling the Arduino skill in Amazon Alexa, navigate to <a href="https://alexa.amazon.com/spa/index.html">https://alexa.amazon.com/spa/index.html</a> and click on the <strong class="bold">Smart Home</strong> link, which is located in the left sidebar, then click on <strong class="bold">Devices</strong>, shown in the preceding figure. Here, you will see cloud<a id="_idIndexMarker872"/> variables will become<a id="_idIndexMarker873"/> devices, as shown in the following figure. If you don’t see your desired Arduino IoT Cloud variables as a device, then at the bottom, click on the <strong class="bold">Discover</strong> button on the <strong class="bold">Devices</strong> page, which will take around 20 seconds to load all the stuff.</p>
<div><div><img alt="Figure 10.14 – Arduino Cloud variables as devices at Amazon Alexa" src="img/B19752_10_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Arduino Cloud variables as devices at Amazon Alexa</p>
<p>Finally, turn on your Amazon Echo Dot and WS2812-based smart lamp and try the following voice commands on Amazon Alexa. Firstly, try these commands, which will help you turn on/off <strong class="bold">TableLight</strong>. As shown in the preceding figure, <strong class="bold">TableLight</strong> is now acting as a device in the Amazon Alexa smart home:</p>
<pre class="console">
Hey Alexa Turn on the TableLight
Hey Alexa Turn off the TableLight</pre> <p>Now it’s time to change<a id="_idIndexMarker874"/> the brightness and colors<a id="_idIndexMarker875"/> of the WS2812 using voice commands. Try the following commands, which will help you to update the brightness and colors. Right now, I have just written four different colors, but you can choose any color name that you want:</p>
<pre class="console">
Hey Alexa set the brightness of TableLight to 99
Hey Alexa set the brightness of TableLight to 50
Hey Alexa change the color of TableLight to red
Hey Alexa change the color of TableLight to blue
Hey Alexa change the color of TableLight to green
Hey Alexa change the color of TableLight to purple</pre> <p>Finally, I am using the Alexa timer functionality to schedule turning on/off the table light after a specific time interval. But you can also use this function just like an alarm and turn on/off the WS2812 for long intervals, such as to turn on the light early in the morning, turning off the lamp at 10:00 P.M., and so on:</p>
<pre class="console">
Hey Alexa turn on the table light after 30 minutes
Hey Alexa turn off the table light after 10 minutes</pre> <p>We have discussed different voice commands for Amazon Alexa, but you can search on the internet for more commands regarding light controls and colors.</p>
<p>Now it’s time to talk about which Arduino Cloud variables are compatible with Amazon Alexa. You can get up-to-date information at <a href="https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H">https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H</a>. At the moment, we have the following list of cloud variables that work perfectly with Amazon Alexa:</p>
<ul>
<li>Temperature</li>
<li>Motion detection</li>
<li>Light, smart plug, and smart switch</li>
<li>Dimmed light</li>
<li>Colored light</li>
</ul>
<p>According to the preceding list, you can create a thermostat for a room, which will help you to change the room or kitchen temperature according to outdoor and indoor thermostat temperature, you can control your heating and cooling system. To turn on/off any device, we have four different types of cloud variables, which have the same data type Boolean but different names, including light, smart plug, smart switch, and motion detection. These four variables could be used to control any relay/magnetic contactors to turn home appliances on/off, such as cooling/heating systems. We have already discussed <strong class="bold">Dimmed light</strong> and <strong class="bold">Colored Light</strong> in previous sections.</p>
<p>In this section, we have set up the Amazon Alexa<a id="_idIndexMarker876"/> with Arduino Cloud skill<a id="_idIndexMarker877"/> and tried different voice commands related to turning lights on and off, as well as how to change the color and brightness of the WS2812 RGB LED ring.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor226"/>What next?</h1>
<p>We still have lots of options available to explore, but now your assignment is to use different relays, sensors, and development boards to do some more experiments and learn from them. In the current chapter, we have only used one WS2812 module for light control, but you can use temperature sensors, relays, and motion sensors to automate your devices in your home, such as automating room switches to control fans, exhaust fans, lights, and air conditioning systems according to room temperature.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Be careful when playing with high-voltage power cables when patching the cables to relays.</p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor227"/>Summary</h1>
<p>In this chapter, we have explored how to develop a low-cost, multi-color smart table lamp for our room using the XIAO ESP32C3 and WS2812. We have set up the Thing, which included cloud variable creation, device association, network configuration, and coding of the development board. Later, we created a dashboard using different widgets to control the WS2812 RGB ring. Finally, we used the Amazon Alexa voice assistant to turn our table lamp on/off and control its color and brightness with voice commands.</p>
<p>This chapter will give you the confidence to build more interesting stuff to make your home and office smarter. In the next chapter, we will talk about Cloud Scheduler and over-the-air update’ features. Both features are interesting and specially designed to carry out operations on IoT nodes.</p>
</div>


<div><h1 id="_idParaDest-228" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor228"/>Part 4: Learning Advanced Features of the Arduino IoT Cloud and Looking Ahead</h1>
<p>In <em class="italic">Part 4</em>, the reader is guided through the advanced features of the Arduino IoT Cloud platform, how to use them to develop professional applications, and the tools for maintaining solutions during their life cycle. The book ends with some suggestions for further learning, experimenting, and sourcing information.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19752_11.xhtml#_idTextAnchor229"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing the Arduino IoT Cloud Scheduler and Over-the-Air Features</em></li>
<li><a href="B19752_12.xhtml#_idTextAnchor251"><em class="italic">Chapter 12</em></a>, <em class="italic">Project #6 – Tracking and Notifying about Your Heart Rate</em></li>
<li><a href="B19752_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Scripting the Arduino IoT Cloud with Cloud CLI</em></li>
<li><a href="B19752_14.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Moving Ahead in the Arduino IoT Cloud</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>