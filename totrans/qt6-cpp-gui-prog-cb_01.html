<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Look-and-Feel Customization with Qt Designer</h1>
<p>Qt 6 allows us to easily design our program’s user interface through a method most people are familiar with. Qt not only provides us with a powerful user interface toolkit, called <strong class="bold">Qt Designer</strong>, which enables us to design our user interface without writing a single line of code, but it also allows advanced users to customize their user interface components through a simple scripting language called <strong class="bold">Qt </strong><strong class="bold">Style Sheet</strong>.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Using style sheets with Qt Designer</li>
<li>Customizing basic style sheets</li>
<li>Creating a login screen using style sheets</li>
<li>Using resources in style sheets</li>
<li>Customizing properties and sub-controls</li>
<li>Styling in <strong class="bold">Qt Modeling </strong><strong class="bold">Language</strong> (<strong class="bold">QML</strong>)</li>
<li>Exposing the QML object pointer to C++</li>
</ul>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
<p>The technical requirements for this chapter include having <strong class="bold">Qt 6.1.1 MinGW 64-bit</strong> and <strong class="bold">Qt Creator 12.0.2</strong>. The code that’s used in this chapter can be downloaded from this book’s GitHub repository: <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01</a>.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Using style sheets with Qt Designer</h1>
<p>In this example, we will learn how<a id="_idIndexMarker000"/> to change the look and feel of our program and make it look more professional by using style sheets and resources. Qt allows you to <a id="_idIndexMarker001"/>decorate your <strong class="bold">graphical user interfaces</strong> (<strong class="bold">GUIs</strong>) using a style sheet language called <strong class="bold">Qt Style Sheets</strong>, which is<a id="_idIndexMarker002"/> very similar to <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), something that’s used by <a id="_idIndexMarker003"/>web designers <a id="_idIndexMarker004"/>to decorate their websites.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>How to do it...</h2>
<p>Let’s get started by learning how to create a new project and get ourselves familiar with Qt Designer:</p>
<ol>
<li>Open up <strong class="bold">Qt Creator</strong> and create a new project. If this is the first time you have used Qt Creator, you can either click the big button, which reads <strong class="bold">Create Project…</strong>, or simply go to <strong class="bold">File</strong> | <strong class="bold">New Project…</strong>.</li>
<li>Select <strong class="bold">Application (Qt)</strong> from the <strong class="bold">Projects</strong> window and select <strong class="bold">Qt </strong><strong class="bold">Widgets Application</strong>.</li>
<li>Click the <strong class="bold">Choose...</strong> button at the bottom. A window will pop out and ask you to insert the project’s name and its location.</li>
<li>Click <strong class="bold">Next</strong> several times, then click the <strong class="bold">Finish</strong> button to create the project. We will stick with the default settings for now. Once the project has been created, the first thing you will see is a panel with tons of big icons on the left-hand side of the window, which is called the mode selector panel; we will discuss this in more detail in the <em class="italic">Dissecting Qt </em><em class="italic">Designer</em> recipe.</li>
<li>You will see all your source files listed on the sidebar panel, which is located next to the mode selector panel. This is where you can select which file you want to edit. In this case, this is <code>mainwindow.ui</code>, because we are about to start designing the program’s UI.</li>
<li>Double-click the <code>mainwindow.ui</code> file; you will see an entirely different interface appear out of nowhere. Qt Creator helped you switch from the script editor to the UI editor (Qt Designer) because it detected the <code>.ui</code> extension on the file you’re trying to open.</li>
<li>You will also notice that the highlighted button on the mode selector panel has changed from <strong class="bold">Edit</strong> to <strong class="bold">Design</strong>. You can switch back to the script editor or change to any other tools by clicking one of the buttons located in the upper half of the mode selector panel.</li>
<li>Let’s go back to Qt Designer and look at the <code>mainwindow.ui</code> file. This is the main window of our program (as <a id="_idIndexMarker005"/>the filename implies) and it’s empty by default, without any widget on it. You <a id="_idIndexMarker006"/>can try to compile and run the program by pressing the <strong class="bold">Run</strong> button (the green arrow button) at the bottom of the mode selector panel; you will see an empty window pop up once the compilation is complete.</li>
<li>Let’s add a push button to our program’s UI by clicking on the <strong class="bold">Push Button</strong> item in the <strong class="bold">Widget Box</strong> area (under the <strong class="bold">Buttons</strong> category) and dragging it to our main window in the form editor. Keep the push button selected; you will see all the properties of this button inside the <strong class="bold">Property Editor</strong> area on the right-hand side of your window. Scroll down to the middle and look for a property called <strong class="bold">styleSheet</strong>. This is where you will apply styles to your widget, which may or may not be inherited from its children or grandchildren recursively, depending on how you set your style sheet. Alternatively, you can right-click on any widget in your UI at the form editor and select <strong class="bold">Change styleSheet...</strong> from the pop-up menu.</li>
<li>You can click on the input field of the <strong class="bold">styleSheet</strong> property to directly write the style sheet code, or click on the <strong class="bold">…</strong> button beside the input field to open up the <strong class="bold">Edit Style Sheet</strong> window, which has a bigger space for writing longer code for style sheets. At the top of the window, you can find several buttons, such as <strong class="bold">Add Resource</strong>, <strong class="bold">Add Gradient</strong>, <strong class="bold">Add Color</strong>, and <strong class="bold">Add Font</strong>, that can help you kickstart your coding if you can’t remember the properties’ names. Let’s try to do some simple styling with the <strong class="bold">Edit Style </strong><strong class="bold">Sheet</strong> window.</li>
<li>Click <strong class="bold">Add Color</strong> and choose a color.</li>
<li>Pick a random color from the color picker window – let’s say, a pure red color. Then, click <strong class="bold">OK</strong>.</li>
<li>A line of code has been added<a id="_idIndexMarker007"/> to the text field in the <strong class="bold">Edit Style Sheet</strong> window, which in my<a id="_idIndexMarker008"/> case is as follows:<pre class="source-code">
color: rgb(255, 0, 0);</pre></li> <li>Click the <strong class="bold">OK</strong> button; the text on your push button should change to red.</li>
</ol>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>How it works...</h2>
<p>Let’s take a bit of time to get familiar with Qt Designer’s interface before we start learning how to design our own UI:</p>
<div><div><img alt="Figure 1.1 – Overview of Qt Designer’s interface" src="img/B20976_01_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Overview of Qt Designer’s interface</p>
<p>The explanation for the preceding screenshot is as follows:</p>
<ol>
<li><strong class="bold">Menu bar</strong>: The menu bar houses application-specific menus that provide easy access to essential functions, such as creating new projects, saving files, undoing, redoing, copying, and pasting. It also allows you to access development tools that come<a id="_idIndexMarker009"/> with Qt Creator, such as the compiler, debugger, and profiler.</li>
<li><strong class="bold">Widget Box</strong>: This is <a id="_idIndexMarker010"/>where you can find all the different types of widgets provided by Qt Designer. You can add a widget to your program’s UI by clicking one of the widgets from the <strong class="bold">Widget Box</strong> area and dragging it to the form editor.</li>
<li><strong class="bold">Mode selector</strong>: The mode selector is a side panel that places shortcut buttons for easy access to different tools. You can quickly switch between the script editor and form editor by clicking the <strong class="bold">Edit</strong> or <strong class="bold">Design</strong> button on the mode selector panel, which is very useful for multitasking. You can also easily navigate to the debugger and profiler tools at the same speed and manner.</li>
<li><strong class="bold">Build shortcuts</strong>: The build shortcuts are located at the bottom of the mode selector panel. You can build, run, and debug your project easily by pressing the shortcut buttons here.</li>
<li><strong class="bold">Form editor</strong>: The form editor is where you edit your program’s UI. You can add different widgets to your program by selecting a widget from the <strong class="bold">Widget Box</strong> area and dragging it to the form editor.</li>
<li><strong class="bold">Form toolbar</strong>: From here, you can quickly select a different form to edit. Click the drop-down box located at the top of the <strong class="bold">Widget Box</strong> area and select the file you want to open with Qt Designer. Beside the drop-down box are buttons to switch between the different modes of the form editor, and also buttons to change the layout of your UI.</li>
<li><code>.ui</code> file. All the widgets are arranged according to their parent-child relationship in the hierarchy. You can select a widget from the <strong class="bold">Object Inspector</strong> area to display its properties in the <strong class="bold">Property </strong><strong class="bold">Editor</strong> area.</li>
<li><strong class="bold">Property Editor</strong>: The <strong class="bold">Property Editor</strong> area will display all the properties of the widget you selected from either the <strong class="bold">Object Inspector</strong> area or the form editor window.</li>
<li><strong class="bold">Action Editor</strong> and <strong class="bold">Signals &amp; Slots Editor</strong>: This window contains two editors: <strong class="bold">Action Editor</strong> and <strong class="bold">Signals &amp; Slots Editor</strong>. Both can be accessed from the tabs beneath the <a id="_idIndexMarker011"/>window. <strong class="bold">Action Editor</strong> is where you create actions that can be added to a <a id="_idIndexMarker012"/>menu bar or toolbar in your program’s UI.</li>
<li><strong class="bold">Output panes</strong>: Output panes consist of several different windows that display information and output messages related to script compilation and debugging. You can switch between different output panes by pressing the buttons that carry a number before them, such as <strong class="bold">1 Issues</strong>, <strong class="bold">2 Search Results</strong>, or <strong class="bold">3 </strong><strong class="bold">Application Output</strong>.</li>
</ol>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>There’s more...</h2>
<p>In this recipe, we discussed how to apply style sheets to Qt widgets through C++ coding. Although that method works well, most of the time, the person who is in charge of designing the program’s UI is not the programmer, but rather a UI designer who specializes in designing user-friendly UI. In this case, it’s better to let the UI designer design the program’s layout and style sheet with a different tool and not mess around with the code. Qt provides an all-in-one editor <a id="_idIndexMarker013"/>called <strong class="bold">Qt Creator</strong>.</p>
<p>Qt Creator consists of several different tools, such as a script editor, compiler, debugger, profiler, and UI editor. The UI editor, which<a id="_idIndexMarker014"/> is also called <strong class="bold">Qt Designer</strong>, is the perfect tool for designers to design their program’s UI without writing any code. This is because Qt Designer adopted the <em class="italic">what you see is what you get</em> approach by providing an accurate visual representation of the final result, which means whatever you design with Qt Designer will turn out the same visually when the program is compiled and run.</p>
<p>The similarities between <a id="_idIndexMarker015"/>Qt Style Sheets and CSS are as follows:</p>
<ul>
<li>This is how a typical piece of CSS code looks:<pre class="source-code">
h1 { color: red; background-color: white;}</pre></li> <li>This is how Qt Style Sheets look, which is almost the same as the preceding CSS:<pre class="source-code">
QLineEdit { color: red; background-color: white;}</pre></li> </ul>
<p>As you can see, both of them contain a selector and a declaration block. Each declaration contains a property and a value, separated by a colon. In Qt, a style sheet can be applied to a single widget by calling the <code>QObject::setStyleSheet()</code> function in C++ code.</p>
<p>Consider the following, for example:</p>
<pre class="source-code">
myPushButton-&gt;setStyleSheet("color : blue");</pre> <p>The preceding code will turn the text of a button with the <code>myPushButton</code> variable name to blue. You can achieve the same result by writing the declaration in the style sheet property field in Qt Designer. We will discuss Qt Designer more in the <em class="italic">Customizing basic style </em><em class="italic">sheets</em> recipe.</p>
<p>Qt Style Sheets also supports all the different types of selectors defined in the CSS2 standard, including the <code>usernameEdit</code> object name, we can do this by using an ID selector to refer to it:</p>
<p>QLineEdit#usernameEdit { background-color: blue }</p>
<p class="callout-heading">Note</p>
<p class="callout">To learn about all the selectors available in CSS2 (which are also supported by Qt Style Sheets), please refer to this document: <a href="http://www.w3.org/TR/REC-CSS2/selector.html">http://www.w3.org/TR/REC-CSS2/selector.html</a>.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Customizing basic style sheets</h1>
<p>In the previous recipe, you<a id="_idIndexMarker020"/> learned how to apply a style sheet to a widget with Qt Designer. Let’s go crazy and push things further by creating a few other types of widgets and changing their style properties to something bizarre for the sake of learning.</p>
<p>This time, however, we will not apply the style to every single widget one by one; instead, we will learn to apply the style sheet to the main window and let it inherit down the hierarchy to all the other widgets so that the style sheet is easier to manage and maintain in the long run.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>How to do it...</h2>
<p>In the following example, we will format different types of widgets on the canvas and add some code to the style sheet to change its appearance:</p>
<ol>
<li>Remove the style sheet from <code>PushButton</code> by selecting it and clicking the small arrow button beside the <strong class="bold">styleSheet</strong> property. This button will revert the property to its default value, which in this case is the empty style sheet.</li>
<li>Add a few more widgets to the UI by dragging them one by one from the <strong class="bold">Widget Box</strong> area to the form editor. I’ve added a line edit, combo box, horizontal slider, radio button, and a check box.</li>
<li>For the sake of simplicity, delete <strong class="bold">menuBar</strong>, <strong class="bold">mainToolBar</strong>, and <strong class="bold">statusBar</strong> from your UI by selecting them in the <strong class="bold">Object Inspector</strong> area, right-clicking, and choosing <strong class="bold">Remove</strong>. Now, your UI should look similar to this:</li>
</ol>
<div><div><img alt="Figure 1.2 – Dragging and dropping some widgets onto the form editor" src="img/B20976_01_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Dragging and dropping some widgets onto the form editor</p>
<ol>
<li value="4">Select the main window from <a id="_idIndexMarker021"/>either the form editor or the <strong class="bold">Object Inspector</strong> area, then right-click and choose <strong class="bold">Change styleSheet...</strong> to open the <strong class="bold">Edit Style Sheet</strong> window. Insert the following into the style sheet:<pre class="source-code">
border: 2px solid gray;
border-radius: 10px;
padding: 0 8px;
background: yellow;</pre></li> <li>You will see a bizarre-looking UI with everything covered in yellow with a thick border. This is because the preceding style sheet does not have a selector, which means the style will apply to the children widgets of the main window down the hierarchy. To change that, let’s try something different:<pre class="source-code">
QPushButton {
     border: 2px solid gray;
     border-radius: 10px;
     padding: 0 8px;
     background: yellow;
}</pre></li> <li>This time, only <strong class="bold">PushButton</strong> will get the style described in the preceding code, and all the other widgets will return to the default styling. You can try to add a few more push buttons to your UI; they will all look the same:</li>
</ol>
<div><div><img alt="Figure 1.3 – Changing the push buttons to yellow" src="img/B20976_01_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Changing the push buttons to yellow</p>
<ol>
<li value="7">This happens because we specifically<a id="_idIndexMarker022"/> tell the selector to apply the style to all the widgets with the <code>QPushButton</code> class. We can also apply the style to just one of the push buttons by mentioning its name in the style sheet, as shown in the following code:<pre class="source-code">
QPushButton#pushButton_3 {
     border: 2px solid gray;
     border-radius: 10px;
     padding: 0 8px;
     background: yellow;
}</pre></li> <li>Once you understand this method, we can add the following code <a id="_idTextAnchor022"/>to the style sheet:<pre class="source-code">
QPushButton {
     color: red;
     border: 0px;
     padding: 0 8px;
     background: white;
}
QPushButton#pushButton_2 {
     border: 1px solid red;
     border-radius: 10px;
}</pre></li> <li>This code changes the style of <a id="_idIndexMarker023"/>all the push buttons, as well as some properties of the <code>pushButton_2</code> button. We keep the style sheet of <code>pushButton_3</code> as-is. Now, the buttons will look like this:</li>
</ol>
<div><div><img alt="Figure 1.4 – Applying a different style to each button" src="img/B20976_01_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Applying a different style to each button</p>
<ol>
<li value="10">The first set of style sheets will change all widgets of the <code>QPushButton</code> type to a white rectangular button with no border and red text. The second set of style sheets only changes the border of a specific <code>QPushButton</code> widget called <code>pushButton_2</code>. Notice that the background color and text color of <code>pushButton_2</code> remain white and red, respectively, because we didn’t override them in the second set of style sheets, hence it will return to the style described in the first set of style sheets since it applies to all the <code>QPushButton</code> widgets. The text of the third button has also changed to red because we didn’t describe the <strong class="bold">Color</strong> property in the third set of style sheets.</li>
<li>Create another set of style sheets that use the universal selector by using the following code:<pre class="source-code">
* {
     background: qradialgradient(cx: 0.3, cy: -0.4, fx: 0.3, fy: -0.4, radius: 1.35, stop: 0 #fff, stop: 1 #888);
     color: rgb(255, 255, 255);
     border: 1px solid #ffffff;
}</pre></li> <li>The universal selector will affect all the widgets, regardless of their type. Therefore, the preceding style sheet will apply a nice gradient color to all the widgets’ backgrounds <a id="_idIndexMarker024"/>and set their text to white with a one-pixel solid outline that is also white. Instead of writing the name of the color (that is, white), we can use the <code>rgb</code> function (<code>rgb(255, 255, 255)</code>) or hex code (<code>#ffffff</code>) to describe the color value.</li>
<li>As before, the preceding style sheet will not affect the push buttons because we have already given them their own styles, which will override the general style described in the universal selector. Just remember that in Qt, the more specific style will ultimately be used when there is more than one style with an influence on a widget. This is how the UI will look now:</li>
</ol>
<div><div><img alt="Figure 1.5 – Applying a gradient background to all the other widgets" src="img/B20976_01_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Applying a gradient background to all the other widgets</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>How it works…</h2>
<p>If you are ever involved in web development using HTML and CSS, Qt’s style sheets work the same way as CSS. Style sheets provide the definitions to describe the presentation of the widgets – what the<a id="_idIndexMarker025"/> colors are for each element in the widget group, how thick the border should be, and so on. If you specify the name of the widget to the style sheet, it will change the style of the particular <code>PushButton</code> widget with the name you provide. None of the other widgets will be affected and will remain as the default style.</p>
<p>To change the name of a widget, select the widget from either the form editor or the <strong class="bold">Object Inspector</strong> area and change the <strong class="bold">objectName</strong> property in the property window. If you used the ID selector previously to change the style of the widget, changing its object name will break the style sheet and lose the style. To fix this problem, simply change the object name in the style sheet as well.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Creating a login screen using style sheets</h1>
<p>Next, we will learn how to put all the<a id="_idIndexMarker026"/> knowledge we learned in the previous<a id="_idIndexMarker027"/> recipe together and create a fake graphical login screen for an imaginary operating system. Style sheets are not the only thing you need to master to design a good UI. You will also need to learn how to arrange the widgets neatly using the layout system in Qt Designer.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>How to do it...</h2>
<p>Let’s get started by following these steps:</p>
<ol>
<li>We need to design the layout of the graphical login screen before we start doing anything. Planning is very<a id="_idIndexMarker028"/> important to produce good software. The<a id="_idIndexMarker029"/> following is a sample layout design I made to show you how I imagine the login screen will look. Just a simple line drawing like this is sufficient, so long as it conveys the message clearly:</li>
</ol>
<div><div><img alt="Figure 1.6 – A simple drawing depicting the login screen" src="img/B20976_01_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – A simple drawing depicting the login screen</p>
<ol>
<li value="2">Go back to Qt Designer again.</li>
<li>We will be placing the widgets at the top panel first, then the logo and the login form beneath it.</li>
<li>Select the main window and change its width and height from <code>400</code> and <code>300</code> to <code>800</code> and <code>600</code>, respectively – we’ll<a id="_idIndexMarker030"/> need a bigger space in which to place all the widgets.</li>
<li>Click and drag a label <a id="_idIndexMarker031"/>under the <strong class="bold">Display Widgets</strong> category from the <strong class="bold">Widget Box</strong> area to the form editor.</li>
<li>Change the <code>currentDateTime</code> and change its text property to the current date and time for display purposes – for example, <code>Wednesday, 25-10-2023 </code><code>3:14 PM</code>.</li>
<li>Click and drag <code>PushButton</code> under the <code>restartButton</code> and <code>shutdownButton</code>.</li>
<li>Select the main window and click the small icon button on the form toolbar that says <strong class="bold">Lay Out Vertically</strong> when you mouse over it. You will see that the widgets are automatically arranged on the main window, but that’s not exactly what we want yet.</li>
<li>Click and drag a <strong class="bold">Horizontal Layout</strong> widget under the <strong class="bold">Layouts</strong> category to the main window.</li>
<li>Click and drag the two push buttons and the text label into the horizontal layout. You will see the three widgets being arranged in a horizontal row, but vertically, they are located in the middle of the screen. The horizontal arrangement is almost correct, but the vertical position is off.</li>
<li>Click and drag a <strong class="bold">Vertical Spacer</strong> widget from the <strong class="bold">Spacers</strong> category and place it beneath the <strong class="bold">Horizontal Layout</strong> widget we created in <em class="italic">Step 9</em> (under the red rectangular outline). All the widgets will be pushed to the top by the spacer.</li>
<li>Place a <strong class="bold">Horizontal Spacer</strong> widget between the text label and the two buttons to keep them apart. This will ensure the text label always sticks to the left and the buttons align to the right.</li>
<li>Set both the <code>55 x 55</code>. Set the <strong class="bold">text</strong> property of the buttons to<a id="_idIndexMarker032"/> empty, as we will be using icons instead of text. We will learn how to<a id="_idIndexMarker033"/> place an icon in the button widgets in the <em class="italic">Using resources in style </em><em class="italic">sheets</em> recipe.</li>
<li>Your UI should look similar to this:</li>
</ol>
<div><div><img alt="Figure 1.7 – Pushing apart the text and buttons using a horizontal spacer" src="img/B20976_01_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Pushing apart the text and buttons using a horizontal spacer</p>
<p>Next, we will be adding the logo. Follow these steps:</p>
<ol>
<li>Add a <strong class="bold">Horizontal Layout</strong> widget between the top panel and a <strong class="bold">Vertical Spacer</strong> widget to serve as a container for the logo.</li>
<li>After adding the <strong class="bold">Horizontal Layout</strong> widget, you will find that the layout is way too thin in height (almost zero height) for you to add any widgets to it. This is because the layout is empty and it’s being pushed by the vertical spacer under it into zero height. To solve this problem, we <a id="_idIndexMarker034"/>can set its <strong class="bold">vertical margin</strong> (either <strong class="bold">layoutTopMargin</strong> or <strong class="bold">layoutBottomMargin</strong>) to be temporarily bigger until a widget is added to the layout.</li>
<li>Add a <code>logo</code>. We will learn more about how to insert an image into the label to use it as a logo in the <em class="italic">Using resources in style sheets</em> recipe. For now, just empty out the <code>150 </code><code>x 150</code>.</li>
<li>Set the vertical margin <a id="_idIndexMarker035"/>of the layout back to zero if you haven’t already done so.</li>
<li>The logo will now appear to <a id="_idIndexMarker036"/>be invisible, so we will just place a temporary style sheet to make it visible until we add an image to it in the <em class="italic">Using resources in style sheets</em> recipe. The style sheet is really simple:<pre class="source-code">
border: 1px solid;</pre><p class="list-inset">Your UI should look similar to this:</p></li> </ol>
<div><div><img alt="Figure 1.8 – Putting the placeholder logo in the middle" src="img/B20976_01_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Putting the placeholder logo in the middle</p>
<p>Now, let’s create the login form:</p>
<ol>
<li>Add a <code>100</code>) so that you can add a widget to it more easily.</li>
<li>Add a <code>20</code>) so that we can place widgets in it.</li>
<li>Right-click the <code>QWidget</code> object, it will automatically inherit all the<a id="_idIndexMarker038"/> properties from the widget class, which means we can now adjust its size to suit our needs.</li>
<li>Rename the <code>QWidget</code> object, which we just converted from the layout, <code>loginForm</code> and change both its <code>350 </code><code>x 200</code>.</li>
<li>Since we already placed the <code>loginForm</code> widget inside <strong class="bold">Horizontal Layout</strong>, we can set its <strong class="bold">layoutTopMargin</strong> property back to zero.</li>
<li>Add the same style sheet that you did for the logo to the <code>loginForm</code> widget to make it visible temporarily. However, this time, we need to add an ID selector in front so that it will only apply the style to <code>loginForm</code> and not its children widgets:<pre class="source-code">
#loginForm { border: 1px solid; }</pre><p class="list-inset">Your UI should look something like this:</p></li> </ol>
<div><div><img alt="Figure 1.9 – Constructing the frame for the login form" src="img/B20976_01_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Constructing the frame for the login form</p>
<p>We are not done with the login form yet. Now that we have created the container for the login form, it’s time to put more widgets into the form:</p>
<ol>
<li>Place two horizontal layouts<a id="_idIndexMarker039"/> in the login form container. We need two layouts: one for the username field<a id="_idIndexMarker040"/> and another for the password field.</li>
<li>Add <code>Username:</code> and the one beneath to <code>Password:</code>. Rename the two line edits to <code>username</code> and <code>password</code>, respectively.</li>
<li>Add a push button beneath the password layout and change its <code>Login</code>. Rename it <code>loginButton</code>.</li>
<li>You can add a <code>Login</code> button to distance them slightly. After the <code>5</code>.</li>
<li>Select the <code>loginForm</code> container and set all its margins to <code>35</code>. This is to make the login form look better<a id="_idIndexMarker041"/> by adding some space to all its sides.</li>
<li>Set the <code>Username</code>, <code>Password</code>, and <code>loginButton</code> widgets to <code>25</code> so that they<a id="_idIndexMarker042"/> don’t look so cramped.<p class="list-inset">Your UI should look something like this:</p></li>
</ol>
<div><div><img alt="Figure 1.10 – Adding widgets to the login form" src="img/B20976_01_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Adding widgets to the login form</p>
<p class="callout-heading">Note</p>
<p class="callout">Alternatively, you can use a grid layout for the <strong class="bold">Username</strong> and <strong class="bold">Password</strong> fields to keep their sizes uniform.</p>
<p>We’re not done yet! As you can see, the login form and the logo are both sticking to the top of the main window due<a id="_idIndexMarker043"/> to the <strong class="bold">Vertical Spacer</strong> widget beneath<a id="_idIndexMarker044"/> them. The logo and the login form should be placed at the center of the main window instead of the top. To fix this problem, follow these steps:</p>
<ol>
<li>Add another <strong class="bold">Vertical Spacer</strong> widget between the top panel and the logo’s layout. This will counter the spacer at the bottom to balance out the alignment.</li>
<li>If you think that the logo is sticking too close to the login form, you can add a <code>10</code>.</li>
<li>Right-click the top panel’s layout and choose <code>topPanel</code>. The layout must be converted into <strong class="bold">QWidget</strong> because we cannot apply style sheets to a layout. This is because a layout doesn’t have any properties other than margins.</li>
<li>There is a little bit of a margin around the edges of the main window – we don’t want that. To remove the margins, select the <strong class="bold">centralWidget</strong> object from the <strong class="bold">Object Inspector</strong> window, which is right under the <strong class="bold">MainWindow</strong> panel, and set all the margin values to zero.</li>
<li>Run the project by clicking the <strong class="bold">Run</strong> button (with the green arrow icon) to see what your program looks like. If everything goes well, you should see something like this:</li>
</ol>
<div><div><img alt="Figure 1.11 – We’re done with the layout – for now" src="img/B20976_01_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – We’re done with the layout – for now</p>
<ol>
<li value="6">Now, let’s decorate the UI <a id="_idIndexMarker045"/>using style sheets! Since all the important widgets have been given object names, it’s easier for us to apply the style sheets to them from the main window since we will only write the style sheets to the main window and let them <a id="_idIndexMarker046"/>inherit down the hierarchy tree.</li>
<li>Right-click on <strong class="bold">MainWindow</strong> from the <strong class="bold">Object Inspector</strong> area and choose <strong class="bold">Change styleSheet...</strong>.</li>
<li>Add the following code to the style sheet:<pre class="source-code">
#centralWidget { background: rgba(32, 80, 96, 100); }</pre></li> <li>The background of the main window will change color. We will learn how to use an image for the background in the <em class="italic">Using resources in style sheets</em> recipe. So, the color is just temporary.</li>
<li>In Qt, if you want to apply styles to the main window itself, you must apply them to its <strong class="bold">centralWidget</strong> widget instead of the main window since the window is just a container.</li>
<li>Add a nice gradient color to the top panel:<pre class="source-code">
#topPanel {
     background-color: qlineargradient(spread:reflect, x1:0.5, y1:0, x2:0, y2:0, stop:0 rgba(91, 204, 233, 100), stop:1 rgba(32, 80, 96, 100));
}</pre></li> <li>Apply the black color to the login form and make it look semi-transparent. We will also make the corners<a id="_idIndexMarker047"/> of the login form container slightly rounded by setting the <code>border-radius</code> property:<pre class="source-code">
#loginForm {
     background: rgba(0, 0, 0, 80);
     border-radius: 8px;
}</pre></li> <li>Apply styles to the<a id="_idIndexMarker048"/> general types of widgets:<pre class="source-code">
QLabel { color: white; }
QLineEdit { border-radius: 3px; }</pre></li> <li>The preceding style sheets will change all the labels’ texts to a white color; this includes the text on the widgets as well because, internally, Qt uses the same type of label on the widgets that have text on them. Also, we made the corners of the line edit widgets slightly rounded.</li>
<li>Apply style sheets to all the push buttons on our UI:<pre class="source-code">
QPushButton {
     color: white;
     background-color: #27a9e3;
     border-width: 0px;
     border-radius: 3px;
}</pre></li> <li>The preceding style sheet changes the text of all the buttons to a white color, then sets its background color to blue, and makes its corners slightly rounded.</li>
<li>To push things even further, we will make it so that the color of the push buttons changes when we<a id="_idIndexMarker049"/> mouse over it by using the <code>hover</code> keyword:<pre class="source-code">
QPushButton:hover { background-color: #66c011; }</pre></li> <li>The preceding style sheet will change the background color of the push buttons to green when we mouse<a id="_idIndexMarker050"/> over them. We will talk more about this in the <em class="italic">Customizing properties and </em><em class="italic">sub-controls</em> recipe.</li>
<li>You can further adjust the size and margins of the widgets to make them look even better. Remember to remove the border line of the login form by removing the style sheet that we applied directly to it in <em class="italic">step 6</em>.</li>
<li>Your login screen should look something like this:</li>
</ol>
<div><div><img alt="Figure 1.12 – Applying colors and styles to the widgets" src="img/B20976_01_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Applying colors and styles to the widgets</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>How it works…</h2>
<p>This example focused more on the layout system of Qt. Qt’s layout system allows our application GUI to automatically<a id="_idIndexMarker051"/> arrange itself within the given space by arranging the children objects of each widget. The spacer items that we used in this recipe<a id="_idIndexMarker052"/> help push the widgets contained in a layout outward to create spacing along the width of the spacer item.</p>
<p>To locate a widget in the middle of the layout, we must put two spacer items into the layout: one on the left-hand side of the widget and one on the right-hand side of the widget. The widget will then be pushed to the middle of the layout by the two spacers.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Using resources in style sheets</h1>
<p>Qt provides us with <a id="_idIndexMarker053"/>a platform-independent resource system that allows us to store any type of file in our program’s executable for later use. There is no limit to the<a id="_idIndexMarker054"/> types of files we can store in our executable – images, audio, video, HTML, XML, text files, binary files, and so on are all permitted.</p>
<p>The resource system is really useful for embedding resource files (such as icons and translation files) into the executable so that it can be accessed by the application at any time. To achieve this, we must tell Qt which files we want to add to its resource system in the <code>.qrc</code> file; Qt will handle the rest during the build process.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>How to do it…</h2>
<p>To add a new <code>.qrc</code> file to our project, go to <code>resources</code>) and click the <code>.qrc</code> file will now be created and automatically opened by Qt Creator. You don’t have to edit the <code>.qrc</code> file directly in XML format as Qt Creator provides you with the user interface to manage your resources.</p>
<p>To add images and icons to your project, you need to make sure that the images and icons are being placed in your project’s directory. While the <code>.qrc</code> file is opened in Qt Creator, click the <strong class="bold">Add</strong> button, followed by the <strong class="bold">Add Prefix</strong> button. The prefix is used to categorize your resources so that they can be better managed when you have a ton of resources in your project:</p>
<ol>
<li>Rename the prefix you just created to <code>/icons</code>.</li>
<li>Create another prefix by clicking <strong class="bold">Add</strong>, followed by <strong class="bold">Add Prefix</strong>.</li>
<li>Rename the new prefix <code>/images</code>.</li>
<li>Select the <code>/icon</code> prefix and click <strong class="bold">Add</strong>, followed by <strong class="bold">Add Files</strong>.</li>
<li>A file selection window will appear; use that to select all the icon files. You can select multiple files at a time by holding the <em class="italic">Ctrl</em> key on your keyboard while clicking on the files to select them. Click <strong class="bold">Open</strong> once you’re done.</li>
<li>Select the <code>/images</code> prefix and click the <strong class="bold">Add</strong> button, followed by the <strong class="bold">Add Files</strong> button. The file-selection <a id="_idIndexMarker055"/>window will pop up again; this time, we will select the background image.</li>
<li>Repeat the preceding<a id="_idIndexMarker056"/> steps, but this time, we will add the logo image to the <code>/images</code> prefix. Don’t forget to save once you’re done by pressing <em class="italic">Ctrl</em> + <em class="italic">S</em>. Your <code>.qrc</code> file should now look like this:</li>
</ol>
<div><div><img alt="Figure 1.13 – Showing the structure of the resource file" src="img/B20976_01_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Showing the structure of the resource file</p>
<ol>
<li value="8">Go back to the <code>mainwindow.ui</code> file; let’s make use of the resources we have just added to our project. Select the restart button located on the top panel. Scroll down the <strong class="bold">Property Editor</strong> area until you see the <strong class="bold">icon</strong> property. Click the little button with a drop-down arrow icon and click <strong class="bold">Choose Resources</strong> from its menu.</li>
<li>The <strong class="bold">Select Resource</strong> window will pop up. Click on the icons prefix on the left panel and select the restart icon on the right panel. Press <strong class="bold">OK</strong>.</li>
<li>A tiny icon will appear on the button. This icon looks very tiny because the default icon size is set to <code>16 x 16</code>. Change the <code>50 x 50</code>; you will see that the icon appears bigger. Repeat the preceding steps for the shutdown button, except this time, choose the shutdown icon instead.</li>
<li>The two buttons should now look like this:</li>
</ol>
<div><div><img alt="Figure 1.14 – Applying icons to the push buttons" src="img/B20976_01_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Applying icons to the push buttons</p>
<ol>
<li value="12">Let’s use the image we <a id="_idIndexMarker057"/>added to the resource file as our logo. Select <a id="_idIndexMarker058"/>the logo widget and remove the style sheet that we added earlier to render its outline.</li>
<li>Scroll down the <strong class="bold">Property Editor</strong> area until you see the <strong class="bold">pixmap</strong> property.</li>
<li>Click the little drop-down button behind the <strong class="bold">pixmap</strong> property and select <strong class="bold">Choose Resources</strong> from the menu. Select the logo image and click <strong class="bold">OK</strong>. The logo size no longer follows the dimension you set previously; it follows the actual dimension of the image instead. We cannot change its dimension because this is simply how the <strong class="bold">pixmap</strong> property works.</li>
<li>If you want more control over the logo’s dimension, you can remove the image from the <strong class="bold">pixmap</strong> property and use a style sheet instead. You can use the following code to apply an image to the icon container:<pre class="source-code">
border-image: url(:/images/logo.png);</pre></li> <li>To obtain the path of the image, right-click the image’s name in the file list window and choose <strong class="bold">Copy path</strong>. The path will be saved to your operating system’s clipboard; now, you can just paste it into the preceding style sheet. Using this method will ensure that the image fits the dimensions of the widget that you applied the style to. Your logo should now appear like what’s shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 1.15 – The logo is now appearing at the top of the login form" src="img/B20976_01_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – The logo is now appearing at the top of the login form</p>
<ol>
<li value="17">Apply the wallpaper image to the background using a style sheet. Since the background dimension will change <a id="_idIndexMarker059"/>according to the window size, we cannot use <code>border-image</code> property in a style sheet. Right-click the main window and select <strong class="bold">Change styleSheet...</strong> to open the <strong class="bold">Edit Style Sheet</strong> window. We will add a new line under the style sheet of the <strong class="bold">centralWidget</strong> widget:<pre class="source-code">
#centralWidget {
     background: rgba(32, 80, 96, 100);
     border-image: url(:/images/login_bg.png);
}</pre></li> <li>It’s really that simple and easy! Your login screen should now look like this:</li>
</ol>
<div><div><img alt="Figure 1.16 – The final result looks neat" src="img/B20976_01_016.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – The final result looks neat</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>How it works…</h2>
<p>The resource system in Qt stores binary files, such as images and translation files, in the executable when it gets compiled. It reads the <code>.qrc</code>) in your project to<a id="_idIndexMarker061"/> locate the files that need to be stored in the executable and include them<a id="_idIndexMarker062"/> in the build process. A <code>.qrc</code> file looks something like this:</p>
<pre class="source-code">
&lt;!DOCTYPE RCC&gt;
&lt;RCC version="1.0"&gt;
     &lt;qresource&gt;
           &lt;file&gt;images/copy.png&lt;/file&gt;
           &lt;file&gt;images/cut.png&lt;/file&gt;
           &lt;file&gt;images/new.png&lt;/file&gt;
           &lt;file&gt;images/open.png&lt;/file&gt;
           &lt;file&gt;images/paste.png&lt;/file&gt;
           &lt;file&gt;images/save.png&lt;/file&gt;
     &lt;/qresource&gt;
&lt;/RCC&gt;</pre> <p>It uses <code>.qrc</code> file, or one of its subdirectories.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Customizing properties and sub-controls</h1>
<p>Qt’s style sheet system enables us to create stunning and professional-looking UIs with ease. In this example, we will learn <a id="_idIndexMarker065"/>how to set custom properties for our widgets and use <a id="_idIndexMarker066"/>them to switch between different styles.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>How to do it…</h2>
<p>Follow these steps to customize widget properties and sub-controls:</p>
<ol>
<li>Let’s create a new Qt project. I have prepared the UI for this purpose. The UI contains three buttons on the<a id="_idIndexMarker067"/> left-hand side and a <strong class="bold">tab widget</strong> with three pages located on the right-hand side, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 1.17 – Basic user interface with three tabs and buttons" src="img/B20976_01_017.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – Basic user interface with three tabs and buttons</p>
<ol>
<li value="2">The three buttons <a id="_idIndexMarker068"/>are blue because I’ve added the following style <a id="_idIndexMarker069"/>sheet to the main window (not to the individual button):<pre class="source-code">
QPushButton {
     color: white;
     background-color: #27a9e3;
     border-width: 0px;
     border-radius: 3px;
}</pre></li> <li>I will explain what <strong class="bold">pseudo-states</strong> are in Qt<a id="_idIndexMarker070"/> by adding the following style sheet to the main window. You might be familiar with this:<pre class="source-code">
QPushButton:hover {
     color: white;
     background-color: #66c011;
     border-width: 0px;
     border-radius: 3px;
}</pre></li> <li>We used the preceding style sheet in the <em class="italic">Creating a login screen using style sheets</em> recipe, to make the buttons change color when there is a mouse-over event. This is made possible by Qt Style Sheet’s <code>hover</code> separated from the <code>QPushButton</code> class by a colon. Every widget has a set of generic pseudo-states, such as <code>QPushButton</code>, but not for <code>QLineEdit</code>. Let’s add the <strong class="bold">pressed</strong> pseudo-state to change the buttons’ color to yellow when the user clicks on it:<pre class="source-code">
QPushButton:pressed {
     color: white;
     background-color: yellow;
     border-width: 0px;
     border-radius: 3px;
}</pre></li> <li>Pseudo-states allow the users to load a different set of style sheets based on the condition that applies to them. Qt pushes this concept further by implementing <strong class="bold">dynamic properties</strong> in Qt Style<a id="_idIndexMarker073"/> Sheets. This allows us to change the style sheet of a widget when a custom condition has been met. We can make use of this feature to change the style sheet of our buttons based on a custom condition that we can set using custom properties in Qt. First, we will add this style sheet to our main window:<pre class="source-code">
QPushButton[pagematches=true] {
     color: white;
     background-color: red;
     border-width: 0px;
     border-radius: 3px;
}</pre></li> <li>This changes the push button’s background <a id="_idIndexMarker074"/>color to red if the <code>pagematches</code> property returns <code>QPushButton</code> class. However, we can add it to our buttons using <code>QObject::setProperty()</code>:<ul><li>In your <code>mainwindow.cpp</code> source code, add the following code right after <code>ui-&gt;setupUi(this)</code>:<pre class="source-code">
ui-&gt;button1-&gt;setProperty("pagematches", true);</pre></li></ul><p class="list-inset">The preceding code will add a custom property called <code>pagematches</code> to the first button and set its value as true. This will make the first button turn red by default.</p><ul><li>After that, right-click on <code>currentChanged(int)</code> option from the list and click <strong class="bold">OK</strong>. Qt will generate a slot function for you, which looks something like this:<pre class="source-code">private slots:
void on_tabWidget_currentChanged(int index);</pre></li><li>The <code>mainwindow.cpp</code>; you will see the function’s declaration there. Let’s add some code to the function:<pre class="source-code">void MainWindow::on_tabWidget_currentChanged(int
index) {
     // Set all buttons to false
     ui-&gt;button1-&gt;setProperty("pagematches", false);
     ui-&gt;button2-&gt;setProperty("pagematches", false);
     ui-&gt;button3-&gt;setProperty("pagematches", false);
     // Set one of the buttons to true
     if (0 == index)
           ui-&gt;button1-&gt;setProperty("pagematches", true);
     else if (index == 1)
           ui-&gt;button2-&gt;setProperty("pagematches", true);
     else
           ui-&gt;button3-&gt;setProperty("pagematches", true);
     // Update buttons style
     ui-&gt;button1-&gt;style()-&gt;polish(ui-&gt;button1);
     ui-&gt;button2-&gt;style()-&gt;polish(ui-&gt;button2);
     ui-&gt;button3-&gt;style()-&gt;polish(ui-&gt;button3);
}</pre></li></ul></li> <li>The preceding <a id="_idIndexMarker077"/>code sets the <code>pagematches</code> properties of all three buttons to <strong class="bold">false</strong> when <strong class="bold">Tab Widget</strong> switches its current page. Be sure <a id="_idIndexMarker078"/>to reset everything before we decide which button should change to red.</li>
<li>Check the <code>index</code> variable supplied by the event signal; this will tell you the index number of the current page. Set the <code>pagematches</code> property of one of the buttons to <code>index</code> number.</li>
<li>Refresh the style of all three buttons by calling <code>polish()</code>. You may also want to add the following header to <code>mainwindow.h</code>:<pre class="source-code">
#include &lt;QStyle&gt;</pre></li> <li>Build and run the project. You should now see the three buttons changing to red whenever you <a id="_idIndexMarker079"/>switch <strong class="bold">Tab Widget</strong> to a different page. Also, the buttons will  change to<a id="_idIndexMarker080"/> green when there is a mouse-over, as well as change to yellow when you click on them:</li>
</ol>
<div><div><img alt="Figure 1.18 – The final result looks like this" src="img/B20976_01_018.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – The final result looks like this</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>How it works…</h2>
<p>Qt provides users the freedom to add custom properties to any type of widget. Custom properties are very useful if you want to change a particular widget when a special condition is met, whereas Qt doesn’t provide such a context by default. This allows the user to extend the usability of Qt and makes it a flexible tool for customized solutions.</p>
<p>For example, if we have a row of buttons on our main window and we need one of them to change its color depending on which page <code>QObject::setProperty()</code>. To read the custom property, we can use another function called <code>QObject::property()</code>.</p>
<p>Next, we will talk about sub-controls in Qt Style Sheets. Often, a widget is not just a single object, but a combination of more than one object or control, used to form a more complex widget. These <a id="_idIndexMarker083"/>objects are called <strong class="bold">sub-controls</strong>.</p>
<p>For example, a spin box widget contains an input field, a down button, an up button, an up arrow, and a down arrow, which is quite complicated compared to some other widgets. In this case, Qt grants us more flexibility by allowing us to change every sub-control using a style sheet if we want to. We can do so by specifying the name of the sub-control behind the widget’s class name, separated by a double colon. For instance, if I want to change the image of the down button to a spin box, I can write my style sheet as follows:</p>
<pre class="source-code">
QSpinBox::down-button {
     image: url(:/images/spindown.png);
     subcontrol-origin: padding;
     subcontrol-position: right bottom;
}</pre> <p>This will only apply the image to the down button of my spin box, and not to any other parts of the widget. By combining <strong class="bold">custom properties</strong>, <strong class="bold">pseudo-states</strong>, and <strong class="bold">sub-controls</strong>, Qt provides us with a very flexible method to customize our user interface.</p>
<p class="callout-heading">Note</p>
<p class="callout">Visit the following link to learn more about pseudo-states and subcontrols in Qt: <a href="http://doc.qt.io/qt-6/stylesheet-reference.html">http://doc.qt.io/qt-6/stylesheet-reference.html</a>.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/>Styling in Qt Modeling Language (QML)</h1>
<p><strong class="bold">Qt Meta Language</strong> or <strong class="bold">Qt Modeling Language</strong> (<strong class="bold">QML</strong>) is a JavaScript-inspired user interface markup language that’s used <a id="_idIndexMarker084"/>by Qt to design user interfaces. Qt provides you with <strong class="bold">Qt Quick Components</strong> (widgets powered <a id="_idIndexMarker085"/>by the QML technology) to<a id="_idIndexMarker086"/> easily design touch-friendly UI without C++ programming. We will learn more about how to use QML and Qt Quick Components to design our program’s UI by following the steps provided in this recipe.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>How to do it…</h2>
<p>Follow these steps to learn about styling in QML:</p>
<ol>
<li>Since Qt 6, The Qt Company has<a id="_idIndexMarker087"/> released a separate program called <strong class="bold">Qt Design Studio</strong> for <a id="_idIndexMarker088"/>developing Qt Quick applications. It’s intended to separate the different tasks of designers and programmers. So, if you’re a GUI designer, you should use <strong class="bold">Qt Design Studio</strong>, while sticking to Qt Creator if you’re a programmer. Once you have installed and opened Qt Design Studio, create a new project by pressing on the big <strong class="bold">Create Project…</strong> button or by going to <strong class="bold">File</strong> | <strong class="bold">New Project…</strong> from the top menu:</li>
</ol>
<div><div><img alt="Figure 1.19 – Creating a new QML project in Qt Design Studio" src="img/B20976_01_019.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19 – Creating a new QML project in Qt Design Studio</p>
<ol>
<li value="2">Once the <strong class="bold">New Project</strong> window <a id="_idIndexMarker089"/>appears, key in the default width and height of your project window and insert a name for your project. Then, select the directory where you want your project to be created, select a default GUI style, pick a target Qt version, and click the <strong class="bold">Create</strong> button. Your Qt Quick project will now be created by Qt Design Studio.</li>
<li>There are some differences <a id="_idIndexMarker090"/>between a <code>App.qml</code> file inside the project resource. This <code>.qml</code> file is the UI description file that’s written using the QML markup language. If you double-click the <code>main.qml</code> file, Qt Creator will open the script editor and you will see something like this:<pre class="source-code">
import QtQuick 6.2
import QtQuick.Window 6.2
import MyProject
Window {
    width: mainScreen.width
    height: mainScreen.height
    visible: true
    title: "MyProject"
    Screen01 {
        id: mainScreen
    }
}</pre></li> <li>This file tells Qt to create a window that loads the <strong class="bold">Screen01</strong> user interface and a window title with your project name. The <strong class="bold">Screen01</strong> interface comes from another file called <strong class="bold">Screen01.ui.qml</strong>.</li>
<li>If you open the <code>main.cpp</code> file<a id="_idIndexMarker092"/> located in the <code>scr</code> folder in your project, you will see the following line of code:<pre class="source-code">
QQmlApplicationEngine engine;
const QUrl url(u"qrc:Main/main.qml"_qs);</pre></li> <li>The preceding code tells Qt’s QML engine to load the <code>main.qml</code> file when the program starts. If you want to load the other <code>.qml</code> file, you know where to look for the code. The <code>src</code> folder is hidden from your Qt Design Studio project; you can look for it inside your project directory.</li>
<li>If you build the project now, all you’ll get is a huge window with simple text and a push button that says <strong class="bold">Press me</strong>. The window’s background color and the text will change when you press the push button:</li>
</ol>
<div><div><img alt="Figure 1.20 – Your first Qt Quick program" src="img/B20976_01_020.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20 – Your first Qt Quick program</p>
<ol>
<li value="8">To add UI elements, we’ll <a id="_idIndexMarker093"/>create a <strong class="bold">Qt Quick UI File</strong> by going to <strong class="bold">File</strong> | <strong class="bold">New File…</strong> and selecting <strong class="bold">Qt Quick UI File</strong> under the <strong class="bold">Files and Classes</strong> | <strong class="bold">Qt Quick </strong><strong class="bold">Files</strong> category:</li>
</ol>
<div><div><img alt="Figure 1.21 - Creating a new Qt Quick UI file" src="img/B20976_01_021.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21 - Creating a new Qt Quick UI file</p>
<ol>
<li value="9">Set <code>Main</code>, followed <a id="_idIndexMarker094"/>by clicking the <strong class="bold">Finish</strong> button:</li>
</ol>
<div><div><img alt="Figure 1.22 – Giving your Qt Quick component a meaningful name" src="img/B20976_01_022.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22 – Giving your Qt Quick component a meaningful name</p>
<ol>
<li value="10">A new file called <code>Main.ui.qml</code> has been added to your project resources. Try to open the <code>Main.ui.qml</code> file by double-clicking on it, if it hasn’t been automatically opened by Qt <a id="_idIndexMarker095"/>Design Studio upon creation. You will see a completely different UI editor compared to what we had for the C++ project in the previous recipes.</li>
<li>Let’s open <code>App.qml</code> and replace <strong class="bold">Screen01</strong> with <strong class="bold">Main</strong>, like so:<pre class="source-code">
Main {
     id: mainScreen
}</pre></li> <li>When <code>App.qml</code> is loaded by the QML engine, it will also import <code>Main.ui.qml</code> into the UI since <code>Main</code> is now being called in the <code>App.qml</code> file. Qt will check whether <code>Main</code> is a valid UI by searching for its <code>.qml</code> file based on the naming convention. This concept is similar to the C++ project we completed in all our previous recipes; the <code>App.qml</code> file acts like the <code>main.cpp</code> file and <code>Main.ui.qml</code> acts like the <code>MainWindow</code> class. You can also create other UI templates and use them in <code>App.qml</code>. Hopefully, this comparison will make it easier to understand how QML works.</li>
<li>Open <code>Main.ui.qml</code>. You should see only one item listed in the <strong class="bold">Navigator</strong> window: <strong class="bold">Item</strong>. This is the <a id="_idIndexMarker096"/>base layout of the window, which shouldn’t be deleted. It is similar to <strong class="bold">centralWidget</strong>, which we used in the previous recipe.</li>
<li>The canvas is empty at the moment, so let’s drag a <strong class="bold">Mouse Area</strong> item and <strong class="bold">Text</strong> items to the canvas from the <strong class="bold">QML Types</strong> panel on the left. Resize <strong class="bold">Mouse Area</strong> so that it fills the entire canvas. Also, make sure that both <strong class="bold">Mouse Area</strong> and the <strong class="bold">Text</strong> items are being placed under the <strong class="bold">Item</strong> item in the <strong class="bold">Navigator</strong> panel, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 1.23 – Dragging and dropping a mouse area and text items onto the canvas" src="img/B20976_01_023.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23 – Dragging and dropping a mouse area and text items onto the canvas</p>
<ol>
<li value="15">The <strong class="bold">Mouse Area</strong> item is an invincible item that gets triggered when the mouse is clicking on it, or when a finger is touching it (for mobile platforms). The <strong class="bold">Mouse Area</strong> item is also<a id="_idIndexMarker097"/> used in a <strong class="bold">button</strong> component, which we will be using in a while. The <strong class="bold">Text</strong> item is self-explanatory: it is a label that displays a block of text in the application.</li>
<li>On the <strong class="bold">Navigator</strong> window, we can hide or show an item by clicking on the icon that resembles an eye beside the item. When an item is hidden, it will not appear on the canvas or the compiled application. Just like the widgets in a C++ Qt project, Qt Quick Components are arranged in a hierarchy based on the parent-child relationship. All the child items will be placed under the parent item with an indented position. In our case, we can see that the <strong class="bold">Mouse Area</strong> and <strong class="bold">Text</strong> elements are positioned slightly to the right compared to the <strong class="bold">Item</strong> item because they are both children of the <strong class="bold">Item</strong> element. We can rearrange the parent-child relationship, as well as their position in the hierarchy, by using a click-and-drag method from the <strong class="bold">Navigator</strong> window. You can try clicking on the <strong class="bold">Text</strong> item and dragging it on top of the mouse area. You will then see that the <strong class="bold">Text</strong> item has changed its position and is now located beneath the mouse area with a wider indentation:</li>
</ol>
<div><div><img alt="Figure 1.24 – Rearranging the parent-child relationship between items" src="img/B20976_01_024.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.24 – Rearranging the parent-child relationship between items</p>
<ol>
<li value="17">We can rearrange them by <a id="_idIndexMarker098"/>using the arrow buttons located at the top of the <strong class="bold">Navigator</strong> window, as shown in the preceding screenshot. Anything that happens to the parent item will also affect all its children, such as moving the parent item, and hiding and showing the parent item.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can pan around the canvas view by holding the middle mouse button (or mouse scroll) while moving your mouse around. You can also zoom in and out by scrolling your mouse while holding the <em class="italic">Ctrl</em> key on your keyboard. By default, scrolling your mouse will move the canvas view up and down. However, if your mouse cursor is on top of the horizontal scroll bar of the canvas, scrolling the mouse will move the view to the left and right.</p>
<ol>
<li value="18">Delete both the <strong class="bold">Mouse Area</strong> item and <strong class="bold">Text</strong> items as we will be learning how to create a user interface from scratch using QML and Qt Quick.</li>
<li>Set the <code>800 x 600</code> as we’re going to need a bigger space for the widgets.</li>
<li>Copy the images we used in the previous C++ project, in the <em class="italic">Using resources in style sheets</em> recipe, over to the QML project’s folder since we are going to recreate the same login screen with QML.</li>
<li>Add the images to the resource file so that we can use them for our UI.</li>
<li>Open <strong class="bold">Qt Design Studio</strong> and switch to the <strong class="bold">Resources</strong> window. Click and drag the background image directly to the canvas. Switch over to the <strong class="bold">Layout</strong> tab on the <strong class="bold">Properties</strong> pane <a id="_idIndexMarker099"/>and click the fill anchor button, indicated here by a red circle. This will make the background image always stick to the window size:</li>
</ol>
<div><div><img alt="Figure 1.25 – Selecting the fill anchor button to make the item follow the size of its parent object" src="img/B20976_01_025.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.25 – Selecting the fill anchor button to make the item follow the size of its parent object</p>
<ol>
<li value="23">Click and drag a <strong class="bold">Rectangle</strong> component from the <strong class="bold">Library</strong> window to the canvas. We will use this as the top panel for our program.</li>
<li>For the top panel, enable the top anchor, left anchor, and right anchor so that the panel sticks to the top of the window and follows its width. Make sure all the margins are set to zero.</li>
<li>Go to the <code>#805bcce9</code> and the second color to <code>#80000000</code>. This will create a half-transparent panel with a blue gradient.</li>
<li>Add a <code>Wednesday, 25-10-2023 3:14 PM</code>) for display purposes. Then, set the text color to white.</li>
<li>Switch over to the <strong class="bold">Layout</strong> tab and enable the top anchor and left anchor so that the text widget will always stick to the top-left corner of the screen.</li>
<li>Add a <code>50 x 50</code>. Then, make it a child of the top <a id="_idIndexMarker100"/>panel by dragging it on top of the top panel in the <strong class="bold">Navigator</strong> window.</li>
<li>Set the color of the mouse area to blue (<code>#27a9e3</code>) and set its radius to <code>2</code> to make its corners slightly rounded. Enable the top anchor and right anchor to make it stick to the top-right corner of the window. Set the top anchor’s margin to <code>8</code> and the right anchor’s margin to <code>10</code> to create some space.</li>
<li>Open the <strong class="bold">Resources</strong> window and drag the shutdown icon to the canvas. Make it a child of the <strong class="bold">Mouse Area</strong> item we created a moment ago. Then, enable the fill anchor to make it fit the size of the mouse area.</li>
<li>Phew – that’s a lot of steps! Now, your items should be arranged as follows in the <strong class="bold">Navigator</strong> window:</li>
</ol>
<div><div><img alt="Figure 1.26 – Be cautious about the parent-child relationship between items" src="img/B20976_01_026.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.26 – Be cautious about the parent-child relationship between items</p>
<ol>
<li value="32">The parent-child relationship and the layout anchors are both very important to keep the widgets in <a id="_idIndexMarker101"/>the correct positions when the main window changes its size. Your top panel should look something like this:</li>
</ol>
<div><div><img alt="Figure 1.27 – Completing the top banner design" src="img/B20976_01_027.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.27 – Completing the top banner design</p>
<ol>
<li value="33">Let’s work on the login form. Add a new <code>360 x 200</code> and set its radius to <code>15</code>.</li>
<li>Set its color to <code>#80000000</code>; this will change it to black with 50% transparency.</li>
<li>Enable the vertical center anchor and the horizontal center anchor to make the rectangle always align with the center of the window. Then, set the margin of the vertical center anchor to <code>100</code> so that it moves slightly lower to the bottom. This will ensure we have the space to place the logo. The following screenshot illustrates the settings for <strong class="bold">Anchors</strong>:</li>
</ol>
<div><div><img alt="Figure 1.28 – Setting the alignment and margin" src="img/B20976_01_028.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.28 – Setting the alignment and margin</p>
<ol>
<li value="36">Add the text objects to the canvas. Make them children of the login form (the <code>Username:</code> and <code>Password:</code>. Change their <a id="_idIndexMarker102"/>text color to white and position them accordingly. We don’t need to set a margin this time because they will follow the rectangle’s position.</li>
<li>Add two text input objects to the canvas and place them next to the text widgets we just created. Make sure the text input is also a child of the login form. Since the text input doesn’t contain any background color property, we need to add two rectangles to the canvas to use as their background.</li>
<li>Add two rectangles to the canvas and make each of them a child of one of the text inputs we just created. Set the <code>5</code> to give them some rounded corners. After that, enable fill anchors on both of the rectangles so that they will follow the size of the text input widgets.</li>
<li>Now, let’s create the login button beneath the password field. Add a mouse area to the canvas and make it a child of the login form. Resize it to your preferred dimension and move it into place.</li>
<li>Since the mouse area does not contain any background color property, we need to add a <code>#27a9e3</code>) and enable the fill anchor so that it fits nicely with the mouse area.</li>
<li>Add a text object to the canvas and make it a child of the login button. Change its text color to white <a id="_idIndexMarker103"/>and set its <code>Login</code>. Finally, enable the horizontal center anchor and the vertical center anchor so that they align with the center of the button.</li>
<li>You will now get a login form that looks pretty similar to the one we made in the C++ project:</li>
</ol>
<div><div><img alt="Figure 1.29 – Final design of the login form" src="img/B20976_01_029.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.29 – Final design of the login form</p>
<ol>
<li value="43">Now, it’s time to add the logo, which is very simple. Open the <strong class="bold">Resources</strong> window and drag the logo image to the canvas.</li>
<li>Make it a child of the login form and set its size to <code>512 </code><code>x 200</code>.</li>
<li>Position it on top of the login form. With that, you’re done.</li>
<li>This is what the entire UI looks like when compiled. We have successfully recreated the login screen from the C++ project, but this time, we did it with QML and Qt Quick:</li>
</ol>
<div><div><img alt="Figure 1.30 – The final result" src="img/B20976_01_030.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.30 – The final result</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>How it works…</h2>
<p>The Qt Quick editor uses a very <a id="_idIndexMarker104"/>different approach for placing widgets in the application compared to the form editor. The user can decide which method is best suited to their purposes. The following screenshot shows what the Qt Quick Designer looks like:</p>
<div><div><img alt="Figure 1.31 – Overview of Qt Design Studio’s user interface" src="img/B20976_01_031.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.31 – Overview of Qt Design Studio’s user interface</p>
<p>Let’s look at the various elements of the editor’s UI:</p>
<ol>
<li><strong class="bold">Navigator</strong>: The <strong class="bold">Navigator</strong> window displays <a id="_idIndexMarker105"/>the items in the current QML file as a tree structure. It’s similar to the object operator window in the other Qt Designer we used in the <em class="italic">Using style sheets with Qt </em><em class="italic">Designer</em> recipe.</li>
<li><strong class="bold">Library</strong>: The <strong class="bold">Library</strong> window displays all the Qt Quick Components or Qt Quick Controls available in QML. You can click and drag it to the canvas window to add to your UI. You can also create your own custom QML components and display them here.</li>
<li><strong class="bold">Assets</strong>: The <strong class="bold">Assets</strong> window displays all the resources in a list that can then be used in your UI design.</li>
<li><strong class="bold">Add Modules</strong>: The <strong class="bold">Add Modules</strong> button allows you to import different QML modules into your current QML file, such as a Bluetooth module, a WebKit module, or a positioning module, to add additional functionality to your QML project.</li>
<li><strong class="bold">Properties</strong>: Similar to the <strong class="bold">Property Editor</strong> area we used in the previous recipe, the <strong class="bold">Properties</strong> pane in QML Designer displays the properties of the selected item. You can also change the properties of the items in the code editor.</li>
<li><strong class="bold">Canvas</strong>: The canvas is the working area where you create QML components and design applications.</li>
<li><strong class="bold">Workspace selector</strong>: The workspace selector area displays the different layouts available in the Qt<a id="_idIndexMarker106"/> Design Studio editor, allowing the user to select the workspace that suits their needs.</li>
<li><strong class="bold">Style selector</strong>: This selector is where you can select a different style to preview how your application will look when running on a specific platform. This is very useful when developing cross-platform applications.</li>
</ol>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Exposing the QML object pointer to C++</h1>
<p>Sometimes, we want to <a id="_idIndexMarker107"/>modify the properties of a QML object through C++ scripting, such as changing the text of a label, hiding/showing the widget, or<a id="_idIndexMarker108"/> changing its size. Qt’s QML engine allows you to register your QML objects to C++ types, which automatically exposes all its properties.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>How to do it…</h2>
<p>We want to create a label in QML and change its text occasionally. To expose the label object to C++, we can do the following:</p>
<ol>
<li>Create a C++ class called <code>MyLabel</code> that extends from the <code>QObject</code> class in <code>mylabel.h</code>:<pre class="source-code">
class MyLabel : public QObject {
Q_OBJECT
public:
     // Object pointer
     QObject* myObject;
     explicit MyLabel(QObject *parent = 0);
     // Must call Q_INVOKABLE so that this function can be used in QML
     Q_INVOKABLE void SetMyObject(QObject* obj);
}</pre></li> <li>In the <code>mylabel.cpp</code> source <a id="_idIndexMarker109"/>file, define a function called <code>SetMyObject()</code> to save the object pointer. This<a id="_idIndexMarker110"/> function will later be called in QML in <code>mylabel.cpp</code>:<pre class="source-code">
void MyLabel::SetMyObject(QObject* obj) {
     // Set the object pointer
     myObject = obj;
}</pre></li> <li>In <code>main.cpp</code>, include the <code>MyLabel</code> header and register it to the QML engine using the <code>qmlRegisterType()</code> function:<pre class="source-code">
include "mylabel.h"
int main(int argc, char *argv[]) {
     // Register your class to QML
     qmlRegisterType&lt;MyLabel&gt;("MyLabelLib", 1, 0, "MyLabel");
}</pre></li> <li>Notice that there are four parameters you need to declare in <code>qmlRegisterType()</code>. Besides declaring your class name (<code>MyLabel</code>), you also need to declare your library name (<code>MyLabelLib</code>) and its version (<code>1.0</code>). This will be used to import your class into QML.</li>
<li>Map the QML engine to our label object in QML and import the class library we defined earlier in <em class="italic">Step 3</em> by calling <code>import MyLabelLib 1.0</code> in our QML file. Notice that the library name and its version number have to match the one you declared in <code>main.cpp</code>; otherwise, it will throw an error. After declaring <code>MyLabel</code> in QML and<a id="_idIndexMarker111"/> setting its ID as <code>mylabel.SetMyObject(myLabel)</code> to expose its pointer to C/C++ right after<a id="_idIndexMarker112"/> the label is initialized:<pre class="source-code">
import MyLabelLib 1.0
ApplicationWindow {
     id: mainWindow
     width: 480
     height: 640
     MyLabel {
           id: mylabel
     }
     Label {
           id: helloWorldLabel
           text: qsTr("Hello World!")
           Component.onCompleted: {
               mylabel.SetMyObject(hellowWorldLabel);
           }
     }
}</pre></li> <li>Wait until the label is fully initiated before exposing its pointer to C/C++; otherwise, you may cause the program to crash. To make sure it’s fully initiated, call the <code>SetMyObject()</code> function within <code>Component.onCompleted</code> and not in any other functions or event callbacks. Now that the QML label has been exposed to C/C++, we can change any of its properties by calling the <code>setProperty()</code> function. For instance, we can set its visibility to <code>true</code> and change its text to <code>Bye </code><code>bye world!</code>:<pre class="source-code">
// Qvariant automatically detects your data type
myObject-&gt;setProperty("visible", Qvariant(true));
myObject-&gt;setProperty("text", Qvariant("Bye bye world!"));</pre></li> <li>Besides changing the <a id="_idIndexMarker113"/>properties, we can also call its functions<a id="_idIndexMarker114"/> by calling the following code:<pre class="source-code">
QVariant returnedValue;
QVariant message = "Hello world!";
QMetaObject::invokeMethod(myObject, "myQMLFunction",
Q_RETURN_ARG(QVariant, returnedValue), Q_ARG(QVariant,
message));
qDebug() &lt;&lt; "QML function returned:" &lt;&lt;
returnedValue.toString();</pre></li> <li>Or, simply, we can call the <code>invokedMethod()</code> function with only two parameters if we do not expect any values to be returned from it:<pre class="source-code">
QMetaObject::invokeMethod(myObject, "myQMLFunction");</pre></li> </ol>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>How it works…</h2>
<p>QML is designed in such a way that it can be expanded through C++ code. The classes in the Qt QML module permit QML objects to be used and operate from C++, and the capability of the QML engine united<a id="_idIndexMarker115"/> with Qt’s <strong class="bold">meta-object system</strong> allows C++ functionality to be called directly from QML. To add some C++ data or usage to QML, it should come forward from a QObject-derived class. QML object types could be instituted from C++ and supervised<a id="_idIndexMarker116"/> to access their properties, appeal their methods, and get their signal alerts. This is possible because all QML object types are executed using QObject-derived classes, allowing the QML engine to forcibly load and inspect objects through the Qt meta-object system.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>There’s more…</h2>
<p>Qt 6 comes with two different types of GUI kits – Qt Widgets and Qt Quick. Both have their strengths and advantages over the other, giving programmers the ability and freedom to design their <a id="_idIndexMarker117"/>application’s interface without having to worry about feature constraints and performance issues.</p>
<p>Qt 6 allows you to pick the best method and programming language that suits your working style and requirements for your project. By going through this chapter, you will be able to create a good-looking and functional cross-platform application using Qt 6 in no time.</p>
</div>
</body></html>