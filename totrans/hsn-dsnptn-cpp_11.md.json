["```cpp\nclass Record { ... };\nclass Database {\n  public:\n  void insert(const Record& r);\n  ...\n};\n```", "```cpp\nclass Database {\n  class Storage { ... };    // Disk storage Storage S;\n  class Index { ... };    // Memory index Index I;\n  public:\n  void insert(const Record& r);\n  ...\n};\n```", "```cpp\n//Example 01\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  I.insert(r);\n}\n```", "```cpp\nvoid Database::insert(const Record& r) {\n  I.insert(r);\n  S.insert(r);\n}\n```", "```cpp\n// Example 02\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  try {\n    I.insert(r);\n  } catch (...) {\n    S.undo();\n    throw;    // Rethrow\n  }\n}\n```", "```cpp\nbool Database::insert(const Record& r) {\n  if (!S.insert(r)) return false;\n  if (!I.insert(r)) {\n    S.undo();\n    return false;\n  }\n  return true;\n}\n```", "```cpp\n// Example 02a:\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  try {\n    I.insert(r);\n  } catch (...) {\n    S.undo();\n    S.finalize();\n    throw;\n  }\n  S.finalize();\n}\n```", "```cpp\nif (action1() == SUCCESS) {\n  if (action2() == SUCCESS) {\n    if (action3() == FAIL) {\n      rollback2();\n      rollback1();\n    }\n    cleanup2();\n  } else {\n    rollback1();\n  }\n  cleanup1();\n}\n```", "```cpp\n// Example 02b:\nclass StorageFinalizer {\n  public:\n  StorageFinalizer(Storage& S) : S_(S) {}\n  ~StorageFinalizer() { S_.finalize(); }\n  private:\n  Storage& S_;\n};\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  StorageFinalizer SF(S);\n  try {\n    I.insert(r);\n  } catch (...) {\n    S.undo();\n    throw;\n  }\n}\n```", "```cpp\nclass Cleanup1() {\n  ~Cleanup1() { cleanup1(); }\n  ...\n};\nclass Cleanup2() {\n  ~Cleanup2() { cleanup2(); }\n  ...\n};\naction1();\nCleanup1 c1;\ntry {\n  action2();\n  Cleanup2 c2;\n  try {\n    action3();\n  } catch (...) {\n    rollback2();\n    throw;\n  }\n} catch (...) {\n  rollback1();\n}\n```", "```cpp\naction1();\nCleanup1 c1;\naction2();\nCleanup2 c2;\n```", "```cpp\n// Example 03:\nclass StorageGuard {\n  public:\n  StorageGuard(Storage& S) : S_(S) {}\n  ~StorageGuard() {\n    if (!commit_) S_.undo();\n  }\n  void commit() noexcept { commit_ = true; }\n  private:\n  Storage& S_;\n  bool commit_ = false;\n};\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  StorageFinalizer SF(S);\n  StorageGuard SG(S);\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\nclass StorageGuard {\n  public:\n  StorageGuard(Storage& S) : S_(S), commit_(false) {}\n  ~StorageGuard() { if (!commit_) S_.undo(); }\n  void commit() noexcept { commit_ = true; }\n  private:\n  Storage& S_;\n  bool commit_;\n  // Important: really bad things happen if\n  // this guard is copied!\n  StorageGuard(const StorageGuard&) = delete;\n  StorageGuard& operator=(const StorageGuard&) = delete;\n};\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  StorageFinalizer SF(S);\n  StorageGuard SG(S);\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\nvoid undo(Storage& S) { S.undo(); }\n```", "```cpp\n{\n  S.insert(r);\n  ScopeGuard SG(undo, S);    // Approximate desired syntax\n  ...\n  SG.commit();            // Disarm the scope guard\n}\n```", "```cpp\n// Example 04\nclass ScopeGuardImplBase {\n  public:\n  ScopeGuardImplBase() = default;\n  void commit() const noexcept { commit_ = true; }\n  protected:\n  ScopeGuardImplBase(const ScopeGuardImplBase& other) :\n    commit_(other.commit_) { other.commit(); }\n  ~ScopeGuardImplBase() {}\n  mutable bool commit_ = false;\n};\ntemplate <typename Func, typename Arg>\nclass ScopeGuardImpl : public ScopeGuardImplBase {\n  public:\n  ScopeGuardImpl(const Func& func, Arg& arg) :\n    func_(func), arg_(arg) {}\n  ~ScopeGuardImpl() { if (!commit_) func_(arg_); }\n  private:\n  const Func& func_;\n  Arg& arg_;\n};\ntemplate <typename Func, typename Arg>\nScopeGuardImpl<Func, Arg>\nMakeGuard(const Func& func, Arg& arg) {\n  return ScopeGuardImpl<Func, Arg>(func, arg);\n}\n```", "```cpp\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  const ScopeGuardImplBase& SG = MakeGuard(undo, S);\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\nusing ScopeGuard = const ScopeGuardImplBase&;\n```", "```cpp\n// Example 04a\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  ScopeGuard SG = MakeGuard(undo, S);\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\nScopeGuard SG(undo, S);\n```", "```cpp\n// Example 05\nclass ScopeGuardImplBase {\n  public:\n  ScopeGuardImplBase() = default;\n  void commit() const noexcept { commit_ = true; }\n  protected:\n  ScopeGuardImplBase(ScopeGuardImplBase&& other) :\n    commit_(other.commit_) { other.commit(); }\n  ~ScopeGuardImplBase() {}\n  mutable bool commit_ = false;\n  private:\n  ScopeGuardImplBase& operator=(const ScopeGuardImplBase&)\n    = delete;\n};\nusing ScopeGuard = const ScopeGuardImplBase&;\ntemplate <typename Func, typename Arg>\nclass ScopeGuardImpl : public ScopeGuardImplBase {\n  public:\n  ScopeGuardImpl(const Func& func, Arg& arg) :\n    func_(func), arg_(arg) {}\n  ~ScopeGuardImpl() { if (!commit_) func_(arg_); }\n  ScopeGuardImpl(ScopeGuardImpl&& other) :\n    ScopeGuardImplBase(std::move(other)),\n    func_(other.func_),\n    arg_(other.arg_) {}\n  private:\n  const Func& func_;\n  Arg& arg_;\n};\ntemplate <typename Func, typename Arg>\nScopeGuardImpl<Func, Arg>\nMakeGuard(const Func& func, Arg& arg) {\n  return ScopeGuardImpl<Func, Arg>(func, arg);\n}\n```", "```cpp\n// Example 05a\ntemplate <typename Func, typename Arg>\nauto MakeGuard(const Func& func, Arg& arg) {\n  return ScopeGuardImpl<Func, Arg>(func, arg);\n}\n```", "```cpp\n// Example 06\ntemplate <typename MemFunc, typename Obj>\nclass ScopeGuardImpl : public ScopeGuardImplBase {\n  public:\n  ScopeGuardImpl(const MemFunc& memfunc, Obj& obj) :\n    memfunc_(memfunc), obj_(obj) {}\n  ~ScopeGuardImpl() { if (!commit_) (obj_.*memfunc_)(); }\n  ScopeGuardImpl(ScopeGuardImpl&& other) :\n    ScopeGuardImplBase(std::move(other)),\n    memfunc_(other.memfunc_),\n    obj_(other.obj_) {}\n  private:\n  const MemFunc& memfunc_; Obj& obj_;\n};\ntemplate <typename MemFunc, typename Obj>\nauto MakeGuard(const MemFunc& memfunc, Obj& obj) {// C++14\n  return ScopeGuardImpl<MemFunc, Obj>(memfunc, obj);\n}\n```", "```cpp\nScopeGuardImpl(const Func& func, Arg& arg);\n```", "```cpp\n// Example 07\nclass ScopeGuardBase {\n  public:\n  ScopeGuardBase() = default;\n  void commit() noexcept { commit_ = true; }\n  protected:\n  ScopeGuardBase(ScopeGuardBase&& other) noexcept :\n    commit_(other.commit_) { other.commit(); }\n  ~ScopeGuardBase() = default;\n  bool commit_ = false;\n  private:\n  ScopeGuardBase& operator=(const ScopeGuardBase&)\n    = delete;\n};\ntemplate <typename Func>\nclass ScopeGuard : public ScopeGuardBase {\n  public:\n  ScopeGuard(Func&& func) : func_(std::move(func)) {}\n  ScopeGuard(const Func& func) : func_(func) {}\n  ~ScopeGuard() { if (!commit_) func_(); }\n  ScopeGuard(ScopeGuard&& other) = default;\n  private:\n  Func func_;\n};\ntemplate <typename Func>\nScopeGuard<Func> MakeGuard(Func&& func) {\n  return ScopeGuard<Func>(std::forward<Func>(func));\n}\n```", "```cpp\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  auto SG = MakeGuard([&] { S.undo(); });\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\n// Example 07a\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  auto SF = MakeGuard([&] { S.finalize(); });\n  auto SG = MakeGuard([&] { S.undo(); });\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\n// Example 07b\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  ScopeGuard SF = [&] { S.finalize(); };    // C++17\n  ScopeGuard SG = [&] { S.undo(); };\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\nON_SCOPE_EXIT { S.finalize(); };\n```", "```cpp\n#define CONCAT2(x, y) x##y\n#define CONCAT(x, y) CONCAT2(x, y)\n#ifdef __COUNTER__\n#define ANON_VAR(x) CONCAT(x, __COUNTER__)\n#else\n#define ANON_VAR(x) CONCAT(x, __LINE__)\n#endif\n```", "```cpp\n// Example 08\nstruct ScopeGuardOnExit {};\ntemplate <typename Func>\nScopeGuard<Func> operator+(ScopeGuardOnExit, Func&& func) {\n  return ScopeGuard<Func>(std::forward<Func>(func));\n}\n#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \\\n  ScopeGuardOnExit() + [&]()\n```", "```cpp\n// Example 08\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  ON_SCOPE_EXIT { S.finalize(); };\n  auto SG = ScopeGuard([&] { S.undo(); });\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\n// Example 08a\n#define ON_SCOPE_EXIT_ROLLBACK(NAME) \\\n  auto NAME = ScopeGuardOnExit() + [&]()\n```", "```cpp\n// Example 08a\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  ON_SCOPE_EXIT { S.finalize(); };\n  ON_SCOPE_EXIT_ROLLBACK(SG){ S.undo(); };\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\naction1();\nON_SCOPE_EXIT { cleanup1; };\nON_SCOPE_EXIT_ROLLBACK(g2){ rollback1(); };\naction2();\nON_SCOPE_EXIT { cleanup2; };\nON_SCOPE_EXIT_ROLLBACK(g4){ rollback2(); };\naction3();\ng2.commit();\ng4.commit();\n```", "```cpp\n// Example 09\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  auto SF = MakeGuard([&] { S.finalize(); });\n  auto SG = MakeGuard([&] { S.undo(); });\n             // What if undo() can throw?\n  I.insert(r);    // Let's say this fails\n  SG.commit();    // Commit never happens\n}            // Control jumps here and undo() throws\n```", "```cpp\n// Example 09a\ntemplate <typename Func>\nclass ScopeGuard : public ScopeGuardBase {\n  public:\n  ...\n  ~ScopeGuard() {\n    if (!commit_) try { func_(); } catch (...) {}\n  }\n  ...\n};\n```", "```cpp\ntemplate <typename Func>\nclass ScopeGuard : public ScopeGuardBase {\n  public:\n  ...\n  ~ScopeGuard() {\n    if (!commit_) try { func_(); } catch (...) {\n      std::cout << \"Rollback failed\" << std::endl;\n      throw;    // Rethrow\n    }\n  }\n  ...\n};\n```", "```cpp\nclass LivingDangerously {\n  public:\n  ~LivingDangerously() {\n    try {\n      if (cleanup() != SUCCESS) throw 0;\n       more_cleanup();\n    } catch (...) {\n      std::cout << \"Cleanup failed, proceeding anyway\" <<\n      std::endl;\n      // No rethrow - this is critical!\n    }\n  }\n};\n```", "```cpp\ntemplate <typename Func, bool on_success, bool on_failure>\nclass ScopeGuard {\n  public:\n  ...\n  ~ScopeGuard() {\n    if ((on_success && is_success()) ||\n        (on_failure && is_failure())) func_();\n  }\n  ...\n};\n```", "```cpp\n// Example 10\ntemplate <typename Func, bool on_success, bool on_failure>\nclass ScopeGuard {\n  public:\n  ...\n  ~ScopeGuard() {\n    if ((on_success && !std::uncaught_exception()) ||\n        (on_failure && std::uncaught_exception())) func_();\n  }\n  ...\n};\n```", "```cpp\n// Example 10\nstruct ScopeGuardOnExit {};\ntemplate <typename Func>\nauto operator+(ScopeGuardOnExit, Func&& func) {\n  return\n    ScopeGuard<Func, true, true>(std::forward<Func>(func));\n}\n#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \\\n  ScopeGuardOnExit() + [&]()\nstruct ScopeGuardOnSuccess {};\ntemplate <typename Func>\nauto operator+(ScopeGuardOnSuccess, Func&& func) {\n  return\n   ScopeGuard<Func, true, false>(std::forward<Func>(func));\n}\n#define ON_SCOPE_SUCCESS auto ANON_VAR(SCOPE_EXIT_STATE) =\\\n  ScopeGuardOnSuccess() + [&]()\nstruct ScopeGuardOnFailure {};\ntemplate <typename Func>\nauto operator+(ScopeGuardOnFailure, Func&& func) {\n  return\n   ScopeGuard<Func, false, true>(std::forward<Func>(func));\n}\n#define ON_SCOPE_FAILURE auto ANON_VAR(SCOPE_EXIT_STATE) =\\\n  ScopeGuardOnFailure() + [&]()\n```", "```cpp\nclass ComplexOperation {\n  Database db_;\n  public:\n  ...\n  ~ComplexOperation() {\n    try {\n      db_.insert(some_record);\n    } catch (...) {}    // Shield any exceptions from insert()\n  }\n};\n{\n  ComplexOperation OP;\n  throw 1;\n}    // OP.~ComplexOperation() runs here\n```", "```cpp\n// Example 10a\nclass UncaughtExceptionDetector {\n  public:\n  UncaughtExceptionDetector() :\n    count_(std::uncaught_exceptions()) {}\n  operator bool() const noexcept {\n    return std::uncaught_exceptions() > count_;\n  }\n  private:\n  const int count_;\n};\n```", "```cpp\n// Example 10a\ntemplate <typename Func, bool on_success, bool on_failure>\nclass ScopeGuard {\n  public:\n  ...\n  ~ScopeGuard() {\n  if ((on_success && !detector_) ||\n      (on_failure && detector_)) func_();\n  }\n  ...\n  private:\n  UncaughtExceptionDetector detector_;\n  ...\n};\n```", "```cpp\n// Example 10b\nnamespace  cxxabiv1 {\n  struct cxa_eh_globals;\n  extern \"C\" cxa_eh_globals* cxa_get_globals() noexcept;\n}\nclass UncaughtExceptionDetector {\n  public:\n  UncaughtExceptionDetector() :\n    count_(uncaught_exceptions()) {}\n  operator bool() const noexcept {\n    return uncaught_exceptions() > count_;\n  }\n  private:\n  const int count_;\n  int uncaught_exceptions() const noexcept {\n    return *(reinterpret_cast<int*>(\n      static_cast<char*>( static_cast<void*>(\n        cxxabiv1::cxa_get_globals())) + sizeof(void*)));\n  }\n};\n```", "```cpp\n// Example 11\nclass ScopeGuard {\n  public:\n  template <typename Func> ScopeGuard(Func&& func) :\n    func_(std::forward<Func>(func)) {}\n  ~ScopeGuard() { if (!commit_) func_(); }\n  void commit() const noexcept { commit_ = true; }\n  ScopeGuard(ScopeGuard&& other) :\n    commit_(other.commit_), func_(std::move(other.func_)) {\n    other.commit();\n  }\n  private:\n  mutable bool commit_ = false;\n  std::function<void()> func_;\n  ScopeGuard& operator=(const ScopeGuard&) = delete;\n};\n```", "```cpp\nvoid Database::insert(const Record& r) {\n  S.insert(r);\n  ScopeGuard SF([&] { S.finalize(); });\n  ScopeGuard SG([&] { S.undo(); });\n  I.insert(r);\n  SG.commit();\n}\n```", "```cpp\n// Example 11\ntemplate <size_t S = 16>\nclass ScopeGuard : public CommitFlag {\n  alignas(8) char space_[S];\n  using guard_t = void(*)(void*);\n  guard_t guard_ = nullptr;\n  template<typename Callable>\n  static void invoke(void* callable) {\n    (*static_cast<Callable*>(callable))();\n  }\n  mutable bool commit_ = false;\n  public:\n  template <typename Callable,\n            typename D = std::decay_t<Callable>>\n    ScopeGuard(Callable&& callable) :\n    guard_(invoke<Callable>) {\n    static_assert(sizeof(Callable) <= sizeof(space_));\n    ::new(static_cast<void*>(space_))\n      D(std::forward<Callable>(callable));\n  }\n  ScopeGuard(ScopeGuard&& other) = default;\n  ~ScopeGuard() { if (!commit_) guard_(space_); }\n};\n```", "```cpp\nvoid BM_nodelete(benchmark::State& state) {\n  for (auto _ : state) {\n    int* p = nullptr;\n    ScopeGuardTypeErased::ScopeGuard SG([&] { delete p; });\n    p = rand() < 0 ? new int(42) : nullptr;\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\nBenchmark                              Time\n-------------------------------------------\nBM_nodelete_explicit                4.48 ns\nBM_nodelete_type_erased             6.29 ns\nBM_nodelete_type_erased_fast        5.48 ns\nBM_nodelete_template                4.50 ns\n```", "```cpp\nvoid BM_nodelete(benchmark::State& state) {\n  for (auto _ : state) {\n    int* p = nullptr;\n    ScopeGuardTypeErased::ScopeGuard SG([&] { delete p; });\n    p = rand() >= 0 ? new int(42) : nullptr;\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\nBenchmark                              Time\n-------------------------------------------\nBM_delete_explicit                  4.54 ns\nBM_delete_type_erased               13.4 ns\nBM_delete_type_erased_fast          12.7 ns\nBM_delete_template                  4.56 ns\n```"]