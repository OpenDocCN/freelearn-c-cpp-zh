- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Linux Systems and the POSIX Standard
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 系统和 POSIX 标准入门
- en: This book is about **Linux** and how we use **C++** in **Linux** environments
    to manage critical resources. The **C++** language is continuously improving,
    as you’ll explore in the following chapters. Before we go there, we’d like to
    spend some time in this chapter developing a fundamental understanding of **operating
    systems** (**OSs**). You are going to learn more about the origins of some specific
    techniques, the **system call interface** and the **Portable Operating System**
    **Interface** (**POSIX**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于 **Linux** 以及我们如何在 **Linux** 环境中使用 **C++** 来管理关键资源。**C++** 语言在不断发展，你将在接下来的章节中了解到这一点。在进入那个话题之前，我们想在本章中花些时间来建立对
    **操作系统** （**OSs**）的基本理解。你将了解更多关于某些特定技术的起源，包括 **系统调用接口** 和 **可移植操作系统** **接口** （**POSIX**）。
- en: Your choice of OS matters. Although OSs were created with a single purpose,
    nowadays their roles differ. Much is expected of them as well. Each OS has its
    own strengths and weaknesses, which we are going to discuss briefly. **Linux**
    is in widespread use across multiple technological areas and has a huge community
    worldwide, so it is perfect for our practical purposes. In our experience, programming
    in Linux or other *Unix-based OS* environments is rather common. Wherever your
    expertise resides – from **Internet of Things** (**IoT**) devices and embedded
    software development to mobile devices, supercomputing, or spacecraft – there
    is a good chance that you will cross paths with a Linux distribution at some point.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的操作系统很重要。尽管操作系统最初是为了单一目的而创建的，但如今它们的角色各不相同。人们对它们也有很高的期望。每个操作系统都有其自身的优势和劣势，我们将简要讨论。**Linux**
    在多个技术领域得到广泛应用，拥有庞大的全球社区，因此非常适合我们的实际目的。根据我们的经验，在 Linux 或其他基于 *Unix* 的操作系统环境中编程相当普遍。无论你的专长在哪里——从
    **物联网** （**IoT**） 设备和嵌入式软件开发到移动设备、超级计算或航天器——你都有很大机会在某个时刻遇到 Linux 发行版。
- en: Use this chapter as an introduction to system programming. Even if you are already
    familiar with the topic, take your time to revisit the terms and details. Most
    of them are covered by college courses or are taken as common knowledge, but it
    is nonetheless important for us to explain some of the fundamentals here to make
    sure we will be on the same page in the chapters to come.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章用作系统编程的入门。即使你对这个主题已经很熟悉，也请花时间回顾一下术语和细节。其中大部分内容都包含在大学课程中，或者被视为常识，但在此处解释一些基本概念仍然很重要，以确保我们在接下来的章节中保持一致。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Getting familiar with the concept of OSs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉操作系统（OSs）的概念
- en: Getting to know the Linux kernel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Linux 内核
- en: Introducing the system call interface and system programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍系统调用接口和系统编程
- en: Navigating through files, processes, and threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件、进程和线程中导航
- en: Running services with `init` and `systemd`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `init` 和 `systemd` 运行服务
- en: '**Portable Operating System** **Interface** (**POSIX**)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植操作系统** **接口** （**POSIX**）'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to get familiar with the programming environment, the reader must
    prepare the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉编程环境，读者必须准备以下内容：
- en: A Linux-based system capable of compiling and executing C++20 (for example,
    Linux Mint 21)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行 C++20 的基于 Linux 的系统（例如，Linux Mint 21）
- en: Getting familiar with the concept of OSs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉操作系统（OSs）的概念
- en: So, what is an OS? You could probably provide at least one answer, but let’s
    discuss this briefly as it is important to understand what our computer system
    truly is and how we manipulate it. Although you might be familiar with most of
    the information provided here, we are using this chapter to align with you on
    the matter of OSs and their uses. Some might say that the OS was created to make
    the hardware work as a whole. Others will argue that it is an aggregation of programs,
    dedicated to managing the system resources overall. It is crucial to utilize these
    resources, such as CPU and memory, efficiently. There is also the concept of the
    OS as an abstraction and an extension of the hardware. Ultimately, we can safely
    say that the modern OS is a complex entity. It also has additional functions,
    such as the collection of statistics, multimedia handling, system safety and security,
    overall stability, reliable error handling, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是操作系统？你可能至少能提供一个答案，但让我们简要讨论一下，因为这很重要，我们需要了解我们的计算机系统真正是什么以及我们如何操作它。尽管你可能熟悉这里提供的大部分信息，但我们使用本章来与你就操作系统及其用途达成一致。有些人可能会说，操作系统是为了使硬件作为一个整体工作而创建的。其他人可能会争论说，它是一系列程序的总和，致力于管理整体系统资源。有效地利用这些资源，如CPU和内存，至关重要。还有操作系统作为抽象和硬件扩展的概念。最终，我们可以安全地说，现代操作系统是一个复杂的实体。它还具有其他功能，例如收集统计数据、多媒体处理、系统安全性和安全性、整体稳定性、可靠的错误处理等。
- en: While the OS is obliged to execute all those tasks, it is still necessary for
    the programmer to pay attention to the system specifics and requirements. Working
    from a higher level of abstraction, through virtual machines, for example, does
    not mean discarding the need to understand how our code impacts the system’s behavior.
    And programmers, who are closer to the OS layers, are required to manage the system’s
    resources efficiently as well. This is one of the reasons that OSs provide **application
    programming interfaces**, or **APIs**. It is valuable expertise to know how to
    use such APIs and what kind of benefits they provide.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然操作系统有义务执行所有这些任务，但程序员仍然需要关注系统的具体要求和细节。从更高的抽象层次工作，例如通过虚拟机，并不意味着可以忽视理解我们的代码如何影响系统行为的需求。而且，更接近操作系统层的程序员需要高效地管理系统的资源。这就是操作系统提供**应用程序编程接口**（APIs）的原因之一。了解如何使用这些API以及它们提供的哪些好处是一种宝贵的专业知识。
- en: We believe that the ability to work closely with the OS is a skill that is not
    so common. Knowledge of how the OS and the computer architecture will behave is
    at the expert level of software engineering. We will discuss some types of OSs
    just to give you a broad picture, but the focus of the book is specifically on
    **POSIX-compliant** OSs. That said, let’s get familiar with one of our main toolsets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，能够与操作系统紧密合作是一种不太常见的技能。了解操作系统和计算机架构的行为属于软件工程的专家级别。我们将讨论一些操作系统类型，只是为了给你一个大致的了解，但本书的重点是专门针对**POSIX兼容**的操作系统。话虽如此，让我们熟悉一下我们主要的工具集之一。
- en: Types of OSs
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统类型
- en: 'If we do some quick research online, we will find many types of OSs, and the
    type definition will strictly be based on the criterion searched for. One example
    is the purpose of the OS: is it a general-purpose one, such as macOS and Windows,
    or more specific, such as **Embedded Linux** and **FreeRTOS**? Another example
    is OSs for PCs versus those for mobile devices. Likewise, the licensing could
    describe the OSs as open source, enterprise, or enterprise open source. Based
    on the number of active users at a time, Windows could be considered a *single-user*
    OS, as it constructs just one **Win32 API** for the current *user session*. On
    the other hand, Unix-like OSs are considered *multi-user*, as multiple users can
    work simultaneously on the system, where each *shell* or a *Terminal* instance
    is considered a separate user session.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网上进行一些快速研究，我们会发现许多类型的操作系统，类型定义将严格基于搜索的标准。一个例子是操作系统的目的：它是一个通用操作系统，如macOS和Windows，还是更具体，如**嵌入式Linux**和**FreeRTOS**？另一个例子是针对PC的操作系统与针对移动设备的操作系统。同样，许可协议可能将操作系统描述为开源、企业或企业开源。根据同一时间活跃用户数量，Windows可能被视为**单用户**操作系统，因为它只为当前的**用户会话**构建一个**Win32
    API**。另一方面，类Unix操作系统被认为是**多用户**的，因为多个用户可以同时在该系统上工作，其中每个**shell**或**终端**实例被视为一个单独的用户会话。
- en: 'So, the system’s applications and their constraints are fundamental. Therefore,
    a key distinction to be aware of is the level of restrictions on the system’s
    behavior. The **general-purpose operating systems** (**GPOSs**) started initially
    as *time-sharing* OSs. Historically, there is another type of OS, originating
    from the same period as the time-sharing ones – the **real-time operating systems**
    (**RTOSs**). It is expected that system programmers understand the specifics of
    **GPOSs** and **RTOSs**. In the following chapters, we will discuss how properties
    such as task priorities, timer values, peripheral speeds, interrupt and signal
    handlers, multithreading, and dynamic memory allocation can lead to changes in
    system behavior. Sometimes these are unpredictable. That’s why we recognize two
    types of **RTOSs**: hard and soft **RTOSs**. Hard **RTOSs** are usually strictly
    related to a given piece of hardware. The system developer is familiar with the
    end device requirements. The task execution times can be preliminary evaluated
    and programmed, although the device’s input is still treated as asynchronous and
    unpredictable. Therefore, our focus in this book remains on **GPOS** programming
    with a bit of soft **RTOS** functions.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系统的应用及其限制是基本的。因此，需要了解的一个关键区别是系统行为的限制级别。**通用操作系统**（**GPOSs**）最初作为**分时**操作系统开始。从历史上看，还有一种类型的操作系统，与分时操作系统起源于同一时期——**实时操作系统**（**RTOSs**）。预期系统程序员了解**GPOSs**和**RTOSs**的特定内容。在接下来的章节中，我们将讨论诸如任务优先级、计时器值、外围设备速度、中断和信号处理程序、多线程和动态内存分配等属性如何导致系统行为的变化。有时这些变化是不可预测的。这就是为什么我们认识到两种类型的**RTOSs**：硬**RTOSs**和软**RTOSs**。硬**RTOSs**通常与特定的硬件紧密相关。系统开发者熟悉最终设备的要求。任务执行时间可以预先评估和编程，尽管设备的输入仍然被视为异步和不可预测的。因此，本书的重点仍然是**GPOS**编程，附带一些软**RTOS**功能。
- en: 'Let’s set the stage like this: the user receives system resources in a cyclic
    manner so often that it creates the impression that the user is the only one relying
    on those resources. The user’s work must not be disrupted, and quick response
    times are to be expected from an OS; theoretically, the smaller the procedures,
    the shorter the response times. We will discuss this further in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029)
    as it is not completely true.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样设定场景：用户以循环方式接收系统资源如此频繁，以至于给人一种用户是唯一依赖这些资源的印象。用户的工作不应被打断，并且操作系统应提供快速响应时间；理论上，程序越小，响应时间越短。我们将在[*第二章*](B20833_02.xhtml#_idTextAnchor029)中进一步讨论这个问题，因为它并不完全正确。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The user is the main *driver* of the system’s functionality with a **GPOS**.
    The main job of the OS is maintaining active dialog with the users and the high
    availability of operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在**GPOS**中，用户是系统功能的主要**驱动器**。操作系统的主要任务是保持与用户和操作的高可用性之间的活跃对话。
- en: Here, each task and each request to the OS must be handled quickly within a
    strict time interval. The **RTOS** expects user input only during exceptional
    situations, errors, and unpredicted behavior.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个任务和对操作系统的每个请求都必须在严格的时间间隔内快速处理。**RTOS**仅在异常情况、错误和不可预测的行为期间期望用户输入。
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Asynchronously working devices and additional peripheral electronics are the
    main *drivers* of the system’s functionality in an RTOS. The main job of the OS
    remains process management and task scheduling.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**RTOS**中，异步工作的设备和额外的外围电子设备是系统功能的主要**驱动器**。操作系统的主要任务仍然是进程管理和任务调度。
- en: 'As we said, there are two types of **RTOS**: *hard RTOS* and *soft RTOS*. In
    a hard **RTOS**, real-time tasks are guaranteed to be executed on time. System
    reaction deadlines are usually preliminarily defined, and the *mission-critical*
    data is stored in ROM, so it cannot be updated at runtime. Functionalities such
    as virtual memory are often removed. Some modern CPU cores provide the so-called
    **tightly coupled memory** (**TCM**), into which the frequently used data and
    code lines are loaded from the **non-volatile memory** (**NVM**) on system startup.
    The system’s behavior is *scripted* *a priori*. The role of these OSs is related
    to machine control, where the user’s input is forbidden.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，有两种类型的**RTOS**：*硬RTOS*和*软RTOS*。在硬**RTOS**中，实时任务保证能够按时执行。系统的反应截止时间通常预先定义，而*关键任务*数据存储在ROM中，因此不能在运行时更新。通常移除虚拟内存等功能。一些现代CPU核心提供了所谓的**紧密耦合内存**（**TCM**），在系统启动时，频繁使用的数据和代码行从**非易失性存储器**（**NVM**）加载到其中。系统的行为是*预先脚本化*的。这些操作系统的作用与机器控制相关，其中禁止用户的输入。
- en: 'A soft **RTOS** provides critical tasks with the highest priority until completion
    and without interruptions. Still, real-time tasks are expected to be completed
    in a timely manner and should not wait endlessly. It is obvious that this type
    of OS cannot be utilized for mission-critical tasks: factory machines robots,
    vehicles, and so on. But it can be used to control the overall system behavior,
    so this type of OS is found in multimedia and research projects, artificial intelligence,
    computer graphics, virtual reality devices, and more. As these **RTOSs** do not
    clash with the **GPOS**s, they can be integrated with them. Their functions can
    be found in some Linux distributions as well. An interesting realization of this
    is **QNX**.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软**RTOS**（实时操作系统）在任务完成之前为关键任务提供最高优先级，并且不会受到中断。然而，实时任务仍需及时完成，不应无限期地等待。显然，这种类型的操作系统不能用于关键任务：例如工厂机器机器人、车辆等。但它可以用来控制整个系统的行为，因此这种类型的操作系统在多媒体和研究项目中、人工智能、计算机图形学、虚拟现实设备等领域都有应用。由于这些**RTOS**与**GPOS**（通用操作系统）不冲突，它们可以与之集成。它们的功能也可以在某些Linux发行版中找到。这种实现的有趣例子是**QNX**。
- en: Linux in short
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简而言之，Linux
- en: There are a few misconceptions here, so let’s settle them briefly. Linux is
    a *Unix-like OS*, meaning it provides similar (and occasionally the same) interfaces
    as Unix – its functions, especially APIs, are designed to match the ones from
    Unix. But it is not a *Unix-based* OS. Their functions are not implemented in
    the same way. A similar misconception exists in understandings of the FreeBSD-macOS
    relationship. Although both share a significant portion of code, their approach
    is completely different, including the way their kernels are structured.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些误解，让我们简要地澄清一下。Linux是一个*类Unix操作系统*，这意味着它提供了类似于Unix（有时甚至是相同的）接口——它的功能，尤其是API，被设计成与Unix匹配。但它不是一个*基于Unix*的操作系统。它们的实现方式并不相同。在FreeBSD-macOS关系的理解中存在类似的误解。尽管两者共享大量的代码，但它们的处理方式完全不同，包括它们内核的结构。
- en: It is important to bear these facts in mind as not all functions we are going
    to use in this book exist or are reachable on all Unix-like OSs. We are focusing
    on Linux, and our examples will work as long as the respective technical requirements
    for each chapter are met.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们需要记住这些事实，因为并非所有我们将要使用的功能都存在于所有类Unix操作系统上。我们专注于Linux，并且只要满足每一章的技术要求，我们的示例就能正常工作。
- en: 'There are a few reasons for this decision. First, Linux is open-sourced, and
    you can easily check its kernel code: [https://github.com/torvalds/linux](https://github.com/torvalds/linux).
    You should be able to read it easily as it is written in C. Even though C is not
    an object-oriented language, the Linux kernel follows many **object-oriented programming**
    (**OOP**) paradigms. The OS itself consists of many independent design blocks,
    called *modules*. You could easily configure, integrate, and apply them specifically
    for your system’s needs. Linux gives us the ability to work with real-time systems
    (described later in the chapter) and do parallel code executions (discussed in
    [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086)). In short – Linux is easily adaptable,
    expandable, and configurable; we could easily use this to our advantage. But *where*,
    exactly?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定有几个原因。首先，Linux是开源的，您可以轻松地检查其内核代码：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)。由于它是用C编写的，您应该能够轻松阅读它。尽管C不是面向对象的语言，但Linux内核遵循了许多**面向对象编程**（**OOP**）范式。操作系统本身由许多独立的设计块组成，称为*模块*。您可以轻松地配置、集成和应用它们，以满足您系统的特定需求。Linux赋予我们与实时系统（本章后面将描述）一起工作的能力，并执行并行代码执行（在第[*第6章*](B20833_06.xhtml#_idTextAnchor086)中讨论）。简而言之——Linux易于适应、扩展和配置；我们可以轻松地利用这一点。但*在哪里*，确切地说？
- en: 'Well, we could develop applications that are close to the OS, or we could even
    produce some modules ourselves, which can be loaded or unloaded at runtime. Such
    an example is a filesystem or device driver. We are going to revisit this topic
    in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029), when deep diving into the
    *process* entity. For now, let’s say that the modules pretty much look like an
    OOP design: they are constructible and destructible; sometimes, based on the kernel’s
    needs, common code could be generalized into one module, and these modules have
    hierarchical dependencies. Nevertheless, the Linux kernel is considered *monolithic*;
    for example, it has complex functionality, but the entire OS runs in *kernel space*.
    In contrast, there are *micro-kernels* (QNX, MINIX, or L4), which constitute the
    bare minimum of a running OS. Additional functionality in this case is provided
    through modules that work outside the kernel itself. This leads to a slightly
    chaotic but overall clear picture of the possibilities of the Linux kernel.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以开发接近操作系统的应用程序，甚至可以自己制作一些模块，这些模块可以在运行时加载或卸载。这样的例子包括文件系统或设备驱动程序。我们将在[*第2章*](B20833_02.xhtml#_idTextAnchor029)中重新探讨这个话题，届时我们将深入探讨*进程*实体。现在，让我们说这些模块基本上看起来像面向对象的设计：它们是可构建和可销毁的；有时，根据内核的需求，通用代码可以概括成一个模块，并且这些模块具有层次依赖性。尽管如此，Linux内核被认为是*单核*的；例如，它具有复杂的功能，但整个操作系统都在*内核空间*中运行。相比之下，存在*微内核*（如QNX、MINIX或L4），它们构成了运行操作系统的最小必要条件。在这种情况下，额外的功能是通过在内核本身之外工作的模块提供的。这导致了一个略微混乱但总体清晰的Linux内核可能性图景。
- en: Getting to know the Linux kernel
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Linux内核
- en: '*Figure 1**.1* illustrates an example of a Linux kernel. Based on your needs,
    the system architecture could look different, but you can observe the three main
    layers we expect to see in any given Linux system.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1*展示了Linux内核的一个示例。根据您的需求，系统架构可能看起来不同，但您可以看到我们期望在任何给定的Linux系统中看到的三个主要层。'
- en: These are the *user space* (running processes and their threads), the *kernel
    space* (the running kernel itself, usually a process of its own), and the *computer*
    – this could be any kind of computing device, such as a PC, tablet, smartphone,
    supercomputer, IoT device, and so on. One by one, all the terms observed in the
    diagram will fall into place as we explain them in the following chapters, so
    don’t worry if you are not familiar with all of them right now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是*用户空间*（运行中的进程及其线程）、*内核空间*（正在运行的内核本身，通常是一个自己的进程）和*计算机*——这可以是任何类型的计算设备，如PC、平板电脑、智能手机、超级计算机、物联网设备等等。随着我们在以下章节中逐一解释它们，图中观察到的所有术语都将逐一到位，所以如果你现在不熟悉所有这些术语，请不要担心。
- en: '![Figure 1.1 – Overview of the Linux kernel and the neighboring layers](img/Figure_1.1_B20833.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Linux内核及其相邻层的概述](img/Figure_1.1_B20833.jpg)'
- en: Figure 1.1 – Overview of the Linux kernel and the neighboring layers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Linux内核及其相邻层的概述
- en: Some interdependencies in the preceding diagram have probably made an impression
    on you already. For example, see how the *device drivers*, the *respective devices*,
    and the *interrupts* are related. The device drivers are a generalization of *character
    device drivers*, *block device drivers*, and *network device drivers.* Note how
    the interrupts are related to the *scheduling* of the tasks. This is a trivial
    but fundamental mechanism, used heavily in the implementation of drivers. It is
    an initial *communication* *and* *control* mechanism of the OS and the hardware.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，一些相互依赖关系可能已经给您留下了印象。例如，看看*设备驱动程序*、*相应设备*和*中断*是如何相关的。设备驱动程序是*字符设备驱动程序*、*块设备驱动程序*和*网络设备驱动程序*的泛化。注意中断是如何与任务的*调度*相关的。这是一个简单但基本的机制，在驱动程序的实现中被广泛使用。它是操作系统和硬件的初始*通信*和*控制*机制。
- en: 'Just one example: let’s say you want to restore and read a file from the disk
    (`read()` call will be executed under the hood, which is then translated to a
    *filesystem* operation. The filesystem calls the device driver to find and retrieve
    the content behind the given file descriptor, which is then related to an address
    known by the filesystem. This will be discussed further in [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047).
    The required device (**NVM**) starts to search for the piece of data – a file.
    Until the operation is finished, if the caller process is a single-threaded process
    and has nothing else to do, it will be stopped. Another process will start to
    work until the device *finds* and *returns a pointer* to the file’s address. Then
    an interrupt is triggered, and this helps the OS to invoke the *scheduler*. Our
    initial process will be started again using the newly loaded data, and the second
    process will now be stopped.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只举一个例子：假设您想要从磁盘恢复并读取一个文件（在底层将执行`read()`调用，然后转换为*文件系统*操作。文件系统调用设备驱动程序来查找并检索给定文件描述符背后的内容，该内容与文件系统已知的一个地址相关联。这将在[*第三章*](B20833_03.xhtml#_idTextAnchor047)中进一步讨论。所需的设备（**NVM**）开始搜索数据块——一个文件。直到操作完成，如果调用进程是一个单线程进程且没有其他事情可做，它将被停止。另一个进程将开始工作，直到设备*找到*并*返回*指向文件地址的指针。然后触发一个中断，这有助于操作系统调用*调度器*。我们的初始进程将使用新加载的数据重新启动，而第二个进程现在将被停止。
- en: This task example demonstrates how you can impact the system’s behavior with
    just a small, insignificant operation – and this is one you will have learned
    to code in your first programming classes. In most cases, nothing bad will happen,
    of course. Many processes will be rescheduled all the time during the lifespan
    of your system. It is the OS’s job to make this happen without disruptions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务示例展示了您如何仅通过一个微小且微不足道的操作来影响系统的行为——这正是您在第一门编程课程中学到的编程技能。当然，在大多数情况下，不会发生任何坏事。在您的系统生命周期内，许多进程将不断重新安排。这是操作系统的职责，确保这一过程不会出现中断。
- en: But the interrupt is a heavy operation that could lead to needless memory accesses
    and useless application state switches. We will discuss this in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029).
    For now, just think about what happens if the system is overloaded – the CPU is
    at 99% usage, or the disk has received many requests and cannot handle them in
    a timely manner. And what if that system was part of an airplane’s embedded devices?
    Of course, this is highly unlikely in reality, as airplanes have strict technical
    requirements and high-quality standards to meet. But just for the sake of argument,
    consider how you might prevent a similar situation from happening, or how you
    would guarantee the code’s successful execution in any user scenario.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但中断是一个重量级的操作，可能会导致不必要的内存访问和无用的应用程序状态转换。我们将在[*第二章*](B20833_02.xhtml#_idTextAnchor029)中讨论这一点。现在，只需考虑如果系统过载会发生什么——CPU
    使用率高达 99%，或者磁盘收到了许多请求但无法及时处理。如果该系统是飞机嵌入式设备的一部分呢？当然，在现实中这种情况非常不可能，因为飞机有严格的技术要求和高质量标准需要满足。但只是为了辩论，考虑一下您如何防止类似情况发生，或者您如何保证在任何用户场景中代码的成功执行。
- en: Introducing the system call interface and system programming
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍系统调用接口和系统编程
- en: Of course, the example that we just saw is simplified but gives us some idea
    about the work that the OS needs to do – in essence, it is responsible for managing
    and providing resources, but at the same time remains available for other processes’
    requests. This is a messy job on modern OSs. Rarely can we do anything about it.
    So, to have better control and predictability of system behavior, programmers
    might directly use the OS’s API, called the **system** **call interface**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们刚才看到的例子是简化的，但它给了我们一些关于操作系统需要执行的工作的想法——本质上，它负责管理和提供资源，但同时也保持对其他进程请求的可用性。在现代操作系统中，这是一项繁杂的工作。我们很少能对此有所作为。因此，为了更好地控制和预测系统行为，程序员可能会直接使用操作系统的
    API，称为**系统调用接口**。
- en: Important note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The NVM data request is a procedure that benefits from the `glibc` and are not
    invoked directly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: NVM 数据请求是一个受益于 `glibc` 的过程，并且不是直接调用的。
- en: In other words, the system calls define the programmer’s interface through which
    all kernel services are made available. The OS can be considered as more of a
    mediator between the kernel service and the hardware. Unless you like to play
    with hardware pins and low-level platform instructions, or you are a module architect
    yourself, you should bravely leave the details to the OS. It is the OS’s responsibility
    to handle the specific computer physical interface operations. It is the application’s
    responsibility to use the correct system calls. And it is the software engineer’s
    task to be aware of their impact on the system’s overall behavior. Bear in mind
    that using system calls comes with a price.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，系统调用定义了程序员通过它来获取所有内核服务的接口。操作系统可以被视为在内核服务和硬件之间的更多中介。除非你喜欢玩硬件引脚和低级平台指令，或者你自己就是模块架构师，否则你应该勇敢地将细节留给操作系统。处理特定的计算机物理接口操作是操作系统的责任。使用正确的系统调用是应用程序的责任。而了解它们对系统整体行为的影响是软件工程师的任务。请记住，使用系统调用是有代价的。
- en: 'As observed in the example, the OS will do a lot while retrieving a file. And
    even more will be done when memory is allocated dynamically, or a single memory
    chunk is accessed by multiple threads. We will discuss this further in the following
    chapters, and will emphasize using systems calls sparingly, with awareness, whether
    voluntarily or involuntarily, wherever possible. Simply said, system calls are
    not trivial function calls as they are not executed in user space. Instead of
    going to the next procedure in your program’s stack, the system call triggers
    a mode switch, which leads to a jump to a routine in the kernel’s memory stack.
    Reading from a file can be visualized as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，在检索文件时，操作系统会做很多事情。当动态分配内存或单个内存块被多个线程访问时，将做更多的事情。我们将在接下来的章节中进一步讨论这个问题，并将强调尽可能谨慎、有意识地使用系统调用，无论是自愿还是不自愿。简单来说，系统调用不是简单的函数调用，因为它们不在用户空间执行。系统调用不会像你的程序堆栈中的下一个程序一样执行，而是触发一个模式切换，导致跳转到内核内存堆栈中的一个例程。从文件中读取可以可视化如下：
- en: '![Figure 1.2 – System call interface representation of reading from a file](img/Figure_1.2_B20833.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 从文件中读取的系统调用接口表示](img/Figure_1.2_B20833.jpg)'
- en: Figure 1.2 – System call interface representation of reading from a file
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 从文件中读取的系统调用接口表示
- en: 'When should we use system calls then? Put simply, when we want to be very precise
    about some OS tasks, often related to **device management**, **file management**,
    **process control**, or **communication infrastructure**. We are going to present
    many examples of these roles in the later chapters, but in brief, you are welcome
    to read more and get familiar yourself with the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该在什么时候使用系统调用呢？简单来说，当我们想要对一些操作系统任务非常精确时，这些任务通常与**设备管理**、**文件管理**、**进程控制**或**通信基础设施**有关。我们将在后面的章节中展示这些角色的许多例子，但简要来说，欢迎您阅读更多内容，并自己熟悉以下内容：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important links
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要链接
- en: 'The right place to start is the **Linux man-pages project**, linked here: [https://www.kernel.org/doc/man-pages/](https://www.kernel.org/doc/man-pages/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的起点是**Linux man-pages 项目**，链接如下：[https://www.kernel.org/doc/man-pages/](https://www.kernel.org/doc/man-pages/)。
- en: 'A brief list of the useful system calls can be found at the following link:
    [https://man7.org/linux/man-pages/man2/syscalls.2.xhtml](https://man7.org/linux/man-pages/man2/syscalls.2.xhtml).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中可以找到有用系统调用的一览表：[https://man7.org/linux/man-pages/man2/syscalls.2.xhtml](https://man7.org/linux/man-pages/man2/syscalls.2.xhtml)。
- en: We strongly encourage you to do more research on system calls used in your own
    projects. Are there any, and what kind of job do they do? Are there any alternatives
    in your implementations?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议你对自己的项目中进行更多关于系统调用的研究。有没有，以及它们执行什么任务？在你的实现中有没有替代方案？
- en: You have probably already guessed that using the **system call interface** involves
    a security risk for the system, too. Being that close to the kernel and the device
    control provides a great opportunity for malicious software to infiltrate your
    software. While your software is impacting system behavior, another program might
    sniff around and gather valuable data. The least you could do is design your code
    in such a way that the user’s interface is well isolated from the crucial procedures,
    especially system calls. It is impossible to be 100% safe, and while there are
    many comprehensive books on the matter of security, the art of securing a system
    is a constantly evolving process itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，使用**系统调用接口**对系统本身也存在安全风险。如此接近内核和设备控制，为恶意软件渗透你的软件提供了极大的机会。当你的软件影响系统行为时，另一个程序可能会四处嗅探并收集有价值的数据。至少，你应该以这种方式设计你的代码，即使用户界面与关键程序（特别是系统调用）隔离良好。要达到100%的安全是不可能的，尽管有许多关于安全问题的全面书籍，但确保系统安全本身是一个不断发展的过程。
- en: 'Speaking about processes, let’s proceed to the next topic: the fundamental
    entities of a Linux system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 说到进程，让我们继续下一个主题：Linux系统的基本实体。
- en: Navigating through files, processes, and threads
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件、进程和线程之间导航
- en: 'If you made it to here – great job! We are going to cover processes and threads
    thoroughly in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029), and filesystems
    in [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047). In the meantime, we will take
    a short detour here, just to paint a better picture for you, through the definition
    of three important terms: **files**, **processes**, and **threads**. You probably
    already noticed two of these in the kernel overview earlier, so we will explain
    them briefly now in case you are not familiar with them.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这里——做得好！我们将在[*第2章*](B20833_02.xhtml#_idTextAnchor029)中彻底介绍进程和线程，在[*第3章*](B20833_03.xhtml#_idTextAnchor047)中介绍文件系统。在此期间，我们将在这里稍作偏离，只是为了通过定义三个重要术语：**文件**、**进程**和**线程**，为你描绘一幅更清晰的画面。你可能已经在前面的内核概述中注意到了其中两个，所以现在我们将简要解释它们，以防你不熟悉它们。
- en: File
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件
- en: 'In short, we require files to represent multiple kinds of resources on our
    system. The programs we write are files as well. The compiled code, for example,
    the executable binaries (`.bin`, `.exe`), and the libraries are all files (`.o`,
    `.so`, `.lib`, .`dll`, and so on). Additionally, we need them for communication
    mechanisms and for storage management. Do you know what types of files are recognizable
    on Linux? Let’s brief you on that quickly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们需要文件来表示我们系统上的多种资源。我们编写的程序也是文件。例如，编译后的代码，可执行二进制文件（`.bin`、`.exe`），以及库都是文件（`.o`、`.so`、`.lib`、`.dll`等等）。此外，我们还需要它们用于通信机制和存储管理。你知道Linux上可识别哪些类型的文件吗？让我们快速了解一下：
- en: '**Ordinary or regular files**: Almost all files storing data on the system
    are treated as regular files: text, media, code, and so on.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通或常规文件**：几乎系统上存储数据的所有文件都被视为常规文件：文本、媒体、代码等等。'
- en: '**Directories**: Used for building the hierarchical structure of the filesystem.
    Instead of storing data, they store the locations of other files.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：用于构建文件系统的层次结构。它们不存储数据，而是存储其他文件的位置。'
- en: '`/dev` directory, representing all your hardware devices.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`目录，代表你所有的硬件设备。'
- en: '**Links**: We use these to allow access to another file at a different location.
    Actually, they are substitutions of real files, and through them those files are
    accessed directly. This is different than Windows’ shortcuts. They are specific
    file types, and an application is required to support them – first to handle the
    shortcut metadata, then to point at the resource, so the file is not accessed
    in one go.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：我们使用这些来允许访问不同位置的另一个文件。实际上，它们是真实文件的替代品，通过它们可以直接访问这些文件。这与Windows的快捷方式不同。它们是特定的文件类型，需要应用程序支持它们——首先处理快捷方式元数据，然后指向资源，这样文件就不会一次性被访问。'
- en: '**Sockets**: This is the communication endpoint for a process to exchange data,
    including with other systems.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：这是进程交换数据的通信端点，包括与其他系统交换数据。'
- en: '**Named pipes**: We use named pipes to exchange bidirectional data between
    two processes currently running on the system.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**：我们使用命名管道在系统上当前运行的两个进程之间交换双向数据。'
- en: In [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047), we will play around with
    these through some practical examples. You will see the usage of every file type
    there, except sockets, which will be explained in great detail later in the book.
    What we need now is a program to run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B20833_03.xhtml#_idTextAnchor047)中，我们将通过一些实际例子来探讨这些内容。你将看到那里每个文件类型的用法，除了套接字，它将在本书后面的部分详细解释。我们现在需要的是一个可以运行的程序。
- en: Process and thread
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程和线程
- en: 'A process is an *instance of a program,* an executing instance, to be precise.
    It has its own address space and remains isolated from other processes. This means
    that each process has a range of (usually virtual) addresses that the OS assigns
    to it. Linux treats them as *tasks*. They are not observable by the general user.
    This is just how the kernel does its job. Each task is described through the `task_struct`
    entity, defined in `include/linux/sched.h`. System administrators and system programmers
    observe processes through the process table, hashed through each process’s specific
    process identifier – `pid`. This method is used for a quick lookup of a process
    – use the `ps` command in Terminal to see the process status on the system and
    then type the following command to see the specific info for a single process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是一个*程序的实例*，更确切地说，是一个正在执行的实例。它有自己的地址空间，并且与其他进程保持隔离。这意味着每个进程都有一个范围（通常是虚拟的）地址，操作系统将其分配给它。Linux将其视为*任务*。它们对普通用户是不可观察的。这正是内核工作的方式。每个任务都通过`task_struct`实体来描述，该实体定义在`include/linux/sched.h`中。系统管理员和系统程序员通过进程表来观察进程，通过每个进程特定的进程标识符——`pid`进行散列。这种方法用于快速查找进程——在终端中使用`ps`命令查看系统上的进程状态，然后输入以下命令以查看单个进程的详细信息：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, let’s start some program, called `test`, and let it run:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们启动一个名为`test`的程序，并让它运行：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can open a separate Terminal and see `test` in the list of running processes
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开一个单独的终端，查看运行进程列表中的`test`，如下所示：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And if you know the `PID` already, then just do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道了`PID`，那么只需执行以下操作：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A new process is created via a copy of the current process’s attributes and
    will belong to a *process group*. One or more groups create a *session*. Each
    session is related to a *terminal*. Both groups and sessions have *process leaders*.
    The *cloning* of attributes is used mainly for resource sharing. If two processes
    share the same virtual memory space, they are treated and managed as two *threads*
    in a single process, but they are not as heavyweight as processes. What is a thread,
    then?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过当前进程属性的副本创建一个新的进程，并将属于一个*进程组*。一个或多个组创建一个*会话*。每个会话都与一个*终端*相关联。组和会话都有*进程领导者*。属性的*克隆*主要用于资源共享。如果两个进程共享相同的虚拟内存空间，它们将被视为单个进程中的两个*线程*来处理和管理，但它们并不像进程那样重量级。那么线程是什么呢？
- en: Important note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Overall, there are four entities we care about: first is the executable file
    as it is the unit-carrier of the instructions to be executed. Second is the process
    – the worker unit executing those instructions. Third – we need these instructions
    as instruments to handle and manage system resources. And fourth is the thread
    – the smallest sequence of instructions, managed independently by the OS, and
    part of a process. Bear in mind that the implementations of processes and threads
    are different for every OS, so do your research before using them.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们有四个实体需要关注：首先是可执行文件，因为它是将要执行指令的单位载体。其次是进程——执行这些指令的工作单元。第三——我们需要这些指令作为处理和管理系统资源的工具。第四是线程——由操作系统独立管理的最小指令序列，是进程的一部分。记住，进程和线程的实现对于每个操作系统都是不同的，所以在使用它们之前请做好研究。
- en: From the kernel’s point of view, the main thread of the process is the *task
    group leader*, identified in the code as `group_leader`. All threads spawned by
    the group leader are iterable through `thread_node`. Actually, they are stored
    in a singly linked list and `thread_node` is its head. The spawned threads carry
    a pointer to the `group_leader` tool. The *process creator*’s `task_struct`objectis
    pointed by it. You probably already guessed correctly that it is the same as the
    `task_struct` of the group leader.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核的角度来看，进程的主线程是*任务组领导者*，在代码中标识为`group_leader`。所有由组领导者产生的线程都可以通过`thread_node`迭代。实际上，它们存储在一个单链表中，`thread_node`是它的头。产生的线程携带一个指向`group_leader`工具的指针。*进程创建者*的`task_struct`对象就是通过它指向的。你可能已经正确猜到了，它与组领导者的`task_struct`相同。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If a process spawns another process, for example, through `fork()`, the newly
    created processes (known as *child processes*) know about their creator through
    the `parent` pointer. They are also aware of their siblings through the `sibling`
    pointer, which is a list node to some other child process of the parent. Each
    parent knows about its children through `children` – a pointer to the list head,
    storing the children and providing access to them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程通过`fork()`等创建另一个进程，那么新创建的进程（称为*子进程*）通过`parent`指针了解它们的创建者。它们也通过`sibling`指针了解它们的兄弟姐妹，这是一个指向父进程其他子进程的列表节点。每个父进程通过`children`了解其子进程——这是一个指向列表头部的指针，存储子进程并提供对它们的访问。
- en: 'As we can see in the following figure, the threads do not define any other
    data structures:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，线程不定义任何其他数据结构：
- en: '![Figure 1.3 – Structures of processes and threads through task_structs](img/Figure_1.3_B20833.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 通过task_structs查看进程和线程的结构](img/Figure_1.3_B20833.jpg)'
- en: Figure 1.3 – Structures of processes and threads through task_structs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 通过task_structs查看进程和线程的结构
- en: We’ve mentioned `fork()`already a couple of times, but what is it? Well, put
    simply, it is a system function that creates a process copy of the process caller.
    It provides the parent with the new process’s ID and initiates the execution of
    the child. We are going to provide some code examples in the next chapter, so
    you could take a look there for more details. There’s something important we should
    mention now, as we are on the topic of Linux environments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了`fork()`几次，但它是什么？简单地说，它是一个创建进程调用者进程副本的系统函数。它向父进程提供新进程的ID并启动子进程的执行。我们将在下一章提供一些代码示例，你可以查看那里以获取更多详细信息。现在，由于我们正在讨论Linux环境，我们应该提到一些重要的事情。
- en: 'Behind the scenes, `fork()` is replaced with `clone()`. Different options are
    provided through `flags`, but if all are set to zero, `clone()` behaves like `fork()`.
    We advise you to read more here: [https://man7.org/linux/man-pages/man2/clone.2.xhtml](https://man7.org/linux/man-pages/man2/clone.2.xhtml).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`fork()`被替换为`clone()`。通过`flags`提供了不同的选项，但如果所有选项都设置为零，`clone()`的行为就像`fork()`。我们建议你在这里了解更多：[https://man7.org/linux/man-pages/man2/clone.2.xhtml](https://man7.org/linux/man-pages/man2/clone.2.xhtml)。
- en: 'You’re probably asking yourself why this implementation is preferable. Think
    about it this way: when the kernel does a switch between the processes, it checks
    the address of the current process in the virtual memory, the *page directory*
    to be exact. If it is the same as the newly executed process, then they share
    the same address space. Then, the switch is only a simple pointer jump instruction,
    usually to the entry point of the program. This means a faster rescheduling is
    to be expected. Be careful – the processes might share the same address space,
    but not the same program stack. `clone()` takes care of creating a different stack
    for each process.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在问自己为什么这种实现更可取。可以这样想：当内核在进程之间进行切换时，它会检查虚拟内存中当前进程的地址，确切地说是*页目录*。如果它与新执行的进程相同，那么它们共享相同的地址空间。然后，切换只是一个简单的指针跳转指令，通常指向程序的入口点。这意味着可以期待更快的重新调度。小心——进程可能共享相同的地址空间，但不是相同的程序栈。`clone()`负责为每个进程创建不同的栈。
- en: Now that the process is created, we must take a look at its *running mode*.
    Note that this is not the same as the *process state*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进程已经创建，我们必须查看其*运行模式*。请注意，这与*进程状态*不同。
- en: Types of processes based on their running mode
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于运行模式的进程类型
- en: 'Some processes require user interaction to be initiated or interacted with.
    They are known as *foreground processes*. But as you’ve probably figured out,
    there are some processes that run independently of our, or any other user’s, activity.
    Processes of this kind are known as *background processes*. Unless instructed
    otherwise, the terminal inputs as program execution calls or user commands are
    treated as foreground processes by default. To run a process in the background,
    simply place `&` at the end of the command line that you use to start the process.
    For example, let’s call the already known `test`, and after it finishes, we see
    the following in Terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进程需要用户交互来启动或与之交互。它们被称为*前台进程*。但正如您可能已经发现的，还有一些进程独立于我们的活动或任何其他用户的操作运行。这类进程被称为*后台进程*。除非另有说明，否则默认将终端输入作为程序执行调用或用户命令处理为前台进程。要在一个后台运行进程，只需在您用于启动进程的命令行末尾放置`&`即可。例如，让我们调用已知的`test`，完成后，我们在终端看到以下内容：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can easily stop it using its `pid` when calling the `kill` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其`pid`轻松地停止它，当调用`kill`命令时：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, killing a process and letting it terminate by itself are two
    different things, and killing the process could lead to unpredictable system behavior
    or the inability to access some resource, such as a file or a socket left unclosed.
    This topic will be revisited later in the book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，终止一个进程并让它自行终止是两回事，终止进程可能会导致不可预测的系统行为或无法访问某些资源，例如未关闭的文件或套接字。这个话题将在本书的后面再次讨论。
- en: Other processes run unattended. They are known as *daemons* and run constantly
    in the background. They are expected to be always available. Daemons are usually
    started through the system’s startup scripts and run until it’s shut down. They
    usually provide system services and multiple users rely on them. Therefore, the
    daemons on startup are usually initiated by the user with ID 0 (usually `root`)
    and might run with `root` privileges.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他进程是无人照料的。它们被称为*守护进程*，并且始终在后台持续运行。它们预期始终可用。守护进程通常通过系统的启动脚本启动，并在关闭之前运行。它们通常提供系统服务，并且多个用户依赖于它们。因此，启动时的守护进程通常由ID为0的用户（通常是`root`）启动，并且可能以`root`权限运行。
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The user with the highest privileges on a Linux system is known as the root
    user, or simply root. This privilege level allows the performing of security-related
    tasks. This role has a direct impact on the system’s integrity, therefore all
    other users must be set with the least-possible privilege level until a higher
    one is required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，拥有最高权限的用户被称为root用户，或简单地称为root。这个权限级别允许执行与安全相关的任务。这个角色对系统的完整性有直接影响，因此，直到需要更高的权限级别之前，所有其他用户都必须设置尽可能低的权限级别。
- en: 'A *zombie process* is a process that has been terminated, but is still recognized
    through its `pid`. It has no address space. Zombie processes continue to exist
    for as long as their parent processes run. This means that until we exit the main
    process, shut down the system, or restart it, the zombie process will still appear
    as `<defunct>` when listed by `ps`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*僵尸进程*是一个已经终止但仍然通过其`pid`被识别的进程。它没有地址空间。僵尸进程会一直存在，直到其父进程运行。这意味着，直到我们退出主进程、关闭系统或重启系统，僵尸进程在`ps`列表中仍然会显示为`<defunct>`：'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see zombie processes through `top` as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过`top`查看僵尸进程：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Getting back to the discussion on background processes, there is another way
    to execute specific procedures without explicitly starting background processes.
    Even better – we can manage such processes running on system startup or on different
    system events. Let’s look at this in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回到后台进程的讨论，还有另一种方法可以执行特定的程序，而无需显式启动后台进程。甚至更好——我们可以管理在系统启动或不同系统事件上运行的此类进程。让我们在下一节中看看这个。
- en: Running services with init and systemd
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用init和systemd运行服务
- en: 'Let’s use this opportunity to discuss the `init` and the `systemd` process
    daemons. There are others as well, but we’ve decided to retain our focus on these
    two. The first one is the initial process, executed on a Linux system by the kernel,
    and its `pid` is always `1`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这个机会来讨论`init`和`systemd`进程守护进程。还有其他一些，但我们已经决定保持对这两个的关注。第一个是在Linux系统上由内核执行的初始进程，其`pid`始终为`1`：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is known as the parent of all processes on the system as it is used to initialize,
    manage, and track other services and daemons. The first `init` daemon for Linux
    is called `Init` and it defines six system states. All system services are mapped
    to those states, respectively. Its script is used to start processes in a pre-defined
    order, which is occasionally used by system programmers. One possible reason to
    use this is to reduce the startup duration of the system. To create a service
    or edit the script, you could modify `/etc/init.d`. As this is a directory, we
    could list it with the `ls` command and see all the services that could be run
    through `init`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为系统上所有进程的父进程，因为它用于初始化、管理和跟踪其他服务和守护进程。Linux 的第一个 `init` 守护进程被称为 `Init`，它定义了六个系统状态。所有系统服务都映射到这些状态。它的脚本用于以预定义的顺序启动进程，这偶尔会被系统程序员使用。使用它的一个可能的原因是减少系统的启动时间。要创建服务或编辑脚本，你可以修改
    `/etc/init.d`。由于这是一个目录，我们可以使用 `ls` 命令列出它，并查看所有可以通过 `init` 运行的服务。
- en: 'This is what we have on our machine:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们机器上的内容：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each of these scripts follows the same code template for its execution and
    maintenance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些脚本都遵循相同的代码模板进行执行和维护：
- en: '![Figure 1.4 – init.d script, representing the possible service actions](img/Figure_1.4_B20833.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – init.d 脚本，表示可能的服务操作](img/Figure_1.4_B20833.jpg)'
- en: Figure 1.4 – init.d script, representing the possible service actions
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – init.d 脚本，表示可能的服务操作
- en: 'You can generate the same template yourself and read more about the `init`
    script source code through the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己生成相同的模板，并通过以下命令了解更多关于 `init` 脚本源代码的信息：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can list the status of the available services through the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令列出可用服务的状态：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could stop the firewall service – `ufw`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以停止防火墙服务 – `ufw`：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s check its status:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查其状态：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s start it again and check its status once more:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次启动它并再次检查其状态：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a similar fashion, you could create your own service and use the `service`
    command to start it. An important remark is that `init` is considered an outdated
    approach on modern, full-scale Linux systems. Still, it can be found on every
    Unix-based OS, unlike **systemd**, so system programmers would anticipate its
    use as a common interface to services. Therefore, we use it more as a simple example
    and an explanation for where services are coming from. If we want to use the latest
    approach, we must turn to **systemd**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，你可以创建自己的服务并使用 `service` 命令来启动它。一个重要的说明是，`init` 在现代的完整规模的 Linux 系统上被认为是一种过时的方法。然而，它可以在每个基于
    Unix 的操作系统上找到，与 **systemd** 不同，因此系统程序员会预期它作为服务的一个常见接口。因此，我们更多地将其用作一个简单的示例和解释服务从何而来。如果我们想使用最新的方法，我们必须转向
    **systemd**。
- en: '`.service` file under the `/lib/systemd/system` or `/etc/systemd/system` directory.
    The services found in `/lib` are definitions for system startup services and those
    in `/etc` are for the services that start during system runtime. Let’s list them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`/lib/systemd/system` 或 `/etc/systemd/system` 目录下的 `.service` 文件。在 `/lib` 中找到的服务是系统启动服务的定义，而在
    `/etc` 中的是在系统运行期间启动的服务。让我们列出它们：'
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before we continue with an example, let’s put one disclaimer here – `systemd`
    has a much more complex interface than `init`. We encourage you to spend time
    examining it separately as we cannot summarize it in short here. But if you list
    your `systemd` directories, you will probably observe many types of files. In
    the context of the daemon, they are known as `units`. Each of them provides a
    different interface as they each relate to a certain entity managed by `systemd`.
    The script inside each file describes what options are set and what the given
    service does. The `units` names are eloquent. `.timer` is for timer management,
    `.service` is for how a given service will be initiated and what it depends on,
    `.path` describes the path-based activation of a given service, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续示例之前，让我们在这里提出一个免责声明 – `systemd` 的接口比 `init` 复杂得多。我们鼓励你花时间单独检查它，因为我们无法在这里简要总结。但如果你列出你的
    `systemd` 目录，你可能会观察到许多类型的文件。在守护进程的上下文中，它们被称为 `units`。每个都提供了不同的接口，因为它们都与 `systemd`
    管理的某个实体相关。每个文件中的脚本描述了设置了哪些选项以及给定服务做什么。`units` 的名称是优雅的。`.timer` 用于定时管理，`.service`
    用于给定服务的启动方式和依赖关系，`.path` 描述了基于路径的给定服务的激活，等等。
- en: 'Let’s make a simple `systemd` service that will have the purpose of monitoring
    whether a given file is being modified. One example is monitoring some configuration:
    we wouldn’t want to limit its permissions for file update, but we’d still like
    to know whether someone has changed it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 `systemd` 服务，其目的是监控一个给定的文件是否被修改。一个例子是监控一些配置：我们不想限制文件更新的权限，但我们仍然想知道是否有人更改了它。
- en: 'First, let’s create some dummy file through a simple text editor. Let’s imagine
    it’s a real configuration. Printing it out gives the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一个简单的文本编辑器创建一些虚拟文件。让我们想象它是一个真实的配置。打印出来如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s prepare a script that describes the procedure we require to be executed
    when the file is changed. Again, just for the purposes of this example, let’s
    create it through a simple text editor – it will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备一个脚本，描述当文件更改时需要执行的程序。再次强调，仅为了这个示例，让我们通过一个简单的文本编辑器创建它——它看起来像这样：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the script is called, there will be a message that the file has changed.
    Of course, you could put any program here. Let’s call it `sniff_printer`, because
    we are sniffing for a file change through the service, and we will print some
    data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本被调用时，将会有一个消息表明文件已更改。当然，你可以在这里放置任何程序。让我们称它为 `sniff_printer`，因为我们通过服务嗅探文件更改，并将打印一些数据。
- en: 'How does this happen then? First, we define our new service through the required
    `unit` – `myservice_test.service` – implementing the following script:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是怎么发生的呢？首先，我们通过所需的 `unit` 定义我们的新服务——`myservice_test.service`——实现以下脚本：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Second, we describe the file path we’re monitoring through another `unit` called
    `myservice_test.path`, implemented via the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们描述我们通过另一个名为 `myservice_test.path` 的 `unit` 监控的文件路径，该 `unit` 通过以下代码实现：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Combining all these pieces together, we get a service that will print out a
    simple message. It will be triggered whenever the provided file is updated. Let’s
    see how it goes. As we are adding a new file to the service directory, we must
    execute a reload:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些部分组合在一起，我们得到一个会打印简单消息的服务。它将在提供的文件更新时被触发。让我们看看效果如何。当我们向服务目录添加新文件时，我们必须执行一个重新加载：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s enable and start the service:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启用并启动服务：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to update the file through some text editor, such as the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过一些文本编辑器，如以下内容，更新文件：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to see the effect we’ve triggered, we have to go through the service
    status:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们触发的影响，我们必须查看服务状态：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can validate that the service has been triggered as our message is present:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过我们的消息存在来验证服务已被触发：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also see the code that was executed and its successful status:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了执行过的代码及其成功状态：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But the process is no longer active as the service `unit` is of type `oneshot`,
    therefore only another file update will retrigger it. We believe this example
    offers a simple explanation of how a daemon could be created and started during
    system runtime. Feel free to experiment yourself and try different unit types
    or options.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于服务 `unit` 的类型是 `oneshot`，因此进程不再活跃，只有另一个文件更新才能重新触发它。我们相信这个例子提供了一个简单的解释，说明如何在系统运行时创建和启动守护程序。请随意实验，尝试不同的
    `unit` 类型或选项。
- en: The process daemon and the startup procedures are a large area of expertise
    in system administration, programming, monitoring, and obtaining execution flow
    information. These topics as well as that of the next section deserve books of
    their own.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 进程守护程序和启动程序是系统管理、编程、监控和获取执行流程信息的一个大型专业领域。这些主题以及下一节的内容都值得有自己的一本书。
- en: Portable Operating System Interface (POSIX)
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植操作系统接口 (POSIX)
- en: 'The **POSIX** standard has the main task of maintaining compatibility between
    different OSs. Therefore, POSIX is frequently used by both standard application
    software developers and system programmers. Nowadays, it can be found not only
    on Unix-like OSs, but in Windows environments as well – for example, **Cygwin**,
    **MinGW**, and **Windows Subsystem for Linux** (**WSL**). POSIX defines both the
    system- and the user-level APIs with one remark: using POSIX, the programmer doesn’t
    need to distinguish between system calls and library functions.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**POSIX** 标准的主要任务是维护不同操作系统之间的兼容性。因此，POSIX 经常被标准应用程序软件开发者和系统程序员使用。如今，它不仅可以在类
    Unix 操作系统上找到，还可以在 Windows 环境中找到——例如，**Cygwin**、**MinGW** 和 **Windows Subsystem
    for Linux**（**WSL**）。POSIX 定义了系统级和用户级 API，有一点需要注意：使用 POSIX，程序员不需要区分系统调用和库函数。'
- en: 'The POSIX API is frequently used in the C programming language. Thus, it is
    compilable with C++. Additional functions are provided to the **system call interface**
    in a few important areas of system programming: **file operations**, **memory
    management**, **process and thread control**, **networking and communications**,
    and **regular expressions** – as you can see, it pretty much covers everything
    that the already existing system calls do. Just don’t get confused and think that
    this is always the case.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX API经常在C编程语言中使用。因此，它可以与C++编译。在系统编程的一些重要领域，为**系统调用接口**提供了额外的功能：**文件操作**、**内存管理**、**进程和线程控制**、**网络和通信**以及**正则表达式**——正如你所见，它几乎涵盖了现有系统调用所做的一切。只是不要混淆，认为这总是这种情况。
- en: As with every standard, POSIX has multiple versions, and you must be aware of
    which one is present in your system. It also could be a part of some environment
    subsystem, such as the **Microsoft POSIX subsystem** for Windows. This is a key
    remark as it is possible that the environment itself doesn’t expose the entire
    interface to you. One reason could be the security assessment of the system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个标准一样，POSIX也有多个版本，你必须了解你系统中存在的是哪一个。它也可能是某些环境子系统的一部分，例如Windows的**Microsoft
    POSIX子系统**。这是一个关键点，因为环境本身可能不会向你完全暴露整个接口。一个可能的原因是系统的安全评估。
- en: With the evolution of POSIX, rules for code quality have been established. Some
    of them are related to **multithreaded memory access**, **synchronization mechanisms**
    and **concurrent executions**, **security** and **access restrictions**, and **type
    safety**. A famous concept in POSIX’s software requirements is *write once,* *adopt
    everywhere*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着POSIX的发展，代码质量规则已经建立。其中一些与**多线程内存访问**、**同步机制**和**并发执行**、**安全**和**访问限制**以及**类型安全**有关。POSIX软件要求中的一个著名概念是*一次编写，到处采用*。
- en: 'The standard defines and targets four main areas of its application, called
    volumes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该标准定义并针对其应用的四个主要领域，称为卷：
- en: '**Base definitions**: Main definitions for the specification: syntax, concepts,
    terms, and service operations'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本定义**：规范的主要定义：语法、概念、术语和服务操作'
- en: '**System interfaces**: Interface descriptions and definitions’ availability'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统接口**：接口描述和定义的可用性'
- en: '**Utilities**: Shell, command, and utility descriptions'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用工具**：Shell、命令和实用工具描述'
- en: '**Rationale**: Versioning information and historical data'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理由**：版本信息和历史数据'
- en: With all that said, in this book our focus is mainly on POSIX as a different
    approach to system calls. In the following chapters, we will see the benefit of
    the general pattern for using objects such as message queues, semaphores, shared
    memory, or threads. A significant improvement is the simplicity of the function
    calls and their naming conventions. For example, `shm_open()`, `mq_open()`, and
    `sem_open()` are used to create and open a shared memory object, a message queue,
    and a semaphore, respectively. Their similarity is obvious. Similar ideas in POSIX
    are welcomed by system programmers. The API is public, too, and there are substantial
    community contributions. Additionally, POSIX provides an interface to objects
    such as the mutex, which is not trivially found and used on Unix. However, in
    later chapters, we will advise readers to focus more on the C++20 features and
    for good reason, so bear with us.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，在这本书中，我们的主要关注点是POSIX作为一种不同的系统调用方法。在接下来的章节中，我们将看到使用对象如消息队列、信号量、共享内存或线程的一般模式的益处。一个显著改进是函数调用及其命名约定的简单性。例如，`shm_open()`、`mq_open()`和`sem_open()`分别用于创建和打开共享内存对象、消息队列和信号量。它们的相似性显而易见。POSIX中的类似思想受到系统程序员的欢迎。API也是公开的，并且有大量的社区贡献。此外，POSIX还为诸如互斥锁这样的对象提供了接口，这在Unix上并不容易找到和使用。然而，在后面的章节中，我们将建议读者更多地关注C++20的特性，这是有充分理由的，所以请耐心等待。
- en: Using POSIX allows software engineers to generalize their OS-related code and
    declare it as *not-OS-specific*. This allows easier and faster reintegration of
    the software, thus reducing the time to market. System programmers can also easily
    switch from one system to another while still writing the same type of code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用POSIX允许软件工程师将他们的操作系统相关代码进行泛化，并声明为*非操作系统特定*。这使得软件的重新集成更加容易和快速，从而缩短了上市时间。系统程序员也可以在编写相同类型代码的同时轻松地在不同的系统之间切换。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the definitions of basic concepts related to
    OSs. You have learned about Linux’s main kernel structure and its expectations
    of software design. Real-time OSs were briefly introduced, and we covered the
    definitions of system calls, the system call interface, and POSIX as well. We’ve
    also laid the foundations of multiprocessing and multithreading. In the next chapter,
    we will discuss the process as the main resource user and manager. We will start
    with some C++20 code. Through this, you will learn about the Linux’s process memory
    layout, the OS’s process-scheduling mechanism, and how multiprocessing operates
    plus the challenges it brings. You will also learn some interesting facts about
    atomic operations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与操作系统相关的基本概念的定义。你学习了Linux的主要内核结构和其对软件设计的期望。实时操作系统被简要介绍，我们还涵盖了系统调用、系统调用接口以及POSIX的定义。我们还为多进程和多线程奠定了基础。在下一章中，我们将讨论进程作为主要资源的使用者和管理者。我们将从一些C++20代码开始。通过这种方式，你将了解Linux的进程内存布局、操作系统的进程调度机制以及多进程的运作方式及其带来的挑战。你还将了解一些关于原子操作的有趣事实。
