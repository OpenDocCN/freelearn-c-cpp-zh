- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Linux Systems and the POSIX Standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is about **Linux** and how we use **C++** in **Linux** environments
    to manage critical resources. The **C++** language is continuously improving,
    as you’ll explore in the following chapters. Before we go there, we’d like to
    spend some time in this chapter developing a fundamental understanding of **operating
    systems** (**OSs**). You are going to learn more about the origins of some specific
    techniques, the **system call interface** and the **Portable Operating System**
    **Interface** (**POSIX**).
  prefs: []
  type: TYPE_NORMAL
- en: Your choice of OS matters. Although OSs were created with a single purpose,
    nowadays their roles differ. Much is expected of them as well. Each OS has its
    own strengths and weaknesses, which we are going to discuss briefly. **Linux**
    is in widespread use across multiple technological areas and has a huge community
    worldwide, so it is perfect for our practical purposes. In our experience, programming
    in Linux or other *Unix-based OS* environments is rather common. Wherever your
    expertise resides – from **Internet of Things** (**IoT**) devices and embedded
    software development to mobile devices, supercomputing, or spacecraft – there
    is a good chance that you will cross paths with a Linux distribution at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Use this chapter as an introduction to system programming. Even if you are already
    familiar with the topic, take your time to revisit the terms and details. Most
    of them are covered by college courses or are taken as common knowledge, but it
    is nonetheless important for us to explain some of the fundamentals here to make
    sure we will be on the same page in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the concept of OSs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the system call interface and system programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through files, processes, and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running services with `init` and `systemd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable Operating System** **Interface** (**POSIX**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get familiar with the programming environment, the reader must
    prepare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++20 (for example,
    Linux Mint 21)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with the concept of OSs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is an OS? You could probably provide at least one answer, but let’s
    discuss this briefly as it is important to understand what our computer system
    truly is and how we manipulate it. Although you might be familiar with most of
    the information provided here, we are using this chapter to align with you on
    the matter of OSs and their uses. Some might say that the OS was created to make
    the hardware work as a whole. Others will argue that it is an aggregation of programs,
    dedicated to managing the system resources overall. It is crucial to utilize these
    resources, such as CPU and memory, efficiently. There is also the concept of the
    OS as an abstraction and an extension of the hardware. Ultimately, we can safely
    say that the modern OS is a complex entity. It also has additional functions,
    such as the collection of statistics, multimedia handling, system safety and security,
    overall stability, reliable error handling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While the OS is obliged to execute all those tasks, it is still necessary for
    the programmer to pay attention to the system specifics and requirements. Working
    from a higher level of abstraction, through virtual machines, for example, does
    not mean discarding the need to understand how our code impacts the system’s behavior.
    And programmers, who are closer to the OS layers, are required to manage the system’s
    resources efficiently as well. This is one of the reasons that OSs provide **application
    programming interfaces**, or **APIs**. It is valuable expertise to know how to
    use such APIs and what kind of benefits they provide.
  prefs: []
  type: TYPE_NORMAL
- en: We believe that the ability to work closely with the OS is a skill that is not
    so common. Knowledge of how the OS and the computer architecture will behave is
    at the expert level of software engineering. We will discuss some types of OSs
    just to give you a broad picture, but the focus of the book is specifically on
    **POSIX-compliant** OSs. That said, let’s get familiar with one of our main toolsets.
  prefs: []
  type: TYPE_NORMAL
- en: Types of OSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we do some quick research online, we will find many types of OSs, and the
    type definition will strictly be based on the criterion searched for. One example
    is the purpose of the OS: is it a general-purpose one, such as macOS and Windows,
    or more specific, such as **Embedded Linux** and **FreeRTOS**? Another example
    is OSs for PCs versus those for mobile devices. Likewise, the licensing could
    describe the OSs as open source, enterprise, or enterprise open source. Based
    on the number of active users at a time, Windows could be considered a *single-user*
    OS, as it constructs just one **Win32 API** for the current *user session*. On
    the other hand, Unix-like OSs are considered *multi-user*, as multiple users can
    work simultaneously on the system, where each *shell* or a *Terminal* instance
    is considered a separate user session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the system’s applications and their constraints are fundamental. Therefore,
    a key distinction to be aware of is the level of restrictions on the system’s
    behavior. The **general-purpose operating systems** (**GPOSs**) started initially
    as *time-sharing* OSs. Historically, there is another type of OS, originating
    from the same period as the time-sharing ones – the **real-time operating systems**
    (**RTOSs**). It is expected that system programmers understand the specifics of
    **GPOSs** and **RTOSs**. In the following chapters, we will discuss how properties
    such as task priorities, timer values, peripheral speeds, interrupt and signal
    handlers, multithreading, and dynamic memory allocation can lead to changes in
    system behavior. Sometimes these are unpredictable. That’s why we recognize two
    types of **RTOSs**: hard and soft **RTOSs**. Hard **RTOSs** are usually strictly
    related to a given piece of hardware. The system developer is familiar with the
    end device requirements. The task execution times can be preliminary evaluated
    and programmed, although the device’s input is still treated as asynchronous and
    unpredictable. Therefore, our focus in this book remains on **GPOS** programming
    with a bit of soft **RTOS** functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set the stage like this: the user receives system resources in a cyclic
    manner so often that it creates the impression that the user is the only one relying
    on those resources. The user’s work must not be disrupted, and quick response
    times are to be expected from an OS; theoretically, the smaller the procedures,
    the shorter the response times. We will discuss this further in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029)
    as it is not completely true.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The user is the main *driver* of the system’s functionality with a **GPOS**.
    The main job of the OS is maintaining active dialog with the users and the high
    availability of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Here, each task and each request to the OS must be handled quickly within a
    strict time interval. The **RTOS** expects user input only during exceptional
    situations, errors, and unpredicted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously working devices and additional peripheral electronics are the
    main *drivers* of the system’s functionality in an RTOS. The main job of the OS
    remains process management and task scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, there are two types of **RTOS**: *hard RTOS* and *soft RTOS*. In
    a hard **RTOS**, real-time tasks are guaranteed to be executed on time. System
    reaction deadlines are usually preliminarily defined, and the *mission-critical*
    data is stored in ROM, so it cannot be updated at runtime. Functionalities such
    as virtual memory are often removed. Some modern CPU cores provide the so-called
    **tightly coupled memory** (**TCM**), into which the frequently used data and
    code lines are loaded from the **non-volatile memory** (**NVM**) on system startup.
    The system’s behavior is *scripted* *a priori*. The role of these OSs is related
    to machine control, where the user’s input is forbidden.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A soft **RTOS** provides critical tasks with the highest priority until completion
    and without interruptions. Still, real-time tasks are expected to be completed
    in a timely manner and should not wait endlessly. It is obvious that this type
    of OS cannot be utilized for mission-critical tasks: factory machines robots,
    vehicles, and so on. But it can be used to control the overall system behavior,
    so this type of OS is found in multimedia and research projects, artificial intelligence,
    computer graphics, virtual reality devices, and more. As these **RTOSs** do not
    clash with the **GPOS**s, they can be integrated with them. Their functions can
    be found in some Linux distributions as well. An interesting realization of this
    is **QNX**.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux in short
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few misconceptions here, so let’s settle them briefly. Linux is
    a *Unix-like OS*, meaning it provides similar (and occasionally the same) interfaces
    as Unix – its functions, especially APIs, are designed to match the ones from
    Unix. But it is not a *Unix-based* OS. Their functions are not implemented in
    the same way. A similar misconception exists in understandings of the FreeBSD-macOS
    relationship. Although both share a significant portion of code, their approach
    is completely different, including the way their kernels are structured.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to bear these facts in mind as not all functions we are going
    to use in this book exist or are reachable on all Unix-like OSs. We are focusing
    on Linux, and our examples will work as long as the respective technical requirements
    for each chapter are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few reasons for this decision. First, Linux is open-sourced, and
    you can easily check its kernel code: [https://github.com/torvalds/linux](https://github.com/torvalds/linux).
    You should be able to read it easily as it is written in C. Even though C is not
    an object-oriented language, the Linux kernel follows many **object-oriented programming**
    (**OOP**) paradigms. The OS itself consists of many independent design blocks,
    called *modules*. You could easily configure, integrate, and apply them specifically
    for your system’s needs. Linux gives us the ability to work with real-time systems
    (described later in the chapter) and do parallel code executions (discussed in
    [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086)). In short – Linux is easily adaptable,
    expandable, and configurable; we could easily use this to our advantage. But *where*,
    exactly?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we could develop applications that are close to the OS, or we could even
    produce some modules ourselves, which can be loaded or unloaded at runtime. Such
    an example is a filesystem or device driver. We are going to revisit this topic
    in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029), when deep diving into the
    *process* entity. For now, let’s say that the modules pretty much look like an
    OOP design: they are constructible and destructible; sometimes, based on the kernel’s
    needs, common code could be generalized into one module, and these modules have
    hierarchical dependencies. Nevertheless, the Linux kernel is considered *monolithic*;
    for example, it has complex functionality, but the entire OS runs in *kernel space*.
    In contrast, there are *micro-kernels* (QNX, MINIX, or L4), which constitute the
    bare minimum of a running OS. Additional functionality in this case is provided
    through modules that work outside the kernel itself. This leads to a slightly
    chaotic but overall clear picture of the possibilities of the Linux kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 1**.1* illustrates an example of a Linux kernel. Based on your needs,
    the system architecture could look different, but you can observe the three main
    layers we expect to see in any given Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: These are the *user space* (running processes and their threads), the *kernel
    space* (the running kernel itself, usually a process of its own), and the *computer*
    – this could be any kind of computing device, such as a PC, tablet, smartphone,
    supercomputer, IoT device, and so on. One by one, all the terms observed in the
    diagram will fall into place as we explain them in the following chapters, so
    don’t worry if you are not familiar with all of them right now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Overview of the Linux kernel and the neighboring layers](img/Figure_1.1_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Overview of the Linux kernel and the neighboring layers
  prefs: []
  type: TYPE_NORMAL
- en: Some interdependencies in the preceding diagram have probably made an impression
    on you already. For example, see how the *device drivers*, the *respective devices*,
    and the *interrupts* are related. The device drivers are a generalization of *character
    device drivers*, *block device drivers*, and *network device drivers.* Note how
    the interrupts are related to the *scheduling* of the tasks. This is a trivial
    but fundamental mechanism, used heavily in the implementation of drivers. It is
    an initial *communication* *and* *control* mechanism of the OS and the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just one example: let’s say you want to restore and read a file from the disk
    (`read()` call will be executed under the hood, which is then translated to a
    *filesystem* operation. The filesystem calls the device driver to find and retrieve
    the content behind the given file descriptor, which is then related to an address
    known by the filesystem. This will be discussed further in [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047).
    The required device (**NVM**) starts to search for the piece of data – a file.
    Until the operation is finished, if the caller process is a single-threaded process
    and has nothing else to do, it will be stopped. Another process will start to
    work until the device *finds* and *returns a pointer* to the file’s address. Then
    an interrupt is triggered, and this helps the OS to invoke the *scheduler*. Our
    initial process will be started again using the newly loaded data, and the second
    process will now be stopped.'
  prefs: []
  type: TYPE_NORMAL
- en: This task example demonstrates how you can impact the system’s behavior with
    just a small, insignificant operation – and this is one you will have learned
    to code in your first programming classes. In most cases, nothing bad will happen,
    of course. Many processes will be rescheduled all the time during the lifespan
    of your system. It is the OS’s job to make this happen without disruptions.
  prefs: []
  type: TYPE_NORMAL
- en: But the interrupt is a heavy operation that could lead to needless memory accesses
    and useless application state switches. We will discuss this in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029).
    For now, just think about what happens if the system is overloaded – the CPU is
    at 99% usage, or the disk has received many requests and cannot handle them in
    a timely manner. And what if that system was part of an airplane’s embedded devices?
    Of course, this is highly unlikely in reality, as airplanes have strict technical
    requirements and high-quality standards to meet. But just for the sake of argument,
    consider how you might prevent a similar situation from happening, or how you
    would guarantee the code’s successful execution in any user scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the system call interface and system programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, the example that we just saw is simplified but gives us some idea
    about the work that the OS needs to do – in essence, it is responsible for managing
    and providing resources, but at the same time remains available for other processes’
    requests. This is a messy job on modern OSs. Rarely can we do anything about it.
    So, to have better control and predictability of system behavior, programmers
    might directly use the OS’s API, called the **system** **call interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The NVM data request is a procedure that benefits from the `glibc` and are not
    invoked directly.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the system calls define the programmer’s interface through which
    all kernel services are made available. The OS can be considered as more of a
    mediator between the kernel service and the hardware. Unless you like to play
    with hardware pins and low-level platform instructions, or you are a module architect
    yourself, you should bravely leave the details to the OS. It is the OS’s responsibility
    to handle the specific computer physical interface operations. It is the application’s
    responsibility to use the correct system calls. And it is the software engineer’s
    task to be aware of their impact on the system’s overall behavior. Bear in mind
    that using system calls comes with a price.
  prefs: []
  type: TYPE_NORMAL
- en: 'As observed in the example, the OS will do a lot while retrieving a file. And
    even more will be done when memory is allocated dynamically, or a single memory
    chunk is accessed by multiple threads. We will discuss this further in the following
    chapters, and will emphasize using systems calls sparingly, with awareness, whether
    voluntarily or involuntarily, wherever possible. Simply said, system calls are
    not trivial function calls as they are not executed in user space. Instead of
    going to the next procedure in your program’s stack, the system call triggers
    a mode switch, which leads to a jump to a routine in the kernel’s memory stack.
    Reading from a file can be visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – System call interface representation of reading from a file](img/Figure_1.2_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – System call interface representation of reading from a file
  prefs: []
  type: TYPE_NORMAL
- en: 'When should we use system calls then? Put simply, when we want to be very precise
    about some OS tasks, often related to **device management**, **file management**,
    **process control**, or **communication infrastructure**. We are going to present
    many examples of these roles in the later chapters, but in brief, you are welcome
    to read more and get familiar yourself with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important links
  prefs: []
  type: TYPE_NORMAL
- en: 'The right place to start is the **Linux man-pages project**, linked here: [https://www.kernel.org/doc/man-pages/](https://www.kernel.org/doc/man-pages/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief list of the useful system calls can be found at the following link:
    [https://man7.org/linux/man-pages/man2/syscalls.2.xhtml](https://man7.org/linux/man-pages/man2/syscalls.2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: We strongly encourage you to do more research on system calls used in your own
    projects. Are there any, and what kind of job do they do? Are there any alternatives
    in your implementations?
  prefs: []
  type: TYPE_NORMAL
- en: You have probably already guessed that using the **system call interface** involves
    a security risk for the system, too. Being that close to the kernel and the device
    control provides a great opportunity for malicious software to infiltrate your
    software. While your software is impacting system behavior, another program might
    sniff around and gather valuable data. The least you could do is design your code
    in such a way that the user’s interface is well isolated from the crucial procedures,
    especially system calls. It is impossible to be 100% safe, and while there are
    many comprehensive books on the matter of security, the art of securing a system
    is a constantly evolving process itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about processes, let’s proceed to the next topic: the fundamental
    entities of a Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through files, processes, and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you made it to here – great job! We are going to cover processes and threads
    thoroughly in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029), and filesystems
    in [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047). In the meantime, we will take
    a short detour here, just to paint a better picture for you, through the definition
    of three important terms: **files**, **processes**, and **threads**. You probably
    already noticed two of these in the kernel overview earlier, so we will explain
    them briefly now in case you are not familiar with them.'
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In short, we require files to represent multiple kinds of resources on our
    system. The programs we write are files as well. The compiled code, for example,
    the executable binaries (`.bin`, `.exe`), and the libraries are all files (`.o`,
    `.so`, `.lib`, .`dll`, and so on). Additionally, we need them for communication
    mechanisms and for storage management. Do you know what types of files are recognizable
    on Linux? Let’s brief you on that quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordinary or regular files**: Almost all files storing data on the system
    are treated as regular files: text, media, code, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: Used for building the hierarchical structure of the filesystem.
    Instead of storing data, they store the locations of other files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev` directory, representing all your hardware devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Links**: We use these to allow access to another file at a different location.
    Actually, they are substitutions of real files, and through them those files are
    accessed directly. This is different than Windows’ shortcuts. They are specific
    file types, and an application is required to support them – first to handle the
    shortcut metadata, then to point at the resource, so the file is not accessed
    in one go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sockets**: This is the communication endpoint for a process to exchange data,
    including with other systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named pipes**: We use named pipes to exchange bidirectional data between
    two processes currently running on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047), we will play around with
    these through some practical examples. You will see the usage of every file type
    there, except sockets, which will be explained in great detail later in the book.
    What we need now is a program to run.
  prefs: []
  type: TYPE_NORMAL
- en: Process and thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A process is an *instance of a program,* an executing instance, to be precise.
    It has its own address space and remains isolated from other processes. This means
    that each process has a range of (usually virtual) addresses that the OS assigns
    to it. Linux treats them as *tasks*. They are not observable by the general user.
    This is just how the kernel does its job. Each task is described through the `task_struct`
    entity, defined in `include/linux/sched.h`. System administrators and system programmers
    observe processes through the process table, hashed through each process’s specific
    process identifier – `pid`. This method is used for a quick lookup of a process
    – use the `ps` command in Terminal to see the process status on the system and
    then type the following command to see the specific info for a single process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let’s start some program, called `test`, and let it run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can open a separate Terminal and see `test` in the list of running processes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you know the `PID` already, then just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A new process is created via a copy of the current process’s attributes and
    will belong to a *process group*. One or more groups create a *session*. Each
    session is related to a *terminal*. Both groups and sessions have *process leaders*.
    The *cloning* of attributes is used mainly for resource sharing. If two processes
    share the same virtual memory space, they are treated and managed as two *threads*
    in a single process, but they are not as heavyweight as processes. What is a thread,
    then?
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, there are four entities we care about: first is the executable file
    as it is the unit-carrier of the instructions to be executed. Second is the process
    – the worker unit executing those instructions. Third – we need these instructions
    as instruments to handle and manage system resources. And fourth is the thread
    – the smallest sequence of instructions, managed independently by the OS, and
    part of a process. Bear in mind that the implementations of processes and threads
    are different for every OS, so do your research before using them.'
  prefs: []
  type: TYPE_NORMAL
- en: From the kernel’s point of view, the main thread of the process is the *task
    group leader*, identified in the code as `group_leader`. All threads spawned by
    the group leader are iterable through `thread_node`. Actually, they are stored
    in a singly linked list and `thread_node` is its head. The spawned threads carry
    a pointer to the `group_leader` tool. The *process creator*’s `task_struct`objectis
    pointed by it. You probably already guessed correctly that it is the same as the
    `task_struct` of the group leader.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If a process spawns another process, for example, through `fork()`, the newly
    created processes (known as *child processes*) know about their creator through
    the `parent` pointer. They are also aware of their siblings through the `sibling`
    pointer, which is a list node to some other child process of the parent. Each
    parent knows about its children through `children` – a pointer to the list head,
    storing the children and providing access to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following figure, the threads do not define any other
    data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Structures of processes and threads through task_structs](img/Figure_1.3_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Structures of processes and threads through task_structs
  prefs: []
  type: TYPE_NORMAL
- en: We’ve mentioned `fork()`already a couple of times, but what is it? Well, put
    simply, it is a system function that creates a process copy of the process caller.
    It provides the parent with the new process’s ID and initiates the execution of
    the child. We are going to provide some code examples in the next chapter, so
    you could take a look there for more details. There’s something important we should
    mention now, as we are on the topic of Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, `fork()` is replaced with `clone()`. Different options are
    provided through `flags`, but if all are set to zero, `clone()` behaves like `fork()`.
    We advise you to read more here: [https://man7.org/linux/man-pages/man2/clone.2.xhtml](https://man7.org/linux/man-pages/man2/clone.2.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re probably asking yourself why this implementation is preferable. Think
    about it this way: when the kernel does a switch between the processes, it checks
    the address of the current process in the virtual memory, the *page directory*
    to be exact. If it is the same as the newly executed process, then they share
    the same address space. Then, the switch is only a simple pointer jump instruction,
    usually to the entry point of the program. This means a faster rescheduling is
    to be expected. Be careful – the processes might share the same address space,
    but not the same program stack. `clone()` takes care of creating a different stack
    for each process.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the process is created, we must take a look at its *running mode*.
    Note that this is not the same as the *process state*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of processes based on their running mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some processes require user interaction to be initiated or interacted with.
    They are known as *foreground processes*. But as you’ve probably figured out,
    there are some processes that run independently of our, or any other user’s, activity.
    Processes of this kind are known as *background processes*. Unless instructed
    otherwise, the terminal inputs as program execution calls or user commands are
    treated as foreground processes by default. To run a process in the background,
    simply place `&` at the end of the command line that you use to start the process.
    For example, let’s call the already known `test`, and after it finishes, we see
    the following in Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily stop it using its `pid` when calling the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, killing a process and letting it terminate by itself are two
    different things, and killing the process could lead to unpredictable system behavior
    or the inability to access some resource, such as a file or a socket left unclosed.
    This topic will be revisited later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Other processes run unattended. They are known as *daemons* and run constantly
    in the background. They are expected to be always available. Daemons are usually
    started through the system’s startup scripts and run until it’s shut down. They
    usually provide system services and multiple users rely on them. Therefore, the
    daemons on startup are usually initiated by the user with ID 0 (usually `root`)
    and might run with `root` privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The user with the highest privileges on a Linux system is known as the root
    user, or simply root. This privilege level allows the performing of security-related
    tasks. This role has a direct impact on the system’s integrity, therefore all
    other users must be set with the least-possible privilege level until a higher
    one is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *zombie process* is a process that has been terminated, but is still recognized
    through its `pid`. It has no address space. Zombie processes continue to exist
    for as long as their parent processes run. This means that until we exit the main
    process, shut down the system, or restart it, the zombie process will still appear
    as `<defunct>` when listed by `ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see zombie processes through `top` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Getting back to the discussion on background processes, there is another way
    to execute specific procedures without explicitly starting background processes.
    Even better – we can manage such processes running on system startup or on different
    system events. Let’s look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running services with init and systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s use this opportunity to discuss the `init` and the `systemd` process
    daemons. There are others as well, but we’ve decided to retain our focus on these
    two. The first one is the initial process, executed on a Linux system by the kernel,
    and its `pid` is always `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is known as the parent of all processes on the system as it is used to initialize,
    manage, and track other services and daemons. The first `init` daemon for Linux
    is called `Init` and it defines six system states. All system services are mapped
    to those states, respectively. Its script is used to start processes in a pre-defined
    order, which is occasionally used by system programmers. One possible reason to
    use this is to reduce the startup duration of the system. To create a service
    or edit the script, you could modify `/etc/init.d`. As this is a directory, we
    could list it with the `ls` command and see all the services that could be run
    through `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we have on our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these scripts follows the same code template for its execution and
    maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – init.d script, representing the possible service actions](img/Figure_1.4_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – init.d script, representing the possible service actions
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate the same template yourself and read more about the `init`
    script source code through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the status of the available services through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could stop the firewall service – `ufw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s check its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s start it again and check its status once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In a similar fashion, you could create your own service and use the `service`
    command to start it. An important remark is that `init` is considered an outdated
    approach on modern, full-scale Linux systems. Still, it can be found on every
    Unix-based OS, unlike **systemd**, so system programmers would anticipate its
    use as a common interface to services. Therefore, we use it more as a simple example
    and an explanation for where services are coming from. If we want to use the latest
    approach, we must turn to **systemd**.
  prefs: []
  type: TYPE_NORMAL
- en: '`.service` file under the `/lib/systemd/system` or `/etc/systemd/system` directory.
    The services found in `/lib` are definitions for system startup services and those
    in `/etc` are for the services that start during system runtime. Let’s list them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Before we continue with an example, let’s put one disclaimer here – `systemd`
    has a much more complex interface than `init`. We encourage you to spend time
    examining it separately as we cannot summarize it in short here. But if you list
    your `systemd` directories, you will probably observe many types of files. In
    the context of the daemon, they are known as `units`. Each of them provides a
    different interface as they each relate to a certain entity managed by `systemd`.
    The script inside each file describes what options are set and what the given
    service does. The `units` names are eloquent. `.timer` is for timer management,
    `.service` is for how a given service will be initiated and what it depends on,
    `.path` describes the path-based activation of a given service, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a simple `systemd` service that will have the purpose of monitoring
    whether a given file is being modified. One example is monitoring some configuration:
    we wouldn’t want to limit its permissions for file update, but we’d still like
    to know whether someone has changed it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create some dummy file through a simple text editor. Let’s imagine
    it’s a real configuration. Printing it out gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s prepare a script that describes the procedure we require to be executed
    when the file is changed. Again, just for the purposes of this example, let’s
    create it through a simple text editor – it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When the script is called, there will be a message that the file has changed.
    Of course, you could put any program here. Let’s call it `sniff_printer`, because
    we are sniffing for a file change through the service, and we will print some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this happen then? First, we define our new service through the required
    `unit` – `myservice_test.service` – implementing the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we describe the file path we’re monitoring through another `unit` called
    `myservice_test.path`, implemented via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining all these pieces together, we get a service that will print out a
    simple message. It will be triggered whenever the provided file is updated. Let’s
    see how it goes. As we are adding a new file to the service directory, we must
    execute a reload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s enable and start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update the file through some text editor, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to see the effect we’ve triggered, we have to go through the service
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate that the service has been triggered as our message is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also see the code that was executed and its successful status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: But the process is no longer active as the service `unit` is of type `oneshot`,
    therefore only another file update will retrigger it. We believe this example
    offers a simple explanation of how a daemon could be created and started during
    system runtime. Feel free to experiment yourself and try different unit types
    or options.
  prefs: []
  type: TYPE_NORMAL
- en: The process daemon and the startup procedures are a large area of expertise
    in system administration, programming, monitoring, and obtaining execution flow
    information. These topics as well as that of the next section deserve books of
    their own.
  prefs: []
  type: TYPE_NORMAL
- en: Portable Operating System Interface (POSIX)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **POSIX** standard has the main task of maintaining compatibility between
    different OSs. Therefore, POSIX is frequently used by both standard application
    software developers and system programmers. Nowadays, it can be found not only
    on Unix-like OSs, but in Windows environments as well – for example, **Cygwin**,
    **MinGW**, and **Windows Subsystem for Linux** (**WSL**). POSIX defines both the
    system- and the user-level APIs with one remark: using POSIX, the programmer doesn’t
    need to distinguish between system calls and library functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The POSIX API is frequently used in the C programming language. Thus, it is
    compilable with C++. Additional functions are provided to the **system call interface**
    in a few important areas of system programming: **file operations**, **memory
    management**, **process and thread control**, **networking and communications**,
    and **regular expressions** – as you can see, it pretty much covers everything
    that the already existing system calls do. Just don’t get confused and think that
    this is always the case.'
  prefs: []
  type: TYPE_NORMAL
- en: As with every standard, POSIX has multiple versions, and you must be aware of
    which one is present in your system. It also could be a part of some environment
    subsystem, such as the **Microsoft POSIX subsystem** for Windows. This is a key
    remark as it is possible that the environment itself doesn’t expose the entire
    interface to you. One reason could be the security assessment of the system.
  prefs: []
  type: TYPE_NORMAL
- en: With the evolution of POSIX, rules for code quality have been established. Some
    of them are related to **multithreaded memory access**, **synchronization mechanisms**
    and **concurrent executions**, **security** and **access restrictions**, and **type
    safety**. A famous concept in POSIX’s software requirements is *write once,* *adopt
    everywhere*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard defines and targets four main areas of its application, called
    volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base definitions**: Main definitions for the specification: syntax, concepts,
    terms, and service operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System interfaces**: Interface descriptions and definitions’ availability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities**: Shell, command, and utility descriptions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rationale**: Versioning information and historical data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that said, in this book our focus is mainly on POSIX as a different
    approach to system calls. In the following chapters, we will see the benefit of
    the general pattern for using objects such as message queues, semaphores, shared
    memory, or threads. A significant improvement is the simplicity of the function
    calls and their naming conventions. For example, `shm_open()`, `mq_open()`, and
    `sem_open()` are used to create and open a shared memory object, a message queue,
    and a semaphore, respectively. Their similarity is obvious. Similar ideas in POSIX
    are welcomed by system programmers. The API is public, too, and there are substantial
    community contributions. Additionally, POSIX provides an interface to objects
    such as the mutex, which is not trivially found and used on Unix. However, in
    later chapters, we will advise readers to focus more on the C++20 features and
    for good reason, so bear with us.
  prefs: []
  type: TYPE_NORMAL
- en: Using POSIX allows software engineers to generalize their OS-related code and
    declare it as *not-OS-specific*. This allows easier and faster reintegration of
    the software, thus reducing the time to market. System programmers can also easily
    switch from one system to another while still writing the same type of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the definitions of basic concepts related to
    OSs. You have learned about Linux’s main kernel structure and its expectations
    of software design. Real-time OSs were briefly introduced, and we covered the
    definitions of system calls, the system call interface, and POSIX as well. We’ve
    also laid the foundations of multiprocessing and multithreading. In the next chapter,
    we will discuss the process as the main resource user and manager. We will start
    with some C++20 code. Through this, you will learn about the Linux’s process memory
    layout, the OS’s process-scheduling mechanism, and how multiprocessing operates
    plus the challenges it brings. You will also learn some interesting facts about
    atomic operations.
  prefs: []
  type: TYPE_NORMAL
