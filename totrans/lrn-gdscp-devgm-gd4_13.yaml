- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: OOP Continued and Advanced Topics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的继续和高级主题
- en: We learned so many things about programming over the course of this book, from
    basic variables, control flows, and classes to things that are GDScript-specific,
    such as accessing nodes in the scene tree and specific annotations. However, don’t
    be mistaken – there is still so much more knowledge out there that can help solve
    problems easier and faster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们学习了大量的编程知识，从基本的变量、控制流和类到GDScript特有的内容，例如访问场景树中的节点和特定的注释。然而，不要误解——还有更多知识可以帮助我们更容易、更快地解决问题。
- en: After many years of studying and professionally applying my programming skills,
    I can confidently state that computer science is a deep and rewarding field to
    keep learning. Plus, every few years a new technology pokes out its head, waiting
    to be studied.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的学习和专业应用我的编程技能，我可以自信地说，计算机科学是一个深奥且值得继续学习的领域。此外，每隔几年就会有一种新技术崭露头角，等待我们去研究。
- en: In this chapter, we’ll look at a bunch of more advanced techniques and concepts
    that will elevate your programming skills to new heights!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一系列更高级的技术和概念，这将使你的编程技能达到新的高度！
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The `super` keyword
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super`关键字'
- en: Static variables and functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量和函数
- en: Enumeration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Lambda functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数
- en: Passing parameters by value or reference
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值或引用传递参数
- en: The `@``tool` annotation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@tool`注释'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with every chapter, you can find the final code in the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以在GitHub仓库的该章节子文件夹中找到最终代码：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13)。
- en: The super keyword
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`super`关键字'
- en: In [*Chapter 4*](B19358_04.xhtml#_idTextAnchor164), we learned all about inheritance
    and how we can override functions from a base class in an inherited class. This
    overriding replaces the function with a whole new body and discards the original
    implementation of the base class. However, sometimes, we still would like to execute
    the original logic that was defined in the parent class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19358_04.xhtml#_idTextAnchor164)中，我们学习了继承以及如何在继承类中覆盖基类中的函数。这种覆盖用全新的主体替换了函数，并丢弃了基类的原始实现。然而，有时我们仍然希望执行在父类中定义的原始逻辑。
- en: 'To accomplish this, we can use the `super` keyword. This keyword gives us direct
    access to all the functions of the parent class on which the current class was
    based. Consider the following example, where we want to have different kinds of
    arrows in our game to shoot enemies with:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用`super`关键字。这个关键字让我们直接访问当前类基于的父类的所有函数。考虑以下示例，我们想在游戏中拥有不同种类的箭来射击敌人：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we define a `BaseArrow` class which is the base for all kinds of arrows.
    It has one function, `describe_damage()`, which just describes what kind of damage
    the arrow does by printing out `Pierces a person` to the console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`BaseArrow`类，它是所有种类箭的基础。它有一个函数`describe_damage()`，该函数只是通过将`Pierces
    a person`打印到控制台来描述箭造成的伤害。
- en: When we override the `describe_damage()` function of the `FireArrow` class,
    we first call `super()` as a function. This will execute the original `describe_damage()`
    function of the `BaseArrow` class before executing the rest.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们覆盖`FireArrow`类的`describe_damage()`函数时，我们首先将`super()`作为一个函数调用。这将执行`BaseArrow`类的原始`describe_damage()`函数，然后再执行其余部分。
- en: 'Let’s execute some code that uses these classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行一些使用这些类的代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result will be as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that the `describe_damage()` function from the base class has been
    executed, using the `super()` keyword, as well as the rest of the `FireArrow`
    class’s implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，使用`super()`关键字执行了基类中的`describe_damage()`函数，以及`FireArrow`类其余的实现。
- en: The `super` keyword gives access to the underlying class we inherited from;
    whether we have overridden that function or not, it will always return to the
    original one. Let’s continue with a look at another new keyword – `static`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`关键字提供了访问我们继承的底层类的方法；无论我们是否覆盖了该函数，它总是会返回原始的函数。让我们继续探讨另一个新关键字——`static`。'
- en: Static variables and functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态变量和函数
- en: 'The next keyword we will look at is `static`. We can declare a variable or
    function as static by putting this keyword in front of it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一个关键字是`static`。我们可以通过在这个关键字前放置它来声明一个变量或函数为静态：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Static variables and functions are declared on the class itself. This means
    that they can be accessed without creating an instance of the class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量和函数是在类本身上声明的。这意味着它们可以在不创建类实例的情况下访问：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Static variables are made to contain information that is bound to a complete
    class of objects. But watch out – the following are two big gotchas for static
    variables and functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量是为了包含与整个对象类绑定在一起的信息。但要注意 – 以下是静态变量和函数的两个大陷阱：
- en: In GDScript, static variables can be assigned a new value, and you can change
    them during the execution of the game. Ideally, you don’t want to do this because
    it can impact your program in ways that are hard to debug.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GDScript中，静态变量可以被赋予新的值，你可以在游戏执行过程中更改它们。理想情况下，你不想这样做，因为这可能会以难以调试的方式影响你的程序。
- en: From a static function, you can call other functions and use member variables
    of the class, but only if they are defined as static too. Because static functions
    are defined on the class itself, they do not have all the context of an initialized
    object of this class. Static functions need to be very self-contained.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个静态函数中，你可以调用其他函数并使用类的成员变量，但前提是它们也被定义为静态。因为静态函数是在类本身上定义的，它们没有初始化对象的全部上下文。静态函数需要非常自包含。
- en: All in all, you won’t see static variables and functions that often in GDScript,
    but it is a well-known concept that many object-oriented programming languages,
    such as C++ or Java, use. Let’s have a look at enums next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在GDScript中，你不会经常看到静态变量和函数，但它是一个在许多面向对象编程语言中，如C++或Java，广为人知的概念。接下来，让我们看看枚举。
- en: Enumerations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: '**Enums**, short for **enumerations**, are a variable type that defines a set
    of constants that need to be grouped together. Unlike normal constants, where
    we want to store a certain value, enums automatically assign values to a constant.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**，简称**枚举**，是一种变量类型，它定义了一组需要组合在一起的常量。与我们要存储特定值的普通常量不同，枚举会自动为常量分配值。'
- en: 'In *Chapters 2* and *5*, we saw that it’s very important to have well-named
    variables. This way, we always know what they will contain. We can actually do
    this for the values of variables too, with named values. Using named values, we
    can associate a human-readable name with a certain value, making code more readable.
    It also removes magic numbers from the code. Have a look at this enum:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第2章**和**第5章**中，我们看到了拥有良好命名的变量非常重要。这样，我们总能知道它们将包含什么。实际上，我们也可以为变量的值使用命名值。使用命名值，我们可以将一个可读性强的名称与某个值关联起来，使代码更易于阅读。它还从代码中移除了魔法数字。看看这个枚举：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we create an enum called `DAMAGE_TYPES` that defines three named values
    – `NONE`, `FIRE`, and `ICE`. You can access these values like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个名为`DAMAGE_TYPES`的枚举，它定义了三个命名值 – `NONE`、`FIRE`和`ICE`。你可以这样访问这些值：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s try printing them out:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将它们打印出来：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll see that it prints out the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它打印出以下内容：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is because each of the names within the enum is associated with an integer
    value. However, instead of using these rough integers, we can now use nicely readable
    names. The first named value is associated with `0`, and each following one goes
    up by one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为枚举内的每个名称都与一个整数值相关联。然而，我们不再使用这些粗略的整数，现在我们可以使用易于阅读的名称。第一个命名值与`0`相关联，每个随后的值递增1。
- en: 'An enum can also be used to type-hint variables; this way, we know that the
    variable needs to be assigned an enum value from a certain type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也可以用来类型提示变量；这样，我们知道变量需要被分配来自某个类型的枚举值：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we type-hint the `damage_type` variable as `DAMAGE_TYPES`.
    Then, we can, for example, match against this variable and determine what to do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`damage_type`变量类型提示为`DAMAGE_TYPES`。然后，例如，我们可以匹配这个变量并确定要执行的操作。
- en: Enums versus strings
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举与字符串的比较
- en: Now, you might think, “*Why don’t we use strings if we want to be able to read
    the value?*” Well, simply, it’s because strings are slower and more memory-heavy
    to work with than integers, the underlying data type of enum values. Another reason
    is ease of use. An enum has a finite set of values, the ones we defined, while
    a string can have an arbitrary number of characters. So, when using an enum, we’re
    sure we’re only dealing with values we know.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，“*为什么我们不用字符串来读取值呢？*”简单来说，这是因为字符串与整数（枚举值的底层数据类型）相比，处理起来更慢且占用更多内存。另一个原因是易用性。枚举有一组有限的值，即我们定义的值，而字符串可以有任意数量的字符。因此，当我们使用枚举时，我们可以确信我们只处理我们知道的值。
- en: 'We can also access enums that are defined in one class from a totally different
    class; like static variables and functions, they can be accessed from the class
    type directly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从完全不同的类中访问在一个类中定义的枚举；就像静态变量和函数一样，它们可以直接从类类型访问：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'var print_hello: Callable = func(): print("Hello")'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'var print_hello: Callable = func(): print("Hello")'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: print_hello.call()
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: print_hello.call()
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'var print_largest: Callable = func(number_a: float, number_b: float):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'var print_largest: Callable = func(number_a: float, number_b: float):'
- en: 'if number_a > number_b:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'if number_a > number_b:'
- en: print(number_a)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: print(number_a)
- en: 'else:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(number_b)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: print(number_b)
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: button.connect("pressed", pressed signal, our lambda function gets executed
    and prints out Button pressed!.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: button.connect("pressed", pressed signal, 我们的自定义lambda函数被调用并打印出 Button pressed!。
- en: 'Another one of its use cases are the `filter()` or `sort_custome()` functions
    that can use lambda function to filter or sort elements in an array:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的另一个用例是`filter()`或`sort_custome()`函数，这些函数可以使用lambda函数来过滤或排序数组中的元素：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each array has the `filter()` and `sort_custome()` function that takes `Callable`
    as an argument. The `filter()` function will filter out any element within the
    array for which the function returns `false`, resulting in an array that only
    has the elements where the function returns `true`. In the preceding example,
    this results in an array with only even numbers.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个数组都有一个`filter()`和`sort_custome()`函数，这些函数接受`Callable`作为参数。`filter()`函数将过滤掉数组中任何返回`false`的元素，从而得到一个只包含返回`true`的元素的数组。在上面的例子中，这导致了一个只包含偶数的数组。
- en: The `sort_custome()` function sorts the elements within the array using the
    `Callable` we provide it. The lambda function should take two elements and, when
    the first element should be sorted before the second element, return `true`; otherwise,
    it should return `false`. This way, we can define our own rules to sort an array’s
    elements.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sort_custome()`函数使用我们提供给它的`Callable`对数组内的元素进行排序。lambda函数应该接受两个元素，如果第一个元素应该在第二个元素之前排序，则返回`true`；否则，应返回`false`。这样，我们可以定义自己的规则来排序数组的元素。'
- en: 'The resulting arrays after running `filter()` and `sort_custome()` with our
    lambda functions are as follows:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用我们的lambda函数运行`filter()`和`sort_custome()`后的结果数组如下：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: More information
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'For more on lambda functions, check out the official documentation: [https://docs.godotengine.org/en/stable/classes/class_callable.html](https://docs.godotengine.org/en/stable/classes/class_callable.html).'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于lambda函数的信息，请参阅官方文档：[https://docs.godotengine.org/en/stable/classes/class_callable.html](https://docs.godotengine.org/en/stable/classes/class_callable.html)。
- en: Now that we know what lambda functions are, let’s take a look at the different
    ways in which we can pass values to functions.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经知道了lambda函数是什么，让我们看看我们可以以不同的方式向函数传递值。
- en: Passing parameters by value or reference
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按值或按引用传递参数
- en: When passing parameters to a function, there are actually two different ways
    in which these parameters can arrive at the body of that function – by value or
    reference. We, as programmers, do not choose which of the two is used; GDScript
    makes this decision based on the data type of the value we provide the function.
    Let’s take a deeper look into both the methods for passing values, which data
    types apply to each, and why it is important to know the difference.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当向函数传递参数时，实际上有两种不同的方式可以使这些参数到达函数体中——按值或按引用。作为程序员，我们并不选择使用哪一种；GDScript会根据我们提供给函数的值的类型来做出这个决定。让我们更深入地了解一下两种传递值的方法，适用于每种数据类型，以及为什么了解这些差异很重要。
- en: Passing by value
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按值传递
- en: Passing by value means that GDScript sends over an exact copy of a value to
    a function. This approach is very simple and predictable because we get a new
    variable in the function that we called. However, because copying over data takes
    time, it can be quite slow for big data types.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按值传递意味着GDScript将值的精确副本发送到函数中。这种方法非常简单且可预测，因为我们得到了在函数中调用的新变量。然而，由于复制数据需要时间，对于大数据类型来说可能会相当慢。
- en: Data types that get passed by value are any of the simpler built-in data types,
    such as integers, floating point numbers, and Booleans. Some also slightly more
    complex classes such as strings, `Vector2`, and `Colors` are passed by value.
    This list is not exhaustive. The general rule of inclusion is anything that is
    not an array, not a dictionary, and not inherited from the `Object` class.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按值传递的数据类型包括任何简单的内置数据类型，如整数、浮点数和布尔值。还有一些稍微复杂一些的类，如字符串、`Vector2`和`Colors`，也是按值传递的。这个列表并不全面。一般规则是包含任何不是数组、不是字典且不是从`Object`类继承的任何东西。
- en: 'Let’s see what passing by value looks like in practice:'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看按值传递在实际中是什么样子：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, you can see that we have two functions that take an integer and a string
    respectively, and each modify the value of the parameter during its execution.
    We also print out the value of this integer and string every step of the way,
    before, during, and after the function’s execution, to see whether the original
    variable, from the `_ready()` function, got altered. Running this will print out
    the following:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们有两个函数，分别接受一个整数和一个字符串，并在其执行过程中修改参数的值。我们还打印出整数和字符串的值，在函数执行之前、期间和之后，以查看原始变量（来自`_ready()`函数）是否被更改。运行此代码将打印出以下内容：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that, although the value got altered in some way during the function’s
    execution, the original value did not change. This is the fun of passing by value;
    we don’t need to worry about side effects.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管在函数执行过程中值以某种方式被更改了，但原始值并没有改变。这就是按值传递的乐趣；我们不需要担心副作用。
- en: Side effects of functions
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的副作用
- en: Side effects, in programmer lingo, mean that a function changes the state of
    a program in ways that are not directly apparent, altering variables outside of
    its scope. You want to avoid this as much as possible so that it is easy to understand
    what a function does.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序员的语言中，副作用意味着函数以不是直接明显的方式改变程序的状态，改变其作用域之外的变量。你应尽可能避免这种情况，以便更容易理解函数的作用。
- en: This is how passing by value works – just a straight copy of the data. Now,
    we’ll see the contrasting idea – passing by reference.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是按值传递的工作方式——只是数据的直接复制。现在，我们将看到对比的概念——按引用传递。
- en: Passing by reference
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过引用传递
- en: The other way to pass values to a function is by reference. This means that
    GDScript does not copy over the whole value but, rather, sends a reference that
    points toward the value. This reference points to where the actual value is stored
    and can be used to access and change it.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向函数传递值的另一种方式是通过引用。这意味着GDScript不会复制整个值，而是发送一个指向值的引用。这个引用指向实际值存储的位置，并可用于访问和更改它。
- en: This mode of passing parameters is used for arrays, dictionaries, and any class
    that inherits from the `Object` class, which includes all types of nodes. It is
    essentially used to pass bigger data types, as copying their complete value over
    would take too much time and slow down the execution of our game.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种传递参数的模式用于数组、字典以及从`Object`类继承的任何类，这包括所有类型的节点。它本质上用于传递更大的数据类型，因为复制它们的完整值会花费太多时间并减慢游戏的执行速度。
- en: 'Here’s an example of what passing by reference looks like:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个按引用传递的例子：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, we use the same setup as before to print out our dictionary every step
    of the way. We run the following code:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们使用之前相同的设置，在每一步打印出我们的字典。我们运行以下代码：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As expected, we can see that after the function ran, the original dictionary
    from the `_ready()` function was altered too! This is a side effect in action.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，我们可以看到在函数运行后，`_ready()`函数中的原始字典也被更改了！这是副作用在起作用。
- en: In general, it is good practice to never alter the values and variables that
    come into a function, and always make a copy or use them directly to calculate
    a value for another variable. When in doubt, it’s best to test out whether a value
    is passed by value or reference; this way, you never encounter unintended bugs.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，一个好的做法是永远不要更改传入函数的值和变量，并且始终复制它们或直接使用它们来计算另一个变量的值。如果有疑问，最好测试一个值是按值传递还是按引用传递；这样，你永远不会遇到意外的错误。
- en: Duplicating arrays or dictionaries
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 复制数组或字典
- en: If you really want to make a copy of an array or dictionary, then you can use
    the `duplicate()` function that is defined on these data types. This function
    will return a copy of the array or dictionary that you can alter safely.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你真的想复制一个数组或字典，那么你可以使用定义在这些数据类型上的 `duplicate()` 函数。这个函数将返回一个数组或字典的副本，你可以安全地对其进行修改。
- en: 'See the documentation for more details: [https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate](https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate).'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看文档以获取更多详细信息：[https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate](https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate)。
- en: We’ll now switch gears and see how we can make tools for the editor from within
    the editor.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将转换方向，看看我们如何从编辑器内部创建编辑器工具。
- en: The @tool annotation
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@tool 注解'
- en: As well as using GDScript to run code during our game’s execution, we can actually
    use it to run code in the editor itself. Running code within the editor grants
    us the power to visualize things, such as the jump height of a character, or automate
    our workflow. In doing so we extend the Godot editor for our own specific needs.
    There are multiple ways of running GDScript code within the editor, ranging from
    running separate scripts to writing whole plugins, but the easiest way is by using
    the `@``tool` annotation.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了在游戏执行期间使用 GDScript 运行代码外，我们实际上还可以在编辑器本身中运行代码。在编辑器中运行代码赋予我们可视化事物的能力，例如角色的跳跃高度，或自动化我们的工作流程。通过这样做，我们扩展了
    Godot 编辑器以满足我们自己的特定需求。在编辑器中运行 GDScript 代码有多种方式，从运行单独的脚本到编写整个插件，但最简单的方法是使用 `@tool`
    注解。
- en: The `@tool` annotation is an annotation that can be added to the top of any
    script. Its effect is that nodes with that script will run their script within
    the editor as if they were instanced within a game. This means that all of their
    code runs from within the editor.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@tool` 注解是一种可以添加到任何脚本顶部的注解。它的作用是，具有该脚本的节点将在编辑器中运行它们的脚本，就像它们在游戏中实例化一样。这意味着它们的所有代码都是在编辑器中运行的。'
- en: This is very useful when we are editing our scenes and want to preview things
    within the editor, such as the health of our player, or create new nodes using
    code.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们编辑场景并希望在编辑器中预览事物时，例如玩家的健康状态，或使用代码创建新节点，这非常有用。
- en: 'Knowing this, we can adjust our player script, by adding the `@tool` annotation
    to the top to update the health label in the editor:'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 了解这一点后，我们可以通过在顶部添加 `@tool` 注解来调整我们的玩家脚本，以更新编辑器中的健康标签：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example is the minimum amount of code needed to update the health label
    from within the editor. However, you can just add the `@tool` annotation at the
    top of your existing player script, and it will work its magic. You’ll see that
    every time you change the player’s health from within the editor now, the health
    label will automatically reflect this change.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个示例是更新编辑器中健康标签所需的最小代码量。然而，你只需在现有的玩家脚本顶部添加 `@tool` 注解，它就会发挥作用。现在，每次你在编辑器中更改玩家的健康状态时，健康标签都会自动反映这一变化。
- en: The risks of @tool
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@tool 的风险'
- en: The `@tool` annotation is very powerful but not without danger. It can remove
    things permanently from a scene and easily change the values of nodes if you don’t
    watch out, so treat it with caution.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@tool` 注解非常强大，但并非没有风险。如果不小心，它可能会永久删除场景中的事物，并轻松更改节点的值，所以请谨慎使用。'
- en: 'However, sometimes you want to use a node in a game and have some code that
    runs in the editor. When we do that, we need a way to distinguish whether the
    code is run in the game or the editor. This can be done by using `Engine.is_editor_hint()`.
    This function on the global `Engine` object returns `true` if we run the code
    from within the editor and `false` when from within the game:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，有时你希望在游戏中使用一个节点，并在编辑器中运行一些代码。当我们这样做时，我们需要一种方法来区分代码是在游戏还是编辑器中运行的。这可以通过使用 `Engine.is_editor_hint()`
    函数来实现。这个全局 `Engine` 对象上的函数，如果我们从编辑器中运行代码，则返回 `true`；如果从游戏中运行，则返回 `false`：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code example shows us how easy it is to differentiate between running code
    in the editor or the game.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个代码示例向我们展示了在编辑器或游戏中运行代码之间的区别是多么容易区分。
- en: More information
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'Want to know more about the `@tool` annotation and running code within the
    editor? Check out the official documentation: [https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html](https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html).'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想了解更多关于 `@tool` 注释和在编辑器中运行代码的信息？请查看官方文档：[https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html](https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html)。
- en: Using the `@tool` annotation wisely, we can make our workflow easier and faster.
    The possibilities are endless; you can even access and change almost every aspect
    of the Godot editor from within one of these scripts, but that is out of the scope
    of this book.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `@tool` 注释明智地，我们可以使我们的工作流程更简单、更快。可能性是无限的；你甚至可以从这些脚本之一中访问和更改 Godot 编辑器几乎每一个方面，但这超出了本书的范围。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took a deeper dive into some of the more advanced topics of programming
    with GDScript. We expanded our knowledge of object-oriented programming with the
    `super` and `static` keywords and the difference between passing by value or reference.
    Then, we saw more features of the GDScript programming language, such as enums
    and lambda functions. We concluded the chapter with a way to run code within the
    Godot editor itself, using the `@``tool` annotation.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章深入探讨了使用 GDScript 编程的一些更高级的主题。我们通过 `super` 和 `static` 关键字以及按值或按引用传递的区别，扩展了我们对面向对象编程的知识。然后，我们看到了
    GDScript 编程语言的更多功能，例如枚举和 lambda 函数。我们以在 Godot 编辑器本身中运行代码的方式结束了本章，使用的是 `@tool`
    注释。
- en: Quiz time
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测验时间
- en: Imagine we have a class named `Character` that has a function called `move()`.
    Now, we create a `Player` class that inherits from this `Character` class and
    overrides this `move()` function. But, instead of completely overriding it, we
    want to extend the original functionality of the `Character` class’s `move()`
    function. What keyword can we use to call the original `move()` function of the
    `Character` class from within the `Player` class?
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `Character` 的类，它有一个名为 `move()` 的函数。现在，我们创建一个 `Player` 类，它继承自这个 `Character`
    类并重写这个 `move()` 函数。但是，我们不想完全重写它，而是想扩展 `Character` 类的 `move()` 函数的原始功能。我们可以在 `Player`
    类中调用 `Character` 类的原始 `move()` 函数的哪个关键字？
- en: Can functions that are labeled `static` call functions that are not labeled
    `static`?
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为 `static` 的函数能否调用未标记为 `static` 的函数？
- en: What will the following snippet of code print out?
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段将打印出什么？
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Are container types, such as arrays and dictionaries, the only types that get
    passed by reference?
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器类型，如数组和字典，是唯一按引用传递的类型吗？
- en: What annotation do we use at the top of a script if we want to run it in the
    editor?
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在编辑器中运行脚本，我们在脚本顶部使用什么注释？
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
