- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP Continued and Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned so many things about programming over the course of this book, from
    basic variables, control flows, and classes to things that are GDScript-specific,
    such as accessing nodes in the scene tree and specific annotations. However, don’t
    be mistaken – there is still so much more knowledge out there that can help solve
    problems easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: After many years of studying and professionally applying my programming skills,
    I can confidently state that computer science is a deep and rewarding field to
    keep learning. Plus, every few years a new technology pokes out its head, waiting
    to be studied.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at a bunch of more advanced techniques and concepts
    that will elevate your programming skills to new heights!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `super` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters by value or reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@``tool` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every chapter, you can find the final code in the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: The super keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19358_04.xhtml#_idTextAnchor164), we learned all about inheritance
    and how we can override functions from a base class in an inherited class. This
    overriding replaces the function with a whole new body and discards the original
    implementation of the base class. However, sometimes, we still would like to execute
    the original logic that was defined in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we can use the `super` keyword. This keyword gives us direct
    access to all the functions of the parent class on which the current class was
    based. Consider the following example, where we want to have different kinds of
    arrows in our game to shoot enemies with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `BaseArrow` class which is the base for all kinds of arrows.
    It has one function, `describe_damage()`, which just describes what kind of damage
    the arrow does by printing out `Pierces a person` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: When we override the `describe_damage()` function of the `FireArrow` class,
    we first call `super()` as a function. This will execute the original `describe_damage()`
    function of the `BaseArrow` class before executing the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute some code that uses these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `describe_damage()` function from the base class has been
    executed, using the `super()` keyword, as well as the rest of the `FireArrow`
    class’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `super` keyword gives access to the underlying class we inherited from;
    whether we have overridden that function or not, it will always return to the
    original one. Let’s continue with a look at another new keyword – `static`.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next keyword we will look at is `static`. We can declare a variable or
    function as static by putting this keyword in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Static variables and functions are declared on the class itself. This means
    that they can be accessed without creating an instance of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Static variables are made to contain information that is bound to a complete
    class of objects. But watch out – the following are two big gotchas for static
    variables and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: In GDScript, static variables can be assigned a new value, and you can change
    them during the execution of the game. Ideally, you don’t want to do this because
    it can impact your program in ways that are hard to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a static function, you can call other functions and use member variables
    of the class, but only if they are defined as static too. Because static functions
    are defined on the class itself, they do not have all the context of an initialized
    object of this class. Static functions need to be very self-contained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, you won’t see static variables and functions that often in GDScript,
    but it is a well-known concept that many object-oriented programming languages,
    such as C++ or Java, use. Let’s have a look at enums next.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enums**, short for **enumerations**, are a variable type that defines a set
    of constants that need to be grouped together. Unlike normal constants, where
    we want to store a certain value, enums automatically assign values to a constant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapters 2* and *5*, we saw that it’s very important to have well-named
    variables. This way, we always know what they will contain. We can actually do
    this for the values of variables too, with named values. Using named values, we
    can associate a human-readable name with a certain value, making code more readable.
    It also removes magic numbers from the code. Have a look at this enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create an enum called `DAMAGE_TYPES` that defines three named values
    – `NONE`, `FIRE`, and `ICE`. You can access these values like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try printing them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see that it prints out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is because each of the names within the enum is associated with an integer
    value. However, instead of using these rough integers, we can now use nicely readable
    names. The first named value is associated with `0`, and each following one goes
    up by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'An enum can also be used to type-hint variables; this way, we know that the
    variable needs to be assigned an enum value from a certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we type-hint the `damage_type` variable as `DAMAGE_TYPES`.
    Then, we can, for example, match against this variable and determine what to do.
  prefs: []
  type: TYPE_NORMAL
- en: Enums versus strings
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might think, “*Why don’t we use strings if we want to be able to read
    the value?*” Well, simply, it’s because strings are slower and more memory-heavy
    to work with than integers, the underlying data type of enum values. Another reason
    is ease of use. An enum has a finite set of values, the ones we defined, while
    a string can have an arbitrary number of characters. So, when using an enum, we’re
    sure we’re only dealing with values we know.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also access enums that are defined in one class from a totally different
    class; like static variables and functions, they can be accessed from the class
    type directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'var print_hello: Callable = func(): print("Hello")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: print_hello.call()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'var print_largest: Callable = func(number_a: float, number_b: float):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if number_a > number_b:'
  prefs: []
  type: TYPE_NORMAL
- en: print(number_a)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(number_b)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: button.connect("pressed", pressed signal, our lambda function gets executed
    and prints out Button pressed!.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another one of its use cases are the `filter()` or `sort_custome()` functions
    that can use lambda function to filter or sort elements in an array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each array has the `filter()` and `sort_custome()` function that takes `Callable`
    as an argument. The `filter()` function will filter out any element within the
    array for which the function returns `false`, resulting in an array that only
    has the elements where the function returns `true`. In the preceding example,
    this results in an array with only even numbers.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `sort_custome()` function sorts the elements within the array using the
    `Callable` we provide it. The lambda function should take two elements and, when
    the first element should be sorted before the second element, return `true`; otherwise,
    it should return `false`. This way, we can define our own rules to sort an array’s
    elements.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The resulting arrays after running `filter()` and `sort_custome()` with our
    lambda functions are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: More information
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For more on lambda functions, check out the official documentation: [https://docs.godotengine.org/en/stable/classes/class_callable.html](https://docs.godotengine.org/en/stable/classes/class_callable.html).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we know what lambda functions are, let’s take a look at the different
    ways in which we can pass values to functions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Passing parameters by value or reference
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When passing parameters to a function, there are actually two different ways
    in which these parameters can arrive at the body of that function – by value or
    reference. We, as programmers, do not choose which of the two is used; GDScript
    makes this decision based on the data type of the value we provide the function.
    Let’s take a deeper look into both the methods for passing values, which data
    types apply to each, and why it is important to know the difference.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Passing by value
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Passing by value means that GDScript sends over an exact copy of a value to
    a function. This approach is very simple and predictable because we get a new
    variable in the function that we called. However, because copying over data takes
    time, it can be quite slow for big data types.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Data types that get passed by value are any of the simpler built-in data types,
    such as integers, floating point numbers, and Booleans. Some also slightly more
    complex classes such as strings, `Vector2`, and `Colors` are passed by value.
    This list is not exhaustive. The general rule of inclusion is anything that is
    not an array, not a dictionary, and not inherited from the `Object` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see what passing by value looks like in practice:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that we have two functions that take an integer and a string
    respectively, and each modify the value of the parameter during its execution.
    We also print out the value of this integer and string every step of the way,
    before, during, and after the function’s execution, to see whether the original
    variable, from the `_ready()` function, got altered. Running this will print out
    the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, although the value got altered in some way during the function’s
    execution, the original value did not change. This is the fun of passing by value;
    we don’t need to worry about side effects.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Side effects of functions
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Side effects, in programmer lingo, mean that a function changes the state of
    a program in ways that are not directly apparent, altering variables outside of
    its scope. You want to avoid this as much as possible so that it is easy to understand
    what a function does.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This is how passing by value works – just a straight copy of the data. Now,
    we’ll see the contrasting idea – passing by reference.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Passing by reference
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The other way to pass values to a function is by reference. This means that
    GDScript does not copy over the whole value but, rather, sends a reference that
    points toward the value. This reference points to where the actual value is stored
    and can be used to access and change it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This mode of passing parameters is used for arrays, dictionaries, and any class
    that inherits from the `Object` class, which includes all types of nodes. It is
    essentially used to pass bigger data types, as copying their complete value over
    would take too much time and slow down the execution of our game.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an example of what passing by reference looks like:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we use the same setup as before to print out our dictionary every step
    of the way. We run the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we can see that after the function ran, the original dictionary
    from the `_ready()` function was altered too! This is a side effect in action.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, it is good practice to never alter the values and variables that
    come into a function, and always make a copy or use them directly to calculate
    a value for another variable. When in doubt, it’s best to test out whether a value
    is passed by value or reference; this way, you never encounter unintended bugs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Duplicating arrays or dictionaries
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you really want to make a copy of an array or dictionary, then you can use
    the `duplicate()` function that is defined on these data types. This function
    will return a copy of the array or dictionary that you can alter safely.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'See the documentation for more details: [https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate](https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll now switch gears and see how we can make tools for the editor from within
    the editor.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The @tool annotation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As well as using GDScript to run code during our game’s execution, we can actually
    use it to run code in the editor itself. Running code within the editor grants
    us the power to visualize things, such as the jump height of a character, or automate
    our workflow. In doing so we extend the Godot editor for our own specific needs.
    There are multiple ways of running GDScript code within the editor, ranging from
    running separate scripts to writing whole plugins, but the easiest way is by using
    the `@``tool` annotation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@tool` annotation is an annotation that can be added to the top of any
    script. Its effect is that nodes with that script will run their script within
    the editor as if they were instanced within a game. This means that all of their
    code runs from within the editor.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This is very useful when we are editing our scenes and want to preview things
    within the editor, such as the health of our player, or create new nodes using
    code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Knowing this, we can adjust our player script, by adding the `@tool` annotation
    to the top to update the health label in the editor:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This example is the minimum amount of code needed to update the health label
    from within the editor. However, you can just add the `@tool` annotation at the
    top of your existing player script, and it will work its magic. You’ll see that
    every time you change the player’s health from within the editor now, the health
    label will automatically reflect this change.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The risks of @tool
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@tool` annotation is very powerful but not without danger. It can remove
    things permanently from a scene and easily change the values of nodes if you don’t
    watch out, so treat it with caution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, sometimes you want to use a node in a game and have some code that
    runs in the editor. When we do that, we need a way to distinguish whether the
    code is run in the game or the editor. This can be done by using `Engine.is_editor_hint()`.
    This function on the global `Engine` object returns `true` if we run the code
    from within the editor and `false` when from within the game:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code example shows us how easy it is to differentiate between running code
    in the editor or the game.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: More information
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Want to know more about the `@tool` annotation and running code within the
    editor? Check out the official documentation: [https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html](https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `@tool` annotation wisely, we can make our workflow easier and faster.
    The possibilities are endless; you can even access and change almost every aspect
    of the Godot editor from within one of these scripts, but that is out of the scope
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This chapter took a deeper dive into some of the more advanced topics of programming
    with GDScript. We expanded our knowledge of object-oriented programming with the
    `super` and `static` keywords and the difference between passing by value or reference.
    Then, we saw more features of the GDScript programming language, such as enums
    and lambda functions. We concluded the chapter with a way to run code within the
    Godot editor itself, using the `@``tool` annotation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Imagine we have a class named `Character` that has a function called `move()`.
    Now, we create a `Player` class that inherits from this `Character` class and
    overrides this `move()` function. But, instead of completely overriding it, we
    want to extend the original functionality of the `Character` class’s `move()`
    function. What keyword can we use to call the original `move()` function of the
    `Character` class from within the `Player` class?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can functions that are labeled `static` call functions that are not labeled
    `static`?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What will the following snippet of code print out?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Are container types, such as arrays and dictionaries, the only types that get
    passed by reference?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What annotation do we use at the top of a script if we want to run it in the
    editor?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
