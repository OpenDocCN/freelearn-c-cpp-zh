- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Association, Aggregation, and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue advancing our knowledge of object-oriented programming
    in C++. We will augment our understanding of object relationships by exploring
    the object-oriented concepts of association, aggregation, and composition. None
    of these OO concepts have direct language support in C++; we will instead learn
    multiple programming techniques to implement these ideas. We will also understand
    which implementation techniques are preferred for various concepts, as well as
    the advantages and pitfalls of various practices.
  prefs: []
  type: TYPE_NORMAL
- en: Association, aggregation, and composition occur copiously in OO designs. It
    is crucial to understand how to implement these important object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concepts of aggregation and composition, and various implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the OO concept of association and its implementation, including
    the importance of backlink maintenance and the utility of reference counting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concepts of association,
    aggregation, and composition, and how to implement these relationships in C++.
    You will also understand many housekeeping approaches necessary to keep these
    relationships up to date, such as reference counting and backlink maintenance.
    Though the concepts are relatively straightforward, you will see why there is
    a substantial amount of bookkeeping required to maintain accuracy for these types
    of object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s broaden our understanding of C++ as an OOP language by exploring these
    core object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter10`
    in a file named `Chp10-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3clgvGe](https://bit.ly/3clgvGe).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding aggregation and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object-oriented concept of aggregation arises in many OO designs. It comes
    up as frequently as inheritance does to specify object relationships. **Aggregation**
    is used to specify Has-A, whole-part, and in some cases, containment relationships.
    A class may contain aggregates of other objects. Aggregation can be broken into
    two categories – *composition* as well as a less strict and *generalized* form
    of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Both **generalized aggregation** and **composition** imply a Has-A or whole-part
    relationship. However, the two differ in the existence requirements between the
    two related objects. With generalized aggregation, the objects can exist independently
    from one another, yet with composition, the objects cannot exist without one another.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at each variety of aggregation, starting with composition.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and implementing composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Composition** is the most specialized form of aggregation and is often what
    most OO designers and programmers think of when they consider aggregation. Composition
    implies containment, and is most often synonymous with a whole-part relationship
    – that is, the whole entity is composed of one or more parts. The whole *contains*
    the parts. The Has-A relationship will also apply to composition.'
  prefs: []
  type: TYPE_NORMAL
- en: The outer object, or *whole*, can be made up of *parts*. With composition, parts
    do not exist without the whole. Implementation is usually an embedded object –
    that is, a data member of the contained object type. On rare occasions, the outer
    object will contain a pointer or reference to the contained object type; however,
    when this occurs, the outer object will be responsible for the creation and destruction
    of the inner object. The contained object has no purpose without its outer layer.
    Likewise, the outer layer is not *ideally* complete without its inner, contained
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a composition as typically implemented. The example will
    illustrate containment – a `Student` *Has-A(n)* `Id`. More so, we will imply that
    an `Id` is a necessary part of a `Student` and will not exist without a `Student`.
    `Id` objects on their own serve no purpose. `Id` objects simply do not need to
    exist if they are not a part of a primary object that gives them purpose. Likewise,
    you might argue that a `Student` is incomplete without an `Id`, though this is
    a bit subjective! We will implement the *part* using an embedded object within
    the *whole*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition example will be broken into many segments. Though only portions
    of the example are shown, the full program can be found in the following GitHub
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, we have defined an `Id` class. An `Id` will be
    a class that can be contained by other classes needing a fully functional `Id`
    capability. The `Id` will become a *part* of any *whole* object that may choose
    to contain it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move onward to build a set of classes that will ultimately contain this
    `Id`. We will start with a class we are familiar with, `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have defined the `Person` class, as we are
    accustomed to describing it. To abbreviate this example, let us assume that the
    accompanying member functions exist as prototyped in the aforementioned class
    definition. You can reference these member functions in the earlier provided GitHub
    link for online code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define our `Student` class. Though it will contain elements that
    we are accustomed to seeing, `Student` will also contain an `Id` as an embedded
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `Student` class, we routinely notice that `Student` is derived
    from `Person`. As we already know, this means that a `Student` instance will include
    the memory layout of a `Person`, as a `Person` subobject.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice the data member, `Id studentId;`, in the `Student` class definition.
    Here, `studentId` is of type `Id`. It is not a pointer, nor is it a reference
    to an `Id`. Data member `studentId` is an embedded (that is, an aggregate or member)
    object. This means that when a `Student` class is instantiated, not only will
    the memory from inherited classes be included but also the memory for any embedded
    objects. We will need to provide a means to initialize the embedded object, `studentId`.
    Note, we have seen member objects before, such as data members of type `string`;
    that is, data members that are of another class type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move forward with the `Student` member functions to understand how we
    may initialize, manipulate, and access the embedded object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed member functions of `Student`, let’s begin with our
    constructors. Notice in the default constructor, we utilize the member initialization
    list (`:`) to specify `studentId(to_string(numStudents + 100) + "Id")`. Because
    `studentId` is a member object, we have the opportunity to select (via the member
    initialization list) which constructor should be used for its initialization.
    Here, we merely select the one with the `Id(const string &)` signature. In the
    absence of a specific value to use to initialize `Id`, we manufacture a string
    value to serve as the needed ID.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in the alternate constructor for `Student`, we use the member initialization
    list to specify `studentId(id)`, which will also select the `Id(const string &)`
    constructor, passing the parameter `id` to this constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The copy constructor for `Student` additionally specifies how to initialize
    the `studentId` member object with the `studentId(s.studentId)` specification
    in the member initialization list. Here, we simply call the copy constructor for
    `Id`.
  prefs: []
  type: TYPE_NORMAL
- en: In our destructor for `Student`, we do not need to deallocate `studentId`. As
    this data member is an embedded (aggregate) object, its memory will go away when
    the memory for the outer object goes away. Of course, because `studentId` is an
    object itself, its own destructor will first be called before its memory is released.
    Under the hood, the compiler will (covertly) patch in a call to the `Id` destructor
    for `studentId` as the last line of code in the `Student` destructor. Actually,
    this will be the penultimate (next to last) implicit line in the destructor –
    the last line that will be covertly patched in will be a call to the `Person`
    destructor (to continue the destruction sequence).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the previous segment of code, let’s notice the call to `studentId.GetId()`,
    which occurs in both `Student::Print()` and `Student::GetStudentId()`. Here, the
    embedded object `studentId` calls its own public function `Id::GetId()` to retrieve
    its private data member in the scope of the `Student` class. Because `studentId`
    is private in `Student`, this embedded object may only be accessed within the
    scope of `Student` (that is, member functions of `Student`). However, the addition
    of `Student::GetStudentId()` provides a public wrapper for `Student` instances
    in other scopes to retrieve this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s take a look at our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned `main()` function, we instantiate two `Student` instances:
    `s1` and `s2`. When the memory is created (in this case, on the stack) for each
    `Student`, memory for any inherited classes will also be included as subobjects.
    Additionally, memory for any embedded objects, such as `Id`, will also be laid
    out as a subobject within `Student`. The memory for the contained object, or *part*,
    will be allocated along with the allocation for the outer object, or *whole*.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s notice the access to the contained piece, the embedded `Id` object.
    We start with a call to `s1.GetStudentId()`; `s1` accesses a `Student` member
    function, `GetStudentId()`. That student member function will utilize the member
    object of `studentId` to call `Id::GetId()` on this inner object of type `Id`.
    The member function `Student::GetStudentId()` can implement this desired public
    access by simply returning the value that `Id::GetId()` returns on the embedded
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example details composition with its typical implementation, an embedded
    object. Let’s now take a look at a much less used, alternate implementation –
    that of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Considering an alternate implementation for composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is useful to understand that composition can alternatively be implemented
    using inheritance, however, this is extremely controversial. Remember, inheritance
    is most often used to implement *Is-A* and not *Has-A* relationships. We briefly
    described using inheritance to implement Has-A relationships in [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426),
    *Exploring Multiple Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, you would simply inherit from the *part*, rather than embed the part
    as a data member. When doing so, you no longer need to provide *wrapper* functions
    to the *part*, such as we saw in the previous program, with the `Student::GetStudentId()`
    method calling `studentId.GetId()` to provide access to its embedded part. The
    wrapper function was necessary with the embedded object example, as the part (`Id`)
    was private in the whole (`Student`). Programmers could not have accessed the
    private `studentId` data member of `Student` outside the scope of `Student`. Of
    course, member functions of `Student` (such as `GetStudentId()`) can access their
    own class’ private data members and in doing so, can implement the `Student::GetStudentId()`
    wrapper function to provide such (safe) access.
  prefs: []
  type: TYPE_NORMAL
- en: Had inheritance been used, the public interface of `Id::GetId()` would have
    been simply inherited as a public interface in `Student`, providing simple access
    without the need to first go through the embedded object explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, though inheriting a *part* is simple in some ways, it vastly compounds
    multiple inheritance. We know multiple inheritance can provide many potential
    complications. Also, using inheritance, the *whole* can only contain one of each
    *part* – not multiples of a *part*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, implementing a whole-part relationship with inheritance may be
    confusing when you compare the implementation to the OO design. Remember, inheritance
    usually means *Is-A* and not *Has-A*. For these reasons, the most typical and
    appreciated implementation of an aggregate is through an embedded object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s move onward by looking at a more general form of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and implementing a generalized aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at the most commonly used form of aggregation in OO designs,
    that of composition. Most notably, with composition, we have seen that the part
    does not have a reason to exist without the whole. Nonetheless, a more generalized
    (but less common) form of aggregation exists and is sometimes specified in OO
    designs. We will now consider this less common form of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: In a **generalized aggregation**, a *part* may exist without the *whole*. A
    part will be created separately and then attached to the whole at a later point
    in time. When the *whole* goes away, a *part* may then remain to be salvaged for
    use with another outer or *whole* object.
  prefs: []
  type: TYPE_NORMAL
- en: In a generalized aggregation, the Has-A relationship certainly applies, as does
    the whole-part designation. The difference is that the *whole* object will not
    create nor destroy a *part* subobject. Consider the straightforward example that
    a `Car` *Has-A(n)* `Engine`. A `Car` object also *Has-A* set of four `Tire` objects.
    The `Engine` or `Tire` objects can be manufactured separately and then passed
    to the constructor of the `Car` to provide these parts to the whole. Yet should
    an `Engine` be destroyed, a new `Engine` can easily be swapped out (using a member
    function), without requiring the entire `Car` to be destroyed and then reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: A generalized aggregation is equivalent to a Has-A relationship, yet we think
    of this with more flexibility and permanence of the individual parts as we did
    with composition. We consider this relationship as an aggregation simply because
    we wish to equate the objects with a Has-A meaning. The Has-A relationship in
    the `Car`, `Engine`, and `Tire` example is strong; the `Engine` and `Tire`s are
    necessary parts, required to make the whole `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, implementation typically is with the *whole* containing a pointer (or
    set of pointers) to the *part(s)*. It is important to note that the parts will
    be passed into a constructor (or another member function) of the outer object
    to establish the relationship. The critical marker is that the whole will not
    create (nor destroy) the parts, and the parts will never destroy the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the longevity of the individual pieces (and the basic implementation)
    of a generalized aggregation will be similar to our next topic – association.
    Let’s move forward to our next section to understand the similarities, as well
    as the OO conceptual differences (sometimes subtle) between generalized aggregation
    and association.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **association** models a relationship that exists between otherwise unrelated
    class types. An association can provide ways for objects to interact to fulfill
    these relationships. Associations are not used for Has-A relationships, however,
    in some cases, there are shades of gray as to whether we’re describing a bonafide
    Has-A relationship, or whether we are merely using the phrase Has-A because it
    sounds appropriate linguistically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplicity for associations exists: one-to-one, one-to-many, many-to-one,
    or many-to-many. For example, a `Student` may be associated with a single `University`,
    and that `University` may be associated with many `Student` instances; this is
    a one-to-many association.'
  prefs: []
  type: TYPE_NORMAL
- en: Associated objects have an independent existence. That is, two or more objects
    may be instantiated and exist independently for a portion of the application.
    At some point, one object may wish to assert a dependency or relationship with
    the other object. Later in the application, the associated objects may part ways
    and continue on their own unrelated paths.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the relationship between a `Course` and an `Instructor`.
    A `Course` is associated with an `Instructor`. A `Course` requires an `Instructor`;
    an `Instructor` is integral to the `Course`. An `Instructor` may be associated
    with many `Course`(s). Yet each part exists independently – one will not create
    nor destroy the other. Instructors may also exist independently without courses;
    perhaps an instructor is taking time to write a book, is taking a sabbatical,
    or is a professor conducting research.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the association is very similar to a generalized aggregation.
    In both cases, the related objects also exist independently. In this case, whether
    one says that `Course` Has-A(n) `Instructor` or that a `Course` has a dependency
    on an `Instructor`, can be a shade of gray. You may ask yourself – is it just
    spoken language that makes me choose the wording of Has-A? Do I instead mean that
    there is a necessary link between the two? Perhaps the relationship is an association,
    and its descriptive adornment (to further describe the nature of the association)
    is *teaches*. You may have arguments supporting either choice. For this reason,
    generalized aggregations can be considered specialized types of associations;
    we will see that their implementations are the same using independently existing
    objects. Nonetheless, we will distinguish a typical association as being a relationship
    between objects that decisively do not support a true Has-A relationship.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the relationship between `University` and `Instructor`.
    Rather than thinking of this as a Has-A relationship, we may instead consider
    the relationship between the two as that of association; we can think of the adornment
    describing this relationship as *employs*. Likewise, `University` ascertains a
    relationship with many `Student` objects. The association here may be described
    by the adornment *educates*. The distinction can be made that `University` is
    made up of `Department` objects, `Building` objects, and components of this nature
    to support any of its Has-A relationships through containment, yet its relationships
    with `Instructor` objects, `Student` objects, and so on are made using associations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have distinguished typical associations from generalized aggregations,
    let’s take a look at how we can implement associations and some of the complexities
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, an association between two or more objects is implemented using pointers
    or sets of pointers. The *one* side is implemented using a pointer to the associated
    object, whereas the *many* side of the relationship is implemented as a set of
    pointers to the associated objects. A set of pointers may be an array of pointers,
    a linked list of pointers, or truly any collection of pointers. Each type of collection
    will have its own set of advantages and drawbacks. For example, arrays of pointers
    are easy to use, have direct access to specific members, yet have a fixed number
    of items. Linked lists of pointers can accommodate any quantity of items, yet
    accessing a specific element requires traversing past others to find the desired
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, a reference may be used to implement the *one* side of an association.
    Recall that a reference must be initialized and cannot at a later date be reset
    to reference another object. Using a reference to model an association implies
    that one instance will be associated with a precise other instance for the duration
    of the primary object’s existence. This is extremely restrictive, so references
    are used very infrequently to implement associations.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the implementation, when the primary object goes away, it will
    not interfere with (that is, delete) the associated object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a typical example illustrating the preferred implementation of a one-to-many
    association, utilizing a pointer on the *one* side, and a set of pointers on the
    *many* side. In this example, a `University` will be associated with many `Student`
    instances. And, for simplicity, a `Student` will be associated with a single `University`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save space, some portions of this program that are the same as in our last
    example will not be shown; however, the program in its entirety can be found in
    our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding segment, let’s first notice the forward declaration of `class
    Student;`. This declaration will allow our code to reference the `Student` type
    prior to the `Student` class definition. In the `University` class definition,
    we see that there is an array of pointers to `Student`. We also see that the `EnrollStudent()`
    method takes a `Student *` as an argument. The forward declaration enables such
    usage of `Student` prior to its definition.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that the `University` has a simple interface with constructors,
    a destructor, and a few member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at the `University` member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Taking a closer look at the aforementioned `University` methods, we can see
    that in both constructors for `University`, we could alternatively null out the
    pointers to the elements comprising our `studentBody` using `nullptr` (versus
    our choice of using in-class initialization, which similarly initializes each
    element). Likewise, in the destructor, we similarly null out our links to the
    associated `Student` instances. Shortly in this section, we will see that there
    will be some additional backlink maintenance required, but for now, the point
    is that we will not delete the associated `Student` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since `University` objects and `Student` objects will exist independently, neither
    will create nor destroy instances of the other type.
  prefs: []
  type: TYPE_NORMAL
- en: We also come across an interesting member function, `EnrollStudent(Student *)`.
    In this method, a pointer to a specific `Student` will be passed in as an input
    parameter. We merely index into our array of pointers to `Student` objects, namely
    `studentBody`, and set an unused array element point to the newly enrolled `Student`.
    We keep track of how many current `Student` objects exist using a `currentNumStudents`
    counter, which is incremented with a post increment after the pointer assignment
    to the array is made.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that the `University` class has a `Print()` method that prints
    the university’s name, followed by its current student body. It does so by simply
    accessing each associated `Student` object in `studentBody` and asking each `Student`
    instance to invoke the `Student::GetFirstName()` and `Student::GetLastName()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s now take a look at our `Student` class definition, along with its
    inline functions. Recall that we’re assuming that the `Person` class is the same
    as seen earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the previous code segment, we see the `Student` class definition. Notice
    that we have an association with a University with the pointer data member `University
    *univ = nullptr;` and that this member is initialized to `nullptr` using in-class
    initialization.
  prefs: []
  type: TYPE_NORMAL
- en: In the class definition for `Student`, we can also see there is a wrapper function
    to encapsulate access to the student’s university’s name with `Student::GetUniversity()`.
    Here, we allow the associated object, `univ`, to call its public method `University::GetName()`
    and return that value as the result of `Student::GetUniversity()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the non-inline member functions of `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code segment, notice that the default `Student` constructor
    and the destructor both only null out their link to the `University` object (using
    `nullptr`). The default constructor has no way to set this link to an existing
    object, and should certainly not create a `University` instance to do so. Likewise,
    the `Student` destructor should not delete the `University` merely because the
    `Student` object’s life expectancy is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting part of the preceding code happens in both the alternate
    constructor and copy constructor of `Student`. Let’s examine the alternate constructor.
    Here, we establish the link to the associated `University` as well as the backlink
    from the `University` back to the `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `this->univ = univ;` line of code, we are assigning the data member,
    `univ` (as pointed to by the `this` pointer) by setting it to point to where the
    input parameter, `univ`, points. Look closely at the previous class definition
    – the identifier for the `University *` is named `univ`. Additionally, the input
    parameter for the `University *` in the alternate constructor is named `univ`.
    We cannot simply assign `univ = univ;` in the body of this constructor (or in
    the member initialization list). The `univ` identifier that is in the most local
    scope is the input parameter, `univ`. Assigning `univ = univ;` would set this
    parameter to itself. Instead, we disambiguate the `univ` on the left-hand side
    of this assignment using the `this` pointer. The statement `this->univ = univ;`
    sets the data member `univ` to the input parameter `univ`. Could we merely have
    renamed the input parameter something different, such as `u`? Sure, but it is
    important to understand how to disambiguate an input parameter and data member
    with the same identifier when the need arises to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the next line of code, `univ->EnrollStudent(this);`. Now
    that `univ` and `this->univ` point to the same object, it does not matter which
    is used to set the backlink. Here, `univ` calls `EnrollStudent()`, which is a
    public member function in the `University` class. No problem, `univ` is of type
    `University`. `University::EnrollStudent(Student *)` expects to be passed a pointer
    to a `Student` to complete the linkage on the `University` side. Luckily, the
    `this` pointer in our `Student` alternate constructor (the scope of the calling
    function) is a `Student *`. The `this` pointer (in the alternate constructor)
    is literally the `Student *` that we need to create the backlink. Here is another
    example where the explicit use of the `this` pointer is required to complete the
    task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move forward to our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the previous code fragment in our `main()` function, we can create
    several independently existing objects, create an association between them, and
    then view that relationship in action.
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a `University`, namely `u1`. Next, we instantiate three
    `Student` objects, `s1`, `s2`, and `s3`, and associate each to `University u1`.
    Note that this association can be set when we instantiate a `Student`, or later
    on, for example, if the `Student` class supported a `SelectUniveristy(University
    *)` interface to do so.
  prefs: []
  type: TYPE_NORMAL
- en: We then print out each `Student`, along with the name of the `University` each
    `Student` attends. Then, we print out the student body for our `University`, `u1`.
    We notice that the link built between the associated objects is complete in both
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen how easily associations can be set up and utilized between related
    objects. However, a lot of housekeeping will arise from implementing associations.
    Let’s move forward to understanding the necessary and related issues of reference
    counting and backlink maintenance, which will help with these housekeeping endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing backlink maintenance and reference counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous subsection, we have seen how to implement associations using
    pointers. We’ve seen how to link an object with a pointer to an object in an associated
    instance. And we’ve seen how to complete the circular, two-sided relationship
    by establishing a backlink.
  prefs: []
  type: TYPE_NORMAL
- en: However, as is typical for associated objects, the relationships are fluid and
    change over time. For example, the given `Student` body will change quite often
    for a given `University`, or the various `Course` set an `Instructor` will teach
    will change each semester. It will be typical, then, to remove a particular object’s
    association to another object, and perhaps associate, instead, to a different
    instance of that class. But, that also means that the associated object must know
    to remove its link to the first mentioned object. This becomes complicated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the `Student` and `Course` relationship. A `Student` is
    enrolled in many `Course` instances. A `Course` contains an association to many
    `Student` instances. This is a many-to-many association. Let’s imagine that the
    `Student` wishes to drop a `Course`. It is not enough for a specific `Student`
    instance to remove a pointer to a specific `Course` instance. Additionally, the
    `Student` must let the particular `Course` instance know that the `Student` in
    question should be removed from that `Course`’s roster. This is known as backlink
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what would happen in the above scenario if a `Student` were to simply
    null out its link to the `Course` it was dropping, and do nothing further. The
    `Student` instance in question would be fine. However, the formerly associated
    `Course` instance would still contain a pointer to the `Student` in question.
    Perhaps this would equate to the `Student` receiving a failing grade in the `Course`
    as the `Instructor` still thinks the `Student` in question is enrolled, yet hasn’t
    been turning in their homework. In the end, the `Student` has been affected after
    all, with the failing grade.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, with associated objects, one object will not delete the other when
    it is done with the other object. For example, when a `Student` drops a `Course`,
    they will not delete that `Course` – only remove their pointer to the `Course`
    in question (and definitely also handle the required backlink maintenance).
  prefs: []
  type: TYPE_NORMAL
- en: One idea to help us with overall link maintenance is to consider **reference
    counting**. The purpose of reference counting is to keep track of how many pointers
    may be pointing to a given instance. For example, if other objects point to a
    given instance, that instance should not be deleted. Otherwise, the pointers in
    the other object will point to deallocated memory, which will lead to numerous
    runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an association with multiplicity, such as the relationship between
    a `Student` and a `Course`. A `Student` should keep track of how many `Course`
    pointers are pointing to the `Student`, that is, how many `Courses` the `Student`
    is taking. A `Student` should not be deleted while various `Courses` point to
    that `Student`. Otherwise, `Courses` will point to deleted memory. One way to
    handle this situation is to check within the `Student` destructor whether the
    object (`this`) contains any non-null pointers to `Course` instances. If the object
    does, it then needs to call a method through each of the active `Course` instances
    to request links to the `Student` be removed from each such `Course`. After each
    link is removed, the reference counter corresponding to the set of `Course` instances
    can be decremented.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, link maintenance should occur in the `Course` class in favor of `Student`
    instances. `Course` instances should not be deleted until all `Student` instances
    enrolled in that `Course` have been notified. Keeping a counter of how many `Student`
    instances point to a particular instance of a `Course` through reference counting
    is helpful. In this example, it is as simple as maintaining a variable to reflect
    the current number of `Student` instances enrolled in the `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: We can meticulously conduct link maintenance ourselves, or we may choose to
    use smart pointers to manage the lifetime of an associated object. **Smart pointers**
    can be found in the C++ Standard Library. They encapsulate a pointer (that is,
    wrap a pointer within a class) to add smart features, including reference counting
    and memory management. Because smart pointers utilize templates, which we will
    not cover until [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with
    Templates*, we will just mention their potential utility here.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen the importance of backlink maintenance and the utility of reference
    counting to fully support associations and their successful implementation. Let’s
    now briefly recap the OO concepts we’ve covered in this chapter – association,
    aggregation, and composition – before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have pressed forward with our pursuit of object-oriented
    programming by exploring various object relationships – association, aggregation,
    and composition. We have understood the various OO design concepts representing
    these relationships and have seen that C++ does not offer direct language support
    through keywords or specific language features to implement these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, we have learned several techniques for implementing these core
    OO relationships, such as embedded objects for composition and generalized aggregation,
    or using pointers to implement association. We have looked at the typical longevity
    of object existence with these relationships; for example, with aggregation, by
    creating and destroying its inner part (through an embedded object, or more rarely,
    by allocating and deallocating a pointer member). Or through the independent existence
    of associated objects that neither create nor destroy one another. We have also
    looked under the hood at the housekeeping required to implement association, particularly
    associations with multiplicity, by examining backlink maintenance and reference
    counting.
  prefs: []
  type: TYPE_NORMAL
- en: We have added key features to our OOP skills through understanding how to implement
    association, aggregation, and composition. We have seen examples of how these
    relationships may even be more prolific in OO designs than inheritance. By mastering
    these skills, we have completed our core skillset of implementing essential OO
    concepts in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions*, which will begin our quest to expand our C++ programming
    repertoire. Let’s continue forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add an additional `Student` constructor to the `University`/`Student` example
    in this chapter to accept the `University` constructor argument by reference,
    rather than by pointer. For example, in addition to the constructor with the signature
    `Student::Student(const string &fn, const string &ln, char mi, const string &t,
    float avg, const string &course, const string &id, University *univ);`, overload
    this function with a similar one, but with `University &univ` as the last parameter.
    How does this change the implicit call to this constructor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: within your overloaded constructor, you will now need to take the address-of
    (`&`) the `University` reference parameter to set the association (which is stored
    as a pointer). You may need to switch to object notation (`.`) to set the backlink
    (if you use parameter `univ`, versus data member `this->univ`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a C++ program to implement a many-to-many association between objects
    of type `Course` and of type `Student`. You may choose to build on your previous
    programs that encapsulate `Student`. The many-to-many relationship should work
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A given `Student` may take zero to many `Course`s, and a given `Course` will
    associate to many `Student` instances. Encapsulate the `Course` class to minimally
    contain a course name, a set of pointers to associated `Student` instances, and
    a reference count to keep track of the number of `Student` instances that are
    in the `Course` (this will equate to how many `Student` instances point to a given
    instance of a `Course`). Add the appropriate interface to reasonably encapsulate
    this class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to your `Student` class a set of pointers to the `Course` instances in which
    that `Student` is enrolled. Additionally, keep track of how many `Course` instances
    a given `Student` is currently enrolled. Add appropriate member functions to support
    this new functionality.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Model your many-sided associations using either a linked list of pointers (that
    is, the data part is a pointer to the associated object) or as an array of pointers
    to the associated objects. Note that an array will enforce a limit on the number
    of associated objects you can have, however, this may be reasonable because a
    given `Course` can only accommodate a maximum number of `Student`s and a `Student`
    may only enroll up to a maximum number of `Course`s per semester. If you choose
    the array of pointers approach, make sure your implementation includes error checking
    to accommodate exceeding the maximum number of associated objects in each array.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to check for simple errors, such as trying to add `Student`s to a `Course`
    that is full, or adding too many `Course`s to a `Student`’s schedule (assume there
    is an upper bound to five courses per semester).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your destructors do not delete the associated instances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce at least three `Student` objects, each of which takes two or more
    `Course`s. Additionally, make sure each `Course` has multiple `Student`s enrolled.
    Print each `Student`, including each `Course` in which they are enrolled. Likewise,
    print each `Course`, showing each `Student` enrolled in the `Course`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '(Optional) Enhance your program in *Exercise 2* to gain experience with backlink
    maintenance and reference counting as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `DropCourse()` interface for `Student`. That is, create a `Student::
    DropCourse(Course *)` method in `Student`. Here, find the `Course` the `Student`
    wishes to drop in their course list, but before removing the `Course`, call a
    method on that `Course` to remove the aforementioned `Student` (that is, `this`)
    from the `Course`. Hint: you can make a `Course::RemoveStudent(Student *)`) method
    to help with backlink removal.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, fully implement proper destructors. When a `Course` is destructed, have
    the `Course` destructor first tell each remaining associated `Student` to remove
    their link to that `Course`. Likewise, when a `Student` is destructed, loop through
    the `Student`’s course list to ask those `Courses` to remove the aforementioned
    `Student` (that is, `this`) from their student list. You may find reference counting
    in each class (that is, by checking `numStudents` or `numCourses`) helpful to
    see whether these tasks must be engaged.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your C++ Programming Repertoire'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to expand your C++ programming skills, beyond the OOP
    skills, to encompass other critical features of C++.
  prefs: []
  type: TYPE_NORMAL
- en: The initial chapter in this section explores exception handling in C++ through
    understanding the mechanisms of `try`, `throw`, and `catch`, and through examining
    many examples to explore exception mechanics by delving into various exception
    handling scenarios. Additionally, this chapter expands exception class hierarchies
    with new exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter digs into the topics of the proper usage of friend functions
    and friend classes, as well as operator overloading (which may sometimes require
    friends), to make operations polymorphic between built-in and user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent chapter explores using C++ templates to help make code generic
    and usable for a variety of data types using template functions and template classes.
    Additionally, this chapter explains how operator overloading will assist in making
    template code extensible for virtually any data type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the Standard Template Library in C++ is introduced, and
    core STL containers such as `list`, `iterator`, `deque`, `stack`, `queue`, `priority_queue`,
    and `map` (including one using a functor) are examined. Additionally, STL algorithms
    and functors are introduced.
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter in this section surveys testing OO programs and components
    by exploring canonical class form, creating drivers for component testing, testing
    classes related through inheritance, association, aggregation, and testing exception-handling
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19087_11.xhtml#_idTextAnchor488), *Handling Exceptions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19087_14.xhtml#_idTextAnchor595), *Understanding STL Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19087_15.xhtml#_idTextAnchor655), *Testing Classes and Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your C++ Programming Repertoire'
  prefs: []
  type: TYPE_NORMAL
