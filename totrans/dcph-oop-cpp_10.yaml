- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Association, Aggregation, and Composition
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue advancing our knowledge of object-oriented programming
    in C++. We will augment our understanding of object relationships by exploring
    the object-oriented concepts of association, aggregation, and composition. None
    of these OO concepts have direct language support in C++; we will instead learn
    multiple programming techniques to implement these ideas. We will also understand
    which implementation techniques are preferred for various concepts, as well as
    the advantages and pitfalls of various practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Association, aggregation, and composition occur copiously in OO designs. It
    is crucial to understand how to implement these important object relationships.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concepts of aggregation and composition, and various implementations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the OO concept of association and its implementation, including
    the importance of backlink maintenance and the utility of reference counting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concepts of association,
    aggregation, and composition, and how to implement these relationships in C++.
    You will also understand many housekeeping approaches necessary to keep these
    relationships up to date, such as reference counting and backlink maintenance.
    Though the concepts are relatively straightforward, you will see why there is
    a substantial amount of bookkeeping required to maintain accuracy for these types
    of object relationships.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Let’s broaden our understanding of C++ as an OOP language by exploring these
    core object relationships.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter10`
    in a file named `Chp10-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3clgvGe](https://bit.ly/3clgvGe).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding aggregation and composition
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object-oriented concept of aggregation arises in many OO designs. It comes
    up as frequently as inheritance does to specify object relationships. **Aggregation**
    is used to specify Has-A, whole-part, and in some cases, containment relationships.
    A class may contain aggregates of other objects. Aggregation can be broken into
    two categories – *composition* as well as a less strict and *generalized* form
    of aggregation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Both **generalized aggregation** and **composition** imply a Has-A or whole-part
    relationship. However, the two differ in the existence requirements between the
    two related objects. With generalized aggregation, the objects can exist independently
    from one another, yet with composition, the objects cannot exist without one another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通用聚合和组合都暗示了“拥有”或整体-部分关系。然而，这两个相关对象的存在要求之间存在差异。在通用聚合中，对象可以独立存在，而在组合中，对象不能没有对方而存在。
- en: Let’s take a look at each variety of aggregation, starting with composition.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看聚合的每一种类型，从组合开始。
- en: Defining and implementing composition
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和实现组合
- en: '**Composition** is the most specialized form of aggregation and is often what
    most OO designers and programmers think of when they consider aggregation. Composition
    implies containment, and is most often synonymous with a whole-part relationship
    – that is, the whole entity is composed of one or more parts. The whole *contains*
    the parts. The Has-A relationship will also apply to composition.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**是聚合最特殊的形式，并且通常是大多数面向对象的设计师和程序员在考虑聚合时首先想到的。组合意味着包含，通常与整体-部分关系同义——也就是说，整体实体由一个或多个部分组成。整体包含部分。拥有关系也将适用于组合。'
- en: The outer object, or *whole*, can be made up of *parts*. With composition, parts
    do not exist without the whole. Implementation is usually an embedded object –
    that is, a data member of the contained object type. On rare occasions, the outer
    object will contain a pointer or reference to the contained object type; however,
    when this occurs, the outer object will be responsible for the creation and destruction
    of the inner object. The contained object has no purpose without its outer layer.
    Likewise, the outer layer is not *ideally* complete without its inner, contained
    pieces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 外部对象，或整体，可以由部分组成。在组合中，部分的存在依赖于整体。实现通常是嵌入的对象——也就是说，是包含对象类型的成员数据。在罕见的情况下，外部对象将包含指向包含对象类型的指针或引用；然而，当这种情况发生时，外部对象将负责创建和销毁内部对象。没有外部层，包含对象就没有任何目的。同样，没有其内部包含的部分，外部层也不是理想上完整的。
- en: Let’s take a look at a composition as typically implemented. The example will
    illustrate containment – a `Student` *Has-A(n)* `Id`. More so, we will imply that
    an `Id` is a necessary part of a `Student` and will not exist without a `Student`.
    `Id` objects on their own serve no purpose. `Id` objects simply do not need to
    exist if they are not a part of a primary object that gives them purpose. Likewise,
    you might argue that a `Student` is incomplete without an `Id`, though this is
    a bit subjective! We will implement the *part* using an embedded object within
    the *whole*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个通常实现的组合。示例将展示包含——一个`Student`拥有一个`Id`。更进一步，我们将暗示`Id`是`Student`的一个必要部分，没有`Student`它将不存在。单独的`Id`对象没有任何作用。如果它们不是赋予它们目的的主要对象的一部分，`Id`对象就无需存在。同样，你可能会说，没有`Id`，`Student`就不完整，尽管这有点主观！我们将使用嵌入在整体中的对象来实现部分。
- en: 'The composition example will be broken into many segments. Though only portions
    of the example are shown, the full program can be found in the following GitHub
    location:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组合示例将被分成许多部分。尽管只展示了示例的一部分，但完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code fragment, we have defined an `Id` class. An `Id` will be
    a class that can be contained by other classes needing a fully functional `Id`
    capability. The `Id` will become a *part* of any *whole* object that may choose
    to contain it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们定义了一个`Id`类。`Id`将是一个可以被其他需要完全功能的`Id`能力的类所包含的类。`Id`将成为任何可能选择包含它的任何整体对象的一部分。
- en: 'Let’s move onward to build a set of classes that will ultimately contain this
    `Id`. We will start with a class we are familiar with, `Person`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，构建一组最终将包含这个`Id`的类。我们将从一个我们熟悉的类`Person`开始：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous segment of code, we have defined the `Person` class, as we are
    accustomed to describing it. To abbreviate this example, let us assume that the
    accompanying member functions exist as prototyped in the aforementioned class
    definition. You can reference these member functions in the earlier provided GitHub
    link for online code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们已经定义了`Person`类，正如我们习惯描述的那样。为了简化这个例子，让我们假设伴随的成员函数如上述类定义中原型所示存在。您可以在之前提供的GitHub链接中参考这些成员函数的在线代码。
- en: 'Now, let’s define our `Student` class. Though it will contain elements that
    we are accustomed to seeing, `Student` will also contain an `Id` as an embedded
    object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的`Student`类。尽管它将包含我们习惯看到的元素，但`Student`还将包含一个作为嵌入对象的`Id`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding `Student` class, we routinely notice that `Student` is derived
    from `Person`. As we already know, this means that a `Student` instance will include
    the memory layout of a `Person`, as a `Person` subobject.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的`Student`类中，我们通常会注意到`Student`是从`Person`派生出来的。正如我们已经知道的，这意味着一个`Student`实例将包含一个`Person`的内存布局，作为一个`Person`子对象。
- en: However, notice the data member, `Id studentId;`, in the `Student` class definition.
    Here, `studentId` is of type `Id`. It is not a pointer, nor is it a reference
    to an `Id`. Data member `studentId` is an embedded (that is, an aggregate or member)
    object. This means that when a `Student` class is instantiated, not only will
    the memory from inherited classes be included but also the memory for any embedded
    objects. We will need to provide a means to initialize the embedded object, `studentId`.
    Note, we have seen member objects before, such as data members of type `string`;
    that is, data members that are of another class type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意`Student`类定义中的数据成员`Id studentId;`。在这里，`studentId`是`Id`类型。它不是一个指针，也不是`Id`的引用。数据成员`studentId`是一个嵌入对象（即聚合或成员对象）。这意味着当`Student`类被实例化时，不仅将包含从继承的类中继承的内存，还包括任何嵌入对象的内存。我们需要提供一种初始化嵌入对象`studentId`的方法。注意，我们之前已经见过成员对象，例如类型为`string`的数据成员；即数据成员是另一个类类型。
- en: 'Let’s move forward with the `Student` member functions to understand how we
    may initialize, manipulate, and access the embedded object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，通过`Student`成员函数来了解我们如何初始化、操作和访问嵌入的对象：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previously listed member functions of `Student`, let’s begin with our
    constructors. Notice in the default constructor, we utilize the member initialization
    list (`:`) to specify `studentId(to_string(numStudents + 100) + "Id")`. Because
    `studentId` is a member object, we have the opportunity to select (via the member
    initialization list) which constructor should be used for its initialization.
    Here, we merely select the one with the `Id(const string &)` signature. In the
    absence of a specific value to use to initialize `Id`, we manufacture a string
    value to serve as the needed ID.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的`Student`成员函数中，让我们从构造函数开始。注意在默认构造函数中，我们利用成员初始化列表（`:`）来指定`studentId(to_string(numStudents
    + 100) + "Id")`。因为`studentId`是一个成员对象，所以我们有机会（通过成员初始化列表）选择用于其初始化的构造函数。在这里，我们只是选择具有`Id(const
    string &)`签名的构造函数。如果没有特定的值用于初始化`Id`，我们将制造一个字符串值来作为所需的ID。
- en: Similarly, in the alternate constructor for `Student`, we use the member initialization
    list to specify `studentId(id)`, which will also select the `Id(const string &)`
    constructor, passing the parameter `id` to this constructor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`Student`的另一个构造函数中，我们使用成员初始化列表来指定`studentId(id)`，这也会选择`Id(const string &)`构造函数，并将参数`id`传递给这个构造函数。
- en: The copy constructor for `Student` additionally specifies how to initialize
    the `studentId` member object with the `studentId(s.studentId)` specification
    in the member initialization list. Here, we simply call the copy constructor for
    `Id`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`的拷贝构造函数还额外指定了如何使用成员初始化列表中的`studentId(s.studentId)`规范来初始化`studentId`成员对象。在这里，我们只是调用了`Id`的拷贝构造函数。'
- en: In our destructor for `Student`, we do not need to deallocate `studentId`. As
    this data member is an embedded (aggregate) object, its memory will go away when
    the memory for the outer object goes away. Of course, because `studentId` is an
    object itself, its own destructor will first be called before its memory is released.
    Under the hood, the compiler will (covertly) patch in a call to the `Id` destructor
    for `studentId` as the last line of code in the `Student` destructor. Actually,
    this will be the penultimate (next to last) implicit line in the destructor –
    the last line that will be covertly patched in will be a call to the `Person`
    destructor (to continue the destruction sequence).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Student` 析构函数中，我们不需要释放 `studentId` 的内存。因为这个数据成员是一个嵌入的（聚合）对象，其内存将在外部对象的内存释放时消失。当然，因为
    `studentId` 本身也是一个对象，所以它的析构函数将在其内存释放之前首先被调用。在底层，编译器将（隐式地）在 `Student` 析构函数的最后一条代码中插入对
    `Id` 析构函数的调用。实际上，这将是析构函数中的倒数第二行隐式插入的代码——最后将被隐式插入的将是调用 `Person` 析构函数（以继续销毁序列）。
- en: Lastly, in the previous segment of code, let’s notice the call to `studentId.GetId()`,
    which occurs in both `Student::Print()` and `Student::GetStudentId()`. Here, the
    embedded object `studentId` calls its own public function `Id::GetId()` to retrieve
    its private data member in the scope of the `Student` class. Because `studentId`
    is private in `Student`, this embedded object may only be accessed within the
    scope of `Student` (that is, member functions of `Student`). However, the addition
    of `Student::GetStudentId()` provides a public wrapper for `Student` instances
    in other scopes to retrieve this information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在之前的代码段中，让我们注意对 `studentId.GetId()` 的调用，这在 `Student::Print()` 和 `Student::GetStudentId()`
    中都发生了。在这里，嵌入对象 `studentId` 调用其自己的公共函数 `Id::GetId()` 来检索其在 `Student` 类作用域内的私有数据成员。因为
    `studentId` 在 `Student` 中是私有的，这个嵌入对象只能在其作用域内（即 `Student` 的成员函数）访问。然而，`Student::GetStudentId()`
    的添加为其他作用域中的 `Student` 实例提供了一个公共包装器来检索此信息。
- en: 'Finally, let’s take a look at our `main()` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下我们的 `main()` 函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the aforementioned `main()` function, we instantiate two `Student` instances:
    `s1` and `s2`. When the memory is created (in this case, on the stack) for each
    `Student`, memory for any inherited classes will also be included as subobjects.
    Additionally, memory for any embedded objects, such as `Id`, will also be laid
    out as a subobject within `Student`. The memory for the contained object, or *part*,
    will be allocated along with the allocation for the outer object, or *whole*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的 `main()` 函数中，我们创建了两个 `Student` 实例：`s1` 和 `s2`。当为每个 `Student` 创建内存（在这种情况下，在栈上）时，任何继承的类的内存也将作为子对象包含在内。此外，任何嵌入的对象，如
    `Id`，也将作为 `Student` 内部的子对象进行布局。包含的对象，或称为 *部分*，将与外部对象，或称为 *整体*，的分配一起分配。
- en: Next, let’s notice the access to the contained piece, the embedded `Id` object.
    We start with a call to `s1.GetStudentId()`; `s1` accesses a `Student` member
    function, `GetStudentId()`. That student member function will utilize the member
    object of `studentId` to call `Id::GetId()` on this inner object of type `Id`.
    The member function `Student::GetStudentId()` can implement this desired public
    access by simply returning the value that `Id::GetId()` returns on the embedded
    object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们注意对包含部分的访问，即嵌入的 `Id` 对象。我们从调用 `s1.GetStudentId()` 开始；`s1` 访问一个 `Student`
    成员函数，`GetStudentId()`。这个学生成员函数将利用 `studentId` 的成员对象来调用 `Id::GetId()`，这是 `Id` 类型的内部对象。`Student::GetStudentId()`
    成员函数可以通过简单地返回 `Id::GetId()` 在嵌入对象上返回的值来实现所需的公共访问。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下上述程序的输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example details composition with its typical implementation, an embedded
    object. Let’s now take a look at a much less used, alternate implementation –
    that of inheritance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子详细介绍了组合及其典型实现，即嵌入对象。现在，让我们看看一种使用较少的、替代的实现方式——继承。
- en: Considering an alternate implementation for composition
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑为组合使用另一种实现方式
- en: It is useful to understand that composition can alternatively be implemented
    using inheritance, however, this is extremely controversial. Remember, inheritance
    is most often used to implement *Is-A* and not *Has-A* relationships. We briefly
    described using inheritance to implement Has-A relationships in [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426),
    *Exploring Multiple Inheritance*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要了解，组合也可以通过继承来实现，然而，这种方法极具争议。记住，继承最常用于实现“是”某种类型（*Is-A*）和“拥有”某种类型（*Has-A*）的关系。我们在[*第9章*](B19087_09.xhtml#_idTextAnchor426)中简要描述了使用继承来实现“拥有”关系，即*探索多重继承*。
- en: To recap, you would simply inherit from the *part*, rather than embed the part
    as a data member. When doing so, you no longer need to provide *wrapper* functions
    to the *part*, such as we saw in the previous program, with the `Student::GetStudentId()`
    method calling `studentId.GetId()` to provide access to its embedded part. The
    wrapper function was necessary with the embedded object example, as the part (`Id`)
    was private in the whole (`Student`). Programmers could not have accessed the
    private `studentId` data member of `Student` outside the scope of `Student`. Of
    course, member functions of `Student` (such as `GetStudentId()`) can access their
    own class’ private data members and in doing so, can implement the `Student::GetStudentId()`
    wrapper function to provide such (safe) access.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你只需从“部分”继承，而不是将部分作为数据成员嵌入。这样做时，你不再需要为“部分”提供“包装”函数，例如我们之前程序中看到的，`Student::GetStudentId()`
    方法调用 `studentId.GetId()` 以提供对其内嵌部分的访问。在嵌入式对象示例中，包装函数是必要的，因为部分（`Id`）在整体（`Student`）中是私有的。程序员无法在
    `Student` 的作用域之外访问私有的 `studentId` 数据成员。当然，`Student` 的成员函数（如 `GetStudentId()`）可以访问它们自己类的私有数据成员，并在这样做时，可以实施
    `Student::GetStudentId()` 包装函数以提供这样的（安全）访问。
- en: Had inheritance been used, the public interface of `Id::GetId()` would have
    been simply inherited as a public interface in `Student`, providing simple access
    without the need to first go through the embedded object explicitly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了继承，`Id::GetId()` 的公共接口将简单地作为 `Student` 中的公共接口继承，提供简单的访问，无需首先显式地通过嵌入式对象。
- en: Nonetheless, though inheriting a *part* is simple in some ways, it vastly compounds
    multiple inheritance. We know multiple inheritance can provide many potential
    complications. Also, using inheritance, the *whole* can only contain one of each
    *part* – not multiples of a *part*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些方面继承“部分”很简单，但它极大地增加了多重继承的复杂性。我们知道多重继承可以带来许多潜在的问题。此外，使用继承，整体只能包含每种“部分”的一个实例——不能有多个“部分”的实例。
- en: Additionally, implementing a whole-part relationship with inheritance may be
    confusing when you compare the implementation to the OO design. Remember, inheritance
    usually means *Is-A* and not *Has-A*. For these reasons, the most typical and
    appreciated implementation of an aggregate is through an embedded object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你将实现与面向对象设计进行比较时，使用继承实现整体-部分关系可能会令人困惑。记住，继承通常意味着“是”某种类型（*Is-A*）而不是“拥有”某种类型（*Has-A*）。因此，聚合最典型和最受欢迎的实现方式是通过内嵌对象。
- en: Next, let’s move onward by looking at a more general form of aggregation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续探讨更一般的聚合形式。
- en: Defining and implementing a generalized aggregation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和实现泛化聚合
- en: We have looked at the most commonly used form of aggregation in OO designs,
    that of composition. Most notably, with composition, we have seen that the part
    does not have a reason to exist without the whole. Nonetheless, a more generalized
    (but less common) form of aggregation exists and is sometimes specified in OO
    designs. We will now consider this less common form of aggregation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了面向对象设计中最常用的聚合形式，即组合。最值得注意的是，通过组合，我们看到部分没有理由在没有整体的情况下存在。然而，存在一种更通用的（但不太常见）的聚合形式，有时在面向对象设计中指定。我们现在将考虑这种不太常见的聚合形式。
- en: In a **generalized aggregation**, a *part* may exist without the *whole*. A
    part will be created separately and then attached to the whole at a later point
    in time. When the *whole* goes away, a *part* may then remain to be salvaged for
    use with another outer or *whole* object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在**泛化聚合**中，一个“部分”可能存在于没有“整体”的情况下。一个部分将单独创建，然后在稍后的时间点附加到整体上。当“整体”消失时，一个“部分”可能仍然可以用于与另一个外部或“整体”对象一起使用。
- en: In a generalized aggregation, the Has-A relationship certainly applies, as does
    the whole-part designation. The difference is that the *whole* object will not
    create nor destroy a *part* subobject. Consider the straightforward example that
    a `Car` *Has-A(n)* `Engine`. A `Car` object also *Has-A* set of four `Tire` objects.
    The `Engine` or `Tire` objects can be manufactured separately and then passed
    to the constructor of the `Car` to provide these parts to the whole. Yet should
    an `Engine` be destroyed, a new `Engine` can easily be swapped out (using a member
    function), without requiring the entire `Car` to be destroyed and then reconstructed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: A generalized aggregation is equivalent to a Has-A relationship, yet we think
    of this with more flexibility and permanence of the individual parts as we did
    with composition. We consider this relationship as an aggregation simply because
    we wish to equate the objects with a Has-A meaning. The Has-A relationship in
    the `Car`, `Engine`, and `Tire` example is strong; the `Engine` and `Tire`s are
    necessary parts, required to make the whole `Car`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Here, implementation typically is with the *whole* containing a pointer (or
    set of pointers) to the *part(s)*. It is important to note that the parts will
    be passed into a constructor (or another member function) of the outer object
    to establish the relationship. The critical marker is that the whole will not
    create (nor destroy) the parts, and the parts will never destroy the whole.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the longevity of the individual pieces (and the basic implementation)
    of a generalized aggregation will be similar to our next topic – association.
    Let’s move forward to our next section to understand the similarities, as well
    as the OO conceptual differences (sometimes subtle) between generalized aggregation
    and association.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Understanding association
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **association** models a relationship that exists between otherwise unrelated
    class types. An association can provide ways for objects to interact to fulfill
    these relationships. Associations are not used for Has-A relationships, however,
    in some cases, there are shades of gray as to whether we’re describing a bonafide
    Has-A relationship, or whether we are merely using the phrase Has-A because it
    sounds appropriate linguistically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplicity for associations exists: one-to-one, one-to-many, many-to-one,
    or many-to-many. For example, a `Student` may be associated with a single `University`,
    and that `University` may be associated with many `Student` instances; this is
    a one-to-many association.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Associated objects have an independent existence. That is, two or more objects
    may be instantiated and exist independently for a portion of the application.
    At some point, one object may wish to assert a dependency or relationship with
    the other object. Later in the application, the associated objects may part ways
    and continue on their own unrelated paths.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the relationship between a `Course` and an `Instructor`.
    A `Course` is associated with an `Instructor`. A `Course` requires an `Instructor`;
    an `Instructor` is integral to the `Course`. An `Instructor` may be associated
    with many `Course`(s). Yet each part exists independently – one will not create
    nor destroy the other. Instructors may also exist independently without courses;
    perhaps an instructor is taking time to write a book, is taking a sabbatical,
    or is a professor conducting research.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`课程`和`讲师`之间的关系。一个`课程`与一个`讲师`相关联。一个`课程`需要有一个`讲师`；`讲师`对`课程`是必不可少的。一个`讲师`可以与多个`课程`(s)相关联。然而，每个部分都是独立存在的——一个不会创建或摧毁另一个。讲师也可以独立于课程存在；也许讲师正在花时间写一本书，正在休假，或者是一位正在进行研究的教授。
- en: In this example, the association is very similar to a generalized aggregation.
    In both cases, the related objects also exist independently. In this case, whether
    one says that `Course` Has-A(n) `Instructor` or that a `Course` has a dependency
    on an `Instructor`, can be a shade of gray. You may ask yourself – is it just
    spoken language that makes me choose the wording of Has-A? Do I instead mean that
    there is a necessary link between the two? Perhaps the relationship is an association,
    and its descriptive adornment (to further describe the nature of the association)
    is *teaches*. You may have arguments supporting either choice. For this reason,
    generalized aggregations can be considered specialized types of associations;
    we will see that their implementations are the same using independently existing
    objects. Nonetheless, we will distinguish a typical association as being a relationship
    between objects that decisively do not support a true Has-A relationship.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，关联与泛化聚合非常相似。在这两种情况下，相关对象也都是独立存在的。在这种情况下，无论是说`课程`拥有`讲师`，还是说`课程`对`讲师`有依赖关系，都可能是一种灰色地带。你可能自己问自己——是口语使我选择了“拥有”这个词吗？我是不是意味着两者之间存在必要的联系？也许这种关系是一种关联，其描述性修饰语（进一步描述关联的性质）是*教授*。你可能对两种选择都有支持性的论点。因此，泛化聚合可以被认为是关联的特殊类型；我们将看到，它们使用独立存在的对象实现时是相同的。尽管如此，我们将区分典型的关联为对象之间的关系，这种关系明确不支持真正的“拥有”关系。
- en: For example, consider the relationship between `University` and `Instructor`.
    Rather than thinking of this as a Has-A relationship, we may instead consider
    the relationship between the two as that of association; we can think of the adornment
    describing this relationship as *employs*. Likewise, `University` ascertains a
    relationship with many `Student` objects. The association here may be described
    by the adornment *educates*. The distinction can be made that `University` is
    made up of `Department` objects, `Building` objects, and components of this nature
    to support any of its Has-A relationships through containment, yet its relationships
    with `Instructor` objects, `Student` objects, and so on are made using associations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`大学`和`讲师`之间的关系。我们与其将其视为“拥有”关系，不如将其视为两者之间的关联关系；我们可以将描述这种关系的修饰语视为*雇佣*。同样，`大学`与许多`学生`对象建立关系。这里的关联可以用修饰语*教育*来描述。可以区分的是，`大学`由`系`对象、`建筑`对象以及此类组件组成，以通过包含支持其“拥有”关系，然而其与`讲师`对象、`学生`对象等的关系则是通过关联来实现的。
- en: Now that we have distinguished typical associations from generalized aggregations,
    let’s take a look at how we can implement associations and some of the complexities
    involved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经区分了典型的关联和泛化聚合，让我们来看看我们如何实现关联以及其中涉及的一些复杂性。
- en: Implementing association
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现关联
- en: Typically, an association between two or more objects is implemented using pointers
    or sets of pointers. The *one* side is implemented using a pointer to the associated
    object, whereas the *many* side of the relationship is implemented as a set of
    pointers to the associated objects. A set of pointers may be an array of pointers,
    a linked list of pointers, or truly any collection of pointers. Each type of collection
    will have its own set of advantages and drawbacks. For example, arrays of pointers
    are easy to use, have direct access to specific members, yet have a fixed number
    of items. Linked lists of pointers can accommodate any quantity of items, yet
    accessing a specific element requires traversing past others to find the desired
    item.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，两个或多个对象之间的关联是通过指针或指针集合实现的。一方使用指向相关对象的指针来实现，而关系的多方使用指向相关对象的指针集合来实现。指针集合可能是一个指针数组、指针链表，或者真正任何指针集合。每种类型的集合都有自己的优点和缺点。例如，指针数组易于使用，可以直接访问特定成员，但项目数量是固定的。指针链表可以容纳任何数量的项目，但访问特定元素需要遍历其他元素以找到所需的项目。
- en: Occasionally, a reference may be used to implement the *one* side of an association.
    Recall that a reference must be initialized and cannot at a later date be reset
    to reference another object. Using a reference to model an association implies
    that one instance will be associated with a precise other instance for the duration
    of the primary object’s existence. This is extremely restrictive, so references
    are used very infrequently to implement associations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能会使用引用来实现关联的一侧。回想一下，引用必须初始化，并且以后不能重置以引用另一个对象。使用引用来建模关联意味着在主对象存在期间，一个实例将与另一个精确的实例相关联。这是非常限制性的，因此引用很少用于实现关联。
- en: Regardless of the implementation, when the primary object goes away, it will
    not interfere with (that is, delete) the associated object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实现方式如何，当主对象消失时，它不会干扰（即删除）相关对象。
- en: Let’s see a typical example illustrating the preferred implementation of a one-to-many
    association, utilizing a pointer on the *one* side, and a set of pointers on the
    *many* side. In this example, a `University` will be associated with many `Student`
    instances. And, for simplicity, a `Student` will be associated with a single `University`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的例子，它说明了如何实现一对多关联的首选方法，在一方使用指针，而在多方使用指针集合。在这个例子中，一个`University`将与多个`Student`实例相关联。为了简单起见，一个`Student`将与一个单一的`University`相关联。
- en: 'To save space, some portions of this program that are the same as in our last
    example will not be shown; however, the program in its entirety can be found in
    our GitHub as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，本程序中与上一个示例相同的部分将不会显示；然而，整个程序可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp)'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding segment, let’s first notice the forward declaration of `class
    Student;`. This declaration will allow our code to reference the `Student` type
    prior to the `Student` class definition. In the `University` class definition,
    we see that there is an array of pointers to `Student`. We also see that the `EnrollStudent()`
    method takes a `Student *` as an argument. The forward declaration enables such
    usage of `Student` prior to its definition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们首先注意到`class Student;`的前向声明。这个声明将允许我们的代码在`Student`类定义之前引用`Student`类型。在`University`类定义中，我们看到有一个指向`Student`的指针数组。我们还看到`EnrollStudent()`方法接受一个`Student
    *`作为参数。前向声明使得在定义之前可以使用`Student`。
- en: We also notice that the `University` has a simple interface with constructors,
    a destructor, and a few member functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，`University`有一个简单的接口，包括构造函数、析构函数和一些成员函数。
- en: 'Next, let’s take a look at the `University` member function definitions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`University`成员函数的定义：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Taking a closer look at the aforementioned `University` methods, we can see
    that in both constructors for `University`, we could alternatively null out the
    pointers to the elements comprising our `studentBody` using `nullptr` (versus
    our choice of using in-class initialization, which similarly initializes each
    element). Likewise, in the destructor, we similarly null out our links to the
    associated `Student` instances. Shortly in this section, we will see that there
    will be some additional backlink maintenance required, but for now, the point
    is that we will not delete the associated `Student` objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察前面提到的 `University` 方法，我们可以看到，在 `University` 的两个构造函数中，我们可以选择使用 `nullptr`
    来将组成我们的 `studentBody` 的指针置为空（而不是我们选择在类内初始化，这同样会初始化每个元素）。同样，在析构函数中，我们也将关联到相关 `Student`
    实例的链接置为空。在本节稍后，我们将看到还需要进行一些额外的反向链接维护，但到目前为止，重点是我们将不会删除相关的 `Student` 对象。
- en: Since `University` objects and `Student` objects will exist independently, neither
    will create nor destroy instances of the other type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `University` 对象和 `Student` 对象将独立存在，因此它们都不会创建或销毁其他类型的实例。
- en: We also come across an interesting member function, `EnrollStudent(Student *)`.
    In this method, a pointer to a specific `Student` will be passed in as an input
    parameter. We merely index into our array of pointers to `Student` objects, namely
    `studentBody`, and set an unused array element point to the newly enrolled `Student`.
    We keep track of how many current `Student` objects exist using a `currentNumStudents`
    counter, which is incremented with a post increment after the pointer assignment
    to the array is made.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遇到了一个有趣的成员函数，`EnrollStudent(Student *)`。在这个方法中，将传递一个指向特定 `Student` 的指针作为输入参数。我们只是索引到我们的
    `Student` 对象指针数组 `studentBody`，并将未使用的数组元素指向新注册的 `Student`。我们使用 `currentNumStudents`
    计数器跟踪当前 `Student` 对象的数量，该计数器在将指针分配给数组后通过后增量增加。
- en: We also notice that the `University` class has a `Print()` method that prints
    the university’s name, followed by its current student body. It does so by simply
    accessing each associated `Student` object in `studentBody` and asking each `Student`
    instance to invoke the `Student::GetFirstName()` and `Student::GetLastName()`
    methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，`University` 类有一个 `Print()` 方法，它会打印大学的名称，然后是其当前的学生阵容。它是通过简单地访问 `studentBody`
    中的每个相关 `Student` 对象，并要求每个 `Student` 实例调用 `Student::GetFirstName()` 和 `Student::GetLastName()`
    方法来实现的。
- en: 'Next, let’s now take a look at our `Student` class definition, along with its
    inline functions. Recall that we’re assuming that the `Person` class is the same
    as seen earlier in this chapter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，现在让我们来看看我们的 `Student` 类定义，包括其内联函数。回想一下，我们假设的 `Person` 类与本章前面看到的相同：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in the previous code segment, we see the `Student` class definition. Notice
    that we have an association with a University with the pointer data member `University
    *univ = nullptr;` and that this member is initialized to `nullptr` using in-class
    initialization.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们看到 `Student` 类的定义。请注意，我们有一个与大学关联的指针数据成员 `University *univ = nullptr;`，并且该成员使用类内初始化设置为
    `nullptr`。
- en: In the class definition for `Student`, we can also see there is a wrapper function
    to encapsulate access to the student’s university’s name with `Student::GetUniversity()`.
    Here, we allow the associated object, `univ`, to call its public method `University::GetName()`
    and return that value as the result of `Student::GetUniversity()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Student` 类的定义中，我们还可以看到有一个包装函数来封装对学生的大学名称的访问，即 `Student::GetUniversity()`。在这里，我们允许关联的对象
    `univ` 调用其公共方法 `University::GetName()`，并将该值作为 `Student::GetUniversity()` 的结果返回。
- en: 'Now, let’s take a look at the non-inline member functions of `Student`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 `Student` 的非内联成员函数：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code segment, notice that the default `Student` constructor
    and the destructor both only null out their link to the `University` object (using
    `nullptr`). The default constructor has no way to set this link to an existing
    object, and should certainly not create a `University` instance to do so. Likewise,
    the `Student` destructor should not delete the `University` merely because the
    `Student` object’s life expectancy is complete.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，请注意，默认的 `Student` 构造函数和析构函数都只将它们与 `University` 对象的链接置为空（使用 `nullptr`）。默认构造函数无法将此链接设置为现有对象，并且绝对不应该创建一个
    `University` 实例来这样做。同样，`Student` 析构函数也不应该仅仅因为 `Student` 对象的生命周期结束就删除 `University`。
- en: The most interesting part of the preceding code happens in both the alternate
    constructor and copy constructor of `Student`. Let’s examine the alternate constructor.
    Here, we establish the link to the associated `University` as well as the backlink
    from the `University` back to the `Student`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In the `this->univ = univ;` line of code, we are assigning the data member,
    `univ` (as pointed to by the `this` pointer) by setting it to point to where the
    input parameter, `univ`, points. Look closely at the previous class definition
    – the identifier for the `University *` is named `univ`. Additionally, the input
    parameter for the `University *` in the alternate constructor is named `univ`.
    We cannot simply assign `univ = univ;` in the body of this constructor (or in
    the member initialization list). The `univ` identifier that is in the most local
    scope is the input parameter, `univ`. Assigning `univ = univ;` would set this
    parameter to itself. Instead, we disambiguate the `univ` on the left-hand side
    of this assignment using the `this` pointer. The statement `this->univ = univ;`
    sets the data member `univ` to the input parameter `univ`. Could we merely have
    renamed the input parameter something different, such as `u`? Sure, but it is
    important to understand how to disambiguate an input parameter and data member
    with the same identifier when the need arises to do so.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the next line of code, `univ->EnrollStudent(this);`. Now
    that `univ` and `this->univ` point to the same object, it does not matter which
    is used to set the backlink. Here, `univ` calls `EnrollStudent()`, which is a
    public member function in the `University` class. No problem, `univ` is of type
    `University`. `University::EnrollStudent(Student *)` expects to be passed a pointer
    to a `Student` to complete the linkage on the `University` side. Luckily, the
    `this` pointer in our `Student` alternate constructor (the scope of the calling
    function) is a `Student *`. The `this` pointer (in the alternate constructor)
    is literally the `Student *` that we need to create the backlink. Here is another
    example where the explicit use of the `this` pointer is required to complete the
    task at hand.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move forward to our `main()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, in the previous code fragment in our `main()` function, we can create
    several independently existing objects, create an association between them, and
    then view that relationship in action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a `University`, namely `u1`. Next, we instantiate three
    `Student` objects, `s1`, `s2`, and `s3`, and associate each to `University u1`.
    Note that this association can be set when we instantiate a `Student`, or later
    on, for example, if the `Student` class supported a `SelectUniveristy(University
    *)` interface to do so.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We then print out each `Student`, along with the name of the `University` each
    `Student` attends. Then, we print out the student body for our `University`, `u1`.
    We notice that the link built between the associated objects is complete in both
    directions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后打印出每个`Student`，以及每个`Student`所就读的`University`的名称。然后，我们打印出我们`University`，`u1`的学生名单。我们注意到，在相关对象之间建立的联系在两个方向上都是完整的。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve seen how easily associations can be set up and utilized between related
    objects. However, a lot of housekeeping will arise from implementing associations.
    Let’s move forward to understanding the necessary and related issues of reference
    counting and backlink maintenance, which will help with these housekeeping endeavors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在相关对象之间建立和利用关联是多么容易。然而，实现关联会产生很多维护工作。让我们继续前进，了解参考计数和反向链接维护的必要和相关问题，这将有助于这些维护工作。
- en: Utilizing backlink maintenance and reference counting
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用反向链接维护和引用计数
- en: In the previous subsection, we have seen how to implement associations using
    pointers. We’ve seen how to link an object with a pointer to an object in an associated
    instance. And we’ve seen how to complete the circular, two-sided relationship
    by establishing a backlink.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们看到了如何使用指针实现关联。我们看到了如何通过指针将一个对象与关联实例中的另一个对象链接起来。我们还看到了如何通过建立反向链接来完成循环的双向关系。
- en: However, as is typical for associated objects, the relationships are fluid and
    change over time. For example, the given `Student` body will change quite often
    for a given `University`, or the various `Course` set an `Instructor` will teach
    will change each semester. It will be typical, then, to remove a particular object’s
    association to another object, and perhaps associate, instead, to a different
    instance of that class. But, that also means that the associated object must know
    to remove its link to the first mentioned object. This becomes complicated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如关联对象通常所表现的那样，关系是流动的，并且会随时间变化。例如，对于特定的`University`，其学生名单会经常变化，或者`Instructor`将教授的各种`Course`集合在每个学期也会变化。因此，通常需要移除特定对象与另一个对象之间的关联，或许还会与该类别的不同实例建立关联。但这同时也意味着关联对象必须知道如何移除其与第一个提到的对象的链接。这变得复杂了。
- en: For example, consider the `Student` and `Course` relationship. A `Student` is
    enrolled in many `Course` instances. A `Course` contains an association to many
    `Student` instances. This is a many-to-many association. Let’s imagine that the
    `Student` wishes to drop a `Course`. It is not enough for a specific `Student`
    instance to remove a pointer to a specific `Course` instance. Additionally, the
    `Student` must let the particular `Course` instance know that the `Student` in
    question should be removed from that `Course`’s roster. This is known as backlink
    maintenance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`Student`和`Course`之间的关系。一名`Student`注册了许多`Course`实例。一个`Course`包含了对许多`Student`实例的关联。这是一个多对多关联。让我们想象一下，如果`Student`想要退选一个`Course`，仅仅移除特定`Student`实例对特定`Course`实例的指针是不够的。此外，`Student`必须让特定的`Course`实例知道，相关的`Student`应该从该`Course`的名单中移除。这被称为反向链接维护。
- en: Consider what would happen in the above scenario if a `Student` were to simply
    null out its link to the `Course` it was dropping, and do nothing further. The
    `Student` instance in question would be fine. However, the formerly associated
    `Course` instance would still contain a pointer to the `Student` in question.
    Perhaps this would equate to the `Student` receiving a failing grade in the `Course`
    as the `Instructor` still thinks the `Student` in question is enrolled, yet hasn’t
    been turning in their homework. In the end, the `Student` has been affected after
    all, with the failing grade.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，如果一名`Student`只是简单地将其与所退选的`Course`之间的链接置为null，并且不再采取任何进一步行动，上述场景会发生什么。相关的`Student`实例将没问题。然而，之前关联的`Course`实例仍然会包含一个指向该`Student`的指针。也许这相当于`Student`在`Course`中得到了不及格的成绩，因为`Instructor`仍然认为该`Student`是注册的，但还没有提交作业。最终，`Student`还是受到了影响，得到了不及格的成绩。
- en: Remember, with associated objects, one object will not delete the other when
    it is done with the other object. For example, when a `Student` drops a `Course`,
    they will not delete that `Course` – only remove their pointer to the `Course`
    in question (and definitely also handle the required backlink maintenance).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于关联对象，当一个对象完成与另一个对象的工作时，它不会删除另一个对象。例如，当一个`Student`退选一门`Course`时，他们不会删除那门`Course`——只会移除他们对那门`Course`的指针（并且肯定还要处理所需的反向链接维护）。
- en: One idea to help us with overall link maintenance is to consider **reference
    counting**. The purpose of reference counting is to keep track of how many pointers
    may be pointing to a given instance. For example, if other objects point to a
    given instance, that instance should not be deleted. Otherwise, the pointers in
    the other object will point to deallocated memory, which will lead to numerous
    runtime errors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个帮助我们进行整体链接维护的想法是考虑**引用计数**。引用计数的目的是跟踪可能指向给定实例的指针数量。例如，如果其他对象指向一个给定的实例，则不应删除该实例。否则，其他对象中的指针将指向已释放的内存，这将导致许多运行时错误。
- en: Let’s consider an association with multiplicity, such as the relationship between
    a `Student` and a `Course`. A `Student` should keep track of how many `Course`
    pointers are pointing to the `Student`, that is, how many `Courses` the `Student`
    is taking. A `Student` should not be deleted while various `Courses` point to
    that `Student`. Otherwise, `Courses` will point to deleted memory. One way to
    handle this situation is to check within the `Student` destructor whether the
    object (`this`) contains any non-null pointers to `Course` instances. If the object
    does, it then needs to call a method through each of the active `Course` instances
    to request links to the `Student` be removed from each such `Course`. After each
    link is removed, the reference counter corresponding to the set of `Course` instances
    can be decremented.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有多重性的关联，例如`Student`和`Course`之间的关系。`Student`应该跟踪有多少`Course`指针指向`Student`，即`Student`正在选修多少门`Course`。在多个`Course`指向该`Student`的情况下，不应删除`Student`。否则，`Course`将指向已删除的内存。处理这种情况的一种方法是在`Student`析构函数中检查对象（`this`）是否包含任何非空`Course`实例指针。如果对象包含，它需要通过每个活动的`Course`实例调用一个方法，请求从每个这样的`Course`中删除对`Student`的链接。在每个链接被删除后，对应于`Course`实例集合的引用计数可以递减。
- en: Likewise, link maintenance should occur in the `Course` class in favor of `Student`
    instances. `Course` instances should not be deleted until all `Student` instances
    enrolled in that `Course` have been notified. Keeping a counter of how many `Student`
    instances point to a particular instance of a `Course` through reference counting
    is helpful. In this example, it is as simple as maintaining a variable to reflect
    the current number of `Student` instances enrolled in the `Course`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，链接维护应在`Course`类中进行，以利于`Student`实例。在所有注册该`Course`的`Student`实例被通知之前，不应删除`Course`实例。通过引用计数保持指向特定`Course`实例的`Student`实例数量的计数器是有帮助的。在这个例子中，这就像维护一个变量来反映当前注册该`Course`的`Student`实例数量一样简单。
- en: We can meticulously conduct link maintenance ourselves, or we may choose to
    use smart pointers to manage the lifetime of an associated object. **Smart pointers**
    can be found in the C++ Standard Library. They encapsulate a pointer (that is,
    wrap a pointer within a class) to add smart features, including reference counting
    and memory management. Because smart pointers utilize templates, which we will
    not cover until [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with
    Templates*, we will just mention their potential utility here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以细致地自行进行链接维护，或者我们可能选择使用智能指针来管理关联对象的生存期。**智能指针**可以在C++标准库中找到。它们封装了一个指针（即，在类中包装一个指针）以添加智能功能，包括引用计数和内存管理。由于智能指针使用模板，而我们将不会在[*第13章*](B19087_13.xhtml#_idTextAnchor561)“使用模板”中介绍模板，我们在这里只提及其潜在用途。
- en: We have now seen the importance of backlink maintenance and the utility of reference
    counting to fully support associations and their successful implementation. Let’s
    now briefly recap the OO concepts we’ve covered in this chapter – association,
    aggregation, and composition – before moving onward to our next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了反向链接维护的重要性以及引用计数在完全支持关联及其成功实现中的实用性。在继续下一章之前，让我们简要回顾一下本章中涵盖的面向对象概念——关联、聚合和组合。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have pressed forward with our pursuit of object-oriented
    programming by exploring various object relationships – association, aggregation,
    and composition. We have understood the various OO design concepts representing
    these relationships and have seen that C++ does not offer direct language support
    through keywords or specific language features to implement these concepts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索各种对象关系——关联、聚合和组合——来继续我们面向对象编程的追求。我们已经理解了代表这些关系的各种OO设计概念，并看到C++不通过关键字或特定语言特性直接提供语言支持来实现这些概念。
- en: Nonetheless, we have learned several techniques for implementing these core
    OO relationships, such as embedded objects for composition and generalized aggregation,
    or using pointers to implement association. We have looked at the typical longevity
    of object existence with these relationships; for example, with aggregation, by
    creating and destroying its inner part (through an embedded object, or more rarely,
    by allocating and deallocating a pointer member). Or through the independent existence
    of associated objects that neither create nor destroy one another. We have also
    looked under the hood at the housekeeping required to implement association, particularly
    associations with multiplicity, by examining backlink maintenance and reference
    counting.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们已经学习了实现这些核心OO关系的技术，例如用于组合的内嵌对象和泛化聚合，或使用指针来实现关联。我们研究了这些关系下对象典型存在期限；例如，在聚合中，通过创建和销毁其内部部分（通过内嵌对象，或者更少的情况下，通过分配和释放指针成员）。或者通过关联对象的独立存在，这些对象既不创建也不销毁对方。我们还深入研究了实现关联（特别是具有多重性的关联）所需的维护工作，特别是通过检查反向链接维护和引用计数。
- en: We have added key features to our OOP skills through understanding how to implement
    association, aggregation, and composition. We have seen examples of how these
    relationships may even be more prolific in OO designs than inheritance. By mastering
    these skills, we have completed our core skillset of implementing essential OO
    concepts in C++.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解如何实现关联、聚合和组合，我们已经增加了我们的OOP技能的关键特性。我们看到了这些关系如何在OO设计中比继承更加普遍的例子。通过掌握这些技能，我们已经完成了在C++中实现基本OO概念的技能集。
- en: We are now ready to continue to [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions*, which will begin our quest to expand our C++ programming
    repertoire. Let’s continue forward!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续前进到[*第11章*](B19087_11.xhtml#_idTextAnchor488)，*处理异常*，这将开始我们扩展C++编程技能库的探索。让我们继续前进！
- en: Questions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Add an additional `Student` constructor to the `University`/`Student` example
    in this chapter to accept the `University` constructor argument by reference,
    rather than by pointer. For example, in addition to the constructor with the signature
    `Student::Student(const string &fn, const string &ln, char mi, const string &t,
    float avg, const string &course, const string &id, University *univ);`, overload
    this function with a similar one, but with `University &univ` as the last parameter.
    How does this change the implicit call to this constructor?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的`University`/`Student`示例中添加一个额外的`Student`构造函数，以便通过引用接受`University`构造函数参数，而不是通过指针。例如，除了具有签名`Student::Student(const
    string &fn, const string &ln, char mi, const string &t, float avg, const string
    &course, const string &id, University *univ);`的构造函数外，还可以重载此函数，但最后一个参数为`University
    &univ`。这种改变如何影响对这个构造函数的隐式调用？
- en: 'Hint: within your overloaded constructor, you will now need to take the address-of
    (`&`) the `University` reference parameter to set the association (which is stored
    as a pointer). You may need to switch to object notation (`.`) to set the backlink
    (if you use parameter `univ`, versus data member `this->univ`).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在你的重载构造函数中，你现在需要取`University`引用参数的地址（`&`）来设置关联（该关联以指针形式存储）。你可能需要切换到对象表示法（`.`）来设置反向链接（如果你使用参数`univ`，而不是数据成员`this->univ`）。
- en: 'Write a C++ program to implement a many-to-many association between objects
    of type `Course` and of type `Student`. You may choose to build on your previous
    programs that encapsulate `Student`. The many-to-many relationship should work
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个C++程序以实现`Course`类型和`Student`类型对象之间的多对多关联。你可以选择基于之前封装`Student`的程序进行构建。多对多关系应按以下方式工作：
- en: A given `Student` may take zero to many `Course`s, and a given `Course` will
    associate to many `Student` instances. Encapsulate the `Course` class to minimally
    contain a course name, a set of pointers to associated `Student` instances, and
    a reference count to keep track of the number of `Student` instances that are
    in the `Course` (this will equate to how many `Student` instances point to a given
    instance of a `Course`). Add the appropriate interface to reasonably encapsulate
    this class.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特定的 `Student` 可以选择零到多个 `Course`，而特定的 `Course` 将与多个 `Student` 实例相关联。将 `Course`
    类封装起来，至少包含课程名称、一组指向相关联的 `Student` 实例的指针和一个引用计数，以跟踪在 `Course` 中的 `Student` 实例数量（这将等同于指向特定
    `Course` 实例的 `Student` 实例数量）。添加适当的接口以合理封装此类。
- en: Add to your `Student` class a set of pointers to the `Course` instances in which
    that `Student` is enrolled. Additionally, keep track of how many `Course` instances
    a given `Student` is currently enrolled. Add appropriate member functions to support
    this new functionality.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Student` 类中添加一组指向该学生已注册的 `Course` 实例的指针。此外，跟踪特定学生当前注册的 `Course` 实例数量。添加适当的成员函数以支持这一新功能。
- en: Model your many-sided associations using either a linked list of pointers (that
    is, the data part is a pointer to the associated object) or as an array of pointers
    to the associated objects. Note that an array will enforce a limit on the number
    of associated objects you can have, however, this may be reasonable because a
    given `Course` can only accommodate a maximum number of `Student`s and a `Student`
    may only enroll up to a maximum number of `Course`s per semester. If you choose
    the array of pointers approach, make sure your implementation includes error checking
    to accommodate exceeding the maximum number of associated objects in each array.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指针链表（即，数据部分是关联对象的指针）或关联对象的指针数组来模拟多方面的关联。请注意，数组将限制您可以拥有的关联对象数量，但这可能是合理的，因为特定的
    `Course` 只能容纳一定数量的 `Student`，而学生每学期可能只能注册一定数量的 `Course`。如果您选择指针数组方法，请确保您的实现包括错误检查，以适应每个数组中关联对象数量的上限。
- en: Be sure to check for simple errors, such as trying to add `Student`s to a `Course`
    that is full, or adding too many `Course`s to a `Student`’s schedule (assume there
    is an upper bound to five courses per semester).
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要检查简单的错误，例如尝试将 `Student` 添加到一个已满的 `Course` 中，或者将过多的 `Course` 添加到学生的课程表（假设每学期最多五门课程）中。
- en: Make sure your destructors do not delete the associated instances.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的析构函数不会删除关联的实例。
- en: Introduce at least three `Student` objects, each of which takes two or more
    `Course`s. Additionally, make sure each `Course` has multiple `Student`s enrolled.
    Print each `Student`, including each `Course` in which they are enrolled. Likewise,
    print each `Course`, showing each `Student` enrolled in the `Course`.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入至少三个 `Student` 对象，每个对象选择两个或更多的 `Course`。此外，确保每个 `Course` 有多个注册的学生。打印每个学生，包括他们注册的每个
    `Course`。同样，打印每个 `Course`，显示注册在该 `Course` 中的每个学生。
- en: '(Optional) Enhance your program in *Exercise 2* to gain experience with backlink
    maintenance and reference counting as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）增强您的程序在 *练习 2* 中，以获得关于反向链接维护和引用计数的经验如下：
- en: 'Implement a `DropCourse()` interface for `Student`. That is, create a `Student::
    DropCourse(Course *)` method in `Student`. Here, find the `Course` the `Student`
    wishes to drop in their course list, but before removing the `Course`, call a
    method on that `Course` to remove the aforementioned `Student` (that is, `this`)
    from the `Course`. Hint: you can make a `Course::RemoveStudent(Student *)`) method
    to help with backlink removal.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Student` 实现 `DropCourse()` 接口。也就是说，在 `Student` 中创建一个 `Student::DropCourse(Course
    *)` 方法。在这里，找到学生想要从课程列表中删除的 `Course`，但在删除 `Course` 之前，调用该 `Course` 上的一个方法来从 `Course`
    中删除上述 `Student`（即 `this`）。提示：您可以创建一个 `Course::RemoveStudent(Student *)` 方法来帮助进行反向链接删除。
- en: Now, fully implement proper destructors. When a `Course` is destructed, have
    the `Course` destructor first tell each remaining associated `Student` to remove
    their link to that `Course`. Likewise, when a `Student` is destructed, loop through
    the `Student`’s course list to ask those `Courses` to remove the aforementioned
    `Student` (that is, `this`) from their student list. You may find reference counting
    in each class (that is, by checking `numStudents` or `numCourses`) helpful to
    see whether these tasks must be engaged.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your C++ Programming Repertoire'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to expand your C++ programming skills, beyond the OOP
    skills, to encompass other critical features of C++.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The initial chapter in this section explores exception handling in C++ through
    understanding the mechanisms of `try`, `throw`, and `catch`, and through examining
    many examples to explore exception mechanics by delving into various exception
    handling scenarios. Additionally, this chapter expands exception class hierarchies
    with new exception classes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter digs into the topics of the proper usage of friend functions
    and friend classes, as well as operator overloading (which may sometimes require
    friends), to make operations polymorphic between built-in and user defined types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent chapter explores using C++ templates to help make code generic
    and usable for a variety of data types using template functions and template classes.
    Additionally, this chapter explains how operator overloading will assist in making
    template code extensible for virtually any data type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the Standard Template Library in C++ is introduced, and
    core STL containers such as `list`, `iterator`, `deque`, `stack`, `queue`, `priority_queue`,
    and `map` (including one using a functor) are examined. Additionally, STL algorithms
    and functors are introduced.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter in this section surveys testing OO programs and components
    by exploring canonical class form, creating drivers for component testing, testing
    classes related through inheritance, association, aggregation, and testing exception-handling
    mechanisms.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19087_11.xhtml#_idTextAnchor488), *Handling Exceptions*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19087_14.xhtml#_idTextAnchor595), *Understanding STL Basics*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19087_15.xhtml#_idTextAnchor655), *Testing Classes and Components*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your C++ Programming Repertoire'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
