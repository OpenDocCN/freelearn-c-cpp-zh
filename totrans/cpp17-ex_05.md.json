["```cpp\n    #ifndef CLOCK_H \n    #define CLOCK_H \n\n    #include <QWidget> \n    #include <QTimer> \n```", "```cpp\n    class Clock : public QWidget { \n      Q_OBJECT \n```", "```cpp\n    public: \n      Clock(QWidget* parentWidgetPtr = nullptr); \n```", "```cpp\n    void paintEvent(QPaintEvent *eventPtr); \n```", "```cpp\n      private: \n        QTimer m_timer; \n    }; \n\n    #endif // CLOCK_H \n```", "```cpp\n    #include <QtWidgets> \n    #include \"Clock.h\"\n```", "```cpp\n    Clock::Clock(QWidget* parentWidgetPtr /* = nullptr */) \n     :QWidget(parentWidgetPtr) { \n```", "```cpp\n    setWindowTitle(tr(\"Clock\")); \n    resize(1000, 500); \n```", "```cpp\n      m_timer.setParent(this); \n      connect(&m_timer, SIGNAL(timeout()), this, SLOT(update())); \n      m_timer.start(100); \n    }\n```", "```cpp\n    void Clock::paintEvent(QPaintEvent* /* eventPtr */) { \n      int side = qMin(width(), height()); \n      QTime time = QTime::currentTime();\n```", "```cpp\n      QPainter painter(this); \n      painter.setRenderHint(QPainter::Antialiasing); \n      painter.setRenderHint(QPainter::TextAntialiasing); \n      painter.translate(width() / 2, height() / 2); \n      painter.scale(side / 200.0, side / 200.0); \n```", "```cpp\n      for (int second = 0; second <= 60; ++second) { \n        if ((second % 5) == 0) { \n          painter.drawLine(QPoint(0, 81), QPoint(0, 98)); \n        } \n        else { \n          painter.drawLine(QPoint(0, 90), QPoint(0, 98)); \n        } \n```", "```cpp\n        painter.rotate(6); \n      }  \n```", "```cpp\n      double hours = time.hour(), minutes = time.minute(), \n             seconds = time.second(), milliseconds = time.msec(); \n```", "```cpp\n      painter.setPen(Qt::black); \n      painter.setBrush(Qt::gray);\n```", "```cpp\n      { static const QPoint hourHand[3] = \n          {QPoint(8, 8), QPoint(-8, 8), QPoint(0, -60)};\n```", "```cpp\n        painter.save(); \n```", "```cpp\n        double hour = hours + (minutes / 60.0) + (seconds / 3600.0) + \n                      (milliseconds / 3600000.0); \n        painter.rotate(30.0 * hour); \n```", "```cpp\n        painter.drawConvexPolygon(hourHand, 3); \n        painter.restore(); \n      } \n```", "```cpp\n      { static const QPoint minuteHand[3] = \n          {QPoint(6, 8), QPoint(-6, 8), QPoint(0, -70)}; \n        painter.save(); \n```", "```cpp\n        double minute = minutes + (seconds / 60.0) + \n                        (milliseconds / 60000.0); \n        painter.rotate(6.0 * minute); \n        painter.drawConvexPolygon(minuteHand, 3); \n        painter.restore(); \n      }\n```", "```cpp\n      { static const QPoint secondHand[3] = \n          {QPoint(4, 8), QPoint(-4, 8), QPoint(0, -80)}; \n\n        painter.save(); \n        double second = seconds + (milliseconds / 1000); \n        painter.rotate(6.0 * second); \n        painter.drawConvexPolygon(secondHand, 3); \n        painter.restore(); \n      } \n    } \n```", "```cpp\n    #include <QApplication> \n    #include \"Clock.h\" \n\n    int main(int argc, char *argv[]) { \n      QApplication application(argc, argv); \n      Clock Clock; \n      Clock.show(); \n      return application.exec(); \n    }\n```", "```cpp\n    #ifndef LISTENER_H \n    #define LISTENER_H \n\n    #include <QObject>\n```", "```cpp\n    #define DEFINE_LISTENER(BaseClass, Listener)           \n      friend bool Listener(QObject* baseObjectPtr) {       \n         return ((BaseClass*) baseObjectPtr)->Listener();  \n      }                                                    \n      bool Listener()                                      \n```", "```cpp\n    #define LISTENER(Listener) (&::Listener) \n```", "```cpp\n    typedef bool (*Listener)(QObject*); \n    #endif // LISTENER_H \n```", "```cpp\n    #ifndef MAINWINDOW_H \n    #define MAINWINDOW_H \n\n    #include <QMainWindow> \n    #include <QActionGroup> \n    #include <QPair> \n    #include <QMap> \n\n    #include \"Listener.h\" \n    #include \"DocumentWidget.h\" \n\n    class MainWindow : public QMainWindow { \n      Q_OBJECT \n\n      public: \n        MainWindow(QWidget* parentWidgetPtr = nullptr); \n        ~MainWindow(); \n\n      protected: \n        void addFileMenu(); \n        void addEditMenu(); \n```", "```cpp\n      protected: \n        void addAction(QMenu* menuPtr, QString text, \n                       const char* onSelectPtr, \n                       QKeySequence acceleratorKey = 0, \n                       QString iconName = QString(), \n                       QToolBar* toolBarPtr = nullptr, \n                       QString statusTip = QString(), \n                       Listener enableListener = nullptr, \n                       Listener checkListener = nullptr, \n                       QActionGroup* groupPtr = nullptr); \n```", "```cpp\n        DEFINE_LISTENER(DocumentWidget, isSaveEnabled); \n        DEFINE_LISTENER(DocumentWidget, isCutEnabled); \n        DEFINE_LISTENER(DocumentWidget, isCopyEnabled); \n        DEFINE_LISTENER(DocumentWidget, isPasteEnabled); \n        DEFINE_LISTENER(DocumentWidget, isDeleteEnabled); \n```", "```cpp\n      public slots: \n        void onMenuShow();\n```", "```cpp\n      private: \n        QMap<QAction*,QPair<QObject*,Listener>> m_enableMap, \n                                                m_checkMap; \n    }; \n\n    #endif // MAINWINDOW_H \n```", "```cpp\n    #include \"MainWindow.h\" \n    #include <QtWidgets> \n```", "```cpp\n    MainWindow::MainWindow(QWidget* parentWidgetPtr /*= nullptr*/) \n     :QMainWindow(parentWidgetPtr) { \n    } \n```", "```cpp\n    MainWindow::~MainWindow() { \n      for (QAction* actionPtr : menuBar()->actions()) { \n        delete actionPtr; \n      } \n    } \n```", "```cpp\n    void MainWindow::addFileMenu() { \n      QMenu* fileMenuPtr = menuBar()->addMenu(tr(\"&File\"));\n```", "```cpp\n      connect(fileMenuPtr, SIGNAL(aboutToShow()), this, \n              SLOT(onMenuShow())); \n```", "```cpp\n      QToolBar *fileToolBarPtr = addToolBar(tr(\"File\")); \n```", "```cpp\n  addAction(fileMenuPtr, tr(\"&New\"), SLOT(onNew()), \n            QKeySequence::New, tr(\"new\"), fileToolBarPtr, \n            tr(\"Create a new file\")); \n\n  addAction(fileMenuPtr, tr(\"&Open\"), SLOT(onOpen()), \n            QKeySequence::Open, tr(\"open\"), fileToolBarPtr, \n            tr(\"Open an existing file\")); \n```", "```cpp\n      addAction(fileMenuPtr, tr(\"&Save\"), SLOT(onSave()), \n                QKeySequence::Save, tr(\"save\"), fileToolBarPtr, \n                tr(\"Save the document to disk\"), \n                LISTENER(isSaveEnabled)); \n```", "```cpp\n      addAction(fileMenuPtr, tr(\"Save &As\"), SLOT(onSaveAs()), \n                0, QString(), nullptr, QString(), \n                LISTENER(isSaveEnabled)); \n```", "```cpp\n      fileMenuPtr->addSeparator(); \n      addAction(fileMenuPtr, tr(\"E&xit\"), \n                SLOT(onExit()), QKeySequence::Quit); \n    } \n```", "```cpp\n    void MainWindow::addEditMenu() { \n      QMenu* editMenuPtr = menuBar()->addMenu(tr(\"&Edit\")); \n      QToolBar* editToolBarPtr = addToolBar(tr(\"Edit\")); \n      connect(editMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n\n      addAction(editMenuPtr, tr(\"&Cut\"), SLOT(onCut()), \n                QKeySequence::Cut, tr(\"cut\"), editToolBarPtr, \n          tr(\"Cut the current selection's contents to the clipboard\"), \n                LISTENER(isCutEnabled)); \n\n      addAction(editMenuPtr, tr(\"&Copy\"), SLOT(onCopy()), \n                QKeySequence::Copy, tr(\"copy\"), editToolBarPtr, \n         tr(\"Copy the current selection's contents to the clipboard\"), \n                LISTENER(isCopyEnabled)); \n\n      addAction(editMenuPtr, tr(\"&Paste\"), SLOT(onPaste()), \n                QKeySequence::Paste, tr(\"paste\"), editToolBarPtr, \n        tr(\"Paste the current selection's contents to the clipboard\"), \n                LISTENER(isPasteEnabled)); \n\n      editMenuPtr->addSeparator(); \n      addAction(editMenuPtr, tr(\"&Delete\"), SLOT(onDelete()), \n                QKeySequence::Delete, tr(\"delete\"), editToolBarPtr, \n                tr(\"Delete the current selection\"), \n                LISTENER(isDeleteEnabled)); \n    } \n```", "```cpp\n    void MainWindow::addAction(QMenu* menuPtr, QString itemText, \n                               const char* onSelectPtr, \n                               QKeySequence acceleratorKey /* = 0 */, \n                               QString iconName /*= QString()*/, \n                               QToolBar* toolBarPtr /*= nullptr*/, \n                               QString statusTip /*= QString()*/, \n                               Listener enableListener /*= nullptr*/, \n                               Listener checkListener /*= nullptr*/, \n                               QActionGroup* groupPtr /*= nullptr*/) { \n      QAction* actionPtr; \n```", "```cpp\n      if (!iconName.isEmpty()) { \n        const QIcon icon = QIcon::fromTheme(\"document-\" + iconName, \n                           QIcon(\":/images/\" + iconName + \".png\")); \n        actionPtr = new QAction(icon, itemText, this); \n      } \n```", "```cpp\n      else { \n        actionPtr = new QAction(itemText, this); \n      }\n```", "```cpp\n      connect(actionPtr, SIGNAL(triggered()), \n              centralWidget(), onSelectPtr); \n```", "```cpp\n      if (acceleratorKey != 0) { \n        actionPtr->setShortcut(acceleratorKey); \n      } \n```", "```cpp\n      menuPtr->addAction(actionPtr); \n```", "```cpp\n      if (toolBarPtr != nullptr) { \n        toolBarPtr->addAction(actionPtr); \n      } \n```", "```cpp\n      if (!statusTip.isEmpty()) { \n          actionPtr->setToolTip(statusTip); \n          actionPtr->setStatusTip(statusTip); \n      } \n```", "```cpp\n      if (enableListener != nullptr) { \n        QWidget* widgetPtr = centralWidget(); \n        m_enableMap[actionPtr] = \n          QPair<QObject*,Listener>(widgetPtr, enableListener); \n        actionPtr->setEnabled(enableListener(widgetPtr)); \n      } \n```", "```cpp\n      if (checkListener != nullptr) { \n        actionPtr->setCheckable(true); \n        QWidget* widgetPtr = centralWidget(); \n        m_checkMap[actionPtr] = \n          QPair<QObject*,Listener>(widgetPtr, checkListener); \n        actionPtr->setChecked(checkListener(widgetPtr)); \n      } \n```", "```cpp\n      if (groupPtr != nullptr) { \n        groupPtr->addAction(actionPtr); \n      } \n    } \n```", "```cpp\n    void MainWindow::onMenuShow() { \n      for (QMap<QAction*,QPair<QObject*,Listener>>::iterator i = \n           m_enableMap.begin(); i != m_enableMap.end(); ++i) { \n        QAction* actionPtr = i.key(); \n        QPair<QObject*,Listener> pair = i.value(); \n        QObject* baseObjectPtr = pair.first; \n        Listener enableFunction = pair.second; \n        actionPtr->setEnabled(enableFunction(baseObjectPtr)); \n      } \n```", "```cpp\n      for (QMap<QAction*,QPair<QObject*,Listener>>::iterator i = \n           m_checkMap.begin(); i != m_checkMap.end(); ++i) { \n        QAction* actionPtr = i.key(); \n        QPair<QObject*,Listener> pair = i.value(); \n        QObject* baseObjectPtr = pair.first; \n        Listener checkFunction = pair.second; \n        actionPtr->setCheckable(true); \n        actionPtr->setChecked(checkFunction(baseObjectPtr)); \n      } \n    } \n```", "```cpp\n    #ifndef DOCUMENTWIDGET_H \n    #define DOCUMENTWIDGET_H \n\n    #include \"Listener.h\" \n    #include <QWidget> \n    #include <QtWidgets> \n    #include <FStream> \n    using namespace std; \n\n    class DocumentWidget : public QWidget { \n      Q_OBJECT \n```", "```cpp\n      public: \n        DocumentWidget(const QString& name, const QString& fileMask, \n                       QWidget* parentWidgetPtr); \n        ~DocumentWidget();\n```", "```cpp\n      protected: \n        void setFilePath(QString filePath); \n```", "```cpp\n      public: \n        void setModifiedFlag(bool flag); \n```", "```cpp\n      private: \n        void setMainWindowTitle(); \n```", "```cpp\n      public: \n        virtual void closeEvent(QCloseEvent* eventPtr); \n```", "```cpp\n      private: \n        bool isClearOk(QString title); \n```", "```cpp\n      public slots: \n        virtual void onNew(); \n        virtual void onOpen(); \n        virtual bool onSave(); \n        virtual bool onSaveAs(); \n        virtual void onExit();\n```", "```cpp\n    virtual bool isSaveEnabled(); \n```", "```cpp\n    private: \n        bool tryWriteFile(QString filePath); \n```", "```cpp\n      protected: \n        virtual void newDocument() = 0; \n        virtual bool writeFile(const QString& filePath) = 0; \n        virtual bool readFile(const QString& filePath) = 0; \n```", "```cpp\n      public: \n        virtual bool isCutEnabled(); \n        virtual bool isCopyEnabled(); \n        virtual bool isPasteEnabled(); \n        virtual bool isDeleteEnabled(); \n```", "```cpp\n      public slots: \n        virtual void onCut(); \n        virtual void onCopy(); \n        virtual void onPaste(); \n        virtual void onDelete(); \n```", "```cpp\n      private: \n        QString m_applicationName, m_fileMask, m_filePath; \n        bool m_modifiedFlag = false; \n    }; \n```", "```cpp\n    QPoint& operator+=(QPoint& point, const QSize& size); \n    QPoint& operator-=(QPoint& point, const QSize& size); \n\n    QRect& operator+=(QRect& rect, int size); \n    QRect& operator-=(QRect& rect, int size); \n```", "```cpp\n    void writePoint(ofstream& outStream, const QPoint& point); \n    void readPoint(ifstream& inStream, QPoint& point); \n```", "```cpp\n    void writeColor(ofstream& outStream, const QColor& color); \n    void readColor(ifstream& inStream, QColor& color); \n```", "```cpp\n    QRect makeRect(const QPoint& centerPoint, int halfSide); \n    #endif // DOCUMENTWIDGET_H \n```", "```cpp\n    #include <QtWidgets> \n    #include <QMessageBox> \n\n    #include \"MainWindow.h\" \n    #include \"DocumentWidget.h\" \n```", "```cpp\n    DocumentWidget::DocumentWidget(const QString& name, \n                    const QString& fileMask, QWidget* parentWidgetPtr) \n     :m_applicationName(name), \n      m_fileMask(fileMask), \n      QWidget(parentWidgetPtr) { \n        setMainWindowTitle(); \n      } \n```", "```cpp\n    DocumentWidget::~DocumentWidget() { \n      // Empty. \n    } \n```", "```cpp\n    void DocumentWidget::setFilePath(QString filePath) { \n      m_filePath = filePath; \n      setMainWindowTitle(); \n    } \n```", "```cpp\n    void DocumentWidget::setModifiedFlag(bool modifiedFlag) { \n      m_modifiedFlag = modifiedFlag; \n      setMainWindowTitle(); \n      ((MainWindow*) parentWidget())->onMenuShow(); \n    } \n```", "```cpp\n    void DocumentWidget::setMainWindowTitle() { \n      QString title= m_applicationName + \n              (m_filePath.isEmpty() ? \"\" : (\" [\" + m_filePath + \"]\"))+ \n              (m_modifiedFlag ? \" *\" : \"\"); \n      this->parentWidget()->setWindowTitle(title); \n    } \n```", "```cpp\n    bool DocumentWidget::isClearOk(QString title) { \n      if (m_modifiedFlag) { \n        QMessageBox messageBox(QMessageBox::Warning, \n                               title, QString()); \n        messageBox.setText(tr(\"The document has been modified.\")); \n        messageBox.setInformativeText( \n                   tr(\"Do you want to save your changes?\")); \n        messageBox.setStandardButtons(QMessageBox::Yes | \n                              QMessageBox::No | QMessageBox::Cancel); \n        messageBox.setDefaultButton(QMessageBox::Yes); \n\n        switch (messageBox.exec()) { \n          case QMessageBox::Yes: \n            return onSave(); \n\n          case QMessageBox::No: \n            return true; \n\n          case QMessageBox::Cancel: \n            return false; \n        } \n      } \n\n      return true; \n    } \n```", "```cpp\n    void DocumentWidget::onNew() { \n      if (isClearOk(tr(\"New File\"))) { \n        newDocument(); \n        setModifiedFlag(false); \n        setFilePath(QString()); \n        update(); \n      } \n    } \n```", "```cpp\n    void DocumentWidget::onOpen() { \n      if (isClearOk(tr(\"Open File\"))) { \n        QString file = \n          QFileDialog::getOpenFileName(this, tr(\"Open File\"), \n                       tr(\"C:\\Users\\Stefan\\Documents\\\" \n                          \"A A_Cpp_By_Example\\Draw\"), \n                  m_fileMask + tr(\";;Text files (*.txt)\")); \n```", "```cpp\n        if (!file.isEmpty()) { \n          if (readFile(file)) { \n            setModifiedFlag(false); \n            setFilePath(file); \n            update(); \n          } \n```", "```cpp\n          else { \n            QMessageBox messageBox; \n            messageBox.setIcon(QMessageBox::Critical); \n            messageBox.setText(tr(\"Read File\")); \n            messageBox.setInformativeText(tr(\"Could not read \"\") + \n                                          m_filePath  + tr(\"\"\")); \n            messageBox.setStandardButtons(QMessageBox::Ok); \n            messageBox.setDefaultButton(QMessageBox::Ok); \n            messageBox.exec(); \n          } \n        } \n      } \n    } \n```", "```cpp\n    bool DocumentWidget::isSaveEnabled() { \n      return m_modifiedFlag; \n    } \n```", "```cpp\n    bool DocumentWidget::onSave() { \n      if (!m_filePath.isEmpty()) { \n        return tryWriteFile(m_filePath); \n      } \n      else { \n        return onSaveAs(); \n      } \n    } \n```", "```cpp\n    bool DocumentWidget::onSaveAs() { \n      QString filePath = \n              QFileDialog::getSaveFileName(this, tr(\"Save File\"), \n                   tr(\"C:\\Users\\Stefan\\Documents\\\" \n                      \"A A_Cpp_By_Example\\Draw\"), \n                m_fileMask + tr(\";;Text files (*.txt)\")); \n\n      if (!filePath.isEmpty()) { \n        return tryWriteFile(filePath); \n      } \n      else { \n        return false; \n      } \n    } \n```", "```cpp\n    bool DocumentWidget::tryWriteFile(QString filePath) { \n      if (writeFile(filePath)) { \n        setModifiedFlag(false); \n        setFilePath(filePath); \n        return true; \n      } \n      else { \n        QMessageBox messageBox; \n        messageBox.setIcon(QMessageBox::Critical); \n        messageBox.setText(tr(\"Write File\")); \n        messageBox.setInformativeText(tr(\"Could not write \"\") + \n                                      filePath  + tr(\"\"\")); \n        messageBox.setStandardButtons(QMessageBox::Ok); \n        messageBox.setDefaultButton(QMessageBox::Ok); \n        messageBox.exec(); \n        return false; \n      } \n    } \n```", "```cpp\n    void DocumentWidget::onExit() { \n      if (isClearOk(tr(\"Exit\"))) { \n        qApp->exit(0); \n      } \n    } \n```", "```cpp\n    bool DocumentWidget::isCutEnabled() { \n      return isCopyEnabled(); \n    } \n\n    bool DocumentWidget::isDeleteEnabled() { \n      return isCopyEnabled(); \n    } \n```", "```cpp\n    void DocumentWidget::onCut() { \n      onCopy(); \n      onDelete(); \n    } \n```", "```cpp\n    bool DocumentWidget::isCopyEnabled() { \n      return false; \n    } \n\n    void DocumentWidget::onCopy() { \n      // Empty. \n    } \n\n    bool DocumentWidget::isPasteEnabled() { \n      return false; \n    } \n\n    void DocumentWidget::onPaste() { \n      // Empty. \n    } \n\n    void DocumentWidget::onDelete() { \n      // Empty. \n} \n```", "```cpp\n    void DocumentWidget::closeEvent(QCloseEvent* eventPtr) { \n      if (isClearOk(tr(\"Close Window\"))) { \n        eventPtr->accept(); \n        qApp->exit(0); \n      } \n```", "```cpp\n      else { \n        eventPtr->ignore(); \n      } \n    } \n```", "```cpp\n    QPoint& operator+=(QPoint& point, const QSize& size) { \n      point.setX(point.x() + size.width()); \n      point.setY(point.y() + size.height()); \n      return point; \n    } \n\n    QPoint& operator-=(QPoint& point, const QSize& size) { \n      point.setX(point.x() - size.width()); \n      point.setY(point.y() - size.height()); \n      return point; \n    } \n```", "```cpp\n    QRect& operator+=(QRect& rect, int size) { \n      rect.setLeft(rect.left() - size); \n      rect.setTop(rect.top() - size); \n      rect.setWidth(rect.width() + size); \n      rect.setHeight(rect.height() + size); \n      return rect; \n    } \n\n    QRect& operator-=(QRect& rect, int size) { \n      rect.setLeft(rect.left() + size); \n      rect.setTop(rect.top() + size); \n      rect.setWidth(rect.width() - size); \n      rect.setHeight(rect.height() - size); \n      return rect; \n    } \n```", "```cpp\n    void writePoint(ofstream& outStream, const QPoint& point) { \n      int x = point.x(), y = point.y(); \n      outStream.write((char*) &x, sizeof x); \n      outStream.write((char*) &y, sizeof y); \n    } \n\n    void readPoint(ifstream& inStream, QPoint& point) { \n      int x, y; \n      inStream.read((char*) &x, sizeof x); \n      inStream.read((char*) &y, sizeof y); \n      point = QPoint(x, y); \n    } \n```", "```cpp\n    void writeColor(ofstream& outStream, const QColor& color) { \n      int red = color.red(), green = color.green(), \n      blue = color.blue(); \n      outStream.write((char*) &red, sizeof red); \n      outStream.write((char*) &green, sizeof green); \n      outStream.write((char*) &blue, sizeof blue); \n    } \n\n    void readColor(ifstream& inStream, QColor& color) { \n      int red, green, blue; \n      inStream.read((char*) &red, sizeof red); \n      inStream.read((char*) &green, sizeof green); \n      inStream.read((char*) &blue, sizeof blue);\n```", "```cpp\n      color = QColor(red, green, blue); \n    } \n```", "```cpp\n    QRect makeRect(const QPoint& centerPoint, int halfSide) { \n      return QRect(centerPoint.x() - halfSide, \n                   centerPoint.y() - halfSide, \n                   2 * halfSide, 2 * halfSide); \n    } \n```", "```cpp\n    #ifndef FIGURE_H \n    #define FIGURE_H \n\n    enum FigureId {LineId, RectangleId, EllipseId}; \n\n    #include <QtWidgets> \n    #include <FStream> \n    using namespace std; \n\n    class Figure { \n      public: \n        Figure(); \n```", "```cpp\n    virtual FigureId getId() const = 0; \n```", "```cpp\n    virtual void initializePoints(QPoint point) = 0; \n    virtual void setLastPoint(QPoint point) = 0; \n```", "```cpp\n    virtual bool isClick(QPoint mousePoint) = 0; \n```", "```cpp\n    virtual void move(QSize distance) = 0; \n```", "```cpp\n    virtual void draw(QPainter &painter) const = 0; \n```", "```cpp\n    virtual bool write(ofstream& outStream) const; \n    virtual bool read(ifstream& inStream); \n```", "```cpp\n    const QColor& color() const {return m_color;} \n    QColor& color() {return m_color;}\n```", "```cpp\n    virtual bool filled() const {return m_filled;} \n    virtual bool& filled() {return m_filled;} \n```", "```cpp\n    static const int Tolerance; \n```", "```cpp\n        static void writeColor(ofstream& outStream, \n\n                               const QColor& color); \n        static void readColor(ifstream& inStream, QColor& color); \n```", "```cpp\n      private: \n        QColor m_color; \n        bool m_marked = false, m_filled = false; \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Figure.h\" \n```", "```cpp\n    const int Figure::Tolerance(6); \n```", "```cpp\n    Figure::Figure() { \n      // Empty. \n    }\n```", "```cpp\n    bool Figure::write(ofstream& outStream) const { \n      writeColor(outStream, m_color); \n      outStream.write((char*) &m_filled, sizeof m_filled); \n      return ((bool) outStream); \n    } \n\n    bool Figure::read(ifstream& inStream) { \n      readColor(inStream, m_color); \n      inStream.read((char*) &m_filled, sizeof m_filled); \n      return ((bool) inStream); \n    } \n```", "```cpp\n    #ifndef LINE_H \n    #define LINE_H \n\n    #include <FStream> \n    using namespace std; \n\n    #include \"Figure.h\" \n\n    class Line : public Figure { \n      public:\n```", "```cpp\n    Line(); \n    FigureId getId() const {return LineId;} \n```", "```cpp\n    void initializePoints(QPoint point); \n    void setLastPoint(QPoint point); \n```", "```cpp\n    bool isClick(QPoint mousePoint); \n```", "```cpp\n    void move(QSize distance); \n```", "```cpp\n    void draw(QPainter& painter) const; \n```", "```cpp\n    bool write(ofstream& outStream) const; \n    bool read(ifstream& inStream); \n```", "```cpp\n    private: \n      QPoint m_firstPoint, m_lastPoint; \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Line.h\" \n\n    Line::Line() { \n      // Empty. \n    }\n```", "```cpp\n    void Line::initializePoints(QPoint point) { \n      m_firstPoint = point; \n      m_lastPoint = point; \n    } \n```", "```cpp\n    void Line::setLastPoint(QPoint point) { \n      m_lastPoint = point; \n    } \n```", "```cpp\n    bool Line::isClick(QPoint mousePoint) { \n      if (m_firstPoint.x() == m_lastPoint.x()) { \n        QRect lineRect(m_firstPoint, m_lastPoint); \n        lineRect.normalized(); \n        lineRect += Tolerance; \n        return lineRect.contains(mousePoint); \n      }\n```", "```cpp\n        else { \n          QPoint leftPoint = (m_firstPoint.x() < m_lastPoint.x()) \n                             ? m_firstPoint : m_lastPoint, \n                 rightPoint = (m_firstPoint.x() < m_lastPoint.x()) \n                              ? m_lastPoint : m_firstPoint; \n\n          if ((leftPoint.x() <= mousePoint.x()) && \n              (mousePoint.x() <= rightPoint.x())) { \n            int lineWidth = rightPoint.x() - leftPoint.x(), \n                lineHeight = rightPoint.y() - leftPoint.y(); \n\n            int diffWidth = mousePoint.x() - leftPoint.x(), \n                diffHeight = mousePoint.y() - leftPoint.y(); \n```", "```cpp\n          return (fabs(diffHeight - (((double) lineHeight) / \n                       lineWidth) * diffWidth) <= Tolerance); \n        } \n```", "```cpp\n        return false; \n      } \n    } \n```", "```cpp\n    void Line::move(QSize distance) { \n      m_firstPoint += distance; \n      m_lastPoint += distance; \n    } \n```", "```cpp\n    void Line::draw(QPainter& painter) const { \n      painter.setPen(color()); \n      painter.drawLine(m_firstPoint, m_lastPoint); \n    } \n```", "```cpp\n    bool Line::write(ofstream& outStream) const { \n      Figure::write(outStream); \n      writePoint(outStream, m_firstPoint); \n      writePoint(outStream, m_lastPoint); \n      return ((bool) outStream); \n    }\n```", "```cpp\n    bool Line::read(ifstream& inStream) { \n      Figure::read(inStream); \n      readPoint(inStream, m_firstPoint); \n      readPoint(inStream, m_lastPoint); \n      return ((bool) inStream); \n    } \n```", "```cpp\n    #ifndef RECTANGLE_H \n    #define RECTANGLE_H \n\n    #include <FStream> \n    using namespace std; \n\n    #include \"Figure.h\" \n\n    class RectangleX : public Figure { \n      public: \n```", "```cpp\n        RectangleX(); \n        virtual FigureId getId() const {return RectangleId;} \n\n        RectangleX(const RectangleX& rectangle); \n\n        virtual void initializePoints(QPoint point); \n        virtual void setLastPoint(QPoint point); \n\n        virtual bool isClick(QPoint mousePoint); \n        virtual void move(QSize distance); \n        virtual void draw(QPainter& painter) const; \n\n        virtual bool write(ofstream& outStream) const; \n        virtual bool read(ifstream& inStream); \n\n      protected: \n        QPoint m_topLeft, m_bottomRight; \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Rectangle.h\" \n\n    RectangleX::RectangleX() { \n      // Empty. \n    } \n```", "```cpp\n    void RectangleX::initializePoints(QPoint point) { \n      m_topLeft = point; \n      m_bottomRight = point; \n    } \n\n    void RectangleX::setLastPoint(QPoint point) { \n      m_bottomRight = point; \n    } \n```", "```cpp\n    bool RectangleX::isClick(QPoint mousePoint) { \n      QRect areaRect(m_topLeft, m_bottomRight); \n```", "```cpp\n      if (filled()) { \n        return areaRect.contains(mousePoint); \n      } \n```", "```cpp\n      else { \n        QRect largeAreaRect(areaRect), smallAreaRect(areaRect); \n\n        largeAreaRect += Tolerance; \n        smallAreaRect -= Tolerance; \n\n        return largeAreaRect.contains(mousePoint) && \n               !smallAreaRect.contains(mousePoint); \n      } \n\n      return false; \n    } \n```", "```cpp\n    void RectangleX::move(QSize distance) { \n      addSizeToPoint(m_topLeft, distance); \n      addSizeToPoint(m_bottomRight, distance); \n    } \n```", "```cpp\n    void RectangleX::draw(QPainter& painter) const { \n      painter.setPen(color()); \n```", "```cpp\n      if (filled()) { \n        painter.fillRect(QRect(m_topLeft, m_bottomRight), color()); \n      } \n```", "```cpp\n      else { \n        painter.setBrush(Qt::NoBrush); \n        painter.drawRect(QRect(m_topLeft, m_bottomRight)); \n      } \n    } \n```", "```cpp\n    bool RectangleX::write(ofstream& outStream) const { \n      Figure::write(outStream); \n      writePoint(outStream, m_topLeft); \n      writePoint(outStream, m_bottomRight); \n      return ((bool) outStream); \n    }\n```", "```cpp\n    bool RectangleX::read (ifstream& inStream) { \n      Figure::read(inStream); \n      readPoint(inStream, m_topLeft); \n      readPoint(inStream, m_bottomRight); \n      return ((bool) inStream); \n    } \n```", "```cpp\n    #ifndef ELLIPSE_H \n    #define ELLIPSE_H \n\n    #include \"Rectangle.h\" \n\n    class EllipseX : public RectangleX { \n      public: \n        EllipseX(); \n        FigureId getId() const {return EllipseId;} \n\n        EllipseX(const EllipseX& ellipse); \n\n        bool isClick(QPoint mousePoint); \n        void draw(QPainter& painter) const; \n    }; \n\n    #endif \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Ellipse.h\" \n\n    EllipseX::EllipseX() { \n      // Empty. \n    }\n```", "```cpp\n    bool EllipseX::isClick(QPoint mousePoint) { \n      QRect normalRect(m_topLeft, m_bottomRight); \n      normalRect.normalized(); \n```", "```cpp\n      if (filled()) { \n        QRegion normalEllipse(normalRect, QRegion::Ellipse); \n        return normalEllipse.contains(mousePoint); \n      } \n```", "```cpp\n      else { \n        QRect largeRect(normalRect), smallRect(normalRect); \n        largeRect += Tolerance; \n        smallRect -= Tolerance; \n\n        QRegion largeEllipse(largeRect, QRegion::Ellipse), \n                smallEllipse(smallRect, QRegion::Ellipse); \n\n        return (largeEllipse.contains(mousePoint) && \n                !smallEllipse.contains(mousePoint)); \n      } \n    } \n```", "```cpp\n    void EllipseX::draw(QPainter& painter) const { \n      painter.setPen(color()); \n```", "```cpp\n      if (filled()) { \n        painter.setBrush(color()); \n        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); \n      }\n```", "```cpp\n      else { \n        painter.setBrush(Qt::NoBrush); \n        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); \n      } \n    }\n```", "```cpp\n    #ifndef DRAWINGWINDOW_H \n    #define DRAWINGWINDOW_H \n\n    #include <QMainWindow> \n    #include <QActionGroup> \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"DrawingWidget.h\" \n\n    class DrawingWindow : public MainWindow { \n      Q_OBJECT \n\n      public: \n        DrawingWindow(QWidget* parentWidgetPtr = nullptr); \n        ~DrawingWindow(); \n\n      public: \n        void closeEvent(QCloseEvent *eventPtr)\n             { m_drawingWidgetPtr->closeEvent(eventPtr); } \n\n      private: \n        DrawingWidget* m_drawingWidgetPtr; \n        QActionGroup* m_figureGroupPtr; \n    }; \n\n    #endif // DRAWINGWINDOW_H \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"DrawingWindow.h\"\n```", "```cpp\n    DrawingWindow::DrawingWindow(QWidget* parentWidgetPtr \n                                 /* = nullptr */) \n     :MainWindow(parentWidgetPtr) { \n      resize(1000, 500); \n```", "```cpp\n      m_drawingWidgetPtr = new DrawingWidget(this); \n      setCentralWidget(m_drawingWidgetPtr); \n```", "```cpp\n      addFileMenu(); \n```", "```cpp\n      { QMenu* formatMenuPtr = menuBar()->addMenu(tr(\"F&ormat\")); \n        connect(formatMenuPtr, SIGNAL(aboutToShow()), \n                this, SLOT(onMenuShow())); \n```", "```cpp\n        addAction(formatMenuPtr, tr(\"&Color\"), \n                  SLOT(onColor()), QKeySequence(Qt::ALT + Qt::Key_C), \n                  QString(), nullptr, tr(\"Figure Color\")); \n```", "```cpp\n        addAction(formatMenuPtr, tr(\"&Fill\"), \n                  SLOT(onFill()), QKeySequence(Qt::CTRL + Qt::Key_F), \n                  QString(), nullptr, tr(\"Figure Fill\"), \n                  LISTENER(isFillEnabled)); \n      } \n```", "```cpp\n      { m_figureGroupPtr = new QActionGroup(this); \n\n        QMenu* figureMenuPtr = menuBar()->addMenu(tr(\"F&igure\")); \n        connect(figureMenuPtr, SIGNAL(aboutToShow()), \n                this, SLOT(onMenuShow()));\n```", "```cpp\n        addAction(figureMenuPtr, tr(\"&Line\"), \n                  SLOT(onLine()), QKeySequence(Qt::CTRL + Qt::Key_L), \n                  QString(), nullptr, tr(\"Line Figure\"), nullptr, \n                  LISTENER(isLineChecked), m_figureGroupPtr); \n        addAction(figureMenuPtr, tr(\"&Rectangle\"), \n                  SLOT(onRectangle()), \n                  QKeySequence(Qt::CTRL + Qt::Key_R), \n                  QString(), nullptr, tr(\"Rectangle Figure\"), nullptr, \n                  LISTENER(isRectangleChecked), m_figureGroupPtr); \n        addAction(figureMenuPtr, tr(\"&Ellipse\"), \n                  SLOT(onEllipse()), \n                  QKeySequence(Qt::CTRL + Qt::Key_E), \n                  QString(), nullptr, tr(\"Ellipse Figure\"), nullptr, \n                  LISTENER(isEllipseChecked), m_figureGroupPtr); \n      } \n    } \n```", "```cpp\n    DrawingWindow::~DrawingWindow() { \n      delete m_figureGroupPtr; \n    } \n```", "```cpp\n    #ifndef DRAWINGWIDGET_H \n    #define DRAWINGWIDGET_H \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"Figure.h\" \n\n    class DrawingWidget : public DocumentWidget { \n      Q_OBJECT \n\n      public: \n        DrawingWidget(QWidget* parentWidgetPtr); \n        ~DrawingWidget(); \n```", "```cpp\n      public: \n        void mousePressEvent(QMouseEvent *eventPtr); \n        void mouseReleaseEvent(QMouseEvent *eventPtr); \n        void mouseMoveEvent(QMouseEvent *eventPtr); \n```", "```cpp\n        void paintEvent(QPaintEvent *eventPtr); \n```", "```cpp\n      private: \n        void newDocument() override; \n        bool writeFile(const QString& filePath); \n        bool readFile(const QString& filePath); \n        Figure* createFigure(FigureId figureId); \n```", "```cpp\n      public slots: \n        void onColor(); \n        void onFill(); \n```", "```cpp\n        DEFINE_LISTENER(DrawingWidget, isFillEnabled);\n```", "```cpp\n        DEFINE_LISTENER(DrawingWidget, isLineChecked); \n        DEFINE_LISTENER(DrawingWidget, isRectangleChecked); \n        DEFINE_LISTENER(DrawingWidget, isEllipseChecked); \n```", "```cpp\n        void onLine(); \n        void onRectangle(); \n        void onEllipse(); \n```", "```cpp\n      private: \n        enum ApplicationMode {Idle, Create, Move}; \n        ApplicationMode m_applicationMode = Idle; \n        void setApplicationMode(ApplicationMode mode); \n```", "```cpp\n        QColor m_currColor = Qt::black; \n        bool m_currFilled = false; \n        FigureId m_addFigureId = LineId; \n```", "```cpp\n        QPoint m_mousePoint;\n```", "```cpp\n        QList<Figure*> m_figurePtrList; \n    }; \n\n    #endif // DRAWINGWIDGET_H \n```", "```cpp\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n    #include \"DrawingWidget.h\" \n\n    #include \"Line.h\" \n    #include \"Rectangle.h\" \n    #include \"Ellipse.h\" \n```", "```cpp\n    DrawingWidget::DrawingWidget(QWidget* parentWidgetPtr) \n     :DocumentWidget(tr(\"Drawing\"), tr(\"Drawing files (*.drw)\"), \n                     parentWidgetPtr) { \n      // Empty. \n    } \n```", "```cpp\n    DrawingWidget::~DrawingWidget() { \n      for (Figure* figurePtr : m_figurePtrList) { \n        delete figurePtr; \n      } \n    } \n```", "```cpp\n    void DrawingWidget::setApplicationMode(ApplicationMode mode) { \n      m_applicationMode = mode; \n      ((MainWindow*) parent())->onMenuShow(); \n    }\n```", "```cpp\n    void DrawingWidget::newDocument() { \n      for (Figure* figurePtr : m_figurePtrList) { \n        delete figurePtr; \n      } \n      m_figurePtrList.clear(); \n```", "```cpp\n      m_currColor = Qt::black; \n      m_addFigureId = LineId; \n      m_currFilled = false; \n    } \n```", "```cpp\n    bool DrawingWidget::writeFile(const QString& filePath) { \n      ofstream outStream(filePath.toStdString()); \n```", "```cpp\n      if (outStream) { \n        writeColor(outStream, m_currColor); \n        outStream.write((char*) &m_currFilled, sizeof m_currFilled); \n\n        int size = m_figurePtrList.size(); \n        outStream.write((char*) &size, sizeof size); \n```", "```cpp\n        for (Figure* figurePtr : m_figurePtrList) { \n          FigureId figureId = figurePtr->getId(); \n          outStream.write((char*) &figureId, sizeof figureId); \n          figurePtr->write(outStream); \n        } \n\n        return ((bool) outStream); \n      } \n```", "```cpp\n      return false; \n    }\n```", "```cpp\n    bool DrawingWidget::readFile(const QString& filePath) { \n      ifstream inStream(filePath.toStdString()); \n\n      if (inStream) { \n        readColor(inStream, m_currColor); \n        inStream.read((char*) &m_currFilled, sizeof m_currFilled); \n\n        int size; \n        inStream.read((char*) &size, sizeof size); \n```", "```cpp\n        for (int count = 0; count < size; ++count) { \n          FigureId figureId = (FigureId) 0; \n          inStream.read((char*) &figureId, sizeof figureId); \n          Figure* figurePtr = createFigure(figureId); \n          figurePtr->read(inStream); \n          m_figurePtrList.push_back(figurePtr); \n        } \n\n        return ((bool) inStream); \n      } \n\n      return false; \n    } \n```", "```cpp\n    Figure* DrawingWidget::createFigure(FigureId figureId) { \n      Figure* figurePtr = nullptr; \n\n      switch (figureId) { \n        case LineId: \n          figurePtr = new Line(); \n          break; \n\n        case RectangleId: \n          figurePtr = new RectangleX(); \n          break; \n\n        case EllipseId: \n          figurePtr = new EllipseX(); \n          break; \n      } \n\n      return figurePtr; \n    } \n```", "```cpp\n    void DrawingWidget::onColor() { \n      QColor newColor = QColorDialog::getColor(m_currColor, this); \n\n      if (newColor.isValid() && (m_currColor != newColor)) { \n        m_currColor = newColor; \n        setModifiedFlag(true); \n      } \n    } \n```", "```cpp\n    bool DrawingWidget::isFillEnabled() { \n      return (m_addFigureId == RectangleId) || \n             (m_addFigureId == EllipseId); \n    } \n```", "```cpp\n    void DrawingWidget::onFill() { \n      m_currFilled = !m_currFilled; \n      setModifiedFlag(true); \n    } \n```", "```cpp\n    bool DrawingWidget::isLineChecked() { \n      return (m_addFigureId == LineId); \n    } \n\n    bool DrawingWidget::isRectangleChecked() { \n      return (m_addFigureId == RectangleId); \n    } \n\n    bool DrawingWidget::isEllipseChecked() { \n      return (m_addFigureId == EllipseId); \n    } \n```", "```cpp\n    void DrawingWidget::onLine() { \n      m_addFigureId = LineId; \n    } \n\n    void DrawingWidget::onRectangle() { \n      m_addFigureId = RectangleId; \n    } \n\n    void DrawingWidget::onEllipse() { \n      m_addFigureId = EllipseId; \n    } \n```", "```cpp\n    void DrawingWidget::mousePressEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n```", "```cpp\n        m_mousePoint = eventPtr->pos(); \n```", "```cpp\n        for (QList<Figure*>::reverse_iterator iterator = \n             m_figurePtrList.rbegin(); \n             iterator != m_figurePtrList.rend(); ++iterator) {\n```", "```cpp\n              Figure* figurePtr = *iterator; \n```", "```cpp\n          if (figurePtr->isClick(m_mousePoint)) { \n            setApplicationMode(Move); \n            m_figurePtrList.removeOne(figurePtr); \n            m_figurePtrList.push_back(figurePtr); \n            break; \n          } \n        } \n```", "```cpp\n        if (m_applicationMode == Idle) { \n          setApplicationMode(Create); \n          Figure* newFigurePtr = createFigure(m_addFigureId); \n          newFigurePtr->color() = m_currColor; \n          newFigurePtr->filled() = m_currFilled; \n          newFigurePtr->initializePoints(m_mousePoint); \n          m_figurePtrList.push_back(newFigurePtr); \n          setModifiedFlag(true); \n        } \n      } \n    } \n```", "```cpp\n    void DrawingWidget::mouseMoveEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n        QPoint newMousePoint = eventPtr->pos();\n```", "```cpp\n        switch (m_applicationMode) { \n          case Create: \n            m_figurePtrList.back()->setLastPoint(m_mousePoint); \n            break; \n```", "```cpp\n          case Move: { \n              QSize distance(newMousePoint.x() - m_mousePoint.x(), \n                             newMousePoint.y() - m_mousePoint.y()); \n              m_figurePtrList.back()->move(distance); \n              setModifiedFlag(true); \n            } \n            break; \n        } \n```", "```cpp\n        m_mousePoint = newMousePoint; \n        update(); \n      } \n    } \n```", "```cpp\n    void DrawingWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n        setApplicationMode(Idle); \n      } \n    } \n```", "```cpp\n    void DrawingWidget::paintEvent(QPaintEvent* /* eventPtr */) { \n      QPainter painter(this); \n      painter.setRenderHint(QPainter::Antialiasing); \n      painter.setRenderHint(QPainter::TextAntialiasing); \n\n      for (Figure* figurePtr : m_figurePtrList) { \n        figurePtr->draw(painter); \n      } \n    } \n```", "```cpp\n    #include \"DrawingWindow.h\" \n    #include <QApplication> \n\n    int main(int argc, char *argv[]) { \n      QApplication application(argc, argv); \n      DrawingWindow drawingWindow; \n      drawingWindow.show(); \n      return application.exec(); \n    }\n```", "```cpp\n    #ifndef CARET_H \n    #define CARET_H \n\n    #include <QObject> \n    #include <QWidget> \n    #include <QTimer> \n\n    class Caret : public QObject { \n      Q_OBJECT \n\n      public: \n        Caret(QWidget* parentWidgetPtr = nullptr);\n\n```", "```cpp\n        void show(); \n        void hide(); \n```", "```cpp\n        void set(QRect rect); \n        void paint(QPainter& painter); \n```", "```cpp\n      public slots: \n        void onTimer(void); \n\n      private: \n        QWidget* m_parentWidgetPtr; \n```", "```cpp\n        bool m_visible, m_blink; \n```", "```cpp\n        QRect m_rect; \n```", "```cpp\n        QTimer m_timer; \n    }; \n\n    #endif // CARET_H \n```", "```cpp\n    #include \"Caret.h\" \n    #include <QPainter>\n```", "```cpp\n    Caret::Caret(QWidget* parentWidgetPtr) \n      :m_parentWidgetPtr(parentWidgetPtr) { \n      m_timer.setParent(this); \n      connect(&m_timer, SIGNAL(timeout()), this, SLOT(onTimer())); \n      m_timer.start(500); \n    } \n```", "```cpp\n    void Caret::show() { \n      m_visible = true; \n      m_parentWidgetPtr->update(m_rect); \n    } \n\n    void Caret::hide() { \n      m_visible = false; \n      m_parentWidgetPtr->update(m_rect); \n    } \n```", "```cpp\n    void Caret::set(QRect rect) { \n      m_rect = rect; \n      m_rect.setWidth(1); \n      m_parentWidgetPtr->update(m_rect); \n    } \n```", "```cpp\n    void Caret::onTimer(void) { \n      m_blink = !m_blink; \n      m_parentWidgetPtr->update(m_rect); \n    }\n```", "```cpp\n    void Caret::paint(QPainter& painter) { \n      if (m_visible && m_blink) { \n        painter.save(); \n        painter.setPen(Qt::NoPen); \n        painter.setBrush(Qt::black); \n        painter.drawRect(m_rect); \n        painter.restore(); \n      } \n    } \n```", "```cpp\n    #ifndef EDITORWINDOW_H \n    #define EDITORWINDOW_H \n\n    #include <QMainWindow> \n    #include <QActionGroup> \n    #include <QPair> \n    #include <QMap> \n\n    #include \"..\\MainWindow\\MainWindow.h\" \n    #include \"EditorWidget.h\" \n\n    class EditorWindow : public MainWindow { \n      Q_OBJECT \n\n      public: \n        EditorWindow(QWidget* parentWidgetPtr = nullptr); \n        ~EditorWindow(); \n```", "```cpp\n      protected: \n        void keyPressEvent(QKeyEvent* eventPtr); \n        void closeEvent(QCloseEvent* eventPtr); \n\n      private: \n        EditorWidget* m_editorWidgetPtr; \n    }; \n\n    #endif // EDITORWINDOW_H \n```", "```cpp\n    #include \"EditorWindow.h\" \n    #include <QtWidgets> \n```", "```cpp\n    EditorWindow::EditorWindow(QWidget* parentWidgetPtr /*= nullptr*/) \n     :MainWindow(parentWidgetPtr) { \n      resize(1000, 500); \n      m_editorWidgetPtr = new EditorWidget(this); \n      setCentralWidget(m_editorWidgetPtr); \n      addFileMenu(); \n    } \n\n    EditorWindow::~EditorWindow() { \n      // Empty. \n    } \n```", "```cpp\n    void EditorWindow::keyPressEvent(QKeyEvent* eventPtr) { \n      m_editorWidgetPtr->keyPressEvent(eventPtr); \n    } \n\n    void EditorWindow::closeEvent(QCloseEvent* eventPtr) { \n      m_editorWidgetPtr->closeEvent(eventPtr); \n    }\n```", "```cpp\n    #ifndef EDITORWIDGET_H \n    #define EDITORWIDGET_H \n\n    #include <QWidget> \n    #include <QMap> \n    #include <QMenu> \n    #include <QToolBar> \n    #include <QPair> \n    #include \"Caret.h\" \n\n    #include \"..\\MainWindow\\DocumentWidget.h\" \n\n    class EditorWidget : public DocumentWidget { \n      Q_OBJECT \n\n      public: \n        EditorWidget(QWidget* parentWidgetPtr); \n```", "```cpp\n        void keyPressEvent(QKeyEvent* eventPtr); \n        void mousePressEvent(QMouseEvent* eventPtr); \n```", "```cpp\n      private: \n        int mouseToIndex(QPoint point); \n```", "```cpp\n      public: \n        void paintEvent(QPaintEvent* eventPtr); \n        void resizeEvent(QResizeEvent* eventPtr);\n```", "```cpp\n      private: \n        void newDocument(void); \n        bool writeFile(const QString& filePath); \n        bool readFile(const QString& filePath); \n```", "```cpp\n      private: \n        void setCaret(); \n```", "```cpp\n        void simulateMouseClick(int x, int y); \n```", "```cpp\n      private: \n        void calculate(); \n```", "```cpp\n        int m_editIndex = 0; \n```", "```cpp\n        Caret m_caret; \n```", "```cpp\n        QString m_editorText; \n```", "```cpp\n        QList<QPair<int,int>> m_lineList; \n```", "```cpp\n        QList<QRect> m_rectList;\n```", "```cpp\n        static const QFont TextFont; \n```", "```cpp\n         int FontWidth, FontHeight; \n    }; \n\n    #endif // EDITORWIDGET_H \n```", "```cpp\n    #include \"EditorWidget.h\" \n    #include <QtWidgets> \n    using namespace std; \n```", "```cpp\n    const QFont EditorWidget::TextFont(\"Courier New\", 12); \n```", "```cpp\n    EditorWidget::EditorWidget(QWidget* parentWidgetPtr) \n     :DocumentWidget(tr(\"Editor\"), tr(\"Editor files (*.edi)\"), \n                     parentWidgetPtr), \n      m_caret(this), \n      m_editorText(tr(\"Hello World\")) { \n      QFontMetrics metrics(TextFont);\n      FontHeight = metrics.height();\n      FontWidth = metrics.averageCharWidth();\n      calculate(); \n      setCaret(); \n      m_caret.show(); \n    } \n```", "```cpp\n    void EditorWidget::newDocument(void) { \n      m_editIndex = 0; \n      m_editorText.clear(); \n      calculate(); \n      setCaret(); \n    } \n```", "```cpp\n    bool EditorWidget::writeFile(const QString& filePath) { \n      QFile file(filePath); \n      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) { \n        QTextStream outStream(&file); \n        outStream << m_editorText; \n```", "```cpp\n        return ((bool) outStream.Ok); \n      } \n```", "```cpp\n      return false; \n    } \n```", "```cpp\n    bool EditorWidget::readFile(const QString& filePath) { \n      QFile file(filePath); \n\n      if (file.open(QIODevice::ReadOnly | QIODevice::Text)) { \n        QTextStream inStream(&file); \n        m_editorText = inStream.readAll(); \n```", "```cpp\n        calculate(); \n        setCaret(); \n```", "```cpp\n        return ((bool) inStream.Ok); \n      } \n```", "```cpp\n      return false; \n    }\n```", "```cpp\n    void EditorWidget::mousePressEvent(QMouseEvent* eventPtr) { \n      if (eventPtr->buttons() == Qt::LeftButton) { \n        m_editIndex = mouseToIndex(eventPtr->pos()); \n        setCaret(); \n      } \n    } \n```", "```cpp\n    void EditorWidget::keyPressEvent(QKeyEvent* eventPtr) { \n      switch (eventPtr->key()) { \n```", "```cpp\n        case Qt::Key_Left: \n          if (m_editIndex > 0) { \n            --m_editIndex; \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Right: \n          if (m_editIndex < m_editorText.size()) { \n            ++m_editIndex; \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Up: { \n            QRect charRect = m_rectList[m_editIndex]; \n\n            if (charRect.top() > 0) { \n              int x = charRect.left() + (charRect.width() / 2), \n                  y = charRect.top() - 1; \n              simulateMouseClick(x, y); \n            } \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Down: { \n            QRect charRect = m_rectList[m_editIndex]; \n            int x = charRect.left() + (charRect.width() / 2), \n                y = charRect.bottom() + 1; \n            simulateMouseClick(x, y); \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Delete: \n          if (m_editIndex < m_editorText.size()) { \n            m_editorText.remove(m_editIndex, 1); \n            setModifiedFlag(true); \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Backspace: \n          if (m_editIndex > 0) { \n            m_editorText.remove(--m_editIndex, 1); \n            setModifiedFlag(true); \n          } \n          break; \n```", "```cpp\n        case Qt::Key_Return: \n          m_editorText.insert(m_editIndex++, 'n'); \n          setModifiedFlag(true); \n          break;\n```", "```cpp\n        default: { \n            QString text = eventPtr->text(); \n\n            if (!text.isEmpty()) { \n              m_editorText.insert(m_editIndex++, text[0]); \n              setModifiedFlag(true); \n            } \n          } \n          break; \n      }  \n```", "```cpp\n      calculate(); \n      setCaret(); \n      update(); \n    } \n```", "```cpp\n    void EditorWidget::simulateMouseClick(int x, int y) { \n      QMouseEvent pressEvent(QEvent::MouseButtonPress, QPointF(x, y), \n                       Qt::LeftButton, Qt::NoButton, Qt::NoModifier); \n      mousePressEvent(&pressEvent); \n      QMouseEvent releaseEvent(QEvent::MouseButtonRelease, \n                               QPointF(x, y), Qt::LeftButton, \n                               Qt::NoButton, Qt::NoModifier); \n      mousePressEvent(&releaseEvent); \n    } \n```", "```cpp\n    void EditorWidget::setCaret() { \n      QRect charRect = m_rectList[m_editIndex]; \n      QRect caretRect(charRect.left(), charRect.top(), \n                      1, charRect.height()); \n      m_caret.hide(); \n      m_caret.set(caretRect); \n      m_caret.show(); \n    }\n```", "```cpp\n    int EditorWidget::mouseToIndex(QPoint mousePoint) { \n      int x = mousePoint.x(), y = mousePoint.y(); \n```", "```cpp\n      if (y > (FontHeight * m_lineList.size())) { \n        y = ((FontHeight * m_lineList.size()) - 1); \n      } \n```", "```cpp\n      int lineIndex = y / FontHeight; \n      QPair<int,int> lineInfo = m_lineList[lineIndex]; \n      int firstIndex = lineInfo.first, lastIndex = lineInfo.second; \n```", "```cpp\n      if (x > ((lastIndex - firstIndex + 1) * FontWidth)) { \n        return (lineIndex == (m_lineList.size() - 1)) \n               ? (lineInfo.second + 1) : lineInfo.second; \n      } \n      else { \n        return firstIndex + (x / FontWidth); \n      } \n\n      return 0; \n    } \n```", "```cpp\n    void EditorWidget::resizeEvent(QResizeEvent* eventPtr) { \n      calculate(); \n      DocumentWidget::resizeEvent(eventPtr); \n    } \n```", "```cpp\n    void EditorWidget::calculate() { \n      m_lineList.clear(); \n      m_rectList.clear(); \n      int windowWidth = width();\n```", "```cpp\n      { int firstIndex = 0, lineWidth = 0; \n        for (int charIndex = 0; charIndex < m_editorText.size(); \n             ++charIndex) { \n          QChar c = m_editorText[charIndex]; \n\n          if (c == 'n') { \n            m_lineList.push_back \n                       (QPair<int,int>(firstIndex, charIndex)); \n            firstIndex = charIndex + 1; \n            lineWidth = 0; \n          } \n          else { \n            if ((lineWidth + FontWidth) > windowWidth) { \n              if (firstIndex == charIndex) { \n                m_lineList.push_back \n                           (QPair<int,int>(firstIndex, charIndex)); \n                firstIndex = charIndex + 1; \n              } \n              else { \n                m_lineList.push_back(QPair<int,int>(firstIndex, \n                                                    charIndex - 1)); \n                firstIndex = charIndex; \n              } \n\n              lineWidth = 0; \n            } \n            else { \n              lineWidth += FontWidth; \n            } \n          } \n        } \n\n        m_lineList.push_back(QPair<int,int>(firstIndex, \n                                            m_editorText.size() - 1)); \n      } \n```", "```cpp\n      { int top = 0; \n        for (int lineIndex = 0; lineIndex < m_lineList.size(); \n             ++lineIndex) { \n          QPair<int,int> lineInfo = m_lineList[lineIndex]; \n          int firstIndex = lineInfo.first, \n              lastIndex = lineInfo.second, left = 0; \n\n          for (int charIndex = firstIndex; \n               charIndex <= lastIndex; ++charIndex){ \n            QRect charRect(left, top, FontWidth, FontHeight); \n            m_rectList.push_back(charRect); \n            left += FontWidth; \n          } \n\n          if (lastIndex == (m_editorText.size() - 1)) { \n            QRect lastRect(left, top, 1, FontHeight); \n            m_rectList.push_back(lastRect); \n          } \n\n          top += FontHeight; \n        } \n      } \n    } \n```", "```cpp\n    void EditorWidget::paintEvent(QPaintEvent* /*eventPtr*/) { \n      QPainter painter(this); \n      painter.setRenderHint(QPainter::Antialiasing); \n      painter.setRenderHint(QPainter::TextAntialiasing); \n      painter.setFont(TextFont); \n      painter.setPen(Qt::black); \n      painter.setBrush(Qt::white); \n```", "```cpp\n      for (int index = 0; index < m_editorText.length(); ++index) { \n        QChar c = m_editorText[index]; \n\n        if (c != 'n') { \n          QRect rect = m_rectList[index]; \n          painter.drawText(rect, c); \n        } \n      } \n\n      m_caret.paint(painter); \n    }\n```", "```cpp\n#include \"EditorWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  EditorWindow editorWindow; \n  editorWindow.show(); \n  return application.exec(); \n} \n```"]