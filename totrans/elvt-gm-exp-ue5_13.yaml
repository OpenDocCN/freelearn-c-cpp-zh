- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Creating and Adding the Enemy Artificial Intelligence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和添加敌人人工智能
- en: In the previous chapter, you added layered animations for the player character
    using animation blending with a combination of Anim Slots, Animation Blueprints,
    and blending functions such as `Layered blend per bone`. With this knowledge,
    you were able to smoothly blend the throwing animation montage with the base movement
    state machine to create layered animations for the character.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用动画混合结合 Anim Slots、Animation Blueprints 和如 `Layered blend per bone`
    这样的混合函数为玩家角色添加了分层动画。有了这些知识，你能够将投掷动画蒙太奇与基本运动状态机平滑地混合，为角色创建分层动画。
- en: The primary focus of this chapter is to take the C++ enemy class you created
    in [*Chapter 12*](B18531_12.xhtml#_idTextAnchor247), *Animation Blending and Montages*,
    and bring this enemy to life using AI. UE5 uses many different tools to achieve
    AI, such as AI Controllers, Blackboards, and Behavior Trees, all of which you
    will learn about and use in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点是，将你在 [*第 12 章*](B18531_12.xhtml#_idTextAnchor247) *动画混合与蒙太奇* 中创建的 C++
    敌人类，通过人工智能使其活跃起来。UE5 使用了许多不同的工具来实现人工智能，例如 AI 控制器、黑板和行为树，所有这些你都将在这章中学习并使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to use a Navigation Mesh to create a navigable space inside of the game
    world that the enemy can move in.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用导航网格在游戏世界中创建一个敌人物体可以移动的可导航空间。
- en: How to create an enemy AI pawn that can navigate between patrol point locations
    inside the game world using a combination of the AI tools present inside `Blackboards`
    and `Behavior Trees`.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个可以使用 `Blackboards` 和 `Behavior Trees` 中现有的 AI 工具在游戏世界中巡逻点位置之间导航的敌人物体 AI。
- en: How to use a Transform Vector to convert local transform into world transform.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用变换向量将局部变换转换为世界变换。
- en: How to create a player projectile class in C++, and how to implement the `OnHit()`collision
    event function to recognize and log when the projectile hits an object in the
    game world.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 C++ 中创建玩家弹射物类，以及如何实现 `OnHit()` 碰撞事件函数以识别和记录弹射物在游戏世界中击中对象的情况。
- en: By the end of this chapter, you will be able to create a navigable space where
    the enemy can move. You will also be able to create an enemy AI pawn and navigate
    it across locations using `Blackboards` and `Behavior Trees`. Lastly, you will
    know how to create and implement a player projectile class and add visual elements
    to it. Before you jump into these systems, let’s take a moment to learn about
    how AI has been used in games in recent history. AI has certainly evolved since
    the days of *Super Mario Bros*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建一个敌人物体可以移动的可导航空间。你还将能够创建一个敌人物体 AI 并使用 `Blackboards` 和 `Behavior
    Trees` 在位置之间导航。最后，你将了解如何创建和实现玩家弹射物类，并为其添加视觉元素。在你深入这些系统之前，让我们花点时间了解一下人工智能在近年来游戏中的应用。自从
    *超级马里奥兄弟* 时代以来，人工智能确实已经发展了很多。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Unreal Engine 5
- en: Visual Studio 2019 installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Visual Studio 2019
- en: The project for this chapter can be found in the `Chapter13` folder of the code
    bundle for this book, which can be downloaded from
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 `Chapter13` 文件夹中找到，可以从
- en: '[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
- en: Enemy AI
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人 AI
- en: What is **artificial intelligence** (**AI**)? This term can mean many things,
    depending on the field and context where it is used, so let’s define it in a way
    that makes sense regarding the subject of video games.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**人工智能**（**AI**）？这个术语可以意味着很多不同的东西，这取决于它被使用的领域和上下文，因此让我们以游戏主题为依据来定义它。
- en: '**AI** is an entity that is aware of its environment and performs choices that
    will help it optimally achieve its intended purpose. AI uses what are called **finite
    state machines** to switch between more than one state based on the input it receives
    from the user or its environment. For example, a video game AI can switch between
    an offensive state to a defensive state based on its current health.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI**是一个了解其环境的实体，并执行有助于其最优实现预期目的的选择。AI使用所谓的**有限状态机**根据从用户或其环境接收的输入在多个状态之间切换。例如，视频游戏AI可以根据其当前健康状态在攻击状态和防御状态之间切换。'
- en: 'In games such as *Hello Neighbor*, which was developed in Unreal Engine 4,
    and *Alien: Isolation*, the goal of the AI is to find the player as efficiently
    as possible, but also to follow some predetermined patterns defined by the developers
    to ensure that the player can outsmart it. *Hello Neighbor* adds a very creative
    element to its AI by having it learn from the players’ past actions and try to
    outsmart the player based on the knowledge it learns.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '在像*Hello Neighbor*这样的游戏中，该游戏是用Unreal Engine 4开发的，以及*Alien: Isolation*，AI的目标是以尽可能高的效率找到玩家，同时也遵循开发者定义的一些预定模式，以确保玩家可以智胜它。*Hello
    Neighbor*通过让AI从玩家的过去行为中学习，并根据所学知识试图智胜玩家，为AI添加了一个非常创造性的元素。'
- en: 'You can find an informative breakdown of how the AI works in the following
    video by the publishers of the game, *TinyBuild Games*: [https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在游戏发行商TinyBuild Games发布的以下视频中找到有关AI如何工作的信息分解：[https://www.youtube.com/watch?v=Hu7Z52RaBGk](https://www.youtube.com/watch?v=Hu7Z52RaBGk)。
- en: Interesting and fun AI is crucial to any game, and depending on the game you
    are making, this can mean a very complex or very simplistic AI. The AI that you
    will be creating for the `SuperSideScroller` game will not be as sophisticated
    as those mentioned previously, but it will fill the needs of the game we are seeking
    to create.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣且有趣的AI对任何游戏都至关重要，并且根据你正在制作的游戏，这可能意味着一个非常复杂或非常简单的AI。为`SuperSideScroller`游戏创建的AI将不会像之前提到的那么复杂，但它将满足我们想要创建的游戏的需求。
- en: 'Let’s break down how the enemy will behave:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下敌人将如何表现：
- en: The enemy will be a very simple enemy that has a basic back and forth movement
    pattern and will not support any attacks; only by colliding with the player character
    will they be able to inflict any damage.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将是一个非常简单的敌人，它有一个基本的来回移动模式，并且不支持任何攻击；只有通过碰撞玩家角色，它们才能造成任何伤害。
- en: However, we need to set the locations for the enemy AI to move between.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，我们需要为敌人AI设置移动之间的位置。
- en: Next, we must decide whether the AI should change locations, should constantly
    move between locations, or whether there should be a pause inbetween selecting
    a new location to move to.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们必须决定AI是否应该改变位置，是否应该不断在位置之间移动，或者是否在选择新位置之间应该有暂停。
- en: Fortunately for us, UE5 provides us with a wide array of tools that we can use
    to develop such complex AI. In the case of our project, however, we will use these
    tools to create a simplistic enemy type. Let’s start by discussing what an AI
    Controller is in UE5.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，UE5为我们提供了一系列工具，我们可以使用这些工具来开发这样的复杂AI。然而，在我们的项目中，我们将使用这些工具来创建一个简单的敌人类型。让我们首先讨论一下UE5中的AI控制器是什么。
- en: AI Controller
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI控制器
- en: Let’s discuss what the main difference is between a **Player Controller** and
    an **AI Controller**. Both of these actors derive from the base **Controller**
    class. A **Controller** is used to take control of a **Pawn** or **Character**
    to control the actions of said pawn or character.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下**玩家控制器**和**AI控制器**之间的主要区别。这两个演员都源自基础**控制器**类。**控制器**用于控制**Pawn**或**Character**，以控制该Pawn或角色的动作。
- en: While a `UWorld` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于`UWorld`类中时。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will learn more about the `UWorld` class in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*, but as a reference, you can read more here:
    [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[*第14章*](B18531_14.xhtml#_idTextAnchor298)中了解更多关于`UWorld`类的信息，*生成玩家投射物*，但作为一个参考，你可以在以下链接中阅读更多：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/index.xhtml)。
- en: The most important aspect of both the Player Controller and the AI Controller
    is the pawns they will control. Let’s learn more about how AI Controllers handle
    this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器和AI控制器最重要的方面是它们将要控制的棋子。让我们更多地了解AI控制器是如何处理这个问题的。
- en: Auto Possess AI
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动控制AI
- en: 'Like all Controllers, the AI Controller must possess a *pawn*. In C++, you
    can use the following function to possess a pawn:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有控制器一样，AI控制器必须控制一个*棋子*。在C++中，你可以使用以下函数来控制棋子：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the following function to unpossess a pawn:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下函数来释放一个棋子：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There’s also the `void AController::OnPossess(APawn* InPawn)` and `void AController::OnUnPossess()`functions,
    which are called whenever the `Possess()` and `UnPossess()`functions are called,
    respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`void AController::OnPossess(APawn* InPawn)`和`void AController::OnUnPossess()`函数，它们分别在调用`Possess()`和`UnPossess()`函数时被调用。
- en: 'When it comes to AI, especially in the context of UE5, there are two methods
    in which AI Pawns or Characters can be possessed by an AI Controller. Let’s take
    a look at these options:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到AI时，尤其是在UE5的上下文中，有两种方法可以使AI棋子或角色被AI控制器控制。让我们看看这些选项：
- en: '`Placed in World`: This first method is how you will be handling AI in this
    project; you will manually place these enemy actors into your game world, and
    the AI will take care of the rest once the game begins.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`放置在世界`：这是你在这个项目中处理AI的方法；你将手动将这些敌人演员放置到你的游戏世界中，一旦游戏开始，AI将负责其余部分。'
- en: '`Spawned`: This second method is only a little more complicated because it
    requires an explicit function call, either in C++ or Blueprint, to `Spawn` an
    instance of a specified class. The `Spawn Actor` method requires a handful of
    parameters, including the `World` object and `Transform` parameters such as `Location`
    and `Rotation`, to ensure that the instance that is spawned is spawned correctly.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`生成`：第二种方法稍微复杂一些，因为它需要显式地调用C++或蓝图中的`生成`函数，以生成指定类的实例。`生成演员`方法需要一些参数，包括`世界`对象和`变换`参数，如`位置`和`旋转`，以确保生成的实例被正确生成。'
- en: '`Placed in World or Spawned`: If you are unsure of which method you want to
    use, a safe option would be `Placed in World or Spawned`; that way, both methods
    are supported.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`放置在世界或生成`：如果你不确定想使用哪种方法，一个安全的选择是`放置在世界或生成`；这样，两种方法都得到了支持。'
- en: For the `SuperSideScroller` game, you will be using the `Placed` `in` `World`
    option because the AI you will create will be manually placed in the game level.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`SuperSideScroller`游戏，你将使用`放置` `在` `世界`选项，因为你要创建的AI将手动放置在游戏关卡中。
- en: Let’s move to our first exercise where we will implement the AI Controller for
    the enemy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到第一个练习，我们将在这里实现敌人的AI控制器。
- en: Exercise 13.01 – implementing AI Controllers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01 – 实现AI控制器
- en: Before the enemy pawn can do anything, it needs to be possessed by an AI Controller.
    This also needs to happen before any logic can be performed by the AI. By the
    end of this exercise, you will have created an AI Controller and applied it to
    the enemy that you created in the previous chapter. Let’s begin by creating the
    AI Controller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人棋子能够做任何事情之前，它需要被AI控制器控制。这也需要在AI执行任何逻辑之前发生。在这个练习结束时，你将创建一个AI控制器并将其应用于上一章中创建的敌人。让我们首先创建AI控制器。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Head to the `Content/Enemy` directory.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content/Enemy`目录。
- en: '*Right-click* on the `Enemy` folder and select the `AI`. In the new `AI` folder
    directory, *right-click* and select the **Blueprint Class** option.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键点击* `敌人`文件夹并选择`AI`。在新`AI`文件夹目录中，*右键点击*并选择**蓝图类**选项。'
- en: From the `AIController` class.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AIController`类。
- en: '*Left-click* this class option and then *left-click* on the blue `AIController`
    class. Also, take note of the tooltip that appears when hovering over the class
    option; it contains useful information about this class from the developers:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*这个类选项，然后*左键点击*蓝色的`AIController`类。还要注意当鼠标悬停在类选项上时出现的工具提示；它包含来自开发者的关于这个类的有用信息：'
- en: '![Figure 13.1 – The AIController asset class, as found in the Pick Parent Class
    dialog box ](img/Figure_13.01_B18531.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – AIController资产类，如图13.01_B18531.jpg所示，在选择父类对话框中找到](img/Figure_13.01_B18531.jpg)'
- en: Figure 13.1 – The AIController asset class, as found in the Pick Parent Class
    dialog box
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – AIController资产类，如图13.01_B18531.jpg所示，在选择父类对话框中找到
- en: With this new `AIController Blueprint` created, name this asset `BP_AIControllerEnemy`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新创建的`AIController蓝图`，将这个资产命名为`BP_AIControllerEnemy`。
- en: With the AI Controller created and named, it’s time to assign this asset to
    the first enemy Blueprint that you made in the previous chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器创建并命名后，现在是时候将此资产分配到你在上一章中制作的第一个敌人蓝图了。
- en: Navigate to the `/Enemy/Blueprints` directory to find `BP_Enemy`. *Double-click*
    to open this Blueprint.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/Enemy/Blueprints`目录以找到`BP_Enemy`。*双击*打开这个蓝图。
- en: In the `Pawn`. This is where you can set different parameters regarding the
    AI functionality of `Pawn` or `Character`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pawn`中。这是你可以设置有关`Pawn`或`Character`的AI功能的不同参数的地方。
- en: The `AI Controller Class` parameter determines, as its name suggests, which
    AI Controller to use for this enemy. *Left-click* on the dropdown to find and
    select the AI Controller you made earlier–that is, `BP_AIController_Enemy`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AI控制器类`参数决定了，正如其名称所暗示的，为这个敌人使用哪个AI控制器。*左键点击*下拉菜单以找到并选择你之前创建的AI控制器——即`BP_AIController_Enemy`。'
- en: With this exercise complete, the enemy AI now knows which AI Controller to use.
    This is crucial because it is in the AI Controller where the AI will use and execute
    the `Behavior Tree` you will create later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人AI现在知道要使用哪个AI控制器。这一点至关重要，因为AI将在AI控制器中使用和执行你将在本章后面创建的`行为树`。
- en: The AI Controller is now assigned to the enemy, which means you are almost ready
    to start developing the actual intelligence for this AI. However, there is still
    one important topic to discuss before doing so, and that is the **Navigation Mesh**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器现在已被分配给敌人，这意味着你几乎可以开始开发这个AI的实际智能了。然而，在这样做之前，还有一个重要的话题需要讨论，那就是**导航网格**。
- en: Navigation Mesh
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格
- en: One of the most crucial aspects of any AI in video games is the ability to navigate
    the environment in a sophisticated manner. In UE5, there is a way for the engine
    to tell the AI which parts of an environment are navigable and which parts are
    not. This is done through a **Navigation Mesh**, or **Nav Mesh** for short.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任何视频游戏中的AI最重要的方面之一是能够以复杂的方式在环境中导航。在UE5中，引擎有一种方法可以告诉AI环境中哪些部分是可导航的，哪些部分是不可导航的。这是通过**导航网格**，或简称**Nav
    Mesh**来实现的。
- en: The term *mesh* is misleading here because it’s implemented through a volume
    in the editor. We will need a Nav Mesh in our level so that our AI can effectively
    navigate the playable bounds of the game world. We’ll add one together in the
    following exercise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“网格”这个术语是误导性的，因为它是通过编辑器中的体积实现的。我们需要在我们的关卡中有一个导航网格，以便我们的AI能够有效地导航游戏世界的可玩边界。我们将在接下来的练习中一起添加一个。
- en: UE5 also supports a **Dynamic Navigation Mesh**, which allows the Nav Mesh to
    update in real time as dynamic objects move around the environment. This results
    in the AI recognizing these changes in the environment and updating their pathing/navigation
    appropriately. This book will not cover this, but you can access the configuration
    options via **Project Settings** | **Navigation Mesh** | **Runtime Generation**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: UE5还支持**动态导航网格**，这使得导航网格可以在动态对象在环境中移动时实时更新。这导致AI识别环境中的这些变化，并相应地更新它们的路径/导航。本书不会涵盖这一点，但你可以通过**项目设置**
    | **导航网格** | **运行时生成**来访问配置选项。
- en: Now that we have learned about the **Navigation Mesh**, let’s start our first
    exercise where we will add the **Navigation Mesh** to our level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**导航网格**，让我们开始第一个练习，在这个练习中，我们将把**导航网格**添加到我们的关卡中。
- en: Exercise 13.02 – implementing a Nav Mesh Volume for the AI enemy
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02 – 为AI敌人实现导航网格体积
- en: In this exercise, you will add a Navigation Mesh to `SideScrollerExampleMap`
    and explore how Navigation Meshes work in UE5\. You’ll also learn how to parameterize
    this volume for the needs of your game. This exercise will be performed within
    the UE5 editor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将为`SideScrollerExampleMap`添加一个导航网格，并探索在UE5中导航网格是如何工作的。你还将学习如何为此体积参数化以适应你的游戏需求。这个练习将在UE5编辑器中执行。
- en: By the end of this exercise, you will have a stronger understanding of the Nav
    Mesh. You will also be able to implement this volume in your levels in the activity
    that follows this exercise. Let’s begin by adding the Nav Mesh Volume to the level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个练习结束时，你将对导航网格有更深入的了解。你还将能够在接下来的活动中在你的关卡中实现这个体积。让我们首先将导航网格体积添加到关卡中。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: If you do not already have the map open, please open **ThirdPersonExampleMap**
    by navigating to **File** and *left-clicking* on the **Open Level** option. From
    the **Open Level** dialog box, navigate to **/ThirdPersonCPP/Maps** to find **SideScrollerExampleMap**.
    Select this map by *left-clicking* and then *left-click* **Open** at the bottom
    to open the map.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有打开地图，请通过导航到**文件**并*左键点击***打开关卡**选项来打开**ThirdPersonExampleMap**。从**打开关卡**对话框中，导航到**/ThirdPersonCPP/Maps**以找到**SideScrollerExampleMap**。通过*左键点击*选择此地图，然后在底部*左键点击**打开**以打开地图。
- en: With the map opened, navigate to the **Window** menu at the top-left of the
    editor, and make sure you select the **Place Actors** panel option. The **Place
    Actors** panel contains a set of easily accessible actor types such as **Volumes**,
    **Lights**, **Geometry**, and others. Under the **Volumes** category, you will
    find the **Nav Mesh Bounds Volume** option.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开地图后，导航到编辑器左上角的**窗口**菜单，并确保你选择了**放置演员**面板选项。**放置演员**面板包含一系列易于访问的演员类型，如**体积**、**灯光**、**几何体**等。在**体积**类别下，你可以找到**Nav
    Mesh Bounds Volume**选项。
- en: '*Left-click* and drag this volume into the map/scene. By default, you will
    see the outline of the volume in the editor. Press the *P* key to visualize the
    **Navigation** area that the volume encompasses, but make sure that the volume
    is intersecting with the ground geometry to see the green visualization, as shown
    in the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*并将此体积拖入地图/场景。默认情况下，你将在编辑器中看到体积的轮廓。按*P*键以可视化体积所包含的**导航**区域，但请确保体积与地面几何体相交，以便看到如图所示的绿色可视化效果：'
- en: '![Figure 13.2 – Areas outlined in green are perceived as navigable by the engine
    and the AI ](img/Figure_13.02_B18531.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 被绿色勾勒的区域被引擎和AI感知为可导航区域](img/Figure_13.02_B18531.jpg)'
- en: Figure 13.2 – Areas outlined in green are perceived as navigable by the engine
    and the AI
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 被绿色勾勒的区域被引擎和AI感知为可导航区域
- en: With the Nav Mesh Volume in place, let’s adjust its shape so that the volume
    extends to the entire area of the level. After this, you’ll learn how to adjust
    the parameters of the Nav Mesh Volume for the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了Nav Mesh Volume之后，让我们调整其形状，使其体积扩展到关卡的全部区域。之后，你将学习如何调整Nav Mesh Volume的游戏参数。
- en: '*Left-click* to select `X: 3000.0`, `Y: 3000.0`, and `Z: 3000.0`.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*选择`X: 3000.0`，`Y: 3000.0`，和`Z: 3000.0`。'
- en: 'Notice that when the shape and dimensions of **NavMeshBoundsVolume** change,
    **Nav Mesh** will adjust and recalculate the navigable area. This can be seen
    in the following screenshot. You will also notice that the upper platforms are
    not navigable; you will fix this later:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当**NavMeshBoundsVolume**的形状和尺寸发生变化时，**Nav Mesh**会进行调整并重新计算可导航区域。这可以在下面的屏幕截图中看到。你还会注意到，上层的平台是不可导航的；你将在稍后修复这个问题：
- en: '![Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area
    of the example map ](img/Figure_13.03_B18531.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 现在，NavMeshBoundsVolume扩展到示例地图的全部可玩区域](img/Figure_13.03_B18531.jpg)'
- en: Figure 13.3 – Now, NavMeshBoundsVolume extends to the entire playable area of
    the example map
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 现在，NavMeshBoundsVolume扩展到示例地图的全部可玩区域
- en: By completing this exercise, you have placed your first `RecastNavMesh` actor,
    which is also created when placing `NavMeshBoundsVolume` in the level.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经放置了你的第一个`RecastNavMesh`演员，这也是在将`NavMeshBoundsVolume`放置在关卡中时创建的。
- en: Recasting the Nav Mesh
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新构建Nav Mesh
- en: 'When you added **NavMeshBoundsVolume**, you may have noticed that another actor
    was created automatically: a **RecastNavMesh** actor called **RecastNavMesh-Default**.
    This **RecastNavMesh** acts as the “brain” of the Nav Mesh because it contains
    the parameters needed to adjust the Nav Mesh that directly influences how the
    AI navigates the given area.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加**NavMeshBoundsVolume**时，你可能已经注意到自动创建了一个其他演员：一个名为**RecastNavMesh-Default**的**RecastNavMesh**演员。这个**RecastNavMesh**充当Nav
    Mesh的“大脑”，因为它包含了调整Nav Mesh所需的参数，这些参数直接影响了AI如何导航给定的区域。
- en: 'The following screenshot shows this asset, as seen from the **World Outliner**
    tab:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了此资产，如图所示，来自**世界大纲**选项卡：
- en: '![Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab
    ](img/Figure_13.04_B18531.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 从**世界大纲**选项卡看到的RecastNavMesh演员](img/Figure_13.04_B18531.jpg)'
- en: Figure 13.4 – The RecastNavMesh actor, as seen from the World Outliner tab
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 从**世界大纲**选项卡看到的RecastNavMesh演员
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot of parameters that exist in `RecastNavMesh`, and we will only
    be covering the important parameters in this book. For more information, check
    out [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecastNavMesh` 中存在许多参数，本书中我们将仅介绍重要的参数。更多信息，请参阅 [https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/NavigationSystem/NavMesh/ARecastNavMesh/index.xhtml)。'
- en: 'There are only two primary sections that are important to you right now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对你来说，只有两个主要部分是重要的：
- en: '**Display**: The **Display** section, as its name suggests, only contains parameters
    that affect the visual debug display of the generated navigable area of **NavMeshBoundsVolume**.
    It is recommended that you try toggling each of the parameters under this category
    to see how they affect the display of the generated Nav Mesh.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示**：正如其名称所暗示的，**显示**部分仅包含影响生成的可导航区域 **NavMeshBoundsVolume** 的视觉调试显示的参数。建议你尝试切换此类别下的每个参数，看看它们如何影响生成的
    Nav Mesh 的显示。'
- en: '`2.0f` to get the full height.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.0f` 以获得完整高度。'
- en: '`44` degrees, and this is a parameter you will leave alone unless your game
    requires it to change.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`44` 度，这是一个你通常不会更改的参数，除非你的游戏需要更改它。'
- en: '**Agent Max Step Height** refers to the height of steps, in terms of staircase
    steps, that can be navigated by the AI. Much like **Agent Max Slope**, this is
    a parameter that you will more than likely leave alone unless your game specifically
    requires this value to change.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Agent Max Step Height** 指的是 AI 可以导航的台阶高度，从楼梯台阶的角度来看。与 **Agent Max Slope**
    类似，这是一个你很可能不会更改的参数，除非你的游戏特别需要更改此值。'
- en: Now that you have learned about the Recast Nav Mesh parameters, let’s put this
    knowledge into practice in the next exercise, which will walk you through changing
    a few of these parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Recast Nav Mesh 参数，让我们将这些知识应用到下一个练习中，该练习将指导你更改其中的一些参数。
- en: Exercise 13.03 – recasting Nav Mesh Volume parameters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03 – 重构 Nav Mesh 体积参数
- en: Now that you have the **Nav Mesh** Volume in the level, it is time to change
    the parameters of the **Recast Nav Mesh** actor so that the Nav Mesh allows the
    enemy AI to navigate across platforms that are thinner than others. This exercise
    will be performed within the UE5 editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在关卡中有了 **Nav Mesh** 体积，是时候更改 **Recast Nav Mesh** 角色的参数，以便 Nav Mesh 允许敌人
    AI 在比其他平台更薄的平台上导航。这个练习将在 UE5 编辑器中执行。
- en: 'Here, you will simply be updating `Cell Size` and `Agent Height` so that they
    fit the needs of your character and the accuracy needed for the Nav Mesh:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需更新 `Cell Size` 和 `Agent Height`，以便它们符合你的角色需求和 Nav Mesh 所需的精度：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows that the extended platform is now navigable
    because of the changes we made to `Cell Size`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了由于我们对 `Cell Size` 的修改，扩展平台现在可以导航：
- en: '![Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow
    extended platform to be navigable ](img/Figure_13.05_B18531.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 将 `Cell Size` 从 19.0f 更改为 5.0f 允许狭窄的扩展平台可导航](img/Figure_13.05_B18531.jpg)'
- en: Figure 13.5 – Changing Cell Size from 19.0f to 5.0f allows for the narrow extended
    platform to be navigable
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 将 `Cell Size` 从 19.0f 更改为 5.0f 允许狭窄的扩展平台可导航
- en: With `SuperSideScrollerExampleMap` set up with its own `NavMeshBoundsVolume`
    actor that you can use for the remainder of this project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SuperSideScrollerExampleMap` 设置其自己的 `NavMeshBoundsVolume` 角色后，你可以使用它来完成本项目的剩余部分。
- en: Activity 13.01 – creating a new level
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 13.01 – 创建新关卡
- en: Now that you have added `NavMeshBoundsVolume` to the example map, it is time
    to create a map for the rest of the `Super SideScroller` game. By creating a map,
    you will have a better understanding of how `NavMeshBoundsVolume` and the properties
    of `RecastNavMesh` affect the environment they are placed in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 `NavMeshBoundsVolume` 添加到示例地图中，是时候为 `Super SideScroller` 游戏的其余部分创建地图了。通过创建地图，你将更好地理解
    `NavMeshBoundsVolume` 和 `RecastNavMesh` 的属性如何影响它们所在的环境。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before moving on to the solution for this activity, if you need an example level
    that will work for the remaining chapters that cover the `SuperSideScroller` game,
    then don’t worry – this chapter comes with the `SuperSideScroller.umap` asset,
    as well as a map called `SuperSideScroller_NoNavMesh`, which does not contain
    `NavMeshBoundsVolume`. You can use `SuperSideScroller.umap` as a reference for
    how to create a level or to get ideas on how to improve your level. You can download
    the map from [https://packt.live/3lo7v2f](https://packt.live/3lo7v2f).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行此活动的解决方案之前，如果您需要一个适用于剩余章节的示例级别，这些章节涵盖了`SuperSideScroller`游戏，那么请放心——本章附带`SuperSideScroller.umap`资产，以及一个名为`SuperSideScroller_NoNavMesh`的地图，该地图不包含`NavMeshBoundsVolume`。您可以将`SuperSideScroller.umap`作为创建级别或获取改进级别想法的参考。您可以从[https://packt.live/3lo7v2f](https://packt.live/3lo7v2f)下载该地图。
- en: 'Follow these steps to create a simplistic map:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个简单的地图：
- en: Create a **New Level**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**新级别**。
- en: Name this level `SuperSideScroller`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此级别命名为`SuperSideScroller`。
- en: Using the **Static Mesh** assets provided by default in the **Content Drawer**
    interface of this project, create an interesting space with different elevations
    to navigate. Add your player character’s **Blueprint** to the level, and make
    sure it is possessed by **Player Controller 0**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此项目**内容抽屉**界面中默认提供的**静态网格**资产，创建一个具有不同高程的有趣空间以进行导航。将您的玩家角色的**蓝图**添加到级别中，并确保它被**Player
    Controller 0**控制。
- en: Add the `1000.0`, `5000.0`, and `2000.0` in the *X*, *Y*, and *Z* axes, respectively.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*X*、*Y*和*Z*轴上分别添加`1000.0`、`5000.0`和`2000.0`。
- en: Make sure that you enable debug visualization for **NavMeshBoundsVolume** by
    pressing the *P* key.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过按*P*键启用**NavMeshBoundsVolume**的调试可视化。
- en: Adjust the parameters of the `Cell Size` parameter is set to `5.0f`, `Agent
    Radius` is set to `42.0f`, and `Agent Height` is set to `192.0f`. Use these values
    as a reference.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Cell Size`参数的值调整为`5.0f`，`Agent Radius`设置为`42.0f`，`Agent Height`设置为`192.0f`。请以此作为参考。
- en: '**Expected Output**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**'
- en: '![Figure 13.6 – The SuperSideScroller map ](img/Figure_13.06_B18531.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – SuperSideScroller地图](img/Figure_13.06_B18531.jpg)'
- en: Figure 13.6 – The SuperSideScroller map
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – SuperSideScroller地图
- en: By the end of this activity, you will have a level that contains the required
    `NavMeshBoundsVolume` and settings for the `RecastNavMesh` actor. This will allow
    the AI we’ll develop in the upcoming exercises to function correctly. Again, if
    you are unsure of how the level should look, please refer to the provided example
    map, `SuperSideScroller.umap`. Now, it is time to jump into developing the AI
    for the `SuperSideScroller` game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此活动之后，您将拥有一个包含所需`NavMeshBoundsVolume`和`RecastNavMesh`演员设置的级别。这将允许我们在即将进行的练习中开发的AI正确运行。再次提醒，如果您不确定级别应该如何看起来，请参考提供的示例地图`SuperSideScroller.umap`。现在，是时候开始开发`SuperSideScroller`游戏的AI了。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Behavior trees and Blackboards
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树和黑板
- en: Behavior Trees and Blackboards work together to allow our AI to follow different
    logical paths and make decisions based on a variety of conditions and variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树和黑板协同工作，使我们的AI能够遵循不同的逻辑路径，并根据各种条件和变量做出决策。
- en: A **behavior tree** is a visual scripting tool that allows you to tell a pawn
    what to do based on certain factors and parameters. For example, a Behavior Tree
    can tell an AI to move to a certain location based on whether the AI can see the
    player.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**是一种可视化脚本工具，允许您根据某些因素和参数告诉一个NPC做什么。例如，行为树可以告诉AI根据AI是否可以看到玩家移动到某个位置。'
- en: To give an example of how `Behavior Trees` and `Blackboards` are used in games,
    let’s look at the game *Gears of War 5*, which was developed with UE5\. The AI
    in `Blackboard`. The logic that determines how these variables are used and how
    the AI will use this information is performed inside the Behavior Tree.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明`Behavior Trees`和`Blackboards`在游戏中的应用，让我们看看使用UE5开发的游戏*Gears of War 5*，其中AI在`Blackboard`中。确定这些变量如何使用以及AI将如何使用这些信息的逻辑在行为树内部执行。
- en: The `Blackboard` is where you define the set of variables that are required
    to have the Behavior Tree perform actions and use those values for decision-making.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`黑板` 是你定义行为树执行操作和使用这些值进行决策所需的变量集的地方。'
- en: The `Behavior Tree` is where you create the tasks that you want the AI to perform,
    such as moving to a location or performing a custom task that you create. Like
    many of the in-editor tools in UE5, `Behavior Trees` are, for the most part, a
    very visual scripting experience.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`行为树` 是你创建 AI 需要执行的任务的地方，例如移动到某个位置或执行你创建的自定义任务。像 UE5 中许多编辑器工具一样，`行为树` 主要提供了一种非常直观的脚本编写体验。'
- en: '`Blackboards` are where you define the variables, also known as `Blackboard`,
    `Behavior Trees` would have no way of passing and storing information across different
    Tasks, Services, or Decorators, rendering it useless:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`黑板` 是你定义变量的地方，也称为 `黑板`，如果没有 `黑板`，`行为树` 将无法在不同任务、服务或装饰器之间传递和存储信息，使其变得无用：'
- en: '![Figure 13.7 – An example set of variables inside a Blackboard that can be
    accessed in the behavior tree ](img/Figure_13.07_B18531.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 黑板内可以访问的行为树中的变量示例](img/Figure_13.07_B18531.jpg)'
- en: Figure 13.7 – An example set of variables inside a Blackboard that can be accessed
    in the behavior tree
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 黑板内可以访问的行为树中的变量示例
- en: Behavior Trees are composed of a set of **objects** – that is, **Composites**,
    **Tasks**, **Decorators**, and **Services** – that work together to define how
    the AI will behave and respond based on the conditions and logic flow that you
    set. All Behavior Trees begin with what is called the Root where the logic flow
    begins; this cannot be modified and has only one execution branch. Let’s take
    a look at these objects in more detail.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树由一组 **对象** 组成 – 即 **组合**、**任务**、**装饰器**和**服务** – 它们共同定义了 AI 将如何根据你设置的条件和逻辑流程行为和响应。所有行为树都以所谓的根开始，逻辑流程从这里开始；这不能被修改，并且只有一个执行分支。让我们更详细地看看这些对象。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the C++ API for `Behavior Tree` Behavior Tree,
    please refer to the following documentation: [https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `行为树` 的 C++ API 的更多信息，请参阅以下文档：[https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites)。
- en: 'Composite nodes tell the `Behavior Tree` how to go about performing tasks and
    other actions. The following screenshot shows the full list of Composite nodes
    that Unreal Engine gives you by default: **Selector**, **Sequence**, and **Simple
    Parallel**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 组合节点告诉 `行为树` 如何执行任务和其他操作。以下截图显示了 Unreal Engine 默认提供的完整组合节点列表：**选择器**、**序列**和**简单并行**。
- en: 'Composite nodes can also have Decorators and Services attached to them so that
    optional conditions can be applied before a `Behavior Tree` branch is executed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 组合节点也可以附加装饰器和服务，以便在执行 `行为树` 分支之前应用可选条件：
- en: '![Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel ](img/Figure_13.08_B18531.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 组合节点 – 选择器、序列和简单并行](img/Figure_13.08_B18531.jpg)'
- en: Figure 13.8 – Composite nodes – Selector, Sequence, and Simple Parallel
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 组合节点 – 选择器、序列和简单并行
- en: 'Let’s look at these nodes in more detail:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些节点：
- en: '`FinishWithResult` task is successful, the parent `Root` to execute again and
    `FinishWithResult` to execute once more. This pattern will continue until `FinishWithResult`
    fails. The `MakeNoise`. If `MakeNoise` fails, the `Root` will execute again. If
    the `MakeNoise` task succeeds, then the Selector will succeed, and the `Root`
    will execute again. Depending on the flow of the behavior tree, if the Selector
    fails or succeeds, the next Composite branch will begin to execute. In the following
    screenshot, there are no other Composite nodes, so if the Selector fails or succeeds,
    the `Root` node will be executed again. However, if there were a **Sequence**
    Composite node with multiple **Selector** nodes underneath, each Selector would
    attempt to successfully execute its children. Regardless of success or failure,
    each **Selector** will attempt execution sequentially:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FinishWithResult`任务成功，父节点`Root`将再次执行，而`FinishWithResult`将再次执行一次。这种模式将持续到`FinishWithResult`失败。如果`MakeNoise`失败，则`Root`将再次执行。如果`MakeNoise`任务成功，那么选择器将成功，`Root`将再次执行。根据行为树的流程，如果选择器失败或成功，下一个组合分支将开始执行。在下面的屏幕截图中，没有其他组合节点，所以如果选择器失败或成功，`Root`节点将再次执行。然而，如果有包含多个**选择器**节点的**序列**组合节点，每个选择器将尝试成功执行其子节点。无论成功或失败，每个**选择器**都将尝试顺序执行：'
- en: '![Figure 13.9 – An example of how a Selector Composite node can be used in
    a behavior tree ](img/Figure_13.09_B18531.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 选择器组合节点在行为树中使用的示例](img/Figure_13.09_B18531.jpg)'
- en: Figure 13.9 – An example of how a Selector Composite node can be used in a behavior
    tree
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 – 选择器组合节点在行为树中使用的示例](img/Figure_13.09_B18531.jpg)'
- en: Note that when adding tasks and `Composite` nodes, you will notice numeric values
    on the top-right corners of each node. These numbers indicate the order in which
    these nodes will be executed. The pattern follows the *top* to *bottom*, *left*
    to *right* paradigm, and these values help you keep track of the ordering. Any
    disconnected task or `Composite` node will be given a value of `–1` to indicate
    that it is unused.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当添加任务和`组合`节点时，你会在每个节点的右上角注意到数字。这些数字表示这些节点将被执行的顺序。模式遵循**从上到下**，**从左到右**的原则，这些值有助于你跟踪顺序。任何断开的任务或`组合`节点将被赋予`-1`的值，以表示它未被使用。
- en: '`Move To` task is successful, then the parent `Wait` task. If the `Wait` task
    is successful, then the Sequence is successful, and `Root` will execute again.
    If the `Move To` task fails, however, the `Root` will execute again, causing the
    `Wait` task to never execute:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Move To`任务成功，则父节点`Wait`任务。如果`Wait`任务成功，则序列成功，`Root`将再次执行。但是，如果`Move To`任务失败，则`Root`将再次执行，导致`Wait`任务永远不会执行：
- en: '![Figure 13.10 – An example of how a Sequence Composite node can be used in
    a behavior tree ](img/Figure_13.10_B18531.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 序列组合节点在行为树中使用的示例](img/Figure_13.10_B18531.jpg)'
- en: Figure 13.10 – An example of how a Sequence Composite node can be used in a
    behavior tree
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 序列组合节点在行为树中使用的示例
- en: '`5` seconds is being executed at the same time as a new **Sequence** of tasks
    is being executed:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`秒的执行与一个新的**序列**任务同时进行：'
- en: '![Figure 13.11 – An example of how a Selector Composite node can be used in
    a behavior tree ](img/Figure_13.11_B18531.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 选择器组合节点在行为树中使用的示例](img/Figure_13.11_B18531.jpg)'
- en: Figure 13.11 – An example of how a Selector Composite node can be used in a
    behavior tree
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 选择器组合节点在行为树中使用的示例
- en: 'The **Simple Parallel** Composite node is also the only **Composite** node
    that has a parameter in its **Details** panel, which is **Finish Mode**. There
    are two options:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单并行**组合节点也是唯一在其**详细信息**面板中具有参数的**组合**节点，该参数是**完成模式**。有两个选项：'
- en: '`Wait` task finishes, the background tree Sequence will abort and the entire
    **Simple Parallel** will execute again.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait`任务完成后，背景树序列将终止，整个**简单并行**将再次执行。'
- en: '`Wait` task will finish after `5` seconds, but the entire **Simple Parallel**
    will wait for the **Move To** and **PlaySound** tasks to execute before restarting.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait`任务将在`5`秒后完成，但整个**简单并行**将等待**移动到**和**播放声音**任务执行完毕后再重启。'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'For more information regarding the C++ API for Composites, please refer to
    the following documentation: [https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组合C++ API的更多信息，请参阅以下文档：[https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Composites/).
- en: Now that we have a better understanding of Composite nodes, let’s take a look
    at a few examples of Task nodes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对组合节点有了更好的理解，让我们看看一些任务节点的示例。
- en: Tasks
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'These are tasks that our AI can perform. Unreal Engine provides us with built-in
    tasks for us to use by default, but we can also create our own in both Blueprints
    and C++. This includes tasks such as telling our AI to **Move To** a specific
    location, **Rotate To Face Target**, and even telling the AI to fire its weapon.
    It’s also important to know that you can create custom tasks using Blueprints.
    Let’s briefly discuss two of the tasks you will be using to develop the AI for
    the enemy character:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们AI可以执行的任务。虚幻引擎为我们提供了默认使用的内置任务，但我们也可以在蓝图和C++中创建自己的任务。这包括告诉我们的AI**移动到**特定位置、**旋转以面对目标**，甚至告诉AI开火。还重要的是要知道，您可以使用蓝图创建自定义任务。让我们简要讨论一下您将用于开发敌方角色AI的两个任务：
- en: '`Behavior Trees`, and you will be using this task in the upcoming exercises
    in this chapter. **Move To task** uses the navigation system to tell the AI how
    and where to move based on the location it is given. You will use this task to
    tell the AI enemy where to go.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行为树`，您将在本章接下来的练习中使用这个任务。**移动到任务**使用导航系统告诉AI如何以及在哪里移动，基于它给出的位置。您将使用这个任务告诉AI敌人去哪里。'
- en: '`Behavior Trees` because it allows a delay inbetween task execution if the
    logic requires it. This can be used to allow the AI to wait a few seconds before
    moving to a new location.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行为树`因为它允许在任务执行之间有延迟，如果逻辑需要的话。这可以用来允许AI在移动到新位置之前等待几秒钟。'
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the C++ API for tasks, please refer to the following
    documentation: [https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于任务C++ API的更多信息，请参阅以下文档：[https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Tasks/).
- en: Decorators
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are conditions that can be added to tasks or **Composite** nodes,
    such as a **Sequence** or **Selector**, that allow branching logic to occur. As
    an example, we can have a **Decorator** that checks whether or not the enemy knows
    the location of the player. If so, we can tell that enemy to move toward that
    last known location. If not, we can tell our AI to generate a new location and
    move there instead. It is also important to know that you can create custom decorators
    using Blueprints.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是可以添加到任务或**组合**节点（如**序列**或**选择器**）的条件，允许分支逻辑发生。例如，我们可以有一个检查敌人是否知道玩家位置的**装饰器**。如果是这样，我们可以告诉敌人移动到那个最后已知的位置。如果不是，我们可以告诉我们的AI生成一个新的位置并移动到那里。还重要的是要知道，您可以使用蓝图创建自定义装饰器。
- en: Let’s also briefly discuss the decorator you will be using to develop the AI
    for the enemy character – the `Behavior Trees` is not executing until you know
    the AI has reached its given location.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也简要讨论一下您将用于开发敌方角色AI的装饰器——`行为树`只有在您知道AI已经到达指定位置时才会执行。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the C++ API for decorators, please refer to
    the following documentation: [https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于装饰器C++ API的更多信息，请参阅以下文档：[https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Decorators/UBTDecorator_BlueprintBase/).
- en: Now that we have a better understanding of Task nodes, let’s briefly discuss
    Service nodes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对任务节点有了更好的理解，让我们简要讨论一下服务节点。
- en: Services
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Services work a lot like decorators because they can be linked with tasks and
    `Composite` nodes. The main difference is that a **Service** allows us to execute
    a branch of nodes based on the interval defined in the service. It is also important
    to know that you can create custom services using Blueprints.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的工作方式与装饰器非常相似，因为它们可以与任务和`Composite`节点链接。主要区别在于，一个**服务**允许我们根据服务中定义的间隔执行节点分支。还重要的是要知道，您可以使用蓝图创建自定义服务。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the C++ API for services, please refer to the
    following documentation: [https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关服务的C++ API的更多信息，请参阅以下文档：[https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/](https://docs.unrealengine.com/4.27/en-US/API/Runtime/AIModule/BehaviorTree/Services/)。
- en: With knowledge of Composite, Task, and Service nodes under our belt, let’s move
    on to the next exercise where we will create the `Behavior Tree` and `Blackboard`
    for the enemy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了复合、任务和服务节点之后，让我们继续下一个练习，我们将为敌人创建`Behavior Tree`和`Blackboard`。
- en: Exercise 13.04 – creating the AI behavior tree and Blackboard
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04 – 创建AI行为树和Blackboard
- en: Now that you have had an overview of `Behavior Trees` and `Blackboards`, this
    exercise will guide you through creating these assets, telling the AI Controller
    to use the `Behavior Tree` you created, and assigning the `Blackboard` to the
    `Behavior Tree`. The `Blackboard` and `Behavior Tree` assets you will create here
    will be used for the `SuperSideScroller` game. This exercise will be performed
    within the UE5 editor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对`Behavior Trees`和`Blackboards`有了概述，这个练习将指导您创建这些资产，告诉AI控制器使用您创建的`Behavior
    Tree`，并将`Blackboard`分配给`Behavior Tree`。您将在这里创建的`Blackboard`和`Behavior Tree`资产将用于`SuperSideScroller`游戏。此练习将在UE5编辑器中执行。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Within the `/Enemy/AI` directory. This is the same directory where you created
    the AI Controller.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/Enemy/AI`目录中。这是您创建AI控制器相同的目录。
- en: In this directory, *right-click* within the blank area of the `Behavior Tree`
    asset. Name this asset `BT_EnemyAI`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中，在`Behavior Tree`资产的空白区域*右键单击*。将此资产命名为`BT_EnemyAI`。
- en: In the same directory as the previous step, *right-click* again within the blank
    area of the `Blackboard` asset. Name this asset `BB_EnemyAI`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步骤相同的目录中，在`Blackboard`资产空白区域再次*右键单击*。将此资产命名为`BB_EnemyAI`。
- en: Before we move on to telling the AI Controller to run this new `Behavior Tree`,
    let’s assign the `Blackboard` to this `Behavior Tree` so that they are connected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们告诉AI控制器运行这个新的`Behavior Tree`之前，让我们将`Blackboard`分配给这个`Behavior Tree`，以便它们连接起来。
- en: Open `BT_EnemyAI` by *double-clicking* the asset in the `Blackboard Asset` parameter.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*双击*`Blackboard Asset`参数中的资产来打开`BT_EnemyAI`。
- en: '*Left-click* the drop-down menu on this parameter and find the `BB_EnemyAI`
    `Blackboard` asset you created earlier. Compile and save the `Behavior Tree`before
    closing it.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*此参数的下拉菜单，找到您之前创建的`BB_EnemyAI` `Blackboard`资产。在关闭之前编译并保存`Behavior Tree`。'
- en: Next, open the AI Controller’s `BP_AIController_Enemy` asset by *double-clicking*
    it inside the `Run Behavior Tree` function.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过*双击*`Run Behavior Tree`函数中的`BP_AIController_Enemy`资产来打开它。
- en: 'The `Run Behavior Tree` function is very straightforward: you assign a `Behavior
    Tree` successfully began its execution.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run Behavior Tree`函数非常简单：您分配一个`Behavior Tree`，它就成功开始执行。'
- en: 'Lastly, connect the `Run Behavior Tree` function and assign `BT_EnemyAI`, which
    you created earlier in this exercise:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，连接`Run Behavior Tree`函数并分配您在此练习中之前创建的`BT_EnemyAI`：
- en: '![Figure 13.12 – Assigning the BT_EnemyAI behavior tree ](img/Figure_13.12_B18531.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 分配BT_EnemyAI行为树](img/Figure_13.12_B18531.jpg)'
- en: Figure 13.12 – Assigning the BT_EnemyAI behavior tree
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 分配BT_EnemyAI行为树
- en: With this exercise complete, the enemy AI Controller now knows to run the **BT_EnemyAI**
    Behavior Tree, and this Behavior Tree knows to use the Blackboard asset called
    **BB_EnemyAI**. With this in place, you can begin to use the Behavior Tree logic
    to develop the AI so that the enemy character can move around the level.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过完成这个练习，敌人AI控制器现在知道要运行**BT_EnemyAI**行为树，而这个行为树知道要使用名为**BB_EnemyAI**的Blackboard资产。有了这个，您就可以开始使用行为树逻辑来开发AI，使敌人角色可以在关卡中移动。
- en: Exercise 13.05 – creating a new behavior tree task
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.05 – 创建新的行为树任务
- en: The goal of this exercise is to develop an AI task for the enemy AI that will
    allow the character to find a random point to move to within the bounds of the
    **Nav Mesh** Volume in your level.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是开发一个针对敌方 AI 的 AI 任务，使角色能够在您关卡中的 **导航网格** 体积内找到一个随机点进行移动。
- en: Although the `SuperSideScroller` game will only allow two-dimensional movement,
    let’s get the AI to move anywhere within the 3D space of the level that you created
    in *Activity 13.01 – creating a new level*, and then work to constrain the enemy
    to two dimensions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 `SuperSideScroller` 游戏中只允许二维移动，但让我们让 AI 在您在 *活动 13.01 – 创建新关卡* 中创建的水平 3D
    空间内移动到任何地方，然后努力将敌人限制在二维空间内。
- en: 'Follow these steps to create this new task for the enemy:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建针对敌人的新任务：
- en: First, open the `Blackboard` asset you created in the previous exercise, `BB_EnemyAI`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您在上一练习中创建的 `Blackboard` 资产，`BB_EnemyAI`。
- en: '*Left-click* on the `Blackboard` and select the **Vector** option. Name this
    vector **MoveToLocation**. You will use this **vector** variable to track the
    next move for the AI as it decides where to move to.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* `黑板` 并选择 **向量** 选项。将此向量命名为 **MoveToLocation**。您将使用这个 **向量** 变量来跟踪 AI
    的下一步移动，当它决定移动到哪个位置时。'
- en: For this enemy AI, you will need to create a new **Task** because the currently
    available tasks inside Unreal do not fit the needs of the enemy behavior.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个敌方 AI，您需要创建一个新的 **任务**，因为 Unreal 中目前可用的任务不符合敌方行为的需求。
- en: Navigate to and open the `Behavior Tree` asset you created in the previous exercise,
    `BT_EnemyAI`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到并打开您在上一练习中创建的 `Behavior Tree` 资产，`BT_EnemyAI`。
- en: '*Left-click* on the `Task`, it will automatically open the task asset for you.
    However, if you have already created a task, a dropdown list of options will appear
    when selecting the **New Task** option. Before working on the logic of this **Task**,
    you must rename the asset.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* `任务`，它将自动为您打开任务资产。但是，如果您已经创建了一个任务，当选择 **新任务** 选项时，将出现一个选项下拉列表。在开始处理此
    **任务** 的逻辑之前，您必须重命名该资产。'
- en: Close the `BTTask_BlueprintBase_New`. Rename this asset `BTTask_FindLocation`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `BTTask_BlueprintBase_New`。将此资产重命名为 `BTTask_FindLocation`。
- en: With the new **Task** asset named, *double-click* to open **Task Editor**. New
    tasks will have empty Blueprint graphs and will not provide you with any default
    events to use in the graph.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名了新的 **任务** 资产后，*双击* 打开 **任务编辑器**。新任务将具有空的蓝图图，并且不会提供任何默认事件供您在图中使用。
- en: '*Right-click* within the graph and from the context-sensitive search, find
    the **Event Receive Execute AI** option.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中 *右键点击*，从上下文相关搜索中找到 **事件接收执行 AI** 选项。
- en: '*Left-click* the **Event Receive Execute AI** option to create the event node
    in the **Task** graph, as shown in the following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* **事件接收执行 AI** 选项，在 **任务** 图中创建事件节点，如图下所示：'
- en: '![Figure 13.13 – Event Receive Execute AI returns both Owner Controller and
    Controlled Pawn ](img/Figure_13.13_B18531.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 事件接收执行 AI 返回所有者控制器和控制者傀儡](img/Figure_13.13_B18531.jpg)'
- en: Figure 13.13 – Event Receive Execute AI returns both Owner Controller and Controlled
    Pawn
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 事件接收执行 AI 返回所有者控制器和控制者傀儡
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Event Receive Execute AI` event will give you access to both **Owner Controller**
    and **Controlled Pawn**. You will use **Controlled Pawn** for this task in the
    upcoming steps.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event Receive Execute AI` 事件将为您提供访问 **所有者控制器** 和 **控制者傀儡** 的权限。您将在接下来的步骤中使用
    **控制者傀儡** 来完成此任务。'
- en: Each `Finish Execute` function so that the `Behavior Tree` asset knows when
    it can move on to the next `Task` or branches of the tree. *Right-click* in the
    graph and search for `Finish Execute` via the context-sensitive search.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `Finish Execute` 函数都让 `Behavior Tree` 资产知道何时可以移动到下一个 `Task` 或树的分支。在图中 *右键点击*，并通过上下文相关搜索搜索
    `Finish Execute`。
- en: '*Left-click* the **Finish Execute** option from the context-sensitive search
    to create the node inside the Blueprint graph of your **Task**, as shown in the
    following screenshot:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* 上下文相关搜索中的 **Finish Execute** 选项，在您的 **任务** 蓝图图中创建节点，如图下所示：'
- en: '![Figure 13.14 – The Finish Execute function, which has a Boolean parameter
    that determines whether the task is successful ](img/Figure_13.14_B18531.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – `Finish Execute` 函数，它有一个布尔参数，用于确定任务是否成功](img/Figure_13.14_B18531.jpg)'
- en: Figure 13.14 – The Finish Execute function, which has a Boolean parameter that
    determines whether the task is successful
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – `Finish Execute` 函数，它有一个布尔参数，用于确定任务是否成功
- en: The next function that you need is called **GetRandomLocationInNavigableRadius**.
    This function, as its name suggests, returns a random vector location within a
    defined radius of the navigable area. This will allow the enemy character to find
    random locations and move to those locations.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个你需要的功能称为 **GetRandomLocationInNavigableRadius**。正如其名称所暗示的，该函数返回在定义半径内的可导航区域内的随机向量位置。这将允许敌人角色找到随机位置并移动到这些位置。
- en: '*Right-click* in the graph and search for `GetRandomLocationInNavigableRadius`
    inside the context-sensitive search. *Left-click* the **GetRandomLocationInNavigableRadius**
    option to place this function inside the graph.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中 *右键点击* 并在上下文相关搜索中搜索 `GetRandomLocationInNavigableRadius`。*左键点击* **GetRandomLocationInNavigableRadius**
    选项，将此函数放入图中。
- en: With these two functions in place, and with **Event Receive Execute** AI-ready,
    it is time to obtain the random location for the enemy AI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数就位，并且 **Event Receive Execute** AI 准备就绪后，是时候获取敌人 AI 的随机位置了。
- en: 'From the `GetActorLocation` function via the context-sensitive search:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过上下文相关搜索的 `GetActorLocation` 函数：
- en: '![Figure 13.15 – The enemy pawn’s location will serve as the origin of the
    random point selection ](img/Figure_13.15_B18531.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 敌人实体的位置将作为随机点选择的原点](img/Figure_13.15_B18531.jpg)'
- en: Figure 13.15 – The enemy pawn’s location will serve as the origin of the random
    point selection
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 敌人实体的位置将作为随机点选择的原点
- en: 'Connect the vector return value from `GetRandomLocationInNavigableRadius` function,
    as shown in the following screenshot. Now, this function will use the enemy AI
    pawn’s location as the origin for determining the next random point:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GetRandomLocationInNavigableRadius` 函数的向量返回值连接起来，如下截图所示。现在，此函数将使用敌人 AI 实体的位置作为确定下一个随机点的起点：
- en: '![Figure 13.16 – Now, the enemy pawn location will be used as the origin of
    the random point vector search ](img/Figure_13.16_B18531.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – 现在，敌人实体的位置将被用作随机点向量搜索的起点](img/Figure_13.16_B18531.jpg)'
- en: Figure 13.16 – Now, the enemy pawn location will be used as the origin of the
    random point vector search
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 现在，敌人实体的位置将被用作随机点向量搜索的起点
- en: Next, you need to tell the `GetRandomLocationInNavigableRadius` function the
    radius in which to check for the random point in the navigable area of the level.
    Set this value to `1000.0f`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要告诉 `GetRandomLocationInNavigableRadius` 函数要检查随机点的可导航区域半径。将此值设置为 `1000.0f`。
- en: The remaining parameters, `Nav Data` and `Filter Class`, can remain as is. Now
    that you are getting a random location from `GetRandomLocationInNavigableRadius`,
    you will need to be able to store this value in the `Blackboard` vector that you
    created earlier in this exercise.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的参数 `Nav Data` 和 `Filter Class` 可以保持不变。现在，你从 `GetRandomLocationInNavigableRadius`
    获取随机位置，你将需要能够将此值存储在之前在此练习中创建的 `Blackboard` 向量中。
- en: To get a reference to the `Blackboard` vector variable, you need to create a
    new variable inside of this `Task` that’s of the `Blackboard Key Selector` type.
    Create this new variable and name it `NewLocation`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取 `Blackboard` 向量变量的引用，你需要在 `Task` 中创建一个新的 `Blackboard Key Selector` 类型的变量。创建此新变量并将其命名为
    `NewLocation`。
- en: Now, you need to make this variable a `Public` variable so that it can be exposed
    inside the `Behavior Tree`. *Left-click* on the “eye” icon so that the eye is
    visible.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要将此变量设置为 `Public` 变量，以便它可以在 `Behavior Tree` 内部暴露。*左键点击* “眼睛”图标，使眼睛可见。
- en: 'With the `Blackboard Key Selector` variable ready, *left-click* and drag out
    a `Getter` of this variable. Then, pull from this variable and search for `Set
    Blackboard Value as Vector`, as shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好 `Blackboard Key Selector` 变量后，*左键点击* 并拖动出此变量的 `Getter`。然后，从这个变量中拉出并搜索 `Set
    Blackboard Value as Vector`，如下截图所示：
- en: '![Figure 13.17 – Set Blackboard Value has a variety of different types to support
    the different variables that can exist inside the Blackboard ](img/Figure_13.17_B18531.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.17 – 设置 Blackboard 值有多种不同类型，以支持 Blackboard 内可能存在的不同变量](img/Figure_13.17_B18531.jpg)'
- en: Figure 13.17 – Set Blackboard Value has a variety of different types to support
    the different variables that can exist inside the Blackboard
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 – 设置 Blackboard 值有多种不同类型，以支持 Blackboard 内可能存在的不同变量
- en: 'Connect the `RandomLocation` output vector from `GetRandomLocationInNavigableRadius`
    to the `Value` vector input parameter of `Set Blackboard Value as Vector`. Then,
    connect the execution pins of these two function nodes. The result will look as
    follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GetRandomLocationInNavigableRadius`的`RandomLocation`输出向量连接到`Set Blackboard
    Value as Vector`的`Value`向量输入参数。然后，连接这两个函数节点的执行引脚。结果将如下所示：
- en: '![Figure 13.18 – Now, the Blackboard vector value is assigned to this new random
    location ](img/Figure_13.18_B18531.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图13.18 – 现在，黑板的向量值被分配给这个新的随机位置](img/Figure_13.18_B18531.jpg)'
- en: Figure 13.18 – Now, the Blackboard vector value is assigned to this new random
    location
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 现在，黑板的向量值被分配给这个新的随机位置
- en: Lastly, you will use the `Return Value` Boolean output parameter of the `GetRandomLocationInNavigableRadius`
    function to determine whether the task executes successfully.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将使用`GetRandomLocationInNavigableRadius`函数的`Return Value`布尔输出参数来确定任务是否执行成功。
- en: 'Connect the Boolean output parameter to the `Success` input parameter of the
    `Finish Execute` function and connect the execution pins of the **Set Blackboard
    Value as Vector** and **Finish Execute** function nodes. The following screenshot
    shows the final result of the **Task** logic:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布尔输出参数连接到`Finish Execute`函数的`Success`输入参数，并将**Set Blackboard Value as Vector**和**Finish
    Execute**函数节点的执行引脚连接起来。以下屏幕截图显示了**任务**逻辑的最终结果：
- en: '![Figure 13.19 – The final setup for the task ](img/Figure_13.19_B18531.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图13.19 – 任务的最终设置](img/Figure_13.19_B18531.jpg)'
- en: Figure 13.19 – The final setup for the task
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 任务的最终设置
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3lmLyk5](https://packt.live/3lmLyk5).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到前一个屏幕截图的全分辨率版本，以便更好地查看：[https://packt.live/3lmLyk5](https://packt.live/3lmLyk5)。
- en: By completing this exercise, you have created your first custom `Behavior Tree`
    and see the enemy AI move around your level.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您已创建了您的第一个自定义`行为树`并看到敌人AI在您的级别周围移动。
- en: Exercise 13.06 – creating the behavior tree logic
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.06 – 创建行为树逻辑
- en: The goal of this exercise is to implement the new task you created in the previous
    exercise inside the `Behavior Tree` to have the enemy AI find a random location
    within the navigable space of your level and then move to this location. You will
    use a combination of the **Composite**, **Task**, and **Service** nodes to accomplish
    this behavior. This exercise will be performed within the UE5 editor.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是在`行为树`中实现您在上一练习中创建的新任务，以便敌人AI在您级别的可导航空间内找到一个随机位置，然后移动到该位置。您将使用**组合**、**任务**和**服务**节点组合来完成此行为。此练习将在UE5编辑器中执行。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: To start, open the `Behavior Trees` you created in *Exercise 13.04 – creating
    the AI behavior tree and Blackboard*, which is `BT_EnemyAI`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开您在*练习13.04 – 创建AI行为树和黑板*中创建的`行为树`，即`BT_EnemyAI`。
- en: Inside this `Behavior Tree`, *left-click* and drag from the bottom of the `Root`
    node and select the `Root` that’s connected to the **Sequence** Composite node.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此`行为树`内部，*左键点击*并从`Root`节点的底部拖动，选择连接到**序列**组合节点的`Root`。
- en: Next, from the **Sequence** node, *left-click* and drag to bring up the context-sensitive
    menu. In this menu, search for the task you created in the previous exercise –
    that is, **BTTask_FindLocation**.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从**序列**节点，*左键点击*并拖动以显示上下文相关菜单。在此菜单中，搜索您在上一练习中创建的任务——即**BTTask_FindLocation**。
- en: By default, the `Blackboard`. If this doesn’t happen, you can assign this Selector
    manually in the **Details** panel of the task.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`黑板`。如果未发生这种情况，您可以在任务的**详细信息**面板中手动分配此选择器。
- en: Now, `Blackboard`. This means that the random location that’s returned from
    the task will be assigned to the `Blackboard` variable and you can reference this
    variable in other tasks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`黑板`。这意味着从任务返回的随机位置将被分配给`黑板`变量，您可以在其他任务中引用此变量。
- en: Now that you have found a valid random location and assigned this location to
    the `Blackboard` variable – that is, **MovetoLocation** – you can use the **Move
    To** task to tell the AI to move to this location.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经找到了一个有效的随机位置并将此位置分配给`黑板`变量——即**MovetoLocation**，您可以使用**移动到**任务告诉AI移动到该位置。
- en: '*Left-click* and pull from the `Behavior Tree` will now look as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击*并从`行为树`拉出时将如下所示：'
- en: '![Figure 13.20 – After selecting the random location, the Move To task will
    let the AI move to this new location ](img/Figure_13.20_B18531.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图13.20 – 选择随机位置后，移动到任务将允许AI移动到这个新位置](img/Figure_13.20_B18531.jpg)'
- en: Figure 13.20 – After selecting the random location, the Move To task will let
    the AI move to this new location
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 选择随机位置后，移动到任务将允许AI移动到这个新位置
- en: By default, the `50.0f`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`50.0f`。
- en: Now, the `Behavior Tree` finds the random location using the `Blackboard` vector
    variable called **MovetoLocation**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`行为树`使用名为**MovetoLocation**的`黑板`向量变量来找到随机位置。
- en: The last thing to do here is to add a decorator to the **Sequence** Composite
    node so that the enemy character is not at a random location before the tree is
    executed again to find and move it to that new location.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里要做的最后一件事是为**序列**组合节点添加一个装饰器，以确保在树再次执行以找到并移动到新位置之前，敌人角色不在随机位置。
- en: '*Right-click* on the top area of the **Sequence** node and select **Add Decorator**.
    From the dropdown, *left-click* and select **Is at Location**.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击**序列**节点的顶部区域并选择**添加装饰器**。从下拉菜单中，*左键单击*并选择**在位置**。'
- en: Since you already have a vector parameter inside `Blackboard`, the **Is at Location**
    decorator should automatically assign the **MoveToLocation** vector variable as
    **Blackboard Key**. Verify this by selecting the decorator and making sure **Blackboard
    Key** is assigned to **MoveToLocation**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你已经在`黑板`内部有一个向量参数，**在位置**装饰器应该自动将**移动到位置**向量变量分配为**黑板键**。通过选择装饰器并确保**黑板键**分配给**移动到位置**来验证这一点。
- en: 'With the decorator in place, you have completed the `Behavior Tree`. The final
    result will look as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了装饰器后，你就完成了`行为树`。最终结果将如下所示：
- en: '![Figure 13.21 – The final setup for the behavior tree for the AI enemy ](img/Figure_13.21_B18531.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图13.21 – AI敌人的行为树最终设置](img/Figure_13.21_B18531.jpg)'
- en: Figure 13.21 – The final setup for the behavior tree for the AI enemy
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 – AI敌人的行为树最终设置
- en: This `Behavior Tree` is telling the AI to find a random location using `Blackboard`
    `Behavior Tree` will execute the **Move To** task, which will tell the AI to move
    to this new random location. The **Sequence** node is wrapped in a decorator that
    ensures that the enemy AI is at **MoveToLocation** before executing again, just
    as a safety net for the AI.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`行为树`指示AI使用`黑板`行为树来执行**移动到**任务，这将告诉AI移动到这个新的随机位置。**序列**节点被一个装饰器包裹，确保在再次执行之前敌人AI处于**移动到位置**状态，就像为AI设置了一个安全网。
- en: Before you can test the new AI behavior, make sure that you have placed **BP_Enemy
    AI** into your level if one is not already there from previous exercises and activities.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你可以测试新的AI行为之前，请确保你已经将**BP_Enemy AI**放入你的级别，如果之前没有从练习和活动中放入的话。
- en: 'Now, if you use **PIE** or **Simulate**, you will see the enemy AI run around
    the map and move to random locations within the **Nav Mesh Volume**:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用**PIE**或**模拟**，你会看到敌人AI在地图上四处跑动，并移动到**导航网格体积**内的随机位置：
- en: '![Figure 13.22 – The enemy AI will now move from location to location ](img/Figure_13.22_B18531.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图13.22 – 敌人AI现在将从位置移动到位置](img/Figure_13.22_B18531.jpg)'
- en: Figure 13.22 – The enemy AI will now move from location to location
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22 – 敌人AI现在将从位置移动到位置
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There can be some cases where the enemy AI will not move. This can be caused
    by the GetRandomLocationInNavigableRadius function not returning `True`. This
    is a known issue, and if it occurs, please restart the editor and try again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，敌人AI可能不会移动。这可能是由于GetRandomLocationInNavigableRadius函数没有返回`True`造成的。这是一个已知问题，如果发生这种情况，请重新启动编辑器并再次尝试。
- en: By completing this exercise, you have created a fully functional `Behavior Tree`
    that allows the enemy AI to find and move to a random location within the navigable
    bounds of your level usingthe **Nav Mesh Volume**. The task you created in the
    previous exercise allows you to find this random point, while the **Move To**
    task allows the AI character to move toward this new location.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了一个完全功能的`行为树`，它允许敌人AI使用**导航网格体积**在您级别的可导航范围内找到并移动到随机位置。你在上一个练习中创建的任务允许你找到这个随机点，而**移动到**任务允许AI角色移动到这个新位置。
- en: Due to how the `Behavior Tree` start over and choose a new random location.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`行为树`重新开始并选择一个新的随机位置。
- en: Now, you can move on to the next activity, where you will add to this `Behavior
    Tree` to have the AI wait between selecting a new random point so that the enemy
    isn’t constantly moving.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以继续到下一个活动，在这个活动中，你将向此`行为树`添加内容，使AI在选择新的随机点之间等待，这样敌人就不会不断移动。
- en: Activity 13.02 – AI moving to the player’s location
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.02 – AI移动到玩家的位置
- en: In the previous exercise, you made the AI enemy character move to random locations
    within the bounds of **Nav Mesh** Volume by using a custom **Task** and the **Move
    To** task together.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你通过使用自定义**任务**和**移动到**任务一起，使AI敌人角色在**导航网格**体积内移动到随机位置。
- en: In this activity, you will continue from the previous exercise and update the
    `Behavior Tree`. You will take advantage of the **Wait** task by using a decorator,
    and also create a new custom task to have the AI follow the player character and
    update its position every few seconds.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将继续从上一个练习开始，并更新`行为树`。你将通过使用装饰器利用**等待**任务，并创建一个新的自定义任务，使AI跟随玩家角色并每隔几秒更新其位置。
- en: 'Follow these steps to complete this activity:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Inside the **BT_EnemyAI Behavior Tree** that you created in the previous exercise,
    you will continue from where you left off and create a new task. Do this by selecting
    **New Task** from the toolbar and choosing **BTTask_BlueprintBase**. Name this
    new task **BTTask_FindPlayer**.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个练习中创建的**BT_EnemyAI行为树**内部，你将继续进行并创建一个新的任务。通过从工具栏中选择**新任务**并选择**BTTask_BlueprintBase**来完成此操作。将此新任务命名为**BTTask_FindPlayer**。
- en: In the **BTTask_FindPlayer** task, create a new event called **Event Receive
    Execute AI**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**BTTask_FindPlayer**任务中，创建一个新的事件，称为**事件接收执行AI**。
- en: Find the `Get Player Character` function to get a reference to the player; make
    sure that you use **Player Index 0**.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`获取玩家角色`函数以获取对玩家的引用；确保你使用**玩家索引0**。
- en: From the player character, call the `Get Actor Location` function to find the
    player’s current location.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从玩家角色调用`获取演员位置`函数以找到玩家的当前位置。
- en: Create a new `Blackboard` Key `Selector` variable inside this task. Name this
    variable `NewLocation`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此任务内部创建一个新的`黑板`键`选择器`变量。将此变量命名为`NewLocation`。
- en: '*Left-click* and drag the `NewLocation` variable into the graph. From this
    variable, search for the `Set Blackboard Value` function as a `Vector`.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并将`NewLocation`变量拖入图中。从该变量中，搜索`设置黑板值`函数作为`向量`。'
- en: Connect `Vector` function to the execution pin of the event’s **Receive Execute
    AI** node.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`向量`函数连接到事件的**接收执行AI**节点的执行引脚。
- en: Add the `Finish Execute` function, ensuring that the Boolean `True`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`完成执行`函数，确保布尔值为`True`。
- en: Lastly, connect `Vector` function to the `Finish Execute` function.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`向量`函数连接到`完成执行`函数。
- en: Save and compile the task Blueprint and return to the`BT_EnemyAI` `Behavior
    Tree`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译任务蓝图，并返回到`BT_EnemyAI` `行为树`。
- en: Replace the **BTTask_FindLocation** task with the new **BTTask_FindPlayer**
    task so that this new task is now the first task underneath the **Sequence** Composite
    node.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**BTTask_FindLocation**任务替换为新的**BTTask_FindPlayer**任务，以便此新任务现在是**序列**组合节点下的第一个任务。
- en: Add a new `PlaySound` task as the third task underneath the **Sequence** Composite
    node by following the custom **BTTask_FindLocation** and **Move To** tasks.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**序列**组合节点下添加一个新的**播放声音**任务，作为第三个任务，在自定义的**BTTask_FindLocation**和**移动到**任务之后。
- en: In the `Sound to Play` parameter, add the **Explosion_Cue SoundCue** asset.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`要播放的声音`参数中，添加**爆炸_Cue 声音Cue**资产。
- en: Add an **Is At Location** decorator to the **PlaySound** task and ensure that
    the **MovetoLocation** Key is assigned to this **Decorator**.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**是否在位置**装饰器添加到**播放声音**任务中，并确保将**移动到位置**键分配给此**装饰器**。
- en: Add a new **Wait** task as the fourth task underneath the **Sequence** Composite
    node following the **PlaySound** tasks.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**序列**组合节点下添加一个新的**等待**任务，作为第四个任务，在**播放声音**任务之后。
- en: Set the `2.0f` seconds before completing successfully.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功完成之前设置`2.0f`秒。
- en: 'The expected output is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 13.23 – Enemy AI following the player and updating to the player’s
    location every 2 seconds ](img/Figure_13.23_B18531.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图13.23 – 敌人AI跟随玩家并每2秒更新到玩家的位置](img/Figure_13.23_B18531.jpg)'
- en: Figure 13.23 – Enemy AI following the player and updating to the player’s location
    every 2 seconds
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23 – 敌人AI跟随玩家并每2秒更新到玩家的位置
- en: The enemy AI character will move to the player’s last known location in the
    navigable space of the level and pause for `2.0f` seconds between each player
    position.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人AI角色将在关卡的可导航空间中移动到玩家的最后已知位置，并在每个玩家位置之间暂停`2.0f`秒。
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: With this activity complete, you have learned how to create a new task that
    allows the AI to find the player’s location and move to the player’s last known
    position. Before moving on to the next set of exercises, remove the `Behavior`
    `Tree` is returned correctly. You will be using the **BTTask_FindLocation** task
    in the upcoming exercises.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，你已经学会了如何创建一个新任务，允许AI找到玩家的位置并移动到玩家最后已知的位置。在继续下一组练习之前，请删除`Behavior` `Tree`返回正确。你将在接下来的练习中使用**BTTask_FindLocation**任务。
- en: In the next exercise, you will address this issue by developing a new Blueprint
    actor that will allow you to set up specific positions that the AI can move toward.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将通过开发一个新的蓝图演员来解决这个问题，这将允许你设置AI可以移动到的特定位置。
- en: Exercise 13.07 – creating the enemy patrol locations
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.07 – 创建敌人巡逻位置
- en: 'The current issue with the AI enemy character is that they can move freely
    around the 3D navigable space because the `Behavior Tree` allows them to find
    a random location within that space. Instead, the AI needs to be given patrol
    points that you can specify and change in the editor. Then, it will choose one
    of these patrol points at random to move to. This is what you will do for the
    `SuperSideScroller` game: create patrol points that the enemy AI can move to.
    This exercise will show you how to create these patrol points using a simple **Blueprint**
    actor. This exercise will be performed within the UE5 editor.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当前AI敌人角色的问题在于，由于`行为树`允许它们在该3D可导航空间内找到随机位置，它们可以自由移动。相反，AI需要被赋予你可以指定和更改的巡逻点。然后，它将随机选择这些巡逻点中的一个进行移动。这就是你将在`SuperSideScroller`游戏中做的事情：创建敌人AI可以移动到的巡逻点。这个练习将向你展示如何使用简单的**蓝图**演员创建这些巡逻点。这个练习将在UE5编辑器内进行。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: First, navigate to the **/Enemy/Blueprints/** directory. This is where you will
    create the new Blueprint actor that will be used for the AI patrol points.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到**/Enemy/Blueprints/**目录。这是你将创建用于AI巡逻点的新蓝图演员的地方。
- en: In this directory, *right-click* and choose the **Blueprint Class** option by
    *left-clicking* this option from the menu.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个目录中，*右键点击*并选择**蓝图类**选项，通过*左键点击*菜单中的此选项。
- en: 'From the `Actor` class:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Actor`类：
- en: '![Figure 13.24 – The Actor class is the base class for all objects that can
    be placed or spawned in the game world ](img/Figure_13.24_B18531.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24 – **Actor**类是所有可以放置或生成在游戏世界中的对象的基类](img/Figure_13.24_B18531.jpg)'
- en: Figure 13.24 – The Actor class is the base class for all objects that can be
    placed or spawned in the game world
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 – **Actor**类是所有可以放置或生成在游戏世界中的对象的基类
- en: Name this new asset **BP_AIPoints** and open this Blueprint by *double-clicking*
    the asset in the **Content Drawer** interface.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新资产命名为**BP_AIPoints**，并通过在**内容抽屉**界面中双击该资产来打开这个蓝图。
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The interface for Blueprints shares many of the same features and layouts as
    other systems, such as Animation Blueprints and tasks, so this should all look
    familiar to you.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图的界面与其他系统（如动画蓝图和任务）共享许多相同的功能和布局，所以这些应该对你来说都很熟悉。
- en: Navigate to the `Points`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Points`。
- en: From the **Variable Type** dropdown, *left-click* and select the **Vector**
    option.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量类型**下拉菜单中，*左键点击*并选择**向量**选项。
- en: Next, you will need to make this vector variable an **Array** so that you can
    store multiple patrol locations. *Left-click* the yellow icon next to **Vector**
    and *left-click* to select the **Array** option.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要将这个向量变量转换为**数组**，这样你就可以存储多个巡逻位置。*左键点击*旁边黄色的**向量**图标，然后*左键点击*选择**数组**选项。
- en: The last step for setting up the `Show` **3D Widget** option is only available
    for variables that involve an actor transform, such as vectors and transforms.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置“显示”**3D小部件**选项的最后一步仅适用于涉及演员变换的变量，例如向量和变换。
- en: With the simple actor set up, it is time to place the actor in the level and
    begin setting up the patrol point locations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的演员设置完成后，现在是时候将演员放置到关卡中并开始设置巡逻点位置了。
- en: 'Add the **BP_AIPoints** actor Blueprint to your level, as shown in the following
    screenshot:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**BP_AIPoints**演员蓝图添加到你的关卡中，如图下所示：
- en: '![Figure 13.25 – The BP_AIPoints actor is now in the level ](img/Figure_13.25_B18531.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图13.25 – BP_AIPoints演员现在位于关卡中](img/Figure_13.25_B18531.jpg)'
- en: Figure 13.25 – The BP_AIPoints actor is now in the level
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 – BP_AIPoints演员现在位于关卡中
- en: With the **BP_AIPoints** actor selected, navigate to its **Details** panel and
    find the **Points** variable.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**BP_AIPoints**演员后，导航到其**详细信息**面板并找到**点**变量。
- en: 'Next, you can add a new element to the vector array by *left-clicking* on the
    **+** symbol, as shown here:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以通过*左键点击***+**符号来向向量数组添加一个新元素，如图所示：
- en: '![Figure 13.26 – You can have many elements inside an array, but the larger
    the array, the more memory is allocated ](img/Figure_13.26_B18531.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图13.26 – 你可以在数组内部包含许多元素，但数组越大，分配的内存就越多](img/Figure_13.26_B18531.jpg)'
- en: Figure 13.26 – You can have many elements inside an array, but the larger the
    array, the more memory is allocated
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 – 你可以在数组内部包含许多元素，但数组越大，分配的内存就越多
- en: 'When you add a new element to the vector array, you will see a 3D widget appear
    that you can then *left-click* to select and move around the level, as shown here:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你向向量数组添加新元素时，你会看到一个3D小部件出现，你可以通过*左键点击*来选择并移动它，如图所示：
- en: '![Figure 13.27 – The first patrol point vector location ](img/Figure_13.27_B18531.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图13.27 – 首个巡逻点向量位置](img/Figure_13.27_B18531.jpg)'
- en: Figure 13.27 – The first patrol point vector location
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 首个巡逻点向量位置
- en: Note
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you update the position of the 3D widget that represents the element of the
    vector array, the 3D coordinates will update in the **Details** panel for the
    **Points** variable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新代表向量数组元素的3D小部件的位置时，**点**变量的详细信息面板中的3D坐标将更新。
- en: 'Finally, add as many elements into the vector array as you would like for the
    context of your level. Keep in mind that the positions of these patrol points
    should line up so that they make a straight line along the horizontal axis, parallel
    to the direction in which the character will move. The following screenshot shows
    the setup in the example `SideScroller.umap` level that’s included in this exercise:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据你的关卡上下文，将尽可能多的元素添加到向量数组中。请注意，这些巡逻点的位置应该对齐，以便它们在水平轴上形成一条直线，与角色移动的方向平行。以下截图显示了本练习中包含的示例`SideScroller.umap`关卡中的设置：
- en: '![Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap
    example level ](img/Figure_13.28_B18531.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图13.28 – 示例巡逻点路径，如图在SideScroller.umap示例关卡中所示](img/Figure_13.28_B18531.jpg)'
- en: Figure 13.28 – The example patrol point path, as seen in the SideScroller.umap
    example level
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 示例巡逻点路径，如图在SideScroller.umap示例关卡中所示
- en: Continue to repeat the previous step to create multiple patrol points and position
    the 3D widgets as you see fit. You can use the provided **SideScroller.umap**
    example level as a reference on how to set up these patrol points.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续重复之前的步骤以创建多个巡逻点，并按照你的喜好定位3D小部件。你可以使用提供的**SideScroller.umap**示例关卡作为如何设置这些巡逻点的参考。
- en: By completing this exercise, you have created a new `Behavior Tree` so that
    the AI can move between these patrol points. Before you set up this functionality,
    let’s learn a bit more about vectors and Vector Transformation, as this knowledge
    will prove useful in the next exercise.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了一个新的`行为树`，以便AI可以在这些巡逻点之间移动。在你设置这个功能之前，让我们更多地了解向量和向量变换，因为这方面的知识将在下一个练习中非常有用。
- en: Vector Transformation
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量变换
- en: 'Before you jump into the next exercise, it is important that you learn about
    Vector Transformation and, more importantly, what the `Transform Location` function
    does. When it comes to an actor’s location, there are two ways of thinking of
    its position: in terms of world space and local space. An actor’s position in
    world space is its location relative to the world itself; in more simple terms,
    this is the location where you place the actor in the level. An actor’s local
    position is its location relative to either itself or a parent actor.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始下一个练习之前，了解向量变换非常重要，更重要的是了解`Transform Location`函数的功能。当涉及到演员的位置时，有两种思考其位置的方式：世界空间和本地空间。演员在世界空间中的位置是相对于世界本身的；用更简单的话说，这就是你在关卡中放置演员的位置。演员的本地位置是相对于它自己或父演员的位置。
- en: 'Let’s consider the **BP_AIPoints** actor as an example of what world space
    and local space are. Each of the locations of the **Points** array is a local-space
    vector because they are positions relative to the world-space position of the
    **BP_AIPoints** actor itself. The following screenshot shows the list of vectors
    in the **Points** array, as shown in the previous exercise. These values are positions
    relative to the location of the **BP_AIPoints** actor in your level:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以**BP_AIPoints**演员为例，来考虑什么是世界空间和本地空间。**Points**数组的每个位置都是一个本地空间向量，因为它们是相对于**BP_AIPoints**演员本身的世界空间位置的。以下截图显示了与之前练习中所示相同的**Points**数组中的向量列表。这些值是相对于你在关卡中**BP_AIPoints**演员的位置的：
- en: '![Figure 13.29 – The local-space position vectors of the Points array, relative
    to the world-space position of the BP_AIPoints actor ](img/Figure_13.29_B18531.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.29 – Points数组相对于BP_AIPoints演员世界空间位置的本地空间位置向量](img/Figure_13.29_B18531.jpg)'
- en: Figure 13.29 – The local-space position vectors of the Points array, relative
    to the world-space position of the BP_AIPoints actor
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.29 – Points数组相对于BP_AIPoints演员世界空间位置的本地空间位置向量
- en: 'To have the enemy AI move to the correct world space location of these points,
    you need to use a function called `Transform Location`. This function takes in
    two parameters:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让敌人AI移动到这些点的正确世界空间位置，你需要使用一个名为`Transform Location`的函数。这个函数接受两个参数：
- en: '`T`: This is the supplied transform that you will use to convert the vector
    location parameter from a local-space value into a world-space value.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`：这是你将用来将向量位置参数从本地空间值转换为世界空间值的变换。'
- en: '`Location`: This is the location that is to be converted from local space into
    world space.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`：这是要将本地空间转换为世界空间的那个位置。'
- en: The result of this Vector Transformation is then returned as the return value
    of the function. You will use this function in the next exercise to return a randomly
    selected vector point from the `Points` array and convert that value from a local-space
    vector into a world-space vector. This new world-space vector will then be used
    to tell the enemy AI where to move relative to the world. Let’s implement this
    now.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 向量变换的结果随后作为函数的返回值返回。你将在下一个练习中使用这个函数从`Points`数组中返回一个随机选择的向量点，并将该值从本地空间向量转换为世界空间向量。这个新的世界空间向量将被用来告诉敌人AI相对于世界应该移动到哪里。现在让我们来实现这个功能。
- en: Exercise 13.08 – selecting a random point in an array
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.08 – 在数组中选择一个随机点
- en: Now that you know more about vectors and Vector Transformation, in this exercise,
    you will create a simple `Blueprint` function to select one of the *patrol point*
    vector locations and transform its vector from a local space value into a world
    space value using a built-in function called `Behavior Tree` so that the AI will
    move to the correct position. This exercise will be performed within the UE5 editor.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对向量和向量变换有了更多的了解，在这个练习中，你将创建一个简单的`Blueprint`函数来选择一个*巡逻点*向量位置，并使用一个名为`Behavior
    Tree`的内置函数将它的向量从本地空间值转换为世界空间值，以便AI能够移动到正确的位置。这个练习将在UE5编辑器中执行。
- en: 'Follow these steps to complete this exercise. Let’s start by creating the new
    function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习。让我们先创建一个新的函数：
- en: Navigate back to the `GetNextPoint`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`GetNextPoint`。
- en: Before you add logic to this function, select this function by *left-clicking*
    it under the **Functions** category to access its **Details** panel.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你向这个函数添加逻辑之前，通过在**函数**类别下**左键单击**这个函数来选择它，以便访问其**详细信息**面板。
- en: In the **Details** panel, enable the **Pure** parameter so that this function
    is labeled as a **Pure Function**. You learned about **Pure Functions** in [*Chapter
    11*](B18531_11.xhtml#_idTextAnchor222), *Working with Blend Space 1D, Key Bindings,
    and State Machines*, when working in the Animation Blueprint for the player character;
    the same thing is happening here.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **详细信息** 面板中，启用 **纯** 参数，以便此函数被标记为 **纯函数**。你曾在 [*第 11 章*](B18531_11.xhtml#_idTextAnchor222)
    中学习过 **纯函数**，即 *使用 Blend Space 1D、按键绑定和状态机* 时的操作；这里发生的是同样的事情。
- en: 'Next, the `GetNextPoint` function needs to return a vector that the `Behavior
    Tree` can use to tell the enemy AI where to move to. Add this new output by *left-clicking*
    on the `NextPoint`, as shown in the following screenshot:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`GetNextPoint` 函数需要返回一个 `Behavior Tree` 可以用来告诉敌人 AI 去哪里移动的向量。通过如下截图所示的 *左键点击*
    在 `NextPoint` 上添加这个新输出：
- en: '![Figure 13.30 – Functions can return multiple variables of different types,
    depending on the needs of your logic ](img/Figure_13.30_B18531.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.30 – 函数可以根据你的逻辑需求返回不同类型的多个变量](img/Figure_13.30_B18531.jpg)'
- en: Figure 13.30 – Functions can return multiple variables of different types, depending
    on the needs of your logic
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.30 – 函数可以根据你的逻辑需求返回不同类型的多个变量
- en: 'When adding an **Output** variable, the function will automatically generate
    a **Return** node and place it in the function graph, as shown in the following
    screenshot. You will use this output to return the new vector patrol point for
    the enemy AI to move to:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当添加一个 **输出** 变量时，函数将自动生成一个 **返回** 节点并将其放置在函数图中，如下面的截图所示。你将使用此输出来返回敌人 AI 移动到的新向量巡逻点：
- en: '![Figure 13.31 – The automatically generated Return Node for the function,
    including the Next Point vector output variable ](img/Figure_13.31_B18531.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.31 – 函数自动生成的返回节点，包括 Next Point 向量输出变量](img/Figure_13.31_B18531.jpg)'
- en: Figure 13.31 – The automatically generated Return Node for the function, including
    the Next Point vector output variable
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.31 – 函数自动生成的返回节点，包括 Next Point 向量输出变量
- en: Now that the function’s groundwork is completed, let’s start adding the logic.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数的基础工作已经完成，让我们开始添加逻辑。
- en: 'To pick a random position, first, you need to find the length of the `Points`
    array. Create a `Points` vector and from this vector variable, *left-click* and
    drag to search for the `Length` function, as shown in the following screenshot:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择一个随机位置，首先，你需要找到 `Points` 数组的长度。创建一个 `Points` 向量，并从这个向量变量中，*左键点击* 并拖动以搜索 `Length`
    函数，如下面的截图所示：
- en: '![Figure 13.32 – The Length function is a pure function that returns the length
    of the array ](img/Figure_13.32_B18531.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.32 – 长度函数是一个纯函数，它返回数组的长度](img/Figure_13.32_B18531.jpg)'
- en: Figure 13.32 – The Length function is a pure function that returns the length
    of the array
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.32 – 长度函数是一个纯函数，它返回数组的长度
- en: 'With the integer output of the `Length` function, *left-click* and drag out
    to use the context-sensitive search to find the `Random Integer` function, as
    shown in the following screenshot. The `Random Integer` function returns a random
    integer between `0` and `Max value`; in this case, this is the length of the `Points`
    vector array:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Length` 函数的整数输出，*左键点击* 并拖动以使用上下文相关搜索找到 `Random Integer` 函数，如下面的截图所示。`Random
    Integer` 函数返回一个介于 `0` 和 `最大值` 之间的随机整数；在这种情况下，这是 `Points` 向量数组的长度：
- en: '![Figure 13.33 – Using Random Integer will allow the function to return a random
    vector from the Points vector array ](img/Figure_13.33_B18531.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.33 – 使用随机整数将允许函数从 Points 向量数组返回一个随机向量](img/Figure_13.33_B18531.jpg)'
- en: Figure 13.33 – Using Random Integer will allow the function to return a random
    vector from the Points vector array
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.33 – 使用随机整数将允许函数从 Points 向量数组返回一个随机向量
- en: Here, you are generating a random integer between 0 and the length of the `Points`
    vector array. Next, you need to find the element of the `Points` vector array
    at the index position of the returned `Random Integer` function.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在生成一个介于 0 和 `Points` 向量数组长度的随机整数。接下来，你需要找到 `Points` 向量数组中返回的 `Random Integer`
    函数的索引位置。
- en: Do this by creating a new `Getter of the Points` vector array. Then, *left-click*
    and drag to search for the `Get(a copy)`function.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个新的 `Points` 向量数组获取器来完成此操作。然后，*左键点击* 并拖动以搜索 `Get(a copy)` 函数。
- en: Next, connect the return value of the `Random Integer` function to the input
    of the `Get (a copy)` function. This will tell the function to choose a random
    integer and use that integer as the index to return from the `Points` vector array.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Random Integer`函数的返回值连接到`Get (a copy)`函数的输入。这将告诉函数选择一个随机整数，并使用该整数作为索引从`Points`向量数组中返回。
- en: Now that you are getting a random vector from the `Points` vector array, you
    need to use the `Transform Location` function to convert the location from a local
    space vector into a world space vector.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你从`Points`向量数组中获取一个随机向量，你需要使用`Transform Location`函数将位置从局部空间向量转换为世界空间向量。
- en: As you have learned already, the vectors in the `Points` vector array are local
    space positions relative to the position of the `BP_AIPoints` actor in the level.
    As a result, you need to use the `Transform Location` function to convert the
    randomly selected local space vector into a world space vector so that the AI
    enemy moves to the correct position.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，`Points`向量数组中的向量是相对于`BP_AIPoints`演员在关卡中的位置的局部空间位置。因此，你需要使用`Transform Location`函数将随机选择的局部空间向量转换为世界空间向量，以便AI敌人移动到正确的位置。
- en: '*Left-click* and drag from the vector output of the `Get(a copy)`function and,
    via the context-sensitive search, find the `Transform Location` function.'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* 并从`Get(a copy)`函数的向量输出开始拖动，通过上下文相关搜索找到`Transform Location`函数。'
- en: Connect the vector output of the `Get(a copy)`function to the `Location` input
    of the `Transform Location` function.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Get(a copy)`函数的向量输出连接到`Transform Location`函数的`Location`输入。
- en: The final step is to use the transform of the Blueprint actor itself as the
    `T` parameter of the `Transform Location` function. Do this by *right-clicking*
    inside the graph and, via the context-sensitive search, finding the `GetActorTransform`
    function and connecting it to the `Transform Location` parameter, `T`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终步骤是使用蓝图演员本身的变换作为`Transform Location`函数的`T`参数。通过在图中*右键点击*，并通过上下文相关搜索找到`GetActorTransform`函数，并将其连接到`Transform
    Location`参数`T`。
- en: 'Finally, connect the `Return Value` vector from the `Transform Location` function
    and connect it to the `NewPoint` vector output of the function:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Transform Location`函数的`Return Value`向量连接到函数的`NewPoint`向量输出：
- en: '![Figure 13.34 – The final logic has been set up for the GetNextPoint function
    ](img/Figure_13.34_B18531.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图13.34 – GetNextPoint函数的最终逻辑已设置](img/Figure_13.34_B18531.jpg)'
- en: Figure 13.34 – The final logic has been set up for the GetNextPoint function
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.34 – GetNextPoint函数的最终逻辑已设置
- en: Note
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/35jlilb](https://packt.live/35jlilb).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到完整分辨率的先前列表，以便更好地查看：[https://packt.live/35jlilb](https://packt.live/35jlilb)。
- en: By completing this exercise, you have created a new Blueprint function inside
    the `Points` array variable, transforms it into a world space vector value using
    the `Transform Location` function, and returns this new vector value. You will
    use this function inside the `Behavior Tree`, so that the enemy will move to one
    of the points you have set up. Before you can do this, the enemy AI needs a reference
    to the **BP_AIPoints** actor so that it knows which points it can select from
    and move to. We’ll do this in the following exercise.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，你已在`Points`数组变量中创建了一个新的蓝图函数，使用`Transform Location`函数将其转换为世界空间向量值，并返回这个新的向量值。你将在`行为树`中使用此函数，以便敌人移动到你设置的其中一个点。在你能够这样做之前，敌人AI需要一个对**BP_AIPoints**演员的引用，以便它知道可以从哪些点中选择并移动。我们将在以下练习中这样做。
- en: Exercise 13.09 – referencing the patrol point actor
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.09 – 引用巡逻点演员
- en: Now that the `Object Reference` variable to the enemy character Blueprint and
    assign the `Object Reference` variable.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`敌人角色蓝图`的对象引用变量分配给`Object Reference`变量。
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An `Object Reference` variable stores a reference to a specific class object
    or actor. With this variable, you can get access to the publicly exposed variables,
    events, and functions that this class has available.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Object Reference`变量存储对特定类对象或演员的引用。使用此变量，你可以访问该类公开的变量、事件和函数。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Navigate to the `/Enemy/Blueprints/` directory and open the enemy character
    Blueprint, **BP_Enemy**, by *double-clicking* the asset from **the Content Drawer**
    interface.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`/Enemy/Blueprints/`目录，并通过*双击* **内容抽屉**界面中的资产打开敌人角色蓝图**BP_Enemy**。
- en: Create a new variable of the `BP_AIPoints` type and make sure the variable is
    of the `Object Reference` variable type.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`BP_AIPoints`类型的变量，并确保该变量是`对象引用`变量类型。
- en: To reference the existing `Instance Editable` parameter. Name this variable
    `Patrol Points`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了引用现有的`实例可编辑`参数，将此变量命名为`Patrol Points`。
- en: 'Now that you have set the object reference, navigate to your level and select
    your enemy AI. The following screenshot shows the enemy AI placed in the provided
    example level – that is, `SuperSideScroller.umap`. If you don’t have an enemy
    in your level, please place one now:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经设置了对象引用，导航到您的关卡并选择您的敌人AI。以下截图显示了放置在提供的示例关卡中的敌人AI – 即，`SuperSideScroller.umap`。如果您关卡中没有敌人，请现在放置一个：
- en: Note
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Placing an enemy into a level works the same as it does for any other actor
    in UE5: *left-click* and drag the enemy AI Blueprint from the **Content Drawer**
    interface into the level.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将敌人放置到关卡中的操作与UE5中任何其他角色的操作相同：*左键点击* 并将敌人AI蓝图从**内容抽屉**界面拖动到关卡中。
- en: '![Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level ](img/Figure_13.35_B18531.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图13.35 – 放置在SuperSideScroller.umap关卡中的敌人AI](img/Figure_13.35_B18531.jpg)'
- en: Figure 13.35 – The enemy AI placed in the SuperSideScroller.umap level
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35 – 放置在SuperSideScroller.umap关卡中的敌人AI
- en: From its `Patrol Points` variable under the `BP_AIPoints` actor we already placed
    in the level in *Exercise 13.07 – creating the enemy patrol locations*. Do this
    by *left-clicking* the dropdown menu for the `Patrol Points` variable and finding
    the actor from the list.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们已经在关卡中放置的`BP_AIPoints`变量下的`Patrol Points`变量开始。通过*左键点击* `Patrol Points`变量的下拉菜单并从列表中找到角色来完成此操作。
- en: With this exercise complete, the enemy AI in your level now has a reference
    to the **BP_AIPoints** actor in your level. With a valid reference in place, the
    enemy AI can use this actor to determine which set of points to move between inside
    the **BTTask_FindLocation** task. All that is left to do now is update the **BTTask_FindLocation**
    task so that it uses these points instead of finding a random location.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您关卡中的敌人AI现在有一个对关卡中**BP_AIPoints**角色的引用。有了有效的引用，敌人AI可以使用此角色来确定在**BTTask_FindLocation**任务中移动到哪个点集。现在剩下的唯一任务是更新**BTTask_FindLocation**任务，使其使用这些点而不是随机查找位置。
- en: Exercise 13.10 – updating BTTask_FindLocation
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.10 – 更新BTTask_FindLocation
- en: The final step in completing the enemy AI patrolling behavior is to replace
    the logic inside `GetNextPoint` function from the **BP_AIPoints** actor instead
    of finding a random location within the navigable space of your level. This exercise
    will be performed within the UE5 editor.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 完成敌人AI巡逻行为的最后一步是替换`GetNextPoint`函数中的逻辑，从**BP_AIPoints**角色而不是在您关卡的可导航空间内随机查找位置。此练习将在UE5编辑器中执行。
- en: As a reminder, go back to *Exercise 13.05 – creating a new behavior tree task*,
    and see what the **BTTask_FindLocation** task looked like before you start.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，回到*练习13.05 – 创建新的行为树任务*，看看在开始之前**BTTask_FindLocation**任务看起来是什么样子。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'First, you must take the returned `Patrol Points` object reference variable
    from the previous exercise:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须从上一个练习中获取返回的`巡逻点`对象引用变量：
- en: '![Figure 13.36 – Casting also ensures that the returned Controlled Pawn is
    of the BP_Enemy class type ](img/Figure_13.36_B18531.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图13.36 – 强制转换也确保返回的受控角色是BP_Enemy类类型](img/Figure_13.36_B18531.jpg)'
- en: Figure 13.36 – Casting also ensures that the returned Controlled Pawn is of
    the BP_Enemy class type
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36 – 强制转换也确保返回的受控角色是BP_Enemy类类型
- en: Next, you can access the `Patrol Points` object reference variable by *left-clicking*
    and dragging from the `Patrol Points`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以通过*左键点击* 并从`Patrol Points`拖动来访问`Patrol Points`对象引用变量。
- en: From the `Patrol Points` reference, you can *left-click* and drag to search
    for the `GetNextPoint` function that you created in *Exercise 13.08 – selecting
    a random point in an array*.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`巡逻点`引用中，您可以*左键点击* 并拖动以搜索您在*练习13.08 – 在数组中选择随机点*中创建的`GetNextPoint`函数。
- en: Now, you can connect the `NextPoint` vector output parameter of the `GetNextPoint`
    function to the `Set Blackboard Value as Vector` function and connect the execution
    pins from the cast to the `Set Blackboard Value as Vector` function. Now, each
    time the **BTTask_FindLocation** task is executed, a new random patrol point will
    be set.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以将 `GetNextPoint` 函数的 `NextPoint` 向量输出参数连接到 `Set Blackboard Value as Vector`
    函数，并将从抛光到 `Set Blackboard Value as Vector` 函数的执行引脚连接起来。现在，每次执行 **BTTask_FindLocation**
    任务时，都会设置一个新的随机巡逻点。
- en: Lastly, connect the `Set Blackboard Value as Vector` function to the `Finish
    Execute` function and manually set the `Success` parameter to `True` so that this
    task will always succeed if the cast is successful.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `Set Blackboard Value as Vector` 函数连接到 `Finish Execute` 函数，并手动将 `Success`
    参数设置为 `True`，这样如果抛光成功，这个任务将始终成功。
- en: 'As a failsafe, create a duplicate of `Cast` function. Then, set the `Success`
    parameter to `False`. This will act as a failsafe so that if, for any reason,
    `BP_Enemy` class, the task will fail. This is a good debugging practice to ensure
    the functionality of the task for its intended AI class:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一种安全措施，创建 `Cast` 函数的副本。然后，将 `Success` 参数设置为 `False`。这将作为一个安全措施，以防万一，如果 `BP_Enemy`
    类，任务将失败。这是确保任务对其预期 AI 类的功能性的良好调试实践：
- en: '![Figure 13.37 – It is always good practice to account for any casting failures
    in your logic ](img/Figure_13.37_B18531.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.37 – 在你的逻辑中考虑到任何抛光失败始终是一个好的实践](img/Figure_13.37_B18531.jpg)'
- en: Figure 13.37 – It is always good practice to account for any casting failures
    in your logic
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.37 – 在你的逻辑中考虑到任何抛光失败始终是一个好的实践
- en: Note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3n58THA](https://packt.live/3n58THA).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到前面截图的全分辨率版本，以便更好地查看：[https://packt.live/3n58THA](https://packt.live/3n58THA)。
- en: 'With the **BTTask_FindLocation** task updated to use the random patrol point
    from the **BP_AIPoints** actor reference in the enemy, the enemy AI will now move
    between the patrol points at random:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **BTTask_FindLocation** 任务更新为使用敌人中 **BP_AIPoints** 演员引用的随机巡逻点后，敌人 AI 现在将在随机巡逻点之间移动：
- en: '![Figure 13.38 – The enemy AI is now moving between the patrol point locations
    in the level ](img/Figure_13.38_B18531.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.38 – 敌人 AI 现在在关卡中的巡逻点位置之间移动](img/Figure_13.38_B18531.jpg)'
- en: Figure 13.38 – The enemy AI is now moving between the patrol point locations
    in the level
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.38 – 敌人 AI 现在在关卡中的巡逻点位置之间移动
- en: With this exercise complete, the enemy AI now uses the reference to the **BP_AIPoints**
    actor in the level to find and move to the patrol points in the level. Each instance
    of the enemy character in the level can have a reference to another unique instance
    of the **BP_AIPoints** actor or can share the same instance reference. It is up
    to you how you would like each enemy AI to move throughout the level.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，敌人 AI 现在将使用关卡中 **BP_AIPoints** 演员的引用来找到并移动到关卡中的巡逻点。关卡中每个敌人角色的实例都可以有一个指向
    **BP_AIPoints** 演员另一个唯一实例的引用，或者可以共享相同的实例引用。如何让每个敌人 AI 在关卡中移动取决于你。
- en: Player projectile
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家投射物
- en: For the last section of this chapter, you will focus on creating the base of
    the player projectile, which can be used to destroy enemies. The goal is to create
    the appropriate actor class, introduce the required collision and projectile movement
    components to the class, and set up the necessary parameters for the projectile’s
    motion behavior.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的最后部分，你将专注于创建玩家投射物的基座，它可以用来摧毁敌人。目标是创建适当的演员类，向该类引入所需的碰撞和投射物移动组件，并为投射物的运动行为设置必要的参数。
- en: For the sake of simplicity, the player projectile will not use gravity, will
    destroy enemies with one hit, and the projectile itself will be destroyed on hitting
    any surface; it will not bounce off walls, for example. The primary goal of the
    player projectile is to have a projectile that the player can spawn and use to
    destroy enemies throughout the level. In this chapter, you will set up the framework’s
    basic functionality, while in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*, you will add sound and visual effects. Let’s
    get started by creating the `PlayerProjectile` class.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，玩家弹道将不会使用重力，将一击摧毁敌人，并且弹道本身在击中任何表面时将被销毁；例如，它不会从墙上弹回。玩家弹道的主要目标是拥有一个玩家可以生成并用于在整个关卡中摧毁敌人的弹道。在本章中，你将设置框架的基本功能，而在
    [*第 14 章*](B18531_14.xhtml#_idTextAnchor298) *生成玩家弹道* 中，你将添加声音和视觉效果。让我们从创建 `PlayerProjectile`
    类开始吧。
- en: Exercise 13.11 – creating the player projectile
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.11 – 创建玩家弹道
- en: So far, we have been working in the UE5 editor to create our enemy AI. For the
    `player projectile` class, we will be using C++ and Visual Studio. The player
    projectile will allow the player to destroy enemies that are placed in the level.
    This projectile will have a short lifespan, travel at a high speed, and collide
    with both enemies and the environment.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在 UE5 编辑器中创建我们的敌人 AI。对于 `player projectile` 类，我们将使用 C++ 和 Visual Studio。玩家弹道将允许玩家摧毁放置在关卡中的敌人。这个弹道将具有短暂的生命周期，以高速移动，并且可以与敌人和环境发生碰撞。
- en: The goal of this exercise is to set up the base actor class for the player projectile
    and begin outlining the functions and components needed in the header file for
    the projectile.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是为玩家弹道设置基演员类，并在头文件中开始概述所需的函数和组件。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: First, you will need to create a new C++ class by using the `Actor` class as
    the parent class for the player projectile. Next, name this new actor class `PlayerProjectile`
    and *left-click* on the **Create Class** option at the bottom right of the menu
    prompt.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个新的 C++ 类，使用 `Actor` 类作为玩家弹道的父类。接下来，将这个新的演员类命名为 `PlayerProjectile`，并在菜单提示的右下角
    *Create Class* 选项上 *左键点击*。
- en: After creating the new class, Visual Studio will generate the required source
    and header files for the class and open these files for you. The `Actor` base
    class comes included with a handful of default functions that you will not need
    for the player projectile.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类后，Visual Studio 将为该类生成所需的源文件和头文件，并为你打开这些文件。`Actor` 基类包含了一些默认函数，这些函数对于玩家弹道不是必需的。
- en: 'Find the following lines of code inside the `PlayerProjectile.h` file and remove
    them:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerProjectile.h` 文件中找到以下代码行并将其删除：
- en: '[PRE3]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines of code represent the declarations of the `Tick()` and `BeginPlay()`
    functions that are included in every Actor-based class by default. The `Tick()`
    function is called on every frame and allows you to perform logic on every frame,
    which can get expensive, depending on what you are trying to do. The `BeginPlay()`
    function is called when this actor is initialized and play has started. This can
    be used to perform logic on the actor as soon as it enters the world. We are removing
    these functions because they are not required for the player projectile and will
    just clutter the code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行代表了在基于 Actor 的每个类中默认包含的 `Tick()` 和 `BeginPlay()` 函数的声明。`Tick()` 函数在每一帧被调用，允许你在每一帧执行逻辑，这可能会根据你尝试做的事情变得昂贵。`BeginPlay()`
    函数在演员初始化和游戏开始时被调用。这可以用来在演员进入世界后立即执行逻辑。我们正在删除这些函数，因为它们对于玩家弹道不是必需的，并且只会使代码变得杂乱。
- en: 'After removing these lines from the `PlayerProjectile.h` header file, you can
    remove the following lines from the `PlayerProjectile.cpp` source files as well:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `PlayerProjectile.h` 头文件中删除这些行之后，你也可以从 `PlayerProjectile.cpp` 源文件中删除以下行：
- en: '[PRE4]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines of code represent the function implementations of the two functions
    you removed in the previous step – that is, `Tick()` and `BeginPlay()`. Again,
    these are being removed because they serve no purpose for the player projectile
    and just add clutter to the code. Additionally, without the declarations inside
    the `PlayerProjectile.h` header file, you would receive a compilation error if
    you were to try to compile this code asis. The only remaining function will be
    the constructor for the projectile class, which you will use to initialize the
    components of the projectile in the next exercise. Now that you have removed the
    unnecessary code from the `PlayerProjectile` class, let’s add the functions and
    components required for the projectile.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行代表了之前步骤中移除的两个函数的实现——即`Tick()`和`BeginPlay()`。同样，这些函数被移除是因为它们对玩家弹射物没有任何作用，只是增加了代码的杂乱。此外，如果没有在`PlayerProjectile.h`头文件中的声明，如果你尝试直接编译此代码，你会收到编译错误。唯一剩下的函数将是弹射物类的构造函数，你将在下一个练习中使用它来初始化弹射物的组件。现在你已经从`PlayerProjectile`类中移除了不必要的代码，让我们添加弹射物所需的函数和组件。
- en: 'Inside the `PlayerProjectile.h` header file, add the following components:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.h`头文件内部，添加以下组件：
- en: '[PRE5]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You are adding three different components here. The first is the collision component,
    which you will use for the projectile to recognize collisions with enemies and
    environment assets. The next component is the projectile movement component, which
    you should be familiar with from the previous project. This will allow the projectile
    to behave like a projectile. The final component is `StaticMeshComponent`. You
    will use this to give the projectile a visual representation so that it can be
    seen in-game.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里添加了三个不同的组件。第一个是碰撞组件，你将使用它来使弹射物能够识别与敌人和环境资产的碰撞。下一个组件是弹射物运动组件，你应该从上一个项目中熟悉它。这将使弹射物表现得像弹射物。最后一个组件是`StaticMeshComponent`。你将使用它来给弹射物一个视觉表示，以便在游戏中可以看到它。
- en: 'Next, add the following function signature code to the `PlayerProjectile.h`
    header file, under the `public` access modifier:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`PlayerProjectile.h`头文件中，在`public`访问修饰符下添加以下函数签名代码：
- en: '[PRE6]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This final event declaration will allow the player projectile to respond to
    `OnHit` events from the `CollisionComp` component you created in the previous
    step.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的事件声明将使玩家弹射物能够响应你在上一步中创建的`CollisionComp`组件的`OnHit`事件。
- en: 'To have this code compile, you will need to implement the function from the
    previous step in the `PlayerProjectile.cpp` source file. Add the following code:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此代码编译，你需要在`PlayerProjectile.cpp`源文件中实现上一步中的函数。添加以下代码：
- en: '[PRE7]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `OnHit` event provides you with a lot of information about the collision
    that takes place. The most important parameter that you will be working with in
    the next exercise is the `OtherActor` parameter. The `OtherActor` parameter will
    tell you the actor that this `OnHit` event is responding to. This will allow you
    to know if this other actor is an enemy. You will use this information to destroy
    the enemies when the projectile hits them.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnHit`事件为你提供了关于发生的碰撞的大量信息。在下一个练习中，你将与之合作的最重要参数是`OtherActor`参数。`OtherActor`参数将告诉你这个`OnHit`事件正在响应的角色。这将使你知道这个其他角色是否是敌人。当弹射物击中它们时，你将使用这些信息来摧毁敌人。'
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the **Compile**
    option to compile the new code.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回到Unreal Engine编辑器，*左键点击* **编译**选项来编译新的代码。
- en: With this exercise complete, you now have the framework ready for the `PlayerProjectile`
    class. The class contains the required components for `OnHit` collision so that
    the projectile can recognize collisions with other actors.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你现在已经为`PlayerProjectile`类准备好了框架。这个类包含了`OnHit`碰撞所需的组件，以便弹射物能够识别与其他角色的碰撞。
- en: In the next exercise, you will continue to customize and enable parameters for
    `PlayerProjectile` so that it behaves the way you need it to for the `SuperSideScroller`
    project.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将继续定制和启用`PlayerProjectile`的参数，以便它在`SuperSideScroller`项目中表现出你所需要的特性。
- en: Exercise 13.12 – initializing the PlayerProjectile class’s settings
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.12 - 初始化PlayerProjectile类的设置
- en: Now that the framework of the `PlayerProjectile` class is in place, it’s time
    to update the constructor of this class with the default settings needed for the
    projectile so that it moves and behaves as you want it to. To do this, you will
    need to initialize the **Projectile Movement**, **Collision**, and **Static Mesh**
    components.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlayerProjectile`类的框架已经建立，是时候更新这个类的构造函数，以包含弹道所需的默认设置，以便它能够按照你的期望移动和表现。为此，你需要初始化**弹道运动**、**碰撞**和**静态网格**组件。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Open Visual Studio and navigate to the `PlayerProjectile.cpp` source file.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并导航到`PlayerProjectile.cpp`源文件。
- en: 'Before adding any code to the constructor, include the following files inside
    the `PlayerProjectile.cpp` source file:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向构造函数添加任何代码之前，请将以下文件包含在`PlayerProjectile.cpp`源文件内部：
- en: '[PRE8]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These header files will allow you to initialize and update the parameters of
    the projectile movement component, the sphere collision component, and `StaticMeshComponent`,
    respectively. Without these files, the `PlayerProjectile` class wouldn’t know
    how to handle these components and how to access their functions and parameters.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头文件将允许你初始化和更新弹道运动组件、球体碰撞组件和`StaticMeshComponent`的参数。没有这些文件，`PlayerProjectile`类将不知道如何处理这些组件以及如何访问它们的函数和参数。
- en: 'By default, the `APlayerProjectile::APlayerProjectile()` constructor function
    includes the following line:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`APlayerProjectile::APlayerProjectile()`构造函数包括以下行：
- en: '[PRE9]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line of code can be removed entirely because it is not required in the
    player projectile.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码可以完全删除，因为它在玩家弹道中不是必需的。
- en: 'In the `PlayerProjectile.cpp` source file, add the following lines to the `APlayerProjectile::APlayerProjectile()`
    constructor:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerProjectile.cpp`源文件中，向`APlayerProjectile::APlayerProjectile()`构造函数中添加以下行：
- en: '[PRE10]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line initializes the sphere collision component and assigns it to
    the `CollisionComp` variable you created in the previous exercise. The sphere
    collision component has a parameter called `InitSphereRadius`. This will determine
    the size, or radius, of the collision actor by default; in this case, a value
    of `15.0f` works well. Next, `SetCollisionProfileName` sets the collision component
    to `BlockAll` so that the collision profile is set to `BlockAll`. This means this
    collision component will respond to `OnHit` when it collides with other objects.
    Lastly, the last line you added allows the `OnComponentHit` event to respond to
    the function you created in the previous exercise:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行初始化球体碰撞组件并将其分配给你在上一个练习中创建的`CollisionComp`变量。球体碰撞组件有一个名为`InitSphereRadius`的参数。这将默认确定碰撞actor的大小或半径；在这种情况下，`15.0f`的值效果很好。接下来，`SetCollisionProfileName`将碰撞组件设置为`BlockAll`，以便将碰撞配置设置为`BlockAll`。这意味着此碰撞组件在与其他对象碰撞时会响应`OnHit`。最后，你添加的最后一行允许`OnComponentHit`事件响应你在上一个练习中创建的函数：
- en: '[PRE11]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This means that when the collision component receives the `OnComponentHit` event
    from a collision event, it will respond with that function; however, this function
    is empty at the moment. You will add code to this function later in this chapter.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当碰撞组件从碰撞事件接收到`OnComponentHit`事件时，它将以该函数响应；然而，这个函数目前是空的。你将在本章的后面添加代码到这个函数中。
- en: Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about how to create custom collision profiles at [https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/](https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/](https://docs.unrealengine.com/4.26/en-US/InteractiveExperiences/Physics/Collision/HowTo/AddCustomCollisionType/)了解更多关于如何创建自定义碰撞配置的信息。
- en: 'The last thing you must do with `Collision Component` is set this component
    as the `Root Component` of the player projectile actor. Add the following line
    of code to the constructor, after the lines from *Step 4*:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`碰撞组件`的最后一步是将此组件设置为玩家弹道actor的`根组件`。在*步骤4*的行之后，向构造函数中添加以下代码行：
- en: '[PRE12]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the collision component set up and ready, let’s move on to the `Projectile
    Movement` component. Add the following lines to the constructor:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好并准备就绪的碰撞组件之后，让我们继续到`弹道运动`组件。在构造函数中添加以下行：
- en: '[PRE13]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This first line initializes `ProjectileMovementComponent` and assigns it to
    the `ProjectileMovement` variable you created in the previous exercise. Next,
    we set `CollisionComp` as the updated component of the projectile movement component.
    The reason we’re doing this is that `ProjectileMovementComponent` will use the
    `Root` of the actor as the component to move. Then, we set the gravity scale of
    the projectile to `0.0f` because the player projectile should not be affected
    by gravity; this behavior should allow the projectile to travel at the same speed,
    at the same height, and not be influenced by gravity. Lastly, we set both the
    `InitialSpeed` and `MaxSpeed` parameters to `500.0f`. This will allow the projectile
    to instantly start moving at this speed and remain at this speed for the duration
    of its lifetime. The player projectile will not support any kind of acceleration
    motion.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一行初始化 `ProjectileMovementComponent` 并将其分配给在上一练习中创建的 `ProjectileMovement` 变量。接下来，我们将
    `CollisionComp` 设置为投射物运动组件的更新组件。我们这样做的原因是 `ProjectileMovementComponent` 将使用角色的
    `Root` 作为移动的组件。然后，我们将投射物的重力比例设置为 `0.0f`，因为玩家投射物不应受到重力的影响；这种行为应允许投射物以相同的速度、相同的高度移动，并且不受重力的影响。最后，我们将
    `InitialSpeed` 和 `MaxSpeed` 参数都设置为 `500.0f`。这将允许投射物以这个速度立即开始移动，并在其生命周期的整个过程中保持这个速度。玩家投射物将不支持任何类型的加速运动。
- en: 'With the projectile movement component initialized and set up, it is time to
    do the same for `StaticMeshComponent`. Add the following code after the lines
    from the previous step:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化并设置投射物运动组件后，现在是时候对 `StaticMeshComponent` 做同样的事情了。在上一步骤的行之后添加以下代码：
- en: '[PRE14]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This first line initializes `StaticMeshComponent` and assigns it to the `MeshComp`
    variable you created in the previous exercise. Then, it attaches this `StaticMeshComponent`
    to `RootComponent` using a struct called `FAttachmentTransformRules` to ensure
    that `StaticMeshComponent` keeps its world transform during the attachment, which
    is `CollisionComp` from *Step 5* of this exercise.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一行初始化 `StaticMeshComponent` 并将其分配给在上一练习中创建的 `MeshComp` 变量。然后，它使用一个名为 `FAttachmentTransformRules`
    的结构将此 `StaticMeshComponent` 附接到 `RootComponent` 上，以确保在附加过程中 `StaticMeshComponent`
    保持其世界变换，即本练习的 *第 5 步* 中的 `CollisionComp`。
- en: Note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information about the `FAttachmentTransformRules` struct
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml).'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到有关 `FAttachmentTransformRules` 结构的更多信息：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FAttachmentTransformRules/index.xhtml)。
- en: 'Lastly, let’s give `PlayerProjectile` an initial life span of `3` seconds so
    that the projectile will automatically be destroyed if it doesn’t collide with
    anything after this time. Add the following code to the end of the constructor:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们给 `PlayerProjectile` 设置一个初始生命周期为 `3` 秒，这样如果在这个时间后投射物没有与任何东西发生碰撞，它将自动被销毁。将以下代码添加到构造函数的末尾：
- en: '[PRE15]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, navigate back into the Unreal Engine editor and *left-click* the **Compile**
    option to compile the new code.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回 Unreal Engine 编辑器并 *左键单击* **编译** 选项来编译新的代码。
- en: By completing this exercise, you have set up the groundwork for **Player Projectile**
    so that it can be created as a Blueprint actor inside the editor. All three required
    components have been initialized and contain the default parameters that you want
    for this projectile. All we need to do now is create the Blueprint from this class
    to see it in the level.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经为 **Player Projectile** 奠定了基础，使其可以在编辑器内部作为 Blueprint actor 创建。所有三个必需的组件都已初始化，并包含您希望为这个投射物设置的默认参数。我们现在需要做的就是从这个类创建
    Blueprint，以便在关卡中看到它。
- en: Activity 13.03 – creating the player projectile Blueprint
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 13.03 – 创建玩家投射物 Blueprint
- en: To conclude this chapter, you will create the Blueprint actor from the new `PlayerProjectile`
    class and customize this actor so that it uses a placeholder shape for `UE_LOG()`
    function to the `APlayerProjectile::OnHit` function inside the `PlayerProjectile.cpp`
    source file so that you can ensure that this function is called when the projectile
    comes into contact with an object in the level.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，您将从新的 `PlayerProjectile` 类创建 Blueprint actor，并自定义此 actor，使其使用占位符形状为 `UE_LOG()`
    函数到 `PlayerProjectile.cpp` 源文件中的 `APlayerProjectile::OnHit` 函数，以确保当投射物与关卡中的对象接触时，此函数被调用。
- en: 'Follow these steps:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Inside the `Projectile` in the `/MainCharacter` directory.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/MainCharacter` 目录下的 `Projectile` 中。
- en: In this directory, create a new Blueprint from the `PlayerProjectile` class,
    which you created in *Exercise 13.11 – creating the player projectile*. Name this
    Blueprint `BP_PlayerProjectile`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录下，从 `PlayerProjectile` 类创建一个新的蓝图，该类是在 *练习 13.11 – 创建玩家投射物* 中创建的。将此蓝图命名为
    `BP_PlayerProjectile`。
- en: Open `MeshComp` component to access its settings.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MeshComp` 组件以访问其设置。
- en: Add the `Shape_Sphere` mesh to the `Static Mesh` parameter of the `MeshComp`
    component.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Shape_Sphere` 网格添加到 `MeshComp` 组件的 `Static Mesh` 参数。
- en: 'Update the transform of `MeshComp` so that it fits the `Scale and Location
    of the CollisionComp` component. Use the following values:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `MeshComp` 的变换，使其适合 `Scale and Location of the CollisionComp` 组件。使用以下值：
- en: '[PRE16]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and save the **BP_PlayerProjectile** Blueprint.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并保存 **BP_PlayerProjectile** 蓝图。
- en: Navigate to the `PlayerProjectile.cpp` source file in Visual Studio and find
    the `APlayerProjectile::OnHit` function.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Visual Studio 中的 `PlayerProjectile.cpp` 源文件，并找到 `APlayerProjectile::OnHit`
    函数。
- en: Inside the function, implement the `UE_LOG` call so that the logged line is
    of `HIT`. `UE_LOG` , as covered back in [*Chapter 11*](B18531_11.xhtml#_idTextAnchor222),
    *Working with Blend Space 1D, Key Bindings, and State Machines*.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，实现 `UE_LOG` 调用，以便记录的行是 `HIT`。`UE_LOG`，如在前面的 [*第 11 章*](B18531_11.xhtml#_idTextAnchor222)
    中所述，*使用一维混合空间、按键绑定和状态机*。
- en: Compile your code changes and navigate to the level where you placed the **BP_PlayerProjectile**
    actor in the previous exercise. If you haven’t added this actor to the level,
    do so now.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码更改，并导航到上一个练习中放置 **BP_PlayerProjectile** 实例的关卡。如果你还没有将此实例添加到关卡中，请现在添加。
- en: Before testing, make sure that you open **Output Log** under **Window**. From
    the **Window** dropdown, hover over the **Developers Tools** option and *left-click*
    to select **Output Log**.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前，确保在 **窗口** 下打开 **输出日志**。从 **窗口** 下拉菜单中，将鼠标悬停在 **开发者工具** 选项上，然后 *左键单击*
    选择 **输出日志**。
- en: Use `PIE` and watch out for the log warning inside **Output Log** when the projectile
    collides with something.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PIE` 并注意当投射物与物体碰撞时 **输出日志** 中的日志警告。
- en: 'The following is the expected output:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '![Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better
    ](img/Figure_13.39_B18531.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.39 – MeshComp 的比例更适合 CollisionComp 的大小](img/Figure_13.39_B18531.jpg)'
- en: Figure 13.39 – The scale of MeshComp fits the size of CollisionComp better
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.39 – MeshComp 的比例更适合 CollisionComp 的大小
- en: 'The log warning should look as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 日志警告应如下所示：
- en: '![Figure 13.40 – When the projectile hits an object, HIT is shown in the Output
    Log area ](img/Figure_13.40_B18531.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.40 – 当投射物击中物体时，输出日志区域显示 HIT](img/Figure_13.40_B18531.jpg)'
- en: Figure 13.40 – When the projectile hits an object, HIT is shown in the Output
    Log area
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.40 – 当投射物击中物体时，输出日志区域显示 HIT
- en: With this final activity complete, `Throw` action. You will update the `APlayerProjectile::OnHit`
    function so that it destroys the enemy that it collides with and becomes an effective
    offensive tool for the player to use against the enemies.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个最终活动后，更新 `Throw` 动作。你将更新 `APlayerProjectile::OnHit` 函数，使其摧毁与之碰撞的敌人，并成为玩家对抗敌人的有效进攻工具。
- en: Note
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the different aspects of the AI tools
    offered by UE5, including `Blackboards`, `Behavior Trees`, and AI Controllers.
    By using a combination of both custom-created tasks and default tasks provided
    by UE5, as well as a decorator, you were able to have the enemy AI navigate within
    the bounds of the Nav Mesh you added to your level.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 UE5 提供的 AI 工具的不同方面，包括 `Blackboards`、`Behavior Trees` 和 AI 控制器。通过结合自定义创建的任务和
    UE5 提供的默认任务，以及装饰器，你能够使敌人 AI 在你添加到关卡中的导航网格范围内导航。
- en: On top of this, you created a new `Blueprint` actor that allows you to add patrol
    points with the use of a `Vector` array variable. Then, you added a new function
    to this actor that selects one of these points at random, converts its location
    from local space into world space, and then returns this new value for use by
    the enemy character.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，你创建了一个新的`Blueprint`演员，它允许你使用`Vector`数组变量添加巡逻点。然后，你为这个演员添加了一个新功能，该功能随机选择这些点中的一个，将其位置从局部空间转换为世界空间，然后返回这个新值供敌人角色使用。
- en: With the ability to randomly select a patrol point, you updated the custom `BTTask_FindLocation`
    task to find and move to the selected patrol point, allowing the enemy to move
    from each patrol point at random. This brought the enemy AI character to a whole
    new level of interaction in terms of the player and the environment.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够随机选择巡逻点，你更新了自定义的`BTTask_FindLocation`任务，以找到并移动到所选的巡逻点，使敌人能够随机地从每个巡逻点移动。这使敌人AI角色的交互在玩家和环境方面达到了全新的水平。
- en: Lastly, you created the `PlayerProjectile` class, which the player will be able
    to use to destroy enemies within the environment. You took advantage of both `Projectile
    Movement Component` and `Sphere Component` to allow for both projectile movement
    and to recognize and respond to collisions within the environment.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你创建了`PlayerProjectile`类，玩家将能够使用它来摧毁环境中的敌人。你利用了`Projectile Movement Component`和`Sphere
    Component`，以实现弹射物的移动，并能够识别和响应环境中的碰撞。
- en: With the `PlayerProjectile` class in a functional state, it is time to move
    on to the next chapter, where you will use `Anim Notifies` to spawn the projectile
    when the player uses the `Throw` action.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PlayerProjectile`类处于功能状态时，是时候进入下一章了，在那里你将使用`Anim Notifies`在玩家使用`Throw`动作时生成弹射物。
