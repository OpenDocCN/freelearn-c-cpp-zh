<html><head></head><body>
<div id="_idContainer034">
<h1 class="chapter-number" id="_idParaDest-264"><a id="_idTextAnchor689"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-265"><a id="_idTextAnchor690"/><span class="koboSpan" id="kobo.2.1">Policy-Based Design</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Policy-based design is one of the most well-known C++ patterns. </span><span class="koboSpan" id="kobo.3.2">Since the introduction of the standard template library in 1998, few new ideas have been more influential on the way we design C++ programs than the invention of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">policy-based design.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">A policy-based design is all about flexibility, extensibility, and customization. </span><span class="koboSpan" id="kobo.5.2">It is a way to design software that can evolve and can be adapted to the changing needs, some of which could not even be anticipated at the time when the initial design was conceived. </span><span class="koboSpan" id="kobo.5.3">A well-designed policy-based system can remain unchanged at the structural level for many years, and serve the changing needs and new requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">without compromise.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Unfortunately, it is also a way to build software that could do all of those things if only there was someone who could figure out how it works. </span><span class="koboSpan" id="kobo.7.2">The aim of this chapter is to teach you to design and understand the systems of the former kind while avoiding the excesses that lead to the disasters of the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">latter one.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Strategy pattern and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">policy-based design</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Compile time policies </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in C++</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Implementations of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">policy-based classes</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Guidelines for the use </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of policies</span></span><a id="_idTextAnchor691"/></li>
</ul>
<h1 id="_idParaDest-266"><a id="_idTextAnchor692"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The example code for this chapter can be found at the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor693"/><span class="koboSpan" id="kobo.24.1">Strategy pattern and policy-based design</span></h1>
<p><span class="koboSpan" id="kobo.25.1">The</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.26.1"> classic Strategy </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.27.1">pattern is a behavioral design pattern that enables the runtime selection of a specific algorithm for a particular behavior, usually from a predefined family of algorithms. </span><span class="koboSpan" id="kobo.27.2">This pattern is also known as the </span><em class="italic"><span class="koboSpan" id="kobo.28.1">policy pattern</span></em><span class="koboSpan" id="kobo.29.1">; the name predates its application to generic programming in C++. </span><span class="koboSpan" id="kobo.29.2">The aim of the Strategy pattern is to allow for more flexibility in </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the design.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.31.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.32.1">In the classic object-oriented Strategy pattern, the decision about which specific algorithm to use is deferred </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">until runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">As is the case with many classic patterns, the generic programming in C++ applies the same approach to algorithm selection at compile time - it allows for compile-time customization of specific aspects of the system behavior by selecting from a family of related, compatible algorithms. </span><span class="koboSpan" id="kobo.34.2">We will now learn the basics of implementing classes with policies in C++, then proceed to study more complex and varied approaches to </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">policy-based design</span><a id="_idTextAnchor694"/><a id="_idTextAnchor695"/><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor696"/><span class="koboSpan" id="kobo.37.1">Foundations of policy-based design</span></h2>
<p><span class="koboSpan" id="kobo.38.1">The Strategy </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.39.1">pattern should be considered whenever we design a system that does certain operations, but the exact implementation of these operations is uncertain, varied, or can change after the system is implemented - in other words, when we know the answer to </span><em class="italic"><span class="koboSpan" id="kobo.40.1">what the system must do</span></em><span class="koboSpan" id="kobo.41.1">, but not </span><em class="italic"><span class="koboSpan" id="kobo.42.1">how</span></em><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">Similarly, the compile-time strategy (or a policy) is a way to implement a class that has a specific function (</span><em class="italic"><span class="koboSpan" id="kobo.44.1">what</span></em><span class="koboSpan" id="kobo.45.1">), but there is more than one way to implement that </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">function (</span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">how</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Throughout this chapter, we will design a smart pointer class to illustrate different ways to use policies. </span><span class="koboSpan" id="kobo.49.2">A smart pointer has many other required and optional features besides policies, and we will not cover all of them - for a complete implementation of a smart pointer, you will be referred to such examples as the C++ standard smart pointers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.51.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">shared_ptr</span></strong><span class="koboSpan" id="kobo.53.1">), Boost smart pointers, or the Loki smart pointer (</span><a href="http://loki-lib.sourceforge.net/"><span class="koboSpan" id="kobo.54.1">http://loki-lib.sourceforge.net/</span></a><span class="koboSpan" id="kobo.55.1">). </span><span class="koboSpan" id="kobo.55.2">The material presented in this chapter will help you to understand the choices made by the implementers of these libraries, as well as how to design their own </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">policy-based classes.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">A very minimal initial </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.58.1">implementation of a smart pointer may look </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
// Example 01
template &lt;typename T&gt;
  T* p_;
  class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr) : p_(p) {}
  ~SmartPtr() {
    delete p_;
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  SmartPtr(const SmartPtr&amp;) = delete;
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
  SmartPtr(SmartPtr&amp;&amp; that) :
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    delete p_;
    p_ = std::exchange(that.p_, nullptr);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.61.1">This pointer has a constructor from the raw pointer of the same type and the usual (for a pointer) operators, that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">*</span></strong><span class="koboSpan" id="kobo.63.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">-&gt;</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">The most interesting part here is the destructor - when the pointer is destroyed, it automatically deletes the object as well (it is not necessary to check the pointer for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">null</span></strong><span class="koboSpan" id="kobo.67.1"> value before deleting it; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">operator delete</span></strong><span class="koboSpan" id="kobo.69.1"> is required to accept a null pointer and do nothing). </span><span class="koboSpan" id="kobo.69.2">It follows, therefore, that the expected use of this smart pointer is </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
// Example 01
Class C { ... </span><span class="koboSpan" id="kobo.71.2">};
{
  SmartPtr&lt;C&gt; p(new C);
  ... </span><span class="koboSpan" id="kobo.71.3">use p ...
</span><span class="koboSpan" id="kobo.71.4">} // Object *p is deleted automatically</span></pre>
<p><span class="koboSpan" id="kobo.72.1">This is a basic example</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.73.1"> of the RAII class. </span><span class="koboSpan" id="kobo.73.2">The RAII object - the smart pointer, in our case - owns the resource (the constructed object) and releases (deletes) it </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.74.1">when the owning object itself is deleted. </span><span class="koboSpan" id="kobo.74.2">The common applications, which were considered in detail in </span><a href="B19262_05.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.75.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.76.1">, </span><em class="italic"><span class="koboSpan" id="kobo.77.1">A Comprehensive Look at RAII</span></em><span class="koboSpan" id="kobo.78.1">, focus on ensuring that the object that was constructed in the scope is deleted when the program exits this scope, no matter how the latter is accomplished (for example, if an exception is thrown somewhere in the middle of the code, the RAII destructor guarantees that the object </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">is destroyed).</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Two more member functions of the smart pointer are noted, not for their implementation, but for their absence - the pointer is made non-copyable as both its copy constructor and the assignment operator are disabled. </span><span class="koboSpan" id="kobo.80.2">This detail, which is sometimes overlooked, is of crucial importance for any RAII class - since the destructor of the pointer deletes the owned object, there should never be two smart pointers that point to, and will attempt to delete, the same object. </span><span class="koboSpan" id="kobo.80.3">On the other hand, moving the pointer is a valid operation: it transfers the ownership from the old pointer to the new one. </span><span class="koboSpan" id="kobo.80.4">Move constructor is necessary for factory functions to work (at least prior </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">to C++17).</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The pointer we have here is functional, but the implementation is constraining. </span><span class="koboSpan" id="kobo.82.2">In particular, it can own and delete only an object that was constructed with the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">operator new</span></strong><span class="koboSpan" id="kobo.84.1">, and only a single object. </span><span class="koboSpan" id="kobo.84.2">While it could capture a pointer that was obtained from a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">operator new</span></strong><span class="koboSpan" id="kobo.86.1"> or a pointer to an array of elements, it does not properly delete </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">such objects.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">We could implement a different smart pointer for objects that are created on a user-defined heap, and another one for objects that are created in client-managed memory, and so on, one for every type of object construction with its corresponding way of deletion. </span><span class="koboSpan" id="kobo.88.2">Most of the code for these pointers would be duplicated - they are all pointers, and the entire pointer-like API will have to be copied into every class. </span><span class="koboSpan" id="kobo.88.3">We can observe that all of these different classes are, fundamentally, of the same kind - the answer to the question </span><em class="italic"><span class="koboSpan" id="kobo.89.1">what is this type?</span></em><span class="koboSpan" id="kobo.90.1"> is always the same - </span><em class="italic"><span class="koboSpan" id="kobo.91.1">it’s a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">smart pointer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">The only difference is in how the deletion is implemented. </span><span class="koboSpan" id="kobo.94.2">This common intent with a difference in one particular aspect of the behavior suggests the use of the Strategy pattern. </span><span class="koboSpan" id="kobo.94.3">We can implement a more general smart pointer where the details of how to handle the deletion of the </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.95.1">object are delegated to one of any number of </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">deletion policies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
// Example 02
template &lt;typename T, typename DeletionPolicy&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  public:
  explicit SmartPtr(
    T* p = nullptr,
    const DeletionPolicy&amp; del_policy = DeletionPolicy()) :
    p_(p), deletion_policy_(del_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  SmartPtr(const SmartPtr&amp;) = delete;
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
  SmartPtr(SmartPtr&amp;&amp; that) :
    p_(std::exchange(that.p_, nullptr)),
    deletion_policy_(std::move(deletion_policy_))
 {}
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    deletion_policy_(p_);
    p_ = std::exchange(that.p_, nullptr);
    deletion_policy_ = std::move(deletion_policy_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.98.1">The deletion policy is an additional template parameter, and an object of the type of the deletion policy is passed to the constructor of the smart pointer (by default, such an object is default-constructed). </span><span class="koboSpan" id="kobo.98.2">The deletion policy object is stored in the smart pointer and is used in its </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.99.1">destructor to delete the object that’s being pointed to by </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Care must be taken when implementing copy and move constructors for such policy-based classes: it is very easy to forget that the policy also needs to be moved or copied to the new object. </span><span class="koboSpan" id="kobo.101.2">In our case, copying is disabled, but move operations are supported. </span><span class="koboSpan" id="kobo.101.3">They must move not just the pointer itself but also the policy object. </span><span class="koboSpan" id="kobo.101.4">We do this as we would any other class: by moving the object (moving pointers is more involved since they are built-in types, but all classes are assumed to handle their own move operations correctly or delete them). </span><span class="koboSpan" id="kobo.101.5">In the assignment operator, remember that the current object owned by the pointer must be deleted by the corresponding, i.e. </span><span class="koboSpan" id="kobo.101.6">old, policy; only then do we move the policy from the right-hand side of </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the assignment.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">The only requirement on the deletion policy type is that it should be callable - the policy is invoked, just like a function with one argument, and the pointer to the object that must be deleted. </span><span class="koboSpan" id="kobo.103.2">For example, the behavior of our original pointer that called </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">operator delete</span></strong><span class="koboSpan" id="kobo.105.1"> on the object can be replicated with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">deletion policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
// Example 02
template &lt;typename T&gt;
struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.108.1">To use this policy, we must specify its type when constructing the smart pointer, and, optionally, pass an object of this type to the constructor, although in this case, the default constructed object will </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">work fine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
class C { ... </span><span class="koboSpan" id="kobo.110.2">};
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;&gt; p(new C(42));</span></pre>
<p><span class="koboSpan" id="kobo.111.1">In C++17, the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">constructor template argument deduction (CTAD)</span></strong><span class="koboSpan" id="kobo.113.1"> can usually deduce the</span><a id="_idIndexMarker827"/> <span class="No-Break"><span class="koboSpan" id="kobo.114.1">template parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
class C { ... </span><span class="koboSpan" id="kobo.115.2">};
SmartPtr p(new C(42));</span></pre>
<p><span class="koboSpan" id="kobo.116.1">If the deletion policy does not match the object type, a syntax error will be reported for the invalid call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">operator()</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">This is usually undesirable: the error message is not particularly </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.119.1">friendly, and, in general, the requirements on the policy have to be inferred from the use of the policy throughout the template (our policy has only one requirement, but this is our first and simplest policy). </span><span class="koboSpan" id="kobo.119.2">A good practice for writing classes with policies is to verify and document all requirements on the policy explicitly and in one place. </span><span class="koboSpan" id="kobo.119.3">In C++20, this can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">with concepts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
// Example 03
template &lt;typename T, typename F&gt; concept Callable1 =
  requires(F f, T* p) { { f(p) } -&gt; std::same_as&lt;void&gt;; };
template &lt;typename T, typename DeletionPolicy&gt;
requires Callable1&lt;T, DeletionPolicy&gt;
class SmartPtr {
  ...
</span><span class="koboSpan" id="kobo.121.2">};</span></pre>
<p><span class="koboSpan" id="kobo.122.1">Before C++20, we can accomplish the same result with </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">compile-time asserts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
// Example 04
template &lt;typename T, typename DeletionPolicy&gt;
requires Callable1&lt;T, DeletionPolicy&gt;
class SmartPtr {
  ...
</span><span class="koboSpan" id="kobo.124.2">  static_assert(std::is_same&lt;
    void, decltype(deletion_policy_(p_))&gt;::value, "");
};</span></pre>
<p><span class="koboSpan" id="kobo.125.1">Even in C++20, you may prefer the assert error messages. </span><span class="koboSpan" id="kobo.125.2">Both options accomplish the same goal: they verify that the policies meet all requirements and also express these requirements in a readable way and in one place in the code. </span><span class="koboSpan" id="kobo.125.3">It is up to you whether to include “movable” in these requirements: strictly speaking, the policy needs to be movable only if</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.126.1"> you need to move the smart pointer itself. </span><span class="koboSpan" id="kobo.126.2">It is reasonable to allow non-movable policies and require move operations only if they </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">are needed.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Other deletion policies are needed for objects that were allocated in different ways. </span><span class="koboSpan" id="kobo.128.2">For example, if an object is created on a user-given heap object whose interface includes the member functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">allocate()</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">deallocate()</span></strong><span class="koboSpan" id="kobo.132.1"> to, respectively, allocate and free memory, we can use the following heap </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">deletion policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
// Example 02
template &lt;typename T&gt; struct DeleteHeap {
  explicit DeleteHeap(Heap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</span></pre>
<p><span class="koboSpan" id="kobo.135.1">On the other hand, if an object is constructed in some memory that is managed separately by the caller, then only the destructor of the object needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">be called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
// Example 02
template &lt;typename T&gt; struct DeleteDestructorOnly {
  void operator()(T* p) const {
    p-&gt;~T();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.138.1">We mentioned earlier that, because the policy is used as a callable entity, </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">deletion_policy_(p_)</span></strong><span class="koboSpan" id="kobo.140.1">, it can be of any type that can be called like a function. </span><span class="koboSpan" id="kobo.140.2">That includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">actual function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
// Example 02
using delete_int_t = void (*)(int*);
void delete_int(int* p) { delete p; }
SmartPtr&lt;int, delete_int_t&gt; p(new int(42), delete_int);</span></pre>
<p><span class="koboSpan" id="kobo.143.1">A template instantiation is also a function and can be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
template &lt;typename T&gt; void delete_T(T* p) { delete p; }
SmartPtr&lt;int, delete_int_t&gt; p(new int(42), delete_T&lt;int&gt;);</span></pre>
<p><span class="koboSpan" id="kobo.146.1">Of all the possible deletion policies, one is often the most commonly used. </span><span class="koboSpan" id="kobo.146.2">In most programs, it will likely be deletion by the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">operator delete</span></strong><span class="koboSpan" id="kobo.148.1"> function. </span><span class="koboSpan" id="kobo.148.2">If this is so, it makes sense to avoid specifying this one policy every time it’s used and make it </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the default:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
// Example 02
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  ...
</span><span class="koboSpan" id="kobo.150.2">};</span></pre>
<p><span class="koboSpan" id="kobo.151.1">Now, our policy-based smart pointer can be used in exactly the same way as the original version, with only one </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">deletion option:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
SmartPtr&lt;C&gt; p(new C(42));</span></pre>
<p><span class="koboSpan" id="kobo.154.1">Here, the second template parameter is left to its default value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">DeleteByOperator&lt;C&gt;</span></strong><span class="koboSpan" id="kobo.156.1">, and a default constructed object of this type is passed to the constructor as the default </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">second argument.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">At this point, I must caution you against a subtle mistake that could be made when implementing such policy-based classes. </span><span class="koboSpan" id="kobo.158.2">Note that the policy object is captured in the constructor of the smart pointer by a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">const</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1"> reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
explicit SmartPtr(T* p = nullptr,
  const DeletionPolicy&amp; del_policy = DeletionPolicy());</span></pre>
<p><span class="koboSpan" id="kobo.162.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">const</span></strong><span class="koboSpan" id="kobo.164.1"> reference</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.165.1"> here is important since a non-const reference cannot be bound to a temporary object (we will consider the r-value references later in this section). </span><span class="koboSpan" id="kobo.165.2">However, the policy is stored in the object itself by value, and, thus, a copy of the policy object must </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">be made:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  ...
</span><span class="koboSpan" id="kobo.167.2">};</span></pre>
<p><span class="koboSpan" id="kobo.168.1">It may be tempting to avoid the copy and capture the policy by reference in the smart pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
// Example 05
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  const DeletionPolicy&amp; deletion_policy_;
  ...
</span><span class="koboSpan" id="kobo.170.2">};</span></pre>
<p><span class="koboSpan" id="kobo.171.1">In some cases, this will even work, </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
Heap h;
DeleteHeap&lt;C&gt; del_h(h);
SmartPtr&lt;C, DeleteHeap&lt;C&gt;&gt; p(new (&amp;heap) C, del_h);</span></pre>
<p><span class="koboSpan" id="kobo.174.1">However, it won’t work for the default way to create smart pointers or any other smart pointer that is initialized with a temporary </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">policy object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
SmartPtr&lt;C&gt; p(new C, DeleteByOperator&lt;C&gt;());</span></pre>
<p><span class="koboSpan" id="kobo.177.1">This code will </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.178.1">compile. </span><span class="koboSpan" id="kobo.178.2">Unfortunately, it is incorrect - the temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">DeleteByOperator&lt;C&gt;</span></strong><span class="koboSpan" id="kobo.180.1"> object is constructed just before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.182.1"> constructor is called, but is destroyed at the end of the statement. </span><span class="koboSpan" id="kobo.182.2">The reference inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.184.1"> object is left dangling. </span><span class="koboSpan" id="kobo.184.2">At first glance, this should not surprise anyone - of course, the temporary object does not outlive the statement in which it was created - it is deleted at the closing semicolon at the latest. </span><span class="koboSpan" id="kobo.184.3">A reader who is more versed in subtle language details may ask - </span><em class="italic"><span class="koboSpan" id="kobo.185.1">doesn’t the standard specifically extend the lifetime of a temporary bound to a constant reference?</span></em><span class="koboSpan" id="kobo.186.1"> Indeed, it does; </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
{
  const C&amp; c = C();
  ... </span><span class="koboSpan" id="kobo.188.2">c is not dangling! </span><span class="koboSpan" id="kobo.188.3">...
</span><span class="koboSpan" id="kobo.188.4">} // the temporary is deleted here</span></pre>
<p><span class="koboSpan" id="kobo.189.1">In this code fragment, the temporary object </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">C()</span></strong><span class="koboSpan" id="kobo.191.1"> is not deleted at the end of the sentence, but only at the end of the lifetime of the reference to which it is bound. </span><span class="koboSpan" id="kobo.191.2">So, why didn’t the same trick work for our deletion policy object? </span><span class="koboSpan" id="kobo.191.3">The answer is, it sort of did - the temporary object that was created when the argument to the constructor was evaluated and bound to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">const</span></strong><span class="koboSpan" id="kobo.193.1"> reference argument was not destroyed for the lifetime of that reference, which is the duration of the constructor call. </span><span class="koboSpan" id="kobo.193.2">Actually, it would not have been destroyed anyway - all temporary objects that are created during the evaluation of the function arguments are deleted at the end of the sentence containing the function call, that is, at the closing semicolon. </span><span class="koboSpan" id="kobo.193.3">The function, in our case, is the constructor of the object, and so the lifetime of the temporaries spans the entire call to the constructor. </span><span class="koboSpan" id="kobo.193.4">It does not, however, extend to the lifetime of the object - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">const</span></strong><span class="koboSpan" id="kobo.195.1"> reference member of the object is not bound to the temporary object, but to the constructor parameter, which itself is a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">const</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> reference.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">The lifetime extension works only once - the reference bound to a temporary object extends its lifetime. </span><span class="koboSpan" id="kobo.198.2">Another reference that’s bound to the first one does nothing else and may be left dangling if the object is </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.199.1">destroyed (the </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">address sanitizer</span></strong><span class="koboSpan" id="kobo.201.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.202.1">ASAN</span></strong><span class="koboSpan" id="kobo.203.1">) of GCC and CLANG helps to find such bugs). </span><span class="koboSpan" id="kobo.203.2">Therefore, if the policy object needs to be stored as a data member of the smart pointer, it has to </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">be copied.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Usually, policy objects are small, and copying them is trivial. </span><span class="koboSpan" id="kobo.205.2">However, sometimes, a policy object may have a non-trivial internal state that is expensive to copy. </span><span class="koboSpan" id="kobo.205.3">You could also imagine a policy object that is non-copyable. </span><span class="koboSpan" id="kobo.205.4">In these cases, it may make sense to move the argument object into the data member object. </span><span class="koboSpan" id="kobo.205.5">This is easy to do if we declare an overload that is similar to a </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">move constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
// Example 06
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  public:
  explicit SmartPtr(T* p = nullptr,
      DeletionPolicy&amp;&amp; del_policy = DeletionPolicy())
    : p_(p), deletion_policy_(std::move(del_policy))
  {}
  ...
</span><span class="koboSpan" id="kobo.207.2">};</span></pre>
<p><span class="koboSpan" id="kobo.208.1">As we said, the policy objects are usually small, so copying them is rarely an issue. </span><span class="koboSpan" id="kobo.208.2">If you do need both constructors, make sure that only one has default arguments, so the call to a constructor with no arguments or with no policy argument is </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">not ambiguous.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">We now have a smart pointer class that has been implemented once, but whose deletion implementation can be customized at compile time by specifying the deletion policy. </span><span class="koboSpan" id="kobo.210.2">We could even add a new deletion policy that did not exist at the time the class was designed, and it will work </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.211.1">as long as it conforms to the same calling interface. </span><span class="koboSpan" id="kobo.211.2">Next, we will consider different ways to implement </span><a id="_idTextAnchor697"/><span class="No-Break"><span class="koboSpan" id="kobo.212.1">p</span><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.213.1">olicy objects.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.214.1">Implementation of policies</span></h2>
<p><span class="koboSpan" id="kobo.215.1">In the previous </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.216.1">section, we learned how to implement the simplest policy object. </span><span class="koboSpan" id="kobo.216.2">The policy can be of any type as long as it conforms to the interface convention, and is stored in the class as a data member. </span><span class="koboSpan" id="kobo.216.3">The policy object is most commonly generated by a template; however, it could be a regular, non-template, object that’s specific to a particular pointer type, or even a function. </span><span class="koboSpan" id="kobo.216.4">The use of the policy was limited to a specific behavioral aspect, such as the deletion of the object owned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">smart pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">There are several ways in which such policies can be implemented and used. </span><span class="koboSpan" id="kobo.218.2">First of all, let’s review the declaration of a smart pointer with a </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">deletion policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr { ... </span><span class="koboSpan" id="kobo.220.2">};</span></pre>
<p><span class="koboSpan" id="kobo.221.1">Next, let’s look at how we can construct a smart </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">pointer object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
class C { ... </span><span class="koboSpan" id="kobo.223.2">};
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;&gt; p(
  new C(42), DeleteByOperator&lt;C&gt;());</span></pre>
<p><span class="koboSpan" id="kobo.224.1">One disadvantage of this design jumps out at once - the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">C</span></strong><span class="koboSpan" id="kobo.226.1"> is mentioned four times in the definition of the object </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">p</span></strong><span class="koboSpan" id="kobo.228.1"> - it must be consistent in all four places, or the code will not compile. </span><span class="koboSpan" id="kobo.228.2">C++17 allows us to simplify the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">definition somewhat:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
SmartPtr p(new C, DeleteByOperator&lt;C&gt;());</span></pre>
<p><span class="koboSpan" id="kobo.231.1">Here, the constructor is used to deduce the parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">class</span></strong><span class="koboSpan" id="kobo.233.1"> template from the constructor arguments, in a manner similar to that of function templates. </span><span class="koboSpan" id="kobo.233.2">There are still two mentions of the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">C</span></strong><span class="koboSpan" id="kobo.235.1"> that must </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">be consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">One alternative implementation that works for stateless policies as well as for policy objects whose internal state does not depend on the types of the primary template (in our case, the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">T</span></strong><span class="koboSpan" id="kobo.239.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.241.1"> template) is to make the policy itself a non-template object but give it a template member function. </span><span class="koboSpan" id="kobo.241.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">DeleteByOperator</span></strong><span class="koboSpan" id="kobo.243.1"> policy is stateless (the object has no data members) and can be implemented without a</span><a id="_idIndexMarker835"/> <span class="No-Break"><span class="koboSpan" id="kobo.244.1">class template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
// Example 07
struct DeleteByOperator {
  template &lt;typename T&gt; void operator()(T* p) const {
    delete p;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.246.1">This is a non-template object, so it does not need a type parameter. </span><span class="koboSpan" id="kobo.246.2">The member function template is instantiated on the type of object that needs to be deleted - the type is deduced by the compiler. </span><span class="koboSpan" id="kobo.246.3">Since the type of the policy object is always the same, we do not have to worry about specifying consistent types when creating the smart </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">pointer object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
// Example 07
SmartPtr&lt;C, DeleteByOperator&gt; p(
  new C, DeleteByOperator());             // Before C++17
SmartPtr p(new C, DeleteByOperator());     // C++17</span></pre>
<p><span class="koboSpan" id="kobo.249.1">This object can be used by our smart pointer as it is, with no changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.251.1"> template, although we may want to change the default </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">template argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&gt;
class SmartPtr { ... </span><span class="koboSpan" id="kobo.253.2">};</span></pre>
<p><span class="koboSpan" id="kobo.254.1">A more complex policy, such as the heap deletion policy, can still be implemented using </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">this approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
struct DeleteHeap {
  explicit DeleteHeap(SmallHeap&amp; heap) : heap_(heap) {}
  template &lt;typename T&gt; void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</span></pre>
<p><span class="koboSpan" id="kobo.257.1">This policy has an</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.258.1"> internal state - the reference to the heap - but nothing in this policy object depends on the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">T</span></strong><span class="koboSpan" id="kobo.260.1"> of the object we need to delete, except for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">operator()</span></strong><span class="koboSpan" id="kobo.262.1"> member function. </span><span class="koboSpan" id="kobo.262.2">Therefore, the policy does not need to be parameterized by the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">object type.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Since the main template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.266.1">, did not have to be changed when we converted our policies from class templates to non-template classes with template member functions, there is no reason why we cannot use both types of policies with the same class. </span><span class="koboSpan" id="kobo.266.2">Indeed, any of the template class policies from the previous subsection would still work, so we can have some deletion policies implemented as classes and others as class templates. </span><span class="koboSpan" id="kobo.266.3">The latter is useful when the policy has data members whose type depends on the object type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">smart pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">If the policies are implemented as class templates, we have to specify the correct type to instantiate the policy for use with each specific policy-based class. </span><span class="koboSpan" id="kobo.268.2">In many cases, this is a very repetitive process - the same type is used to parameterize the main template and its policies. </span><span class="koboSpan" id="kobo.268.3">We can get the compiler to do this job for us if we use the entire template and not its particular instantiation as </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">a policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
// Example 08
template &lt;typename T,
          template &lt;typename&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr,
    const DeletionPolicy&lt;T&gt;&amp; del_policy =
                             DeletionPolicy&lt;T&gt;())
  : p_(p), deletion_policy_(deletion_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  ...
</span><span class="koboSpan" id="kobo.270.2">};</span></pre>
<p><span class="koboSpan" id="kobo.271.1">Note the syntax for the</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.272.1"> second template parameter - </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">template &lt;typename&gt; class DeletionPolicy</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">This is known as a </span><em class="italic"><span class="koboSpan" id="kobo.275.1">template template</span></em><span class="koboSpan" id="kobo.276.1"> parameter - the parameter of a template is itself a template. </span><span class="koboSpan" id="kobo.276.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">class</span></strong><span class="koboSpan" id="kobo.278.1"> keyword is necessary in C++14 and earlier; in C++17, it can be replaced with </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">typename</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">To use this parameter, we need to instantiate it with some type; in our case, it is the main template type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">T</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">This ensures the consistency of the object type in the primary smart pointer template and its policies, although the constructor argument still must be constructed with the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">correct type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
SmartPtr&lt;C, DeleteByOperator&gt; p(
  new C, DeleteByOperator&lt;C&gt;());</span></pre>
<p><span class="koboSpan" id="kobo.285.1">Again, in C++17, the class template parameters can be deduced by the constructor; this works for template template parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
SmartPtr p(new C, DeleteByOperator&lt;C&gt;());</span></pre>
<p><span class="koboSpan" id="kobo.288.1">The template template parameters seem like an attractive alternative to the regular type parameters when the types are instantiated from a template anyway. </span><span class="koboSpan" id="kobo.288.2">Why don’t we always use them? </span><span class="koboSpan" id="kobo.288.3">First of all, as you can see, they are somewhat less flexible than template class parameters: they save typing in the common case when the policy is a template with the same first argument as the class itself, but they don’t work in any other case (the policy may be a non-template or a template that requires more than one argument). </span><span class="koboSpan" id="kobo.288.4">The other issue is that, as written, the template template parameter has one significant limitation - the number of template parameters has to match the specification precisely, including the default arguments. </span><span class="koboSpan" id="kobo.288.5">In other words, let’s say I have the </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">following template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
template &lt;typename T, typename Heap = MyHeap&gt; class DeleteHeap { ... </span><span class="koboSpan" id="kobo.290.2">};</span></pre>
<p><span class="koboSpan" id="kobo.291.1">This template cannot be used as a parameter of the preceding smart pointer - it has two template parameters, while we only specified only one in the declaration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.293.1"> (a parameter with a default value is still a parameter). </span><span class="koboSpan" id="kobo.293.2">This limitation is easy to work around: all we have</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.294.1"> to do is define the template template parameter as a </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">variadic template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
// Example 09
template &lt;typename T,
          template &lt;typename...&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  ...
</span><span class="koboSpan" id="kobo.296.2">};</span></pre>
<p><span class="koboSpan" id="kobo.297.1">Now the deletion policy template can have any number of type parameters as long as they have default values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">DeletionPolicy&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.299.1"> is what we use in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.301.1"> and it has to compile). </span><span class="koboSpan" id="kobo.301.2">In contrast, we can use an instantiation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">DeleteHeap</span></strong><span class="koboSpan" id="kobo.303.1"> template for a smart pointer where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">DeletionPolicy</span></strong><span class="koboSpan" id="kobo.305.1"> is a type parameter, not a template template parameter - we just need a class, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">DeleteHeap&lt;int, MyHeap&gt;</span></strong><span class="koboSpan" id="kobo.307.1"> will do as good </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">as any.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">So far, we have always captured the policy object as a data member of the policy-based class. </span><span class="koboSpan" id="kobo.309.2">This approach to integrating classes into a larger class is</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.310.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">composition</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">There are other ways in which the primary template can get access to the customized behavior</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.313.1"> algorithms provided by the policies, which w</span><a id="_idTextAnchor700"/><a id="_idTextAnchor701"/><span class="koboSpan" id="kobo.314.1">e will </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">consider next.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor702"/><span class="koboSpan" id="kobo.316.1">Use of policy objects</span></h2>
<p><span class="koboSpan" id="kobo.317.1">All of our </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.318.1">examples until now have stored the policy object as a data member of the class. </span><span class="koboSpan" id="kobo.318.2">This is generally the preferred way of storing the policies, but it has one significant downside - a data member always has a non-zero size. </span><span class="koboSpan" id="kobo.318.3">Consider our smart pointer with one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">deletion policies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  ...
</span><span class="koboSpan" id="kobo.320.2">};</span></pre>
<p><span class="koboSpan" id="kobo.321.1">Note that the policy object has no data members. </span><span class="koboSpan" id="kobo.321.2">However, the size of the object is not zero, but one byte (we can verify that by printing the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">sizeof(DeleteByOperator&lt;int&gt;)</span></strong><span class="koboSpan" id="kobo.323.1">). </span><span class="koboSpan" id="kobo.323.2">This is necessary because every object in a C++ program must have a </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">unique address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
DeleteByOperator&lt;int&gt; d1;     // &amp;d1 = ....
</span><span class="koboSpan" id="kobo.325.2">DeleteByOperator&lt;long&gt; d2; // &amp;d2 must be != &amp;d1</span></pre>
<p><span class="koboSpan" id="kobo.326.1">When two objects are laid out consecutively in memory, the difference between their addresses is the size of the first object (plus padding, if necessary). </span><span class="koboSpan" id="kobo.326.2">To prevent both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">d1</span></strong><span class="koboSpan" id="kobo.328.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">d2</span></strong><span class="koboSpan" id="kobo.330.1"> objects from residing at the same address, the standard mandates that their size is at least </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">one byte.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">When used as a data member of another class, an object will occupy at least as much space as its size requires, which in our case, is one byte. </span><span class="koboSpan" id="kobo.332.2">Assuming that the pointer takes 8 bytes, the entire object is, therefore, 9 bytes long. </span><span class="koboSpan" id="kobo.332.3">But the size of an object also has to be padded to the nearest value that meets the alignment requirements - if the address of the pointer has to be aligned on 8 bytes, the object can be either 8 bytes or 16 bytes, but not in-between. </span><span class="koboSpan" id="kobo.332.4">So, adding an empty policy object to the class ends up changing its size from 8 bytes to 16 bytes. </span><span class="koboSpan" id="kobo.332.5">This is purely a waste of memory and is often undesirable, especially for objects that are created in large numbers, such as pointers. </span><span class="koboSpan" id="kobo.332.6">It is not possible to coax the compiler into creating a data member of zero size; the standard forbids it. </span><span class="koboSpan" id="kobo.332.7">But there is another way in which policies can be used without </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">The alternative to </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.335.1">composition is inheritance - we can use the policy as a base class for the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">primary class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
// Example 10
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
  : DeletionPolicy(std::move(deletion_policy)), p_(p)
  {}
  ~SmartPtr() {
    DeletionPolicy::operator()(p_);
  }
  ...
</span><span class="koboSpan" id="kobo.337.2">};</span></pre>
<p><span class="koboSpan" id="kobo.338.1">This approach relies on a particular optimization - if a base class is empty (has no non-static data members), it can be completely optimized out of the layout of the derived class. </span><span class="koboSpan" id="kobo.338.2">This is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">empty base class optimization</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">It is allowed by the standard, but usually isn’t</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.341.1"> required (C++11 requires this optimization for certain classes, but not for the classes we are using in this chapter). </span><span class="koboSpan" id="kobo.341.2">Even though it is not required, it is almost universally done by modern compilers. </span><span class="koboSpan" id="kobo.341.3">With empty base class optimization, the size of the derived </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.343.1"> class is only as large as necessary to hold its data members - in our case, </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">8 bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">When using inheritance for policies, the choice must be made between public or private inheritance. </span><span class="koboSpan" id="kobo.345.2">Usually, the policies are used to provide an implementation for a particular aspect of behavior. </span><span class="koboSpan" id="kobo.345.3">Such inheritance for implementation is expressed through private inheritance. </span><span class="koboSpan" id="kobo.345.4">In some cases, a policy may be used to change the public interface of the class; in this case, public inheritance should be used. </span><span class="koboSpan" id="kobo.345.5">For the deletion policy, we are not changing the interface of the class - the smart pointer always deletes the object at the end of its life; the only question is how. </span><span class="koboSpan" id="kobo.345.6">Therefore, the</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.346.1"> deletion policy should use </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">private inheritance.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">While the deletion policy using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">operator delete</span></strong><span class="koboSpan" id="kobo.350.1"> is stateless, some policies have data members that must be preserved from the object given to the constructor. </span><span class="koboSpan" id="kobo.350.2">Therefore, in general, the base class policy should be initialized from the constructor argument by copying or moving it into the base class, similarly to the way we initialized the data members. </span><span class="koboSpan" id="kobo.350.3">The base classes are always initialized on the member initialization list before the data members of the derived class. </span><span class="koboSpan" id="kobo.350.4">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">base_type::function_name()</span></strong><span class="koboSpan" id="kobo.352.1"> syntax can be used to call a member function of a base class; in our </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">DeletionPolicy::operator()(p_)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Inheritance or composition are the two choices for integrating the policy class into the primary class. </span><span class="koboSpan" id="kobo.356.2">In general, the composition should be preferred, unless there is a reason to use inheritance. </span><span class="koboSpan" id="kobo.356.3">We have already seen one such reason - the empty base class optimization. </span><span class="koboSpan" id="kobo.356.4">Inheritance is also a necessary choice if we want to affect the public interface of </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">Our smart pointer is, so far, missing several important features that are commonly found in most smart pointer implementations. </span><span class="koboSpan" id="kobo.358.2">One such feature is the ability to release the pointer, that is, to prevent the automatic destruction of the object from taking place. </span><span class="koboSpan" id="kobo.358.3">This can be useful if, in some cases, the object is destroyed by some other means, or, alternatively, if the lifetime of the object needs to be extended and its ownership is passed to another resource-owning object. </span><span class="koboSpan" id="kobo.358.4">We can easily add this feature to our </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">smart pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
template &lt;typename T,
          typename DeletionPolicy&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  ~SmartPtr() {
    if (p) DeletionPolicy::operator()(p_);
  }
  void release() { p_ = nullptr; }
  ...
</span><span class="koboSpan" id="kobo.360.2">};</span></pre>
<p><span class="koboSpan" id="kobo.361.1">Now, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">p.release()</span></strong><span class="koboSpan" id="kobo.363.1"> on our smart pointer, and the destructor will do nothing. </span><span class="koboSpan" id="kobo.363.2">We can hard-code the release feature into the pointer, but sometimes you may want to enforce the deletion as it is done in the pointer, with no release. </span><span class="koboSpan" id="kobo.363.3">This calls for making the release feature optional, controlled by another policy. </span><span class="koboSpan" id="kobo.363.4">We can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">ReleasePolicy</span></strong><span class="koboSpan" id="kobo.365.1"> template parameter to control whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">release()</span></strong><span class="koboSpan" id="kobo.367.1"> member function is present, but what should it do? </span><span class="koboSpan" id="kobo.367.2">We could, of course, move the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">SmartPtr::release()</span></strong><span class="koboSpan" id="kobo.369.1"> into </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
// Example 11
template &lt;typename T&gt; struct WithRelease {
  void release(T*&amp; p) { p = nullptr; }
};</span></pre>
<p><span class="koboSpan" id="kobo.372.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.374.1"> implementation only has to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ReleasePolicy::release(p_)</span></strong><span class="koboSpan" id="kobo.376.1"> to delegate the appropriate handling of </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">release()</span></strong><span class="koboSpan" id="kobo.378.1"> to the policy. </span><span class="koboSpan" id="kobo.378.2">But what is the appropriate handling if we do not want to support the release functionality? </span><span class="koboSpan" id="kobo.378.3">Our no-release policy can simply do nothing, but this is misleading - the user has the expectation that, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">release()</span></strong><span class="koboSpan" id="kobo.380.1"> was called, the object would not be destroyed. </span><span class="koboSpan" id="kobo.380.2">We could assert at runtime and terminate the program. </span><span class="koboSpan" id="kobo.380.3">This converts a logic error on the part of the programmer - trying to release a no-release smart pointer - into a runtime error. </span><span class="koboSpan" id="kobo.380.4">The best way would be for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.382.1"> class to not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">release()</span></strong><span class="koboSpan" id="kobo.384.1"> member function at all if it is not wanted. </span><span class="koboSpan" id="kobo.384.2">This way, the incorrect code would be impossible to compile. </span><span class="koboSpan" id="kobo.384.3">The only way to do this is to make the policy inject a new public member function into the public interface of the primary template. </span><span class="koboSpan" id="kobo.384.4">This can be accomplished using </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">public inheritance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
template &lt;typename T,
          typename DeletionPolicy,
          typename ReleasePolicy&gt;
class SmartPtr : private DeletionPolicy,
                 public ReleasePolicy {
  ...
</span><span class="koboSpan" id="kobo.386.2">};</span></pre>
<p><span class="koboSpan" id="kobo.387.1">Now, if the release</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.388.1"> policy has a public member function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">release()</span></strong><span class="koboSpan" id="kobo.390.1">, then so does the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">SmartPtr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">This solves the interface problem. </span><span class="koboSpan" id="kobo.393.2">Now, there is a small matter of implementation. </span><span class="koboSpan" id="kobo.393.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">release()</span></strong><span class="koboSpan" id="kobo.395.1"> member function has now moved into the policy class, but it must operate on the data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">p_</span></strong><span class="koboSpan" id="kobo.397.1"> of the parent class. </span><span class="koboSpan" id="kobo.397.2">One way to do this would be to pass a reference to this pointer from the derived class to the base policy class during construction. </span><span class="koboSpan" id="kobo.397.3">This is an ugly implementation - it wastes 8 bytes of memory to store a reference to a data member that is almost “right there,” which is stored in the derived class right next to the base class itself. </span><span class="koboSpan" id="kobo.397.4">A much better way is to cast from the base class to the correct derived class. </span><span class="koboSpan" id="kobo.397.5">Of course, for this to work, the base class needs to know what the correct derived class is. </span><span class="koboSpan" id="kobo.397.6">The solution to this problem is the </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.399.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.400.1">CRTP</span></strong><span class="koboSpan" id="kobo.401.1">) that </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.402.1">we studied in this book: the policy should be a template (so we will need a template template parameter) that is instantiated on the derived </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">class type.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">This way, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.406.1"> class is both the derived class of the release policy and the template parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">of it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
// Example 11
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          template &lt;typename...&gt; class ReleasePolicy =
                                       WithRelease&gt;
class SmartPtr : private DeletionPolicy,
                 public ReleasePolicy&lt;SmartPtr&lt;T,
                          DeletionPolicy, ReleasePolicy&gt;&gt;
{ ... </span><span class="koboSpan" id="kobo.408.2">};</span></pre>
<p><span class="koboSpan" id="kobo.409.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">ReleasePolicy</span></strong><span class="koboSpan" id="kobo.411.1"> template is specialized with the concrete instantiation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.413.1"> template, including all its policies, and including the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">ReleasePolicy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1"> itself.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Now, the release policy knows the type of the derived class and can cast itself to that type. </span><span class="koboSpan" id="kobo.416.2">This case is always safe because the correct derived class is guaranteed </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">by construction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
// Example 11
template &lt;typename P&gt; struct WithRelease {
  void release() { static_cast&lt;P*&gt;(this)-&gt;p_ = nullptr; }
};</span></pre>
<p><span class="koboSpan" id="kobo.419.1">The template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">P</span></strong><span class="koboSpan" id="kobo.421.1"> will be substituted with the type of the smart pointer. </span><span class="koboSpan" id="kobo.421.2">Once the smart pointer publicly inherits from the release policy, the public member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">release()</span></strong><span class="koboSpan" id="kobo.423.1">, of the policy is inherited and becomes a part of the smart pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">public interface.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">The last detail concerning the implementation of the release policy has to do with the access. </span><span class="koboSpan" id="kobo.425.2">As we’ve written so far, the data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">p_</span></strong><span class="koboSpan" id="kobo.427.1"> is private in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.429.1"> class and cannot be accessed by its base classes directly. </span><span class="koboSpan" id="kobo.429.2">The solution to this is to declare the corresponding base class to be a friend of the </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
// Example 11
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          template &lt;typename...&gt; class ReleasePolicy =
                                       WithRelease&gt;
class SmartPtr : private DeletionPolicy,
  public ReleasePolicy&lt;SmartPtr&lt;T, DeletionPolicy,
                                   ReleasePolicy&gt;&gt;
{
  friend class ReleasePolicy&lt;SmartPtr&gt;;
  T* p_;
  ...
</span><span class="koboSpan" id="kobo.431.2">};</span></pre>
<p><span class="koboSpan" id="kobo.432.1">Note that inside the body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.434.1"> class, we do not need to repeat all the template parameters. </span><span class="koboSpan" id="kobo.434.2">The shorthand </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.436.1"> refers to the currently instantiated template. </span><span class="koboSpan" id="kobo.436.2">This does not extend to the part of the class declaration before the opening brace of the class, so we had to repeat the template parameters when specifying the policy as a </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">The no-release policy is just as easy </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">to write:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
// Example 11
template &lt;typename P&gt; struct NoRelease {};</span></pre>
<p><span class="koboSpan" id="kobo.441.1">There is </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.442.1">no </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">release()</span></strong><span class="koboSpan" id="kobo.444.1"> function here, so an attempt to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">release()</span></strong><span class="koboSpan" id="kobo.446.1"> on a smart pointer with this policy will not compile. </span><span class="koboSpan" id="kobo.446.2">This solves our stated requirement to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">release()</span></strong><span class="koboSpan" id="kobo.448.1"> public member function only when it makes sense to call one. </span><span class="koboSpan" id="kobo.448.2">The policy-based design is a complex pattern, and it is rare to be limited to just one way to do something. </span><span class="koboSpan" id="kobo.448.3">There is another way to accomplish the same objective, we are going to study it later in this chapter, in the section, </span><em class="italic"><span class="koboSpan" id="kobo.449.1">Using policies to control the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.450.1">public interface</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">There is yet another way in which policy objects can sometimes be used. </span><span class="koboSpan" id="kobo.452.2">This applies only to policies that have no internal state in any version of the policy, by design. </span><span class="koboSpan" id="kobo.452.3">For example, our deletion policies are sometimes stateless, but the one with the reference to the caller’s heap is not, so this is a policy that is not always stateless. </span><span class="koboSpan" id="kobo.452.4">The release policy can always be considered stateless; there is no reason for us to add a data member to it, but it is constrained to be used through public inheritance because its primary effect is to inject a new public </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">member function.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Let’s consider another aspect of behavior that we may want to customize - debugging or logging. </span><span class="koboSpan" id="kobo.454.2">For debugging purposes, it may be convenient to print when an object is owned by a smart pointer and when it is deleted. </span><span class="koboSpan" id="kobo.454.3">We could add a debugging policy to the smart pointer to support this. </span><span class="koboSpan" id="kobo.454.4">The debug policy has to do only one thing, and that is to print something when a smart pointer is constructed or destroyed. </span><span class="koboSpan" id="kobo.454.5">It does not need access to the smart pointer if we pass the value of the pointer to the printing function. </span><span class="koboSpan" id="kobo.454.6">Therefore, we can make the print functions static in the debug policy and not store this policy in the smart pointer class </span><a id="_idIndexMarker848"/><span class="No-Break"><span class="koboSpan" id="kobo.455.1">at all:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
// Example 12
template &lt;typename T,
          typename DeletionPolicy,
          typename DebugPolicy = NoDebug&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
  : DeletionPolicy(std::move(deletion_policy)), p_(p) {
    DebugPolicy::constructed(p_);
  }
  ~SmartPtr() {
    DebugPolicy::deleted(p_);
    DeletionPolicy::operator()(p_);
  }
  ...
</span><span class="koboSpan" id="kobo.456.2">};</span></pre>
<p><span class="koboSpan" id="kobo.457.1">For simplicity, we have omitted the release policy, but multiple policies are easy to combine. </span><span class="koboSpan" id="kobo.457.2">The debugging policy implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">is straightforward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
// Example 12
struct Debug {
  template &lt;typename T&gt;
  static void constructed(const T* p) {
    std::cout &lt;&lt; "Constructed SmartPtr for object " &lt;&lt;
      static_cast&lt;const void*&gt;(p) &lt;&lt; std::endl;
  }
  template &lt;typename T&gt;
  static void deleted(const T* p) {
    std::cout &lt;&lt; "Destroyed SmartPtr for object " &lt;&lt;
      static_cast&lt;const void*&gt;(p) &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.460.1">We have chosen to implement the policy as a non-template class with template static member functions. </span><span class="koboSpan" id="kobo.460.2">Alternatively, we could have implemented it as a template, parametrized with the object type </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">T</span></strong><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">The no-debug version of the policy, which is the default, is even </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.463.1">simpler. </span><span class="koboSpan" id="kobo.463.2">It must have the same functions defined, but they don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">do anything:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
// Example 12
struct NoDebug {
  template &lt;typename T&gt;
    static void constructed(const T* p) {}
  template &lt;typename T&gt; static void deleted(const T* p) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.466.1">We can expect the compiler to inline the empty template functions at the call site and optimize the entire call away since no code needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">be generated.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">Note that by choosing this implementation of policies, we made a somewhat restrictive design decision - all versions of the debug policy must be stateless. </span><span class="koboSpan" id="kobo.468.2">We may, in time, come to regret this decision if we need to, for example, store a custom output stream inside a debug policy, instead of the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">std::cout</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">But even in that case, only the implementation of the smart pointer class will have to change - the client code will continue to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">no changes.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">We have considered three different ways to incorporate the policy objects into the policy-based class - by composition, by inheritance (public or private), and by compile-time incorporation</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.473.1"> only, where the policy object does not need to be stored inside the main object at runtime. </span><span class="koboSpan" id="kobo.473.2">We will now move on to more advanced tech</span><a id="_idTextAnchor703"/><a id="_idTextAnchor704"/><span class="koboSpan" id="kobo.474.1">niques for </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">policy-based design.</span></span></p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor705"/><span class="koboSpan" id="kobo.476.1">Advanced policy-based design</span></h1>
<p><span class="koboSpan" id="kobo.477.1">The techniques we </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.478.1">have introduced in the previous section form the foundation of policy-based design - policies can be classes, template instantiations, or templates (used by template template parameters). </span><span class="koboSpan" id="kobo.478.2">The policy classes can be composed, inherited, or used statically at compile time. </span><span class="koboSpan" id="kobo.478.3">If a policy needs to know the type of the primary policy-based class, the CRTP can be used. </span><span class="koboSpan" id="kobo.478.4">The rest is largely variations on the same theme, as well as tricky ways to combine several techniques to accomplish something new. </span><span class="koboSpan" id="kobo.478.5">We will now consider some of</span><a id="_idTextAnchor706"/><a id="_idTextAnchor707"/><span class="koboSpan" id="kobo.479.1"> these more </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">advanced techniques.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor708"/><span class="koboSpan" id="kobo.481.1">Policies for constructors</span></h2>
<p><span class="koboSpan" id="kobo.482.1">Policies can be </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.483.1">used to customize almost any aspect of the implementation, as well as to alter the class interface. </span><span class="koboSpan" id="kobo.483.2">However, there are unique challenges that arise when we attempt to customize class constructors </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">using policies.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">As an example, let’s consider another limitation of our current smart pointer. </span><span class="koboSpan" id="kobo.485.2">As it stands so far, the object owned by the smart pointer is always deleted when the smart pointer is deleted. </span><span class="koboSpan" id="kobo.485.3">If the smart pointer supports release, then we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">release()</span></strong><span class="koboSpan" id="kobo.487.1"> member function and be wholly responsible for the deletion of the object. </span><span class="koboSpan" id="kobo.487.2">But how are we going to ensure this deletion? </span><span class="koboSpan" id="kobo.487.3">The most likely way is, we will let another smart pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">own it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
SmartPtr&lt;C&gt; p1(new C);
SmartPtr&lt;C&gt; p2(&amp;*p1); // Now two pointers own one object
p1.release();</span></pre>
<p><span class="koboSpan" id="kobo.490.1">This approach is verbose and error-prone - we temporarily let two pointers own the same object. </span><span class="koboSpan" id="kobo.490.2">If something were to happen at this moment that causes both pointers to be deleted, we would destroy the same object twice. </span><span class="koboSpan" id="kobo.490.3">We also have to remember to always release one of these pointers, but only one. </span><span class="koboSpan" id="kobo.490.4">We should take the higher-level view of the problem - we are trying to pass the ownership of the object from one smart pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">The better way to do this is by moving the first pointer into </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the second:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
SmartPtr&lt;C&gt; p1(new C);
SmartPtr&lt;C&gt; p2(std::move(p1));</span></pre>
<p><span class="koboSpan" id="kobo.495.1">Now, the first pointer is left in the moved-from state, which we can define (the only requirement is that the destructor call must be valid). </span><span class="koboSpan" id="kobo.495.2">We choose to define it to be a pointer that does not own any object, that is, a pointer in the released state. </span><span class="koboSpan" id="kobo.495.3">The second pointer receives the ownership of the object and will delete it in </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">due time.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">To support this functionality, we must implement the move constructor. </span><span class="koboSpan" id="kobo.497.2">However, there may be a reason to sometimes prevent the transfer of ownership. </span><span class="koboSpan" id="kobo.497.3">Therefore, we may want to have both</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.498.1"> movable and non-movable pointers. </span><span class="koboSpan" id="kobo.498.2">This calls for yet another policy to control whether moving </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">is supported:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden
&gt;
class SmartPtr ...;</span></pre>
<p><span class="koboSpan" id="kobo.501.1">For simplicity, we have reverted to just one other policy - the deletion policy. </span><span class="koboSpan" id="kobo.501.2">The other policies we have considered can be added alongside the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">MovePolicy</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">The deletion policy can be implemented in any of the ways we have learned already. </span><span class="koboSpan" id="kobo.503.3">Since it is likely to benefit from the empty base optimization, we will stay with the inheritance-based implementation for it. </span><span class="koboSpan" id="kobo.503.4">The move policy can be implemented in several different ways, but inheritance is probably </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">the easiest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
// Example 13
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy,
                 private MovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)),
      MovePolicy(), p_(p) {}
  … SmartPtr code unchanged …
  SmartPtr(SmartPtr&amp;&amp; that) :
    DeletionPolicy(std::move(that)),
    MovePolicy(std::move(that)),
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr(const SmartPtr&amp;) = delete;
};</span></pre>
<p><span class="koboSpan" id="kobo.506.1">With both policies</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.507.1"> integrated using private inheritance, we now have a derived object with several base classes. </span><span class="koboSpan" id="kobo.507.2">Such multiple inheritance is fairly common in policy-based design in C++, and should not alarm you. </span><span class="koboSpan" id="kobo.507.3">This technique is sometimes known as </span><em class="italic"><span class="koboSpan" id="kobo.508.1">mix-in</span></em><span class="koboSpan" id="kobo.509.1"> since the implementation of the derived class is </span><em class="italic"><span class="koboSpan" id="kobo.510.1">mixed</span></em><span class="koboSpan" id="kobo.511.1"> from the pieces provided by the base classes. </span><span class="koboSpan" id="kobo.511.2">In C++, the term </span><em class="italic"><span class="koboSpan" id="kobo.512.1">mix-in</span></em><span class="koboSpan" id="kobo.513.1"> is also used to refer to a totally different inheritance scheme that is related to the CRTP, so the use of this term often creates confusion (in most object-oriented languages, </span><em class="italic"><span class="koboSpan" id="kobo.514.1">mix-in</span></em><span class="koboSpan" id="kobo.515.1"> unambiguously refers to the application of multiple inheritance that we can </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">see here).</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">The new feature in our smart pointer class is the move constructor. </span><span class="koboSpan" id="kobo.517.2">The move constructor is unconditionally present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.519.1"> class. </span><span class="koboSpan" id="kobo.519.2">However, its implementation requires that all base classes be movable. </span><span class="koboSpan" id="kobo.519.3">This gives us a way to disable move support with a non-movable </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">move policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
// Example 13
struct MoveForbidden {
  MoveForbidden() = default;
  MoveForbidden(MoveForbidden&amp;&amp;) = delete;
  MoveForbidden(const MoveForbidden&amp;) = delete;
  MoveForbidden&amp; operator=(MoveForbidden&amp;&amp;) = delete;
  MoveForbidden&amp; operator=(const MoveForbidden&amp;) = delete;
};</span></pre>
<p><span class="koboSpan" id="kobo.522.1">The movable policy is </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">much simpler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
// Example 13
struct MoveAllowed {
};</span></pre>
<p><span class="koboSpan" id="kobo.525.1">We can now</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.526.1"> construct a movable pointer and a </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">non-movable pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
class C { ... </span><span class="koboSpan" id="kobo.528.2">};
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, MoveAllowed&gt; p = ...;
auto p1(std::move(p)); // OK
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, MoveForbidden&gt; q = ...;
auto q1(std::move(q)); // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.529.1">An attempt to move a non-movable pointer does not compile because one of the base classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">MoveForbidden</span></strong><span class="koboSpan" id="kobo.531.1">, is non-movable (does not have a move constructor). </span><span class="koboSpan" id="kobo.531.2">Note that the moved-from pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">p</span></strong><span class="koboSpan" id="kobo.533.1"> in the preceding example can be safely deleted, but cannot be used in any other way. </span><span class="koboSpan" id="kobo.533.2">In particular, it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">be dereferenced.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">While we are dealing with movable pointers, it would make sense to provide a move assignment operator </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
// Example 13
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy,
                 private MovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)),
      MovePolicy(), p_(p) {}
  … SmartPtr code unchanged …
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    if (this == &amp;that) return *this;
    DeletionPolicy::operator()(p_);
    p_ = std::exchange(that.p_, nullptr);
    DeletionPolicy::operator=(std::move(that));
    MovePolicy::operator=(std::move(that));
    return *this;
  }
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
};</span></pre>
<p><span class="koboSpan" id="kobo.538.1">Note the check for the</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.539.1"> self-assignment. </span><span class="koboSpan" id="kobo.539.2">Unlike the copy assignment, which is required to do nothing for self-assignment, the move assignment is less constrained by the standard. </span><span class="koboSpan" id="kobo.539.3">The only certain requirement is that the self-move should always leave an object in a well-defined state (the moved-from state is an example of such a state). </span><span class="koboSpan" id="kobo.539.4">A no-op self-move is not required but is valid as well. </span><span class="koboSpan" id="kobo.539.5">Also, note the way in which the base classes are move-assigned - the easiest way is to invoke the move assignment operator of each base class directly. </span><span class="koboSpan" id="kobo.539.6">There is no need to cast the derived class </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">that</span></strong><span class="koboSpan" id="kobo.541.1"> to each of the base types - this is an implicitly performed cast. </span><span class="koboSpan" id="kobo.541.2">We must not forget to set the moved-from pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">nullptr</span></strong><span class="koboSpan" id="kobo.543.1">, otherwise, the object owned by these pointers will be </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">deleted twice.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">For simplicity, we have ignored all of the policies we introduced earlier. </span><span class="koboSpan" id="kobo.545.2">This is fine – not all designs need everything to be controlled by a policy, and, in any case, it is quite straightforward to combine multiple policies. </span><span class="koboSpan" id="kobo.545.3">However, it is a good opportunity to point out that different policies are sometimes related - for example, if we use both a release policy and a move policy, the use of a movable move policy strongly suggests that the object must support release (a released pointer is similar to a moved-from pointer). </span><span class="koboSpan" id="kobo.545.4">Using template metaprogramming, we can force such dependence between the policies, if </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">need be.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Note that a policy that needs to disable or enable constructors does not automatically have to be used as a base class - move assignment or construction also moves all data members, and, therefore, a non-movable data member will disable the move operations just as well. </span><span class="koboSpan" id="kobo.547.2">The more important reason to use inheritance here is the empty base class optimization: if we introduced a </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">MovePolicy</span></strong><span class="koboSpan" id="kobo.549.1"> data member into our class, it would double the object size from 8 to 16 bytes on a </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">64-bit machine.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">We have considered making our pointers movable. </span><span class="koboSpan" id="kobo.551.2">But what about copying? </span><span class="koboSpan" id="kobo.551.3">So far, we have disallowed copying outright - both the copy constructor and the copy assignment operator are deleted in our smart pointer from the very beginning. </span><span class="koboSpan" id="kobo.551.4">This makes sense so far - we do not want to have two smart pointers own the same object and delete it twice. </span><span class="koboSpan" id="kobo.551.5">But there is another type of ownership where the copy operation makes perfect sense - the shared ownership, such as what’s implemented by a reference-counting shared pointer. </span><span class="koboSpan" id="kobo.551.6">With this type of pointer, copying the pointer is allowed, and both pointers now equally own the pointed-to object. </span><span class="koboSpan" id="kobo.551.7">A reference count is maintained to count how many pointers to the same object exist in the program. </span><span class="koboSpan" id="kobo.551.8">When the very last pointer owning a particular object is deleted, so is the object itself, since there are no more references </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">There are several ways to implement a reference-counted shared pointer, but let’s start with the design of the class and its policies. </span><span class="koboSpan" id="kobo.553.2">We still need a deletion policy, and it makes sense to have a single policy control the move and copy operations. </span><span class="koboSpan" id="kobo.553.3">For simplicity, we will again limit ourselves to just the policies we are </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">currently exploring:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
// Example 14
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename CopyMovePolicy = NoMoveNoCopy
&gt;
class SmartPtr : private DeletionPolicy,
                 public CopyMovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)), p_(p)
  {}
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    CopyMovePolicy(std::move(other)),
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr(const SmartPtr&amp; other) :
    DeletionPolicy(other),
    CopyMovePolicy(other),
    p_(other.p_) {}
  ~SmartPtr() {
    if (CopyMovePolicy::must_delete())
      DeletionPolicy::operator()(p_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.556.1">The copy </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.557.1">operations are no longer unconditionally deleted. </span><span class="koboSpan" id="kobo.557.2">Both the copy and the move constructor are provided (the two assignment operators are omitted for brevity, but should be implemented in the same way it was </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">done earlier).</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">The deletion of the object in the destructor of the smart pointer is no longer unconditional - in the case of the reference-counted pointer, the copying policy maintains the reference count and knows when there is only one copy of the smart pointer for a </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">particular object.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">The smart pointer class itself provides the requirements for the policy classes. </span><span class="koboSpan" id="kobo.561.2">The no-move, no-copy policy must disallow all copy and </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">move operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
// Example 14
class NoMoveNoCopy {
  protected:
  NoMoveNoCopy() = default;
  NoMoveNoCopy(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy(const NoMoveNoCopy&amp;) = delete;
  NoMoveNoCopy&amp; operator=(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy&amp; operator=(const NoMoveNoCopy&amp;) = delete;
  constexpr bool must_delete() const { return true; }
};</span></pre>
<p><span class="koboSpan" id="kobo.564.1">In addition to </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.565.1">that, the non-copyable smart pointer always deletes the object it owns in its destructor, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">must_delete()</span></strong><span class="koboSpan" id="kobo.567.1"> member function should always return </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">true</span></strong><span class="koboSpan" id="kobo.569.1">. </span><span class="koboSpan" id="kobo.569.2">Note that this function must be implemented by all copying policies, even if it is trivial, otherwise, the smart pointer class will not compile. </span><span class="koboSpan" id="kobo.569.3">However, we can fully expect the compiler to optimize the call away and unconditionally call the destructor when this policy </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">The move-only policy is similar to the movable policy we had earlier, but now we must explicitly enable the move operations and disable the </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">copy operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
// Example 14
class MoveNoCopy {
  protected:
  MoveNoCopy() = default;
  MoveNoCopy(MoveNoCopy&amp;&amp;) = default;
  MoveNoCopy(const MoveNoCopy&amp;) = delete;
  MoveNoCopy&amp; operator=(MoveNoCopy&amp;&amp;) = default;
  MoveNoCopy&amp; operator=(const MoveNoCopy&amp;) = delete;
  constexpr bool must_delete() const { return true; }
};</span></pre>
<p><span class="koboSpan" id="kobo.574.1">Again, the deletion is unconditional (the pointer inside the smart pointer object can be null if the object was moved, but this does not prevent us from calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">operator delete</span></strong><span class="koboSpan" id="kobo.576.1"> on it). </span><span class="koboSpan" id="kobo.576.2">This policy allows the move constructor and the move assignment operator to compile; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.578.1"> class provides the correct implementation for these operations, and no additional support from the policy </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">is required.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">The reference-counting copying policy is much more complex. </span><span class="koboSpan" id="kobo.580.2">Here, we have to decide on the shared pointer implementation. </span><span class="koboSpan" id="kobo.580.3">The simplest implementation allocates the reference </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.581.1">counter in a separate memory allocation, which is managed by the copying policy. </span><span class="koboSpan" id="kobo.581.2">Let’s start with a reference-counted copying policy that does not allow </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">move operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
// Example 14
class NoMoveCopyRefCounted {
  size_t* count_;
  protected:
  NoMoveCopyRefCounted() : count_(new size_t(1)) {}
  NoMoveCopyRefCounted(const NoMoveCopyRefCounted&amp; other) :
    count_(other.count_)
  {
    ++(*count_);
  }
  NoMoveCopyRefCounted(NoMoveCopyRefCounted&amp;&amp;) = delete;
  ~NoMoveCopyRefCounted() {
    --(*count_);
    if (*count_ == 0) {
      delete count_;
    }
  }
  bool must_delete() const { return *count_ == 1; }
};</span></pre>
<p><span class="koboSpan" id="kobo.584.1">When a smart pointer with this copying policy is constructed, a new reference counter is allocated and initialized to one (we have one smart pointer pointing to the particular object - the one we are now constructing). </span><span class="koboSpan" id="kobo.584.2">When a smart pointer is copied, so are all its base classes, including the copy policy. </span><span class="koboSpan" id="kobo.584.3">The copy constructor of this policy simply increments the reference count. </span><span class="koboSpan" id="kobo.584.4">When a smart pointer is deleted, the reference count is decremented. </span><span class="koboSpan" id="kobo.584.5">The very last smart pointer to be deleted also deletes the count itself. </span><span class="koboSpan" id="kobo.584.6">The copying policy also controls when the pointed-to object is deleted - it happens when the reference count reaches one, which means that we are about to delete the very last pointer for this object. </span><span class="koboSpan" id="kobo.584.7">It is, of course, very important to make sure that the counter is not deleted before</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.585.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">must_delete()</span></strong><span class="koboSpan" id="kobo.587.1"> function is called. </span><span class="koboSpan" id="kobo.587.2">This is guaranteed to be true since the destructors of the base classes run after the destructor of the derived class - the derived class of the last smart pointer will see the counter value of one and will delete the object; then, the destructor of the copying policy will decrement the counter once more, see it drop to zero, and delete the </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">counter itself.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">With this policy, we can implement shared ownership of </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">an object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, NoMoveCopyRefCounted&gt; p1{new C};
auto p2(p1);</span></pre>
<p><span class="koboSpan" id="kobo.592.1">Now, we have two pointers to the same object, with the reference count of two. </span><span class="koboSpan" id="kobo.592.2">The object is deleted when the last of the two pointers is, assuming that no more copies are created beforehand. </span><span class="koboSpan" id="kobo.592.3">The smart pointer is copyable, but </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">not movable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, NoMoveCopyRefCounted&gt; p1{new C};
auto p2(std::move(p1)); // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.595.1">In general, once reference-counted copying is supported, there is probably no reason to disallow move operations, unless they are simply not needed (in which case, the no-move implementation can be slightly more efficient). </span><span class="koboSpan" id="kobo.595.2">To support the move, we must give some thought to the moved-from state of the reference-counting policy – clearly, it must not decrement the reference counter when it is deleted, since a moved-from pointer no longer owns the object. </span><span class="koboSpan" id="kobo.595.3">The simplest way is to reset the pointer to the reference counter so that it is no longer accessible from the copying policy, but then the copying policy</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.596.1"> must support the special case of a null </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">counter pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
// Example 15
class MoveCopyRefCounted {
  size_t* count_;
  protected:
  MoveCopyRefCounted() : count_(new size_t(1)) {}
  MoveCopyRefCounted(const MoveCopyRefCounted&amp; other) :
    count_(other.count_)
  {
    if (count_) ++(*count_);
  }
  ~MoveCopyRefCounted() {
    if (!count_) return;
    --(*count_);
    if (*count_ == 0) {
      delete count_;
    }
  }
  MoveCopyRefCounted(MoveCopyRefCounted&amp;&amp; other) :
    count_(std::exchange(other.count_, nullptr)) {}
  bool must_delete() const {
    return count_ &amp;&amp; *count_ == 1;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.599.1">Finally, a reference-counting copying policy must support the assignment operations as well. </span><span class="koboSpan" id="kobo.599.2">These are implemented similarly to the copy or move constructors (but take care to use the left-hand-side policies for the deletion of the left-hand-side objects before assigning the new values to </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">the policies).</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">As you have seen, some of the policy implementations can get pretty complex, and their interactions are even more so. </span><span class="koboSpan" id="kobo.601.2">Fortunately, the policy-based design is particularly well-suited for</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.602.1"> writing testable objects. </span><span class="koboSpan" id="kobo.602.2">This application of policy-based design is so </span><a id="_idTextAnchor709"/><a id="_idTextAnchor710"/><span class="koboSpan" id="kobo.603.1">important that it deserves </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">special mention.</span></span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor711"/><span class="koboSpan" id="kobo.605.1">Policies for test</span></h2>
<p><span class="koboSpan" id="kobo.606.1">We will now </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.607.1">show the reader how to use policy-based design to write better tests. </span><span class="koboSpan" id="kobo.607.2">In particular, policies can be used to make the code more testable by means of unit tests. </span><span class="koboSpan" id="kobo.607.3">This can be done by substituting a special test-only version of a policy instead of the regular one. </span><span class="koboSpan" id="kobo.607.4">Let us demonstrate this with the example of the reference-counting policy from the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">previous subsection.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">The main challenge of that policy is, of course, maintaining the correct reference count. </span><span class="koboSpan" id="kobo.609.2">We can easily develop some tests that should exercise all of the corner cases of </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">reference counting:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
// Test 1: only one pointer
{
  SmartPtr&lt;C, ... </span><span class="koboSpan" id="kobo.611.2">policies ...&gt; p(new C);
} // C should be deleted here
// Test 2: one copy
{
  SmartPtr&lt;C, ... </span><span class="koboSpan" id="kobo.611.3">policies ...&gt; p(new C);
  {
    auto p1(p); // Reference count should be 2
  } // C should not be deleted here
} // C should be deleted here</span></pre>
<p><span class="koboSpan" id="kobo.612.1">The hard part is actually testing that all of this code works the way it is supposed to. </span><span class="koboSpan" id="kobo.612.2">We know what the reference count should be, but we have no way of checking what it really is (adding the public function </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">count()</span></strong><span class="koboSpan" id="kobo.614.1"> to the smart pointer solves that problem, but it is the least of the difficulties). </span><span class="koboSpan" id="kobo.614.2">We know when the object is supposed to be deleted, but it is hard to verify that it actually was. </span><span class="koboSpan" id="kobo.614.3">We will probably get a crash if we delete the object twice, but even that is not certain. </span><span class="koboSpan" id="kobo.614.4">It is even harder to catch the case when the object is not deleted at all. </span><span class="koboSpan" id="kobo.614.5">A sanitizer can find such issues, at least if we use standard memory management, but they are not available in all environments and, unless the tests are designed to be run with the sanitizer, can produce very </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">noisy output.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">Fortunately, we can use policies to give our tests a window into the internal working of the object. </span><span class="koboSpan" id="kobo.616.2">For example, if we did not implement a public </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">count()</span></strong><span class="koboSpan" id="kobo.618.1"> method in all our reference-counting policies, we can create a testable wrapper for the </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">reference-counting policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
class NoMoveCopyRefCounted {
  protected:
  size_t* count_;
  ...
</span><span class="koboSpan" id="kobo.620.2">};
class NoMoveCopyRefCountedTest :
  public NoMoveCopyRefCounted {
  public:
  using NoMoveCopyRefCounted::NoMoveCopyRefCounted;
  size_t count() const { return *count_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.621.1">Note that we had to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">count_</span></strong><span class="koboSpan" id="kobo.623.1"> data member from private to protected in the main copy policy. </span><span class="koboSpan" id="kobo.623.2">We could also declare the test policy a friend, but then we would have to do this for every new test policy. </span><span class="koboSpan" id="kobo.623.3">Now, we can actually implement </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">our tests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
// Test 1: only one pointer
{
  SmartPtr&lt;C, ... </span><span class="koboSpan" id="kobo.625.2">NoMoveCopyRefCountedTest&gt; p(new C);
  assert(p.count() == 1);
} // C should be deleted here
// Test 2: one copy
{
  SmartPtr&lt;C, ... </span><span class="koboSpan" id="kobo.625.3">NoMoveCopyRefCountedTest&gt; p(new C);
  {
  auto p1(p); // Reference count should be 2
    assert(p.count() == 2);
    assert(p1.count() == 2);
    assert(&amp;*p == &amp;*p1);
  } // C should not be deleted here
  assert(p.count == 1);
} // C should be deleted here</span></pre>
<p><span class="koboSpan" id="kobo.626.1">Similarly, we can create an instrumented deletion policy that checks whether the object will be deleted, or record in some external logging object that it was actually deleted and test that the deletion was properly logged. </span><span class="koboSpan" id="kobo.626.2">We would need to instrument our smart pointer implementation to make calls to the debugging or </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">testing policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
// Example 16:
template &lt;... </span><span class="koboSpan" id="kobo.628.2">template parameters ...,
          typename DebugPolicy = NoDebug&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.628.3">base policies ... </span><span class="koboSpan" id="kobo.628.4">{
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy()) :
    DeletionPolicy(std::move(deletion_policy)), p_(p)
  {
    DebugPolicy::construct(this, p);
  }
  ~SmartPtr() {
    DebugPolicy::destroy(this, p_,
                         CopyMovePolicy::must_delete());
  if (CopyMovePolicy::must_delete())
    DeletionPolicy::operator()(p_);
  }
  ...
</span><span class="koboSpan" id="kobo.628.5">};</span></pre>
<p><span class="koboSpan" id="kobo.629.1">Both debug </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.630.1">and production (non-debug) policies must have all the methods referenced in the class, but the empty methods of the non-debug policy are going to be inlined and optimized down </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">to nothing.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
// Example 16
struct NoDebug {
  template &lt;typename P, typename T&gt;
  static void construct(const P* ptr, const T* p) {}
  template &lt;typename P, typename T&gt;
  static void destroy(const P* ptr, const T* p,
                      bool must_delete) {}
  ... </span><span class="koboSpan" id="kobo.632.2">other events ...
</span><span class="koboSpan" id="kobo.632.3">};</span></pre>
<p><span class="koboSpan" id="kobo.633.1">The debug policies vary, the basic ones simply log all </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">debuggable events:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
// Example 16
struct Debug {
  template &lt;typename P, typename T&gt;
  static void construct(const P* ptr, const T* p) {
    std::cout &lt;&lt; "Constructed SmartPtr at " &lt;&lt; ptr &lt;&lt;
      ", object " &lt;&lt; static_cast&lt;const void*&gt;(p) &lt;&lt;
      std::endl;
  }
  template &lt;typename P, typename T&gt;
  static void destroy(const P* ptr, const T* p,
                      bool must_delete) {
    std::cout &lt;&lt; "Destroyed SmartPtr at " &lt;&lt; ptr &lt;&lt;
      ", object " &lt;&lt; static_cast&lt;const void*&gt;(p) &lt;&lt;
      (must_delete ? </span><span class="koboSpan" id="kobo.635.2">" is" : " is not") &lt;&lt; " deleted" &lt;&lt;
      std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.636.1">The more complex </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.637.1">policies can validate that the internal state of the objects is consistent with the requirements and that the class invariants </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">are maintained.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">By now, the reader has likely noticed that the declarations of the policy-based objects can be </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">quite long:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
SmartPtr&lt;C, DeleteByOperator&lt;T&gt;, MoveNoCopy,
         WithRelease, Debug&gt; p( ... </span><span class="koboSpan" id="kobo.641.2">);</span></pre>
<p><span class="koboSpan" id="kobo.642.1">This is one of the most frequently observed problems with policy-based design, and we shoul</span><a id="_idTextAnchor712"/><a id="_idTextAnchor713"/><span class="koboSpan" id="kobo.643.1">d consider some ways to mitigate </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">this problem.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor714"/><span class="koboSpan" id="kobo.645.1">Policy adapters and aliases</span></h2>
<p><span class="koboSpan" id="kobo.646.1">Perhaps the most</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.647.1"> obvious drawback of the policy-based design is the way we have to declare the concrete objects - specifically, the long list of policies that must be repeated every time. </span><span class="koboSpan" id="kobo.647.2">Judicious use of default parameters helps to simplify the most commonly used cases. </span><span class="koboSpan" id="kobo.647.3">For example, let us look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">long declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
SmartPtr&lt;C, DeleteByOperator&lt;T&gt;, MoveNoCopy,
         WithRelease, NoDebug&gt;
p( ... </span><span class="koboSpan" id="kobo.649.2">);</span></pre>
<p><span class="koboSpan" id="kobo.650.1">Sometimes, this can be reduced to </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.652.1">
SmartPtr&lt;C&gt; p( ... </span><span class="koboSpan" id="kobo.652.2">);</span></pre>
<p><span class="koboSpan" id="kobo.653.1">This can be done if the defaults represent the most common case of a movable non-debug pointer that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">operator delete</span></strong><span class="koboSpan" id="kobo.655.1">. </span><span class="koboSpan" id="kobo.655.2">However, what is the point of adding the policies if we are not going to use them? </span><span class="koboSpan" id="kobo.655.3">A well-thought-out order of policy parameters helps to make the more common policy combinations shorter. </span><span class="koboSpan" id="kobo.655.4">For example, if the most common variation is the deletion policy, then a new pointer with a different deletion policy and default remaining policies can be declared without repeating the policies we do not need </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">to change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
SmartPtr&lt;C, DeleteHeap&lt;T&gt;&gt; p( ... </span><span class="koboSpan" id="kobo.657.2">);</span></pre>
<p><span class="koboSpan" id="kobo.658.1">This still leaves the problem of the less commonly used policies. </span><span class="koboSpan" id="kobo.658.2">Also, policies are often added later as additional features must be added to the design. </span><span class="koboSpan" id="kobo.658.3">These policies are almost always added to the end of the parameter list. </span><span class="koboSpan" id="kobo.658.4">To do otherwise would require rewriting every bit of code where a policy-based class is declared to reorder its parameters. </span><span class="koboSpan" id="kobo.658.5">However, the late-coming policies are not necessarily less often used, and this evolution of the design may lead to a case where many policy arguments have to be explicitly written, even at their default values, so that one of the trailing arguments can </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">be changed.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">While there is no general solution to this problem within the confines of the traditional policy-based design, in practice, there are often few commonly used groups of policies, and then there are some frequent variations. </span><span class="koboSpan" id="kobo.660.2">For example, most of our smart pointers may be using </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">operator delete</span></strong><span class="koboSpan" id="kobo.662.1"> and support move and release, but we frequently need to alternate between the debug and non-debug versions. </span><span class="koboSpan" id="kobo.662.2">This can be accomplished by creating adapters that convert a class with many policies to a new interface that exposes only the policies we want to change often and pins the rest of the policies to their commonly used values. </span><span class="koboSpan" id="kobo.662.3">Any large design will likely need more than one such adapter, as the commonly used sets of policies </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">can vary.</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">The simplest way to write such an adapter is with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">using</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1"> alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
// Example 17
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
using SmartPtrAdapter =
  SmartPtr&lt;T, DeleteByOperator&lt;T&gt;, MoveNoCopy,
              WithRelease, DebugPolicy&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.668.1">The other </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.669.1">option is to </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">use inheritance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
// Example 18
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
class SmartPtrAdapter : public SmartPtr&lt;T,
  DeleteByOperator&lt;T&gt;, MoveNoCopy,
  WithRelease, DebugPolicy&gt;
{...};</span></pre>
<p><span class="koboSpan" id="kobo.672.1">This creates a derived class template that pins some of the parameters of the base class template while leaving the rest parameterized. </span><span class="koboSpan" id="kobo.672.2">The entire public interface of the base class is inherited, but some care needs to be taken about the constructors of the base class. </span><span class="koboSpan" id="kobo.672.3">By default, they are not inherited, and so the newly derived class will have the default compiler-generated constructors. </span><span class="koboSpan" id="kobo.672.4">This is probably not something we want, so we have to bring the base class constructors (and possibly the assignment operators) into the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">derived class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
// Example 18
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
class SmartPtrAdapter : public SmartPtr&lt;T,
  DeleteByOperator&lt;T&gt;, MoveNoCopy,
  WithRelease, DebugPolicy&gt;
{
  using base_t = SmartPtr&lt;T, DeleteByOperator&lt;T&gt;,
    MoveNoCopy, WithRelease, DebugPolicy&gt;;
  using base_t::SmartPtr;
  using base_t::operator=;
};</span></pre>
<p><span class="koboSpan" id="kobo.675.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">using</span></strong><span class="koboSpan" id="kobo.677.1"> alias is definitely easier to write and maintain, but the derived class adapter offers more flexibility if it is necessary to also adapt some of the member functions, nested </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">types, etc.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">We can now use the new adapter when we need a smart pointer with the preset policies, but quickly change the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">debug policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
SmartPtrAdapter&lt;C, Debug&gt; p1{new C); // Debug pointer
SmartPtrAdapter&lt;C&gt; p2{new C); // Non-debug pointer</span></pre>
<p><span class="koboSpan" id="kobo.682.1">As we said from the beginning, the most common application of policies is to select a specific implementation for some aspect of the behavior of the class. </span><span class="koboSpan" id="kobo.682.2">Sometimes, such variations in the implementation are reflected in the public interface of the class as well - some operations may make sense only for some implementations, and not for others, and the best way to make sure that an operation that is not compatible with the implementation</span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.683.1"> is not invoked is to simply not </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">provide it.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">Now, let us revisit the issue of selectively enabl</span><a id="_idTextAnchor715"/><a id="_idTextAnchor716"/><span class="koboSpan" id="kobo.686.1">ing parts of the public interface </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">using policies.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor717"/><span class="koboSpan" id="kobo.688.1">Using policies to control the public interface</span></h2>
<p><span class="koboSpan" id="kobo.689.1">We have</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.690.1"> previously used policies to control the public interface in one of two ways - first, we were able to inject a public member function by inheriting from a policy. </span><span class="koboSpan" id="kobo.690.2">This approach is reasonably flexible and powerful, but has two drawbacks - first, once we inherit publicly from a policy, we have no control over what interface gets injected - every public member function of the policy becomes a part of the derived class interface. </span><span class="koboSpan" id="kobo.690.3">Second, to implement anything useful this way, we have to let the policy class cast itself to the derived class, and then it has to have access to all of the data members and possibly other policies of the class. </span><span class="koboSpan" id="kobo.690.4">The second approach we tried relied on a particular property of the constructors - to copy or move a class, we have to copy or move all of its base classes or data members; if one of them is non-copyable or non-movable, the entire constructor will fail to compile. </span><span class="koboSpan" id="kobo.690.5">Unfortunately, it usually fails with a rather non-obvious syntax error - nothing as straightforward as </span><em class="italic"><span class="koboSpan" id="kobo.691.1">no copy constructor found in this object.</span></em><span class="koboSpan" id="kobo.692.1"> We can extend this technique to other member functions, for example, to assignment operators, but it </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">gets uglier.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">We will now learn a more direct way to manipulate the public interface of a policy-based class. </span><span class="koboSpan" id="kobo.694.2">First of all, let’s differentiate between conditionally disabling existing member functions and adding new ones. </span><span class="koboSpan" id="kobo.694.3">The former is reasonable and generally safe: if a particular implementation cannot support certain operations offered by the interface, they should not be offered in the first place. </span><span class="koboSpan" id="kobo.694.4">The latter is dangerous as it allows for the essentially arbitrary and uncontrolled extension of the public interface of the class. </span><span class="koboSpan" id="kobo.694.5">Therefore, we will focus on providing the interface for all possible intended uses of a policy-based class, and then disabling parts of that interface when they do not make sense for some</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.695.1"> choice </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">of policies.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">There is already a facility in the C++ language to selectively enable and disable member functions. </span><span class="koboSpan" id="kobo.697.2">Prior to C++20, this facility is most commonly implemented through concepts (if they are available) or </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">std::enable_if</span></strong><span class="koboSpan" id="kobo.699.1">, but the foundation behind it is the SFINAE idiom that we studied in </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.700.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.701.1">, </span><em class="italic"><span class="koboSpan" id="kobo.702.1">SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.703.1">. </span><span class="koboSpan" id="kobo.703.2">In C++20, the much more powerful concepts can replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">std::enable_if</span></strong><span class="koboSpan" id="kobo.705.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">many cases.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">To illustrate the use of SFINAE to let the policies selectively enable a member function, we’re going to reimplement the policy controlling the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">release()</span></strong><span class="koboSpan" id="kobo.709.1"> member function. </span><span class="koboSpan" id="kobo.709.2">We have done this once already in this chapter by inheriting from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">ReleasePolicy</span></strong><span class="koboSpan" id="kobo.711.1"> that may or may not provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">release()</span></strong><span class="koboSpan" id="kobo.713.1"> member function; if one is provided, CRTP had to be used to implement it. </span><span class="koboSpan" id="kobo.713.2">We are now going to do the same but using </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">C++20 concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">As we just said, a policy that relies on SFINAE and concepts cannot add any new member functions to the interface of a class; it can only disable some of them. </span><span class="koboSpan" id="kobo.715.2">Therefore, the first step is to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">release()</span></strong><span class="koboSpan" id="kobo.717.1"> function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">SmartPtr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.719.1">class itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
// Example 19
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename ReleasePolicy = NoRelease&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  void release() { p_ = nullptr; }
  ...
</span><span class="koboSpan" id="kobo.720.2">};</span></pre>
<p><span class="koboSpan" id="kobo.721.1">Right now, it is always enabled, so we need to conditionally enable it using some property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">ReleasePolicy</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">Since this policy controls a single behavior, all we need is a constant value</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.724.1"> that tells us whether the release feature should </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">be supported:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.726.1">
// Example 19
struct WithRelease {
  static constexpr bool enabled = true;
};
struct NoRelease {
  static constexpr bool enabled = false;
};</span></pre>
<p><span class="koboSpan" id="kobo.727.1">Now, we need to conditionally enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">release()</span></strong><span class="koboSpan" id="kobo.729.1"> member function with </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">a constraint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.731.1">
// Example 19
template &lt;...&gt; class SmartPtr ... </span><span class="koboSpan" id="kobo.731.2">{
  ...
</span><span class="koboSpan" id="kobo.731.3">  void release() requires ReleasePolicy::enabled {
    p_ = nullptr;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.732.1">That’s all we need in C++20. </span><span class="koboSpan" id="kobo.732.2">Note that we did not need to inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">ReleasePolicy</span></strong><span class="koboSpan" id="kobo.734.1"> because there is nothing in it except for a constant value. </span><span class="koboSpan" id="kobo.734.2">We also do not need to move or copy this policy, for the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">same reason.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">Before C++20 and concepts, we have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">std::enable_if</span></strong><span class="koboSpan" id="kobo.738.1"> to enable or disable a particular member function - in general, the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">std::enable_if&lt;value, type&gt;</span></strong><span class="koboSpan" id="kobo.740.1"> will compile and yield the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">type</span></strong><span class="koboSpan" id="kobo.742.1"> if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">value</span></strong><span class="koboSpan" id="kobo.744.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">true</span></strong><span class="koboSpan" id="kobo.746.1"> (it must be a compile-time, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">constexpr</span></strong><span class="koboSpan" id="kobo.748.1">, Boolean value). </span><span class="koboSpan" id="kobo.748.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">value</span></strong><span class="koboSpan" id="kobo.750.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">false</span></strong><span class="koboSpan" id="kobo.752.1">, the type substitution fails (no type result is produced). </span><span class="koboSpan" id="kobo.752.2">The proper use for this template metafunction is in an SFINAE context, where the failure of type substitution does not result in a compilation error, but simply disables the function that causes the failure (to be more precise, it removes it from the overload </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">resolution set).</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">The policies themselves do not have to change at all: both SFINAE and constraints need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">constexpr bool</span></strong><span class="koboSpan" id="kobo.756.1"> value. </span><span class="koboSpan" id="kobo.756.2">What changes is the expression used to disable a member function. </span><span class="koboSpan" id="kobo.756.3">It is tempting to write it </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">simply as:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
template &lt;...&gt; class SmartPtr ... </span><span class="koboSpan" id="kobo.758.2">{
  ...
</span><span class="koboSpan" id="kobo.758.3">  std::enable_if_t&lt;ReleasePolicy::enabled&gt; release() {
    p_ = nullptr;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.759.1">Unfortunately, this is not going to work: for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">NoRelease</span></strong><span class="koboSpan" id="kobo.761.1"> policy, this fails to compile even if we do not try to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">release()</span></strong><span class="koboSpan" id="kobo.763.1">. </span><span class="koboSpan" id="kobo.763.2">The reason is that SFINAE works only when template parameter substitution is done (</span><strong class="bold"><span class="koboSpan" id="kobo.764.1">S</span></strong><span class="koboSpan" id="kobo.765.1"> stands</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.766.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">Substitution</span></strong><span class="koboSpan" id="kobo.768.1">) and applies only to function templates. </span><span class="koboSpan" id="kobo.768.2">Therefore, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">release()</span></strong><span class="koboSpan" id="kobo.770.1"> function must be a template, and, furthermore, the potential substitution failure has to occur during the substitution of template parameters. </span><span class="koboSpan" id="kobo.770.2">We do not need any template parameters to declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">release()</span></strong><span class="koboSpan" id="kobo.772.1">, but we have to introduce a dummy one to </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">use SFINAE:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
// Example 20
template &lt;...&gt; class SmartPtr ... </span><span class="koboSpan" id="kobo.774.2">{
  ...
</span><span class="koboSpan" id="kobo.774.3">  template&lt;typename U = T&gt;
  std::enable_if_t&lt;sizeof(U) != 0 &amp;&amp;
                   ReleasePolicy::enabled&gt; release() {
    p_ = nullptr;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.775.1">We have seen such “fake templates” when we were describing the “concept utilities” – a way to mimic concepts before C++20 – in </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.776.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.777.1">, SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.778.1">. </span><span class="koboSpan" id="kobo.778.2">Now we have a template type parameter; the fact that it is never going to be used and is always set to its default value changes nothing. </span><span class="koboSpan" id="kobo.778.3">The conditional expression in the return type uses this template parameter (never mind that the part of the expression that depends on the parameter can never fail). </span><span class="koboSpan" id="kobo.778.4">Therefore, we are now within the </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">SFINAE rules.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">Now that we have a way to disable a member function selectively, we can revisit the conditionally enabled constructors to see how we can enable and disable constructors </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">In C++20, the </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.783.1">answer is “exactly the same way.” </span><span class="koboSpan" id="kobo.783.2">We need a policy with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">constexpr</span></strong><span class="koboSpan" id="kobo.785.1"> Boolean value and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">restrict</span></strong><span class="koboSpan" id="kobo.787.1"> constraint to disable </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">any constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.789.1">
// Example 21
struct MoveForbidden {
  static constexpr bool enabled = false;
};
struct MoveAllowed {
  static constexpr bool enabled = true;
};</span></pre>
<p><span class="koboSpan" id="kobo.790.1">We can use this policy to constrain any member function, </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">constructors included:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.792.1">
// Example 21
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  SmartPtr(SmartPtr&amp;&amp; other)
    requires MovePolicy::enabled :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
</span><span class="koboSpan" id="kobo.792.2">};</span></pre>
<p><span class="koboSpan" id="kobo.793.1">Prior to C++20, we have to use SFINAE. </span><span class="koboSpan" id="kobo.793.2">The one complication here is that the constructors have no return type and we have to hide the SFINAE test somewhere else. </span><span class="koboSpan" id="kobo.793.3">In addition, we again have to make the constructor a template. </span><span class="koboSpan" id="kobo.793.4">We can use a dummy template</span><a id="_idIndexMarker874"/> <span class="No-Break"><span class="koboSpan" id="kobo.794.1">parameter again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
// Example 22
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  template &lt;typename U = T,
    std::enable_if_t&lt;sizeof(U) != 0 &amp;&amp; MovePolicy::enabled,
                     bool&gt; = true&gt;
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
</span><span class="koboSpan" id="kobo.795.2">};</span></pre>
<p><span class="koboSpan" id="kobo.796.1">If you use the concept utilities from </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.797.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.798.1">, SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.799.1">, the code is going to look simpler and more straightforward, although a dummy template parameter is </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">still needed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
// Example 22
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  template &lt;typename U = T,
    REQUIRES(sizeof(U) != 0 &amp;&amp; MovePolicy::enabled)&gt;
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
</span><span class="koboSpan" id="kobo.801.2">};</span></pre>
<p><span class="koboSpan" id="kobo.802.1">Now that we have a fully general way to enable or disable specific member functions that work for constructors as well, the reader may be wondering, what was the point of introducing the earlier way? </span><span class="koboSpan" id="kobo.802.2">Firstly, for simplicity - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">enable_if</span></strong><span class="koboSpan" id="kobo.804.1"> expression has to be used in the right context, and the compiler errors that are generated if anything is even slightly wrong are not pretty. </span><span class="koboSpan" id="kobo.804.2">On the other hand, the notion that a non-copyable base class makes the entire derived class non-copyable is very basic and works every time. </span><span class="koboSpan" id="kobo.804.3">This technique can even be used in C++03, where SFINAE is much more limited and even harder to get to </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">work correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">Also, we have already seen that sometimes policies need to add member variables to the class instead of (or in addition to) member functions. </span><span class="koboSpan" id="kobo.806.2">Our reference-counting pointer is a perfect example: if one of the policies provides reference counting, it must also contain the count. </span><span class="koboSpan" id="kobo.806.3">Member variables cannot be restricted with constraints, so they have to come from the base </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">policy class.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Yet another reason to at least know the way to inject public member functions through policies is that sometimes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">enable_if</span></strong><span class="koboSpan" id="kobo.810.1"> alternative requires that the entire set of possible functions be declared in the primary class template, and then some can be selectively disabled. </span><span class="koboSpan" id="kobo.810.2">Sometimes, that set of functions is self-contradicting and cannot be present all at once. </span><span class="koboSpan" id="kobo.810.3">An example is a set of conversion operators. </span><span class="koboSpan" id="kobo.810.4">Right now, our smart pointer cannot be converted back into a raw pointer. </span><span class="koboSpan" id="kobo.810.5">We could enable such conversions and require them to be explicit, or allow </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">implicit conversions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.812.1">
void f(C*);
SmartPtr&lt;C&gt; p(...);
f((C*)(p));     // Explicit conversion
f(p);         // Implicit conversion</span></pre>
<p><span class="koboSpan" id="kobo.813.1">The conversion</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.814.1"> operators are defined </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
template &lt;typename T, ...&gt;
class SmartPtr ... </span><span class="koboSpan" id="kobo.816.2">{
  T* p_;
  public:
  explicit operator T*() { return p_; } // Explicit
  operator T*() { return p_; }          // Implicit
  ...
</span><span class="koboSpan" id="kobo.816.3">};</span></pre>
<p><span class="koboSpan" id="kobo.817.1">We already decided that we do not want these operators to be unconditionally present; instead, we want them controlled by a raw conversion policy. </span><span class="koboSpan" id="kobo.817.2">Let us start with the same approach we used the last time for a policy that enables a </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
// Example 23
struct NoRaw {
  static constexpr bool implicit_conv = false;
  static constexpr bool explicit_conv = false;
};
struct ExplicitRaw {
  static constexpr bool implicit_conv = false;
  static constexpr bool explicit_conv = true;
};
struct ImplicitRaw {
  static constexpr bool implicit_conv = true;
  static constexpr bool explicit_conv = false;
};</span></pre>
<p><span class="koboSpan" id="kobo.820.1">Again, we will write C++20 code first, where we can restrict both the explicit and the implicit </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.821.1">operators </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">using constraints:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
// Example 23
template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.823.2">{
  T* p_;
  public:
  explicit operator T*()
    requires ConversionPolicy::explicit_conv
    { return p_; }
  operator T*()
    requires ConversionPolicy::implicit_conv
    { return p_; }
  explicit operator const T*()
    requires ConversionPolicy::explicit_conv const
    { return p_; }
  operator const T*()
    requires ConversionPolicy::implicit_conv const
    { return p_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.824.1">For completeness, we also provided conversions to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">const</span></strong><span class="koboSpan" id="kobo.826.1"> raw pointer. </span><span class="koboSpan" id="kobo.826.2">Note that in C++20, there is a simpler way to</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.827.1"> provide these operators using the conditional explicit specifier (another </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">C++20 feature):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.829.1">
// Example 24
template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.829.2">{
  T* p_;
  public:
  explicit (ConversionPolicy::explicit_conv)
  operator T*()
    requires (ConversionPolicy::explicit_conv ||
              ConversionPolicy::implicit_conv)
    { return p_; }
  explicit (ConversionPolicy::explicit_conv)
  operator const T*()
    requires (ConversionPolicy::explicit_conv const ||
              ConversionPolicy::implicit_conv const)
    { return p_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.830.1">Prior to C++20, we can attempt to enable one of these operators using </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">std::enable_if</span></strong><span class="koboSpan" id="kobo.832.1"> and SFINAE, again based on a conversion policy. </span><span class="koboSpan" id="kobo.832.2">The problem is, we cannot declare both implicit and explicit conversion to the same type, even if one is later disabled. </span><span class="koboSpan" id="kobo.832.3">These operators cannot be in the same overload set to </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">begin with:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
// Example 25 – does not compile!
</span><span class="koboSpan" id="kobo.834.2">template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.834.3">{
  T* p_;
  public:
  template &lt;typename U = T,
            REQUIRES(ConversionPolicy::explicit_conv)&gt;
  explicit operator T*() { return p_; }
  template &lt;typename U = T,
            REQUIRES(ConversionPolicy::implicit_conv)&gt;
  operator T*() { return p_; }
  ...
</span><span class="koboSpan" id="kobo.834.4">};</span></pre>
<p><span class="koboSpan" id="kobo.835.1">If we want to have the option to select one of these operators in our smart pointer class, we have to have them generated by the base class policy. </span><span class="koboSpan" id="kobo.835.2">Since the policy needs to be aware </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.836.1">of the smart pointer type, we have to use the CRTP again. </span><span class="koboSpan" id="kobo.836.2">Here is a set of policies to control the conversion from smart pointers to </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">raw pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
// Example 26
template &lt;typename P, typename T&gt; struct NoRaw {
};
template &lt;typename P, typename T&gt; struct ExplicitRaw {
  explicit operator T*() {
    return static_cast&lt;P*&gt;(this)-&gt;p_;
  }
  explicit operator const T*() const {
    return static_cast&lt;const P*&gt;(this)-&gt;p_;
  }
};
template &lt;typename P, typename T&gt; struct ImplicitRaw {
  operator T*() {
    return static_cast&lt;P*&gt;(this)-&gt;p_;
  }
  operator const T*() const {
    return static_cast&lt;const P*&gt;(this)-&gt;p_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.839.1">These policies add the desired public member function operators to the derived class. </span><span class="koboSpan" id="kobo.839.2">Since they are templates that need to be instantiated with the derived class type, the conversion </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.840.1">policy is a template template parameter, and its use follows </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">the CRTP:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.842.1">
// Example 26
template &lt;typename T, ... </span><span class="koboSpan" id="kobo.842.2">other policies ...
</span><span class="koboSpan" id="kobo.842.3">          template &lt;typename, typename&gt;
          class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.842.4">other base policies ...,
  public ConversionPolicy&lt;SmartPtr&lt;... </span><span class="koboSpan" id="kobo.842.5">paramerers ...&gt;, T&gt;
{
  T* p_;
  template&lt;typename, typename&gt;
  friend class ConversionPolicy;
  public:
  ...
</span><span class="koboSpan" id="kobo.842.6">};</span></pre>
<p><span class="koboSpan" id="kobo.843.1">Once again, note the use of the template template parameter: the template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">ConversionPolicy</span></strong><span class="koboSpan" id="kobo.845.1"> is not a type but a template. </span><span class="koboSpan" id="kobo.845.2">When inheriting from an instantiation of this policy, we have to write the complete type of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">SmartPtr</span></strong><span class="koboSpan" id="kobo.847.1"> class, with all its template arguments. </span><span class="koboSpan" id="kobo.847.2">We made the conversion policy a template of two arguments (the second one is the object type </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">T</span></strong><span class="koboSpan" id="kobo.849.1">). </span><span class="koboSpan" id="kobo.849.2">We could also deduce the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">T</span></strong><span class="koboSpan" id="kobo.851.1"> from the first template parameter (the smart pointer type), it’s largely a matter </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">of style.</span></span></p>
<p><span class="koboSpan" id="kobo.853.1">The selected conversion policy adds its public interface, if any, to that of the derived class. </span><span class="koboSpan" id="kobo.853.2">One policy adds a set of explicit conversion operators, while the other one provides implicit conversions. </span><span class="koboSpan" id="kobo.853.3">Just like in the earlier CRTP example, the base class needs access to the private data members of the derived class. </span><span class="koboSpan" id="kobo.853.4">We can either grant friendship to the entire template (and every instantiation of it) or, more verbosely, to the specific instantiation used as the base class for each </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">smart pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
friend class ConversionPolicy&lt;
  SmartPtr&lt;T, ... </span><span class="koboSpan" id="kobo.855.2">parameters ..., ConversionPolicy&gt;, T&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.856.1">We have learned several different ways to implement new policies. </span><span class="koboSpan" id="kobo.856.2">Sometimes, the challenge comes in reusing the on</span><a id="_idTextAnchor718"/><a id="_idTextAnchor719"/><span class="koboSpan" id="kobo.857.1">es we already have. </span><span class="koboSpan" id="kobo.857.2">The next section shows one way to </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">do it.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor720"/><span class="koboSpan" id="kobo.859.1">Rebinding policies</span></h2>
<p><span class="koboSpan" id="kobo.860.1">As we have already seen, the policy lists can get quite long. </span><span class="koboSpan" id="kobo.860.2">Often, we want to change just one policy and create a class </span><em class="italic"><span class="koboSpan" id="kobo.861.1">just like that other one, but with a small change.</span></em><span class="koboSpan" id="kobo.862.1"> There are at least two ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">The first way is very general but somewhat verbose. </span><span class="koboSpan" id="kobo.864.2">The first step is to expose the template parameters as aliases, inside the primary template. </span><span class="koboSpan" id="kobo.864.3">This is a good practice, anyway - without such aliases, it is very difficult to find out, at compile time, what a template parameter was in case we ever need to use it outside of the template. </span><span class="koboSpan" id="kobo.864.4">For example, we have a smart pointer, and we want to know what the deletion policy was. </span><span class="koboSpan" id="kobo.864.5">The easiest way, by far, is with some help from the smart pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">class itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename CopyMovePolicy = NoMoveNoCopy,
          template &lt;typename, typename&gt;
            class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : ... </span><span class="koboSpan" id="kobo.866.2">base policies ... </span><span class="koboSpan" id="kobo.866.3">{
  T* p_;
  public:
  using value_type = T;
  using deletion_policy_t = DeletionPolicy;
  using copy_move_policy_t = CopyMovePolicy;
  template &lt;typename P, typename T1&gt;
  using conversion_policy_t = ConversionPolicy&lt;P, T1&gt;;
  ...
</span><span class="koboSpan" id="kobo.866.4">};</span></pre>
<p><span class="koboSpan" id="kobo.867.1">Note that we’re using two different types of aliases here - for the regular template parameters such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">DeletionPolicy</span></strong><span class="koboSpan" id="kobo.869.1">, we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">using</span></strong><span class="koboSpan" id="kobo.871.1"> alias. </span><span class="koboSpan" id="kobo.871.2">For a template template parameter, we have to use the template alias, sometimes called template </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">typedef</span></strong><span class="koboSpan" id="kobo.873.1"> - to reproduce the same policy with another smart pointer, we need to know the template itself, not the template instantiation, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">ConversionPolicy&lt;SmartPtr, T&gt;</span></strong><span class="koboSpan" id="kobo.875.1">. </span><span class="koboSpan" id="kobo.875.2">Now, if we need to create another smart pointer with some </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.876.1">of the same policies, we can simply query the policies of the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">original object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
// Example 27
SmartPtr&lt;int,
  DeleteByOperator&lt;int&gt;, MoveNoCopy, ImplicitRaw&gt;
  p1(new int(42));
using ptr_t = decltype(p1); // The exact type of p1
SmartPtr&lt;ptr_t::value_type,
  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,
  ptr_t::conversion_policy_t&gt; p2;
SmartPtr&lt;double,
  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,
  ptr_t::conversion_policy_t&gt; p3;</span></pre>
<p><span class="koboSpan" id="kobo.879.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">p2</span></strong><span class="koboSpan" id="kobo.881.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">p1</span></strong><span class="koboSpan" id="kobo.883.1"> have exactly the same type. </span><span class="koboSpan" id="kobo.883.2">There is, of course, an easier way to accomplish that. </span><span class="koboSpan" id="kobo.883.3">But the point is, we could alter any one of the types in the list and keep the rest, and get a pointer just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">p1</span></strong><span class="koboSpan" id="kobo.885.1">, </span><em class="italic"><span class="koboSpan" id="kobo.886.1">except for one change.</span></em><span class="koboSpan" id="kobo.887.1"> For example, the pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">p2</span></strong><span class="koboSpan" id="kobo.889.1"> has the same policies but points to </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">double</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">The latter turns out to be a pretty common case, and there is a way to facilitate the </span><em class="italic"><span class="koboSpan" id="kobo.894.1">rebinding</span></em><span class="koboSpan" id="kobo.895.1"> or a template to a different type while keeping the rest of the arguments intact. </span><span class="koboSpan" id="kobo.895.2">To do this, the </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.896.1">primary template and all its policies need to support </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">such rebinding:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.898.1">
// Example 27
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const { delete p; }
  template &lt;typename U&gt;
    using rebind_type = DeleteByOperator&lt;U&gt;;
};
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename CopyMovePolicy = NoMoveNoCopy,
          template &lt;typename, typename&gt;
            class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : private DeletionPolicy,
  public CopyMovePolicy,
  public ConversionPolicy&lt;SmartPtr&lt;T, DeletionPolicy,
    CopyMovePolicy, ConversionPolicy&gt;, T&gt; {
  T* p_;
  public:
  ...
</span><span class="koboSpan" id="kobo.898.2">  template &lt;typename U&gt;
  using rebind = SmartPtr&lt;U,
    typename DeletionPolicy::template rebind&lt;U&gt;,
    CopyMovePolicy, ConversionPolicy&gt;;
};</span></pre>
<p><span class="koboSpan" id="kobo.899.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">rebind</span></strong><span class="koboSpan" id="kobo.901.1"> alias defines a new template that has only one parameter - the type we can change. </span><span class="koboSpan" id="kobo.901.2">The rest of the parameters come from the primary template itself. </span><span class="koboSpan" id="kobo.901.3">Some of these parameters are types that also depend on the primary type </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">T</span></strong><span class="koboSpan" id="kobo.903.1">, and themselves need rebinding (in our example, the deletion policy). </span><span class="koboSpan" id="kobo.903.2">By choosing not to rebind the copy/move policy, we impose a requirement that none of these policies depend on the primary type, otherwise this policy, too, needs to be rebound. </span><span class="koboSpan" id="kobo.903.3">Finally, the template conversion policy does not need rebinding - we have access to the entire template here, so it will be instantiated with the new primary type. </span><span class="koboSpan" id="kobo.903.4">We can now use the rebinding mechanism to create a </span><em class="italic"><span class="koboSpan" id="kobo.904.1">similar</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.905.1">pointer type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.906.1">
SmartPtr&lt;int,
  DeleteByOperator&lt;int&gt;, MoveNoCopy, ImplicitRaw&gt;
p(new int(42));
using dptr_t = decltype(p)::rebind&lt;double&gt;;
dptr_t q(new double(4.2));</span></pre>
<p><span class="koboSpan" id="kobo.907.1">If we have direct access to the smart pointer type, we can use it for rebinding (for example, in a template context). </span><span class="koboSpan" id="kobo.907.2">Otherwise, we can get the type from a variable of this type using </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">decltype()</span></strong><span class="koboSpan" id="kobo.909.1">. </span><span class="koboSpan" id="kobo.909.2">The pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">q</span></strong><span class="koboSpan" id="kobo.911.1"> has the same policies as </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">p</span></strong><span class="koboSpan" id="kobo.913.1"> but points to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">double</span></strong><span class="koboSpan" id="kobo.915.1">, and the type-dependent policies such as the deletion policy have been </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">updated accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">We have covered the main ways in which the policies can be implemented and used to customize policy-based classes. </span><span class="koboSpan" id="kobo.917.2">It is now time to review what we have learned and stat</span><a id="_idTextAnchor721"/><a id="_idTextAnchor722"/><span class="koboSpan" id="kobo.918.1">e some general guidelines for the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">policy-based designs.</span></span></p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor723"/><span class="koboSpan" id="kobo.920.1">Recommendations and guidelines</span></h1>
<p><span class="koboSpan" id="kobo.921.1">The policy-based design allows for exceptional flexibility in the creation of finely customizable classes. </span><span class="koboSpan" id="kobo.921.2">Sometimes, this flexibility and power become the enemy of a good design. </span><span class="koboSpan" id="kobo.921.3">In this section, we will review the strengths and weaknesses of the poli</span><a id="_idTextAnchor724"/><a id="_idTextAnchor725"/><span class="koboSpan" id="kobo.922.1">cy-based design and come up with some </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">general recommendations.</span></span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor726"/><span class="koboSpan" id="kobo.924.1">Strengths of the policy-based design</span></h2>
<p><span class="koboSpan" id="kobo.925.1">The main advantages </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.926.1">of the policy-based design are flexibility and extensibility of the design. </span><span class="koboSpan" id="kobo.926.2">At a high level, these are the same benefits the Strategy pattern offers, only realized at compile-time. </span><span class="koboSpan" id="kobo.926.3">The policy-based design allows the programmer to select, at compile time, one of several algorithms for each specific task or operation performed by the system. </span><span class="koboSpan" id="kobo.926.4">Since the only constraints on the algorithms are the requirements on the interface that binds them into the rest of the system, it is equally possible to extend the system by writing new policies for the </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">customizable operations.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">At a high level, the policy-based design allows the software system to be built from components. </span><span class="koboSpan" id="kobo.928.2">At a high level, this is hardly a novel idea, certainly not limited to policy-based design. </span><span class="koboSpan" id="kobo.928.3">The focus of the policy-based design is the use of components to define behavior and the implementation of individual classes. </span><span class="koboSpan" id="kobo.928.4">There is some similarity between policies and callbacks - both allow a user-specified action to be taken when a particular event takes place. </span><span class="koboSpan" id="kobo.928.5">However, the policies are much more general than callbacks - while a callback is a function, policies are entire classes, with multiple functions and, possibly, a non-trivial </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">internal state.</span></span></p>
<p><span class="koboSpan" id="kobo.930.1">These general concepts translate into a unique set of advantages for the design, mostly centered around the ideas of flexibility and extensibility. </span><span class="koboSpan" id="kobo.930.2">With the overall structure of the system and its high-level components determined by the high-level design, the policies allow for a variety of low-level customizations within the constraints that were imposed by the original design. </span><span class="koboSpan" id="kobo.930.3">Policies can extend the class interface (add public member functions), implement or extend the state of the class (add data members), and specify implementations (add private member functions). </span><span class="koboSpan" id="kobo.930.4">The original design, in setting the overall structure of the classes and their interactions, in effect authorizes each policy to have one or more of </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">these roles.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">The result is an extensible system that can be modified to address evolving requirements, even ones that have not been anticipated or known at the time when the system was designed. </span><span class="koboSpan" id="kobo.932.2">The overall architecture remains stable, while the selection of possible policies and the constraints on their interfaces offers a</span><a id="_idTextAnchor727"/><a id="_idTextAnchor728"/><span class="koboSpan" id="kobo.933.1"> systematic, disciplined way to modify and extend </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">the software.</span></span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor729"/><span class="koboSpan" id="kobo.935.1">Disadvantages of policy-based design</span></h2>
<p><span class="koboSpan" id="kobo.936.1">The first problem </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.937.1">with the policy-based design that comes to mind is the one we have already encountered - declarations of policy-based classes with a specific set of policies are extremely verbose, especially if one of the policies at the end of the list has to be changed. </span><span class="koboSpan" id="kobo.937.2">Consider the declaration of a smart pointer with all of the policies we have implemented in this chapter, </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">put together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.939.1">
SmartPtr&lt;int, DeleteByOperator&lt;int&gt;, NoMoveNoCopy, ExplicitRaw, WithoutArrow, NoDebug&gt; p;</span></pre>
<p><span class="koboSpan" id="kobo.940.1">That’s just for a smart pointer - a class with a fairly simple interface and limited functionality. </span><span class="koboSpan" id="kobo.940.2">Even though it is unlikely that someone will need one pointer with all of these customization possibilities, the policy-based classes tend to have a lot of policies. </span><span class="koboSpan" id="kobo.940.3">This problem may be the most evident, but it is actually not the worst. </span><span class="koboSpan" id="kobo.940.4">The template aliases help to give concise names to the few policy combinations that are actually used by a particular application. </span><span class="koboSpan" id="kobo.940.5">In the template context, the types of smart pointers used as function arguments are deduced and do not need to be explicitly specified. </span><span class="koboSpan" id="kobo.940.6">In regular code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">auto</span></strong><span class="koboSpan" id="kobo.942.1"> can be used to save a lot of typing and also make the code more robust - when the complex type declarations that must be consistent are replaced with an automatic way to generate these consistent types, the errors caused by typing something slightly different in two different places disappear (in general, if there is a recipe to make the compiler generate correct-by-construction code, </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">use it).</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">The much more significant, if slightly less visible, problem is that all of these policy-based types with different policies are actually different types. </span><span class="koboSpan" id="kobo.944.2">Two smart pointers that point to the same object type but have different deletion policies are different types. </span><span class="koboSpan" id="kobo.944.3">Two smart pointers that are otherwise the same but have different copying policies are different types. </span><span class="koboSpan" id="kobo.944.4">Why is that a problem? </span><span class="koboSpan" id="kobo.944.5">Consider a function that is called to work on an object that is passed into the function using a smart pointer. </span><span class="koboSpan" id="kobo.944.6">This function does not copy the smart pointer, so it should not matter what the copying policy is - it is never used. </span><span class="koboSpan" id="kobo.944.7">And yet, what should the argument type be? </span><span class="koboSpan" id="kobo.944.8">There is no one type that can accommodate all smart pointers, even the ones with very </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">similar functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.946.1">There are several possible solutions here. </span><span class="koboSpan" id="kobo.946.2">The most straightforward one is to make all functions that use policy-based types into templates. </span><span class="koboSpan" id="kobo.946.3">This does simplify the coding, and it reduces code duplication (at least the source code duplication), but it has its own downsides - the machine code becomes larger since there are multiple copies of every function, and all template code must be in the </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">header files.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">The other option is to erase the policy types. </span><span class="koboSpan" id="kobo.948.2">We saw the type erasure technique in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.949.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.950.1">, </span><em class="italic"><span class="koboSpan" id="kobo.951.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.952.1">. </span><span class="koboSpan" id="kobo.952.2">Type erasure solves the problem of having many similar types - we could make all smart pointers, regardless of their policies, be of the same type (only to the extent that the policies determine the implementation and not the public interface, of course). </span><span class="koboSpan" id="kobo.952.3">However, this comes at a very </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">high cost.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">One of the main drawbacks of the templates in general, and the policy-based design, in particular, is that templates provide a zero-overhead abstraction - we can express our programs in terms of convenient high-level abstractions and concepts, but the compiler strips it all away, inlines all of the templates, and generates the minimum necessary code. </span><span class="koboSpan" id="kobo.954.2">Type erasure not only negates this advantage but has the opposite effect - it adds a very high overhead of memory allocations and indirect </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">function calls.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">The last option is to avoid using policy-based types, at least for some operations. </span><span class="koboSpan" id="kobo.956.2">Sometimes, this choice carries a little extra cost - for example, a function that needs to operate on an object but not delete or own it should take the object by reference instead of a smart pointer (see </span><a href="B19262_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.957.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.958.1">, </span><em class="italic"><span class="koboSpan" id="kobo.959.1">Memory and Ownership</span></em><span class="koboSpan" id="kobo.960.1">). </span><span class="koboSpan" id="kobo.960.2">In addition to clearly expressing the</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.961.1"> fact that the function is not going to own the object, this neatly solves the problem of what type the argument should be - the reference is the same type, no matter which smart pointer it came from. </span><span class="koboSpan" id="kobo.961.2">This is, however, a limited approach - more often than not, we do need to operate on the entire policy-based objects, which are usually much more complex than a simple pointer (for example, custom containers are often implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">using policies).</span></span></p>
<p><span class="koboSpan" id="kobo.963.1">The final disadvantage is the general complexity of the policy-based types, although such claims should be made with care - the important question is, complexity compared to what? </span><span class="koboSpan" id="kobo.963.2">Policy-based designs are usually invoked to solve complex design problems where a family of similar types serves the same overall purpose (</span><em class="italic"><span class="koboSpan" id="kobo.964.1">what</span></em><span class="koboSpan" id="kobo.965.1">), but does so in slightly different ways (</span><em class="italic"><span class="koboSpan" id="kobo.966.1">h</span><a id="_idTextAnchor730"/><a id="_idTextAnchor731"/><span class="koboSpan" id="kobo.967.1">ow)</span></em><span class="koboSpan" id="kobo.968.1">. </span><span class="koboSpan" id="kobo.968.2">This leads us to the recommendations on the use </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">of policies.</span></span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor732"/><span class="koboSpan" id="kobo.970.1">Guidelines for policy-based designs</span></h2>
<p><span class="koboSpan" id="kobo.971.1">The guidelines for </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.972.1">policy-based designs boil down to managing the complexity and making sure the ends justify the means - the flexibility of the design and the elegance of the resulting solutions should justify the complexity of the implementation and </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">its use.</span></span></p>
<p><span class="koboSpan" id="kobo.974.1">Since most of the complexity comes from the increasing number of policies, this is the focus of most of the guidelines. </span><span class="koboSpan" id="kobo.974.2">Some policies end up putting together very different types that happen to have a similar implementation. </span><span class="koboSpan" id="kobo.974.3">The goal of such a policy-based type is to reduce code duplication. </span><span class="koboSpan" id="kobo.974.4">While a worthwhile objective, this is generally not a good enough reason to expose a multitude of disparate policy options to the end user of the type. </span><span class="koboSpan" id="kobo.974.5">If two different types or type families happen to have similar implementations, that implementation can be factored out. </span><span class="koboSpan" id="kobo.974.6">The private, hidden, implementation-only part of the design can itself use policies if it makes the </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">implementation easier.</span></span></p>
<p><span class="koboSpan" id="kobo.976.1">However, these hidden policies should not be selected by the client - the client should specify the types that make sense in the application and the policies that customize the visible behavior. </span><span class="koboSpan" id="kobo.976.2">From these types and policies, the implementation can derive additional types as needed. </span><span class="koboSpan" id="kobo.976.3">This is no different than calling a common function to, say, find the minimum element in a sequence from several different unrelated algorithms that all happen to need that operation. </span><span class="koboSpan" id="kobo.976.4">The common code is not duplicated, but neither is it exposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">So, when should a policy-based type be broken up into two or more pieces? </span><span class="koboSpan" id="kobo.978.2">A good way to look at it is to ask whether the primary type, with a particular set of policies, has a good specific name that describes it. </span><span class="koboSpan" id="kobo.978.3">For example, a non-copyable owning pointer, movable or not, is a </span><em class="italic"><span class="koboSpan" id="kobo.979.1">unique pointer - </span></em><span class="koboSpan" id="kobo.980.1">there is only one such pointer for each object at any given time. </span><span class="koboSpan" id="kobo.980.2">This is true for any deletion or </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">conversion policy.</span></span></p>
<p><span class="koboSpan" id="kobo.982.1">On the other hand, a reference-counted pointer is a </span><em class="italic"><span class="koboSpan" id="kobo.983.1">shared pointer,</span></em><span class="koboSpan" id="kobo.984.1"> again, with any choice of other policies. </span><span class="koboSpan" id="kobo.984.2">This suggests that our one smart pointer to end all smart pointers would be, perhaps, better split into two - a non-copyable unique pointer and a copyable shared pointer. </span><span class="koboSpan" id="kobo.984.3">We still get some code reuse because the deletion policy, for example, is common to both pointer types, and does not have to be implemented twice. </span><span class="koboSpan" id="kobo.984.4">This is, indeed, the choice the C++ standard makes. </span><span class="koboSpan" id="kobo.984.5">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.986.1"> has only one policy, the deletion policy. </span><span class="koboSpan" id="kobo.986.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.988.1"> also has the same policy and can use the same policy objects, but it is type-erased, so all shared pointers to a particular object are of </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">one type.</span></span></p>
<p><span class="koboSpan" id="kobo.990.1">But what about other policies? </span><span class="koboSpan" id="kobo.990.2">Here, we come to the second guideline - the policies that restrict the use of the class should be justified by the cost of possible errors that are caused by the incorrect use they are trying to prevent. </span><span class="koboSpan" id="kobo.990.3">For example, do we really need a non-movable policy? </span><span class="koboSpan" id="kobo.990.4">On the one hand, it could prevent a programming error if the ownership of the object absolutely must not be transferred. </span><span class="koboSpan" id="kobo.990.5">On the other hand, in many cases, the programmer will simply change the code to use a movable pointer. </span><span class="koboSpan" id="kobo.990.6">Also, we are forced to use movable pointers to return them by value from factory functions. </span><span class="koboSpan" id="kobo.990.7">However, a non-copyable policy is often justified and should be the default. </span><span class="koboSpan" id="kobo.990.8">For example, there are good reasons to make most containers non-copyable by default: copying a large collection of data is almost always the result of sloppy coding, usually when passing arguments </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">to functions.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">Similarly, while it is probably desirable to prevent implicit casting to the raw pointer as a matter of basic coding discipline, there is always a way to convert the smart pointer to the raw one explicitly - if nothing else, </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">&amp;*p</span></strong><span class="koboSpan" id="kobo.994.1"> should always work. </span><span class="koboSpan" id="kobo.994.2">Again, the benefits of the carefully restricted interface probably do not justify adding this policy. </span><span class="koboSpan" id="kobo.994.3">However, it makes a great compact learning example for a set of techniques that can be used to create more complex and more useful policies, and so the time we spent learning how this policy works is </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">entirely justified.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">When a policy affecting the public interface is justified, we have to make a choice between a constraint-based policy that restricts the existing member functions and a CRTP-based policy that adds them. </span><span class="koboSpan" id="kobo.996.2">As a rule, a design that relies on constraints is preferable, even prior to C++20 where we have to use the “pseudo-concepts.” </span><span class="koboSpan" id="kobo.996.3">However, this approach cannot be used to add member variables to the class, only </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">member functions.</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">Another way to look at the question of what the right set of policies is and what policies should be broken up into separate groups is to go back to the fundamental strength of the policy-based design - the composability of the behavior expressed by different policies. </span><span class="koboSpan" id="kobo.998.2">If we have a class with four different policies, each of which can have four different implementations, that is 256 different versions of the class. </span><span class="koboSpan" id="kobo.998.3">It is, of course, unlikely that we will need all 256. </span><span class="koboSpan" id="kobo.998.4">But the point is, at the time when we implement the class, we do not know which of these versions we will actually need later. </span><span class="koboSpan" id="kobo.998.5">We could make a guess and implement only a few most likely ones. </span><span class="koboSpan" id="kobo.998.6">If we are wrong, this will result in much code duplication and copy-pasting. </span><span class="koboSpan" id="kobo.998.7">With the policy-based design, we have the potential to implement any combination of the behavior, without actually having to write them all explicitly </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">up front.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">Now that we understand this strength of policy-based designs, we can use it to evaluate a particular set of policies - do they need to be composable? </span><span class="koboSpan" id="kobo.1000.2">Would we ever need to combine them in different ways? </span><span class="koboSpan" id="kobo.1000.3">If some policies always come in certain combinations or groups, this calls for automatically deducing these policies from one primary user-specified policy. </span><span class="koboSpan" id="kobo.1000.4">On the other hand, a set of largely independent policies that can be combined arbitrarily is probably a good set </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">of policies.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">Another way to address some of the weaknesses of policy-based design is to try and accomplish the same goal by different means. </span><span class="koboSpan" id="kobo.1002.2">There is no substitute for the entirety of the capabilities offered by the policies - the Strategy pattern is there for a reason. </span><span class="koboSpan" id="kobo.1002.3">However, there are alternative patterns that offer somewhat superficial similarities and may be used to solve some of the same problems as the policy-based design addresses. </span><span class="koboSpan" id="kobo.1002.4">We will see one such alternative in </span><a href="B19262_16.xhtml#_idTextAnchor739"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1003.1">Chapter 16</span></em></span></a><span class="koboSpan" id="kobo.1004.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1005.1">Adapters and Decorators</span></em><span class="koboSpan" id="kobo.1006.1"> when we talk about decorators. </span><span class="koboSpan" id="kobo.1006.2">It </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.1007.1">is not as general, but when it works, it can provide all the advantages of the policie</span><a id="_idTextAnchor733"/><a id="_idTextAnchor734"/><span class="koboSpan" id="kobo.1008.1">s, in particular, the composability, without some of </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">the problems.</span></span></p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor735"/><span class="koboSpan" id="kobo.1010.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1011.1">In this chapter, we have studied, extensively, the applications of the Strategy pattern (also known as the policy pattern) to C++ generic programming. </span><span class="koboSpan" id="kobo.1011.2">The combination of the two gives rise to one of the most powerful tools in the arsenal of a C++ programmer - the policy-based design of classes. </span><span class="koboSpan" id="kobo.1011.3">This approach provides great flexibility by allowing us to compose the behavior of the class from many building blocks, or policies, each of which is responsible for a particular aspect of </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">the behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">We have learned different ways to implement policies - these can be templates, classes with template member functions, classes with static functions, and even classes with constant values. </span><span class="koboSpan" id="kobo.1013.2">Just as varied are the ways that we can use policies through composition, inheritance, or direct access to static members. </span><span class="koboSpan" id="kobo.1013.3">Policy parameters can be types or templates, each with its own advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">and limitations.</span></span></p>
<p><span class="koboSpan" id="kobo.1015.1">A tool as powerful as the policy-based design is also easily misused or applied in poor judgment. </span><span class="koboSpan" id="kobo.1015.2">Often, such situations arise from the gradual evolution of the software toward more and more complexity. </span><span class="koboSpan" id="kobo.1015.3">To mitigate such mischance, we have provided a set of guidelines and recommendations that focus on the key advantages that the policy-based design offers to the programmer and suggested the techniques and constraints that maximize </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">such advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">In the next chapter, we will consider a more limited design pattern that can sometimes be used to mimic the policy-based approach, without some of its drawbacks. </span><span class="koboSpan" id="kobo.1017.2">This chapter is dedicated to the Decorator pattern and the more general Adapter pattern. </span><span class="koboSpan" id="kobo.1017.3">Both are sort of C</span><a id="_idTextAnchor736"/><a id="_idTextAnchor737"/><span class="koboSpan" id="kobo.1018.1">++ magic tricks - they make an object appear as something </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">it’s not.</span></span></p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor738"/><span class="koboSpan" id="kobo.1020.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1021.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">Strategy pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1023.1">How is the Strategy pattern implemented at compile time using C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">generic programming?</span></span></li>
<li><span class="koboSpan" id="kobo.1025.1">What types can be used </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">as policies?</span></span></li>
<li><span class="koboSpan" id="kobo.1027.1">How can policies be integrated into the </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">primary template?</span></span></li>
<li><span class="koboSpan" id="kobo.1029.1">Should I use policies with public member functions or policies with </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">constraint variables?</span></span></li>
<li><span class="koboSpan" id="kobo.1031.1">What are the main drawbacks of </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">policy-based design?</span></span></li>
</ol>
</div>
</body></html>