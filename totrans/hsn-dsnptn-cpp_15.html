<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-264"><a id="_idTextAnchor689"/>15</h1>
<h1 id="_idParaDest-265"><a id="_idTextAnchor690"/>Policy-Based Design</h1>
<p>Policy-based design is one of the most well-known C++ patterns. Since the introduction of the standard template library in 1998, few new ideas have been more influential on the way we design C++ programs than the invention of policy-based design.</p>
<p>A policy-based design is all about flexibility, extensibility, and customization. It is a way to design software that can evolve and can be adapted to the changing needs, some of which could not even be anticipated at the time when the initial design was conceived. A well-designed policy-based system can remain unchanged at the structural level for many years, and serve the changing needs and new requirements without compromise.</p>
<p>Unfortunately, it is also a way to build software that could do all of those things if only there was someone who could figure out how it works. The aim of this chapter is to teach you to design and understand the systems of the former kind while avoiding the excesses that lead to the disasters of the latter one.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Strategy pattern and policy-based design</li>
<li>Compile time policies in C++</li>
<li>Implementations of policy-based classes</li>
<li>Guidelines for the use of policies<a id="_idTextAnchor691"/></li>
</ul>
<h1 id="_idParaDest-266"><a id="_idTextAnchor692"/>Technical requirements</h1>
<p>The example code for this chapter can be found at the following GitHub link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter15</a>.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor693"/>Strategy pattern and policy-based design</h1>
<p>The<a id="_idIndexMarker819"/> classic Strategy <a id="_idIndexMarker820"/>pattern is a behavioral design pattern that enables the runtime selection of a specific algorithm for a particular behavior, usually from a predefined family of algorithms. This pattern is also known as the <em class="italic">policy pattern</em>; the name predates its application to generic programming in C++. The aim of the Strategy pattern is to allow for more flexibility in the design.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the classic object-oriented Strategy pattern, the decision about which specific algorithm to use is deferred until runtime.</p>
<p>As is the case with many classic patterns, the generic programming in C++ applies the same approach to algorithm selection at compile time - it allows for compile-time customization of specific aspects of the system behavior by selecting from a family of related, compatible algorithms. We will now learn the basics of implementing classes with policies in C++, then proceed to study more complex and varied approaches to policy-based design<a id="_idTextAnchor694"/><a id="_idTextAnchor695"/>.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor696"/>Foundations of policy-based design</h2>
<p>The Strategy <a id="_idIndexMarker821"/>pattern should be considered whenever we design a system that does certain operations, but the exact implementation of these operations is uncertain, varied, or can change after the system is implemented - in other words, when we know the answer to <em class="italic">what the system must do</em>, but not <em class="italic">how</em>. Similarly, the compile-time strategy (or a policy) is a way to implement a class that has a specific function (<em class="italic">what</em>), but there is more than one way to implement that function (<em class="italic">how</em>).</p>
<p>Throughout this chapter, we will design a smart pointer class to illustrate different ways to use policies. A smart pointer has many other required and optional features besides policies, and we will not cover all of them - for a complete implementation of a smart pointer, you will be referred to such examples as the C++ standard smart pointers (<code>unique_ptr</code> and <code>shared_ptr</code>), Boost smart pointers, or the Loki smart pointer (<a href="http://loki-lib.sourceforge.net/">http://loki-lib.sourceforge.net/</a>). The material presented in this chapter will help you to understand the choices made by the implementers of these libraries, as well as how to design their own policy-based classes.</p>
<p>A very minimal initial <a id="_idIndexMarker822"/>implementation of a smart pointer may look like this:</p>
<pre class="source-code">
// Example 01
template &lt;typename T&gt;
  T* p_;
  class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr) : p_(p) {}
  ~SmartPtr() {
    delete p_;
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  SmartPtr(const SmartPtr&amp;) = delete;
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
  SmartPtr(SmartPtr&amp;&amp; that) :
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    delete p_;
    p_ = std::exchange(that.p_, nullptr);
  }
};</pre>
<p>This pointer has a constructor from the raw pointer of the same type and the usual (for a pointer) operators, that is, <code>*</code> and <code>-&gt;</code>. The most interesting part here is the destructor - when the pointer is destroyed, it automatically deletes the object as well (it is not necessary to check the pointer for the <code>null</code> value before deleting it; the <code>operator delete</code> is required to accept a null pointer and do nothing). It follows, therefore, that the expected use of this smart pointer is as follows:</p>
<pre class="source-code">
// Example 01
Class C { ... };
{
  SmartPtr&lt;C&gt; p(new C);
  ... use p ...
} // Object *p is deleted automatically</pre>
<p>This is a basic example<a id="_idIndexMarker823"/> of the RAII class. The RAII object - the smart pointer, in our case - owns the resource (the constructed object) and releases (deletes) it <a id="_idIndexMarker824"/>when the owning object itself is deleted. The common applications, which were considered in detail in <a href="B19262_05.xhtml#_idTextAnchor199"><em class="italic">Chapter 5</em></a>, <em class="italic">A Comprehensive Look at RAII</em>, focus on ensuring that the object that was constructed in the scope is deleted when the program exits this scope, no matter how the latter is accomplished (for example, if an exception is thrown somewhere in the middle of the code, the RAII destructor guarantees that the object is destroyed).</p>
<p>Two more member functions of the smart pointer are noted, not for their implementation, but for their absence - the pointer is made non-copyable as both its copy constructor and the assignment operator are disabled. This detail, which is sometimes overlooked, is of crucial importance for any RAII class - since the destructor of the pointer deletes the owned object, there should never be two smart pointers that point to, and will attempt to delete, the same object. On the other hand, moving the pointer is a valid operation: it transfers the ownership from the old pointer to the new one. Move constructor is necessary for factory functions to work (at least prior to C++17).</p>
<p>The pointer we have here is functional, but the implementation is constraining. In particular, it can own and delete only an object that was constructed with the standard <code>operator new</code>, and only a single object. While it could capture a pointer that was obtained from a custom <code>operator new</code> or a pointer to an array of elements, it does not properly delete such objects.</p>
<p>We could implement a different smart pointer for objects that are created on a user-defined heap, and another one for objects that are created in client-managed memory, and so on, one for every type of object construction with its corresponding way of deletion. Most of the code for these pointers would be duplicated - they are all pointers, and the entire pointer-like API will have to be copied into every class. We can observe that all of these different classes are, fundamentally, of the same kind - the answer to the question <em class="italic">what is this type?</em> is always the same - <em class="italic">it’s a </em><em class="italic">smart pointer</em>.</p>
<p>The only difference is in how the deletion is implemented. This common intent with a difference in one particular aspect of the behavior suggests the use of the Strategy pattern. We can implement a more general smart pointer where the details of how to handle the deletion of the <a id="_idIndexMarker825"/>object are delegated to one of any number of deletion policies:</p>
<pre class="source-code">
// Example 02
template &lt;typename T, typename DeletionPolicy&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  public:
  explicit SmartPtr(
    T* p = nullptr,
    const DeletionPolicy&amp; del_policy = DeletionPolicy()) :
    p_(p), deletion_policy_(del_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  SmartPtr(const SmartPtr&amp;) = delete;
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
  SmartPtr(SmartPtr&amp;&amp; that) :
    p_(std::exchange(that.p_, nullptr)),
    deletion_policy_(std::move(deletion_policy_))
 {}
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    deletion_policy_(p_);
    p_ = std::exchange(that.p_, nullptr);
    deletion_policy_ = std::move(deletion_policy_);
  }
};</pre>
<p>The deletion policy is an additional template parameter, and an object of the type of the deletion policy is passed to the constructor of the smart pointer (by default, such an object is default-constructed). The deletion policy object is stored in the smart pointer and is used in its <a id="_idIndexMarker826"/>destructor to delete the object that’s being pointed to by the pointer.</p>
<p>Care must be taken when implementing copy and move constructors for such policy-based classes: it is very easy to forget that the policy also needs to be moved or copied to the new object. In our case, copying is disabled, but move operations are supported. They must move not just the pointer itself but also the policy object. We do this as we would any other class: by moving the object (moving pointers is more involved since they are built-in types, but all classes are assumed to handle their own move operations correctly or delete them). In the assignment operator, remember that the current object owned by the pointer must be deleted by the corresponding, i.e. old, policy; only then do we move the policy from the right-hand side of the assignment.</p>
<p>The only requirement on the deletion policy type is that it should be callable - the policy is invoked, just like a function with one argument, and the pointer to the object that must be deleted. For example, the behavior of our original pointer that called <code>operator delete</code> on the object can be replicated with the following deletion policy:</p>
<pre class="source-code">
// Example 02
template &lt;typename T&gt;
struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};</pre>
<p>To use this policy, we must specify its type when constructing the smart pointer, and, optionally, pass an object of this type to the constructor, although in this case, the default constructed object will work fine:</p>
<pre class="source-code">
class C { ... };
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;&gt; p(new C(42));</pre>
<p>In C++17, the <strong class="bold">constructor template argument deduction (CTAD)</strong> can usually deduce the<a id="_idIndexMarker827"/> template parameters:</p>
<pre class="source-code">
class C { ... };
SmartPtr p(new C(42));</pre>
<p>If the deletion policy does not match the object type, a syntax error will be reported for the invalid call to <code>operator()</code>. This is usually undesirable: the error message is not particularly <a id="_idIndexMarker828"/>friendly, and, in general, the requirements on the policy have to be inferred from the use of the policy throughout the template (our policy has only one requirement, but this is our first and simplest policy). A good practice for writing classes with policies is to verify and document all requirements on the policy explicitly and in one place. In C++20, this can be done with concepts:</p>
<pre class="source-code">
// Example 03
template &lt;typename T, typename F&gt; concept Callable1 =
  requires(F f, T* p) { { f(p) } -&gt; std::same_as&lt;void&gt;; };
template &lt;typename T, typename DeletionPolicy&gt;
requires Callable1&lt;T, DeletionPolicy&gt;
class SmartPtr {
  ...
};</pre>
<p>Before C++20, we can accomplish the same result with compile-time asserts:</p>
<pre class="source-code">
// Example 04
template &lt;typename T, typename DeletionPolicy&gt;
requires Callable1&lt;T, DeletionPolicy&gt;
class SmartPtr {
  ...
  static_assert(std::is_same&lt;
    void, decltype(deletion_policy_(p_))&gt;::value, "");
};</pre>
<p>Even in C++20, you may prefer the assert error messages. Both options accomplish the same goal: they verify that the policies meet all requirements and also express these requirements in a readable way and in one place in the code. It is up to you whether to include “movable” in these requirements: strictly speaking, the policy needs to be movable only if<a id="_idIndexMarker829"/> you need to move the smart pointer itself. It is reasonable to allow non-movable policies and require move operations only if they are needed.</p>
<p>Other deletion policies are needed for objects that were allocated in different ways. For example, if an object is created on a user-given heap object whose interface includes the member functions <code>allocate()</code> and <code>deallocate()</code> to, respectively, allocate and free memory, we can use the following heap deletion policy:</p>
<pre class="source-code">
// Example 02
template &lt;typename T&gt; struct DeleteHeap {
  explicit DeleteHeap(Heap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</pre>
<p>On the other hand, if an object is constructed in some memory that is managed separately by the caller, then only the destructor of the object needs to be called:</p>
<pre class="source-code">
// Example 02
template &lt;typename T&gt; struct DeleteDestructorOnly {
  void operator()(T* p) const {
    p-&gt;~T();
  }
};</pre>
<p>We mentioned earlier that, because the policy is used as a callable entity, <code>deletion_policy_(p_)</code>, it can be of any type that can be called like a function. That includes the actual function:</p>
<pre class="source-code">
// Example 02
using delete_int_t = void (*)(int*);
void delete_int(int* p) { delete p; }
SmartPtr&lt;int, delete_int_t&gt; p(new int(42), delete_int);</pre>
<p>A template instantiation is also a function and can be used in the same way:</p>
<pre class="source-code">
template &lt;typename T&gt; void delete_T(T* p) { delete p; }
SmartPtr&lt;int, delete_int_t&gt; p(new int(42), delete_T&lt;int&gt;);</pre>
<p>Of all the possible deletion policies, one is often the most commonly used. In most programs, it will likely be deletion by the default <code>operator delete</code> function. If this is so, it makes sense to avoid specifying this one policy every time it’s used and make it the default:</p>
<pre class="source-code">
// Example 02
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  ...
};</pre>
<p>Now, our policy-based smart pointer can be used in exactly the same way as the original version, with only one deletion option:</p>
<pre class="source-code">
SmartPtr&lt;C&gt; p(new C(42));</pre>
<p>Here, the second template parameter is left to its default value, <code>DeleteByOperator&lt;C&gt;</code>, and a default constructed object of this type is passed to the constructor as the default second argument.</p>
<p>At this point, I must caution you against a subtle mistake that could be made when implementing such policy-based classes. Note that the policy object is captured in the constructor of the smart pointer by a <code>const</code> reference:</p>
<pre class="source-code">
explicit SmartPtr(T* p = nullptr,
  const DeletionPolicy&amp; del_policy = DeletionPolicy());</pre>
<p>The <code>const</code> reference<a id="_idIndexMarker830"/> here is important since a non-const reference cannot be bound to a temporary object (we will consider the r-value references later in this section). However, the policy is stored in the object itself by value, and, thus, a copy of the policy object must be made:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  ...
};</pre>
<p>It may be tempting to avoid the copy and capture the policy by reference in the smart pointer as well:</p>
<pre class="source-code">
// Example 05
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  const DeletionPolicy&amp; deletion_policy_;
  ...
};</pre>
<p>In some cases, this will even work, for example:</p>
<pre class="source-code">
Heap h;
DeleteHeap&lt;C&gt; del_h(h);
SmartPtr&lt;C, DeleteHeap&lt;C&gt;&gt; p(new (&amp;heap) C, del_h);</pre>
<p>However, it won’t work for the default way to create smart pointers or any other smart pointer that is initialized with a temporary policy object:</p>
<pre class="source-code">
SmartPtr&lt;C&gt; p(new C, DeleteByOperator&lt;C&gt;());</pre>
<p>This code will <a id="_idIndexMarker831"/>compile. Unfortunately, it is incorrect - the temporary <code>DeleteByOperator&lt;C&gt;</code> object is constructed just before the <code>SmartPtr</code> constructor is called, but is destroyed at the end of the statement. The reference inside the <code>SmartPtr</code> object is left dangling. At first glance, this should not surprise anyone - of course, the temporary object does not outlive the statement in which it was created - it is deleted at the closing semicolon at the latest. A reader who is more versed in subtle language details may ask - <em class="italic">doesn’t the standard specifically extend the lifetime of a temporary bound to a constant reference?</em> Indeed, it does; for example:</p>
<pre class="source-code">
{
  const C&amp; c = C();
  ... c is not dangling! ...
} // the temporary is deleted here</pre>
<p>In this code fragment, the temporary object <code>C()</code> is not deleted at the end of the sentence, but only at the end of the lifetime of the reference to which it is bound. So, why didn’t the same trick work for our deletion policy object? The answer is, it sort of did - the temporary object that was created when the argument to the constructor was evaluated and bound to the <code>const</code> reference argument was not destroyed for the lifetime of that reference, which is the duration of the constructor call. Actually, it would not have been destroyed anyway - all temporary objects that are created during the evaluation of the function arguments are deleted at the end of the sentence containing the function call, that is, at the closing semicolon. The function, in our case, is the constructor of the object, and so the lifetime of the temporaries spans the entire call to the constructor. It does not, however, extend to the lifetime of the object - the <code>const</code> reference member of the object is not bound to the temporary object, but to the constructor parameter, which itself is a <code>const</code> reference.</p>
<p>The lifetime extension works only once - the reference bound to a temporary object extends its lifetime. Another reference that’s bound to the first one does nothing else and may be left dangling if the object is <a id="_idIndexMarker832"/>destroyed (the <strong class="bold">address sanitizer</strong> (<strong class="bold">ASAN</strong>) of GCC and CLANG helps to find such bugs). Therefore, if the policy object needs to be stored as a data member of the smart pointer, it has to be copied.</p>
<p>Usually, policy objects are small, and copying them is trivial. However, sometimes, a policy object may have a non-trivial internal state that is expensive to copy. You could also imagine a policy object that is non-copyable. In these cases, it may make sense to move the argument object into the data member object. This is easy to do if we declare an overload that is similar to a move constructor:</p>
<pre class="source-code">
// Example 06
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  public:
  explicit SmartPtr(T* p = nullptr,
      DeletionPolicy&amp;&amp; del_policy = DeletionPolicy())
    : p_(p), deletion_policy_(std::move(del_policy))
  {}
  ...
};</pre>
<p>As we said, the policy objects are usually small, so copying them is rarely an issue. If you do need both constructors, make sure that only one has default arguments, so the call to a constructor with no arguments or with no policy argument is not ambiguous.</p>
<p>We now have a smart pointer class that has been implemented once, but whose deletion implementation can be customized at compile time by specifying the deletion policy. We could even add a new deletion policy that did not exist at the time the class was designed, and it will work <a id="_idIndexMarker833"/>as long as it conforms to the same calling interface. Next, we will consider different ways to implement <a id="_idTextAnchor697"/>p<a id="_idTextAnchor698"/>olicy objects.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor699"/>Implementation of policies</h2>
<p>In the previous <a id="_idIndexMarker834"/>section, we learned how to implement the simplest policy object. The policy can be of any type as long as it conforms to the interface convention, and is stored in the class as a data member. The policy object is most commonly generated by a template; however, it could be a regular, non-template, object that’s specific to a particular pointer type, or even a function. The use of the policy was limited to a specific behavioral aspect, such as the deletion of the object owned by the smart pointer.</p>
<p>There are several ways in which such policies can be implemented and used. First of all, let’s review the declaration of a smart pointer with a deletion policy:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr { ... };</pre>
<p>Next, let’s look at how we can construct a smart pointer object:</p>
<pre class="source-code">
class C { ... };
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;&gt; p(
  new C(42), DeleteByOperator&lt;C&gt;());</pre>
<p>One disadvantage of this design jumps out at once - the type <code>C</code> is mentioned four times in the definition of the object <code>p</code> - it must be consistent in all four places, or the code will not compile. C++17 allows us to simplify the definition somewhat:</p>
<pre class="source-code">
SmartPtr p(new C, DeleteByOperator&lt;C&gt;());</pre>
<p>Here, the constructor is used to deduce the parameters of the <code>class</code> template from the constructor arguments, in a manner similar to that of function templates. There are still two mentions of the type <code>C</code> that must be consistent.</p>
<p>One alternative implementation that works for stateless policies as well as for policy objects whose internal state does not depend on the types of the primary template (in our case, the type <code>T</code> of the <code>SmartPtr</code> template) is to make the policy itself a non-template object but give it a template member function. For example, the <code>DeleteByOperator</code> policy is stateless (the object has no data members) and can be implemented without a<a id="_idIndexMarker835"/> class template:</p>
<pre class="source-code">
// Example 07
struct DeleteByOperator {
  template &lt;typename T&gt; void operator()(T* p) const {
    delete p;
  }
};</pre>
<p>This is a non-template object, so it does not need a type parameter. The member function template is instantiated on the type of object that needs to be deleted - the type is deduced by the compiler. Since the type of the policy object is always the same, we do not have to worry about specifying consistent types when creating the smart pointer object:</p>
<pre class="source-code">
// Example 07
SmartPtr&lt;C, DeleteByOperator&gt; p(
  new C, DeleteByOperator());             // Before C++17
SmartPtr p(new C, DeleteByOperator());     // C++17</pre>
<p>This object can be used by our smart pointer as it is, with no changes to the <code>SmartPtr</code> template, although we may want to change the default template argument:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&gt;
class SmartPtr { ... };</pre>
<p>A more complex policy, such as the heap deletion policy, can still be implemented using this approach:</p>
<pre class="source-code">
struct DeleteHeap {
  explicit DeleteHeap(SmallHeap&amp; heap) : heap_(heap) {}
  template &lt;typename T&gt; void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</pre>
<p>This policy has an<a id="_idIndexMarker836"/> internal state - the reference to the heap - but nothing in this policy object depends on the type <code>T</code> of the object we need to delete, except for the <code>operator()</code> member function. Therefore, the policy does not need to be parameterized by the object type.</p>
<p>Since the main template, <code>SmartPtr</code>, did not have to be changed when we converted our policies from class templates to non-template classes with template member functions, there is no reason why we cannot use both types of policies with the same class. Indeed, any of the template class policies from the previous subsection would still work, so we can have some deletion policies implemented as classes and others as class templates. The latter is useful when the policy has data members whose type depends on the object type of the smart pointer.</p>
<p>If the policies are implemented as class templates, we have to specify the correct type to instantiate the policy for use with each specific policy-based class. In many cases, this is a very repetitive process - the same type is used to parameterize the main template and its policies. We can get the compiler to do this job for us if we use the entire template and not its particular instantiation as a policy:</p>
<pre class="source-code">
// Example 08
template &lt;typename T,
          template &lt;typename&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr,
    const DeletionPolicy&lt;T&gt;&amp; del_policy =
                             DeletionPolicy&lt;T&gt;())
  : p_(p), deletion_policy_(deletion_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  ...
};</pre>
<p>Note the syntax for the<a id="_idIndexMarker837"/> second template parameter - <code>template &lt;typename&gt; class DeletionPolicy</code>. This is known as a <em class="italic">template template</em> parameter - the parameter of a template is itself a template. The <code>class</code> keyword is necessary in C++14 and earlier; in C++17, it can be replaced with <code>typename</code>. To use this parameter, we need to instantiate it with some type; in our case, it is the main template type parameter <code>T</code>. This ensures the consistency of the object type in the primary smart pointer template and its policies, although the constructor argument still must be constructed with the correct type:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteByOperator&gt; p(
  new C, DeleteByOperator&lt;C&gt;());</pre>
<p>Again, in C++17, the class template parameters can be deduced by the constructor; this works for template template parameters as well:</p>
<pre class="source-code">
SmartPtr p(new C, DeleteByOperator&lt;C&gt;());</pre>
<p>The template template parameters seem like an attractive alternative to the regular type parameters when the types are instantiated from a template anyway. Why don’t we always use them? First of all, as you can see, they are somewhat less flexible than template class parameters: they save typing in the common case when the policy is a template with the same first argument as the class itself, but they don’t work in any other case (the policy may be a non-template or a template that requires more than one argument). The other issue is that, as written, the template template parameter has one significant limitation - the number of template parameters has to match the specification precisely, including the default arguments. In other words, let’s say I have the following template:</p>
<pre class="source-code">
template &lt;typename T, typename Heap = MyHeap&gt; class DeleteHeap { ... };</pre>
<p>This template cannot be used as a parameter of the preceding smart pointer - it has two template parameters, while we only specified only one in the declaration of <code>SmartPtr</code> (a parameter with a default value is still a parameter). This limitation is easy to work around: all we have<a id="_idIndexMarker838"/> to do is define the template template parameter as a variadic template:</p>
<pre class="source-code">
// Example 09
template &lt;typename T,
          template &lt;typename...&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  ...
};</pre>
<p>Now the deletion policy template can have any number of type parameters as long as they have default values (<code>DeletionPolicy&lt;T&gt;</code> is what we use in the <code>SmartPtr</code> and it has to compile). In contrast, we can use an instantiation of the <code>DeleteHeap</code> template for a smart pointer where the <code>DeletionPolicy</code> is a type parameter, not a template template parameter - we just need a class, and <code>DeleteHeap&lt;int, MyHeap&gt;</code> will do as good as any.</p>
<p>So far, we have always captured the policy object as a data member of the policy-based class. This approach to integrating classes into a larger class is<a id="_idIndexMarker839"/> known as <strong class="bold">composition</strong>. There are other ways in which the primary template can get access to the customized behavior<a id="_idIndexMarker840"/> algorithms provided by the policies, which w<a id="_idTextAnchor700"/><a id="_idTextAnchor701"/>e will consider next.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor702"/>Use of policy objects</h2>
<p>All of our <a id="_idIndexMarker841"/>examples until now have stored the policy object as a data member of the class. This is generally the preferred way of storing the policies, but it has one significant downside - a data member always has a non-zero size. Consider our smart pointer with one of the deletion policies:</p>
<pre class="source-code">
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr {
  T* p_;
  DeletionPolicy deletion_policy_;
  ...
};</pre>
<p>Note that the policy object has no data members. However, the size of the object is not zero, but one byte (we can verify that by printing the value of <code>sizeof(DeleteByOperator&lt;int&gt;)</code>). This is necessary because every object in a C++ program must have a unique address:</p>
<pre class="source-code">
DeleteByOperator&lt;int&gt; d1;     // &amp;d1 = ....
DeleteByOperator&lt;long&gt; d2; // &amp;d2 must be != &amp;d1</pre>
<p>When two objects are laid out consecutively in memory, the difference between their addresses is the size of the first object (plus padding, if necessary). To prevent both the <code>d1</code> and <code>d2</code> objects from residing at the same address, the standard mandates that their size is at least one byte.</p>
<p>When used as a data member of another class, an object will occupy at least as much space as its size requires, which in our case, is one byte. Assuming that the pointer takes 8 bytes, the entire object is, therefore, 9 bytes long. But the size of an object also has to be padded to the nearest value that meets the alignment requirements - if the address of the pointer has to be aligned on 8 bytes, the object can be either 8 bytes or 16 bytes, but not in-between. So, adding an empty policy object to the class ends up changing its size from 8 bytes to 16 bytes. This is purely a waste of memory and is often undesirable, especially for objects that are created in large numbers, such as pointers. It is not possible to coax the compiler into creating a data member of zero size; the standard forbids it. But there is another way in which policies can be used without the overhead.</p>
<p>The alternative to <a id="_idIndexMarker842"/>composition is inheritance - we can use the policy as a base class for the primary class:</p>
<pre class="source-code">
// Example 10
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
  : DeletionPolicy(std::move(deletion_policy)), p_(p)
  {}
  ~SmartPtr() {
    DeletionPolicy::operator()(p_);
  }
  ...
};</pre>
<p>This approach relies on a particular optimization - if a base class is empty (has no non-static data members), it can be completely optimized out of the layout of the derived class. This is known as the <code>SmartPtr</code> class is only as large as necessary to hold its data members - in our case, 8 bytes.</p>
<p>When using inheritance for policies, the choice must be made between public or private inheritance. Usually, the policies are used to provide an implementation for a particular aspect of behavior. Such inheritance for implementation is expressed through private inheritance. In some cases, a policy may be used to change the public interface of the class; in this case, public inheritance should be used. For the deletion policy, we are not changing the interface of the class - the smart pointer always deletes the object at the end of its life; the only question is how. Therefore, the<a id="_idIndexMarker844"/> deletion policy should use private inheritance.</p>
<p>While the deletion policy using the <code>operator delete</code> is stateless, some policies have data members that must be preserved from the object given to the constructor. Therefore, in general, the base class policy should be initialized from the constructor argument by copying or moving it into the base class, similarly to the way we initialized the data members. The base classes are always initialized on the member initialization list before the data members of the derived class. Finally, the <code>base_type::function_name()</code> syntax can be used to call a member function of a base class; in our case, <code>DeletionPolicy::operator()(p_)</code>.</p>
<p>Inheritance or composition are the two choices for integrating the policy class into the primary class. In general, the composition should be preferred, unless there is a reason to use inheritance. We have already seen one such reason - the empty base class optimization. Inheritance is also a necessary choice if we want to affect the public interface of the class.</p>
<p>Our smart pointer is, so far, missing several important features that are commonly found in most smart pointer implementations. One such feature is the ability to release the pointer, that is, to prevent the automatic destruction of the object from taking place. This can be useful if, in some cases, the object is destroyed by some other means, or, alternatively, if the lifetime of the object needs to be extended and its ownership is passed to another resource-owning object. We can easily add this feature to our smart pointer:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  ~SmartPtr() {
    if (p) DeletionPolicy::operator()(p_);
  }
  void release() { p_ = nullptr; }
  ...
};</pre>
<p>Now, we can call <code>p.release()</code> on our smart pointer, and the destructor will do nothing. We can hard-code the release feature into the pointer, but sometimes you may want to enforce the deletion as it is done in the pointer, with no release. This calls for making the release feature optional, controlled by another policy. We can add a <code>ReleasePolicy</code> template parameter to control whether the <code>release()</code> member function is present, but what should it do? We could, of course, move the implementation of <code>SmartPtr::release()</code> into the policy:</p>
<pre class="source-code">
// Example 11
template &lt;typename T&gt; struct WithRelease {
  void release(T*&amp; p) { p = nullptr; }
};</pre>
<p>Now, the <code>SmartPtr</code> implementation only has to call <code>ReleasePolicy::release(p_)</code> to delegate the appropriate handling of <code>release()</code> to the policy. But what is the appropriate handling if we do not want to support the release functionality? Our no-release policy can simply do nothing, but this is misleading - the user has the expectation that, if <code>release()</code> was called, the object would not be destroyed. We could assert at runtime and terminate the program. This converts a logic error on the part of the programmer - trying to release a no-release smart pointer - into a runtime error. The best way would be for the <code>SmartPtr</code> class to not have the <code>release()</code> member function at all if it is not wanted. This way, the incorrect code would be impossible to compile. The only way to do this is to make the policy inject a new public member function into the public interface of the primary template. This can be accomplished using public inheritance:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy,
          typename ReleasePolicy&gt;
class SmartPtr : private DeletionPolicy,
                 public ReleasePolicy {
  ...
};</pre>
<p>Now, if the release<a id="_idIndexMarker845"/> policy has a public member function called <code>release()</code>, then so does the <code>SmartPtr</code> class.</p>
<p>This solves the interface problem. Now, there is a small matter of implementation. The <code>release()</code> member function has now moved into the policy class, but it must operate on the data member <code>p_</code> of the parent class. One way to do this would be to pass a reference to this pointer from the derived class to the base policy class during construction. This is an ugly implementation - it wastes 8 bytes of memory to store a reference to a data member that is almost “right there,” which is stored in the derived class right next to the base class itself. A much better way is to cast from the base class to the correct derived class. Of course, for this to work, the base class needs to know what the correct derived class is. The solution to this problem is the <strong class="bold">Curiously Recurring Template Pattern</strong> (<strong class="bold">CRTP</strong>) that <a id="_idIndexMarker846"/>we studied in this book: the policy should be a template (so we will need a template template parameter) that is instantiated on the derived class type.</p>
<p>This way, the <code>SmartPtr</code> class is both the derived class of the release policy and the template parameter of it:</p>
<pre class="source-code">
// Example 11
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          template &lt;typename...&gt; class ReleasePolicy =
                                       WithRelease&gt;
class SmartPtr : private DeletionPolicy,
                 public ReleasePolicy&lt;SmartPtr&lt;T,
                          DeletionPolicy, ReleasePolicy&gt;&gt;
{ ... };</pre>
<p>Note that the <code>ReleasePolicy</code> template is specialized with the concrete instantiation of the <code>SmartPtr</code> template, including all its policies, and including the <code>ReleasePolicy</code> itself.</p>
<p>Now, the release policy knows the type of the derived class and can cast itself to that type. This case is always safe because the correct derived class is guaranteed by construction:</p>
<pre class="source-code">
// Example 11
template &lt;typename P&gt; struct WithRelease {
  void release() { static_cast&lt;P*&gt;(this)-&gt;p_ = nullptr; }
};</pre>
<p>The template parameter <code>P</code> will be substituted with the type of the smart pointer. Once the smart pointer publicly inherits from the release policy, the public member function, <code>release()</code>, of the policy is inherited and becomes a part of the smart pointer public interface.</p>
<p>The last detail concerning the implementation of the release policy has to do with the access. As we’ve written so far, the data member <code>p_</code> is private in the <code>SmartPtr</code> class and cannot be accessed by its base classes directly. The solution to this is to declare the corresponding base class to be a friend of the derived class:</p>
<pre class="source-code">
// Example 11
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          template &lt;typename...&gt; class ReleasePolicy =
                                       WithRelease&gt;
class SmartPtr : private DeletionPolicy,
  public ReleasePolicy&lt;SmartPtr&lt;T, DeletionPolicy,
                                   ReleasePolicy&gt;&gt;
{
  friend class ReleasePolicy&lt;SmartPtr&gt;;
  T* p_;
  ...
};</pre>
<p>Note that inside the body of the <code>SmartPtr</code> class, we do not need to repeat all the template parameters. The shorthand <code>SmartPtr</code> refers to the currently instantiated template. This does not extend to the part of the class declaration before the opening brace of the class, so we had to repeat the template parameters when specifying the policy as a base class.</p>
<p>The no-release policy is just as easy to write:</p>
<pre class="source-code">
// Example 11
template &lt;typename P&gt; struct NoRelease {};</pre>
<p>There is <a id="_idIndexMarker847"/>no <code>release()</code> function here, so an attempt to call <code>release()</code> on a smart pointer with this policy will not compile. This solves our stated requirement to have a <code>release()</code> public member function only when it makes sense to call one. The policy-based design is a complex pattern, and it is rare to be limited to just one way to do something. There is another way to accomplish the same objective, we are going to study it later in this chapter, in the section, <em class="italic">Using policies to control the </em><em class="italic">public interface</em>.</p>
<p>There is yet another way in which policy objects can sometimes be used. This applies only to policies that have no internal state in any version of the policy, by design. For example, our deletion policies are sometimes stateless, but the one with the reference to the caller’s heap is not, so this is a policy that is not always stateless. The release policy can always be considered stateless; there is no reason for us to add a data member to it, but it is constrained to be used through public inheritance because its primary effect is to inject a new public member function.</p>
<p>Let’s consider another aspect of behavior that we may want to customize - debugging or logging. For debugging purposes, it may be convenient to print when an object is owned by a smart pointer and when it is deleted. We could add a debugging policy to the smart pointer to support this. The debug policy has to do only one thing, and that is to print something when a smart pointer is constructed or destroyed. It does not need access to the smart pointer if we pass the value of the pointer to the printing function. Therefore, we can make the print functions static in the debug policy and not store this policy in the smart pointer class <a id="_idIndexMarker848"/>at all:</p>
<pre class="source-code">
// Example 12
template &lt;typename T,
          typename DeletionPolicy,
          typename DebugPolicy = NoDebug&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
  : DeletionPolicy(std::move(deletion_policy)), p_(p) {
    DebugPolicy::constructed(p_);
  }
  ~SmartPtr() {
    DebugPolicy::deleted(p_);
    DeletionPolicy::operator()(p_);
  }
  ...
};</pre>
<p>For simplicity, we have omitted the release policy, but multiple policies are easy to combine. The debugging policy implementation is straightforward:</p>
<pre class="source-code">
// Example 12
struct Debug {
  template &lt;typename T&gt;
  static void constructed(const T* p) {
    std::cout &lt;&lt; "Constructed SmartPtr for object " &lt;&lt;
      static_cast&lt;const void*&gt;(p) &lt;&lt; std::endl;
  }
  template &lt;typename T&gt;
  static void deleted(const T* p) {
    std::cout &lt;&lt; "Destroyed SmartPtr for object " &lt;&lt;
      static_cast&lt;const void*&gt;(p) &lt;&lt; std::endl;
  }
};</pre>
<p>We have chosen to implement the policy as a non-template class with template static member functions. Alternatively, we could have implemented it as a template, parametrized with the object type <code>T</code>. The no-debug version of the policy, which is the default, is even <a id="_idIndexMarker849"/>simpler. It must have the same functions defined, but they don’t do anything:</p>
<pre class="source-code">
// Example 12
struct NoDebug {
  template &lt;typename T&gt;
    static void constructed(const T* p) {}
  template &lt;typename T&gt; static void deleted(const T* p) {}
};</pre>
<p>We can expect the compiler to inline the empty template functions at the call site and optimize the entire call away since no code needs to be generated.</p>
<p>Note that by choosing this implementation of policies, we made a somewhat restrictive design decision - all versions of the debug policy must be stateless. We may, in time, come to regret this decision if we need to, for example, store a custom output stream inside a debug policy, instead of the default <code>std::cout</code>. But even in that case, only the implementation of the smart pointer class will have to change - the client code will continue to work with no changes.</p>
<p>We have considered three different ways to incorporate the policy objects into the policy-based class - by composition, by inheritance (public or private), and by compile-time incorporation<a id="_idIndexMarker850"/> only, where the policy object does not need to be stored inside the main object at runtime. We will now move on to more advanced tech<a id="_idTextAnchor703"/><a id="_idTextAnchor704"/>niques for policy-based design.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor705"/>Advanced policy-based design</h1>
<p>The techniques we <a id="_idIndexMarker851"/>have introduced in the previous section form the foundation of policy-based design - policies can be classes, template instantiations, or templates (used by template template parameters). The policy classes can be composed, inherited, or used statically at compile time. If a policy needs to know the type of the primary policy-based class, the CRTP can be used. The rest is largely variations on the same theme, as well as tricky ways to combine several techniques to accomplish something new. We will now consider some of<a id="_idTextAnchor706"/><a id="_idTextAnchor707"/> these more advanced techniques.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor708"/>Policies for constructors</h2>
<p>Policies can be <a id="_idIndexMarker852"/>used to customize almost any aspect of the implementation, as well as to alter the class interface. However, there are unique challenges that arise when we attempt to customize class constructors using policies.</p>
<p>As an example, let’s consider another limitation of our current smart pointer. As it stands so far, the object owned by the smart pointer is always deleted when the smart pointer is deleted. If the smart pointer supports release, then we can call the <code>release()</code> member function and be wholly responsible for the deletion of the object. But how are we going to ensure this deletion? The most likely way is, we will let another smart pointer own it:</p>
<pre class="source-code">
SmartPtr&lt;C&gt; p1(new C);
SmartPtr&lt;C&gt; p2(&amp;*p1); // Now two pointers own one object
p1.release();</pre>
<p>This approach is verbose and error-prone - we temporarily let two pointers own the same object. If something were to happen at this moment that causes both pointers to be deleted, we would destroy the same object twice. We also have to remember to always release one of these pointers, but only one. We should take the higher-level view of the problem - we are trying to pass the ownership of the object from one smart pointer to another.</p>
<p>The better way to do this is by moving the first pointer into the second:</p>
<pre class="source-code">
SmartPtr&lt;C&gt; p1(new C);
SmartPtr&lt;C&gt; p2(std::move(p1));</pre>
<p>Now, the first pointer is left in the moved-from state, which we can define (the only requirement is that the destructor call must be valid). We choose to define it to be a pointer that does not own any object, that is, a pointer in the released state. The second pointer receives the ownership of the object and will delete it in due time.</p>
<p>To support this functionality, we must implement the move constructor. However, there may be a reason to sometimes prevent the transfer of ownership. Therefore, we may want to have both<a id="_idIndexMarker853"/> movable and non-movable pointers. This calls for yet another policy to control whether moving is supported:</p>
<pre class="source-code">
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden
&gt;
class SmartPtr ...;</pre>
<p>For simplicity, we have reverted to just one other policy - the deletion policy. The other policies we have considered can be added alongside the new <code>MovePolicy</code>. The deletion policy can be implemented in any of the ways we have learned already. Since it is likely to benefit from the empty base optimization, we will stay with the inheritance-based implementation for it. The move policy can be implemented in several different ways, but inheritance is probably the easiest:</p>
<pre class="source-code">
// Example 13
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy,
                 private MovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)),
      MovePolicy(), p_(p) {}
  … SmartPtr code unchanged …
  SmartPtr(SmartPtr&amp;&amp; that) :
    DeletionPolicy(std::move(that)),
    MovePolicy(std::move(that)),
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr(const SmartPtr&amp;) = delete;
};</pre>
<p>With both policies<a id="_idIndexMarker854"/> integrated using private inheritance, we now have a derived object with several base classes. Such multiple inheritance is fairly common in policy-based design in C++, and should not alarm you. This technique is sometimes known as <em class="italic">mix-in</em> since the implementation of the derived class is <em class="italic">mixed</em> from the pieces provided by the base classes. In C++, the term <em class="italic">mix-in</em> is also used to refer to a totally different inheritance scheme that is related to the CRTP, so the use of this term often creates confusion (in most object-oriented languages, <em class="italic">mix-in</em> unambiguously refers to the application of multiple inheritance that we can see here).</p>
<p>The new feature in our smart pointer class is the move constructor. The move constructor is unconditionally present in the <code>SmartPtr</code> class. However, its implementation requires that all base classes be movable. This gives us a way to disable move support with a non-movable move policy:</p>
<pre class="source-code">
// Example 13
struct MoveForbidden {
  MoveForbidden() = default;
  MoveForbidden(MoveForbidden&amp;&amp;) = delete;
  MoveForbidden(const MoveForbidden&amp;) = delete;
  MoveForbidden&amp; operator=(MoveForbidden&amp;&amp;) = delete;
  MoveForbidden&amp; operator=(const MoveForbidden&amp;) = delete;
};</pre>
<p>The movable policy is much simpler:</p>
<pre class="source-code">
// Example 13
struct MoveAllowed {
};</pre>
<p>We can now<a id="_idIndexMarker855"/> construct a movable pointer and a non-movable pointer:</p>
<pre class="source-code">
class C { ... };
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, MoveAllowed&gt; p = ...;
auto p1(std::move(p)); // OK
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, MoveForbidden&gt; q = ...;
auto q1(std::move(q)); // Does not compile</pre>
<p>An attempt to move a non-movable pointer does not compile because one of the base classes, <code>MoveForbidden</code>, is non-movable (does not have a move constructor). Note that the moved-from pointer <code>p</code> in the preceding example can be safely deleted, but cannot be used in any other way. In particular, it cannot be dereferenced.</p>
<p>While we are dealing with movable pointers, it would make sense to provide a move assignment operator as well:</p>
<pre class="source-code">
// Example 13
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy,
                 private MovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)),
      MovePolicy(), p_(p) {}
  … SmartPtr code unchanged …
  SmartPtr&amp; operator=(SmartPtr&amp;&amp; that) {
    if (this == &amp;that) return *this;
    DeletionPolicy::operator()(p_);
    p_ = std::exchange(that.p_, nullptr);
    DeletionPolicy::operator=(std::move(that));
    MovePolicy::operator=(std::move(that));
    return *this;
  }
  SmartPtr&amp; operator=(const SmartPtr&amp;) = delete;
};</pre>
<p>Note the check for the<a id="_idIndexMarker856"/> self-assignment. Unlike the copy assignment, which is required to do nothing for self-assignment, the move assignment is less constrained by the standard. The only certain requirement is that the self-move should always leave an object in a well-defined state (the moved-from state is an example of such a state). A no-op self-move is not required but is valid as well. Also, note the way in which the base classes are move-assigned - the easiest way is to invoke the move assignment operator of each base class directly. There is no need to cast the derived class <code>that</code> to each of the base types - this is an implicitly performed cast. We must not forget to set the moved-from pointer to <code>nullptr</code>, otherwise, the object owned by these pointers will be deleted twice.</p>
<p>For simplicity, we have ignored all of the policies we introduced earlier. This is fine – not all designs need everything to be controlled by a policy, and, in any case, it is quite straightforward to combine multiple policies. However, it is a good opportunity to point out that different policies are sometimes related - for example, if we use both a release policy and a move policy, the use of a movable move policy strongly suggests that the object must support release (a released pointer is similar to a moved-from pointer). Using template metaprogramming, we can force such dependence between the policies, if need be.</p>
<p>Note that a policy that needs to disable or enable constructors does not automatically have to be used as a base class - move assignment or construction also moves all data members, and, therefore, a non-movable data member will disable the move operations just as well. The more important reason to use inheritance here is the empty base class optimization: if we introduced a <code>MovePolicy</code> data member into our class, it would double the object size from 8 to 16 bytes on a 64-bit machine.</p>
<p>We have considered making our pointers movable. But what about copying? So far, we have disallowed copying outright - both the copy constructor and the copy assignment operator are deleted in our smart pointer from the very beginning. This makes sense so far - we do not want to have two smart pointers own the same object and delete it twice. But there is another type of ownership where the copy operation makes perfect sense - the shared ownership, such as what’s implemented by a reference-counting shared pointer. With this type of pointer, copying the pointer is allowed, and both pointers now equally own the pointed-to object. A reference count is maintained to count how many pointers to the same object exist in the program. When the very last pointer owning a particular object is deleted, so is the object itself, since there are no more references to it.</p>
<p>There are several ways to implement a reference-counted shared pointer, but let’s start with the design of the class and its policies. We still need a deletion policy, and it makes sense to have a single policy control the move and copy operations. For simplicity, we will again limit ourselves to just the policies we are currently exploring:</p>
<pre class="source-code">
// Example 14
template &lt;typename T,
  typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
  typename CopyMovePolicy = NoMoveNoCopy
&gt;
class SmartPtr : private DeletionPolicy,
                 public CopyMovePolicy {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy())
    : DeletionPolicy(std::move(deletion_policy)), p_(p)
  {}
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    CopyMovePolicy(std::move(other)),
    p_(std::exchange(that.p_, nullptr)) {}
  SmartPtr(const SmartPtr&amp; other) :
    DeletionPolicy(other),
    CopyMovePolicy(other),
    p_(other.p_) {}
  ~SmartPtr() {
    if (CopyMovePolicy::must_delete())
      DeletionPolicy::operator()(p_);
  }
};</pre>
<p>The copy <a id="_idIndexMarker857"/>operations are no longer unconditionally deleted. Both the copy and the move constructor are provided (the two assignment operators are omitted for brevity, but should be implemented in the same way it was done earlier).</p>
<p>The deletion of the object in the destructor of the smart pointer is no longer unconditional - in the case of the reference-counted pointer, the copying policy maintains the reference count and knows when there is only one copy of the smart pointer for a particular object.</p>
<p>The smart pointer class itself provides the requirements for the policy classes. The no-move, no-copy policy must disallow all copy and move operations:</p>
<pre class="source-code">
// Example 14
class NoMoveNoCopy {
  protected:
  NoMoveNoCopy() = default;
  NoMoveNoCopy(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy(const NoMoveNoCopy&amp;) = delete;
  NoMoveNoCopy&amp; operator=(NoMoveNoCopy&amp;&amp;) = delete;
  NoMoveNoCopy&amp; operator=(const NoMoveNoCopy&amp;) = delete;
  constexpr bool must_delete() const { return true; }
};</pre>
<p>In addition to <a id="_idIndexMarker858"/>that, the non-copyable smart pointer always deletes the object it owns in its destructor, so the <code>must_delete()</code> member function should always return <code>true</code>. Note that this function must be implemented by all copying policies, even if it is trivial, otherwise, the smart pointer class will not compile. However, we can fully expect the compiler to optimize the call away and unconditionally call the destructor when this policy is used.</p>
<p>The move-only policy is similar to the movable policy we had earlier, but now we must explicitly enable the move operations and disable the copy operations:</p>
<pre class="source-code">
// Example 14
class MoveNoCopy {
  protected:
  MoveNoCopy() = default;
  MoveNoCopy(MoveNoCopy&amp;&amp;) = default;
  MoveNoCopy(const MoveNoCopy&amp;) = delete;
  MoveNoCopy&amp; operator=(MoveNoCopy&amp;&amp;) = default;
  MoveNoCopy&amp; operator=(const MoveNoCopy&amp;) = delete;
  constexpr bool must_delete() const { return true; }
};</pre>
<p>Again, the deletion is unconditional (the pointer inside the smart pointer object can be null if the object was moved, but this does not prevent us from calling <code>operator delete</code> on it). This policy allows the move constructor and the move assignment operator to compile; the <code>SmartPtr</code> class provides the correct implementation for these operations, and no additional support from the policy is required.</p>
<p>The reference-counting copying policy is much more complex. Here, we have to decide on the shared pointer implementation. The simplest implementation allocates the reference <a id="_idIndexMarker859"/>counter in a separate memory allocation, which is managed by the copying policy. Let’s start with a reference-counted copying policy that does not allow move operations:</p>
<pre class="source-code">
// Example 14
class NoMoveCopyRefCounted {
  size_t* count_;
  protected:
  NoMoveCopyRefCounted() : count_(new size_t(1)) {}
  NoMoveCopyRefCounted(const NoMoveCopyRefCounted&amp; other) :
    count_(other.count_)
  {
    ++(*count_);
  }
  NoMoveCopyRefCounted(NoMoveCopyRefCounted&amp;&amp;) = delete;
  ~NoMoveCopyRefCounted() {
    --(*count_);
    if (*count_ == 0) {
      delete count_;
    }
  }
  bool must_delete() const { return *count_ == 1; }
};</pre>
<p>When a smart pointer with this copying policy is constructed, a new reference counter is allocated and initialized to one (we have one smart pointer pointing to the particular object - the one we are now constructing). When a smart pointer is copied, so are all its base classes, including the copy policy. The copy constructor of this policy simply increments the reference count. When a smart pointer is deleted, the reference count is decremented. The very last smart pointer to be deleted also deletes the count itself. The copying policy also controls when the pointed-to object is deleted - it happens when the reference count reaches one, which means that we are about to delete the very last pointer for this object. It is, of course, very important to make sure that the counter is not deleted before<a id="_idIndexMarker860"/> the <code>must_delete()</code> function is called. This is guaranteed to be true since the destructors of the base classes run after the destructor of the derived class - the derived class of the last smart pointer will see the counter value of one and will delete the object; then, the destructor of the copying policy will decrement the counter once more, see it drop to zero, and delete the counter itself.</p>
<p>With this policy, we can implement shared ownership of an object:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, NoMoveCopyRefCounted&gt; p1{new C};
auto p2(p1);</pre>
<p>Now, we have two pointers to the same object, with the reference count of two. The object is deleted when the last of the two pointers is, assuming that no more copies are created beforehand. The smart pointer is copyable, but not movable:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteByOperator&lt;C&gt;, NoMoveCopyRefCounted&gt; p1{new C};
auto p2(std::move(p1)); // Does not compile</pre>
<p>In general, once reference-counted copying is supported, there is probably no reason to disallow move operations, unless they are simply not needed (in which case, the no-move implementation can be slightly more efficient). To support the move, we must give some thought to the moved-from state of the reference-counting policy – clearly, it must not decrement the reference counter when it is deleted, since a moved-from pointer no longer owns the object. The simplest way is to reset the pointer to the reference counter so that it is no longer accessible from the copying policy, but then the copying policy<a id="_idIndexMarker861"/> must support the special case of a null counter pointer:</p>
<pre class="source-code">
// Example 15
class MoveCopyRefCounted {
  size_t* count_;
  protected:
  MoveCopyRefCounted() : count_(new size_t(1)) {}
  MoveCopyRefCounted(const MoveCopyRefCounted&amp; other) :
    count_(other.count_)
  {
    if (count_) ++(*count_);
  }
  ~MoveCopyRefCounted() {
    if (!count_) return;
    --(*count_);
    if (*count_ == 0) {
      delete count_;
    }
  }
  MoveCopyRefCounted(MoveCopyRefCounted&amp;&amp; other) :
    count_(std::exchange(other.count_, nullptr)) {}
  bool must_delete() const {
    return count_ &amp;&amp; *count_ == 1;
  }
};</pre>
<p>Finally, a reference-counting copying policy must support the assignment operations as well. These are implemented similarly to the copy or move constructors (but take care to use the left-hand-side policies for the deletion of the left-hand-side objects before assigning the new values to the policies).</p>
<p>As you have seen, some of the policy implementations can get pretty complex, and their interactions are even more so. Fortunately, the policy-based design is particularly well-suited for<a id="_idIndexMarker862"/> writing testable objects. This application of policy-based design is so <a id="_idTextAnchor709"/><a id="_idTextAnchor710"/>important that it deserves special mention.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor711"/>Policies for test</h2>
<p>We will now <a id="_idIndexMarker863"/>show the reader how to use policy-based design to write better tests. In particular, policies can be used to make the code more testable by means of unit tests. This can be done by substituting a special test-only version of a policy instead of the regular one. Let us demonstrate this with the example of the reference-counting policy from the previous subsection.</p>
<p>The main challenge of that policy is, of course, maintaining the correct reference count. We can easily develop some tests that should exercise all of the corner cases of reference counting:</p>
<pre class="source-code">
// Test 1: only one pointer
{
  SmartPtr&lt;C, ... policies ...&gt; p(new C);
} // C should be deleted here
// Test 2: one copy
{
  SmartPtr&lt;C, ... policies ...&gt; p(new C);
  {
    auto p1(p); // Reference count should be 2
  } // C should not be deleted here
} // C should be deleted here</pre>
<p>The hard part is actually testing that all of this code works the way it is supposed to. We know what the reference count should be, but we have no way of checking what it really is (adding the public function <code>count()</code> to the smart pointer solves that problem, but it is the least of the difficulties). We know when the object is supposed to be deleted, but it is hard to verify that it actually was. We will probably get a crash if we delete the object twice, but even that is not certain. It is even harder to catch the case when the object is not deleted at all. A sanitizer can find such issues, at least if we use standard memory management, but they are not available in all environments and, unless the tests are designed to be run with the sanitizer, can produce very noisy output.</p>
<p>Fortunately, we can use policies to give our tests a window into the internal working of the object. For example, if we did not implement a public <code>count()</code> method in all our reference-counting policies, we can create a testable wrapper for the reference-counting policy:</p>
<pre class="source-code">
class NoMoveCopyRefCounted {
  protected:
  size_t* count_;
  ...
};
class NoMoveCopyRefCountedTest :
  public NoMoveCopyRefCounted {
  public:
  using NoMoveCopyRefCounted::NoMoveCopyRefCounted;
  size_t count() const { return *count_; }
};</pre>
<p>Note that we had to change the <code>count_</code> data member from private to protected in the main copy policy. We could also declare the test policy a friend, but then we would have to do this for every new test policy. Now, we can actually implement our tests:</p>
<pre class="source-code">
// Test 1: only one pointer
{
  SmartPtr&lt;C, ... NoMoveCopyRefCountedTest&gt; p(new C);
  assert(p.count() == 1);
} // C should be deleted here
// Test 2: one copy
{
  SmartPtr&lt;C, ... NoMoveCopyRefCountedTest&gt; p(new C);
  {
  auto p1(p); // Reference count should be 2
    assert(p.count() == 2);
    assert(p1.count() == 2);
    assert(&amp;*p == &amp;*p1);
  } // C should not be deleted here
  assert(p.count == 1);
} // C should be deleted here</pre>
<p>Similarly, we can create an instrumented deletion policy that checks whether the object will be deleted, or record in some external logging object that it was actually deleted and test that the deletion was properly logged. We would need to instrument our smart pointer implementation to make calls to the debugging or testing policy:</p>
<pre class="source-code">
// Example 16:
template &lt;... template parameters ...,
          typename DebugPolicy = NoDebug&gt;
class SmartPtr : ... base policies ... {
  T* p_;
  public:
  explicit SmartPtr(T* p = nullptr,
    DeletionPolicy&amp;&amp; deletion_policy = DeletionPolicy()) :
    DeletionPolicy(std::move(deletion_policy)), p_(p)
  {
    DebugPolicy::construct(this, p);
  }
  ~SmartPtr() {
    DebugPolicy::destroy(this, p_,
                         CopyMovePolicy::must_delete());
  if (CopyMovePolicy::must_delete())
    DeletionPolicy::operator()(p_);
  }
  ...
};</pre>
<p>Both debug <a id="_idIndexMarker864"/>and production (non-debug) policies must have all the methods referenced in the class, but the empty methods of the non-debug policy are going to be inlined and optimized down to nothing.</p>
<pre class="source-code">
// Example 16
struct NoDebug {
  template &lt;typename P, typename T&gt;
  static void construct(const P* ptr, const T* p) {}
  template &lt;typename P, typename T&gt;
  static void destroy(const P* ptr, const T* p,
                      bool must_delete) {}
  ... other events ...
};</pre>
<p>The debug policies vary, the basic ones simply log all debuggable events:</p>
<pre class="source-code">
// Example 16
struct Debug {
  template &lt;typename P, typename T&gt;
  static void construct(const P* ptr, const T* p) {
    std::cout &lt;&lt; "Constructed SmartPtr at " &lt;&lt; ptr &lt;&lt;
      ", object " &lt;&lt; static_cast&lt;const void*&gt;(p) &lt;&lt;
      std::endl;
  }
  template &lt;typename P, typename T&gt;
  static void destroy(const P* ptr, const T* p,
                      bool must_delete) {
    std::cout &lt;&lt; "Destroyed SmartPtr at " &lt;&lt; ptr &lt;&lt;
      ", object " &lt;&lt; static_cast&lt;const void*&gt;(p) &lt;&lt;
      (must_delete ? " is" : " is not") &lt;&lt; " deleted" &lt;&lt;
      std::endl;
  }
};</pre>
<p>The more complex <a id="_idIndexMarker865"/>policies can validate that the internal state of the objects is consistent with the requirements and that the class invariants are maintained.</p>
<p>By now, the reader has likely noticed that the declarations of the policy-based objects can be quite long:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteByOperator&lt;T&gt;, MoveNoCopy,
         WithRelease, Debug&gt; p( ... );</pre>
<p>This is one of the most frequently observed problems with policy-based design, and we shoul<a id="_idTextAnchor712"/><a id="_idTextAnchor713"/>d consider some ways to mitigate this problem.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor714"/>Policy adapters and aliases</h2>
<p>Perhaps the most<a id="_idIndexMarker866"/> obvious drawback of the policy-based design is the way we have to declare the concrete objects - specifically, the long list of policies that must be repeated every time. Judicious use of default parameters helps to simplify the most commonly used cases. For example, let us look at the following long declaration:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteByOperator&lt;T&gt;, MoveNoCopy,
         WithRelease, NoDebug&gt;
p( ... );</pre>
<p>Sometimes, this can be reduced to the following:</p>
<pre class="source-code">
SmartPtr&lt;C&gt; p( ... );</pre>
<p>This can be done if the defaults represent the most common case of a movable non-debug pointer that uses the <code>operator delete</code>. However, what is the point of adding the policies if we are not going to use them? A well-thought-out order of policy parameters helps to make the more common policy combinations shorter. For example, if the most common variation is the deletion policy, then a new pointer with a different deletion policy and default remaining policies can be declared without repeating the policies we do not need to change:</p>
<pre class="source-code">
SmartPtr&lt;C, DeleteHeap&lt;T&gt;&gt; p( ... );</pre>
<p>This still leaves the problem of the less commonly used policies. Also, policies are often added later as additional features must be added to the design. These policies are almost always added to the end of the parameter list. To do otherwise would require rewriting every bit of code where a policy-based class is declared to reorder its parameters. However, the late-coming policies are not necessarily less often used, and this evolution of the design may lead to a case where many policy arguments have to be explicitly written, even at their default values, so that one of the trailing arguments can be changed.</p>
<p>While there is no general solution to this problem within the confines of the traditional policy-based design, in practice, there are often few commonly used groups of policies, and then there are some frequent variations. For example, most of our smart pointers may be using <code>operator delete</code> and support move and release, but we frequently need to alternate between the debug and non-debug versions. This can be accomplished by creating adapters that convert a class with many policies to a new interface that exposes only the policies we want to change often and pins the rest of the policies to their commonly used values. Any large design will likely need more than one such adapter, as the commonly used sets of policies can vary.</p>
<p>The simplest way to write such an adapter is with the <code>using</code> alias:</p>
<pre class="source-code">
// Example 17
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
using SmartPtrAdapter =
  SmartPtr&lt;T, DeleteByOperator&lt;T&gt;, MoveNoCopy,
              WithRelease, DebugPolicy&gt;;</pre>
<p>The other <a id="_idIndexMarker867"/>option is to use inheritance:</p>
<pre class="source-code">
// Example 18
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
class SmartPtrAdapter : public SmartPtr&lt;T,
  DeleteByOperator&lt;T&gt;, MoveNoCopy,
  WithRelease, DebugPolicy&gt;
{...};</pre>
<p>This creates a derived class template that pins some of the parameters of the base class template while leaving the rest parameterized. The entire public interface of the base class is inherited, but some care needs to be taken about the constructors of the base class. By default, they are not inherited, and so the newly derived class will have the default compiler-generated constructors. This is probably not something we want, so we have to bring the base class constructors (and possibly the assignment operators) into the derived class:</p>
<pre class="source-code">
// Example 18
template &lt;typename T, typename DebugPolicy = NoDebug&gt;
class SmartPtrAdapter : public SmartPtr&lt;T,
  DeleteByOperator&lt;T&gt;, MoveNoCopy,
  WithRelease, DebugPolicy&gt;
{
  using base_t = SmartPtr&lt;T, DeleteByOperator&lt;T&gt;,
    MoveNoCopy, WithRelease, DebugPolicy&gt;;
  using base_t::SmartPtr;
  using base_t::operator=;
};</pre>
<p>The <code>using</code> alias is definitely easier to write and maintain, but the derived class adapter offers more flexibility if it is necessary to also adapt some of the member functions, nested types, etc.</p>
<p>We can now use the new adapter when we need a smart pointer with the preset policies, but quickly change the debug policy:</p>
<pre class="source-code">
SmartPtrAdapter&lt;C, Debug&gt; p1{new C); // Debug pointer
SmartPtrAdapter&lt;C&gt; p2{new C); // Non-debug pointer</pre>
<p>As we said from the beginning, the most common application of policies is to select a specific implementation for some aspect of the behavior of the class. Sometimes, such variations in the implementation are reflected in the public interface of the class as well - some operations may make sense only for some implementations, and not for others, and the best way to make sure that an operation that is not compatible with the implementation<a id="_idIndexMarker868"/> is not invoked is to simply not provide it.</p>
<p>Now, let us revisit the issue of selectively enabl<a id="_idTextAnchor715"/><a id="_idTextAnchor716"/>ing parts of the public interface using policies.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor717"/>Using policies to control the public interface</h2>
<p>We have<a id="_idIndexMarker869"/> previously used policies to control the public interface in one of two ways - first, we were able to inject a public member function by inheriting from a policy. This approach is reasonably flexible and powerful, but has two drawbacks - first, once we inherit publicly from a policy, we have no control over what interface gets injected - every public member function of the policy becomes a part of the derived class interface. Second, to implement anything useful this way, we have to let the policy class cast itself to the derived class, and then it has to have access to all of the data members and possibly other policies of the class. The second approach we tried relied on a particular property of the constructors - to copy or move a class, we have to copy or move all of its base classes or data members; if one of them is non-copyable or non-movable, the entire constructor will fail to compile. Unfortunately, it usually fails with a rather non-obvious syntax error - nothing as straightforward as <em class="italic">no copy constructor found in this object.</em> We can extend this technique to other member functions, for example, to assignment operators, but it gets uglier.</p>
<p>We will now learn a more direct way to manipulate the public interface of a policy-based class. First of all, let’s differentiate between conditionally disabling existing member functions and adding new ones. The former is reasonable and generally safe: if a particular implementation cannot support certain operations offered by the interface, they should not be offered in the first place. The latter is dangerous as it allows for the essentially arbitrary and uncontrolled extension of the public interface of the class. Therefore, we will focus on providing the interface for all possible intended uses of a policy-based class, and then disabling parts of that interface when they do not make sense for some<a id="_idIndexMarker870"/> choice of policies.</p>
<p>There is already a facility in the C++ language to selectively enable and disable member functions. Prior to C++20, this facility is most commonly implemented through concepts (if they are available) or <code>std::enable_if</code>, but the foundation behind it is the SFINAE idiom that we studied in <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a>, <em class="italic">SFINAE, Concepts, and Overload Resolution Management</em>. In C++20, the much more powerful concepts can replace <code>std::enable_if</code> in many cases.</p>
<p>To illustrate the use of SFINAE to let the policies selectively enable a member function, we’re going to reimplement the policy controlling the public <code>release()</code> member function. We have done this once already in this chapter by inheriting from a <code>ReleasePolicy</code> that may or may not provide the <code>release()</code> member function; if one is provided, CRTP had to be used to implement it. We are now going to do the same but using C++20 concepts.</p>
<p>As we just said, a policy that relies on SFINAE and concepts cannot add any new member functions to the interface of a class; it can only disable some of them. Therefore, the first step is to add the <code>release()</code> function to the <code>SmartPtr</code> class itself:</p>
<pre class="source-code">
// Example 19
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename ReleasePolicy = NoRelease&gt;
class SmartPtr : private DeletionPolicy {
  T* p_;
  public:
  void release() { p_ = nullptr; }
  ...
};</pre>
<p>Right now, it is always enabled, so we need to conditionally enable it using some property of the <code>ReleasePolicy</code>. Since this policy controls a single behavior, all we need is a constant value<a id="_idIndexMarker871"/> that tells us whether the release feature should be supported:</p>
<pre class="source-code">
// Example 19
struct WithRelease {
  static constexpr bool enabled = true;
};
struct NoRelease {
  static constexpr bool enabled = false;
};</pre>
<p>Now, we need to conditionally enable the <code>release()</code> member function with a constraint:</p>
<pre class="source-code">
// Example 19
template &lt;...&gt; class SmartPtr ... {
  ...
  void release() requires ReleasePolicy::enabled {
    p_ = nullptr;
  }
};</pre>
<p>That’s all we need in C++20. Note that we did not need to inherit from <code>ReleasePolicy</code> because there is nothing in it except for a constant value. We also do not need to move or copy this policy, for the same reason.</p>
<p>Before C++20 and concepts, we have to use <code>std::enable_if</code> to enable or disable a particular member function - in general, the expression <code>std::enable_if&lt;value, type&gt;</code> will compile and yield the specified <code>type</code> if the <code>value</code> is <code>true</code> (it must be a compile-time, or <code>constexpr</code>, Boolean value). If the <code>value</code> is <code>false</code>, the type substitution fails (no type result is produced). The proper use for this template metafunction is in an SFINAE context, where the failure of type substitution does not result in a compilation error, but simply disables the function that causes the failure (to be more precise, it removes it from the overload resolution set).</p>
<p>The policies themselves do not have to change at all: both SFINAE and constraints need a <code>constexpr bool</code> value. What changes is the expression used to disable a member function. It is tempting to write it simply as:</p>
<pre class="source-code">
template &lt;...&gt; class SmartPtr ... {
  ...
  std::enable_if_t&lt;ReleasePolicy::enabled&gt; release() {
    p_ = nullptr;
  }
};</pre>
<p>Unfortunately, this is not going to work: for the <code>NoRelease</code> policy, this fails to compile even if we do not try to call <code>release()</code>. The reason is that SFINAE works only when template parameter substitution is done (<code>release()</code> function must be a template, and, furthermore, the potential substitution failure has to occur during the substitution of template parameters. We do not need any template parameters to declare <code>release()</code>, but we have to introduce a dummy one to use SFINAE:</p>
<pre class="source-code">
// Example 20
template &lt;...&gt; class SmartPtr ... {
  ...
  template&lt;typename U = T&gt;
  std::enable_if_t&lt;sizeof(U) != 0 &amp;&amp;
                   ReleasePolicy::enabled&gt; release() {
    p_ = nullptr;
  }
};</pre>
<p>We have seen such “fake templates” when we were describing the “concept utilities” – a way to mimic concepts before C++20 – in <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a><em class="italic">, SFINAE, Concepts, and Overload Resolution Management</em>. Now we have a template type parameter; the fact that it is never going to be used and is always set to its default value changes nothing. The conditional expression in the return type uses this template parameter (never mind that the part of the expression that depends on the parameter can never fail). Therefore, we are now within the SFINAE rules.</p>
<p>Now that we have a way to disable a member function selectively, we can revisit the conditionally enabled constructors to see how we can enable and disable constructors as well.</p>
<p>In C++20, the <a id="_idIndexMarker873"/>answer is “exactly the same way.” We need a policy with a <code>constexpr</code> Boolean value and a <code>restrict</code> constraint to disable any constructor:</p>
<pre class="source-code">
// Example 21
struct MoveForbidden {
  static constexpr bool enabled = false;
};
struct MoveAllowed {
  static constexpr bool enabled = true;
};</pre>
<p>We can use this policy to constrain any member function, constructors included:</p>
<pre class="source-code">
// Example 21
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  SmartPtr(SmartPtr&amp;&amp; other)
    requires MovePolicy::enabled :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
};</pre>
<p>Prior to C++20, we have to use SFINAE. The one complication here is that the constructors have no return type and we have to hide the SFINAE test somewhere else. In addition, we again have to make the constructor a template. We can use a dummy template<a id="_idIndexMarker874"/> parameter again:</p>
<pre class="source-code">
// Example 22
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  template &lt;typename U = T,
    std::enable_if_t&lt;sizeof(U) != 0 &amp;&amp; MovePolicy::enabled,
                     bool&gt; = true&gt;
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
};</pre>
<p>If you use the concept utilities from <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a><em class="italic">, SFINAE, Concepts, and Overload Resolution Management</em>, the code is going to look simpler and more straightforward, although a dummy template parameter is still needed:</p>
<pre class="source-code">
// Example 22
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename MovePolicy = MoveForbidden&gt;
class SmartPtr : private DeletionPolicy {
  public:
  template &lt;typename U = T,
    REQUIRES(sizeof(U) != 0 &amp;&amp; MovePolicy::enabled)&gt;
  SmartPtr(SmartPtr&amp;&amp; other) :
    DeletionPolicy(std::move(other)),
    p_(std::exchange(other.p_, nullptr)) {}
  ...
};</pre>
<p>Now that we have a fully general way to enable or disable specific member functions that work for constructors as well, the reader may be wondering, what was the point of introducing the earlier way? Firstly, for simplicity - the <code>enable_if</code> expression has to be used in the right context, and the compiler errors that are generated if anything is even slightly wrong are not pretty. On the other hand, the notion that a non-copyable base class makes the entire derived class non-copyable is very basic and works every time. This technique can even be used in C++03, where SFINAE is much more limited and even harder to get to work correctly.</p>
<p>Also, we have already seen that sometimes policies need to add member variables to the class instead of (or in addition to) member functions. Our reference-counting pointer is a perfect example: if one of the policies provides reference counting, it must also contain the count. Member variables cannot be restricted with constraints, so they have to come from the base policy class.</p>
<p>Yet another reason to at least know the way to inject public member functions through policies is that sometimes the <code>enable_if</code> alternative requires that the entire set of possible functions be declared in the primary class template, and then some can be selectively disabled. Sometimes, that set of functions is self-contradicting and cannot be present all at once. An example is a set of conversion operators. Right now, our smart pointer cannot be converted back into a raw pointer. We could enable such conversions and require them to be explicit, or allow implicit conversions:</p>
<pre class="source-code">
void f(C*);
SmartPtr&lt;C&gt; p(...);
f((C*)(p));     // Explicit conversion
f(p);         // Implicit conversion</pre>
<p>The conversion<a id="_idIndexMarker875"/> operators are defined as follows:</p>
<pre class="source-code">
template &lt;typename T, ...&gt;
class SmartPtr ... {
  T* p_;
  public:
  explicit operator T*() { return p_; } // Explicit
  operator T*() { return p_; }          // Implicit
  ...
};</pre>
<p>We already decided that we do not want these operators to be unconditionally present; instead, we want them controlled by a raw conversion policy. Let us start with the same approach we used the last time for a policy that enables a member function:</p>
<pre class="source-code">
// Example 23
struct NoRaw {
  static constexpr bool implicit_conv = false;
  static constexpr bool explicit_conv = false;
};
struct ExplicitRaw {
  static constexpr bool implicit_conv = false;
  static constexpr bool explicit_conv = true;
};
struct ImplicitRaw {
  static constexpr bool implicit_conv = true;
  static constexpr bool explicit_conv = false;
};</pre>
<p>Again, we will write C++20 code first, where we can restrict both the explicit and the implicit <a id="_idIndexMarker876"/>operators using constraints:</p>
<pre class="source-code">
// Example 23
template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... {
  T* p_;
  public:
  explicit operator T*()
    requires ConversionPolicy::explicit_conv
    { return p_; }
  operator T*()
    requires ConversionPolicy::implicit_conv
    { return p_; }
  explicit operator const T*()
    requires ConversionPolicy::explicit_conv const
    { return p_; }
  operator const T*()
    requires ConversionPolicy::implicit_conv const
    { return p_; }
};</pre>
<p>For completeness, we also provided conversions to a <code>const</code> raw pointer. Note that in C++20, there is a simpler way to<a id="_idIndexMarker877"/> provide these operators using the conditional explicit specifier (another C++20 feature):</p>
<pre class="source-code">
// Example 24
template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... {
  T* p_;
  public:
  explicit (ConversionPolicy::explicit_conv)
  operator T*()
    requires (ConversionPolicy::explicit_conv ||
              ConversionPolicy::implicit_conv)
    { return p_; }
  explicit (ConversionPolicy::explicit_conv)
  operator const T*()
    requires (ConversionPolicy::explicit_conv const ||
              ConversionPolicy::implicit_conv const)
    { return p_; }
};</pre>
<p>Prior to C++20, we can attempt to enable one of these operators using <code>std::enable_if</code> and SFINAE, again based on a conversion policy. The problem is, we cannot declare both implicit and explicit conversion to the same type, even if one is later disabled. These operators cannot be in the same overload set to begin with:</p>
<pre class="source-code">
// Example 25 – does not compile!
template &lt;typename T, ..., typename ConversionPolicy&gt;
class SmartPtr : ... {
  T* p_;
  public:
  template &lt;typename U = T,
            REQUIRES(ConversionPolicy::explicit_conv)&gt;
  explicit operator T*() { return p_; }
  template &lt;typename U = T,
            REQUIRES(ConversionPolicy::implicit_conv)&gt;
  operator T*() { return p_; }
  ...
};</pre>
<p>If we want to have the option to select one of these operators in our smart pointer class, we have to have them generated by the base class policy. Since the policy needs to be aware <a id="_idIndexMarker878"/>of the smart pointer type, we have to use the CRTP again. Here is a set of policies to control the conversion from smart pointers to raw pointers:</p>
<pre class="source-code">
// Example 26
template &lt;typename P, typename T&gt; struct NoRaw {
};
template &lt;typename P, typename T&gt; struct ExplicitRaw {
  explicit operator T*() {
    return static_cast&lt;P*&gt;(this)-&gt;p_;
  }
  explicit operator const T*() const {
    return static_cast&lt;const P*&gt;(this)-&gt;p_;
  }
};
template &lt;typename P, typename T&gt; struct ImplicitRaw {
  operator T*() {
    return static_cast&lt;P*&gt;(this)-&gt;p_;
  }
  operator const T*() const {
    return static_cast&lt;const P*&gt;(this)-&gt;p_;
  }
};</pre>
<p>These policies add the desired public member function operators to the derived class. Since they are templates that need to be instantiated with the derived class type, the conversion <a id="_idIndexMarker879"/>policy is a template template parameter, and its use follows the CRTP:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, ... other policies ...
          template &lt;typename, typename&gt;
          class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : ... other base policies ...,
  public ConversionPolicy&lt;SmartPtr&lt;... paramerers ...&gt;, T&gt;
{
  T* p_;
  template&lt;typename, typename&gt;
  friend class ConversionPolicy;
  public:
  ...
};</pre>
<p>Once again, note the use of the template template parameter: the template parameter <code>ConversionPolicy</code> is not a type but a template. When inheriting from an instantiation of this policy, we have to write the complete type of our <code>SmartPtr</code> class, with all its template arguments. We made the conversion policy a template of two arguments (the second one is the object type <code>T</code>). We could also deduce the type <code>T</code> from the first template parameter (the smart pointer type), it’s largely a matter of style.</p>
<p>The selected conversion policy adds its public interface, if any, to that of the derived class. One policy adds a set of explicit conversion operators, while the other one provides implicit conversions. Just like in the earlier CRTP example, the base class needs access to the private data members of the derived class. We can either grant friendship to the entire template (and every instantiation of it) or, more verbosely, to the specific instantiation used as the base class for each smart pointer:</p>
<pre class="source-code">
friend class ConversionPolicy&lt;
  SmartPtr&lt;T, ... parameters ..., ConversionPolicy&gt;, T&gt;;</pre>
<p>We have learned several different ways to implement new policies. Sometimes, the challenge comes in reusing the on<a id="_idTextAnchor718"/><a id="_idTextAnchor719"/>es we already have. The next section shows one way to do it.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor720"/>Rebinding policies</h2>
<p>As we have already seen, the policy lists can get quite long. Often, we want to change just one policy and create a class <em class="italic">just like that other one, but with a small change.</em> There are at least two ways to do this.</p>
<p>The first way is very general but somewhat verbose. The first step is to expose the template parameters as aliases, inside the primary template. This is a good practice, anyway - without such aliases, it is very difficult to find out, at compile time, what a template parameter was in case we ever need to use it outside of the template. For example, we have a smart pointer, and we want to know what the deletion policy was. The easiest way, by far, is with some help from the smart pointer class itself:</p>
<pre class="source-code">
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename CopyMovePolicy = NoMoveNoCopy,
          template &lt;typename, typename&gt;
            class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : ... base policies ... {
  T* p_;
  public:
  using value_type = T;
  using deletion_policy_t = DeletionPolicy;
  using copy_move_policy_t = CopyMovePolicy;
  template &lt;typename P, typename T1&gt;
  using conversion_policy_t = ConversionPolicy&lt;P, T1&gt;;
  ...
};</pre>
<p>Note that we’re using two different types of aliases here - for the regular template parameters such as <code>DeletionPolicy</code>, we can use a <code>using</code> alias. For a template template parameter, we have to use the template alias, sometimes called template <code>typedef</code> - to reproduce the same policy with another smart pointer, we need to know the template itself, not the template instantiation, such as <code>ConversionPolicy&lt;SmartPtr, T&gt;</code>. Now, if we need to create another smart pointer with some <a id="_idIndexMarker880"/>of the same policies, we can simply query the policies of the original object:</p>
<pre class="source-code">
// Example 27
SmartPtr&lt;int,
  DeleteByOperator&lt;int&gt;, MoveNoCopy, ImplicitRaw&gt;
  p1(new int(42));
using ptr_t = decltype(p1); // The exact type of p1
SmartPtr&lt;ptr_t::value_type,
  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,
  ptr_t::conversion_policy_t&gt; p2;
SmartPtr&lt;double,
  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,
  ptr_t::conversion_policy_t&gt; p3;</pre>
<p>Now, <code>p2</code> and <code>p1</code> have exactly the same type. There is, of course, an easier way to accomplish that. But the point is, we could alter any one of the types in the list and keep the rest, and get a pointer just like <code>p1</code>, <em class="italic">except for one change.</em> For example, the pointer <code>p2</code> has the same policies but points to a <code>double</code>.</p>
<p>The latter turns out to be a pretty common case, and there is a way to facilitate the <em class="italic">rebinding</em> or a template to a different type while keeping the rest of the arguments intact. To do this, the <a id="_idIndexMarker881"/>primary template and all its policies need to support such rebinding:</p>
<pre class="source-code">
// Example 27
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const { delete p; }
  template &lt;typename U&gt;
    using rebind_type = DeleteByOperator&lt;U&gt;;
};
template &lt;typename T,
          typename DeletionPolicy = DeleteByOperator&lt;T&gt;,
          typename CopyMovePolicy = NoMoveNoCopy,
          template &lt;typename, typename&gt;
            class ConversionPolicy = ExplicitRaw&gt;
class SmartPtr : private DeletionPolicy,
  public CopyMovePolicy,
  public ConversionPolicy&lt;SmartPtr&lt;T, DeletionPolicy,
    CopyMovePolicy, ConversionPolicy&gt;, T&gt; {
  T* p_;
  public:
  ...
  template &lt;typename U&gt;
  using rebind = SmartPtr&lt;U,
    typename DeletionPolicy::template rebind&lt;U&gt;,
    CopyMovePolicy, ConversionPolicy&gt;;
};</pre>
<p>The <code>rebind</code> alias defines a new template that has only one parameter - the type we can change. The rest of the parameters come from the primary template itself. Some of these parameters are types that also depend on the primary type <code>T</code>, and themselves need rebinding (in our example, the deletion policy). By choosing not to rebind the copy/move policy, we impose a requirement that none of these policies depend on the primary type, otherwise this policy, too, needs to be rebound. Finally, the template conversion policy does not need rebinding - we have access to the entire template here, so it will be instantiated with the new primary type. We can now use the rebinding mechanism to create a <em class="italic">similar</em> pointer type:</p>
<pre class="source-code">
SmartPtr&lt;int,
  DeleteByOperator&lt;int&gt;, MoveNoCopy, ImplicitRaw&gt;
p(new int(42));
using dptr_t = decltype(p)::rebind&lt;double&gt;;
dptr_t q(new double(4.2));</pre>
<p>If we have direct access to the smart pointer type, we can use it for rebinding (for example, in a template context). Otherwise, we can get the type from a variable of this type using <code>decltype()</code>. The pointer <code>q</code> has the same policies as <code>p</code> but points to a <code>double</code>, and the type-dependent policies such as the deletion policy have been updated accordingly.</p>
<p>We have covered the main ways in which the policies can be implemented and used to customize policy-based classes. It is now time to review what we have learned and stat<a id="_idTextAnchor721"/><a id="_idTextAnchor722"/>e some general guidelines for the use of policy-based designs.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor723"/>Recommendations and guidelines</h1>
<p>The policy-based design allows for exceptional flexibility in the creation of finely customizable classes. Sometimes, this flexibility and power become the enemy of a good design. In this section, we will review the strengths and weaknesses of the poli<a id="_idTextAnchor724"/><a id="_idTextAnchor725"/>cy-based design and come up with some general recommendations.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor726"/>Strengths of the policy-based design</h2>
<p>The main advantages <a id="_idIndexMarker882"/>of the policy-based design are flexibility and extensibility of the design. At a high level, these are the same benefits the Strategy pattern offers, only realized at compile-time. The policy-based design allows the programmer to select, at compile time, one of several algorithms for each specific task or operation performed by the system. Since the only constraints on the algorithms are the requirements on the interface that binds them into the rest of the system, it is equally possible to extend the system by writing new policies for the customizable operations.</p>
<p>At a high level, the policy-based design allows the software system to be built from components. At a high level, this is hardly a novel idea, certainly not limited to policy-based design. The focus of the policy-based design is the use of components to define behavior and the implementation of individual classes. There is some similarity between policies and callbacks - both allow a user-specified action to be taken when a particular event takes place. However, the policies are much more general than callbacks - while a callback is a function, policies are entire classes, with multiple functions and, possibly, a non-trivial internal state.</p>
<p>These general concepts translate into a unique set of advantages for the design, mostly centered around the ideas of flexibility and extensibility. With the overall structure of the system and its high-level components determined by the high-level design, the policies allow for a variety of low-level customizations within the constraints that were imposed by the original design. Policies can extend the class interface (add public member functions), implement or extend the state of the class (add data members), and specify implementations (add private member functions). The original design, in setting the overall structure of the classes and their interactions, in effect authorizes each policy to have one or more of these roles.</p>
<p>The result is an extensible system that can be modified to address evolving requirements, even ones that have not been anticipated or known at the time when the system was designed. The overall architecture remains stable, while the selection of possible policies and the constraints on their interfaces offers a<a id="_idTextAnchor727"/><a id="_idTextAnchor728"/> systematic, disciplined way to modify and extend the software.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor729"/>Disadvantages of policy-based design</h2>
<p>The first problem <a id="_idIndexMarker883"/>with the policy-based design that comes to mind is the one we have already encountered - declarations of policy-based classes with a specific set of policies are extremely verbose, especially if one of the policies at the end of the list has to be changed. Consider the declaration of a smart pointer with all of the policies we have implemented in this chapter, put together:</p>
<pre class="source-code">
SmartPtr&lt;int, DeleteByOperator&lt;int&gt;, NoMoveNoCopy, ExplicitRaw, WithoutArrow, NoDebug&gt; p;</pre>
<p>That’s just for a smart pointer - a class with a fairly simple interface and limited functionality. Even though it is unlikely that someone will need one pointer with all of these customization possibilities, the policy-based classes tend to have a lot of policies. This problem may be the most evident, but it is actually not the worst. The template aliases help to give concise names to the few policy combinations that are actually used by a particular application. In the template context, the types of smart pointers used as function arguments are deduced and do not need to be explicitly specified. In regular code, <code>auto</code> can be used to save a lot of typing and also make the code more robust - when the complex type declarations that must be consistent are replaced with an automatic way to generate these consistent types, the errors caused by typing something slightly different in two different places disappear (in general, if there is a recipe to make the compiler generate correct-by-construction code, use it).</p>
<p>The much more significant, if slightly less visible, problem is that all of these policy-based types with different policies are actually different types. Two smart pointers that point to the same object type but have different deletion policies are different types. Two smart pointers that are otherwise the same but have different copying policies are different types. Why is that a problem? Consider a function that is called to work on an object that is passed into the function using a smart pointer. This function does not copy the smart pointer, so it should not matter what the copying policy is - it is never used. And yet, what should the argument type be? There is no one type that can accommodate all smart pointers, even the ones with very similar functionality.</p>
<p>There are several possible solutions here. The most straightforward one is to make all functions that use policy-based types into templates. This does simplify the coding, and it reduces code duplication (at least the source code duplication), but it has its own downsides - the machine code becomes larger since there are multiple copies of every function, and all template code must be in the header files.</p>
<p>The other option is to erase the policy types. We saw the type erasure technique in <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>. Type erasure solves the problem of having many similar types - we could make all smart pointers, regardless of their policies, be of the same type (only to the extent that the policies determine the implementation and not the public interface, of course). However, this comes at a very high cost.</p>
<p>One of the main drawbacks of the templates in general, and the policy-based design, in particular, is that templates provide a zero-overhead abstraction - we can express our programs in terms of convenient high-level abstractions and concepts, but the compiler strips it all away, inlines all of the templates, and generates the minimum necessary code. Type erasure not only negates this advantage but has the opposite effect - it adds a very high overhead of memory allocations and indirect function calls.</p>
<p>The last option is to avoid using policy-based types, at least for some operations. Sometimes, this choice carries a little extra cost - for example, a function that needs to operate on an object but not delete or own it should take the object by reference instead of a smart pointer (see <a href="B19262_03.xhtml#_idTextAnchor110"><em class="italic">Chapter 3</em></a>, <em class="italic">Memory and Ownership</em>). In addition to clearly expressing the<a id="_idIndexMarker884"/> fact that the function is not going to own the object, this neatly solves the problem of what type the argument should be - the reference is the same type, no matter which smart pointer it came from. This is, however, a limited approach - more often than not, we do need to operate on the entire policy-based objects, which are usually much more complex than a simple pointer (for example, custom containers are often implemented using policies).</p>
<p>The final disadvantage is the general complexity of the policy-based types, although such claims should be made with care - the important question is, complexity compared to what? Policy-based designs are usually invoked to solve complex design problems where a family of similar types serves the same overall purpose (<em class="italic">what</em>), but does so in slightly different ways (<em class="italic">h<a id="_idTextAnchor730"/><a id="_idTextAnchor731"/>ow)</em>. This leads us to the recommendations on the use of policies.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor732"/>Guidelines for policy-based designs</h2>
<p>The guidelines for <a id="_idIndexMarker885"/>policy-based designs boil down to managing the complexity and making sure the ends justify the means - the flexibility of the design and the elegance of the resulting solutions should justify the complexity of the implementation and its use.</p>
<p>Since most of the complexity comes from the increasing number of policies, this is the focus of most of the guidelines. Some policies end up putting together very different types that happen to have a similar implementation. The goal of such a policy-based type is to reduce code duplication. While a worthwhile objective, this is generally not a good enough reason to expose a multitude of disparate policy options to the end user of the type. If two different types or type families happen to have similar implementations, that implementation can be factored out. The private, hidden, implementation-only part of the design can itself use policies if it makes the implementation easier.</p>
<p>However, these hidden policies should not be selected by the client - the client should specify the types that make sense in the application and the policies that customize the visible behavior. From these types and policies, the implementation can derive additional types as needed. This is no different than calling a common function to, say, find the minimum element in a sequence from several different unrelated algorithms that all happen to need that operation. The common code is not duplicated, but neither is it exposed to the user.</p>
<p>So, when should a policy-based type be broken up into two or more pieces? A good way to look at it is to ask whether the primary type, with a particular set of policies, has a good specific name that describes it. For example, a non-copyable owning pointer, movable or not, is a <em class="italic">unique pointer - </em>there is only one such pointer for each object at any given time. This is true for any deletion or conversion policy.</p>
<p>On the other hand, a reference-counted pointer is a <em class="italic">shared pointer,</em> again, with any choice of other policies. This suggests that our one smart pointer to end all smart pointers would be, perhaps, better split into two - a non-copyable unique pointer and a copyable shared pointer. We still get some code reuse because the deletion policy, for example, is common to both pointer types, and does not have to be implemented twice. This is, indeed, the choice the C++ standard makes. The <code>std::unique_ptr</code> has only one policy, the deletion policy. The <code>std::shared_ptr</code> also has the same policy and can use the same policy objects, but it is type-erased, so all shared pointers to a particular object are of one type.</p>
<p>But what about other policies? Here, we come to the second guideline - the policies that restrict the use of the class should be justified by the cost of possible errors that are caused by the incorrect use they are trying to prevent. For example, do we really need a non-movable policy? On the one hand, it could prevent a programming error if the ownership of the object absolutely must not be transferred. On the other hand, in many cases, the programmer will simply change the code to use a movable pointer. Also, we are forced to use movable pointers to return them by value from factory functions. However, a non-copyable policy is often justified and should be the default. For example, there are good reasons to make most containers non-copyable by default: copying a large collection of data is almost always the result of sloppy coding, usually when passing arguments to functions.</p>
<p>Similarly, while it is probably desirable to prevent implicit casting to the raw pointer as a matter of basic coding discipline, there is always a way to convert the smart pointer to the raw one explicitly - if nothing else, <code>&amp;*p</code> should always work. Again, the benefits of the carefully restricted interface probably do not justify adding this policy. However, it makes a great compact learning example for a set of techniques that can be used to create more complex and more useful policies, and so the time we spent learning how this policy works is entirely justified.</p>
<p>When a policy affecting the public interface is justified, we have to make a choice between a constraint-based policy that restricts the existing member functions and a CRTP-based policy that adds them. As a rule, a design that relies on constraints is preferable, even prior to C++20 where we have to use the “pseudo-concepts.” However, this approach cannot be used to add member variables to the class, only member functions.</p>
<p>Another way to look at the question of what the right set of policies is and what policies should be broken up into separate groups is to go back to the fundamental strength of the policy-based design - the composability of the behavior expressed by different policies. If we have a class with four different policies, each of which can have four different implementations, that is 256 different versions of the class. It is, of course, unlikely that we will need all 256. But the point is, at the time when we implement the class, we do not know which of these versions we will actually need later. We could make a guess and implement only a few most likely ones. If we are wrong, this will result in much code duplication and copy-pasting. With the policy-based design, we have the potential to implement any combination of the behavior, without actually having to write them all explicitly up front.</p>
<p>Now that we understand this strength of policy-based designs, we can use it to evaluate a particular set of policies - do they need to be composable? Would we ever need to combine them in different ways? If some policies always come in certain combinations or groups, this calls for automatically deducing these policies from one primary user-specified policy. On the other hand, a set of largely independent policies that can be combined arbitrarily is probably a good set of policies.</p>
<p>Another way to address some of the weaknesses of policy-based design is to try and accomplish the same goal by different means. There is no substitute for the entirety of the capabilities offered by the policies - the Strategy pattern is there for a reason. However, there are alternative patterns that offer somewhat superficial similarities and may be used to solve some of the same problems as the policy-based design addresses. We will see one such alternative in <a href="B19262_16.xhtml#_idTextAnchor739"><em class="italic">Chapter 16</em></a>, <em class="italic">Adapters and Decorators</em> when we talk about decorators. It <a id="_idIndexMarker886"/>is not as general, but when it works, it can provide all the advantages of the policie<a id="_idTextAnchor733"/><a id="_idTextAnchor734"/>s, in particular, the composability, without some of the problems.</p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor735"/>Summary</h1>
<p>In this chapter, we have studied, extensively, the applications of the Strategy pattern (also known as the policy pattern) to C++ generic programming. The combination of the two gives rise to one of the most powerful tools in the arsenal of a C++ programmer - the policy-based design of classes. This approach provides great flexibility by allowing us to compose the behavior of the class from many building blocks, or policies, each of which is responsible for a particular aspect of the behavior.</p>
<p>We have learned different ways to implement policies - these can be templates, classes with template member functions, classes with static functions, and even classes with constant values. Just as varied are the ways that we can use policies through composition, inheritance, or direct access to static members. Policy parameters can be types or templates, each with its own advantages and limitations.</p>
<p>A tool as powerful as the policy-based design is also easily misused or applied in poor judgment. Often, such situations arise from the gradual evolution of the software toward more and more complexity. To mitigate such mischance, we have provided a set of guidelines and recommendations that focus on the key advantages that the policy-based design offers to the programmer and suggested the techniques and constraints that maximize such advantages.</p>
<p>In the next chapter, we will consider a more limited design pattern that can sometimes be used to mimic the policy-based approach, without some of its drawbacks. This chapter is dedicated to the Decorator pattern and the more general Adapter pattern. Both are sort of C<a id="_idTextAnchor736"/><a id="_idTextAnchor737"/>++ magic tricks - they make an object appear as something it’s not.</p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor738"/>Questions</h1>
<ol>
<li>What is the Strategy pattern?</li>
<li>How is the Strategy pattern implemented at compile time using C++ generic programming?</li>
<li>What types can be used as policies?</li>
<li>How can policies be integrated into the primary template?</li>
<li>Should I use policies with public member functions or policies with constraint variables?</li>
<li>What are the main drawbacks of policy-based design?</li>
</ol>
</div>
</body></html>