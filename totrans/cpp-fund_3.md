# *第三章*

# 类

## 课程目标

在本章结束时，你将能够：

+   声明和定义一个类

+   使用对象访问类的成员

+   应用访问修饰符以封装数据

+   在数据成员和成员函数上使用静态修饰符

+   实现嵌套类

+   使用友元指定符访问私有和受保护的成员

+   使用构造函数、拷贝构造函数、赋值运算符和析构函数

+   重载运算符

+   实现函数对象

在本章中，我们将学习关于 C++ 中的类和对象。

## 简介

在上一章中，我们看到了如何使用函数将基本操作组合成具有明确意义的单元。此外，在第一章中，我们看到了在 C++ 中，我们可以将数据存储在基本类型中，例如整数、字符和浮点数。

在本章中，我们将介绍如何定义和声明类以及如何访问类的成员函数。我们将探讨 `成员` 和 `友元` 函数是什么以及如何在程序中使用它们。在本章的后面部分，我们将探讨构造函数和析构函数的工作原理。在本章结束时，我们将探讨函数对象（functors）以及如何在程序中使用它们。

## 声明和定义一个类

**类**是将数据和操作组合在一起以创建新类型的一种方式，这些类型可以用来表示复杂的概念。

基本类型可以组合成更有意义的抽象。例如，*位置数据*由纬度和经度坐标组成，这些坐标以 `float` 值表示。在这种表示下，当我们的代码需要操作位置时，我们必须提供纬度和经度作为单独的变量。这很容易出错，因为我们可能会忘记传递两个变量中的一个，或者我们可能会以错误的顺序提供它们。

此外，计算两个坐标之间的距离是一个复杂任务，我们不希望一遍又一遍地编写相同的代码。当我们使用更复杂对象时，这变得更加困难。

继续我们的坐标示例，我们不是使用两个 `float` 类型的操作，而是可以定义一个类型，该类型存储位置并提供与它交互所需的必要操作。

### 使用类的优势

类提供了多个好处，例如抽象、信息隐藏和封装。让我们深入探讨这些内容：

+   `float` 变量，但这并不代表我们想要使用的概念。程序员需要记住这两个变量具有不同的含义，并且应该一起使用。类允许我们明确地定义一个概念，该概念由数据和该数据上的操作组成，并给它赋予一个 *名称*。

    在我们的示例中，我们可以创建一个类来表示 GPS 坐标。数据将是两个 `float` 变量，用于描述表示它的 `float` 变量。

+   **信息隐藏**：向类的用户公开一组功能，同时隐藏它们在类中实现细节的过程。

    这种方法减少了与类交互的复杂性，并使得将来更新类实现变得更加容易：

![图2.1：类直接暴露了用户代码使用的功能，隐藏了它实际上是用两个浮点数实现的这一事实](img/Image70122.jpg)

###### 图2.1：类直接暴露了用户代码使用的功能，隐藏了它实际上是用两个浮点数实现的这一事实

我们讨论了可以将GPS坐标表示为纬度和经度的事实。稍后，我们可能会决定将坐标表示为从**北极**的距离。多亏了信息隐藏，我们可以改变类的实现方式，而类的用户不会受到影响，因为我们没有改变类提供的功能：

![图2.2：类的实现方式发生变化，但由于它对用户隐藏，并且功能没有改变，用户不需要改变他们的代码与类的交互方式](img/Image70130.jpg)

###### 图2.2：类的实现方式发生变化，但由于它对用户隐藏，并且功能没有改变，用户不需要改变他们的代码与它的交互方式

类向用户公开的功能集通常被称为**公共接口**。

#### 注意

改变类的实现通常比改变类的接口更方便，因为改变接口需要你改变所有类的用户以适应新的接口。正确设计类的公共接口是创建易于使用且维护性低的类的第一步。

+   **封装**：这是将数据和我们可以对其执行的操作组合在一起的原则。由于数据被隐藏在类中，用户无法访问或操作它。类必须提供与它交互的功能。C++通过允许用户将用于与类交互的操作和实现这些操作所使用的数据放在同一个单元中来实现封装：**类**。

让我们探索C++中类的结构及其相关信息。以下是一个类的基本结构：

[PRE0]

#### 注意

在关闭花括号后忘记添加最后一个分号是很常见的。请务必确保添加它。

### C++数据成员和访问说明符

在类的主体内部，我们可以定义以下类成员：

+   **数据成员**：这些是存在于类内部的变量，看起来像**变量声明**，但位于类体内部。它们也被称为**字段**。

+   **成员函数**：这些是可以访问类内部变量的函数。它们看起来像**函数声明**，但位于类体内部。它们也被称为**方法**。

如我们之前提到的，类通过拒绝用户访问信息来支持信息隐藏。程序员使用**访问修饰符**来指定类的哪些部分可供用户访问。

C++中有以下三种访问修饰符：

+   `private`只能被类内部的函数访问，并且不允许在类外部直接访问

+   `protected`只能被类内部和派生类中的函数访问。我们将在本书的最后一章中了解更多

+   `public`可以在程序的任何地方访问

访问修饰符后面跟着冒号来限定类中的一个区域，并且在该区域中定义的任何成员都具有它前面的访问修饰符。以下是语法：

[PRE1]

#### 注意

默认情况下，类成员具有`private`访问修饰符。

在C++中，我们也可以使用`struct`关键字来定义一个类。`struct`与类相同，唯一的区别是，默认情况下，访问修饰符是`public`，而对于类来说，它是`private`。

以下并排的代码片段是等效的：

![](img/C11557_03_03.jpg)

###### 图3.2：类和struct代码片段之间的区别

是否使用`struct`或`class`取决于使用的约定：通常，当我们想要一个可以从代码的任何地方访问的数据成员集合时，我们使用`structs`；另一方面，当我们正在模拟一个更复杂的概念时，我们使用类。

我们已经学习了如何定义一个类。现在，让我们了解如何在程序中使用它。

一个类定义了一个对象的蓝图或设计。就像蓝图一样，我们可以从同一个类创建多个对象。这些对象被称为**实例**。

我们可以以创建任何基本类型相同的方式创建一个实例：先定义变量的类型，然后是变量的名称。让我们看看以下示例。

[PRE2]

以下是一个示例，展示了具有多个实例的类：

[PRE3]

在这里，我们有`Coordinates`类的两个实例，每个实例都有其`latitude`和`longitude`，它们可以独立改变。一旦我们有一个实例，我们就可以访问它的成员。

当我们声明一个类时，我们创建一个新的作用域，称为`class`或`struct`，从类外部的作用域是点（`.`）运算符。

对于之前定义的变量，我们可以使用以下代码来访问它们的`latitude`：

[PRE4]

如果我们想调用一个成员函数，我们可以这样调用它：

[PRE5]

另一方面，当我们编写`class`方法的主体时，我们处于类的范围内。这意味着我们可以通过直接使用它们的名称来访问类的其他成员，而无需使用*点*运算符。当前实例的成员将被使用。

假设`distance`方法实现如下：

[PRE6]

当我们调用 `newYorkPosition.distance(tokyoPosition);` 时，`distance` 方法是在 `newYorkPosition` 实例上被调用的。这意味着 `distance` 方法中的 `latitude` 和 `longitude` 指的是 `newYorkPosition.latitude` 和 `newYorkPosition.longitude`，而 `other_coordinate.latitude` 指的是 `tokyoPosition.latitude`。

如果我们调用 `tokyoPosition.distance(newYorkPosition);`，当前的实例将是 `tokyoPosition`，而 `latitude` 和 `longitude` 将指向 `tokyoPosition`，`other_coordinate` 则指向 `newYorkPosition`。

### 静态成员

在上一节中，我们了解到一个类定义了组成对象的字段和方法。它就像一个蓝图，指定了对象的外观，但实际上并没有构建它。*一个实例是由类定义的蓝图构建的对象*。实例包含数据，我们可以对实例进行操作。

想象一下汽车的蓝图。它指定了汽车的引擎，以及汽车将有四个轮子。蓝图是汽车类，但我们不能启动并驾驶蓝图。按照蓝图构建的汽车是类的实例。构建的汽车有四个轮子和引擎，我们可以驾驶它。同样，类的实例包含由类指定的字段。

这意味着每个字段的值都与类的特定实例相关联，并独立于所有其他实例的字段演变。同时，这也意味着字段不能没有关联的实例存在：将没有对象能够提供存储（内存中的空间）来存储字段的值！

然而，有时我们希望所有实例共享相同的值。在这种情况下，我们可以通过创建一个 `static` 字段，将字段与类关联而不是与实例关联。让我们检查以下语法：

[PRE7]

将只有一个 `memberName` 字段，它被所有实例共享。像任何 C++ 变量一样，`memberName` 需要存储在内存中。我们不能使用实例对象的存储，因为 `memberName` 与任何特定实例无关。`memberName` 以类似 *全局变量* 的方式存储。

在声明 `static` 变量的类之外，在一个 `.cpp` 文件中，我们可以定义 `static` 变量的值。初始化值的语法如下：

[PRE8]

#### 注意

注意，我们不需要重复 `static` 关键字。

在 `.cpp` 文件中定义 `static` 变量的值非常重要。如果我们将其定义在 **头文件** 中，定义将被包含在头文件内的任何地方，这将创建多个定义，并且 **链接器** 将会报错。

类静态变量的生命周期持续整个程序运行期间，就像全局变量一样。

让我们看看一个类中的静态字段如何在头文件中定义，以及如何在`.cpp`文件中为其赋值：

[PRE9]

当访问实例的成员时，我们学习了如何使用点运算符。

当访问静态成员时，我们可能没有实例来使用点运算符。C++通过在类名后使用`::`运算符，给了我们访问类静态成员的能力。

#### 注意

声明静态字段时始终使用`const`。任何实例都可以访问其类的静态字段；如果它们是**可变的**，那么追踪哪个实例正在修改值就变得极其困难。在多线程程序中，同时从不同的线程修改静态字段是常见的，这会导致创建错误。

让我们检查以下练习，以了解静态变量是如何工作的。

### 练习7：使用静态变量

让我们编写一个程序来打印和查找从1到10的数字的平方：

1.  包含所需的头文件。

1.  编写`squares()`函数和以下逻辑：

    [PRE10]

1.  现在，在`main`函数中，添加以下代码：

    [PRE11]

    输出如下：

    [PRE12]

除了静态字段之外，类还可以有静态方法。

静态方法与类相关联；它可以不通过实例来调用。由于类的字段和成员与实例相关联，而静态方法则不是，因此静态方法不能调用它们。可以使用作用域解析运算符调用静态方法：`ClassName::staticMethodName();`。

#### 注意

静态方法只能调用类内部的其它静态方法和静态字段。

## 成员函数

**成员函数**是用于操作类数据成员的函数，它们定义了类的对象属性和行为。

声明成员函数只是在一个类体内部声明一个函数的事情。让我们检查以下语法：

[PRE13]

成员函数，就像类的数据成员一样，可以使用应用于对象的点（`.`）运算符来访问：

[PRE14]

让我们了解如何在类作用域之外声明成员函数。

### 声明成员函数

成员函数，就像数据成员一样，必须在类内部声明。然而，成员函数的实现可以放在类体内部或外部。

以下是在类外部定义成员函数的定义，这是通过使用作用域解析运算符（`::`）来声明所引用的函数是类的成员来完成的。在类体中，函数使用其原型进行声明：

[PRE15]

### 使用const成员函数

类的成员函数可以被指定为`const`，这意味着该函数限制其访问为只读。此外，当成员函数访问`const`成员数据时，它必须为`const`。因此，不允许`const`成员函数修改对象的状态或调用这样做的方法。

要将成员函数声明为`const`，我们在函数声明中使用`const`关键字，位于函数名之后和函数体之前：

[PRE16]

除了我们在上一章中学到的重载规则之外，成员函数可以在它们的`const-ness`上进行重载，这意味着两个函数可以具有相同的签名，除了一个是`const`而另一个不是。当对象被声明为`const`时，将调用`const`成员函数；否则，调用非`const`函数。让我们考察以下代码：

[PRE17]

#### 注意

区分`const`函数和返回`const`类型的函数很重要。两者都使用了相同的`const`关键字，但在函数原型中的位置不同。它们表达的概念不同，是独立的。

以下示例显示了三种`const`函数的版本：

+   第一个是一个`const`成员函数

+   第二个返回一个`const`引用

+   第三个是一个返回`const`引用的`const`函数：

    [PRE18]

### `this`关键字

当在`class`上下文中使用`this`关键字时，它代表一个指针，其值是调用成员函数的对象的地址。它可以出现在任何非静态成员函数的体内。

在以下示例中，`setColorToRed()`和`setColorToBlue()`执行相同的操作。两者都设置一个数据成员，但前者使用`this`关键字来引用当前对象：

[PRE19]

#### 注意

`pointer->member`是访问由`pointer`指向的`struct`成员的一种方便方式。它等价于`(*pointer).member`。

### 练习八：使用`this`关键字创建一个问候新用户的程序

让我们编写一个程序，要求用户输入他们的名字，并用欢迎信息问候他们：

1.  首先，包含所需的头文件。

1.  然后，添加以下函数以打印所需输出：

    [PRE20]

1.  现在，让我们使用`this`关键字完成程序，并添加一个结束语。在之前的类中定义以下方法：

    [PRE21]

1.  编写如下`main`函数：

    [PRE22]

    输出如下：

    [PRE23]

    #### 注意

    函数参数与类的数据成员同名时，会遮蔽其可见性。在这种情况下，需要使用`this`关键字来消除歧义。

### 非成员类相关函数

定义为属于类接口的概念性函数或操作，非成员类相关函数不是类本身的一部分。让我们考察以下示例：

[PRE24]

打印函数将圆的半径写入给定的流，这通常是标准输出。

### 活动七：通过获取器和设置器实现信息隐藏

在这个活动中，你被要求定义一个名为`Coordinates`的类，它包含两个数据成员，`latitude`和`longitude`，都是`float`类型且不可公开访问。

与`Coordinates`类相关联的操作有四个：`set_latitude`、`set_longitude`、`get_latitude`和`get_longitude`。

#### 注意

`set_latitude`和`set_longitude`操作用于设置`x`和`y`坐标（也称为`get_latitude`和`get_longitude`用于**检索**它们（有时称为**获取器**）。

通过成员函数使用获取器和设置器进行封装。

要执行此活动，请按照以下步骤进行：

1.  定义一个名为`Coordinates`的类，其成员在`private`访问指定符下。

1.  将之前指定的四个操作添加，并通过在它们的声明前加上`public`访问指定符使它们公开可访问。

1.  设置器（`set_latitude`和`set_longitude`）应该接受一个浮点数作为参数并返回`void`，而获取器不接收任何参数并返回一个`float`。

1.  现在应该实现这四个方法。设置器将给定的值赋给它们应该设置的相应成员；获取器返回存储的值。

    #### 注意

    这个活动的解决方案可以在第288页找到。

## 构造函数和析构函数

到目前为止，我们已经学习了如何声明数据成员，如何在带有`public`指定符的函数中使用它们，以及如何访问它们。现在，让我们来探讨如何给它们设置值。

在下面的例子中，我们将声明一个名为`Rectangle`的`struct`，并按照以下方式为其设置值：

[PRE25]

这行代码将打印一个随机值，因为我们从未设置`int`的值。C++对基本类型的初始化规则是它们获得非指定值。

#### 注意

在某些情况下，当变量未初始化时，它们的值被设置为`0`。这可能是由于操作系统实现、标准库或编译器的某些细节导致的，C++标准不保证这一点。当程序依赖于这种行为时，程序将出现奇怪的错误，因为变量初始化为`0`是不可预测的。始终显式初始化基本类型的变量。

### 构造函数

初始化数据成员的方式是通过使用**构造函数**。构造函数是一个特殊的成员函数，它具有与类**相同名称**且**没有返回类型**，当编译器创建类的新对象时，它会被自动调用。

与任何其他函数一样，构造函数可以接受参数并具有函数体。我们可以在变量的名称后添加参数列表来调用构造函数：

[PRE26]

当没有参数时，我们可以避免使用括号，就像我们在前面的例子中所做的那样。

`Rectangle`结构体不带参数的构造函数示例如下：

[PRE27]

#### 注意

当构造函数所做的唯一操作是初始化数据成员时，可以选择使用初始化列表，我们将在本章后面向您展示。

除了为数据成员赋值外，构造函数还可以执行代码，类似于正常函数体。这对于**类不变性**的概念很重要。

将类的实现隐藏在`private`成员中，并且只通过`public`方法与类表示的概念进行交互的关键优势是能够强制执行类不变性。

类不变性是类的属性或属性集，对于类的任何给定实例，在任何点上都应该是`true`。它被称为`true`。

让我们看看一个需要类不变性的类的示例。想象一下，我们想要创建一个表示日期的类。日期将包含年、月和日，所有这些都表示为整数。

将其实现为一个`struct`，其中所有字段都是`public`。参考以下代码：

[PRE28]

现在，用户可以轻松地执行以下操作：

[PRE29]

之前的代码没有意义，因为格里高利历中只有12个月。

对于日期，一个类不变性是月份总是在1到12之间，日期总是在1到31之间，并且根据月份，甚至更少。

不论用户对`Date`对象进行的任何更改，不变性都必须始终成立。

一个类可以隐藏日期存储为三个整数的事实，并公开与`Date`对象交互的函数。函数可以期望找到的日期始终处于有效状态（不变性在函数开始时得到满足），并且它们需要确保在函数结束时将类留在有效状态（不变性在函数结束时得到满足）。

构造函数不仅初始化数据成员，还确保类遵守不变性。在构造函数执行后，不变性必须是`true`。

#### 注意

不变性的概念并不仅限于C++语言，并且没有专门的设施来指定类的不变性。一个最佳实践是在类代码中一起记录类的预期不变性，以便与该类一起工作的开发者可以轻松地检查预期的不变性并确保他们遵守它。

在代码中使用断言也有助于识别何时不遵守不变性。这可能意味着代码中存在错误。

### 重载构造函数

与其他函数类似，我们可以通过接受不同的参数来重载构造函数。当对象可以通过多种方式创建时，这很有用，因为用户可以通过提供预期的参数来创建对象，并且将调用正确的构造函数。

我们在本章前面展示了`Rectangle`类的默认构造函数的示例。如果我们想添加一个从正方形创建矩形的构造函数，我们可以在`Rectangle`类中添加以下构造函数：

[PRE30]

第二个构造函数是一个重载构造函数，它将根据类对象的初始化方式被调用。

在以下示例中，第一行将调用带有空参数的构造函数，而第二行将调用重载构造函数：

[PRE31]

#### 注意

只有一个非默认参数的构造函数也称为**转换构造函数**。这种构造函数指定了一个隐式转换，即从参数的类型转换为类类型。

根据之前的定义，以下转换是可能的：

[PRE32]

构造函数被初始化，并且它从类型`Square`转换为`Rectangle`。

同样，编译器在调用函数时也可以创建隐式转换，如下面的示例所示：

[PRE33]

当调用`use_rectangle`时，编译器通过调用转换构造函数创建一个新的`Rectangle`类型的对象，该构造函数接受一个`Square`。

避免这种情况的一种方法是在构造函数定义前使用`explicit`指定符：

[PRE34]

让我们看看`Rectangle`的另一种实现，它有一个显式构造函数：

[PRE35]

当我们尝试使用`Square`调用一个接受`ExplicitRectangle`的函数时，我们会得到一个错误：

[PRE36]

### 构造函数成员初始化

如我们所见，构造函数用于初始化成员。到目前为止，我们通过直接给成员赋值在函数体内初始化成员。C++提供了一种更方便的方式来初始化类的字段值：初始化列表。初始化列表允许你在执行构造函数体之前调用类的数据成员的构造函数。要编写初始化列表，在构造函数体之前插入一个冒号（`:`）和一个用逗号分隔的初始化成员列表。

让我们看看以下示例：

[PRE37]

注意，在这个最后的情况下，构造函数除了初始化其成员外没有做任何事情。因此，它有一个空函数体。

现在，如果我们尝试打印`Rectangle`对象的宽度和高度，我们会注意到它们被正确地初始化为`0`：

[PRE38]

初始化列表是C++中初始化成员变量的推荐方式，当数据成员是`const`时是必要的。

当使用初始化列表时，成员构造的顺序是它们在类内部声明的顺序；而不是它们在初始化列表中出现的顺序。让我们看看以下示例：

[PRE39]

当调用`Example`类的默认构造函数时，`first`方法将首先被初始化，然后是`second`方法，即使它们在初始化列表中的顺序不同。

#### 注意

你应该始终按照成员声明的顺序在初始化列表中编写成员；当顺序与预期不同时，编译器会通过警告来帮助你。

### 聚合类初始化

没有用户声明的构造函数、没有私有或保护指定符的非静态数据成员、没有基类和没有虚函数的类或结构体被认为是聚合。

#### 注意

我们将在第6章中讨论基类和虚函数。

即使这些类没有构造函数，也可以通过使用括号括起来的逗号分隔的初始化子句列表来初始化，如下所示：

[PRE40]

### 析构函数

当对象超出作用域时，会自动调用**析构函数**，并用于销毁其类的对象。

析构函数与类名相同，前面有一个波浪号(`~`)，并且不接收任何参数也不返回任何值（甚至不是void）。让我们来看一个例子：

[PRE41]

执行析构函数的主体并销毁在主体内部分配的任何自动对象后，类的析构函数会调用所有直接成员的析构函数。数据成员的销毁顺序与它们的构造顺序相反。

### 练习9：创建一个简单的坐标程序以演示构造函数和析构函数的使用

让我们编写一个简单的程序来演示构造函数和析构函数的使用：

1.  首先，包含所需的头文件。

1.  现在，将以下代码添加到`Coordinates`类中：

    [PRE42]

1.  在`main`函数中，添加以下代码：

    [PRE43]

    输出如下：

    [PRE44]

### 默认构造函数和析构函数

所有类都需要构造函数和析构函数。当程序员没有定义这些函数时，编译器会自动创建隐式定义的构造函数和析构函数。

#### 注意

默认构造函数可能不会初始化数据成员。具有内置或复合类型成员的类通常应在类内部初始化这些成员或定义其默认构造函数版本。

### 活动8：在2D地图上表示位置

Alice正在编写一个程序来展示世界地图的2D版本。用户需要能够保存位置，例如他们的房子、餐厅或工作场所。为了启用此功能，Alice需要能够表示世界中的位置。

创建一个名为`Coordinates`的类，其数据成员是点的2D坐标。为了确保对象始终正确初始化，实现一个构造函数来初始化类的数据成员。

让我们执行以下步骤：

1.  第一步是创建一个名为`Coordinates`的类，其中包含坐标作为数据成员。

1.  现在，有两个浮点值`_latitude`和`_longitude`，它们标识地理坐标系统上的坐标。此外，这些数据成员使用`private`访问修饰符定义。

1.  通过添加两个参数`latitude`和`longitude`的`public`构造函数来扩展类，这些参数用于初始化类的数据成员。

1.  Alice现在可以使用这个`Coordinates`类来表示地图上的2D位置。

    #### 注意

    本活动的解决方案可以在第289页找到。

## 资源获取即初始化

**资源获取即初始化**，或简称**RAII**，是一种编程习惯，用于通过将其绑定到对象的生存周期来自动管理资源的生命周期。

通过智能地使用对象的构造函数和析构函数，你可以实现RAII。前者获取资源，而后者负责实现它。当资源无法获取时，构造函数可以抛出异常，而析构函数绝不能抛出异常。

通常，当资源的使用涉及`open()`/`close()`、`lock()`/`unlock()`、`start()`/`stop()`、`init()`/`destroy()`或类似函数调用时，通过RAII类的实例操作资源是一种良好的实践。

以下是一种使用RAII风格机制打开和关闭文件的方法。

#### 注意

C++像许多语言一样，将输入/输出操作表示为流，其中数据可以写入或读取。

类的构造函数将文件打开到提供的流中，而析构函数将关闭它：

[PRE45]

要打开文件，只需向`file_handle`类提供文件路径。然后，在整个`file_handle`对象的生命周期内，文件将不会关闭。一旦对象达到作用域的末尾，文件将被关闭：

[PRE46]

这代替了以下代码：

[PRE47]

尽管应用RAII惯用语提供的优势似乎只是减少代码，但真正的改进是拥有更安全的代码。程序员编写一个正确打开文件但从未关闭它或分配永远不会被销毁的内存的函数是很常见的情况。

RAII确保这些操作不会被遗忘，因为它会自动处理它们。

### 活动9：在地图上存储不同位置的多组坐标

在2D地图程序中，用户可以在地图上保存多个位置。我们需要能够存储多个坐标以跟踪用户保存的位置。为此，我们需要一种创建可以存储它们的数组的方法：

1.  使用RAII编程惯用语，编写一个管理内存分配和删除值数组的类。该类有一个整数数组作为成员数据，它将用于存储值。

1.  构造函数接受数组的大小作为参数。

1.  构造函数还负责分配内存，该内存用于存储坐标。

1.  要分配内存，请使用`allocate_memory`函数（元素数量），它返回一个指向请求大小的坐标数组的指针。要释放内存，请调用`release_memory`（数组），它接受一个坐标数组并释放内存。

1.  最后，定义一个析构函数，并确保在其实现中释放先前分配的数组：

    #### 注意

    本活动的解决方案可以在第290页找到。

## 嵌套类声明

在类的范围内，我们可以声明的不仅仅是数据成员和成员函数；我们可以在另一个类内部声明一个类。这些类被称为**嵌套类**。

由于嵌套类声明发生在*外部类*内部，它可以访问所有声明的名称，就像它是外部类的一部分：它可以访问甚至**私有声明**。

另一方面，嵌套类与任何实例都不相关联，因此它只能访问*静态成员*。

要访问嵌套类，我们可以使用双冒号（`::`），类似于访问外部类的静态成员。让我们看看以下示例：

[PRE48]

嵌套类有两个主要用途：

+   当实现一个类时，我们需要一个对象来管理类的一些逻辑。在这种情况下，嵌套类通常是**私有的**，并且不会通过类的**公共接口**暴露出来。它主要用于简化类的实现。

+   在设计类的功能时，我们希望提供一个与原始类密切相关且提供部分该功能的类。在这种情况下，该类对类的用户是可访问的，并且通常是类交互的重要部分。

想象一个列表——对象序列。我们希望用户能够遍历列表中的项目。为此，我们需要跟踪用户已经遍历过的项目和剩余的项目。这通常是通过一个`List`类来完成的。

我们将在*第5课*，*标准库容器和算法*中更详细地了解迭代器。

## 友元指定符

正如我们已经看到的，类的私有和保护成员不能从其他函数和类内部访问。一个类可以声明另一个函数或类为友元：这个函数或类将有权访问声明**友元关系**的类的私有和保护成员。

用户必须在类的主体内部指定`friend`声明。

### 友元函数

友元函数是非成员函数，有权访问类的私有和保护成员。将函数声明为`friend`函数的方法是在类内部添加其声明，并在其前面加上`friend`关键字。让我们看看以下代码：

[PRE49]

在前面的例子中，声明在类作用域之外的功能有权访问类数据成员，因为它被声明为`friend`函数。

### 友元类

同样，像`friend`函数一样，一个类也可以通过使用`friend`关键字成为另一个类的友元。

将一个类声明为`friend`就像声明它的所有方法为友元函数一样。

#### 注意

友情不是相互的。如果一个类是另一个类的友元，那么相反的情况并不自动成立。

以下代码演示了友情不是相互的概念：

[PRE50]

友情不是传递的；因此，在前面的例子中，类`C`不是类`A`的友元，类`C`的方法不能访问类`A`的保护或私有成员。此外，`A`不能访问`B`的私有成员，因为`B`是`A`的友元，但友情不是相互的。

### 练习 10：创建一个打印用户身高的程序

让我们编写一个程序，从用户那里收集以英寸为单位的高度输入，并在执行计算后打印用户以英尺为单位的高度：

1.  首先，让我们将所有必需的头文件添加到程序中。

1.  现在，创建一个名为`Height`的类，包含一个`public`方法，如下所示：

    [PRE51]

1.  如您所见，在之前的代码中，我们使用了一个名为`print_feet`的友元函数。现在，让我们声明它：

    [PRE52]

1.  在`main`函数中调用类，如下所示：

    [PRE53]

    输出如下：

    [PRE54]

### 活动10：创建苹果实例的`AppleTree`类

有时，我们可能只想在有限数量的类中创建特定类型的对象，以防止创建该类型的对象。这通常发生在类之间有严格关系时。

创建一个不提供`public`构造函数的`Apple`类和一个负责创建前者的`AppleTree`类。

让我们执行以下步骤：

1.  首先，我们需要创建一个具有`private`构造函数的类。这样，对象就不能被构造，因为构造函数不是公开可访问的：

    [PRE55]

1.  `AppleTree`类被定义，并包含一个名为`createFruit`的方法，负责创建一个`Apple`并返回它：

    [PRE56]

1.  如果我们编译此代码，我们将得到一个错误。此时，`Apple`构造函数是`private`的，因此`AppleTree`类无法访问它。我们需要将`AppleTree`类声明为`Apple`的`friend`，以允许`AppleTree`访问`Apple`的私有方法：

    [PRE57]

1.  现在可以使用以下代码构造`Apple`对象：

    [PRE58]

    #### 注意

    本活动的解决方案可以在第291页找到。

## 复制构造函数和赋值运算符

一种特殊的构造函数类型是`const`修饰的。

以下代码引用了一个具有用户定义的复制构造函数的类，它将另一个对象的数据成员复制到当前对象中：

[PRE59]

当类定义没有显式声明复制构造函数且所有数据成员都具有复制构造函数时，编译器会**隐式地**声明一个复制构造函数。这个隐式复制构造函数会按照初始化的**相同顺序**复制类的成员。

让我们看看一个例子：

[PRE60]

当`C`被复制构造时，成员按顺序复制：首先复制`a`，然后复制`b`。要复制`A`和`B`，编译器会调用这些类中定义的复制构造函数。

#### 注意

当复制指针时，我们不是复制指向的对象，而是简单地复制对象所在的位置的地址。

这意味着当一个类包含一个`指针`作为数据成员时，隐式复制构造函数只会复制指针，而不是指向的对象，因此复制的对象和原始对象将共享指针指向的对象。这有时被称为**浅拷贝**。

### 复制赋值运算符

复制对象的另一种方式是使用**复制赋值运算符**，与构造运算符相反，当对象已经被初始化时才会调用它。

赋值运算符的签名和实现看起来与复制构造函数非常相似，唯一的区别是前者是 `=` 运算符的重载，它通常返回对 `*this` 的引用，尽管这不是必需的。

这里是使用复制赋值运算符的一个示例：

[PRE61]

此外，对于复制赋值运算符，当它没有显式声明时，编译器生成一个 *隐式* 的。至于复制构造函数，成员的复制顺序与初始化顺序相同。

在以下示例中，当复制构造函数和复制赋值运算符被调用时，它们将输出一句话：

[PRE62]

以下代码展示了两种复制对象的方法。前者使用复制构造函数，而后者使用复制赋值运算符。当它们被调用时，两种实现将打印一句话：

[PRE63]

### 移动构造函数和移动赋值运算符

与复制类似，移动也允许你将一个对象的数据成员设置为与另一个数据成员相等。唯一的区别在于内容是从一个对象转移到另一个对象，从而从源对象中移除。

移动构造函数和移动赋值操作符是接受对 `class` 本身 `rvalue` 引用参数的成员：

[PRE64]

#### 注意

为了清晰起见，我们可以简要描述一个 `rvalue` 引用（通过在函数参数类型后放置一个 `&&` 运算符形成）为一个没有内存地址且不会超出单个表达式的值，例如，一个**临时对象**。

移动构造函数和移动赋值运算符允许将 `rvalue` 对象拥有的资源移动到 `lvalue` 中，而不进行复制。

当我们将构造函数或源对象赋值给目标对象时，我们将源对象的内容转移到目标对象中，但源对象需要保持有效。为此，在实现此类方法时，将源对象的数据成员重置为有效值是基本的。这是防止析构函数多次释放类的资源（如内存）所必需的。

假设存在一个可以获取、释放、重置并检查是否已重置的 `Resource`。

这里是 `WrongMove` 构造函数的一个示例：

[PRE65]

`WrongMove` 类的移动构造函数会释放资源两次：

[PRE66]

相反，移动构造函数应该重置其他对象的 `_resource` 成员，这样析构函数就不会再次调用 `release_resource`：

[PRE67]

如果没有提供用户定义的构造函数、析构函数、复制构造函数或复制或移动赋值运算符，编译器可以隐式生成移动构造函数和移动赋值运算符：

[PRE68]

### 防止隐式构造函数和赋值运算符

如果我们的类满足所有必需条件，编译器将隐式生成复制构造函数、复制赋值、移动构造函数和移动赋值。

对于我们的类不应该被复制或移动的情况，我们可以阻止这种情况发生。

为了防止生成隐式构造函数和运算符，我们可以编写构造函数或运算符的声明，并在声明末尾添加`= delete`。

让我们考察以下示例：

[PRE69]

## 运算符重载

C++类代表用户定义类型。因此，需要能够以不同的方式操作这些类型。某些运算符函数在操作不同类型时可能具有不同的意义。**运算符重载**允许你定义运算符应用于类类型对象时的含义。

例如，当`+`运算符应用于数值类型时，与应用于以下由坐标构成的`Point`类不同。语言无法指定`+`运算符对用户定义类型（如`Point`）应该做什么，因为它不控制这些类型，也不知道预期的行为是什么。因此，语言不定义用户定义类型的运算符。

然而，C++允许用户指定用户定义类型（包括类）的大多数运算符的行为。

下面是一个`+`运算符的例子，它被定义为`Point`类：

[PRE70]

以下是可以重载和不能重载的所有运算符的列表：

+   以下是可以重载的运算符：

![图3.4：可以重载的运算符](img/C11557_03_04.jpg)

###### 图3.4：可以重载的运算符

+   以下是不能重载的运算符：

![图3.5：不能重载的运算符](img/C11557_03_05.jpg)

###### 图3.5：不能重载的运算符

需要两个操作数的运算符被称为`+`、`-`、`*`和`/`。

重载二元运算符的方法需要接受一个参数。当编译器遇到运算符的使用时，它将调用位于运算符左侧的变量的方法，而右侧的变量将作为参数传递给方法。

在前面的示例中，我们看到`Point`定义了`+`运算符，它接受一个参数。当在`Point`上使用加法操作时，代码将如下所示：

[PRE71]

代码示例的最后一行等价于编写以下内容：

[PRE72]

编译器自动将第一个表达式重写为第二个表达式。

只需要一个操作数的运算符被称为`--`、`++`和`!`。

重载一元运算符的方法不能接受任何参数。当编译器遇到运算符的使用时，它将调用分配给该运算符的变量的方法。

例如，假设我们有一个如下定义的对象：

[PRE73]

我们将编写以下内容：

[PRE74]

因此，代码被重写如下：

[PRE75]

#### 注意

运算符重载可以通过两种方式实现：要么作为成员函数，要么作为非成员函数。这两种方式最终会产生相同的效果。

### 活动11：对点对象进行排序

在 2D 地图应用中，我们希望能够按照从西南到东北的顺序显示用户保存的位置：为了能够按顺序显示位置，我们需要能够按照这种顺序对表示位置的点进行排序。

记住，`x` 坐标代表沿着西东轴的位置，而 `y` 坐标代表沿着南北轴的位置。

在现实场景中，为了比较两个点，我们需要比较它们的 `x` 和 `y` 坐标。要在代码中这样做，我们需要为 `Point` 类重载 `<` 操作符。我们定义的这个新函数返回一个 `bool`，根据 `p_1` 和 `p_2` 的顺序返回 `true` 或 `false`。

如果 `p_1` 的 `x` 坐标小于 `p_2` 的 `x` 坐标，则 `p_1` 点在顺序上比 `p_2` 点更早。如果它们相等，则需要比较它们的 `y` 坐标。

让我们执行以下步骤：

1.  我们需要为之前定义的 `Point` 类添加一个 `<` 操作符的重载，该重载接受另一个类型为 `Point` 的对象作为参数，并返回一个 `bool`，指示该对象是否小于提供的参数，使用之前定义的比较两个点的方法：

1.  在这一点上，我们能够比较两个 `Point` 对象：

1.  由于在我们的示例中，`p_1.x` 被初始化为 `1`，而 `p_2.x` 被初始化为 `2`，比较的结果将是 `true`，这表明 `p_1` 在顺序上比 `p_2` 更早。

    #### 注意

    本活动的解决方案可以在第 293 页找到。

## 介绍 Functors

`operator()` 函数也被称为 **函数调用操作符**。

定义 `functor` 所使用的语法如下：

[PRE76]

函数调用操作符有一个返回类型，并可以接受任何类型和数量的参数。要调用对象的函数调用操作符，我们可以写出对象的名字，然后是包含传递给操作符的参数的括号。你可以想象，提供了一个调用操作符的对象可以像使用函数一样使用。以下是一个 `functor` 的例子：

[PRE77]

它们在可以传递一个具有 `operator()` 定义的对象到接受该对象的算法模板的地方特别有用。这利用了代码的可重用性和可测试性。我们将在第 5 章讨论 **lambda** 时了解更多。

以下是一个简单的 `functor` 示例，它在字符串末尾添加一个新行之前打印一个字符串：

[PRE78]

### 活动 12：实现 Functors

编写一个函数对象，它在构造时接受一个数字，并定义一个操作符调用，该调用接受另一个数字并返回两个数字的和。

让我们执行以下步骤以实现所需的输出：

1.  定义一个名为 `AddX` 的类，它由一个类型为 `int` 的 `private` 数据成员和一个用于初始化它的构造函数组成。

1.  通过调用操作符`operator()`扩展它，该操作符接受一个`int`类型的参数并返回一个`int`。函数体内的实现应该返回先前定义的`x`值与函数参数`y`的和。

1.  实例化我们刚刚定义的类的对象并调用调用操作符：

    [PRE79]

    #### 注意

    该活动的解决方案可以在第294页找到。

## 摘要

在本章中，我们看到了如何在C++中使用类概念。我们首先阐述了使用类的优点，描述了它们如何帮助我们创建强大的抽象。

我们概述了类可以使用哪些访问修饰符来控制谁可以访问类的字段和方法。

我们继续探讨类与其实例之间的概念差异，以及这在对静态字段和静态方法实现时产生的含义。

我们看到了构造函数是如何用于初始化类及其成员的，而析构函数则是用于清理由类管理的资源。

我们随后探讨了如何结合构造函数和析构函数来实现C++著名的RAII（资源获取即初始化）范式。我们展示了RAII如何使创建处理资源并使程序更安全、更易于工作的类变得简单。

最后，我们介绍了操作符重载的概念以及如何使用它来创建与内置类型一样易于使用的类。

在下一章中，我们将重点关注模板。我们将主要探讨如何实现模板函数和类，并编写适用于多种类型的代码。
