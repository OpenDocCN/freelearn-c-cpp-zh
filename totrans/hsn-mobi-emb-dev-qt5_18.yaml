- en: Universal Platform for Mobiles and Embedded Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications and targeting all the different platforms can take heaps
    of time and cost thousands of dollars. There's a new target platform for Qt applications
    called Qt for WebAssembly that allows Qt and Qt Quick apps to be run over a network
    from a web browser. You will learn how to set up, cross build, deploy, and run
    Qt applications that work on any device with a modern web browser. You could say
    that Qt for WebAssembly is the universal platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will detail the following material:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building with Qt Creator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying for mobile and embedded devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips, tricks and suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is this WebAssembly thing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly is neither strictly Web nor Assembly. At the same time, it is a
    little of both.
  prefs: []
  type: TYPE_NORMAL
- en: At the technical level, it is a new binary instruction format for a stack-based
    virtual machine, according to the WebAssembly web site at [http://webassembly.org](http://webassembly.org).
    It runs in a modern web browser, but people are naturally experimenting with this
    and it can now run standalone and experimentally like any other app, with support
    being written for the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of the Emscripten tool, it can be compiled from C and C++. Emscripten
    is a tool written in Python that uses LLVM to transpile C++ code into WebAssembly
    byte code that can be loaded by a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly byte code runs in the same sandbox as JavaScript, so consequentially
    it has the same limitations regarding access to the local file system, as well
    as living in one thread. It also has the same security benefits. Although there
    is work being done to fully support pthreads, it is, at the time of this writing,
    still experimental.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Easy install binary SDK from the following Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten sdk [https://github.com/emscripten-core/emscripten.git](https://github.com/emscripten-core/emscripten.git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, manually compile the SDK. You can download the sources from
    these Git URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten [https://github.com/emscripten-core/emscripten.git](https://github.com/emscripten-core/emscripten.git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binaryen [https://github.com/WebAssembly/binaryen.git](https://github.com/WebAssembly/binaryen.git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LLVM [https://github.com/llvm/llvm-project.git](https://github.com/llvm/llvm-project.git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Emscripten website at [https://emscripten.org/:](https://emscripten.org/)
  prefs: []
  type: TYPE_NORMAL
- en: '*Emscripten is a toolchain that uses LLVM to transpile code to WebAssembly
    to run in a web browser at near native speeds.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the two ways to install Emscripten:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository, install precompiled binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repositories, build them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend the first one, as LLVM is very time-consuming to build. It is also
    recommended to use Linux or macOS. If you are on Windows, you can install the
    Linux subsystem and use that, or use MinGW compiler. The Visual Studio compiler
    does not seem to support output targets with the four-letter extensions that Emscripten
    outputs, namely `.wasm` and `.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Download Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to have Git and Python installed for this—just clone the `emscripten
    sdk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In there, are Python scripts to help out, the most important one being `emsdk`.
  prefs: []
  type: TYPE_NORMAL
- en: First run `./emsdk --help` to print out some documentation on how to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to install and then activate the SDK as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can target a specific SDK; you can see what is available by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install a particular version of the SDK by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `activate` command sets up the `~/.emscripten` file that contains the environment
    settings needed by Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able build with it, you need to source the `emsdk_env.sh` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Qt targets a certain Emscripten version that is known to be good for that version.
    For Qt 5.11, Qt for WebAssembly has its own branch—`wip/webassembly`. It has been
    integrated into 5.12 as a tech preview, and in 5.13 for official support. At the
    time of this writing, it is planned to be included with Qt Creator as a binary
    install.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Emscripten SDK manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to build Emscripten manually, such as to compile upstream LLVM which
    has support for transpiling directly to WebAssembly binary instead of writing
    first to JavaScript and then to WebAssembly. This can speed up compile times,
    but, at the time of this writing, is still experimental. This makes use of adding
    an argument to the linker `-s WASM_OBJECT_FILES=1`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on using `WASM_OBJECT_FILES`, see [https://github.com/emscripten-core/emscripten/issues/6830](https://github.com/emscripten-core/emscripten/issues/6830).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to install `node.js` and `cmake` packages from your OS. Clone
    the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Emscripten does not have to be built, as it is written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build `binaryen`, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To build LLVM, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `emscripten` to write the configure file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `~/.emscripten` file. Copy this file over to your `emsdks`
    directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up the environment, write a script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save it somewhere as `emsdk-env.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to make this executable, so run `chmod +x emsdk-env.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you need to set up the build environment, simply run this script and
    use the same console to build.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are ready, let's see how to configure and build Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and compiling Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find information on Qt for WebAssembly at this URL: [https://wiki.qt.io/Qt_for_WebAssembly](https://wiki.qt.io/Qt_for_WebAssembly)
  prefs: []
  type: TYPE_NORMAL
- en: I guess we need the sources. You can get them through Qt Creator, or you can
    `git clone` the repository. Using Git, you have more control over which version
    and any branch if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For 5.12 and 5.13, you can simply clone the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can `clone` this tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with any new technology, it is moving fast, so grab the latest version you
    can. For this book, we are using Qt 5.12, but I included mentioning other versions
    as they have many bug fixes and optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can configure and compile Qt!
  prefs: []
  type: TYPE_NORMAL
- en: 'For 5.12 and 5.13 it was simplified to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you need threads, 5.13 has support for multithreading WebAssembly, but you
    also need to configure the browser to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Once it configures, all you need to do is run make!
  prefs: []
  type: TYPE_NORMAL
- en: Then, to build your Qt app for running in a web browser, simply use the `qmake` command
    from the build directory and run it on your apps pro file. Not every Qt feature
    is supported—like local filesystem access and threads. `QOpenGLWidget` is also
    not supported, although `QOpenGLWindow` works fine. Let's see how to build using
    then command line.
  prefs: []
  type: TYPE_NORMAL
- en: Building with the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a Qt for a WebAssembly application requires you to source the Emscripten
    environment file, so run this in your console command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add the path to Qt for WebAssembly `qmake` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you must replace `/path/to` with the actual filesystem path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are then ready for action! You build it just like any other Qt app, by
    running `qmake` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to debug, rerun `qmake` with `CONFIG+=debug` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will add various Emscripten specific arguments to the compiler and linker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is built, you can run it by using the `emrun` command from Emscripten,
    which will start a simple web server and serve the `<target>.html` file. This
    will, in turn, load up `qtloader.js`, which, in turn, loads up the `<target>.js`
    file, which loads the `<target>.wasm` binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also give `emrun` the directory, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This gives you time to bring up the browser's web console for debugging. Now,
    let's see how to use Qt creator for building.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Qt Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to use Qt Creator to build and run your Qt app once you have
    compiled Qt itself from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The Build environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Qt Creator, navigate to Tools | Options... | Kits
  prefs: []
  type: TYPE_NORMAL
- en: Then go to the Compilers tab. You need to add `emcc` as a C compiler, and `em++`
    as a C++ compiler, so click on the Add button and select Custom from the drop-down
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'First select C and add the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `emcc (1.38.16)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler path: `/home/user/emsdk/emscripten/1.38.16/emcc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make path: `/usr/bin/make`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ABI: `x86 linux unknown elf 64bit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt mkspecs: `wasm-emscripten`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select C++ and add the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: `emc++(1.38.16)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler path: `/home/user/emsdk/emscripten/1.38.16/em++`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make path: `/usr/bin/make`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ABI: `x86 linux unknown elf 64bit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt mkspecs: `wasm-emscripten`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Apply.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the tab labeled Qt Versions and click on the Add button. Navigate to where
    you build Qt for WebAssembly, and, in the `bin` directory, select the qmake. Click
    Apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the tab labeled Kits, and click on the Add button. Add the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: Name: `Qt %{Qt:Version} (qt5-wasm)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compiler: `C: emcc (1.38.16`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compile: `C++: em++ (1.38.16)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt version: `Qt (qt5-wasm)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Run environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to make your application's project active to build for Qt for WebAssembly.
    From the left-hand side buttons in Qt Creator, select Projects, and select your
    Qt for WebAssembly kit.
  prefs: []
  type: TYPE_NORMAL
- en: Running the WebAssembly apps in Qt Creator is currently a bit tricky, as you
    need to specify `emrun` as a custom executable and then the build directory or
    `<target>.html` file as its argument. You can also specify which browser to run.
    You can run Chrome using the `--browser chrome argument`.
  prefs: []
  type: TYPE_NORMAL
- en: To get a list of found browsers, run the command `emrun --list_browsers`.
  prefs: []
  type: TYPE_NORMAL
- en: You can even run the app in an Android device that is connected to a USB using
    the `--android` argument. You need to have **Android Debug Bridge** (**adb**) command
    installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, now that we know how to run the app, we need to tell the Qt Creator
    project to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Projects | Run. In the Run section, select Add | Custom Executable and
    add the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executable: `/home/user/emsdk/emrun <target>.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working directory: `%{buildDir}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we are ready to build and run. Here is how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0993db3c-14f7-43b0-b7d7-988382dca979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can even run OpenGL apps! Here is the `hellogles3` example from Qt running
    in the Firefox browser on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/787ad667-750d-4c79-979b-a00035465efb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also run declarative apps! Here is Qt Quick''s `qopenglunderqml` example
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a3c9d8-4ab8-4914-b5b6-c7010ce5e66f.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying for mobile and embedded devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Really, deploying for mobile and embedded devices is only copying the resulting
    files from Emscripten built onto a CORS-enabled web server.
  prefs: []
  type: TYPE_NORMAL
- en: Any web browser that supports WebAssembly will be able to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are considerations regarding screen size.
  prefs: []
  type: TYPE_NORMAL
- en: For testing, you can run your application using the `emrun` command from the
    Emscripten SDK. If you plan on testing from another device other than localhost,
    you will need to use the `--hostname` argument to set the IP address that it uses.
  prefs: []
  type: TYPE_NORMAL
- en: There are Python scripts for CORS-enabled web servers for testing as well. The
    Apache web server can also be configured to support CORS.
  prefs: []
  type: TYPE_NORMAL
- en: There are five files that currently need to be deployed—`qtloader.js`, `qtlogo.svg`,
    `<target>.html`, `<target>.js`, and `<target>.wasm`. The `.wasm` file is the big
    WebAssembly binary, statically linked. Following are few suggestions to help you
    along with the process.
  prefs: []
  type: TYPE_NORMAL
- en: Tips, tricks, and suggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt for WebAssembly is treated by Qt as a cross platform build. It is an emerging
    technology and, as such, some features required may need special settings configuration
    to be changed or enabled. There are a few things you need to keep in mind when
    using it as a target.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I run through some tips regarding Qt for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All major browsers now have support for loading WebAssembly. Firefox seems to
    load fastest, although Chrome has a configuration that can be set to speed it
    up (look at `chrome://flags for #enable-webassembly-baseline`). Mobile browsers
    that come with Android and iOS also work, although these may run into out of memory
    errors, depending on the application being run.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 5.13 for WebAssembly has added experimental support for threads, which rely
    `onSharedArrayBuffer` support in the browsers. This has been turned off by default,
    due to Spectre vulnerabilities, and need to be enabled in the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome, navigate to `chrome://flags` and enable `#enable-webassembly-threads`.
  prefs: []
  type: TYPE_NORMAL
- en: In Firefox, navigate to `about://config` and enable `javascript.options.shared.memory`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging is done by using the debugging console in the web browser. Extra
    debugging capabilities can be enabled by invoking `qmake` with `CONFIG+=debug`,
    even with a Qt compiled in release mode. Here is what a crash can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4f39e1f-2c55-4d87-89f0-8f969d470f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also remote debug from your phone and see the remote browser''s JavaScript
    console output on your desktop. See the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging](https://developer.mozilla.org/en-US/docs/Tools/Remote_Debugging)'
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simple download requests can be made with the usual `QNetworkAccessManager`.
    These will go through `XMLNetworkRequest`, and will require a CORS-enabled server
    to download from. Typical `QTCPSocket` and `QUdpSockets` get transpiled into WebSockets.
    Your web server needs to support WebSockets, or you can use the Websockify tool,
    which is available from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/novnc/websockify](https://github.com/novnc/websockify)'
  prefs: []
  type: TYPE_NORMAL
- en: Fonts and filesystem access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System fonts cannot be accessed, and must be included and embedded into the
    application. Qt embeds one font.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem access is also not currently supported, but will be in the future
    by using a Qt WebAssembly specific API.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL is supported as OpenGL ES2, which gets transpiled into WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few differences between OpenGL ES2 and WebGL that you should be
    aware of if you plan on using OpenGL in your WebAssembly application. WebGL is
    more strict generally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the differences for WebGL:'
  prefs: []
  type: TYPE_NORMAL
- en: A buffer may only be bound to one `ARRAY_BUFFER` or `ELEMENT_ARRAY_BUFFER` in
    it's lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No client side `Arrays`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No binary shaders, `ShaderBinary`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces `offset` for `drawElements`; `vertexAttribPointer` and `stride` arguments
    for `vertexAttribPointer` are a multiple of the size of the data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawArrays` and `drawElements` are restricted from requesting data outside
    the bounds of a buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds `DEPTH_STENCIL_ATTACHMENT` and `DEPTH_STENCIL`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`texImage2D` and `texSubImage2D` size based on the `TexImageSource` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copyTexImage2D`, `copyTexSubImage2D` and `readPixels` cannot touch pixels
    outside of `framebuffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stencil testing and bound `framebuffer` have restricted drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertexAttribPointer` value must not exceed the value 255'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zNear` cannot be greater than `zFar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: constant color and constant alpha cannot be used with `blendFunc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no support for `GL_FIXED`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compressedTexImage2D` and `compressedTexSubImage2D` are not supported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLSL token size limited to 256 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLSL is ASCII characters only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLSL limited to 1 level of nested structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform and attribute location lengths limited to 256 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO_LOG_LENGTH`, `SHADER_SOURCE_LENGTH`, `ACTIVE_UNIFORM_MAX_LENGTH`, and
    `ACTIVE_ATTRIBUTE_MAX_LENGTH` have been removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture type passed to `texSubImage2D` must match `texImage2D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls that `read` and `write` to same texture (feedback loop) not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from missing attachment is not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute aliasing not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ​`gl_Position` initial value defined as (0,0,0,0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information, see the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: WebGL 1.0 [https://www.khronos.org/registry/webgl/specs/latest/1.0/#6](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6)
  prefs: []
  type: TYPE_NORMAL
- en: WebGL 2.0 [https://www.khronos.org/registry/webgl/specs/latest/2.0/#5](https://www.khronos.org/registry/webgl/specs/latest/2.0/#5)
  prefs: []
  type: TYPE_NORMAL
- en: Supported Qt modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt for WebAssembly supports the following Qt modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qtbase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtdeclarative`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtquickcontrols2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtwebsockets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtmqtt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtsvg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtcharts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qtgraphicaleffects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secondary event loops do not work in Qt for Webassembly. This is because the
    Emscripten event loop it needs to tie in to does not return. If you need to pop
    up a dialog, do not call `exec()` but call `show()`, and use signals to get a
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual keyboards on mobile platforms like Android and iOS do not automatically
    pop up. You can use Qt Virtual Keyboard directly in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt for WebAssembly is a new and upcoming platform for Qt, which runs Qt apps
    in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to download or build the Emscripten SDK, and use to build
    Qt for WebAssembly. You can now run Qt apps in a web browser, including mobile
    and embedded devices, as long as the browser supports WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we explore building a complete Linux embedded operating
    system.
  prefs: []
  type: TYPE_NORMAL
