<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor166"/>6</h1>
<h1 id="_idParaDest-155"><a id="_idTextAnchor167"/>Building the C++ Matching Engine</h1>
<p>We spent the last chapter discussing the design of the electronic trading ecosystem we will build in this book. The first component we will start with is the matching engine at the exchange. In this chapter, we will focus on the task of building the order book of the exchange matching engine, based on orders that clients enter. We will implement the various data structures and algorithms needed to track these orders, perform matching when orders <em class="italic">cross</em> each other, and update the order book. <em class="italic">Crossing</em> means when a buy order has a price equal to or greater than a sell order and then can execute against each other, but we will discuss this in greater detail in this chapter. We will focus on achieving the lowest latencies possible in these operations, since the exchanges with the best infrastructure are likely to do the most business and be preferred by participants. For now, we will not worry about the details of the market data publisher and order gateway server components at the trading exchange.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Defining the operations and interactions in our matching engine</li>
<li>Building the matching engine and exchanging external data</li>
<li>Building the order book and matching orders</li>
</ul>
<p>We will kick off this chapter by first clarifying some assumptions we will make to simplify the matching engine and limit the scope of what we can cover in this book. We will also define some types, constants, and basic structures in the first section.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor168"/>Technical requirements</h1>
<p>All the code for this book can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</a>. The source code for this chapter is in the <code>Chapter6</code> directory in the repository.</p>
<p>It is important that you have read and understand the design of the electronic trading ecosystem presented in the <em class="italic">Designing Our Trading Ecosystem</em> chapter. Note that in this chapter, we will also use the code we built in <a href="B19434_04.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Building the C++ Building Blocks for Low Latency Applications</em>, which can be found in the <code>Chapter6/common/</code> directory in the GitHub repository for this book.</p>
<p>The specifications of the environment in which the source code for this book was developed are shown as follows. We present the details of this environment because all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in your environment:</p>
<ul>
<li>OS: <code>Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </code><code>x86_64 GNU/Linux.</code></li>
<li>GCC: <code>g++ (Ubuntu </code><code>11.3.0-1ubuntu1~22.04.1) 11.3.0.</code></li>
<li>CMake: <code>cmake </code><code>version 3.23.2.</code></li>
<li>Ninja: <code>1.10.2.</code></li>
</ul>
<h1 id="_idParaDest-157"><a id="_idTextAnchor169"/>Defining the operations and interactions in our matching engine</h1>
<p>Here, we will declare <a id="_idIndexMarker867"/>and define the types, constants, and structures we will need as we build the matching engine in this chapter.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor170"/>Defining some types and constants</h2>
<p>Let us define a few common typedefs to document the types we will use in the rest of this book. We will also define some constants to represent some assumptions that exist, purely for the purpose of simplifying the design of our matching engine. Note that you don’t need these limits/constants, and we leave this enhancement up to the interested among you. All the code for this subsection can be found in the <code>Chapter6/common/types.h</code> file in the GitHub repository for this book.</p>
<h3>Defining a few basic types</h3>
<p>We will define some <a id="_idIndexMarker868"/>types to hold different attributes in our electronic trading system, such as the following:</p>
<ul>
<li><code>OrderId</code> to identify orders</li>
<li><code>TickerId</code> to identify trading instruments</li>
<li><code>ClientId</code> for the exchange to identify different clients</li>
<li><code>Price</code> to hold prices for instruments</li>
<li><code>Qty</code> to hold quantity values for orders</li>
<li><code>Priority</code> to capture the position of an order in the <strong class="bold">First In First Out</strong> (<strong class="bold">FIFO</strong>) queue at a price level, as discussed in the <em class="italic">Designing Our Trading </em><em class="italic">Ecosystem </em>chapter.</li>
<li><code>Side</code> to signify the side (buy/sell) of an order</li>
</ul>
<p>We will also provide basic methods to convert these to strings purely for logging purposes. Let us look at each one of these code blocks to understand the declarations next:</p>
<pre class="source-code">
#pragma once
#include &lt;cstdint&gt;
#include &lt;limits&gt;
#include "common/macros.h"</pre>
<p>First, we <a id="_idIndexMarker869"/>define the <code>OrderId</code> type to identify orders, which is simply <code>uint64_t</code>, and a corresponding <code>orderIdToString()</code> method to log it. We also add a <code>OrderId_INVALID</code> sentinel method to signify invalid values:</p>
<pre class="source-code">
namespace Common {
  typedef uint64_t OrderId;
  constexpr auto OrderId_INVALID =
    std::numeric_limits&lt;OrderId&gt;::max();
  inline auto orderIdToString(OrderId order_id) -&gt;
    std::string {
    if (UNLIKELY(order_id == OrderId_INVALID)) {
      return "INVALID";
    }
    return std::to_string(order_id);
  }</pre>
<p>We define the <code>TickerId</code> type to identify trading instruments, which is simply a <code>uint32_t</code> type, and add a <a id="_idIndexMarker870"/>corresponding <code>tickerIdToString()</code> method <a id="_idIndexMarker871"/>for it. We have a <code>TickerId_INVALID</code> sentinel value for invalid instruments:</p>
<pre class="source-code">
  typedef uint32_t TickerId;
  constexpr auto TickerId_INVALID =
    std::numeric_limits&lt;TickerId&gt;::max();
  inline auto tickerIdToString(TickerId ticker_id) -&gt;
    std::string {
    if (UNLIKELY(ticker_id == TickerId_INVALID)) {
      return "INVALID";
    }
    return std::to_string(ticker_id);
  }</pre>
<p>The <code>ClientId</code> type is <a id="_idIndexMarker872"/>used to differentiate between different <a id="_idIndexMarker873"/>trading participants. The <code>ClientId_INVALID</code> value represents an invalid sentinel. The <code>clientIdToString()</code> method is used for logging purposes:</p>
<pre class="source-code">
  typedef uint32_t ClientId;
  constexpr auto ClientId_INVALID =
    std::numeric_limits&lt;ClientId&gt;::max();
  inline auto clientIdToString(ClientId client_id) -&gt;
    std::string {
    if (UNLIKELY(client_id == ClientId_INVALID)) {
      return "INVALID";
    }
    return std::to_string(client_id);
  }</pre>
<p>The next type is <code>Price</code>, which is <a id="_idIndexMarker874"/>used to capture prices on orders. We also add a <code>Price_INVALID</code> constant to represent invalid prices. Finally, a <code>priceToString()</code> method to <em class="italic">stringify</em> these values:</p>
<pre class="source-code">
  typedef int64_t Price;
  constexpr auto Price_INVALID =
    std::numeric_limits&lt;Price&gt;::max();
  inline auto priceToString(Price price) -&gt; std::string {
    if (UNLIKELY(price == Price_INVALID)) {
      return "INVALID";
    }
    return std::to_string(price);
  }</pre>
<p>The <code>Qty</code> type is <code>typedef</code> for <code>uint32_t</code> and represents order quantities. We also provide <a id="_idIndexMarker875"/>the usual <code>Qty_INVALID</code> sentinel and the <code>qtyToString()</code> method <a id="_idIndexMarker876"/>to convert them to strings:</p>
<pre class="source-code">
  typedef uint32_t Qty;
  constexpr auto Qty_INVALID =
    std::numeric_limits&lt;Qty&gt;::max();
  inline auto qtyToString(Qty qty) -&gt; std::string {
    if (UNLIKELY(qty == Qty_INVALID)) {
      return "INVALID";
    }
    return std::to_string(qty);
  }</pre>
<p>The <code>Priority</code> type is just a <a id="_idIndexMarker877"/>position in the queue of type <code>uint64_t</code>. We assign the <code>Priority_INVALID</code> sentinel value and the <code>priorityToString()</code> method:</p>
<pre class="source-code">
  typedef uint64_t Priority;
  constexpr auto Priority_INVALID =
    std::numeric_limits&lt;Priority&gt;::max();
  inline auto priorityToString(Priority priority) -&gt;
    std::string {
    if (UNLIKELY(priority == Priority_INVALID)) {
      return "INVALID";
    }
    return std::to_string(priority);
  }</pre>
<p>The <code>Side</code> type is an enumeration <a id="_idIndexMarker878"/>and contains two valid values, as shown in the following code block. We <a id="_idIndexMarker879"/>also define a <code>sideToString()</code> method, as we did for the other types previously:</p>
<pre class="source-code">
  enum class Side : int8_t {
    INVALID = 0,
    BUY = 1,
    SELL = -1
  };
  inline auto sideToString(Side side) -&gt; std::string {
    switch (side) {
      case Side::BUY:
        return "BUY";
      case Side::SELL:
        return "SELL";
      case Side::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }
}</pre>
<p>Those are all the <a id="_idIndexMarker880"/>basic types we need for this chapter. Next, we will define some limits to simplify the design of our system.</p>
<h3>Defining some limits and constraints</h3>
<p>We will define the <a id="_idIndexMarker881"/>following constant limits:</p>
<ul>
<li><code>LOG_QUEUE_SIZE</code> represents the size of the lock-free queue used by the logger. This holds the maximum number of characters that can be held in memory without the logger queue being full.</li>
<li><code>ME_MAX_TICKERS</code> represents the number of trading instruments the exchange supports.</li>
<li><code>ME_MAX_CLIENT_UPDATES</code> holds the maximum number of unprocessed order requests from all clients that the matching engine has not processed yet. This also represents the maximum number of order responses from the matching engine that the order server has not published yet.</li>
<li><code>ME_MAX_MARKET_UPDATES</code> represents the maximum number of market updates generated by the matching engine that have not yet been published by the market data publisher.</li>
<li><code>ME_MAX_NUM_CLIENTS</code> holds how many maximum simultaneous market participants can exist in our trading ecosystem.</li>
<li><code>ME_MAX_ORDER_IDS</code> is the maximum number of orders possible for a single trading instrument.</li>
<li><code>ME_MAX_PRICE_LEVELS</code> represents the maximum depth of price levels for the limit order book that the matching engine maintains.</li>
</ul>
<p>Note that these <a id="_idIndexMarker882"/>values have been chosen arbitrarily here; these can be increased or decreased, depending on the capacity of the system on which we run the electronic trading ecosystem. We chose powers of two to enable the possibility of using shifts over multiplies when trying to compute addresses; however, the effect is negligible on modern processors, and we would not recommend worrying about this too much. The source for the constants we described previously is presented here:</p>
<pre class="source-code">
namespace Common {
  constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;
  constexpr size_t ME_MAX_TICKERS = 8;
  constexpr size_t ME_MAX_CLIENT_UPDATES = 256 * 1024;
  constexpr size_t ME_MAX_MARKET_UPDATES = 256 * 1024;
  constexpr size_t ME_MAX_NUM_CLIENTS = 256;
  constexpr size_t ME_MAX_ORDER_IDS = 1024 * 1024;
  constexpr size_t ME_MAX_PRICE_LEVELS = 256;
}</pre>
<p>These are all the constants we require for now. Now, we can shift our attention to more complex structures that we will need inside the matching engine.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor171"/>Designing the matching engine</h2>
<p>We will need a <a id="_idIndexMarker883"/>few structures for our matching engine to communicate with the market data publisher and order server components.</p>
<h3>Defining the MEClientRequest and ClientRequestLFQueue types</h3>
<p>The <code>MEClientRequest</code> structure is used by the order server to forward order requests from the <a id="_idIndexMarker884"/>clients to the matching engine. Remember <a id="_idIndexMarker885"/>that the communication <a id="_idIndexMarker886"/>from the order server <a id="_idIndexMarker887"/>to the matching engine is established through the lock-free queue component we built earlier. <code>ClientRequestLFQueue</code> is a typedef for a lock-free queue of <code>MEClientRequest</code> objects. The code for this structure can be found in the <code>Chapter6/order_server/client_request.h</code> file in the GitHub repository:</p>
<pre class="source-code">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {</pre>
<p>Note two things here – we use the <code>#pragma pack()</code> directive to make sure these structures are packed and do not contain any extra padding. This is important because these will be sent and received over a network as flat binary structures in later chapters. We also define a <code>ClientRequestType</code> enumeration to define what type of order request it is – whether it is a new order or a cancel request for an existing order. We also define an <code>INVALID</code> sentinel value and a <code>clientRequestTypeToString()</code> method to <a id="_idIndexMarker888"/>convert this enumeration into human-readable <a id="_idIndexMarker889"/>strings:</p>
<pre class="source-code">
#pragma pack(push, 1)
  enum class ClientRequestType : uint8_t {
    INVALID = 0,
    NEW = 1,
    CANCEL = 2
  };
  inline std::string
    clientRequestTypeToString(ClientRequestType type) {
    switch (type) {
      case ClientRequestType::NEW:
        return "NEW";
      case ClientRequestType::CANCEL:
        return "CANCEL";
      case ClientRequestType::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }</pre>
<p>Now, we can <a id="_idIndexMarker890"/>define the <code>MEClientRequest</code> structure, which <a id="_idIndexMarker891"/>will contain information for a single order request from the trading participant to the exchange. Note that this is the internal representation that the matching engine uses, not necessarily the exact format that the client sends. We will look at that in the next chapter, <em class="italic">Communicating with Market Participants</em>. The important members of this struct are the following:</p>
<ul>
<li>A <code>type_</code> variable of type <code>ClientRequestType</code></li>
<li>The <code>client_id_</code> variable of type <code>ClientId</code> of the trading client that sent this request</li>
<li>A <code>ticker_id_</code> variable of type <code>TickerId</code> of the instrument for which this request is meant</li>
<li><code>OrderId</code> (<code>order_id_</code>) of the order for which this request is made, which can be a new order or reference an existing order</li>
<li><code>Side</code> of the order in the <code>side_</code> variable</li>
<li><code>Price</code> of the <a id="_idIndexMarker892"/>order in the <code>price_</code> variable</li>
<li><code>Qty</code> of the order <a id="_idIndexMarker893"/>saved in the <code>qty_</code> variable</li>
</ul>
<p>Additionally, we <a id="_idIndexMarker894"/>will also add a simple <code>toString()</code> method <a id="_idIndexMarker895"/>to help us later on with logging, as shown here:</p>
<pre class="source-code">
  struct MEClientRequest {
    ClientRequestType type_ = ClientRequestType::INVALID;
    ClientId client_id_ = ClientId_INVALID;
    TickerId ticker_id_ = TickerId_INVALID;
    OrderId order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MEClientRequest"
         &lt;&lt; " ["
         &lt;&lt; "type:" &lt;&lt; clientRequestTypeToString(type_)
         &lt;&lt; " client:" &lt;&lt; clientIdToString(client_id_)
         &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
         &lt;&lt; " oid:" &lt;&lt; orderIdToString(order_id_)
         &lt;&lt; " side:" &lt;&lt; sideToString(side_)
         &lt;&lt; " qty:" &lt;&lt; qtyToString(qty_)
         &lt;&lt; " price:" &lt;&lt; priceToString(price_)
         &lt;&lt; "]";
      return ss.str();
    }
  };</pre>
<p>As discussed <a id="_idIndexMarker896"/>previously, we also define the <code>ClientRequestLFQueue</code> typedef <a id="_idIndexMarker897"/>to represent the lock-free queue of <a id="_idIndexMarker898"/>these structures, as <a id="_idIndexMarker899"/>shown in the following code snippet. The <code>#pragma pack(pop)</code> simply restores the alignment setting to the default – that is, not tightly packed (which we had set by specifying the <code>#pragma pack(push, 1)</code> directive). This is because we only want to tightly pack the structures that will be sent over a network and no others:</p>
<pre class="source-code">
#pragma pack(pop)
  typedef LFQueue&lt;MEClientRequest&gt; ClientRequestLFQueue;
}</pre>
<p>We will define a similar structure used by the matching engine that sends order responses to the order server component. Let us look at that in the next subsection.</p>
<h3>Defining the MEClientResponse and ClientResponseLFQueue types</h3>
<p>Let us present <a id="_idIndexMarker900"/>the implementation <a id="_idIndexMarker901"/>of the structure used <a id="_idIndexMarker902"/>by the matching engine that sends <a id="_idIndexMarker903"/>order responses for the order server component to dispatch to clients. Similar to the last section, we will also define <code>ClientResponseLFQueue</code>, which is a lock-free queue of the <code>MEClientResponse</code> objects. The code for this structure is available in the <code>Chapter6/order_server/client_response.h</code> source file in the GitHub repository:</p>
<pre class="source-code">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {</pre>
<p>First, we will define a <code>ClientResponseType</code> enumeration to represent the type of response for client orders. In addition to the <code>INVALID</code> sentinel value, it contains values that represent when a request for a new order is accepted, an order is canceled, an order is executed, or a cancel request is rejected by the matching engine. We also add the <code>clientResponseTypeToString()</code> method to convert the <code>ClientResponseType</code> values to strings:</p>
<pre class="source-code">
#pragma pack(push, 1)
  enum class ClientResponseType : uint8_t {
    INVALID = 0,
    ACCEPTED = 1,
    CANCELED = 2,
    FILLED = 3,
    CANCEL_REJECTED = 4
  };
  inline std::string
    clientResponseTypeToString(ClientResponseType type) {
    switch (type) {
      case ClientResponseType::ACCEPTED:
        return "ACCEPTED";
      case ClientResponseType::CANCELED:
        return "CANCELED";
      case ClientResponseType::FILLED:
        return "FILLED";
      case ClientResponseType::CANCEL_REJECTED:
        return "CANCEL_REJECTED";
      case ClientResponseType::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }</pre>
<p>Finally, we define the <code>MEClientResponse</code> message used internally by the matching engine to communicate <a id="_idIndexMarker904"/>order response messages <a id="_idIndexMarker905"/>for the trading clients when <a id="_idIndexMarker906"/>there are updates to the <a id="_idIndexMarker907"/>client’s orders. Before we look at the source code, the important data members in this struct are listed as follows:</p>
<ul>
<li>A <code>ClientResponseType type_</code> variable to represent the type of the client response.</li>
<li>A <code>client_id_</code> variable of type <code>ClientId</code> to represent which market participant the response message is meant for.</li>
<li>The <code>ticker_id_</code> variable of type <code>TickerId</code> to represent the trading instrument of this response.</li>
<li>A <code>client_order_id_</code> variable that identifies <code>OrderId</code> of the order this response message affects. This <code>OrderId</code> is the one that the client sent in the original <code>MEClientRequest</code> message for the order.</li>
<li>A <code>market_order_id_</code> variable, also of type <code>OrderId</code>, but this one identifies this order in the public market data stream. This <code>OrderId</code> is unique across all market participants, since it is possible for different market participants to send orders with the same <code>client_order_id_</code> value. Even in those cases, two orders with the same <code>client_order_id_</code> will have different <code>market_order_id_</code> values in their responses. This <code>market_order_id_</code> value is also used when generating market updates for this order.</li>
<li>A <code>side_</code> variable of type <code>Side</code> to represent the side of this order response.</li>
<li><code>Price</code> of this client response update and whether it is accepted, canceled or executed.</li>
<li>An <code>exec_qty_</code> variable of type <code>Qty</code>, which is only used in the event of an order execution. This variable is used to hold how much quantity was executed in this <code>MEClientResponse</code> message. This value is not cumulative, meaning that when an order gets partially executed multiple times, a <code>MEClientResponse</code> message is generated for each individual execution and only contains the quantity executed in that particular execution, not across all of them.</li>
<li>A <code>leaves_qty_</code> variable, also of type <code>Qty</code>, which represents how much of the original order’s quantity is still live in the matching engine’s order book. This is used to communicate the size of this specific order in the book, which is still active for further possible executions.</li>
</ul>
<p>Finally, we also <a id="_idIndexMarker908"/>have our usual <code>toString()</code> method <a id="_idIndexMarker909"/>for easy logging purposes. The <a id="_idIndexMarker910"/>definition of <a id="_idIndexMarker911"/>the <code>MEClientResponse</code> structure, as discussed previously, is presented next:</p>
<pre class="source-code">
  struct MEClientResponse {
    ClientResponseType type_ = ClientResponseType::INVALID;
    ClientId client_id_ = ClientId_INVALID;
    TickerId ticker_id_ = TickerId_INVALID;
    OrderId client_order_id_ = OrderId_INVALID;
    OrderId market_order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty exec_qty_ = Qty_INVALID;
    Qty leaves_qty_ = Qty_INVALID;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MEClientResponse"
         &lt;&lt; " ["
         &lt;&lt; "type:" &lt;&lt; clientResponseTypeToString(type_)
         &lt;&lt; " client:" &lt;&lt; clientIdToString(client_id_)
         &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
         &lt;&lt; " coid:" &lt;&lt; orderIdToString(client_order_id_)
         &lt;&lt; " moid:" &lt;&lt; orderIdToString(market_order_id_)
         &lt;&lt; " side:" &lt;&lt; sideToString(side_)
         &lt;&lt; " exec_qty:" &lt;&lt; qtyToString(exec_qty_)
         &lt;&lt; " leaves_qty:" &lt;&lt; qtyToString(leaves_qty_)
         &lt;&lt; " price:" &lt;&lt; priceToString(price_)
         &lt;&lt; "]";
      return ss.str();
    }
  };
#pragma pack(pop)</pre>
<p>The <code>ClientResponseLFQueue</code> type definition is presented as follows, which represents a lock-free queue of the structures we discussed previously:</p>
<pre class="source-code">
  typedef LFQueue&lt;MEClientResponse&gt; ClientResponseLFQueue;
}</pre>
<p>That concludes the <a id="_idIndexMarker912"/>discussion of the structures <a id="_idIndexMarker913"/>we need to represent client <a id="_idIndexMarker914"/>requests and <a id="_idIndexMarker915"/>responses to and from the matching engine. Let us move on to the market update structure in the next subsection.</p>
<h3>Defining the MEMarketUpdate and MEMarketUpdateLFQueue types</h3>
<p>The market update <a id="_idIndexMarker916"/>structure is used by the matching engine <a id="_idIndexMarker917"/>to provide market data updates to <a id="_idIndexMarker918"/>the market data <a id="_idIndexMarker919"/>publishing component. We also have a <code>MEMarketUpdateLFQueue</code> type to represent a lock-free queue of the <code>MEMarketUpdate</code> objects. The code for this can be found in the <code>Chapter6/exchange/market_data/market_update.h</code> source file:</p>
<pre class="source-code">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Exchange {</pre>
<p>The <code>MEMarketUpdate</code> struct also needs to be a packed structure, since it will be part of the message that is sent and received over the network; hence, we use the <code>#pragma pack()</code> directive again. Before we define the struct, we need to define the <code>MarketUpdateType</code> enumeration that represents the update action in the market update for an order. In addition to taking on an <code>INVALID</code> sentinel value, it can also be used to represent events such as an order being added, modified, or canceled in the order book, as well as trade events in the market:</p>
<pre class="source-code">
#pragma pack(push, 1)
  enum class MarketUpdateType : uint8_t {
    INVALID = 0,
    ADD = 1,
    MODIFY = 2,
    CANCEL = 3,
    TRADE = 4
  };
  inline std::string
    marketUpdateTypeToString(MarketUpdateType type) {
    switch (type) {
      case MarketUpdateType::ADD:
        return "ADD";
      case MarketUpdateType::MODIFY:
        return "MODIFY";
      case MarketUpdateType::CANCEL:
        return "CANCEL";
      case MarketUpdateType::TRADE:
        return "TRADE";
      case MarketUpdateType::INVALID:
        return "INVALID";
    }
    return "UNKNOWN";
  }</pre>
<p>Finally, we <a id="_idIndexMarker920"/>define the <code>MEMarketUpdate</code> struct, which <a id="_idIndexMarker921"/>contains the following important <a id="_idIndexMarker922"/>data members:</p>
<ul>
<li>The <code>type_</code> variable <a id="_idIndexMarker923"/>of <code>MarketUpdateType</code> to represent the type of the market update.</li>
<li>An <code>order_id_</code> variable of type <code>OrderId</code> to represent the specific order in the limit order book for which this order update is applicable.</li>
<li>A <code>ticker_id_</code> variable of type <code>TickerId</code> to represent the trading instrument that this update applies to.</li>
<li>A <code>Side</code> variable to represent the side of this order.</li>
<li>A <code>Price</code> variable for the exact price of the order in this market order update.</li>
<li>A <code>priority_</code> field of type <code>Priority</code>, which, as we discussed before, will be used to specify the exact position of this order in the FIFO queue. We build a FIFO queue of all orders at the same price. This field specifies the position/location of this order in that queue.</li>
</ul>
<p>The complete <code>MEMarketUpdate</code> struct is <a id="_idIndexMarker924"/>shown in <a id="_idIndexMarker925"/>the following code block, along <a id="_idIndexMarker926"/>with the <code>MEMarketUpdateLFQueue</code> typedef, which <a id="_idIndexMarker927"/>captures a lock-free queue of <code>MEMarketUpdate</code> struct messages:</p>
<pre class="source-code">
  struct MEMarketUpdate {
    MarketUpdateType type_ = MarketUpdateType::INVALID;
    OrderId order_id_ = OrderId_INVALID;
    TickerId ticker_id_ = TickerId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    Priority priority_ = Priority_INVALID;
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MEMarketUpdate"
         &lt;&lt; " ["
         &lt;&lt; " type:" &lt;&lt; marketUpdateTypeToString(type_)
         &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
         &lt;&lt; " oid:" &lt;&lt; orderIdToString(order_id_)
         &lt;&lt; " side:" &lt;&lt; sideToString(side_)
         &lt;&lt; " qty:" &lt;&lt; qtyToString(qty_)
         &lt;&lt; " price:" &lt;&lt; priceToString(price_)
         &lt;&lt; " priority:" &lt;&lt; priorityToString(priority_)
         &lt;&lt; "]";
      return ss.str();
    }
  };
#pragma pack(pop)
  typedef Common::LFQueue&lt;Exchange::MEMarketUpdate&gt;
    MEMarketUpdateLFQueue;
}</pre>
<p>This concludes <a id="_idIndexMarker928"/>the structures we will need to represent and <a id="_idIndexMarker929"/>publish market data updates from <a id="_idIndexMarker930"/>the matching <a id="_idIndexMarker931"/>engine. In the next subsection, we will build some structures and define some types that we will use to build the limit order book.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor172"/>Designing the exchange order book</h2>
<p>In this section, we will define some building blocks that will be used to build, maintain, and update the limit <a id="_idIndexMarker932"/>order book in an efficient manner. Before we <a id="_idIndexMarker933"/>discuss each of the structures and objects we will need, we will present a diagram for you to build a visual understanding of the limit order book implementation.</p>
<p>The limit order book is organized <a id="_idIndexMarker934"/>as a collection of buy orders (referred to as bids) and sell <a id="_idIndexMarker935"/>orders (referred to as asks). Orders that are entered at the same price are organized in the <strong class="bold">First In First Out</strong> (<strong class="bold">FIFO</strong>) order in our matching engine. We <a id="_idIndexMarker936"/>discussed these details in the <em class="italic">Designing Our Trading Ecosystem</em> chapter, in the <em class="italic">Designing the C++ matching engine in a trading </em><em class="italic">exchange</em> section.</p>
<p>For the order book we build inside the matching engine, we have a list of bid prices and ask prices that have active orders. Each price level is represented by the <code>MEOrdersAtPrice</code> struct, as shown in the following diagram. The bids are sorted from highest to lowest price level, and the asks are sorted from lowest to highest price level. Each <code>MEOrdersAtPrice</code> stores the individual orders from highest to lowest priority in a doubly linked list. Information for each individual order is contained in the <code>MEOrder</code> structs. We will track each price level in a hash map of type <code>OrdersAtPriceHashMap</code>, which is indexed by the price of that level. We will also track each <code>MEOrder</code> object by their <code>market_order_id_</code> value in a hash map of type <code>OrderHashMap</code>. The diagram representing this design of our matching engine order book is presented as follows.</p>
<div><div><img alt="Figure 6.1 – The design of the limit order book inside the matching engine" src="img/Figure_6.1_B19434.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The design of the limit order book inside the matching engine</p>
<p>Now that we have discussed the overall design of the limit order book data structure and the components <a id="_idIndexMarker937"/>that make it up, we can start defining the <a id="_idIndexMarker938"/>basic structs we need to implement that design. In the next subsection, we will first design the basic blocks – the <code>MEOrder</code> structure to hold information for a single order.</p>
<h3>Defining the MEOrder, OrderHashMap, and ClientOrderHashMap types</h3>
<p>The first <a id="_idIndexMarker939"/>structure is used to hold information <a id="_idIndexMarker940"/>inside the book for a single limit <a id="_idIndexMarker941"/>order, which <a id="_idIndexMarker942"/>we will call <code>MEOrder</code>. This is shown in the following code <a id="_idIndexMarker943"/>blocks, and the <a id="_idIndexMarker944"/>code can be found in the <code>Chapter6/matcher/me_order.h</code> and <code>Chapter6/matcher/me_order.cpp</code> source files in the GitHub repository.</p>
<p>The <code>MEOrder</code> struct has the following important data members in it to save the attributes required to represent a single order in the limit order book:</p>
<ul>
<li>A <code>ticker_id_</code> variable of type <code>TickerId</code> to represent the instrument that this order corresponds to.</li>
<li>A <code>client_id_</code> variable of type <code>ClientId</code> that captures the market participant who owns this order.</li>
<li>Two <code>OrderId</code> sets, as <a id="_idIndexMarker945"/>we discussed <a id="_idIndexMarker946"/>before – <code>client_order_id_</code>, which <a id="_idIndexMarker947"/>is what the client sent on its order request, and <code>market_order_id_</code>, which <a id="_idIndexMarker948"/>is generated <a id="_idIndexMarker949"/>by the matching engine and is unique <a id="_idIndexMarker950"/>across all clients.</li>
<li><code>Side side_</code> to represent whether the order is a buy or sell order.</li>
<li>A <code>price_</code> variable of type <code>Price</code> to represent the price of the order.</li>
<li><code>Qty qty_</code> to represent the quantity of the order that is still active in the order book.</li>
<li>A <code>priority_</code> variable of type <code>Priority</code>, which, as we discussed before, will represent the exact position of this order in the queue of other <code>MEOrder</code> instances with the same <code>side_</code> and <code>price_</code> values.</li>
<li>The <code>MEOrder</code> structure also has two pointers to other <code>MEOrder</code> objects. This is because the <code>MEOrder</code> objects are also maintained as a doubly linked list of orders arranged at a price level in the <code>MEOrdersAtPrice</code> structure, as we discussed in the previous section:</li>
</ul>
<pre class="source-code">
#pragma once
#include &lt;array&gt;
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Exchange {
  struct MEOrder {
    TickerId ticker_id_ = TickerId_INVALID;
    ClientId client_id_ = ClientId_INVALID;
    OrderId client_order_id_ = OrderId_INVALID;
    OrderId market_order_id_ = OrderId_INVALID;
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    Qty qty_ = Qty_INVALID;
    Priority priority_ = Priority_INVALID;
    MEOrder *prev_order_ = nullptr;
    MEOrder *next_order_ = nullptr;
    // only needed for use with MemPool.
    MEOrder() = default;
    MEOrder(TickerId ticker_id, ClientId client_id, OrderId
      client_order_id, OrderId market_order_id, Side side,
      Price price,Qty qty, Priority priority, MEOrder
      *prev_order, MEOrder *next_order) noexcept
        :     ticker_id_(ticker_id),
              client_id_(client_id),
              client_order_id_(client_order_id),
              market_order_id_(market_order_id),
              side_(side),
              price_(price),
              qty_(qty),
              priority_(priority),
              prev_order_(prev_order),
              next_order_(next_order) {}
    auto toString() const -&gt; std::string;
  };</pre>
<p>Additionally, the <code>OrderHashMap</code> type <a id="_idIndexMarker951"/>is used to <a id="_idIndexMarker952"/>represent a hash map, implemented using <code>std::array</code>, where <code>OrderId</code> is the key and <code>MEOrder</code> is the <a id="_idIndexMarker953"/>value. We will <a id="_idIndexMarker954"/>also define <a id="_idIndexMarker955"/>another type, <code>ClientOrderHashMap</code>, which is a hash map, implemented using <code>std::array</code> to <a id="_idIndexMarker956"/>represent a mapping from <code>ClientId</code> to the <code>OrderHashMap</code> objects:</p>
<pre class="source-code">
  typedef std::array&lt;MEOrder *, ME_MAX_ORDER_IDS&gt;
    OrderHashMap;
  Typedef std::array&lt;OrderHashMap, ME_MAX_NUM_CLIENTS&gt;
    ClientOrderHashMap;
}</pre>
<p>We present the <code>toString()</code> method for the <code>MEOrder</code> structure, which is very simple and available in the <code>Chapter6/exchange/matcher/me_order.cpp</code> file:</p>
<pre class="source-code">
#include "me_order.h"
namespace Exchange {
  auto MEOrder::toString() const -&gt; std::string {
    std::stringstream ss;
    ss &lt;&lt; "MEOrder" &lt;&lt; "["
       &lt;&lt; "ticker:" &lt;&lt; tickerIdToString(ticker_id_) &lt;&lt; " "
       &lt;&lt; "cid:" &lt;&lt; clientIdToString(client_id_) &lt;&lt; " "
       &lt;&lt; "oid:" &lt;&lt; orderIdToString(client_order_id_) &lt;&lt; " "
       &lt;&lt; "moid:" &lt;&lt; orderIdToString(market_order_id_) &lt;&lt; " "
       &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
       &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
       &lt;&lt; "qty:" &lt;&lt; qtyToString(qty_) &lt;&lt; " "
       &lt;&lt; "prio:" &lt;&lt; priorityToString(priority_) &lt;&lt; " "
       &lt;&lt; "prev:" &lt;&lt; orderIdToString(prev_order_ ?
         prev_order_-&gt;market_order_id_ :
         OrderId_INVALID) &lt;&lt; " "
       &lt;&lt; "next:" &lt;&lt; orderIdToString(next_order_ ?
         next_order_-&gt;market_order_id_ :
         OrderId_INVALID) &lt;&lt; "]";
    return ss.str();
  }
}</pre>
<p>Next, we <a id="_idIndexMarker957"/>will build <a id="_idIndexMarker958"/>some additional structures <a id="_idIndexMarker959"/>that contain <a id="_idIndexMarker960"/>and manage <a id="_idIndexMarker961"/>order <a id="_idIndexMarker962"/>objects.</p>
<h3>Defining the MEOrdersAtPrice and OrdersAtPriceHashMap types</h3>
<p>As discussed in <em class="italic">Figure 6</em><em class="italic">.1</em>, we define another structure that maintains a list of <code>MEOrder</code> objects, <a id="_idIndexMarker963"/>and we call it <code>MEOrdersAtPrice</code>. This <a id="_idIndexMarker964"/>structure, presented <a id="_idIndexMarker965"/>in the following code <a id="_idIndexMarker966"/>block, will be used to hold all the orders entered at the same price, arranged in the FIFO priority order. This is achieved by creating a singly linked list of <code>MEOrder</code> objects, arranged in order of highest to lowest priority. For that, we create a <code>first_me_order_</code> variable of the <code>MEOrder</code> type pointer, which will represent the first order at this price level, and the other orders following it are chained together in the FIFO order.</p>
<p>The <code>MEOrdersAtPrice</code> structure also has two pointers to the <code>MEOrdersAtPrice</code> objects, one for the previous (<code>prev_entry_</code>) and one for the next (<code>next_entry_</code>). This is because the structure itself is a node in a doubly linked list of <code>MEOrdersAtPrice</code> objects. The doubly linked list of <code>MEOrdersAtPrice</code> is arranged from the most aggressive to the least aggressive prices on the buy and sell sides.</p>
<p>The two other variables this struct contains are a <code>side_</code> variable of type <code>Side</code> and a <code>price_</code> variable of type <code>Price</code>, respectively representing the side and price of this price level:</p>
<pre class="source-code">
namespace Exchange {
  struct MEOrdersAtPrice {
    Side side_ = Side::INVALID;
    Price price_ = Price_INVALID;
    MEOrder *first_me_order_ = nullptr;
    MEOrdersAtPrice *prev_entry_ = nullptr;
    MEOrdersAtPrice *next_entry_ = nullptr;</pre>
<p>We add a default <a id="_idIndexMarker967"/>constructor <a id="_idIndexMarker968"/>and a trivial custom container to initialize objects of this structure:</p>
<pre class="source-code">
    MEOrdersAtPrice() = default;
    MEOrdersAtPrice(Side side, Price price, MEOrder
      *first_me_order, MEOrdersAtPrice *prev_entry,
      MEOrdersAtPrice *next_entry)
        : side_(side), price_(price),
        first_me_order_(first_me_order),
        prev_entry_(prev_entry), next_entry_(next_entry) {}</pre>
<p>We also add <a id="_idIndexMarker969"/>a simple <code>toString()</code> method for logging <a id="_idIndexMarker970"/>purposes, as shown here:</p>
<pre class="source-code">
    auto toString() const {
      std::stringstream ss;
      ss &lt;&lt; "MEOrdersAtPrice["
         &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
         &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
         &lt;&lt; "first_me_order:" &lt;&lt; (first_me_order_ ?
           first_me_order_-&gt;toString() : "null") &lt;&lt; " "
         &lt;&lt; "prev:" &lt;&lt; priceToString(prev_entry_ ?
           prev_entry_-&gt;price_ : Price_INVALID) &lt;&lt; " "
         &lt;&lt; "next:" &lt;&lt; priceToString(next_entry_ ?
           next_entry_-&gt;price_ : Price_INVALID) &lt;&lt; "]";
      return ss.str();
    }
  };</pre>
<p>The <code>OrdersAtPriceHashMap</code> type represents a hash map, implemented through a <code>std::array</code> to represent a mapping from Price to <code>MEOrdersAtPrice</code>:</p>
<pre class="source-code">
  typedef std::array&lt;MEOrdersAtPrice *,
    ME_MAX_PRICE_LEVELS&gt; OrdersAtPriceHashMap;
}</pre>
<p>This concludes <a id="_idIndexMarker971"/>this section on setting up the initial types, <a id="_idIndexMarker972"/>definitions, and basic structures for the <a id="_idIndexMarker973"/>matching engine <a id="_idIndexMarker974"/>and limit order book. Next, we can look at how the matching engine framework is built.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor173"/>Building the matching engine and exchanging external data</h1>
<p>In this section, we will build various parts of the matching engine class. A lot of the heavy lifting <a id="_idIndexMarker975"/>of handling client requests, building and updating the limit <a id="_idIndexMarker976"/>order book, and generating order responses and market updates will be offloaded to the order book class, which we will discuss in the next section. Please reread the <em class="italic">Designing the C++ matching engine in a trading exchange</em> section in the previous chapter, <em class="italic">Designing Our Trading Ecosystem</em>, for a refresher on the components we will build in this section and the design principles behind them. We present the diagram from that chapter here for easy reference, showing the design of the matching engine.</p>
<div><div><img alt="Figure 6.2 – The design of our matching engine component" src="img/Figure_6.2_B19434.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The design of our matching engine component</p>
<p>The matching <a id="_idIndexMarker977"/>engine is an independent thread of execution that <a id="_idIndexMarker978"/>consumes order requests from <code>ClientRequestLFQueue</code>, publishes order responses to <code>ClientResponseLFQueue</code>, and publishes market updates to <code>MEMarketUpdateLFQueue</code>. Let us first declare and define some code for the construction, destruction, thread management, and boilerplate functionality for the matching engine.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor174"/>Building the matching engine</h2>
<p>The <code>MatchingEngine</code> class contains a couple of important data members – first, an <code>OrderBookHashMap</code> object <a id="_idIndexMarker979"/>to track the limit order book for each of the trading instruments. The class also contains pointers to the following objects – <code>ClientRequestLFQueue</code>, <code>ClientResponseLFQueue</code>, and <code>MEMarketUpdateLFQueue</code>, all of which will be passed to it in the constructor. Let us first declare and define some code for the construction, destruction, thread management, and boilerplate functionality for the matching engine. We will also have a Boolean, <code>run_</code>, to track the thread state, a <code>time_str_</code> string, and a <code>Logger</code> object to output some logs. The code for the next sub-sections is available in the <code>Chapter6/exchange/matcher/matching_engine.h</code> source file in the GitHub repository for this book.</p>
<p>First, the header files we need to include to build our matching engine are presented here:</p>
<pre class="source-code">
#pragma once
#include "common/thread_utils.h"
#include "common/lf_queue.h"
#include "common/macros.h"
#include "order_server/client_request.h"
#include "order_server/client_response.h"
#include "market_data/market_update.h"
#include "me_order_book.h"</pre>
<p>We declare the <a id="_idIndexMarker980"/>constructor and destructor methods next, and we add the <code>start()</code> and <code>stop()</code> methods to respectively start and stop the execution of the main matching engine loop, which we will build shortly:</p>
<pre class="source-code">
namespace Exchange {
  class MatchingEngine final {
  public:
    MatchingEngine(ClientRequestLFQueue *client_requests,
                   ClientResponseLFQueue *client_responses,
                   MEMarketUpdateLFQueue *market_updates);
    ~MatchingEngine();
    auto start() -&gt; void;
    auto stop() -&gt; void;</pre>
<p>We add our <a id="_idIndexMarker981"/>usual boilerplate code for the constructors and assignment operators to prevent accidental copies:</p>
<pre class="source-code">
    // Deleted default, copy &amp; move constructors and
    // assignment-operators.
    MatchingEngine() = delete;
    MatchingEngine(const MatchingEngine &amp;) = delete;
    MatchingEngine(const MatchingEngine &amp;&amp;) = delete;
    MatchingEngine &amp;operator=(const MatchingEngine &amp;) =
      delete;
    MatchingEngine &amp;operator=(const MatchingEngine &amp;&amp;) =
      delete;</pre>
<p>Finally, we add the data members for this <code>MatchingEngine</code> class, as discussed before. The <code>ticker_order_book_</code> variable of type <code>OrderBookHashMap</code> is used to store <code>MEOrderBook</code> for each instrument. We store the <code>incoming_requests_</code>, <code>outgoing_ogw_responses_</code>, and <code>outgoing_md_updates_</code> pointers of the <code>ClientRequestLFQueue</code>, <code>ClientResponseLFQueue</code>, and <code>MEMarketUpdateLFQueue</code> types respectively to communicate with the other threads. Then, we have the <code>run_</code> Boolean variable, which we mark <code>volatile</code>, since it will be accessed from different threads:</p>
<pre class="source-code">
  private:
    OrderBookHashMap ticker_order_book_;
    ClientRequestLFQueue *incoming_requests_ = nullptr;
    ClientResponseLFQueue *outgoing_ogw_responses_ =
      nullptr;
    MEMarketUpdateLFQueue *outgoing_md_updates_ = nullptr;
    volatile bool run_ = false;
    std::string time_str_;
    Logger logger_;
  };
}</pre>
<p>Let us look at the <a id="_idIndexMarker982"/>implementation of the constructor, the destructor, and the <code>start()</code> method that creates and launches a thread to execute the <code>run()</code> method (which we will look at shortly). This code is in the <code>Chapter6/exchange/matcher/matching_engine.cpp</code> source file. The constructor itself is straightforward – it initializes the internal data members and creates an <code>MEOrderBook</code> instance for each one of the supported trading instruments:</p>
<pre class="source-code">
#include "matching_engine.h"
namespace Exchange {
  MatchingEngine::MatchingEngine(ClientRequestLFQueue
    *client_requests, ClientResponseLFQueue
    *client_responses, MEMarketUpdateLFQueue
    *market_updates)
      : incoming_requests_(client_requests),
        outgoing_ogw_responses_(client_responses),
        outgoing_md_updates_(market_updates),
        logger_("exchange_matching_engine.log") {
    for(size_t i = 0; i &lt; ticker_order_book_.size(); ++i) {
      ticker_order_book_[i] = new MEOrderBook(i, &amp;logger_,
        this);
    }
  }</pre>
<p>The destructor does <a id="_idIndexMarker983"/>the opposite of the constructor and resets the internal data member variables. It also deletes the <code>MEOrderBook</code> objects it created in the constructor:</p>
<pre class="source-code">
  MatchingEngine::~MatchingEngine() {
    run_ = false;
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
    incoming_requests_ = nullptr;
    outgoing_ogw_responses_ = nullptr;
    outgoing_md_updates_ = nullptr;
    for(auto&amp; order_book : ticker_order_book_) {
      delete order_book;
      order_book = nullptr;
    }
  }</pre>
<p>The <code>start()</code> method creates and launches a new thread, assigning it the <code>MatchingEngine::run()</code> method. Before it does that, it enables <code>run_ flag</code>, since it controls the execution of the <code>run()</code> method:</p>
<pre class="source-code">
  auto MatchingEngine::start() -&gt; void {
    run_ = true;
    ASSERT(Common::createAndStartThread(-1,
      "Exchange/MatchingEngine", [this]() { run(); }) !=
      nullptr, "Failed to start MatchingEngine thread.");
  }</pre>
<p>The <code>stop()</code> method <a id="_idIndexMarker984"/>simply sets the <code>run_</code> flag to be <code>false</code>, and that in turn causes the <code>run()</code> method to exit out of its main loop, but this will become clear shortly:</p>
<pre class="source-code">
  auto MatchingEngine::stop() -&gt; void {
    run_ = false;
  }
}</pre>
<p>Next, we will investigate the source code that handles how the matching engine consumes the order requests and publishes order responses and market updates. But first, let us present the main <code>run()</code> loop that the matching engine thread executes. This code is very simple – it simply consumes <code>MEClientRequest</code> objects from the <code>incoming_requests_</code> lock-free queue and forwards them to the <code>processClientRequest()</code> method. To achieve this, it simply checks the <code>LFQueue::getNextToRead()</code> method to see whether there is a valid entry to be read, and if so, forwards the object at that entry to be processed, and updates the read index in the lock-free queue using the <code>LFQueue::updateReadIndex()</code> method. This code is in the <code>Chapter6/exchange/matcher/matching_engine.h</code> source file:</p>
<pre class="source-code">
auto run() noexcept {
  logger_.log("%:% %() %\n", __FILE__, __LINE__,
    __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
  while (run_) {
    const auto me_client_request =
      incoming_requests_-&gt;getNextToRead();
    if (LIKELY(me_client_request)) {
      logger_.log("%:% %() % Processing %\n", __FILE__,
        __LINE__, __FUNCTION__,
        Common::getCurrentTimeStr(&amp;time_str_),
                  me_client_request-&gt;toString());
      processClientRequest(me_client_request);
      incoming_requests_-&gt;updateReadIndex();
    }
  }
}</pre>
<p>Now, let us look at <a id="_idIndexMarker985"/>the source code to handle client requests.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor175"/>Consuming from and publishing to the order gateway queue</h2>
<p>First, we will start <a id="_idIndexMarker986"/>with the implementation <a id="_idIndexMarker987"/>of <code>processClientRequest()</code> in the <code>MatchingEngine</code> class in the <code>matching_engine.h</code> header file. This implementation simply checks for the type of the <code>MEClientRequest</code> and forwards it to the limit order book for the corresponding instrument. It finds the correct order book instance that this <code>MEClientRequest</code> is meant for by accessing the <code>ticker_order_book_</code> container, using the <code>ticker_id_</code> field in <code>MEClientRequest</code>:</p>
<pre class="source-code">
auto processClientRequest(const MEClientRequest *client_request) noexcept {
  auto order_book = ticker_order_book_[client_request
    -&gt;ticker_id_];</pre>
<p>For client requests that try to add a new order (<code>ClientRequestType::NEW</code>), we call the <code>MEOrderBook::add()</code> method and let it service that request:</p>
<pre class="source-code">
  switch (client_request-&gt;type_) {
    case ClientRequestType::NEW: {
      order_book-&gt;add(client_request-&gt;client_id_,
        client_request-&gt;order_id_,
        client_request-&gt;ticker_id_,
        client_request-&gt;side_, client_request-&gt;price_,
        client_request-&gt;qty_);
    }
      break;</pre>
<p>Similarly, client <a id="_idIndexMarker988"/>requests that try to cancel an existing <a id="_idIndexMarker989"/>order (<code>ClientRequestType::CANCEL</code>) are forwarded to the <code>MEOrderBook::cancel()</code> method:</p>
<pre class="source-code">
    case ClientRequestType::CANCEL: {
      order_book-&gt;cancel(client_request-&gt;client_id_,
        client_request-&gt;order_id_,
        client_request-&gt;ticker_id_);
    }
      break;
    default: {
      FATAL("Received invalid client-request-type:" +
        clientRequestTypeToString(client_request-&gt;type_));
    }
      break;
  }
}</pre>
<p>We will also define a method in the same class that the limit order book will use to publish order <a id="_idIndexMarker990"/>responses through <code>MEClientResponse</code> messages. This simply writes the response to the <code>outgoing_ogw_responses_</code> lock-free queue <a id="_idIndexMarker991"/>and advances the writer index. It does that by finding the next valid index to write the <code>MEClientResponse</code> message to by calling the <code>LFQueue::getNextToWriteTo()</code> method, moving the data into that slot, and updating the next write index by calling the <code>LFQueue::updateWriteIndex()</code> method:</p>
<pre class="source-code">
auto sendClientResponse(const MEClientResponse *client_response) noexcept {
  logger_.log("%:% %() % Sending %\n", __FILE__, __LINE__,
    __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
    client_response-&gt;toString());
  auto next_write = outgoing_ogw_responses_
    -&gt;getNextToWriteTo();
  *next_write = std::move(*client_response);
  outgoing_ogw_responses_-&gt;updateWriteIndex();
}</pre>
<p>Now, we will look <a id="_idIndexMarker992"/>at some code that is similar to what <a id="_idIndexMarker993"/>we just saw, except it is used to publish market data updates.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor176"/>Publishing to the market data publisher queue</h2>
<p>The <code>sendMarketUpdate()</code> method in <code>Chapter6/exchange/matcher/matching_engine.h</code> is used by the limit order book to <a id="_idIndexMarker994"/>publish market data updates through the <code>MEMarketUpdate</code> structure. It simply writes to the <code>outgoing_md_updates_</code> lock-free queue and advances the writer. It does this exactly the same way we saw before – by calling the <code>getNextToWriteTo()</code> method, writing the <code>MEMarketUpdate</code> message to that slot, and updating the next write index using <code>updateWriteIndex()</code>:</p>
<pre class="source-code">
auto sendMarketUpdate(const MEMarketUpdate *market_update) noexcept {
  logger_.log("%:% %() % Sending %\n", __FILE__, __LINE__,
    __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
    market_update-&gt;toString());
  auto next_write = outgoing_md_updates_
    -&gt;getNextToWriteTo();
  *next_write = *market_update;
  outgoing_md_updates_-&gt;updateWriteIndex();
}</pre>
<p>That concludes this section, and we now have the finished implementation of the matching engine. In the next subsection, we will tie all these pieces together into the trading exchange binary, all except the limit order book implementation, which is the last section we will discuss in this chapter.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor177"/>Building the exchange application binary</h2>
<p>We can now build the trading exchange binary. We will instantiate the three lock-free queues for order <a id="_idIndexMarker995"/>requests, order responses, and market updates that the matching engine object needs. We will also create the <code>MatchingEngine</code> object and launch the thread, and then the binary simply sleeps forever. Since the application goes into an infinite loop, we will also install a signal handler for this application to trap external signals and exit gracefully. Note that this code will be extended in later chapters in this book as we build the order server and market data publisher components on the trading exchange side that need to be added here. The code for this application is in <code>Chapter6/exchange/exchange_main.cpp</code> in the GitHub repository for this book. Let us break down the source file and understand each of the code blocks.</p>
<p>First, we add some variables that will be pointers for the <code>Logger</code> object and the <code>MatchingEngine</code> object. We will also add a <code>signal_handler()</code> method to be invoked when killing the exchange application. The signal handler simply deletes these objects and exits:</p>
<pre class="source-code">
#include &lt;csignal&gt;
#include "matcher/matching_engine.h"
Common::Logger* logger = nullptr;
Exchange::MatchingEngine* matching_engine = nullptr;
void signal_handler(int) {
  using namespace std::literals::chrono_literals;
  std::this_thread::sleep_for(10s);
  delete logger; logger = nullptr;
  delete matching_engine; matching_engine = nullptr;
  std::this_thread::sleep_for(10s);
  exit(EXIT_SUCCESS);
}</pre>
<p>The <code>main()</code> method is pretty simple for now till we add other components in the next chapter. It installs the <code>signal_handler()</code> method using the <code>std::signal()</code> routine to <a id="_idIndexMarker996"/>trap external <code>SIGINT</code> signals. The <code>SIGINT</code> signal is the signal value 2, which is sent to a running process when either <em class="italic">Ctrl</em> + <em class="italic">C</em> is pressed in Linux or <code>kill –2 PID</code> is sent to that <code>ClientRequestLFQueue</code> variable, <code>client_requests</code>, and the <code>ClientResponseLFQueue</code> variable, <code>client_responses</code>, to be of the <code>ME_MAX_CLIENT_UPDATES</code> size. We also initialize the lock-free queue variable, <code>market_updates</code>, of type <code>MEMarketUpdateLFQueue</code> to be of <code>ME_MAX_MARKET_UPDATES</code> capacity. The <code>main()</code> method also initializes the <code>logger</code> variable with an instance of the <code>Logger</code> class:</p>
<pre class="source-code">
int main(int, char **) {
  logger = new Common::Logger("exchange_main.log");
  std::signal(SIGINT, signal_handler);
  const int sleep_time = 100 * 1000;
  Exchange::ClientRequestLFQueue
    client_requests(ME_MAX_CLIENT_UPDATES);
  Exchange::ClientResponseLFQueue
    client_responses(ME_MAX_CLIENT_UPDATES);
  Exchange::MEMarketUpdateLFQueue
    market_updates(ME_MAX_MARKET_UPDATES);</pre>
<p>Finally, the <code>main()</code> method initializes the <code>matching_engine</code> variable with an instance of the <code>MatchingEngine</code> class we created and passes it the three lock-free queues it needs from the preceding code block. It then calls the <code>start()</code> method so that the main <a id="_idIndexMarker997"/>matching engine thread can start executing. At this point, the <code>main()</code> method is done, so it enters into an infinite loop, where it sleeps most of the time and waits for an external signal that will kill this process:</p>
<pre class="source-code">
  std::string time_str;
  logger-&gt;log("%:% %() % Starting Matching Engine...\n",
    __FILE__, __LINE__, __FUNCTION__,
    Common::getCurrentTimeStr(&amp;time_str));
  matching_engine = new
    Exchange::MatchingEngine(&amp;client_requests,
    &amp;client_responses, &amp;market_updates);
  matching_engine-&gt;start();
  while (true) {
    logger-&gt;log("%:% %() % Sleeping for a few
    milliseconds..\n", __FILE__, __LINE__, __FUNCTION__,
    Common::getCurrentTimeStr(&amp;time_str));
    usleep(sleep_time * 1000);
  }
}</pre>
<p>To make it easy to build the main binary, we have provided a script, <code>Chapter6/build.sh</code>, which uses CMake and Ninja to build this binary. You will have to update this script to <a id="_idIndexMarker998"/>point to the correct binaries on your system, or use a different build system if you prefer. The next section will provide some information on how to run this <code>exchange_main</code> application.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor178"/>Running the exchange application binary</h2>
<p>Running the <code>exchange_main</code> application is achieved at this point simply by calling the <code>exchange_main</code> binary, as <a id="_idIndexMarker999"/>shown in the following code block. We also show the output you should be able to see on the terminal:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter6$ ./cmake-build-release/exchange_main
Set core affinity for Common/Logger exchange_main.log 139685103920704 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 139684933506624 to -1
Set core affinity for Exchange/MatchingEngine 139684925113920 to -1</pre>
<p>This process can be stopped by sending it the <code>SIGINT</code> signal, as we mentioned before. At this point, it will generate three log files, similar to the ones shown in the following snippet. However, note at this point that there is nothing interesting in the log files, since we have only built the matching engine component out of all the components we need to build the full trading ecosystem. At the end of the next chapter, <em class="italic">Communicating with Market Participants</em>, we will run this application again with additional components and have slightly more interesting output:</p>
<pre class="source-code">
exchange_main.log exchange_matching_engine.log</pre>
<p>The next section will look at the internal workings of the order book and how it handles client order requests and generates order responses and market updates.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor179"/>Building the order book and matching orders</h1>
<p>This final section implements the order book functionality. Remember that the order book handles client <a id="_idIndexMarker1000"/>order requests forwarded from the matching engine. It <a id="_idIndexMarker1001"/>checks the order request type, updates the order book, generates order responses for the client, and generates market data updates for the public market data feed. All the code for the limit order book in the matching engine is in the <code>me_order_book.h</code> and <code>me_order_book.cpp</code> source files, saved in the <code>Chapter6/exchange/matcher/</code> directory in the GitHub repository for this book.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor180"/>Building the internal data structures</h2>
<p>First, we will declare <a id="_idIndexMarker1002"/>the data members for the limit order book. We presented a diagram depicting the data structures that make up the limit order book previously, in Figure 6.1. The limit order book contains the following important data members:</p>
<ul>
<li>A <code>matching_engine_</code> pointer variable to the <code>MatchingEngine</code> parent for the order <a id="_idIndexMarker1003"/>book to publish order responses and market data updates to.</li>
<li>The <code>ClientOrderHashMap</code> variable, <code>cid_oid_to_order_</code>, to track the <code>OrderHashMap</code> objects by their <code>ClientId</code> key. As a reminder, <code>OrderHashMap</code> tracks the <code>MEOrder</code> objects by their <code>OrderId</code> keys.</li>
<li>The <code>orders_at_price_pool_</code> memory pool variable of the <code>MEOrdersAtPrice</code> objects to create new objects from and return dead objects back to.</li>
<li>The head of the doubly linked list of bids (<code>bids_by_price_</code>) and asks (<code>asks_by_price_</code>), since we track orders at the price level as a list of <code>MEOrdersAtPrice</code> objects.</li>
<li>A hash map, <code>OrdersAtPriceHashMap</code>, to track the <code>MEOrdersAtPrice</code> objects for the price levels, using the price of the level as a key into the map.</li>
<li>A memory pool of the <code>MEOrder</code> objects, called <code>order_pool_</code>, where <code>MEOrder</code> objects are created from and returned to without incurring dynamic memory allocations.</li>
<li>Some minor members, such as <code>TickerId</code> for the instrument for this order book, <code>OrderId</code> to track <a id="_idIndexMarker1004"/>the next market data order ID, an <code>MEClientResponse</code> variable (<code>client_response_</code>), an <code>MEMarketUpdate</code> object (<code>market_update_</code>), a string to log time, and the <code>Logger</code> object for logging purposes.</li>
</ul>
<p>First, we include some <a id="_idIndexMarker1005"/>dependent header files and also forward-declare the <code>MatchingEngine</code> class because we will reference that type without fully defining it yet:</p>
<pre class="source-code">
#pragma once
#include "common/types.h"
#include "common/mem_pool.h"
#include "common/logging.h"
#include "order_server/client_response.h"
#include "market_data/market_update.h"
#include "me_order.h"
using namespace Common;
namespace Exchange {
  class MatchingEngine;
  class MEOrderBook final {</pre>
<p>Now, we will <a id="_idIndexMarker1006"/>define the data member variables, as discussed previously:</p>
<pre class="source-code">
private:
  TickerId ticker_id_ = TickerId_INVALID;
  MatchingEngine *matching_engine_ = nullptr;
  ClientOrderHashMap cid_oid_to_order_;
  MemPool&lt;MEOrdersAtPrice&gt; orders_at_price_pool_;
  MEOrdersAtPrice *bids_by_price_ = nullptr;
  MEOrdersAtPrice *asks_by_price_ = nullptr;
  OrdersAtPriceHashMap price_orders_at_price_;
  MemPool&lt;MEOrder&gt; order_pool_;
  MEClientResponse client_response_;
  MEMarketUpdate market_update_;
  OrderId next_market_order_id_ = 1;
  std::string time_str_;
  Logger *logger_ = nullptr;</pre>
<p>At this point, we will also define the <code>OrderBookHashMap</code> type, which we referenced before and is <code>std::array</code> of the <code>MEOrderBook</code> objects indexed by <code>TickerId</code>:</p>
<pre class="source-code">
 typedef std::array&lt;MEOrderBook *, ME_MAX_TICKERS&gt; OrderBookHashMap;
  };
}</pre>
<p>Next, let us <a id="_idIndexMarker1007"/>present the straightforward implementation of the constructor and the destructor, as well as the boilerplate code for the default constructor and assignment operators:</p>
<pre class="source-code">
#include "me_order_book.h"
#include "matcher/matching_engine.h"
MEOrderBook::MEOrderBook(TickerId ticker_id, Logger *logger, MatchingEngine *matching_engine)
    : ticker_id_(ticker_id),
      matching_engine_(matching_engine),
      orders_at_price_pool_(ME_MAX_PRICE_LEVELS),
      order_pool_(ME_MAX_ORDER_IDS), logger_(logger) {
}
MEOrderBook::~MEOrderBook() {
  logger_-&gt;log("%:% %() % OrderBook\n%\n", __FILE__,
    __LINE__, __FUNCTION__,
    Common::getCurrentTimeStr(&amp;time_str_),
              toString(false, true));
  matching_engine_ = nullptr;
  bids_by_price_ = asks_by_price_ = nullptr;
  for (auto &amp;itr: cid_oid_to_order_) {
    itr.fill(nullptr);
  }
}</pre>
<p>Then, we add the boilerplate code to most of our classes to prevent accidental copies and assignments <a id="_idIndexMarker1008"/>of the <code>MEOrderBook</code> objects:</p>
<pre class="source-code">
// Deleted default, copy &amp; move constructors and
// assignment-operators.
MEOrderBook() = delete;
MEOrderBook(const MEOrderBook &amp;) = delete;
MEOrderBook(const MEOrderBook &amp;&amp;) = delete;
MEOrderBook &amp;operator=(const MEOrderBook &amp;) = delete;
MEOrderBook &amp;operator=(const MEOrderBook &amp;&amp;) = delete;</pre>
<p>Before we move on to the implementation of the different operations that will be performed on the order book, let us present a few simple methods to generate new market order IDs, convert <code>Price</code> to an index in <code>OrdersAtPriceHashMap</code>, and access the <code>OrdersAtPriceHashMap price_orders_at_price_</code> map when given <code>Price</code>:</p>
<pre class="source-code">
namespace Exchange {
  class MatchingEngine;
  class MEOrderBook final {
private:</pre>
<p>The <code>generateNewMarketOrderId()</code> method is basic; it returns the <code>next_market_order_id_</code> value and increments it the next time this method is called:</p>
<pre class="source-code">
  auto generateNewMarketOrderId() noexcept -&gt; OrderId {
    return next_market_order_id_++;
  }</pre>
<p>The <code>priceToIndex()</code> method converts a <code>Price</code> argument into an index that ranges between <code>0</code> and <code>ME_MAX_PRICE_LEVELS-1</code>, which is then used to index the price levels <code>std::array</code>:</p>
<pre class="source-code">
  auto priceToIndex(Price price) const noexcept {
    return (price % ME_MAX_PRICE_LEVELS);
  }</pre>
<p>Finally, the <code>getOrdersAtPrice()</code> utility method indexes <code>std::array</code> of <code>price_orders_at_price_</code> by <a id="_idIndexMarker1009"/>converting <code>Price</code> it is provided into an index, using the <code>priceToIndex()</code> method, which returns the <code>MEOrdersAtPrice</code> object:</p>
<pre class="source-code">
  auto getOrdersAtPrice(Price price) const noexcept -&gt;
    MEOrdersAtPrice * {
    return price_orders_at_price_.at(priceToIndex(price));
  }
  };
}</pre>
<p>The next few subsections will detail the important operations of handling new order requests and cancellation requests for existing orders, and matching aggressive orders that cross existing passive orders on the other side of the order book. We will also generate and publish order responses and market data updates back to the matching engine.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor181"/>Handling new passive orders</h2>
<p>The first important task <a id="_idIndexMarker1010"/>we need to perform in the order book is handling client order requests that want to enter new orders in the market. We will implement the <code>MEOrderBook::add()</code> method, which the matching engine calls first. It generates and sends <code>MEClientResponse</code>, accepting the new order, and sends it to the matching engine (to be sent to the client who sent the new order). It then also checks to see whether this new order crosses an existing passive order on the other side and whether it matches either fully or partially, by calling the <code>checkForMatch()</code> method. If the new order either does not match at all or is partially filled and leaves some quantity in the book, <code>MEOrder</code> is added to the order book. In this case, it also generates <code>MEMarketUpdate</code> for the public market data feed and sends it back to the matching engine (to be published by the market data publisher component). We will discuss the <code>getNextPriority()</code>, <code>checkForMatch()</code>, and <code>addOrder()</code> methods shortly in this section, but let us first explore the <code>MEOrderBook::add()</code> method:</p>
<pre class="source-code">
auto MEOrderBook::add(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty) noexcept -&gt; void {</pre>
<p>The first thing it does is generate <code>new_market_order_id_</code> to be used for <code>MEClientResponse</code> and <code>MEMarketUpdate</code>. It updates the <code>client_response_</code> data member with the attributes from this request and calls the <code>MatchingEngine::sendClientResponse()</code> method to publish that response back to the matching engine:</p>
<pre class="source-code">
  const auto new_market_order_id =
    generateNewMarketOrderId();
  client_response_ = {ClientResponseType::ACCEPTED,
    client_id, ticker_id, client_order_id,
    new_market_order_id, side, price, 0, qty};
  matching_engine_-&gt;sendClientResponse(&amp;client_response_);</pre>
<p>Next, the <code>MEOrderBook::add()</code> method calls the <code>MEOrderBook::checkForMatch()</code> method, which checks the current state of the order book against the new client request that just came in. It checks whether a partial or complete match can be made. The <code>checkForMatch()</code> method (which we will build shortly) returns the quantity of the order left over (if any) after the matching event. For orders that do not execute at all, <code>leaves_qty</code> returned is the same as the original quantity <a id="_idIndexMarker1011"/>on the order. For orders that partially execute, it is whatever is left after matching. For orders that fully execute, this method will return a <code>0</code> value and that will be assigned to <code>leaves_qty</code>. We will see the complete implementation of <code>checkForMatch()</code> shortly, but for now, let us use it:</p>
<pre class="source-code">
  const auto leaves_qty = checkForMatch(client_id,
    client_order_id, ticker_id, side, price, qty,
    new_market_order_id);</pre>
<p>In the event that there is a quantity left over after the matching event, we need to generate a market data update corresponding to this new order that will join the book. To do that, the <code>MEOrderBook::add()</code> method finds out the correct priority value for this order by calling the <code>MEOrderBook::getNextPriority()</code> method. It allocates a new <code>MEOrder</code> object from the <code>order_pool_</code> memory pool and assigns it the attributes for this order. It then calls the <code>MEOrderBook::addOrder()</code> method to actually add it at the correct price level and priority in the <code>MEOrdersAtPrice</code> data structures. Finally, it fills in the <code>market_update_</code> object with the values for the market update and calls the <code>MatchingEngine::sendMarketUpdate()</code> method to publish it to the matching engine:</p>
<pre class="source-code">
  if (LIKELY(leaves_qty)) {
    const auto priority = getNextPriority(ticker_id,
    price);
    auto order = order_pool_.allocate(ticker_id, client_id,
      client_order_id, new_market_order_id, side, price,
      leaves_qty, priority, nullptr, nullptr);
    addOrder(order);
    market_update_ = {MarketUpdateType::ADD,
      new_market_order_id, ticker_id, side, price,
      leaves_qty, priority};
    matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
  }
}</pre>
<p>The <code>getNextPriority()</code> method is quite straightforward. If a price level already exists at a <a id="_idIndexMarker1012"/>certain price, then it just returns a priority value one higher than the last order at that price. If a price level does not already exist, then it returns 1 for the first order at that price level:</p>
<pre class="source-code">
auto getNextPriority(Price price) noexcept {
  const auto orders_at_price = getOrdersAtPrice(price);
  if (!orders_at_price)
    return 1lu;
  return orders_at_price-&gt;first_me_order_-&gt;prev_order_
    -&gt;priority_ + 1;
}</pre>
<p>Next, we will lay out the details of adding a new order to the limit order book. The method appends the <code>MEOrder</code> object passed to it at the end of the <code>MEOrdersAtPrice</code> entry at the price for this order. If an <code>MEOrdersAtPrice</code> entry does not already exist (new price level), it first allocates a new entry, adds the new level into the book using the <code>addOrdersAtPrice()</code> method, and then appends the order. Additionally, it tracks the <code>MEOrder</code> object in the <code>ClientOrderHashMap id_oid_to_order_</code> map, mapping from <code>ClientId</code> and <code>OrderId</code> to the <code>MEOrder</code> objects:</p>
<pre class="source-code">
auto addOrder(MEOrder *order) noexcept {</pre>
<p>First, we try to check and fetch <code>MEOrdersAtPrice</code> if one exists by calling the <code>getOrdersAtPrice()</code> method and saving it in the <code>orders_at_price</code> variable. Then, we check whether a valid <code>MEOrdersAtPrice</code> exists, meaning a price level with the price and side of this order already exists. If such a price level does not exist and this is the first order that forms that level, we create a new <code>MEOrdersAtPrice</code> from <code>orders_at_price_pool_</code>, initialize it, and call the <code>addOrdersAtPrice()</code> method on it:</p>
<pre class="source-code">
  const auto orders_at_price = getOrdersAtPrice(order
    -&gt;price_);
  if (!orders_at_price) {
    order-&gt;next_order_ = order-&gt;prev_order_ = order;
    auto new_orders_at_price =
      orders_at_price_pool_.allocate(order-&gt;side_,
      order-&gt;price_, order, nullptr, nullptr);
    addOrdersAtPrice(new_orders_at_price);
  }</pre>
<p>If a valid price level <a id="_idIndexMarker1013"/>exists, we append the new order at the very end of the doubly linked list of <code>MEOrder</code> objects, reachable from the <code>first_me_order_</code> member of <code>MEOrdersAtPrice</code>. We then update the <code>prev_order_</code> and <code>next_order_</code> pointers on <code>MEOrder</code> being added as well as the last element on the list, after which the <code>MEOrder</code> object is appended:</p>
<pre class="source-code">
  else {
    auto first_order = (orders_at_price ?
      orders_at_price-&gt;first_me_order_ : nullptr);
    first_order-&gt;prev_order_-&gt;next_order_ = order;
    order-&gt;prev_order_ = first_order-&gt;prev_order_;
    order-&gt;next_order_ = first_order;
    first_order-&gt;prev_order_ = order;
  }</pre>
<p>Finally, we add this <code>MEOrder</code> pointer to the <code>cid_oid_to_order_</code> container, which is <code>std::array</code> of <code>std::array</code> instances, indexed first by <code>client_id_</code> of the order and then by <code>client_order_id_</code> of the order:</p>
<pre class="source-code">
  cid_oid_to_order_.at(order-&gt;client_id_)
    .at(order-&gt;client_order_id_) = order;
}</pre>
<p>Finally, to finish the discussion of adding new orders to the book, we need to implement the <code>addOrdersAtPrice()</code> method to add new price levels to the book. This method first adds the new <code>MEOrdersAtPrice</code> entry into <code>OrdersAtPriceHashMap price_orders_at_price_</code>. Then, it walks through the bid or ask price levels, from the most aggressive to the least aggressive price, to find the correct spot for the new price level. Note that this <a id="_idIndexMarker1014"/>implementation iterates through the doubly linked list of <code>MEOrdersAtPrice</code> objects on the side. It is possible to have an alternative implementation that walks through the <code>price_orders_at_price_</code> hash map to find the right spot. Both implementations are viable and perform differently, depending on the number of price levels and the distance between consecutive prices. We will revisit this topic at the end of the book, in the <em class="italic">Optimizing the Performance of Our C++ </em><em class="italic">System </em>chapter.</p>
<p>The first task for the <code>addOrdersAtPrice()</code> method is to insert the new <code>MEOrdersAtPrice</code> in the <code>price_orders_at_price_</code> hash map, mapping from <code>Price</code> to <code>MEOrdersAtPrice</code>:</p>
<pre class="source-code">
auto addOrdersAtPrice(MEOrdersAtPrice *new_orders_at_price) noexcept {
  price_orders_at_price_.at(priceToIndex(
    new_orders_at_price-&gt;price_)) = new_orders_at_price;</pre>
<p>Then, we need to insert it in its correct location for the bids/asks arranged by price. We do this by first assigning a <code>best_orders_by_price</code> variable to the beginning of the bids or asks, sorted by price:</p>
<pre class="source-code">
  const auto best_orders_by_price = (new_orders_at_price-&gt;
    side_ == Side::BUY ? bids_by_price_ : asks_by_price_);</pre>
<p>We need to handle an edge case where there are no bids or no asks – that is, a side of the order book is empty. In such a case, we set the <code>bids_by_price_</code> or <code>asks_by_price_</code> members, which point to the head of the sorted list for that side:</p>
<pre class="source-code">
  if (UNLIKELY(!best_orders_by_price)) {
    (new_orders_at_price-&gt;side_ == Side::BUY ?
      bids_by_price_ : asks_by_price_) =
      new_orders_at_price;
    new_orders_at_price-&gt;prev_entry_ =
      new_orders_at_price-&gt;next_entry_ =
      new_orders_at_price;
  }</pre>
<p>Otherwise, we need to find the correct entry in the doubly linked list of price levels. We do this by walking <a id="_idIndexMarker1015"/>through the bids or the asks till we find the correct price level, before or after which we insert the new price level. We track the price level before or after the new one in the following <code>target</code> variable, and we track whether we need to insert after or before the target variable using the <code>add_after</code> Boolean flag:</p>
<pre class="source-code">
  else {
    auto target = best_orders_by_price;
    bool add_after = ((new_orders_at_price-&gt;side_ ==
      Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
      target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
      Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
      target-&gt;price_));
    if (add_after) {
      target = target-&gt;next_entry_;
      add_after = ((new_orders_at_price-&gt;side_ ==
        Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
        target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
        Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
        target-&gt;price_));
    }
    while (add_after &amp;&amp; target != best_orders_by_price) {
      add_after = ((new_orders_at_price-&gt;side_ ==
      Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
      target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
      Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
      target-&gt;price_));
      if (add_after)
        target = target-&gt;next_entry_;
    }</pre>
<p>Once we find the correct location for the new <code>MEOrdersAtPrice</code> entry, we append the new price level <a id="_idIndexMarker1016"/>by updating the <code>prev_entry_</code> or <code>next_entry_</code> variables in the <code>target</code> <code>MEOrdersAtPrice</code> structure, as well as the new <code>MEOrdersAtPrice</code> being appended, as shown here:</p>
<pre class="source-code">
    if (add_after) { // add new_orders_at_price after
                     // target.
      if (target == best_orders_by_price) {
        target = best_orders_by_price-&gt;prev_entry_;
      }
      new_orders_at_price-&gt;prev_entry_ = target;
      target-&gt;next_entry_-&gt;prev_entry_ =
        new_orders_at_price;
      new_orders_at_price-&gt;next_entry_ =
        target-&gt;next_entry_;
      target-&gt;next_entry_ = new_orders_at_price;
    } else { // add new_orders_at_price before target.
      new_orders_at_price-&gt;prev_entry_ =
        target-&gt;prev_entry_;
      new_orders_at_price-&gt;next_entry_ = target;
      target-&gt;prev_entry_-&gt;next_entry_ =
        new_orders_at_price;
      target-&gt;prev_entry_ = new_orders_at_price;</pre>
<p>Finally, if we add the new price level before an existing price level, we need to check whether prepending this price <a id="_idIndexMarker1017"/>level changes the <code>bids_by_price_</code> or <code>asks_by_price_</code> variable. Remember that these variables track the start of the bids or asks, respectively – that is, the highest bid price and the lowest ask price. If we have a new best bid/ask price level, we update the <code>bids_by_price_</code> or <code>asks_by_price_</code> variable, respectively:</p>
<pre class="source-code">
      if ((new_orders_at_price-&gt;side_ == Side::BUY &amp;&amp;
        new_orders_at_price-&gt;price_ &gt; best_orders_by_price
        -&gt;price_) || new_orders_at_price-&gt;side_ ==
        Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &lt;
        best_orders_by_price-&gt;price_)) {
        target-&gt;next_entry_ = (target-&gt;next_entry_ ==
        best_orders_by_price ? new_orders_at_price :
        target-&gt;next_entry_);
        (new_orders_at_price-&gt;side_ == Side::BUY ?
          bids_by_price_ : asks_by_price_) =
          new_orders_at_price;
      }
    }
  }
}</pre>
<p>Next, we will <a id="_idIndexMarker1018"/>discuss the source code that handles order cancellation requests.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor182"/>Handling order cancellation requests</h2>
<p>The code to handle order cancellation requests is forwarded from the matching engine. First, it checks to see <a id="_idIndexMarker1019"/>whether the cancel request is valid, meaning that <code>ClientId</code> is valid and <code>OrderId</code> on the cancellation request corresponds to an active order in the order book. If the order is not cancellable, it generates and publishes an <code>MEClientResponse</code> message to signify a rejected cancel request back to the matching engine. If the order can be canceled, it generates <code>MEClientResponse</code> to signify the successful cancel attempt and calls the <code>removeOrder()</code> method to remove the order from the limit order book. We will discuss the details of <code>removeOrder()</code> right after this next method.</p>
<p>We will track an <code>is_cancelable</code> Boolean variable that determines whether we were able to successfully find and cancel the client’s order or not. If <code>client_id</code> is larger than the maximum possible client ID value, then we cannot cancel the order. If the client ID is valid, then we check the container from <code>cid_oid_to_order_</code> for the provided <code>client_id</code> and the <code>order_id</code> value. If a valid order does not exist, then we confirm that the order is not cancelable:</p>
<pre class="source-code">
auto MEOrderBook::cancel(ClientId client_id, OrderId order_id, TickerId ticker_id) noexcept -&gt; void {
  auto is_cancelable = (client_id &lt;
    cid_oid_to_order_.size());
  MEOrder *exchange_order = nullptr;
  if (LIKELY(is_cancelable)) {
    auto &amp;co_itr = cid_oid_to_order_.at(client_id);
    exchange_order = co_itr.at(order_id);
    is_cancelable = (exchange_order != nullptr);
  }</pre>
<p>If we determine that the order cannot be cancelled, we generate an <code>MEClientResponse</code> message of type <code>ClientResponseType::CANCEL_REJECTED</code> to notify the matching engine:</p>
<pre class="source-code">
  if (UNLIKELY(!is_cancelable)) {
    client_response_ =
      {ClientResponseType::CANCEL_REJECTED, client_id,
      ticker_id, order_id, OrderId_INVALID,
      Side::INVALID, Price_INVALID, Qty_INVALID,
      Qty_INVALID};
  }</pre>
<p>If we can <a id="_idIndexMarker1020"/>successfully cancel the order, we update the attributes in the <code>client_response_</code> member variable and the <code>market_update_</code> member variable. Then, we call the <code>removeOrder()</code> method to update our order book and delete this order from it. Finally, we send the market update to the matching engine, using the <code>sendMarketUpdate()</code> method, and we send the client response to the matching engine, using the <code>sendClientResponse()</code> method:</p>
<pre class="source-code">
  else {
    client_response_ = {ClientResponseType::CANCELED,
      client_id, ticker_id, order_id,
      exchange_order-&gt;market_order_id_,
      exchange_order-&gt;side_, exchange_order-&gt;price_,
      Qty_INVALID, exchange_order-&gt;qty_};
    market_update_ = {MarketUpdateType::CANCEL,
      exchange_order-&gt;market_order_id_, ticker_id,
      exchange_order-&gt;side_, exchange_order-&gt;price_, 0,
      exchange_order-&gt;priority_};
    removeOrder(exchange_order);
    matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
  }
  matching_engine_-&gt;sendClientResponse(&amp;client_response_);
}</pre>
<p>Next, let us implement the <code>removeOrder()</code> method. It first finds <code>MEOrdersAtPrice</code> that the order being removed belongs to and then finds and removes <code>MEOrder</code> from the list of orders contained in <code>MEOrdersAtPrice</code>. If the order being <a id="_idIndexMarker1021"/>removed is the only order at the price level, the method also calls <code>removeOrdersAtPrice()</code> to remove the entire price level, since after this deletion, that no longer exists. Finally, it removes the entry for that <code>MEOrder</code> from the <code>cid_oid_to_order_</code> hash map and returns the deallocated <code>MEOrder</code> object to the <code>order_pool_</code> memory pool:</p>
<pre class="source-code">
auto removeOrder(MEOrder *order) noexcept {
  auto orders_at_price = getOrdersAtPrice(order-&gt;price_);
  if (order-&gt;prev_order_ == order) { // only one element.
    removeOrdersAtPrice(order-&gt;side_, order-&gt;price_);
  } else { // remove the link.
    const auto order_before = order-&gt;prev_order_;
    const auto order_after = order-&gt;next_order_;
    order_before-&gt;next_order_ = order_after;
    order_after-&gt;prev_order_ = order_before;
    if (orders_at_price-&gt;first_me_order_ == order) {
      orders_at_price-&gt;first_me_order_ = order_after;
    }
    order-&gt;prev_order_ = order-&gt;next_order_ = nullptr;
  }
  cid_oid_to_order_.at(order-&gt;client_id_).at(order
    -&gt;client_order_id_) = nullptr;
  order_pool_.deallocate(order);
}</pre>
<p>To conclude our discussion of tasks involved in handling order cancellation requests, we will implement the <code>removeOrdersAtPrice()</code> method. It finds and removes <code>MEOrdersAtPrice</code> from the doubly linked list of <code>MEOrdersAtPrice</code> for the bid or ask side. If this price entry being removed happens to be the only <code>MEOrdersAtPrice</code> entry on that <a id="_idIndexMarker1022"/>side of the book, it sets the head of the doubly linked list to be <code>nullptr</code>, representing an empty side of the book. Finally, the method removes the entry from the <code>price_orders_at_price_</code> hash map for that price and returns the deallocated <code>MEOrdersAtPrice</code> to the <code>orders_at_price_pool_</code> memory pool:</p>
<pre class="source-code">
auto removeOrdersAtPrice(Side side, Price price) noexcept {
  const auto best_orders_by_price = (side == Side::BUY ?
    bids_by_price_ : asks_by_price_);
  auto orders_at_price = getOrdersAtPrice(price);
  if (UNLIKELY(orders_at_price-&gt;next_entry_ ==
    orders_at_price)) { // empty side of book.
    (side == Side::BUY ? bids_by_price_ : asks_by_price_) =
      nullptr;
  } else {
    orders_at_price-&gt;prev_entry_-&gt;next_entry_ =
      orders_at_price-&gt;next_entry_;
    orders_at_price-&gt;next_entry_-&gt;prev_entry_ =
      orders_at_price-&gt;prev_entry_;
    if (orders_at_price == best_orders_by_price) {
      (side == Side::BUY ? bids_by_price_ : asks_by_price_)
      = orders_at_price-&gt;next_entry_;
    }
    Orders_at_price-&gt;prev_entry_ = orders_at_price
      -&gt;next_entry_ = nullptr;
  }
  price_orders_at_price_.at(priceToIndex(price)) = nullptr;
  orders_at_price_pool_.deallocate(orders_at_price);
}</pre>
<p>The last operation we need to tackle is an important one – matching aggressive orders against passive <a id="_idIndexMarker1023"/>orders on the other side of the order book. We will look at the implementation of that operation next.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor183"/>Matching aggressive orders and updating the order book</h2>
<p>In this subsection, we will implement the matching functionality in the limit order book by presenting <a id="_idIndexMarker1024"/>the <code>MEOrderBook::checkForMatch()</code> method we encountered earlier. The diagram presented in <em class="italic">Figure 6</em><em class="italic">.3</em> shows <a id="_idIndexMarker1025"/>what would happen in a hypothetical state of the limit order book. Here, the state of the ask side is shown, and the passive sell prices represented by <code>MEOrdersAtPrice</code> are <code>MEOrder</code> objects are shown, the first one with a priority of <code>MEOrder</code> following that in the FIFO queue has a priority of <strong class="bold">13</strong>, a market order ID of <strong class="bold">1400</strong>, and a quantity of <strong class="bold">10</strong>. In this case, a new buy order with a quantity of <strong class="bold">25</strong> and a price of <strong class="bold">117</strong> (represented in blue) will match the first order with a market order ID of <strong class="bold">1200</strong> (represented in yellow) and execute it fully. It will then partially execute the remaining quantity of <strong class="bold">5</strong> against the order with a market order ID of <strong class="bold">1400</strong> (represented in magenta), and the matching event is finished. These steps are presented in the algorithm right after the following diagram.</p>
<div><div><img alt="Figure 6.3 – An exa﻿mple of a matching event in the limit order book" src="img/Figure_6.3_B19434.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – An exa<a id="_idTextAnchor184"/>mple of a matching event in the limit order book</p>
<p>This method iterates through the <code>MEOrdersAtPrice</code> objects on the side of the book opposite to the new (and possibly aggressive) order. It iterates through the price levels from the most aggressive to least aggressive price and, for each price level, matches the <code>MEOrder</code> objects contained at that price level from the first to last, in the FIFO order. It continues matching the new order against the passive orders on the other side, from the most aggressive to the least aggressive price and in the first to last order at a price level, by calling the <code>match()</code> method. It stops and returns when either the new aggressive order <a id="_idIndexMarker1026"/>has no more unmatched quantity left to match, the <a id="_idIndexMarker1027"/>remaining price levels on the other side no longer cross the new order’s price, or the side of the book is empty. At that point, it returns the remaining unmatched quantity on the new order to the caller:</p>
<pre class="source-code">
auto MEOrderBook::checkForMatch(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty, Qty new_market_order_id) noexcept {
  auto leaves_qty = qty;</pre>
<p>We keep iterating through all the ask price levels, arranged from the lowest to the highest prices, starting from the <code>asks_by_price_</code> level. For the <code>asks_by_price_</code> level, we start from the <code>first_me_order_</code> object of the <code>MEOrder</code> type pointer and iterate in the FIFO order, from the lowest to the highest priority. For each order that can match against the new aggressive order, we call the <code>MEOrder::match()</code> method to perform the actual match. We continue doing this till either there is no more <code>leaves_qty</code> left, the <code>asks_by_price_</code> variable is <code>nullptr</code> to signify an empty book side, or the remaining price levels cannot be used to match the new order:</p>
<pre class="source-code">
  if (side == Side::BUY) {
    while (leaves_qty &amp;&amp; asks_by_price_) {
      const auto ask_itr = asks_by_price_-&gt;first_me_order_;
      if (LIKELY(price &lt; ask_itr-&gt;price_)) {
        break;
      }
      match(ticker_id, client_id, side, client_order_id,
        new_market_order_id, ask_itr, &amp;leaves_qty);
    }
  }</pre>
<p>If the new order has a side of sell, we perform the same logic as described previously, except we iterate through the <code>bids_by_price_</code> price levels, which are arranged from the highest buy price to the lowest buy price, as shown here:</p>
<pre class="source-code">
  if (side == Side::SELL) {
    while (leaves_qty &amp;&amp; bids_by_price_) {
      const auto bid_itr = bids_by_price_-&gt;first_me_order_;
      if (LIKELY(price &gt; bid_itr-&gt;price_)) {
        break;
      }
      match(ticker_id, client_id, side, client_order_id,
        new_market_order_id, bid_itr, &amp;leaves_qty);
    }
  }
  return leaves_qty;
}</pre>
<p>The <code>match()</code> method is called when a new aggressive order matches an existing passive order on the other side of the book. It computes the executed quantity, which is the minimum of <a id="_idIndexMarker1028"/>the quantity of the new order and the existing passive <a id="_idIndexMarker1029"/>order it would match against. It subtracts this executed quantity from the remaining quantity of the aggressive order, as well as the passive order it matched against. It generates two execution order responses and sends them to the matching engine – one for the client who sent the aggressive order and another one for the client whose passive order got executed against the new order. It also creates and publishes a market update of type <code>MarketUpdateType::TRADE</code> to notify participants about the execution on the public market data feed. Finally, it checks whether this trade transaction fully executes the passive order or not, and if there is a full execution, it generates another market update of type <code>MarketUpdateType::CANCEL</code> to notify participants that the passive order has been removed. If the passive order is only partially matched, it instead generates a market update of type <code>MarketUpdateType::MODIFY</code> with the new remaining quantity of the passive limit order.</p>
<p>What this means is that participants who choose to ignore trade messages from the market data stream can still accurately build and maintain the limit order book. We could theoretically eliminate the extra cancel or modify market update, but that would require downstream market data consumers to apply trade messages to their order books and update them.</p>
<p>The <code>MEOrderBook::match()</code> method takes a few arguments to identify the client information, but the key arguments are the <code>MEOrder</code> pointer, <code>itr</code>, and the <code>Qty</code> pointer, <code>leaves_qty</code>. The <code>MEOrder</code> pointer represents the order in the book that the new order is being matched against, and <code>Qty</code> represents the remaining quantity on the new order. These <a id="_idIndexMarker1030"/>arguments are passed by pointer because we <a id="_idIndexMarker1031"/>will modify them directly in this method and expect the changes to be reflected in the calling method:</p>
<pre class="source-code">
auto MEOrderBook::match(TickerId ticker_id, ClientId client_id, Side side, OrderId client_order_id, OrderId new_market_order_id, MEOrder* itr, Qty* leaves_qty) noexcept {</pre>
<p>We compute the <code>fill_qty</code> variable to be the minimum of the quantity on the passive order that exists in the book and the new order’s quantity. We then use <code>fill_qty</code> to decrease both <code>leaves_qty</code> and the <code>qty_</code> member on the <code>MEOrder</code> object:</p>
<pre class="source-code">
  const auto order = itr;
  const auto order_qty = order-&gt;qty_;
  const auto fill_qty = std::min(*leaves_qty, order_qty);
  *leaves_qty -= fill_qty;
  order-&gt;qty_ -= fill_qty;</pre>
<p>We generate a client response message of type <code>ClientResponseType::FILLED</code>, meant for the client who sent the new order, and dispatch it to the matching engine using the <code>sendClientResponse()</code> method:</p>
<pre class="source-code">
  client_response_ = {ClientResponseType::FILLED,
    client_id, ticker_id, client_order_id,
    new_market_order_id, side, itr-&gt;price_, fill_qty,
    *leaves_qty};
  matching_engine_-&gt;sendClientResponse(&amp;client_response_);</pre>
<p>We also generate a second client response message of <code>type_</code> <code>ClientResponseType::FILLED</code>; this one is meant for the client whose order was in the order book and got matched:</p>
<pre class="source-code">
  client_response_ = {ClientResponseType::FILLED, order
    -&gt;client_id_, ticker_id, order-&gt;client_order_id_,
    order-&gt;market_order_id_, order-&gt;side_, itr-&gt;price_,
    fill_qty, order-&gt;qty_};
  matching_engine_-&gt;sendClientResponse(&amp;client_response_);</pre>
<p>We will also generate <a id="_idIndexMarker1032"/>a market update of type <code>MarketUpdateType::TRADE</code> and <a id="_idIndexMarker1033"/>publish it using <code>sendMarketUpdate()</code>, notifying the participants about the trade transaction that occurred and providing them with <code>fill_qty</code>:</p>
<pre class="source-code">
  market_update_ = {MarketUpdateType::TRADE,
    OrderId_INVALID, ticker_id, side, itr-&gt;price_,
    fill_qty, Priority_INVALID};
  matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);</pre>
<p>Finally, we will generate a market update for the passive client order that existed in the book. If there is some quantity remaining on this <code>MEOrder</code>, then we generate a <code>MarketUpdateType::MODIFY</code> message and pass the remaining quantity left on that order. If the order is fully executed, then we generate a <code>MarketUpdateType::CANCEL</code> update, publish it, and also call the <code>MEOrderBook::removeOrder()</code> method to remove this <code>MEOrder</code> from the order book:</p>
<pre class="source-code">
  if (!order-&gt;qty_) {
    market_update_ = {MarketUpdateType::CANCEL,
      order-&gt;market_order_id_, ticker_id, order-&gt;side_,
      order-&gt;price_, order_qty, Priority_INVALID};
    matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
    removeOrder(order);
  } else {
    market_update_ = {MarketUpdateType::MODIFY,
      order-&gt;market_order_id_, ticker_id, order-&gt;side_,
      order-&gt;price_, order-&gt;qty_, order-&gt;priority_};
    matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
  }
}</pre>
<p>This concludes our <a id="_idIndexMarker1034"/>discussion of the operations involved in handling client <a id="_idIndexMarker1035"/>order requests, updating the limit order book inside the matching engine, and generating and publishing order responses and market updates.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor185"/>Summary</h1>
<p>We started the C++ implementation of our electronic trading ecosystem in this chapter. The first component we built was the exchange matching engine in charge of accepting and answering order requests from the order server component in the exchange infrastructure. This component is also responsible for generating and publishing market data updates to the market data publisher component in the exchange’s infrastructure.</p>
<p>First, we declared some assumptions in our matching engine and limit order books. We also defined a couple of basic <code>OrderId</code> and chain together orders at the same price inside the <code>MEOrdersAtPrice</code> structure. Reiterating what we already covered, these price levels themselves are maintained in a doubly linked list and a hash map indexed by price.</p>
<p>Then, we built the matching engine component, which is an independent thread of execution that consumes updates from the order server and publishes responses and market data updates back to the order server and the market data publisher. We also built the main application binary for the electronic trading exchange, which we will enhance in the next chapter.</p>
<p>Finally, we laid out the details of the mechanism involved in building and updating the data structures for the limit order book. We discussed the tasks involved in handling new order requests and order cancelation requests. We also implemented the functionality of the matching engine to perform the actual matching between new aggressive orders against existing passive orders that cross in price. Match events generate private execution messages for the market participants involved in a match event. Additionally, the event also generates trade messages and order deletion or modification on the public market data feed.</p>
<p>In the next chapter, we will build the market data publisher component, which is the component that consumes the market data updates generated from the matching engine and puts them on the wire for participants to consume. Additionally, we will also build the order server component that resides in the electronic trading exchange and manages the communication with the different market participant order gateways, forwarding requests and responses to and from the matching engine.</p>
</div>
</body></html>