<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-155"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.2.1">Building the C++ Matching Engine</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We spent the last chapter discussing the design of the electronic trading ecosystem we will build in this book. </span><span class="koboSpan" id="kobo.3.2">The first component we will start with is the matching engine at the exchange. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will focus on the task of building the order book of the exchange matching engine, based on orders that clients enter. </span><span class="koboSpan" id="kobo.3.4">We will implement the various data structures and algorithms needed to track these orders, perform matching when orders </span><em class="italic"><span class="koboSpan" id="kobo.4.1">cross</span></em><span class="koboSpan" id="kobo.5.1"> each other, and update the order book. </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Crossing</span></em><span class="koboSpan" id="kobo.7.1"> means when a buy order has a price equal to or greater than a sell order and then can execute against each other, but we will discuss this in greater detail in this chapter. </span><span class="koboSpan" id="kobo.7.2">We will focus on achieving the lowest latencies possible in these operations, since the exchanges with the best infrastructure are likely to do the most business and be preferred by participants. </span><span class="koboSpan" id="kobo.7.3">For now, we will not worry about the details of the market data publisher and order gateway server components at the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">trading exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Defining the operations and interactions in our </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">matching engine</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Building the matching engine and exchanging </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">external data</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Building the order book and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">matching orders</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">We will kick off this chapter by first clarifying some assumptions we will make to simplify the matching engine and limit the scope of what we can cover in this book. </span><span class="koboSpan" id="kobo.17.2">We will also define some types, constants, and basic structures in the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">first section.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">All the code for this book can be found in the GitHub repository for this book at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The source code for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">Chapter6</span></strong><span class="koboSpan" id="kobo.24.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">It is important that you have read and understand the design of the electronic trading ecosystem presented in the </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.28.1"> chapter. </span><span class="koboSpan" id="kobo.28.2">Note that in this chapter, we will also use the code we built in </span><a href="B19434_04.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Building the C++ Building Blocks for Low Latency Applications</span></em><span class="koboSpan" id="kobo.32.1">, which can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">Chapter6/common/</span></strong><span class="koboSpan" id="kobo.34.1"> directory in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The specifications of the environment in which the source code for this book was developed are shown as follows. </span><span class="koboSpan" id="kobo.36.2">We present the details of this environment because all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">your environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.38.1">OS: </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">x86_64 GNU/Linux.</span></strong></span></li>
<li><span class="koboSpan" id="kobo.41.1">GCC: </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">11.3.0-1ubuntu1~22.04.1) 11.3.0.</span></strong></span></li>
<li><span class="koboSpan" id="kobo.44.1">CMake: </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">version 3.23.2.</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Ninja: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">1.10.2.</span></strong></span></li>
</ul>
<h1 id="_idParaDest-157"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.49.1">Defining the operations and interactions in our matching engine</span></h1>
<p><span class="koboSpan" id="kobo.50.1">Here, we will declare </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.51.1">and define the types, constants, and structures we will need as we build the matching engine in </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">this chapter.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.53.1">Defining some types and constants</span></h2>
<p><span class="koboSpan" id="kobo.54.1">Let us define a few common typedefs to document the types we will use in the rest of this book. </span><span class="koboSpan" id="kobo.54.2">We will also define some constants to represent some assumptions that exist, purely for the purpose of simplifying the design of our matching engine. </span><span class="koboSpan" id="kobo.54.3">Note that you donâ€™t need these limits/constants, and we leave this enhancement up to the interested among you. </span><span class="koboSpan" id="kobo.54.4">All the code for this subsection can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">Chapter6/common/types.h</span></strong><span class="koboSpan" id="kobo.56.1"> file in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">this book.</span></span></p>
<h3><span class="koboSpan" id="kobo.58.1">Defining a few basic types</span></h3>
<p><span class="koboSpan" id="kobo.59.1">We will define some </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.60.1">types to hold different attributes in our electronic trading system, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">OrderId</span></strong><span class="koboSpan" id="kobo.63.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">identify orders</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">TickerId</span></strong><span class="koboSpan" id="kobo.66.1"> to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">trading instruments</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">ClientId</span></strong><span class="koboSpan" id="kobo.69.1"> for the exchange to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">different clients</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Price</span></strong><span class="koboSpan" id="kobo.72.1"> to hold prices </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">for instruments</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Qty</span></strong><span class="koboSpan" id="kobo.75.1"> to hold quantity values </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">for orders</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Priority</span></strong><span class="koboSpan" id="kobo.78.1"> to capture the position of an order in the </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">First In First Out</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">FIFO</span></strong><span class="koboSpan" id="kobo.82.1">) queue at a price level, as discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Designing Our Trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.84.1">Ecosystem </span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">chapter.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">Side</span></strong><span class="koboSpan" id="kobo.87.1"> to signify the side (buy/sell) of </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">an order</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.89.1">We will also provide basic methods to convert these to strings purely for logging purposes. </span><span class="koboSpan" id="kobo.89.2">Let us look at each one of these code blocks to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">declarations next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
#pragma once
#include &lt;cstdint&gt;
#include &lt;limits&gt;
#include "common/macros.h"</span></pre>
<p><span class="koboSpan" id="kobo.92.1">First, we </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.93.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">OrderId</span></strong><span class="koboSpan" id="kobo.95.1"> type to identify orders, which is simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">uint64_t</span></strong><span class="koboSpan" id="kobo.97.1">, and a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">orderIdToString()</span></strong><span class="koboSpan" id="kobo.99.1"> method to log it. </span><span class="koboSpan" id="kobo.99.2">We also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">OrderId_INVALID</span></strong><span class="koboSpan" id="kobo.101.1"> sentinel method to signify </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">invalid values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
namespace Common {
Â Â typedef uint64_t OrderId;
Â Â constexpr auto OrderId_INVALID =
Â Â Â Â std::numeric_limits&lt;OrderId&gt;::max();
Â Â inline auto orderIdToString(OrderId order_id) -&gt;
Â Â Â Â std::string {
Â Â Â Â if (UNLIKELY(order_id == OrderId_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(order_id);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.104.1">We define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">TickerId</span></strong><span class="koboSpan" id="kobo.106.1"> type to identify trading instruments, which is simply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">uint32_t</span></strong><span class="koboSpan" id="kobo.108.1"> type, and add a </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.109.1">corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">tickerIdToString()</span></strong><span class="koboSpan" id="kobo.111.1"> method </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.112.1">for it. </span><span class="koboSpan" id="kobo.112.2">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">TickerId_INVALID</span></strong><span class="koboSpan" id="kobo.114.1"> sentinel value for </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">invalid instruments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
Â Â typedef uint32_t TickerId;
Â Â constexpr auto TickerId_INVALID =
Â Â Â Â std::numeric_limits&lt;TickerId&gt;::max();
Â Â inline auto tickerIdToString(TickerId ticker_id) -&gt;
Â Â Â Â std::string {
Â Â Â Â if (UNLIKELY(ticker_id == TickerId_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(ticker_id);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.117.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">ClientId</span></strong><span class="koboSpan" id="kobo.119.1"> type is </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.120.1">used to differentiate between different </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.121.1">trading participants. </span><span class="koboSpan" id="kobo.121.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">ClientId_INVALID</span></strong><span class="koboSpan" id="kobo.123.1"> value represents an invalid sentinel. </span><span class="koboSpan" id="kobo.123.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">clientIdToString()</span></strong><span class="koboSpan" id="kobo.125.1"> method is used for </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">logging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
Â Â typedef uint32_t ClientId;
Â Â constexpr auto ClientId_INVALID =
Â Â Â Â std::numeric_limits&lt;ClientId&gt;::max();
Â Â inline auto clientIdToString(ClientId client_id) -&gt;
Â Â Â Â std::string {
Â Â Â Â if (UNLIKELY(client_id == ClientId_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(client_id);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.128.1">The next type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Price</span></strong><span class="koboSpan" id="kobo.130.1">, which is </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.131.1">used to capture prices on orders. </span><span class="koboSpan" id="kobo.131.2">We also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Price_INVALID</span></strong><span class="koboSpan" id="kobo.133.1"> constant to represent invalid prices. </span><span class="koboSpan" id="kobo.133.2">Finally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">priceToString()</span></strong><span class="koboSpan" id="kobo.135.1"> method to </span><em class="italic"><span class="koboSpan" id="kobo.136.1">stringify</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.137.1">these values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
Â Â typedef int64_t Price;
Â Â constexpr auto Price_INVALID =
Â Â Â Â std::numeric_limits&lt;Price&gt;::max();
Â Â inline auto priceToString(Price price) -&gt; std::string {
Â Â Â Â if (UNLIKELY(price == Price_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(price);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.139.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Qty</span></strong><span class="koboSpan" id="kobo.141.1"> type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">typedef</span></strong><span class="koboSpan" id="kobo.143.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">uint32_t</span></strong><span class="koboSpan" id="kobo.145.1"> and represents order quantities. </span><span class="koboSpan" id="kobo.145.2">We also provide </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.146.1">the usual </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Qty_INVALID</span></strong><span class="koboSpan" id="kobo.148.1"> sentinel and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">qtyToString()</span></strong><span class="koboSpan" id="kobo.150.1"> method </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.151.1">to convert them </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">to strings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
Â Â typedef uint32_t Qty;
Â Â constexpr auto Qty_INVALID =
Â Â Â Â std::numeric_limits&lt;Qty&gt;::max();
Â Â inline auto qtyToString(Qty qty) -&gt; std::string {
Â Â Â Â if (UNLIKELY(qty == Qty_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(qty);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.154.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Priority</span></strong><span class="koboSpan" id="kobo.156.1"> type is just a </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.157.1">position in the queue of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">uint64_t</span></strong><span class="koboSpan" id="kobo.159.1">. </span><span class="koboSpan" id="kobo.159.2">We assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Priority_INVALID</span></strong><span class="koboSpan" id="kobo.161.1"> sentinel value and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">priorityToString()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
Â Â typedef uint64_t Priority;
Â Â constexpr auto Priority_INVALID =
Â Â Â Â std::numeric_limits&lt;Priority&gt;::max();
Â Â inline auto priorityToString(Priority priority) -&gt;
Â Â Â Â std::string {
Â Â Â Â if (UNLIKELY(priority == Priority_INVALID)) {
Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return std::to_string(priority);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.165.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Side</span></strong><span class="koboSpan" id="kobo.167.1"> type is an enumeration </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.168.1">and contains two valid values, as shown in the following code block. </span><span class="koboSpan" id="kobo.168.2">We </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.169.1">also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">sideToString()</span></strong><span class="koboSpan" id="kobo.171.1"> method, as we did for the other </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">types previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
Â Â enum class Side : int8_t {
Â Â Â Â INVALID = 0,
Â Â Â Â BUY = 1,
Â Â Â Â SELL = -1
Â Â };
Â Â inline auto sideToString(Side side) -&gt; std::string {
Â Â Â Â switch (side) {
Â Â Â Â Â Â case Side::BUY:
Â Â Â Â Â Â Â Â return "BUY";
Â Â Â Â Â Â case Side::SELL:
Â Â Â Â Â Â Â Â return "SELL";
Â Â Â Â Â Â case Side::INVALID:
Â Â Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return "UNKNOWN";
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.174.1">Those are all the </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.175.1">basic types we need for this chapter. </span><span class="koboSpan" id="kobo.175.2">Next, we will define some limits to simplify the design of </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">our system.</span></span></p>
<h3><span class="koboSpan" id="kobo.177.1">Defining some limits and constraints</span></h3>
<p><span class="koboSpan" id="kobo.178.1">We will define the </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.179.1">following </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">constant limits:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">LOG_QUEUE_SIZE</span></strong><span class="koboSpan" id="kobo.182.1"> represents the size of the lock-free queue used by the logger. </span><span class="koboSpan" id="kobo.182.2">This holds the maximum number of characters that can be held in memory without the logger queue </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">being full.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.185.1"> represents the number of trading instruments the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">exchange supports.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">ME_MAX_CLIENT_UPDATES</span></strong><span class="koboSpan" id="kobo.188.1"> holds the maximum number of unprocessed order requests from all clients that the matching engine has not processed yet. </span><span class="koboSpan" id="kobo.188.2">This also represents the maximum number of order responses from the matching engine that the order server has not </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">published yet.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">ME_MAX_MARKET_UPDATES</span></strong><span class="koboSpan" id="kobo.191.1"> represents the maximum number of market updates generated by the matching engine that have not yet been published by the market </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">data publisher.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ME_MAX_NUM_CLIENTS</span></strong><span class="koboSpan" id="kobo.194.1"> holds how many maximum simultaneous market participants can exist in our </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">trading ecosystem.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">ME_MAX_ORDER_IDS</span></strong><span class="koboSpan" id="kobo.197.1"> is the maximum number of orders possible for a single </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">trading instrument.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">ME_MAX_PRICE_LEVELS</span></strong><span class="koboSpan" id="kobo.200.1"> represents the maximum depth of price levels for the limit order book that the matching </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">engine maintains.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.202.1">Note that these </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.203.1">values have been chosen arbitrarily here; these can be increased or decreased, depending on the capacity of the system on which we run the electronic trading ecosystem. </span><span class="koboSpan" id="kobo.203.2">We chose powers of two to enable the possibility of using shifts over multiplies when trying to compute addresses; however, the effect is negligible on modern processors, and we would not recommend worrying about this too much. </span><span class="koboSpan" id="kobo.203.3">The source for the constants we described previously is </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
namespace Common {
Â Â constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;
Â Â constexpr size_t ME_MAX_TICKERS = 8;
Â Â constexpr size_t ME_MAX_CLIENT_UPDATES = 256 * 1024;
Â Â constexpr size_t ME_MAX_MARKET_UPDATES = 256 * 1024;
Â Â constexpr size_t ME_MAX_NUM_CLIENTS = 256;
Â Â constexpr size_t ME_MAX_ORDER_IDS = 1024 * 1024;
Â Â constexpr size_t ME_MAX_PRICE_LEVELS = 256;
}</span></pre>
<p><span class="koboSpan" id="kobo.206.1">These are all the constants we require for now. </span><span class="koboSpan" id="kobo.206.2">Now, we can shift our attention to more complex structures that we will need inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">matching engine.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.208.1">Designing the matching engine</span></h2>
<p><span class="koboSpan" id="kobo.209.1">We will need a </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.210.1">few structures for our matching engine to communicate with the market data publisher and order </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">server components.</span></span></p>
<h3><span class="koboSpan" id="kobo.212.1">Defining the MEClientRequest and ClientRequestLFQueue types</span></h3>
<p><span class="koboSpan" id="kobo.213.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.215.1"> structure is used by the order server to forward order requests from the </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.216.1">clients to the matching engine. </span><span class="koboSpan" id="kobo.216.2">Remember </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.217.1">that the communication </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.218.1">from the order server </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.219.1">to the matching engine is established through the lock-free queue component we built earlier. </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.221.1"> is a typedef for a lock-free queue of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.223.1"> objects. </span><span class="koboSpan" id="kobo.223.2">The code for this structure can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">Chapter6/order_server/client_request.h</span></strong><span class="koboSpan" id="kobo.225.1"> file in the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">GitHub repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {</span></pre>
<p><span class="koboSpan" id="kobo.228.1">Note two things here â€“ we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">#pragma pack()</span></strong><span class="koboSpan" id="kobo.230.1"> directive to make sure these structures are packed and do not contain any extra padding. </span><span class="koboSpan" id="kobo.230.2">This is important because these will be sent and received over a network as flat binary structures in later chapters. </span><span class="koboSpan" id="kobo.230.3">We also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">ClientRequestType</span></strong><span class="koboSpan" id="kobo.232.1"> enumeration to define what type of order request it is â€“ whether it is a new order or a cancel request for an existing order. </span><span class="koboSpan" id="kobo.232.2">We also define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">INVALID</span></strong><span class="koboSpan" id="kobo.234.1"> sentinel value and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">clientRequestTypeToString()</span></strong><span class="koboSpan" id="kobo.236.1"> method to </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.237.1">convert this enumeration into </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">human-readable </span></span><span class="No-Break"><a id="_idIndexMarker889"/></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">strings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
#pragma pack(push, 1)
Â Â enum class ClientRequestType : uint8_t {
Â Â Â Â INVALID = 0,
Â Â Â Â NEW = 1,
Â Â Â Â CANCEL = 2
Â Â };
Â Â inline std::string
Â Â Â Â clientRequestTypeToString(ClientRequestType type) {
Â Â Â Â switch (type) {
Â Â Â Â Â Â case ClientRequestType::NEW:
Â Â Â Â Â Â Â Â return "NEW";
Â Â Â Â Â Â case ClientRequestType::CANCEL:
Â Â Â Â Â Â Â Â return "CANCEL";
Â Â Â Â Â Â case ClientRequestType::INVALID:
Â Â Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return "UNKNOWN";
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.241.1">Now, we can </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.242.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.244.1"> structure, which </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.245.1">will contain information for a single order request from the trading participant to the exchange. </span><span class="koboSpan" id="kobo.245.2">Note that this is the internal representation that the matching engine uses, not necessarily the exact format that the client sends. </span><span class="koboSpan" id="kobo.245.3">We will look at that in the next chapter, </span><em class="italic"><span class="koboSpan" id="kobo.246.1">Communicating with Market Participants</span></em><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">The important members of this struct are </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.249.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">type_</span></strong><span class="koboSpan" id="kobo.251.1"> variable of </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ClientRequestType</span></strong></span></li>
<li><span class="koboSpan" id="kobo.254.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">client_id_</span></strong><span class="koboSpan" id="kobo.256.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ClientId</span></strong><span class="koboSpan" id="kobo.258.1"> of the trading client that sent </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">this request</span></span></li>
<li><span class="koboSpan" id="kobo.260.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.262.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">TickerId</span></strong><span class="koboSpan" id="kobo.264.1"> of the instrument for which this request </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">is meant</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">OrderId</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">order_id_</span></strong><span class="koboSpan" id="kobo.269.1">) of the order for which this request is made, which can be a new order or reference an </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">existing order</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Side</span></strong><span class="koboSpan" id="kobo.272.1"> of the order in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">side_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.274.1"> variable</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Price</span></strong><span class="koboSpan" id="kobo.276.1"> of the </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.277.1">order in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">price_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1"> variable</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Qty</span></strong><span class="koboSpan" id="kobo.281.1"> of the order </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.282.1">saved in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">qty_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1"> variable</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.285.1">Additionally, we </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.286.1">will also add a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">toString()</span></strong><span class="koboSpan" id="kobo.288.1"> method </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.289.1">to help us later on with logging, as </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
Â Â struct MEClientRequest {
Â Â Â Â ClientRequestType type_ = ClientRequestType::INVALID;
Â Â Â Â ClientId client_id_ = ClientId_INVALID;
Â Â Â Â TickerId ticker_id_ = TickerId_INVALID;
Â Â Â Â OrderId order_id_ = OrderId_INVALID;
Â Â Â Â Side side_ = Side::INVALID;
Â Â Â Â Price price_ = Price_INVALID;
Â Â Â Â Qty qty_ = Qty_INVALID;
Â Â Â Â auto toString() const {
Â Â Â Â Â Â std::stringstream ss;
Â Â Â Â Â Â ss &lt;&lt; "MEClientRequest"
Â Â Â Â Â Â Â Â Â &lt;&lt; " ["
Â Â Â Â Â Â Â Â Â &lt;&lt; "type:" &lt;&lt; clientRequestTypeToString(type_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " client:" &lt;&lt; clientIdToString(client_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " oid:" &lt;&lt; orderIdToString(order_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " side:" &lt;&lt; sideToString(side_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " qty:" &lt;&lt; qtyToString(qty_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " price:" &lt;&lt; priceToString(price_)
Â Â Â Â Â Â Â Â Â &lt;&lt; "]";
Â Â Â Â Â Â return ss.str();
Â Â Â Â }
Â Â };</span></pre>
<p><span class="koboSpan" id="kobo.292.1">As discussed </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.293.1">previously, we also define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.295.1"> typedef </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.296.1">to represent the lock-free queue of </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.297.1">these structures, as </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.298.1">shown in the following code snippet. </span><span class="koboSpan" id="kobo.298.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">#pragma pack(pop)</span></strong><span class="koboSpan" id="kobo.300.1"> simply restores the alignment setting to the default â€“ that is, not tightly packed (which we had set by specifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">#pragma pack(push, 1)</span></strong><span class="koboSpan" id="kobo.302.1"> directive). </span><span class="koboSpan" id="kobo.302.2">This is because we only want to tightly pack the structures that will be sent over a network and </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">no others:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
#pragma pack(pop)
Â Â typedef LFQueue&lt;MEClientRequest&gt; ClientRequestLFQueue;
}</span></pre>
<p><span class="koboSpan" id="kobo.305.1">We will define a similar structure used by the matching engine that sends order responses to the order server component. </span><span class="koboSpan" id="kobo.305.2">Let us look at that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">next subsection.</span></span></p>
<h3><span class="koboSpan" id="kobo.307.1">Defining the MEClientResponse and ClientResponseLFQueue types</span></h3>
<p><span class="koboSpan" id="kobo.308.1">Let us present </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.309.1">the implementation </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.310.1">of the structure used </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.311.1">by the matching engine that sends </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.312.1">order responses for the order server component to dispatch to clients. </span><span class="koboSpan" id="kobo.312.2">Similar to the last section, we will also define </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.314.1">, which is a lock-free queue of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.316.1"> objects. </span><span class="koboSpan" id="kobo.316.2">The code for this structure is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Chapter6/order_server/client_response.h</span></strong><span class="koboSpan" id="kobo.318.1"> source file in the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">GitHub repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
#include "common/lf_queue.h"
using namespace Common;
namespace Exchange {</span></pre>
<p><span class="koboSpan" id="kobo.321.1">First, we will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">ClientResponseType</span></strong><span class="koboSpan" id="kobo.323.1"> enumeration to represent the type of response for client orders. </span><span class="koboSpan" id="kobo.323.2">In addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">INVALID</span></strong><span class="koboSpan" id="kobo.325.1"> sentinel value, it contains values that represent when a request for a new order is accepted, an order is canceled, an order is executed, or a cancel request is rejected by the matching engine. </span><span class="koboSpan" id="kobo.325.2">We also add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">clientResponseTypeToString()</span></strong><span class="koboSpan" id="kobo.327.1"> method to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ClientResponseType</span></strong><span class="koboSpan" id="kobo.329.1"> values </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">to strings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
#pragma pack(push, 1)
Â Â enum class ClientResponseType : uint8_t {
Â Â Â Â INVALID = 0,
Â Â Â Â ACCEPTED = 1,
Â Â Â Â CANCELED = 2,
Â Â Â Â FILLED = 3,
Â Â Â Â CANCEL_REJECTED = 4
Â Â };
Â Â inline std::string
Â Â Â Â clientResponseTypeToString(ClientResponseType type) {
Â Â Â Â switch (type) {
Â Â Â Â Â Â case ClientResponseType::ACCEPTED:
Â Â Â Â Â Â Â Â return "ACCEPTED";
Â Â Â Â Â Â case ClientResponseType::CANCELED:
Â Â Â Â Â Â Â Â return "CANCELED";
Â Â Â Â Â Â case ClientResponseType::FILLED:
Â Â Â Â Â Â Â Â return "FILLED";
Â Â Â Â Â Â case ClientResponseType::CANCEL_REJECTED:
Â Â Â Â Â Â Â Â return "CANCEL_REJECTED";
Â Â Â Â Â Â case ClientResponseType::INVALID:
Â Â Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return "UNKNOWN";
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.332.1">Finally, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.334.1"> message used internally by the matching engine to communicate </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.335.1">order response messages </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.336.1">for the trading clients when </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.337.1">there are updates to the </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.338.1">clientâ€™s orders. </span><span class="koboSpan" id="kobo.338.2">Before we look at the source code, the important data members in this struct are listed </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.340.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">ClientResponseType type_</span></strong><span class="koboSpan" id="kobo.342.1"> variable to represent the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">client response.</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">client_id_</span></strong><span class="koboSpan" id="kobo.346.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">ClientId</span></strong><span class="koboSpan" id="kobo.348.1"> to represent which market participant the response message is </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">meant for.</span></span></li>
<li><span class="koboSpan" id="kobo.350.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.352.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">TickerId</span></strong><span class="koboSpan" id="kobo.354.1"> to represent the trading instrument of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">this response.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">client_order_id_</span></strong><span class="koboSpan" id="kobo.358.1"> variable that identifies </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">OrderId</span></strong><span class="koboSpan" id="kobo.360.1"> of the order this response message affects. </span><span class="koboSpan" id="kobo.360.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">OrderId</span></strong><span class="koboSpan" id="kobo.362.1"> is the one that the client sent in the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.364.1"> message for </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the order.</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">market_order_id_</span></strong><span class="koboSpan" id="kobo.368.1"> variable, also of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">OrderId</span></strong><span class="koboSpan" id="kobo.370.1">, but this one identifies this order in the public market data stream. </span><span class="koboSpan" id="kobo.370.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">OrderId</span></strong><span class="koboSpan" id="kobo.372.1"> is unique across all market participants, since it is possible for different market participants to send orders with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">client_order_id_</span></strong><span class="koboSpan" id="kobo.374.1"> value. </span><span class="koboSpan" id="kobo.374.2">Even in those cases, two orders with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">client_order_id_</span></strong><span class="koboSpan" id="kobo.376.1"> will have different </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">market_order_id_</span></strong><span class="koboSpan" id="kobo.378.1"> values in their responses. </span><span class="koboSpan" id="kobo.378.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">market_order_id_</span></strong><span class="koboSpan" id="kobo.380.1"> value is also used when generating market updates for </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">this order.</span></span></li>
<li><span class="koboSpan" id="kobo.382.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">side_</span></strong><span class="koboSpan" id="kobo.384.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Side</span></strong><span class="koboSpan" id="kobo.386.1"> to represent the side of this </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">order response.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Price</span></strong><span class="koboSpan" id="kobo.389.1"> of this client response update and whether it is accepted, canceled </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">or executed.</span></span></li>
<li><span class="koboSpan" id="kobo.391.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">exec_qty_</span></strong><span class="koboSpan" id="kobo.393.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Qty</span></strong><span class="koboSpan" id="kobo.395.1">, which is only used in the event of an order execution. </span><span class="koboSpan" id="kobo.395.2">This variable is used to hold how much quantity was executed in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.397.1"> message. </span><span class="koboSpan" id="kobo.397.2">This value is not cumulative, meaning that when an order gets partially executed multiple times, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.399.1"> message is generated for each individual execution and only contains the quantity executed in that particular execution, not across all </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">of them.</span></span></li>
<li><span class="koboSpan" id="kobo.401.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">leaves_qty_</span></strong><span class="koboSpan" id="kobo.403.1"> variable, also of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Qty</span></strong><span class="koboSpan" id="kobo.405.1">, which represents how much of the original orderâ€™s quantity is still live in the matching engineâ€™s order book. </span><span class="koboSpan" id="kobo.405.2">This is used to communicate the size of this specific order in the book, which is still active for further </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">possible executions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.407.1">Finally, we also </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.408.1">have our usual </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">toString()</span></strong><span class="koboSpan" id="kobo.410.1"> method </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.411.1">for easy logging purposes. </span><span class="koboSpan" id="kobo.411.2">The </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.412.1">definition of </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.413.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.415.1"> structure, as discussed previously, is </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">presented next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
Â Â struct MEClientResponse {
Â Â Â Â ClientResponseType type_ = ClientResponseType::INVALID;
Â Â Â Â ClientId client_id_ = ClientId_INVALID;
Â Â Â Â TickerId ticker_id_ = TickerId_INVALID;
Â Â Â Â OrderId client_order_id_ = OrderId_INVALID;
Â Â Â Â OrderId market_order_id_ = OrderId_INVALID;
Â Â Â Â Side side_ = Side::INVALID;
Â Â Â Â Price price_ = Price_INVALID;
Â Â Â Â Qty exec_qty_ = Qty_INVALID;
Â Â Â Â Qty leaves_qty_ = Qty_INVALID;
Â Â Â Â auto toString() const {
Â Â Â Â Â Â std::stringstream ss;
Â Â Â Â Â Â ss &lt;&lt; "MEClientResponse"
Â Â Â Â Â Â Â Â Â &lt;&lt; " ["
Â Â Â Â Â Â Â Â Â &lt;&lt; "type:" &lt;&lt; clientResponseTypeToString(type_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " client:" &lt;&lt; clientIdToString(client_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " coid:" &lt;&lt; orderIdToString(client_order_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " moid:" &lt;&lt; orderIdToString(market_order_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " side:" &lt;&lt; sideToString(side_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " exec_qty:" &lt;&lt; qtyToString(exec_qty_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " leaves_qty:" &lt;&lt; qtyToString(leaves_qty_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " price:" &lt;&lt; priceToString(price_)
Â Â Â Â Â Â Â Â Â &lt;&lt; "]";
Â Â Â Â Â Â return ss.str();
Â Â Â Â }
Â Â };
#pragma pack(pop)</span></pre>
<p><span class="koboSpan" id="kobo.418.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.420.1"> type definition is presented as follows, which represents a lock-free queue of the structures we </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">discussed previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
Â Â typedef LFQueue&lt;MEClientResponse&gt; ClientResponseLFQueue;
}</span></pre>
<p><span class="koboSpan" id="kobo.423.1">That concludes the </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.424.1">discussion of the structures </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.425.1">we need to represent client </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.426.1">requests and </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.427.1">responses to and from the matching engine. </span><span class="koboSpan" id="kobo.427.2">Let us move on to the market update structure in the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">next subsection.</span></span></p>
<h3><span class="koboSpan" id="kobo.429.1">Defining the MEMarketUpdate and MEMarketUpdateLFQueue types</span></h3>
<p><span class="koboSpan" id="kobo.430.1">The market update </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.431.1">structure is used by the matching engine </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.432.1">to provide market data updates to </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.433.1">the market data </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.434.1">publishing component. </span><span class="koboSpan" id="kobo.434.2">We also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.436.1"> type to represent a lock-free queue of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.438.1"> objects. </span><span class="koboSpan" id="kobo.438.2">The code for this can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Chapter6/exchange/market_data/market_update.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.440.1">source file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
#pragma once
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Exchange {</span></pre>
<p><span class="koboSpan" id="kobo.442.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.444.1"> struct also needs to be a packed structure, since it will be part of the message that is sent and received over the network; hence, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">#pragma pack()</span></strong><span class="koboSpan" id="kobo.446.1"> directive again. </span><span class="koboSpan" id="kobo.446.2">Before we define the struct, we need to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">MarketUpdateType</span></strong><span class="koboSpan" id="kobo.448.1"> enumeration that represents the update action in the market update for an order. </span><span class="koboSpan" id="kobo.448.2">In addition to taking on an </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">INVALID</span></strong><span class="koboSpan" id="kobo.450.1"> sentinel value, it can also be used to represent events such as an order being added, modified, or canceled in the order book, as well as trade events in </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the market:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
#pragma pack(push, 1)
Â Â enum class MarketUpdateType : uint8_t {
Â Â Â Â INVALID = 0,
Â Â Â Â ADD = 1,
Â Â Â Â MODIFY = 2,
Â Â Â Â CANCEL = 3,
Â Â Â Â TRADE = 4
Â Â };
Â Â inline std::string
Â Â Â Â marketUpdateTypeToString(MarketUpdateType type) {
Â Â Â Â switch (type) {
Â Â Â Â Â Â case MarketUpdateType::ADD:
Â Â Â Â Â Â Â Â return "ADD";
Â Â Â Â Â Â case MarketUpdateType::MODIFY:
Â Â Â Â Â Â Â Â return "MODIFY";
Â Â Â Â Â Â case MarketUpdateType::CANCEL:
Â Â Â Â Â Â Â Â return "CANCEL";
Â Â Â Â Â Â case MarketUpdateType::TRADE:
Â Â Â Â Â Â Â Â return "TRADE";
Â Â Â Â Â Â case MarketUpdateType::INVALID:
Â Â Â Â Â Â Â Â return "INVALID";
Â Â Â Â }
Â Â Â Â return "UNKNOWN";
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.453.1">Finally, we </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.454.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.456.1"> struct, which </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.457.1">contains the following important </span><a id="_idIndexMarker922"/><span class="No-Break"><span class="koboSpan" id="kobo.458.1">data members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.459.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">type_</span></strong><span class="koboSpan" id="kobo.461.1"> variable </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.462.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">MarketUpdateType</span></strong><span class="koboSpan" id="kobo.464.1"> to represent the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">market update.</span></span></li>
<li><span class="koboSpan" id="kobo.466.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">order_id_</span></strong><span class="koboSpan" id="kobo.468.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">OrderId</span></strong><span class="koboSpan" id="kobo.470.1"> to represent the specific order in the limit order book for which this order update </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">is applicable.</span></span></li>
<li><span class="koboSpan" id="kobo.472.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.474.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">TickerId</span></strong><span class="koboSpan" id="kobo.476.1"> to represent the trading instrument that this update </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">applies to.</span></span></li>
<li><span class="koboSpan" id="kobo.478.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Side</span></strong><span class="koboSpan" id="kobo.480.1"> variable to represent the side of </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">this order.</span></span></li>
<li><span class="koboSpan" id="kobo.482.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Price</span></strong><span class="koboSpan" id="kobo.484.1"> variable for the exact price of the order in this market </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">order update.</span></span></li>
<li><span class="koboSpan" id="kobo.486.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">priority_</span></strong><span class="koboSpan" id="kobo.488.1"> field of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Priority</span></strong><span class="koboSpan" id="kobo.490.1">, which, as we discussed before, will be used to specify the exact position of this order in the FIFO queue. </span><span class="koboSpan" id="kobo.490.2">We build a FIFO queue of all orders at the same price. </span><span class="koboSpan" id="kobo.490.3">This field specifies the position/location of this order in </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">that queue.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.492.1">The complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.494.1"> struct is </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.495.1">shown in </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.496.1">the following code block, along </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.497.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.499.1"> typedef, which </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.500.1">captures a lock-free queue of </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">MEMarketUpdate</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.502.1">struct messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
Â Â struct MEMarketUpdate {
Â Â Â Â MarketUpdateType type_ = MarketUpdateType::INVALID;
Â Â Â Â OrderId order_id_ = OrderId_INVALID;
Â Â Â Â TickerId ticker_id_ = TickerId_INVALID;
Â Â Â Â Side side_ = Side::INVALID;
Â Â Â Â Price price_ = Price_INVALID;
Â Â Â Â Qty qty_ = Qty_INVALID;
Â Â Â Â Priority priority_ = Priority_INVALID;
Â Â Â Â auto toString() const {
Â Â Â Â Â Â std::stringstream ss;
Â Â Â Â Â Â ss &lt;&lt; "MEMarketUpdate"
Â Â Â Â Â Â Â Â Â &lt;&lt; " ["
Â Â Â Â Â Â Â Â Â &lt;&lt; " type:" &lt;&lt; marketUpdateTypeToString(type_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " ticker:" &lt;&lt; tickerIdToString(ticker_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " oid:" &lt;&lt; orderIdToString(order_id_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " side:" &lt;&lt; sideToString(side_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " qty:" &lt;&lt; qtyToString(qty_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " price:" &lt;&lt; priceToString(price_)
Â Â Â Â Â Â Â Â Â &lt;&lt; " priority:" &lt;&lt; priorityToString(priority_)
Â Â Â Â Â Â Â Â Â &lt;&lt; "]";
Â Â Â Â Â Â return ss.str();
Â Â Â Â }
Â Â };
#pragma pack(pop)
Â Â typedef Common::LFQueue&lt;Exchange::MEMarketUpdate&gt;
Â Â Â Â MEMarketUpdateLFQueue;
}</span></pre>
<p><span class="koboSpan" id="kobo.504.1">This concludes </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.505.1">the structures we will need to represent and </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.506.1">publish market data updates from </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.507.1">the matching </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.508.1">engine. </span><span class="koboSpan" id="kobo.508.2">In the next subsection, we will build some structures and define some types that we will use to build the limit </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">order book.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.510.1">Designing the exchange order book</span></h2>
<p><span class="koboSpan" id="kobo.511.1">In this section, we will define some building blocks that will be used to build, maintain, and update the limit </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.512.1">order book in an efficient manner. </span><span class="koboSpan" id="kobo.512.2">Before we </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.513.1">discuss each of the structures and objects we will need, we will present a diagram for you to build a visual understanding of the limit order </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">book implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">The limit order book is organized </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.516.1">as a collection of buy orders (referred to as bids) and sell </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.517.1">orders (referred to as asks). </span><span class="koboSpan" id="kobo.517.2">Orders that are entered at the same price are organized in the </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">First In First Out</span></strong><span class="koboSpan" id="kobo.519.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">FIFO</span></strong><span class="koboSpan" id="kobo.521.1">) order in our matching engine. </span><span class="koboSpan" id="kobo.521.2">We </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.522.1">discussed these details in the </span><em class="italic"><span class="koboSpan" id="kobo.523.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.524.1"> chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.525.1">Designing the C++ matching engine in a trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.526.1">exchange</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">For the order book we build inside the matching engine, we have a list of bid prices and ask prices that have active orders. </span><span class="koboSpan" id="kobo.528.2">Each price level is represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.530.1"> struct, as shown in the following diagram. </span><span class="koboSpan" id="kobo.530.2">The bids are sorted from highest to lowest price level, and the asks are sorted from lowest to highest price level. </span><span class="koboSpan" id="kobo.530.3">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.532.1"> stores the individual orders from highest to lowest priority in a doubly linked list. </span><span class="koboSpan" id="kobo.532.2">Information for each individual order is contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">MEOrder</span></strong><span class="koboSpan" id="kobo.534.1"> structs. </span><span class="koboSpan" id="kobo.534.2">We will track each price level in a hash map of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.536.1">, which is indexed by the price of that level. </span><span class="koboSpan" id="kobo.536.2">We will also track each </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">MEOrder</span></strong><span class="koboSpan" id="kobo.538.1"> object by their </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">market_order_id_</span></strong><span class="koboSpan" id="kobo.540.1"> value in a hash map of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">The diagram representing this design of our matching engine order book is presented </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">as follows.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.544.1"><img alt="Figure 6.1 â€“ The design of the limit order book inside the matching engine" src="image/Figure_6.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.545.1">Figure 6.1 â€“ The design of the limit order book inside the matching engine</span></p>
<p><span class="koboSpan" id="kobo.546.1">Now that we have discussed the overall design of the limit order book data structure and the components </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.547.1">that make it up, we can start defining the </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.548.1">basic structs we need to implement that design. </span><span class="koboSpan" id="kobo.548.2">In the next subsection, we will first design the basic blocks â€“ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">MEOrder</span></strong><span class="koboSpan" id="kobo.550.1"> structure to hold information for a </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">single order.</span></span></p>
<h3><span class="koboSpan" id="kobo.552.1">Defining the MEOrder, OrderHashMap, and ClientOrderHashMap types</span></h3>
<p><span class="koboSpan" id="kobo.553.1">The first </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.554.1">structure is used to hold information </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.555.1">inside the book for a single limit </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.556.1">order, which </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.557.1">we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">MEOrder</span></strong><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">This is shown in the following code </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.560.1">blocks, and the </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.561.1">code can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Chapter6/matcher/me_order.h</span></strong><span class="koboSpan" id="kobo.563.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Chapter6/matcher/me_order.cpp</span></strong><span class="koboSpan" id="kobo.565.1"> source files in the </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">MEOrder</span></strong><span class="koboSpan" id="kobo.569.1"> struct has the following important data members in it to save the attributes required to represent a single order in the limit </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">order book:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.571.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.573.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">TickerId</span></strong><span class="koboSpan" id="kobo.575.1"> to represent the instrument that this order </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">corresponds to.</span></span></li>
<li><span class="koboSpan" id="kobo.577.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">client_id_</span></strong><span class="koboSpan" id="kobo.579.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">ClientId</span></strong><span class="koboSpan" id="kobo.581.1"> that captures the market participant who owns </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">this order.</span></span></li>
<li><span class="koboSpan" id="kobo.583.1">Two </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">OrderId</span></strong><span class="koboSpan" id="kobo.585.1"> sets, as </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.586.1">we discussed </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.587.1">before â€“ </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">client_order_id_</span></strong><span class="koboSpan" id="kobo.589.1">, which </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.590.1">is what the client sent on its order request, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">market_order_id_</span></strong><span class="koboSpan" id="kobo.592.1">, which </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.593.1">is generated </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.594.1">by the matching engine and is unique </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.595.1">across </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">all clients.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Side side_</span></strong><span class="koboSpan" id="kobo.598.1"> to represent whether the order is a buy or </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">sell order.</span></span></li>
<li><span class="koboSpan" id="kobo.600.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">price_</span></strong><span class="koboSpan" id="kobo.602.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Price</span></strong><span class="koboSpan" id="kobo.604.1"> to represent the price of </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the order.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Qty qty_</span></strong><span class="koboSpan" id="kobo.607.1"> to represent the quantity of the order that is still active in the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">order book.</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">priority_</span></strong><span class="koboSpan" id="kobo.611.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Priority</span></strong><span class="koboSpan" id="kobo.613.1">, which, as we discussed before, will represent the exact position of this order in the queue of other </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">MEOrder</span></strong><span class="koboSpan" id="kobo.615.1"> instances with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">side_</span></strong><span class="koboSpan" id="kobo.617.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">price_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> values.</span></span></li>
<li><span class="koboSpan" id="kobo.620.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">MEOrder</span></strong><span class="koboSpan" id="kobo.622.1"> structure also has two pointers to other </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">MEOrder</span></strong><span class="koboSpan" id="kobo.624.1"> objects. </span><span class="koboSpan" id="kobo.624.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">MEOrder</span></strong><span class="koboSpan" id="kobo.626.1"> objects are also maintained as a doubly linked list of orders arranged at a price level in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.628.1"> structure, as we discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">previous section:</span></span></li>
</ul>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
#pragma once
#include &lt;array&gt;
#include &lt;sstream&gt;
#include "common/types.h"
using namespace Common;
namespace Exchange {
Â Â struct MEOrder {
Â Â Â Â TickerId ticker_id_ = TickerId_INVALID;
Â Â Â Â ClientId client_id_ = ClientId_INVALID;
Â Â Â Â OrderId client_order_id_ = OrderId_INVALID;
Â Â Â Â OrderId market_order_id_ = OrderId_INVALID;
Â Â Â Â Side side_ = Side::INVALID;
Â Â Â Â Price price_ = Price_INVALID;
Â Â Â Â Qty qty_ = Qty_INVALID;
Â Â Â Â Priority priority_ = Priority_INVALID;
Â Â Â Â MEOrder *prev_order_ = nullptr;
Â Â Â Â MEOrder *next_order_ = nullptr;
Â Â Â Â // only needed for use with MemPool.
</span><span class="koboSpan" id="kobo.630.2">Â Â Â Â MEOrder() = default;
Â Â Â Â MEOrder(TickerId ticker_id, ClientId client_id, OrderId
Â Â Â Â Â Â client_order_id, OrderId market_order_id, Side side,
Â Â Â Â Â Â Price price,Qty qty, Priority priority, MEOrder
Â Â Â Â Â Â *prev_order, MEOrder *next_order) noexcept
Â Â Â Â Â Â Â Â :Â Â Â Â Â ticker_id_(ticker_id),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â client_id_(client_id),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â client_order_id_(client_order_id),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â market_order_id_(market_order_id),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â side_(side),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â price_(price),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â qty_(qty),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â priority_(priority),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â prev_order_(prev_order),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â next_order_(next_order) {}
Â Â Â Â auto toString() const -&gt; std::string;
Â Â };</span></pre>
<p><span class="koboSpan" id="kobo.631.1">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.633.1"> type </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.634.1">is used to </span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.635.1">represent a hash map, implemented using </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">std::array</span></strong><span class="koboSpan" id="kobo.637.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">OrderId</span></strong><span class="koboSpan" id="kobo.639.1"> is the key and </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">MEOrder</span></strong><span class="koboSpan" id="kobo.641.1"> is the </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.642.1">value. </span><span class="koboSpan" id="kobo.642.2">We will </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.643.1">also define </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.644.1">another type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">ClientOrderHashMap</span></strong><span class="koboSpan" id="kobo.646.1">, which is a hash map, implemented using </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">std::array</span></strong><span class="koboSpan" id="kobo.648.1"> to </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.649.1">represent a mapping from </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">ClientId</span></strong><span class="koboSpan" id="kobo.651.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">OrderHashMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.653.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.654.1">
Â Â typedef std::array&lt;MEOrder *, ME_MAX_ORDER_IDS&gt;
Â Â Â Â OrderHashMap;
Â Â Typedef std::array&lt;OrderHashMap, ME_MAX_NUM_CLIENTS&gt;
Â Â Â Â ClientOrderHashMap;
}</span></pre>
<p><span class="koboSpan" id="kobo.655.1">We present the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">toString()</span></strong><span class="koboSpan" id="kobo.657.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">MEOrder</span></strong><span class="koboSpan" id="kobo.659.1"> structure, which is very simple and available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Chapter6/exchange/matcher/me_order.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
#include "me_order.h"
namespace Exchange {
Â Â auto MEOrder::toString() const -&gt; std::string {
Â Â Â Â std::stringstream ss;
Â Â Â Â ss &lt;&lt; "MEOrder" &lt;&lt; "["
Â Â Â Â Â Â Â &lt;&lt; "ticker:" &lt;&lt; tickerIdToString(ticker_id_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "cid:" &lt;&lt; clientIdToString(client_id_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "oid:" &lt;&lt; orderIdToString(client_order_id_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "moid:" &lt;&lt; orderIdToString(market_order_id_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "qty:" &lt;&lt; qtyToString(qty_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "prio:" &lt;&lt; priorityToString(priority_) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "prev:" &lt;&lt; orderIdToString(prev_order_ ?
</span><span class="koboSpan" id="kobo.662.2">Â Â Â Â Â Â Â Â Â prev_order_-&gt;market_order_id_ :
Â Â Â Â Â Â Â Â Â OrderId_INVALID) &lt;&lt; " "
Â Â Â Â Â Â Â &lt;&lt; "next:" &lt;&lt; orderIdToString(next_order_ ?
</span><span class="koboSpan" id="kobo.662.3">Â Â Â Â Â Â Â Â Â next_order_-&gt;market_order_id_ :
Â Â Â Â Â Â Â Â Â OrderId_INVALID) &lt;&lt; "]";
Â Â Â Â return ss.str();
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.663.1">Next, we </span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.664.1">will build </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.665.1">some additional structures </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.666.1">that contain </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.667.1">and manage </span><a id="_idIndexMarker961"/><span class="No-Break"><span class="koboSpan" id="kobo.668.1">order </span></span><span class="No-Break"><a id="_idIndexMarker962"/></span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.670.1">Defining the MEOrdersAtPrice and OrdersAtPriceHashMap types</span></h3>
<p><span class="koboSpan" id="kobo.671.1">As discussed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.672.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.673.1">.1</span></em><span class="koboSpan" id="kobo.674.1">, we define another structure that maintains a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">MEOrder</span></strong><span class="koboSpan" id="kobo.676.1"> objects, </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.677.1">and we call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.679.1">. </span><span class="koboSpan" id="kobo.679.2">This </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.680.1">structure, presented </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.681.1">in the following code </span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.682.1">block, will be used to hold all the orders entered at the same price, arranged in the FIFO priority order. </span><span class="koboSpan" id="kobo.682.2">This is achieved by creating a singly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">MEOrder</span></strong><span class="koboSpan" id="kobo.684.1"> objects, arranged in order of highest to lowest priority. </span><span class="koboSpan" id="kobo.684.2">For that, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">first_me_order_</span></strong><span class="koboSpan" id="kobo.686.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">MEOrder</span></strong><span class="koboSpan" id="kobo.688.1"> type pointer, which will represent the first order at this price level, and the other orders following it are chained together in the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">FIFO order.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.692.1"> structure also has two pointers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.694.1"> objects, one for the previous (</span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">prev_entry_</span></strong><span class="koboSpan" id="kobo.696.1">) and one for the next (</span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">next_entry_</span></strong><span class="koboSpan" id="kobo.698.1">). </span><span class="koboSpan" id="kobo.698.2">This is because the structure itself is a node in a doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.700.1"> objects. </span><span class="koboSpan" id="kobo.700.2">The doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.702.1"> is arranged from the most aggressive to the least aggressive prices on the buy and </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">sell sides.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">The two other variables this struct contains are a </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">side_</span></strong><span class="koboSpan" id="kobo.706.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Side</span></strong><span class="koboSpan" id="kobo.708.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">price_</span></strong><span class="koboSpan" id="kobo.710.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">Price</span></strong><span class="koboSpan" id="kobo.712.1">, respectively representing the side and price of this </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">price level:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.714.1">
namespace Exchange {
Â Â struct MEOrdersAtPrice {
Â Â Â Â Side side_ = Side::INVALID;
Â Â Â Â Price price_ = Price_INVALID;
Â Â Â Â MEOrder *first_me_order_ = nullptr;
Â Â Â Â MEOrdersAtPrice *prev_entry_ = nullptr;
Â Â Â Â MEOrdersAtPrice *next_entry_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.715.1">We add a default </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.716.1">constructor </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.717.1">and a trivial custom container to initialize objects of </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">this structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
Â Â Â Â MEOrdersAtPrice() = default;
Â Â Â Â MEOrdersAtPrice(Side side, Price price, MEOrder
Â Â Â Â Â Â *first_me_order, MEOrdersAtPrice *prev_entry,
Â Â Â Â Â Â MEOrdersAtPrice *next_entry)
Â Â Â Â Â Â Â Â : side_(side), price_(price),
Â Â Â Â Â Â Â Â first_me_order_(first_me_order),
Â Â Â Â Â Â Â Â prev_entry_(prev_entry), next_entry_(next_entry) {}</span></pre>
<p><span class="koboSpan" id="kobo.720.1">We also add </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.721.1">a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">toString()</span></strong><span class="koboSpan" id="kobo.723.1"> method for logging </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.724.1">purposes, as </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.726.1">
Â Â Â Â auto toString() const {
Â Â Â Â Â Â std::stringstream ss;
Â Â Â Â Â Â ss &lt;&lt; "MEOrdersAtPrice["
Â Â Â Â Â Â Â Â Â &lt;&lt; "side:" &lt;&lt; sideToString(side_) &lt;&lt; " "
Â Â Â Â Â Â Â Â Â &lt;&lt; "price:" &lt;&lt; priceToString(price_) &lt;&lt; " "
Â Â Â Â Â Â Â Â Â &lt;&lt; "first_me_order:" &lt;&lt; (first_me_order_ ?
</span><span class="koboSpan" id="kobo.726.2">Â Â Â Â Â Â Â Â Â Â Â first_me_order_-&gt;toString() : "null") &lt;&lt; " "
Â Â Â Â Â Â Â Â Â &lt;&lt; "prev:" &lt;&lt; priceToString(prev_entry_ ?
</span><span class="koboSpan" id="kobo.726.3">Â Â Â Â Â Â Â Â Â Â Â prev_entry_-&gt;price_ : Price_INVALID) &lt;&lt; " "
Â Â Â Â Â Â Â Â Â &lt;&lt; "next:" &lt;&lt; priceToString(next_entry_ ?
</span><span class="koboSpan" id="kobo.726.4">Â Â Â Â Â Â Â Â Â Â Â next_entry_-&gt;price_ : Price_INVALID) &lt;&lt; "]";
Â Â Â Â Â Â return ss.str();
Â Â Â Â }
Â Â };</span></pre>
<p><span class="koboSpan" id="kobo.727.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.729.1"> type represents a hash map, implemented through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">std::array</span></strong><span class="koboSpan" id="kobo.731.1"> to represent a mapping from Price </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">MEOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
Â Â typedef std::array&lt;MEOrdersAtPrice *,
Â Â Â Â ME_MAX_PRICE_LEVELS&gt; OrdersAtPriceHashMap;
}</span></pre>
<p><span class="koboSpan" id="kobo.736.1">This concludes </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.737.1">this section on setting up the initial types, </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.738.1">definitions, and basic structures for the </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.739.1">matching engine </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.740.1">and limit order book. </span><span class="koboSpan" id="kobo.740.2">Next, we can look at how the matching engine framework </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">is built.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.742.1">Building the matching engine and exchanging external data</span></h1>
<p><span class="koboSpan" id="kobo.743.1">In this section, we will build various parts of the matching engine class. </span><span class="koboSpan" id="kobo.743.2">A lot of the heavy lifting </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.744.1">of handling client requests, building and updating the limit </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.745.1">order book, and generating order responses and market updates will be offloaded to the order book class, which we will discuss in the next section. </span><span class="koboSpan" id="kobo.745.2">Please reread the </span><em class="italic"><span class="koboSpan" id="kobo.746.1">Designing the C++ matching engine in a trading exchange</span></em><span class="koboSpan" id="kobo.747.1"> section in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.748.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.749.1">, for a refresher on the components we will build in this section and the design principles behind them. </span><span class="koboSpan" id="kobo.749.2">We present the diagram from that chapter here for easy reference, showing the design of the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">matching engine.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.751.1"><img alt="Figure 6.2 â€“ The design of our matching engine component" src="image/Figure_6.2_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.752.1">Figure 6.2 â€“ The design of our matching engine component</span></p>
<p><span class="koboSpan" id="kobo.753.1">The matching </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.754.1">engine is an independent thread of execution that </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.755.1">consumes order requests from </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.757.1">, publishes order responses to </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.759.1">, and publishes market updates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.761.1">. </span><span class="koboSpan" id="kobo.761.2">Let us first declare and define some code for the construction, destruction, thread management, and boilerplate functionality for the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">matching engine.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.763.1">Building the matching engine</span></h2>
<p><span class="koboSpan" id="kobo.764.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.766.1"> class contains a couple of important data members â€“ first, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">OrderBookHashMap</span></strong><span class="koboSpan" id="kobo.768.1"> object </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.769.1">to track the limit order book for each of the trading instruments. </span><span class="koboSpan" id="kobo.769.2">The class also contains pointers to the following objects â€“ </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.771.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.773.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.775.1">, all of which will be passed to it in the constructor. </span><span class="koboSpan" id="kobo.775.2">Let us first declare and define some code for the construction, destruction, thread management, and boilerplate functionality for the matching engine. </span><span class="koboSpan" id="kobo.775.3">We will also have a Boolean, </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">run_</span></strong><span class="koboSpan" id="kobo.777.1">, to track the thread state, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">time_str_</span></strong><span class="koboSpan" id="kobo.779.1"> string, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">Logger</span></strong><span class="koboSpan" id="kobo.781.1"> object to output some logs. </span><span class="koboSpan" id="kobo.781.2">The code for the next sub-sections is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Chapter6/exchange/matcher/matching_engine.h</span></strong><span class="koboSpan" id="kobo.783.1"> source file in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">First, the header files we need to include to build our matching engine are </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.787.1">
#pragma once
#include "common/thread_utils.h"
#include "common/lf_queue.h"
#include "common/macros.h"
#include "order_server/client_request.h"
#include "order_server/client_response.h"
#include "market_data/market_update.h"
#include "me_order_book.h"</span></pre>
<p><span class="koboSpan" id="kobo.788.1">We declare the </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.789.1">constructor and destructor methods next, and we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">start()</span></strong><span class="koboSpan" id="kobo.791.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">stop()</span></strong><span class="koboSpan" id="kobo.793.1"> methods to respectively start and stop the execution of the main matching engine loop, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">build shortly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
namespace Exchange {
Â Â class MatchingEngine final {
Â Â public:
Â Â Â Â MatchingEngine(ClientRequestLFQueue *client_requests,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ClientResponseLFQueue *client_responses,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â MEMarketUpdateLFQueue *market_updates);
Â Â Â Â ~MatchingEngine();
Â Â Â Â auto start() -&gt; void;
Â Â Â Â auto stop() -&gt; void;</span></pre>
<p><span class="koboSpan" id="kobo.796.1">We add our </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.797.1">usual boilerplate code for the constructors and assignment operators to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">accidental copies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
Â Â Â Â // Deleted default, copy &amp; move constructors and
Â Â Â Â // assignment-operators.
</span><span class="koboSpan" id="kobo.799.2">Â Â Â Â MatchingEngine() = delete;
Â Â Â Â MatchingEngine(const MatchingEngine &amp;) = delete;
Â Â Â Â MatchingEngine(const MatchingEngine &amp;&amp;) = delete;
Â Â Â Â MatchingEngine &amp;operator=(const MatchingEngine &amp;) =
Â Â Â Â Â Â delete;
Â Â Â Â MatchingEngine &amp;operator=(const MatchingEngine &amp;&amp;) =
Â Â Â Â Â Â delete;</span></pre>
<p><span class="koboSpan" id="kobo.800.1">Finally, we add the data members for this </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.802.1"> class, as discussed before. </span><span class="koboSpan" id="kobo.802.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">ticker_order_book_</span></strong><span class="koboSpan" id="kobo.804.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">OrderBookHashMap</span></strong><span class="koboSpan" id="kobo.806.1"> is used to store </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.808.1"> for each instrument. </span><span class="koboSpan" id="kobo.808.2">We store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">incoming_requests_</span></strong><span class="koboSpan" id="kobo.810.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">outgoing_ogw_responses_</span></strong><span class="koboSpan" id="kobo.812.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">outgoing_md_updates_</span></strong><span class="koboSpan" id="kobo.814.1"> pointers of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.816.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.818.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.820.1"> types respectively to communicate with the other threads. </span><span class="koboSpan" id="kobo.820.2">Then, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">run_</span></strong><span class="koboSpan" id="kobo.822.1"> Boolean variable, which we mark </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">volatile</span></strong><span class="koboSpan" id="kobo.824.1">, since it will be accessed from </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">different threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.826.1">
Â Â private:
Â Â Â Â OrderBookHashMap ticker_order_book_;
Â Â Â Â ClientRequestLFQueue *incoming_requests_ = nullptr;
Â Â Â Â ClientResponseLFQueue *outgoing_ogw_responses_ =
Â Â Â Â Â Â nullptr;
Â Â Â Â MEMarketUpdateLFQueue *outgoing_md_updates_ = nullptr;
Â Â Â Â volatile bool run_ = false;
Â Â Â Â std::string time_str_;
Â Â Â Â Logger logger_;
Â Â };
}</span></pre>
<p><span class="koboSpan" id="kobo.827.1">Let us look at the </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.828.1">implementation of the constructor, the destructor, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">start()</span></strong><span class="koboSpan" id="kobo.830.1"> method that creates and launches a thread to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">run()</span></strong><span class="koboSpan" id="kobo.832.1"> method (which we will look at shortly). </span><span class="koboSpan" id="kobo.832.2">This code is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">Chapter6/exchange/matcher/matching_engine.cpp</span></strong><span class="koboSpan" id="kobo.834.1"> source file. </span><span class="koboSpan" id="kobo.834.2">The constructor itself is straightforward â€“ it initializes the internal data members and creates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.836.1"> instance for each one of the supported </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">trading instruments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
#include "matching_engine.h"
namespace Exchange {
Â Â MatchingEngine::MatchingEngine(ClientRequestLFQueue
Â Â Â Â *client_requests, ClientResponseLFQueue
Â Â Â Â *client_responses, MEMarketUpdateLFQueue
Â Â Â Â *market_updates)
Â Â Â Â Â Â : incoming_requests_(client_requests),
Â Â Â Â Â Â Â Â outgoing_ogw_responses_(client_responses),
Â Â Â Â Â Â Â Â outgoing_md_updates_(market_updates),
Â Â Â Â Â Â Â Â logger_("exchange_matching_engine.log") {
Â Â Â Â for(size_t i = 0; i &lt; ticker_order_book_.size(); ++i) {
Â Â Â Â Â Â ticker_order_book_[i] = new MEOrderBook(i, &amp;logger_,
Â Â Â Â Â Â Â Â this);
Â Â Â Â }
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.839.1">The destructor does </span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.840.1">the opposite of the constructor and resets the internal data member variables. </span><span class="koboSpan" id="kobo.840.2">It also deletes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.842.1"> objects it created in </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.844.1">
Â Â MatchingEngine::~MatchingEngine() {
Â Â Â Â run_ = false;
Â Â Â Â using namespace std::literals::chrono_literals;
Â Â Â Â std::this_thread::sleep_for(1s);
Â Â Â Â incoming_requests_ = nullptr;
Â Â Â Â outgoing_ogw_responses_ = nullptr;
Â Â Â Â outgoing_md_updates_ = nullptr;
Â Â Â Â for(auto&amp; order_book : ticker_order_book_) {
Â Â Â Â Â Â delete order_book;
Â Â Â Â Â Â order_book = nullptr;
Â Â Â Â }
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.845.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">start()</span></strong><span class="koboSpan" id="kobo.847.1"> method creates and launches a new thread, assigning it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">MatchingEngine::run()</span></strong><span class="koboSpan" id="kobo.849.1"> method. </span><span class="koboSpan" id="kobo.849.2">Before it does that, it enables </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">run_ flag</span></strong><span class="koboSpan" id="kobo.851.1">, since it controls the execution of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.853.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
Â Â auto MatchingEngine::start() -&gt; void {
Â Â Â Â run_ = true;
Â Â Â Â ASSERT(Common::createAndStartThread(-1,
Â Â Â Â Â Â "Exchange/MatchingEngine", [this]() { run(); }) !=
Â Â Â Â Â Â nullptr, "Failed to start MatchingEngine thread.");
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.855.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">stop()</span></strong><span class="koboSpan" id="kobo.857.1"> method </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.858.1">simply sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">run_</span></strong><span class="koboSpan" id="kobo.860.1"> flag to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">false</span></strong><span class="koboSpan" id="kobo.862.1">, and that in turn causes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">run()</span></strong><span class="koboSpan" id="kobo.864.1"> method to exit out of its main loop, but this will become </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">clear shortly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
Â Â auto MatchingEngine::stop() -&gt; void {
Â Â Â Â run_ = false;
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.867.1">Next, we will investigate the source code that handles how the matching engine consumes the order requests and publishes order responses and market updates. </span><span class="koboSpan" id="kobo.867.2">But first, let us present the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">run()</span></strong><span class="koboSpan" id="kobo.869.1"> loop that the matching engine thread executes. </span><span class="koboSpan" id="kobo.869.2">This code is very simple â€“ it simply consumes </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.871.1"> objects from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">incoming_requests_</span></strong><span class="koboSpan" id="kobo.873.1"> lock-free queue and forwards them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">processClientRequest()</span></strong><span class="koboSpan" id="kobo.875.1"> method. </span><span class="koboSpan" id="kobo.875.2">To achieve this, it simply checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">LFQueue::getNextToRead()</span></strong><span class="koboSpan" id="kobo.877.1"> method to see whether there is a valid entry to be read, and if so, forwards the object at that entry to be processed, and updates the read index in the lock-free queue using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">LFQueue::updateReadIndex()</span></strong><span class="koboSpan" id="kobo.879.1"> method. </span><span class="koboSpan" id="kobo.879.2">This code is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">Chapter6/exchange/matcher/matching_engine.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.881.1">source file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
auto run() noexcept {
Â Â logger_.log("%:% %() %\n", __FILE__, __LINE__,
Â Â Â Â __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_));
Â Â while (run_) {
Â Â Â Â const auto me_client_request =
Â Â Â Â Â Â incoming_requests_-&gt;getNextToRead();
Â Â Â Â if (LIKELY(me_client_request)) {
Â Â Â Â Â Â logger_.log("%:% %() % Processing %\n", __FILE__,
Â Â Â Â Â Â Â Â __LINE__, __FUNCTION__,
Â Â Â Â Â Â Â Â Common::getCurrentTimeStr(&amp;time_str_),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â me_client_request-&gt;toString());
Â Â Â Â Â Â processClientRequest(me_client_request);
Â Â Â Â Â Â incoming_requests_-&gt;updateReadIndex();
Â Â Â Â }
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.883.1">Now, let us look at </span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.884.1">the source code to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">client requests.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.886.1">Consuming from and publishing to the order gateway queue</span></h2>
<p><span class="koboSpan" id="kobo.887.1">First, we will start </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.888.1">with the implementation </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.889.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">processClientRequest()</span></strong><span class="koboSpan" id="kobo.891.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.893.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">matching_engine.h</span></strong><span class="koboSpan" id="kobo.895.1"> header file. </span><span class="koboSpan" id="kobo.895.2">This implementation simply checks for the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.897.1"> and forwards it to the limit order book for the corresponding instrument. </span><span class="koboSpan" id="kobo.897.2">It finds the correct order book instance that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.899.1"> is meant for by accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">ticker_order_book_</span></strong><span class="koboSpan" id="kobo.901.1"> container, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">ticker_id_</span></strong><span class="koboSpan" id="kobo.903.1"> field </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">MEClientRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.907.1">
auto processClientRequest(const MEClientRequest *client_request) noexcept {
Â Â auto order_book = ticker_order_book_[client_request
Â Â Â Â -&gt;ticker_id_];</span></pre>
<p><span class="koboSpan" id="kobo.908.1">For client requests that try to add a new order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.910.1">), we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.912.1"> method and let it service </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">that request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
Â Â switch (client_request-&gt;type_) {
Â Â Â Â case ClientRequestType::NEW: {
Â Â Â Â Â Â order_book-&gt;add(client_request-&gt;client_id_,
Â Â Â Â Â Â Â Â client_request-&gt;order_id_,
Â Â Â Â Â Â Â Â client_request-&gt;ticker_id_,
Â Â Â Â Â Â Â Â client_request-&gt;side_, client_request-&gt;price_,
Â Â Â Â Â Â Â Â client_request-&gt;qty_);
Â Â Â Â }
Â Â Â Â Â Â break;</span></pre>
<p><span class="koboSpan" id="kobo.915.1">Similarly, client </span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.916.1">requests that try to cancel an existing </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.917.1">order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">ClientRequestType::CANCEL</span></strong><span class="koboSpan" id="kobo.919.1">) are forwarded to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">MEOrderBook::cancel()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.921.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
Â Â Â Â case ClientRequestType::CANCEL: {
Â Â Â Â Â Â order_book-&gt;cancel(client_request-&gt;client_id_,
Â Â Â Â Â Â Â Â client_request-&gt;order_id_,
Â Â Â Â Â Â Â Â client_request-&gt;ticker_id_);
Â Â Â Â }
Â Â Â Â Â Â break;
Â Â Â Â default: {
Â Â Â Â Â Â FATAL("Received invalid client-request-type:" +
Â Â Â Â Â Â Â Â clientRequestTypeToString(client_request-&gt;type_));
Â Â Â Â }
Â Â Â Â Â Â break;
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.923.1">We will also define a method in the same class that the limit order book will use to publish order </span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.924.1">responses through </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.926.1"> messages. </span><span class="koboSpan" id="kobo.926.2">This simply writes the response to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">outgoing_ogw_responses_</span></strong><span class="koboSpan" id="kobo.928.1"> lock-free queue </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.929.1">and advances the writer index. </span><span class="koboSpan" id="kobo.929.2">It does that by finding the next valid index to write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.931.1"> message to by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">LFQueue::getNextToWriteTo()</span></strong><span class="koboSpan" id="kobo.933.1"> method, moving the data into that slot, and updating the next write index by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">LFQueue::updateWriteIndex()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
auto sendClientResponse(const MEClientResponse *client_response) noexcept {
Â Â logger_.log("%:% %() % Sending %\n", __FILE__, __LINE__,
Â Â Â Â __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
Â Â Â Â client_response-&gt;toString());
Â Â auto next_write = outgoing_ogw_responses_
Â Â Â Â -&gt;getNextToWriteTo();
Â Â *next_write = std::move(*client_response);
Â Â outgoing_ogw_responses_-&gt;updateWriteIndex();
}</span></pre>
<p><span class="koboSpan" id="kobo.937.1">Now, we will look </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.938.1">at some code that is similar to what </span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.939.1">we just saw, except it is used to publish market </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">data updates.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.941.1">Publishing to the market data publisher queue</span></h2>
<p><span class="koboSpan" id="kobo.942.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">sendMarketUpdate()</span></strong><span class="koboSpan" id="kobo.944.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">Chapter6/exchange/matcher/matching_engine.h</span></strong><span class="koboSpan" id="kobo.946.1"> is used by the limit order book to </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.947.1">publish market data updates through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.949.1"> structure. </span><span class="koboSpan" id="kobo.949.2">It simply writes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">outgoing_md_updates_</span></strong><span class="koboSpan" id="kobo.951.1"> lock-free queue and advances the writer. </span><span class="koboSpan" id="kobo.951.2">It does this exactly the same way we saw before â€“ by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">getNextToWriteTo()</span></strong><span class="koboSpan" id="kobo.953.1"> method, writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.955.1"> message to that slot, and updating the next write index </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">updateWriteIndex()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.959.1">
auto sendMarketUpdate(const MEMarketUpdate *market_update) noexcept {
Â Â logger_.log("%:% %() % Sending %\n", __FILE__, __LINE__,
Â Â Â Â __FUNCTION__, Common::getCurrentTimeStr(&amp;time_str_),
Â Â Â Â market_update-&gt;toString());
Â Â auto next_write = outgoing_md_updates_
Â Â Â Â -&gt;getNextToWriteTo();
Â Â *next_write = *market_update;
Â Â outgoing_md_updates_-&gt;updateWriteIndex();
}</span></pre>
<p><span class="koboSpan" id="kobo.960.1">That concludes this section, and we now have the finished implementation of the matching engine. </span><span class="koboSpan" id="kobo.960.2">In the next subsection, we will tie all these pieces together into the trading exchange binary, all except the limit order book implementation, which is the last section we will discuss in </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">this chapter.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.962.1">Building the exchange application binary</span></h2>
<p><span class="koboSpan" id="kobo.963.1">We can now build the trading exchange binary. </span><span class="koboSpan" id="kobo.963.2">We will instantiate the three lock-free queues for order </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.964.1">requests, order responses, and market updates that the matching engine object needs. </span><span class="koboSpan" id="kobo.964.2">We will also create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.966.1"> object and launch the thread, and then the binary simply sleeps forever. </span><span class="koboSpan" id="kobo.966.2">Since the application goes into an infinite loop, we will also install a signal handler for this application to trap external signals and exit gracefully. </span><span class="koboSpan" id="kobo.966.3">Note that this code will be extended in later chapters in this book as we build the order server and market data publisher components on the trading exchange side that need to be added here. </span><span class="koboSpan" id="kobo.966.4">The code for this application is in </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">Chapter6/exchange/exchange_main.cpp</span></strong><span class="koboSpan" id="kobo.968.1"> in the GitHub repository for this book. </span><span class="koboSpan" id="kobo.968.2">Let us break down the source file and understand each of the </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">code blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">First, we add some variables that will be pointers for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">Logger</span></strong><span class="koboSpan" id="kobo.972.1"> object and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.974.1"> object. </span><span class="koboSpan" id="kobo.974.2">We will also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">signal_handler()</span></strong><span class="koboSpan" id="kobo.976.1"> method to be invoked when killing the exchange application. </span><span class="koboSpan" id="kobo.976.2">The signal handler simply deletes these objects </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">and exits:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
#include &lt;csignal&gt;
#include "matcher/matching_engine.h"
Common::Logger* logger = nullptr;
Exchange::MatchingEngine* matching_engine = nullptr;
void signal_handler(int) {
Â Â using namespace std::literals::chrono_literals;
Â Â std::this_thread::sleep_for(10s);
Â Â delete logger; logger = nullptr;
Â Â delete matching_engine; matching_engine = nullptr;
Â Â std::this_thread::sleep_for(10s);
Â Â exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.979.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">main()</span></strong><span class="koboSpan" id="kobo.981.1"> method is pretty simple for now till we add other components in the next chapter. </span><span class="koboSpan" id="kobo.981.2">It installs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">signal_handler()</span></strong><span class="koboSpan" id="kobo.983.1"> method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">std::signal()</span></strong><span class="koboSpan" id="kobo.985.1"> routine to </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.986.1">trap external </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">SIGINT</span></strong><span class="koboSpan" id="kobo.988.1"> signals. </span><span class="koboSpan" id="kobo.988.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">SIGINT</span></strong><span class="koboSpan" id="kobo.990.1"> signal is the signal value 2, which is sent to a running process when either </span><em class="italic"><span class="koboSpan" id="kobo.991.1">Ctrl</span></em><span class="koboSpan" id="kobo.992.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.993.1">C</span></em><span class="koboSpan" id="kobo.994.1"> is pressed in Linux or </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">kill â€“2 PID</span></strong><span class="koboSpan" id="kobo.996.1"> is sent to that </span><strong class="bold"><span class="koboSpan" id="kobo.997.1">Process ID</span></strong><span class="koboSpan" id="kobo.998.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.999.1">PID</span></strong><span class="koboSpan" id="kobo.1000.1">). </span><span class="koboSpan" id="kobo.1000.2">This is the common way to terminate processes gracefully. </span><span class="koboSpan" id="kobo.1000.3">It then initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">ClientRequestLFQueue</span></strong><span class="koboSpan" id="kobo.1002.1"> variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">client_requests</span></strong><span class="koboSpan" id="kobo.1004.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">ClientResponseLFQueue</span></strong><span class="koboSpan" id="kobo.1006.1"> variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">client_responses</span></strong><span class="koboSpan" id="kobo.1008.1">, to be of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">ME_MAX_CLIENT_UPDATES</span></strong><span class="koboSpan" id="kobo.1010.1"> size. </span><span class="koboSpan" id="kobo.1010.2">We also initialize the lock-free queue variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">market_updates</span></strong><span class="koboSpan" id="kobo.1012.1">, of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">MEMarketUpdateLFQueue</span></strong><span class="koboSpan" id="kobo.1014.1"> to be of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">ME_MAX_MARKET_UPDATES</span></strong><span class="koboSpan" id="kobo.1016.1"> capacity. </span><span class="koboSpan" id="kobo.1016.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">main()</span></strong><span class="koboSpan" id="kobo.1018.1"> method also initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">logger</span></strong><span class="koboSpan" id="kobo.1020.1"> variable with an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">Logger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
int main(int, char **) {
Â Â logger = new Common::Logger("exchange_main.log");
Â Â std::signal(SIGINT, signal_handler);
Â Â const int sleep_time = 100 * 1000;
Â Â Exchange::ClientRequestLFQueue
Â Â Â Â client_requests(ME_MAX_CLIENT_UPDATES);
Â Â Exchange::ClientResponseLFQueue
Â Â Â Â client_responses(ME_MAX_CLIENT_UPDATES);
Â Â Exchange::MEMarketUpdateLFQueue
Â Â Â Â market_updates(ME_MAX_MARKET_UPDATES);</span></pre>
<p><span class="koboSpan" id="kobo.1024.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">main()</span></strong><span class="koboSpan" id="kobo.1026.1"> method initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">matching_engine</span></strong><span class="koboSpan" id="kobo.1028.1"> variable with an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1030.1"> class we created and passes it the three lock-free queues it needs from the preceding code block. </span><span class="koboSpan" id="kobo.1030.2">It then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">start()</span></strong><span class="koboSpan" id="kobo.1032.1"> method so that the main </span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.1033.1">matching engine thread can start executing. </span><span class="koboSpan" id="kobo.1033.2">At this point, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">main()</span></strong><span class="koboSpan" id="kobo.1035.1"> method is done, so it enters into an infinite loop, where it sleeps most of the time and waits for an external signal that will kill </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">this process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
Â Â std::string time_str;
Â Â logger-&gt;log("%:% %() % Starting Matching Engine...\n",
Â Â Â Â __FILE__, __LINE__, __FUNCTION__,
Â Â Â Â Common::getCurrentTimeStr(&amp;time_str));
Â Â matching_engine = new
Â Â Â Â Exchange::MatchingEngine(&amp;client_requests,
Â Â Â Â &amp;client_responses, &amp;market_updates);
Â Â matching_engine-&gt;start();
Â Â while (true) {
Â Â Â Â logger-&gt;log("%:% %() % Sleeping for a few
Â Â Â Â milliseconds..\n", __FILE__, __LINE__, __FUNCTION__,
Â Â Â Â Common::getCurrentTimeStr(&amp;time_str));
Â Â Â Â usleep(sleep_time * 1000);
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1038.1">To make it easy to build the main binary, we have provided a script, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">Chapter6/build.sh</span></strong><span class="koboSpan" id="kobo.1040.1">, which uses CMake and Ninja to build this binary. </span><span class="koboSpan" id="kobo.1040.2">You will have to update this script to </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.1041.1">point to the correct binaries on your system, or use a different build system if you prefer. </span><span class="koboSpan" id="kobo.1041.2">The next section will provide some information on how to run this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">exchange_main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1"> application.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.1044.1">Running the exchange application binary</span></h2>
<p><span class="koboSpan" id="kobo.1045.1">Running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1047.1"> application is achieved at this point simply by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">exchange_main</span></strong><span class="koboSpan" id="kobo.1049.1"> binary, as </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.1050.1">shown in the following code block. </span><span class="koboSpan" id="kobo.1050.2">We also show the output you should be able to see on </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter6$ ./cmake-build-release/exchange_main
Set core affinity for Common/Logger exchange_main.log 139685103920704 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 139684933506624 to -1
Set core affinity for Exchange/MatchingEngine 139684925113920 to -1</span></pre>
<p><span class="koboSpan" id="kobo.1053.1">This process can be stopped by sending it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">SIGINT</span></strong><span class="koboSpan" id="kobo.1055.1"> signal, as we mentioned before. </span><span class="koboSpan" id="kobo.1055.2">At this point, it will generate three log files, similar to the ones shown in the following snippet. </span><span class="koboSpan" id="kobo.1055.3">However, note at this point that there is nothing interesting in the log files, since we have only built the matching engine component out of all the components we need to build the full trading ecosystem. </span><span class="koboSpan" id="kobo.1055.4">At the end of the next chapter, </span><em class="italic"><span class="koboSpan" id="kobo.1056.1">Communicating with Market Participants</span></em><span class="koboSpan" id="kobo.1057.1">, we will run this application again with additional components and have slightly more </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">interesting output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
exchange_main.log exchange_matching_engine.log</span></pre>
<p><span class="koboSpan" id="kobo.1060.1">The next section will look at the internal workings of the order book and how it handles client order requests and generates order responses and </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">market updates.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.1062.1">Building the order book and matching orders</span></h1>
<p><span class="koboSpan" id="kobo.1063.1">This final section implements the order book functionality. </span><span class="koboSpan" id="kobo.1063.2">Remember that the order book handles client </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.1064.1">order requests forwarded from the matching engine. </span><span class="koboSpan" id="kobo.1064.2">It </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.1065.1">checks the order request type, updates the order book, generates order responses for the client, and generates market data updates for the public market data feed. </span><span class="koboSpan" id="kobo.1065.2">All the code for the limit order book in the matching engine is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">me_order_book.h</span></strong><span class="koboSpan" id="kobo.1067.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">me_order_book.cpp</span></strong><span class="koboSpan" id="kobo.1069.1"> source files, saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">Chapter6/exchange/matcher/</span></strong><span class="koboSpan" id="kobo.1071.1"> directory in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">this book.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.1073.1">Building the internal data structures</span></h2>
<p><span class="koboSpan" id="kobo.1074.1">First, we will declare </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.1075.1">the data members for the limit order book. </span><span class="koboSpan" id="kobo.1075.2">We presented a diagram depicting the data structures that make up the limit order book previously, in </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">Figure 6</span></span><span class="koboSpan" id="kobo.1077.1">.1. </span><span class="koboSpan" id="kobo.1077.2">The limit order book contains the following important </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">data members:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1079.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">matching_engine_</span></strong><span class="koboSpan" id="kobo.1081.1"> pointer variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1083.1"> parent for the order </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.1084.1">book to publish order responses and market data </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">updates to.</span></span></li>
<li><span class="koboSpan" id="kobo.1086.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">ClientOrderHashMap</span></strong><span class="koboSpan" id="kobo.1088.1"> variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.1090.1">, to track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.1092.1"> objects by their </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">ClientId</span></strong><span class="koboSpan" id="kobo.1094.1"> key. </span><span class="koboSpan" id="kobo.1094.2">As a reminder, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.1096.1"> tracks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1098.1"> objects by their </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">OrderId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1"> keys.</span></span></li>
<li><span class="koboSpan" id="kobo.1101.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.1103.1"> memory pool variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1105.1"> objects to create new objects from and return dead objects </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">back to.</span></span></li>
<li><span class="koboSpan" id="kobo.1107.1">The head of the doubly linked list of bids (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1109.1">) and asks (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1111.1">), since we track orders at the price level as a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">MEOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1"> objects.</span></span></li>
<li><span class="koboSpan" id="kobo.1114.1">A hash map, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.1116.1">, to track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1118.1"> objects for the price levels, using the price of the level as a key into </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">the map.</span></span></li>
<li><span class="koboSpan" id="kobo.1120.1">A memory pool of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1122.1"> objects, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">order_pool_</span></strong><span class="koboSpan" id="kobo.1124.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1126.1"> objects are created from and returned to without incurring dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">memory allocations.</span></span></li>
<li><span class="koboSpan" id="kobo.1128.1">Some minor members, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">TickerId</span></strong><span class="koboSpan" id="kobo.1130.1"> for the instrument for this order book, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">OrderId</span></strong><span class="koboSpan" id="kobo.1132.1"> to track </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.1133.1">the next market data order ID, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1135.1"> variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">client_response_</span></strong><span class="koboSpan" id="kobo.1137.1">), an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1139.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">market_update_</span></strong><span class="koboSpan" id="kobo.1141.1">), a string to log time, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Logger</span></strong><span class="koboSpan" id="kobo.1143.1"> object for </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">logging purposes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1145.1">First, we include some </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.1146.1">dependent header files and also forward-declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.1148.1"> class because we will reference that type without fully defining </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">it yet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1150.1">
#pragma once
#include "common/types.h"
#include "common/mem_pool.h"
#include "common/logging.h"
#include "order_server/client_response.h"
#include "market_data/market_update.h"
#include "me_order.h"
using namespace Common;
namespace Exchange {
Â Â class MatchingEngine;
Â Â class MEOrderBook final {</span></pre>
<p><span class="koboSpan" id="kobo.1151.1">Now, we will </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.1152.1">define the data member variables, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">discussed previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
private:
Â Â TickerId ticker_id_ = TickerId_INVALID;
Â Â MatchingEngine *matching_engine_ = nullptr;
Â Â ClientOrderHashMap cid_oid_to_order_;
Â Â MemPool&lt;MEOrdersAtPrice&gt; orders_at_price_pool_;
Â Â MEOrdersAtPrice *bids_by_price_ = nullptr;
Â Â MEOrdersAtPrice *asks_by_price_ = nullptr;
Â Â OrdersAtPriceHashMap price_orders_at_price_;
Â Â MemPool&lt;MEOrder&gt; order_pool_;
Â Â MEClientResponse client_response_;
Â Â MEMarketUpdate market_update_;
Â Â OrderId next_market_order_id_ = 1;
Â Â std::string time_str_;
Â Â Logger *logger_ = nullptr;</span></pre>
<p><span class="koboSpan" id="kobo.1155.1">At this point, we will also define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">OrderBookHashMap</span></strong><span class="koboSpan" id="kobo.1157.1"> type, which we referenced before and is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">std::array</span></strong><span class="koboSpan" id="kobo.1159.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.1161.1"> objects indexed </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">TickerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1165.1">
 typedef std::array&lt;MEOrderBook *, ME_MAX_TICKERS&gt; OrderBookHashMap;
Â Â };
}</span></pre>
<p><span class="koboSpan" id="kobo.1166.1">Next, let us </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.1167.1">present the straightforward implementation of the constructor and the destructor, as well as the boilerplate code for the default constructor and </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">assignment operators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
#include "me_order_book.h"
#include "matcher/matching_engine.h"
MEOrderBook::MEOrderBook(TickerId ticker_id, Logger *logger, MatchingEngine *matching_engine)
Â Â Â Â : ticker_id_(ticker_id),
Â Â Â Â Â Â matching_engine_(matching_engine),
Â Â Â Â Â Â orders_at_price_pool_(ME_MAX_PRICE_LEVELS),
Â Â Â Â Â Â order_pool_(ME_MAX_ORDER_IDS), logger_(logger) {
}
MEOrderBook::~MEOrderBook() {
Â Â logger_-&gt;log("%:% %() % OrderBook\n%\n", __FILE__,
Â Â Â Â __LINE__, __FUNCTION__,
Â Â Â Â Common::getCurrentTimeStr(&amp;time_str_),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â toString(false, true));
Â Â matching_engine_ = nullptr;
Â Â bids_by_price_ = asks_by_price_ = nullptr;
Â Â for (auto &amp;itr: cid_oid_to_order_) {
Â Â Â Â itr.fill(nullptr);
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1170.1">Then, we add the boilerplate code to most of our classes to prevent accidental copies and assignments </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.1171.1">of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">MEOrderBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1174.1">
// Deleted default, copy &amp; move constructors and
// assignment-operators.
</span><span class="koboSpan" id="kobo.1174.2">MEOrderBook() = delete;
MEOrderBook(const MEOrderBook &amp;) = delete;
MEOrderBook(const MEOrderBook &amp;&amp;) = delete;
MEOrderBook &amp;operator=(const MEOrderBook &amp;) = delete;
MEOrderBook &amp;operator=(const MEOrderBook &amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.1175.1">Before we move on to the implementation of the different operations that will be performed on the order book, let us present a few simple methods to generate new market order IDs, convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">Price</span></strong><span class="koboSpan" id="kobo.1177.1"> to an index in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.1179.1">, and access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">OrdersAtPriceHashMap price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1181.1"> map when </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">given </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">Price</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1185.1">
namespace Exchange {
Â Â class MatchingEngine;
Â Â class MEOrderBook final {
private:</span></pre>
<p><span class="koboSpan" id="kobo.1186.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">generateNewMarketOrderId()</span></strong><span class="koboSpan" id="kobo.1188.1"> method is basic; it returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">next_market_order_id_</span></strong><span class="koboSpan" id="kobo.1190.1"> value and increments it the next time this method </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">is called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1192.1">
Â Â auto generateNewMarketOrderId() noexcept -&gt; OrderId {
Â Â Â Â return next_market_order_id_++;
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1193.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">priceToIndex()</span></strong><span class="koboSpan" id="kobo.1195.1"> method converts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">Price</span></strong><span class="koboSpan" id="kobo.1197.1"> argument into an index that ranges between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">0</span></strong><span class="koboSpan" id="kobo.1199.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">ME_MAX_PRICE_LEVELS-1</span></strong><span class="koboSpan" id="kobo.1201.1">, which is then used to index the price </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">levels </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">std::array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1205.1">
Â Â auto priceToIndex(Price price) const noexcept {
Â Â Â Â return (price % ME_MAX_PRICE_LEVELS);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1206.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">getOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1208.1"> utility method indexes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">std::array</span></strong><span class="koboSpan" id="kobo.1210.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1212.1"> by </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.1213.1">converting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">Price</span></strong><span class="koboSpan" id="kobo.1215.1"> it is provided into an index, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">priceToIndex()</span></strong><span class="koboSpan" id="kobo.1217.1"> method, which returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">MEOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
Â Â auto getOrdersAtPrice(Price price) const noexcept -&gt;
Â Â Â Â MEOrdersAtPrice * {
Â Â Â Â return price_orders_at_price_.at(priceToIndex(price));
Â Â }
Â Â };
}</span></pre>
<p><span class="koboSpan" id="kobo.1221.1">The next few subsections will detail the important operations of handling new order requests and cancellation requests for existing orders, and matching aggressive orders that cross existing passive orders on the other side of the order book. </span><span class="koboSpan" id="kobo.1221.2">We will also generate and publish order responses and market data updates back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">matching engine.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.1223.1">Handling new passive orders</span></h2>
<p><span class="koboSpan" id="kobo.1224.1">The first important task </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.1225.1">we need to perform in the order book is handling client order requests that want to enter new orders in the market. </span><span class="koboSpan" id="kobo.1225.2">We will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.1227.1"> method, which the matching engine calls first. </span><span class="koboSpan" id="kobo.1227.2">It generates and sends </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1229.1">, accepting the new order, and sends it to the matching engine (to be sent to the client who sent the new order). </span><span class="koboSpan" id="kobo.1229.2">It then also checks to see whether this new order crosses an existing passive order on the other side and whether it matches either fully or partially, by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">checkForMatch()</span></strong><span class="koboSpan" id="kobo.1231.1"> method. </span><span class="koboSpan" id="kobo.1231.2">If the new order either does not match at all or is partially filled and leaves some quantity in the book, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1233.1"> is added to the order book. </span><span class="koboSpan" id="kobo.1233.2">In this case, it also generates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1235.1"> for the public market data feed and sends it back to the matching engine (to be published by the market data publisher component). </span><span class="koboSpan" id="kobo.1235.2">We will discuss the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">getNextPriority()</span></strong><span class="koboSpan" id="kobo.1237.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">checkForMatch()</span></strong><span class="koboSpan" id="kobo.1239.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1241.1"> methods shortly in this section, but let us first explore the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">MEOrderBook::add()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1244.1">
auto MEOrderBook::add(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty) noexcept -&gt; void {</span></pre>
<p><span class="koboSpan" id="kobo.1245.1">The first thing it does is generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">new_market_order_id_</span></strong><span class="koboSpan" id="kobo.1247.1"> to be used for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.1251.1">. </span><span class="koboSpan" id="kobo.1251.2">It updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">client_response_</span></strong><span class="koboSpan" id="kobo.1253.1"> data member with the attributes from this request and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">MatchingEngine::sendClientResponse()</span></strong><span class="koboSpan" id="kobo.1255.1"> method to publish that response back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">matching engine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1257.1">
Â Â const auto new_market_order_id =
Â Â Â Â generateNewMarketOrderId();
Â Â client_response_ = {ClientResponseType::ACCEPTED,
Â Â Â Â client_id, ticker_id, client_order_id,
Â Â Â Â new_market_order_id, side, price, 0, qty};
Â Â matching_engine_-&gt;sendClientResponse(&amp;client_response_);</span></pre>
<p><span class="koboSpan" id="kobo.1258.1">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.1260.1"> method calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">MEOrderBook::checkForMatch()</span></strong><span class="koboSpan" id="kobo.1262.1"> method, which checks the current state of the order book against the new client request that just came in. </span><span class="koboSpan" id="kobo.1262.2">It checks whether a partial or complete match can be made. </span><span class="koboSpan" id="kobo.1262.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">checkForMatch()</span></strong><span class="koboSpan" id="kobo.1264.1"> method (which we will build shortly) returns the quantity of the order left over (if any) after the matching event. </span><span class="koboSpan" id="kobo.1264.2">For orders that do not execute at all, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">leaves_qty</span></strong><span class="koboSpan" id="kobo.1266.1"> returned is the same as the original quantity </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.1267.1">on the order. </span><span class="koboSpan" id="kobo.1267.2">For orders that partially execute, it is whatever is left after matching. </span><span class="koboSpan" id="kobo.1267.3">For orders that fully execute, this method will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">0</span></strong><span class="koboSpan" id="kobo.1269.1"> value and that will be assigned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">leaves_qty</span></strong><span class="koboSpan" id="kobo.1271.1">. </span><span class="koboSpan" id="kobo.1271.2">We will see the complete implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">checkForMatch()</span></strong><span class="koboSpan" id="kobo.1273.1"> shortly, but for now, let us </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">use it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1275.1">
Â Â const auto leaves_qty = checkForMatch(client_id,
Â Â Â Â client_order_id, ticker_id, side, price, qty,
Â Â Â Â new_market_order_id);</span></pre>
<p><span class="koboSpan" id="kobo.1276.1">In the event that there is a quantity left over after the matching event, we need to generate a market data update corresponding to this new order that will join the book. </span><span class="koboSpan" id="kobo.1276.2">To do that, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.1278.1"> method finds out the correct priority value for this order by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">MEOrderBook::getNextPriority()</span></strong><span class="koboSpan" id="kobo.1280.1"> method. </span><span class="koboSpan" id="kobo.1280.2">It allocates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1282.1"> object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">order_pool_</span></strong><span class="koboSpan" id="kobo.1284.1"> memory pool and assigns it the attributes for this order. </span><span class="koboSpan" id="kobo.1284.2">It then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">MEOrderBook::addOrder()</span></strong><span class="koboSpan" id="kobo.1286.1"> method to actually add it at the correct price level and priority in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1288.1"> data structures. </span><span class="koboSpan" id="kobo.1288.2">Finally, it fills in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">market_update_</span></strong><span class="koboSpan" id="kobo.1290.1"> object with the values for the market update and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">MatchingEngine::sendMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1292.1"> method to publish it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">matching engine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1294.1">
Â Â if (LIKELY(leaves_qty)) {
Â Â Â Â const auto priority = getNextPriority(ticker_id,
Â Â Â Â price);
Â Â Â Â auto order = order_pool_.allocate(ticker_id, client_id,
Â Â Â Â Â Â client_order_id, new_market_order_id, side, price,
Â Â Â Â Â Â leaves_qty, priority, nullptr, nullptr);
Â Â Â Â addOrder(order);
Â Â Â Â market_update_ = {MarketUpdateType::ADD,
Â Â Â Â Â Â new_market_order_id, ticker_id, side, price,
Â Â Â Â Â Â leaves_qty, priority};
Â Â Â Â matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1295.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">getNextPriority()</span></strong><span class="koboSpan" id="kobo.1297.1"> method is quite straightforward. </span><span class="koboSpan" id="kobo.1297.2">If a price level already exists at a </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.1298.1">certain price, then it just returns a priority value one higher than the last order at that price. </span><span class="koboSpan" id="kobo.1298.2">If a price level does not already exist, then it returns 1 for the first order at that </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">price level:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1300.1">
auto getNextPriority(Price price) noexcept {
Â Â const auto orders_at_price = getOrdersAtPrice(price);
Â Â if (!orders_at_price)
Â Â Â Â return 1lu;
Â Â return orders_at_price-&gt;first_me_order_-&gt;prev_order_
Â Â Â Â -&gt;priority_ + 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.1301.1">Next, we will lay out the details of adding a new order to the limit order book. </span><span class="koboSpan" id="kobo.1301.2">The method appends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1303.1"> object passed to it at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1305.1"> entry at the price for this order. </span><span class="koboSpan" id="kobo.1305.2">If an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1307.1"> entry does not already exist (new price level), it first allocates a new entry, adds the new level into the book using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">addOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1309.1"> method, and then appends the order. </span><span class="koboSpan" id="kobo.1309.2">Additionally, it tracks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1311.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">ClientOrderHashMap id_oid_to_order_</span></strong><span class="koboSpan" id="kobo.1313.1"> map, mapping from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">ClientId</span></strong><span class="koboSpan" id="kobo.1315.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">OrderId</span></strong><span class="koboSpan" id="kobo.1317.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">MEOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1320.1">
auto addOrder(MEOrder *order) noexcept {</span></pre>
<p><span class="koboSpan" id="kobo.1321.1">First, we try to check and fetch </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1323.1"> if one exists by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">getOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1325.1"> method and saving it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">orders_at_price</span></strong><span class="koboSpan" id="kobo.1327.1"> variable. </span><span class="koboSpan" id="kobo.1327.2">Then, we check whether a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1329.1"> exists, meaning a price level with the price and side of this order already exists. </span><span class="koboSpan" id="kobo.1329.2">If such a price level does not exist and this is the first order that forms that level, we create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1331.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">orders_at_price_pool_</span></strong><span class="koboSpan" id="kobo.1333.1">, initialize it, and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">addOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1335.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1337.1">
Â Â const auto orders_at_price = getOrdersAtPrice(order
Â Â Â Â -&gt;price_);
Â Â if (!orders_at_price) {
Â Â Â Â order-&gt;next_order_ = order-&gt;prev_order_ = order;
Â Â Â Â auto new_orders_at_price =
Â Â Â Â Â Â orders_at_price_pool_.allocate(order-&gt;side_,
Â Â Â Â Â Â order-&gt;price_, order, nullptr, nullptr);
Â Â Â Â addOrdersAtPrice(new_orders_at_price);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1338.1">If a valid price level </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.1339.1">exists, we append the new order at the very end of the doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1341.1"> objects, reachable from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">first_me_order_</span></strong><span class="koboSpan" id="kobo.1343.1"> member of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1345.1">. </span><span class="koboSpan" id="kobo.1345.2">We then update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">prev_order_</span></strong><span class="koboSpan" id="kobo.1347.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">next_order_</span></strong><span class="koboSpan" id="kobo.1349.1"> pointers on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1351.1"> being added as well as the last element on the list, after which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1353.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">is appended:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1355.1">
Â Â else {
Â Â Â Â auto first_order = (orders_at_price ?
</span><span class="koboSpan" id="kobo.1355.2">Â Â Â Â Â Â orders_at_price-&gt;first_me_order_ : nullptr);
Â Â Â Â first_order-&gt;prev_order_-&gt;next_order_ = order;
Â Â Â Â order-&gt;prev_order_ = first_order-&gt;prev_order_;
Â Â Â Â order-&gt;next_order_ = first_order;
Â Â Â Â first_order-&gt;prev_order_ = order;
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1356.1">Finally, we add this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1358.1"> pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.1360.1"> container, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">std::array</span></strong><span class="koboSpan" id="kobo.1362.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">std::array</span></strong><span class="koboSpan" id="kobo.1364.1"> instances, indexed first by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">client_id_</span></strong><span class="koboSpan" id="kobo.1366.1"> of the order and then by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">client_order_id_</span></strong><span class="koboSpan" id="kobo.1368.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">the order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1370.1">
Â Â cid_oid_to_order_.at(order-&gt;client_id_)
Â Â Â Â .at(order-&gt;client_order_id_) = order;
}</span></pre>
<p><span class="koboSpan" id="kobo.1371.1">Finally, to finish the discussion of adding new orders to the book, we need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">addOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1373.1"> method to add new price levels to the book. </span><span class="koboSpan" id="kobo.1373.2">This method first adds the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1375.1"> entry into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">OrdersAtPriceHashMap price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1377.1">. </span><span class="koboSpan" id="kobo.1377.2">Then, it walks through the bid or ask price levels, from the most aggressive to the least aggressive price, to find the correct spot for the new price level. </span><span class="koboSpan" id="kobo.1377.3">Note that this </span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.1378.1">implementation iterates through the doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1380.1"> objects on the side. </span><span class="koboSpan" id="kobo.1380.2">It is possible to have an alternative implementation that walks through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1381.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1382.1"> hash map to find the right spot. </span><span class="koboSpan" id="kobo.1382.2">Both implementations are viable and perform differently, depending on the number of price levels and the distance between consecutive prices. </span><span class="koboSpan" id="kobo.1382.3">We will revisit this topic at the end of the book, in the </span><em class="italic"><span class="koboSpan" id="kobo.1383.1">Optimizing the Performance of Our C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1384.1">System </span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">chapter</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1386.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1387.1">The first task for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">addOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1389.1"> method is to insert the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1391.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1393.1"> hash map, mapping from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">Price</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1395.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">MEOrdersAtPrice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1398.1">
auto addOrdersAtPrice(MEOrdersAtPrice *new_orders_at_price) noexcept {
Â Â price_orders_at_price_.at(priceToIndex(
Â Â Â Â new_orders_at_price-&gt;price_)) = new_orders_at_price;</span></pre>
<p><span class="koboSpan" id="kobo.1399.1">Then, we need to insert it in its correct location for the bids/asks arranged by price. </span><span class="koboSpan" id="kobo.1399.2">We do this by first assigning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">best_orders_by_price</span></strong><span class="koboSpan" id="kobo.1401.1"> variable to the beginning of the bids or asks, sorted </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">by price:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1403.1">
Â Â const auto best_orders_by_price = (new_orders_at_price-&gt;
Â Â Â Â side_ == Side::BUY ? </span><span class="koboSpan" id="kobo.1403.2">bids_by_price_ : asks_by_price_);</span></pre>
<p><span class="koboSpan" id="kobo.1404.1">We need to handle an edge case where there are no bids or no asks â€“ that is, a side of the order book is empty. </span><span class="koboSpan" id="kobo.1404.2">In such a case, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1406.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1408.1"> members, which point to the head of the sorted list for </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">that side:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1410.1">
Â Â if (UNLIKELY(!best_orders_by_price)) {
Â Â Â Â (new_orders_at_price-&gt;side_ == Side::BUY ?
</span><span class="koboSpan" id="kobo.1410.2">Â Â Â Â Â Â bids_by_price_ : asks_by_price_) =
Â Â Â Â Â Â new_orders_at_price;
Â Â Â Â new_orders_at_price-&gt;prev_entry_ =
Â Â Â Â Â Â new_orders_at_price-&gt;next_entry_ =
Â Â Â Â Â Â new_orders_at_price;
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1411.1">Otherwise, we need to find the correct entry in the doubly linked list of price levels. </span><span class="koboSpan" id="kobo.1411.2">We do this by walking </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.1412.1">through the bids or the asks till we find the correct price level, before or after which we insert the new price level. </span><span class="koboSpan" id="kobo.1412.2">We track the price level before or after the new one in the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">target</span></strong><span class="koboSpan" id="kobo.1414.1"> variable, and we track whether we need to insert after or before the target variable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">add_after</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1416.1">Boolean flag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1417.1">
Â Â else {
Â Â Â Â auto target = best_orders_by_price;
Â Â Â Â bool add_after = ((new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
Â Â Â Â Â Â target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
Â Â Â Â Â Â target-&gt;price_));
Â Â Â Â if (add_after) {
Â Â Â Â Â Â target = target-&gt;next_entry_;
Â Â Â Â Â Â add_after = ((new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Â Â Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
Â Â Â Â Â Â Â Â target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Â Â Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
Â Â Â Â Â Â Â Â target-&gt;price_));
Â Â Â Â }
Â Â Â Â while (add_after &amp;&amp; target != best_orders_by_price) {
Â Â Â Â Â Â add_after = ((new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &gt;
Â Â Â Â Â Â target-&gt;price_) || (new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Side::BUY &amp;&amp; new_orders_at_price-&gt;price_ &lt;
Â Â Â Â Â Â target-&gt;price_));
Â Â Â Â Â Â if (add_after)
Â Â Â Â Â Â Â Â target = target-&gt;next_entry_;
Â Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1418.1">Once we find the correct location for the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1420.1"> entry, we append the new price level </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.1421.1">by updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">prev_entry_</span></strong><span class="koboSpan" id="kobo.1423.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">next_entry_</span></strong><span class="koboSpan" id="kobo.1425.1"> variables in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">target</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1428.1"> structure, as well as the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1430.1"> being appended, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1432.1">
Â Â Â Â if (add_after) { // add new_orders_at_price after
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // target.
</span><span class="koboSpan" id="kobo.1432.2">Â Â Â Â Â Â if (target == best_orders_by_price) {
Â Â Â Â Â Â Â Â target = best_orders_by_price-&gt;prev_entry_;
Â Â Â Â Â Â }
Â Â Â Â Â Â new_orders_at_price-&gt;prev_entry_ = target;
Â Â Â Â Â Â target-&gt;next_entry_-&gt;prev_entry_ =
Â Â Â Â Â Â Â Â new_orders_at_price;
Â Â Â Â Â Â new_orders_at_price-&gt;next_entry_ =
Â Â Â Â Â Â Â Â target-&gt;next_entry_;
Â Â Â Â Â Â target-&gt;next_entry_ = new_orders_at_price;
Â Â Â Â } else { // add new_orders_at_price before target.
</span><span class="koboSpan" id="kobo.1432.3">Â Â Â Â Â Â new_orders_at_price-&gt;prev_entry_ =
Â Â Â Â Â Â Â Â target-&gt;prev_entry_;
Â Â Â Â Â Â new_orders_at_price-&gt;next_entry_ = target;
Â Â Â Â Â Â target-&gt;prev_entry_-&gt;next_entry_ =
Â Â Â Â Â Â Â Â new_orders_at_price;
Â Â Â Â Â Â target-&gt;prev_entry_ = new_orders_at_price;</span></pre>
<p><span class="koboSpan" id="kobo.1433.1">Finally, if we add the new price level before an existing price level, we need to check whether prepending this price </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.1434.1">level changes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1436.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1438.1"> variable. </span><span class="koboSpan" id="kobo.1438.2">Remember that these variables track the start of the bids or asks, respectively â€“ that is, the highest bid price and the lowest ask price. </span><span class="koboSpan" id="kobo.1438.3">If we have a new best bid/ask price level, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1440.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">asks_by_price_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1442.1">variable, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1443.1">
Â Â Â Â Â Â if ((new_orders_at_price-&gt;side_ == Side::BUY &amp;&amp;
Â Â Â Â Â Â Â Â new_orders_at_price-&gt;price_ &gt; best_orders_by_price
Â Â Â Â Â Â Â Â -&gt;price_) || new_orders_at_price-&gt;side_ ==
Â Â Â Â Â Â Â Â Side::SELL &amp;&amp; new_orders_at_price-&gt;price_ &lt;
Â Â Â Â Â Â Â Â best_orders_by_price-&gt;price_)) {
Â Â Â Â Â Â Â Â target-&gt;next_entry_ = (target-&gt;next_entry_ ==
Â Â Â Â Â Â Â Â best_orders_by_price ? </span><span class="koboSpan" id="kobo.1443.2">new_orders_at_price :
Â Â Â Â Â Â Â Â target-&gt;next_entry_);
Â Â Â Â Â Â Â Â (new_orders_at_price-&gt;side_ == Side::BUY ?
</span><span class="koboSpan" id="kobo.1443.3">Â Â Â Â Â Â Â Â Â Â bids_by_price_ : asks_by_price_) =
Â Â Â Â Â Â Â Â Â Â new_orders_at_price;
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1444.1">Next, we will </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.1445.1">discuss the source code that handles order </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">cancellation requests.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.1447.1">Handling order cancellation requests</span></h2>
<p><span class="koboSpan" id="kobo.1448.1">The code to handle order cancellation requests is forwarded from the matching engine. </span><span class="koboSpan" id="kobo.1448.2">First, it checks to see </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.1449.1">whether the cancel request is valid, meaning that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">ClientId</span></strong><span class="koboSpan" id="kobo.1451.1"> is valid and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">OrderId</span></strong><span class="koboSpan" id="kobo.1453.1"> on the cancellation request corresponds to an active order in the order book. </span><span class="koboSpan" id="kobo.1453.2">If the order is not cancellable, it generates and publishes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1455.1"> message to signify a rejected cancel request back to the matching engine. </span><span class="koboSpan" id="kobo.1455.2">If the order can be canceled, it generates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1457.1"> to signify the successful cancel attempt and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1458.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1459.1"> method to remove the order from the limit order book. </span><span class="koboSpan" id="kobo.1459.2">We will discuss the details of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1461.1"> right after this </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">next method.</span></span></p>
<p><span class="koboSpan" id="kobo.1463.1">We will track an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">is_cancelable</span></strong><span class="koboSpan" id="kobo.1465.1"> Boolean variable that determines whether we were able to successfully find and cancel the clientâ€™s order or not. </span><span class="koboSpan" id="kobo.1465.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">client_id</span></strong><span class="koboSpan" id="kobo.1467.1"> is larger than the maximum possible client ID value, then we cannot cancel the order. </span><span class="koboSpan" id="kobo.1467.2">If the client ID is valid, then we check the container from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.1469.1"> for the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">client_id</span></strong><span class="koboSpan" id="kobo.1471.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">order_id</span></strong><span class="koboSpan" id="kobo.1473.1"> value. </span><span class="koboSpan" id="kobo.1473.2">If a valid order does not exist, then we confirm that the order is </span><span class="No-Break"><span class="koboSpan" id="kobo.1474.1">not cancelable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1475.1">
auto MEOrderBook::cancel(ClientId client_id, OrderId order_id, TickerId ticker_id) noexcept -&gt; void {
Â Â auto is_cancelable = (client_id &lt;
Â Â Â Â cid_oid_to_order_.size());
Â Â MEOrder *exchange_order = nullptr;
Â Â if (LIKELY(is_cancelable)) {
Â Â Â Â auto &amp;co_itr = cid_oid_to_order_.at(client_id);
Â Â Â Â exchange_order = co_itr.at(order_id);
Â Â Â Â is_cancelable = (exchange_order != nullptr);
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1476.1">If we determine that the order cannot be cancelled, we generate an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">MEClientResponse</span></strong><span class="koboSpan" id="kobo.1478.1"> message of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">ClientResponseType::CANCEL_REJECTED</span></strong><span class="koboSpan" id="kobo.1480.1"> to notify the </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">matching engine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1482.1">
Â Â if (UNLIKELY(!is_cancelable)) {
Â Â Â Â client_response_ =
Â Â Â Â Â Â {ClientResponseType::CANCEL_REJECTED, client_id,
Â Â Â Â Â Â ticker_id, order_id, OrderId_INVALID,
Â Â Â Â Â Â Side::INVALID, Price_INVALID, Qty_INVALID,
Â Â Â Â Â Â Qty_INVALID};
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1483.1">If we can </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.1484.1">successfully cancel the order, we update the attributes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">client_response_</span></strong><span class="koboSpan" id="kobo.1486.1"> member variable and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">market_update_</span></strong><span class="koboSpan" id="kobo.1488.1"> member variable. </span><span class="koboSpan" id="kobo.1488.2">Then, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1490.1"> method to update our order book and delete this order from it. </span><span class="koboSpan" id="kobo.1490.2">Finally, we send the market update to the matching engine, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">sendMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1492.1"> method, and we send the client response to the matching engine, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">sendClientResponse()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1495.1">
Â Â else {
Â Â Â Â client_response_ = {ClientResponseType::CANCELED,
Â Â Â Â Â Â client_id, ticker_id, order_id,
Â Â Â Â Â Â exchange_order-&gt;market_order_id_,
Â Â Â Â Â Â exchange_order-&gt;side_, exchange_order-&gt;price_,
Â Â Â Â Â Â Qty_INVALID, exchange_order-&gt;qty_};
Â Â Â Â market_update_ = {MarketUpdateType::CANCEL,
Â Â Â Â Â Â exchange_order-&gt;market_order_id_, ticker_id,
Â Â Â Â Â Â exchange_order-&gt;side_, exchange_order-&gt;price_, 0,
Â Â Â Â Â Â exchange_order-&gt;priority_};
Â Â Â Â removeOrder(exchange_order);
Â Â Â Â matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
Â Â }
Â Â matching_engine_-&gt;sendClientResponse(&amp;client_response_);
}</span></pre>
<p><span class="koboSpan" id="kobo.1496.1">Next, let us implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">removeOrder()</span></strong><span class="koboSpan" id="kobo.1498.1"> method. </span><span class="koboSpan" id="kobo.1498.2">It first finds </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1500.1"> that the order being removed belongs to and then finds and removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1502.1"> from the list of orders contained in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1504.1">. </span><span class="koboSpan" id="kobo.1504.2">If the order being </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.1505.1">removed is the only order at the price level, the method also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">removeOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1507.1"> to remove the entire price level, since after this deletion, that no longer exists. </span><span class="koboSpan" id="kobo.1507.2">Finally, it removes the entry for that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1509.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.1511.1"> hash map and returns the deallocated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1513.1"> object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">order_pool_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1515.1">memory pool:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1516.1">
auto removeOrder(MEOrder *order) noexcept {
Â Â auto orders_at_price = getOrdersAtPrice(order-&gt;price_);
Â Â if (order-&gt;prev_order_ == order) { // only one element.
</span><span class="koboSpan" id="kobo.1516.2">Â Â Â Â removeOrdersAtPrice(order-&gt;side_, order-&gt;price_);
Â Â } else { // remove the link.
</span><span class="koboSpan" id="kobo.1516.3">Â Â Â Â const auto order_before = order-&gt;prev_order_;
Â Â Â Â const auto order_after = order-&gt;next_order_;
Â Â Â Â order_before-&gt;next_order_ = order_after;
Â Â Â Â order_after-&gt;prev_order_ = order_before;
Â Â Â Â if (orders_at_price-&gt;first_me_order_ == order) {
Â Â Â Â Â Â orders_at_price-&gt;first_me_order_ = order_after;
Â Â Â Â }
Â Â Â Â order-&gt;prev_order_ = order-&gt;next_order_ = nullptr;
Â Â }
Â Â cid_oid_to_order_.at(order-&gt;client_id_).at(order
Â Â Â Â -&gt;client_order_id_) = nullptr;
Â Â order_pool_.deallocate(order);
}</span></pre>
<p><span class="koboSpan" id="kobo.1517.1">To conclude our discussion of tasks involved in handling order cancellation requests, we will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">removeOrdersAtPrice()</span></strong><span class="koboSpan" id="kobo.1519.1"> method. </span><span class="koboSpan" id="kobo.1519.2">It finds and removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1521.1"> from the doubly linked list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1523.1"> for the bid or ask side. </span><span class="koboSpan" id="kobo.1523.2">If this price entry being removed happens to be the only </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1525.1"> entry on that </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.1526.1">side of the book, it sets the head of the doubly linked list to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">nullptr</span></strong><span class="koboSpan" id="kobo.1528.1">, representing an empty side of the book. </span><span class="koboSpan" id="kobo.1528.2">Finally, the method removes the entry from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.1530.1"> hash map for that price and returns the deallocated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1532.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">orders_at_price_pool_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1534.1">memory pool:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1535.1">
auto removeOrdersAtPrice(Side side, Price price) noexcept {
Â Â const auto best_orders_by_price = (side == Side::BUY ?
</span><span class="koboSpan" id="kobo.1535.2">Â Â Â Â bids_by_price_ : asks_by_price_);
Â Â auto orders_at_price = getOrdersAtPrice(price);
Â Â if (UNLIKELY(orders_at_price-&gt;next_entry_ ==
Â Â Â Â orders_at_price)) { // empty side of book.
</span><span class="koboSpan" id="kobo.1535.3">Â Â Â Â (side == Side::BUY ? </span><span class="koboSpan" id="kobo.1535.4">bids_by_price_ : asks_by_price_) =
Â Â Â Â Â Â nullptr;
Â Â } else {
Â Â Â Â orders_at_price-&gt;prev_entry_-&gt;next_entry_ =
Â Â Â Â Â Â orders_at_price-&gt;next_entry_;
Â Â Â Â orders_at_price-&gt;next_entry_-&gt;prev_entry_ =
Â Â Â Â Â Â orders_at_price-&gt;prev_entry_;
Â Â Â Â if (orders_at_price == best_orders_by_price) {
Â Â Â Â Â Â (side == Side::BUY ? </span><span class="koboSpan" id="kobo.1535.5">bids_by_price_ : asks_by_price_)
Â Â Â Â Â Â = orders_at_price-&gt;next_entry_;
Â Â Â Â }
Â Â Â Â Orders_at_price-&gt;prev_entry_ = orders_at_price
Â Â Â Â Â Â -&gt;next_entry_ = nullptr;
Â Â }
Â Â price_orders_at_price_.at(priceToIndex(price)) = nullptr;
Â Â orders_at_price_pool_.deallocate(orders_at_price);
}</span></pre>
<p><span class="koboSpan" id="kobo.1536.1">The last operation we need to tackle is an important one â€“ matching aggressive orders against passive </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.1537.1">orders on the other side of the order book. </span><span class="koboSpan" id="kobo.1537.2">We will look at the implementation of that </span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1">operation next.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.1539.1">Matching aggressive orders and updating the order book</span></h2>
<p><span class="koboSpan" id="kobo.1540.1">In this subsection, we will implement the matching functionality in the limit order book by presenting </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.1541.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">MEOrderBook::checkForMatch()</span></strong><span class="koboSpan" id="kobo.1543.1"> method we encountered earlier. </span><span class="koboSpan" id="kobo.1543.2">The diagram presented in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1544.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1545.1">.3</span></em><span class="koboSpan" id="kobo.1546.1"> shows </span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.1547.1">what would happen in a hypothetical state of the limit order book. </span><span class="koboSpan" id="kobo.1547.2">Here, the state of the ask side is shown, and the passive sell prices represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1549.1"> are </span><strong class="bold"><span class="koboSpan" id="kobo.1550.1">117</span></strong><span class="koboSpan" id="kobo.1551.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1552.1">118</span></strong><span class="koboSpan" id="kobo.1553.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1554.1">119</span></strong><span class="koboSpan" id="kobo.1555.1">, and so on, in that order. </span><span class="koboSpan" id="kobo.1555.2">At the best ask price, </span><strong class="bold"><span class="koboSpan" id="kobo.1556.1">117</span></strong><span class="koboSpan" id="kobo.1557.1">, the first two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1559.1"> objects are shown, the first one with a priority of </span><strong class="bold"><span class="koboSpan" id="kobo.1560.1">11</span></strong><span class="koboSpan" id="kobo.1561.1">, a market order ID of </span><strong class="bold"><span class="koboSpan" id="kobo.1562.1">1200</span></strong><span class="koboSpan" id="kobo.1563.1">, and a quantity of </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">20</span></strong><span class="koboSpan" id="kobo.1565.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1567.1"> following that in the FIFO queue has a priority of </span><strong class="bold"><span class="koboSpan" id="kobo.1568.1">13</span></strong><span class="koboSpan" id="kobo.1569.1">, a market order ID of </span><strong class="bold"><span class="koboSpan" id="kobo.1570.1">1400</span></strong><span class="koboSpan" id="kobo.1571.1">, and a quantity of </span><strong class="bold"><span class="koboSpan" id="kobo.1572.1">10</span></strong><span class="koboSpan" id="kobo.1573.1">. </span><span class="koboSpan" id="kobo.1573.2">In this case, a new buy order with a quantity of </span><strong class="bold"><span class="koboSpan" id="kobo.1574.1">25</span></strong><span class="koboSpan" id="kobo.1575.1"> and a price of </span><strong class="bold"><span class="koboSpan" id="kobo.1576.1">117</span></strong><span class="koboSpan" id="kobo.1577.1"> (represented in blue) will match the first order with a market order ID of </span><strong class="bold"><span class="koboSpan" id="kobo.1578.1">1200</span></strong><span class="koboSpan" id="kobo.1579.1"> (represented in yellow) and execute it fully. </span><span class="koboSpan" id="kobo.1579.2">It will then partially execute the remaining quantity of </span><strong class="bold"><span class="koboSpan" id="kobo.1580.1">5</span></strong><span class="koboSpan" id="kobo.1581.1"> against the order with a market order ID of </span><strong class="bold"><span class="koboSpan" id="kobo.1582.1">1400</span></strong><span class="koboSpan" id="kobo.1583.1"> (represented in magenta), and the matching event is finished. </span><span class="koboSpan" id="kobo.1583.2">These steps are presented in the algorithm right after the </span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.1585.1"><img alt="Figure 6.3 â€“ An exaï»¿mple of a matching event in the limit order book" src="image/Figure_6.3_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1586.1">Figure 6.3 â€“ An exa</span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1587.1">mple of a matching event in the limit order book</span></p>
<p><span class="koboSpan" id="kobo.1588.1">This method iterates through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1590.1"> objects on the side of the book opposite to the new (and possibly aggressive) order. </span><span class="koboSpan" id="kobo.1590.2">It iterates through the price levels from the most aggressive to least aggressive price and, for each price level, matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1592.1"> objects contained at that price level from the first to last, in the FIFO order. </span><span class="koboSpan" id="kobo.1592.2">It continues matching the new order against the passive orders on the other side, from the most aggressive to the least aggressive price and in the first to last order at a price level, by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">match()</span></strong><span class="koboSpan" id="kobo.1594.1"> method. </span><span class="koboSpan" id="kobo.1594.2">It stops and returns when either the new aggressive order </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.1595.1">has no more unmatched quantity left to match, the </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.1596.1">remaining price levels on the other side no longer cross the new orderâ€™s price, or the side of the book is empty. </span><span class="koboSpan" id="kobo.1596.2">At that point, it returns the remaining unmatched quantity on the new order to </span><span class="No-Break"><span class="koboSpan" id="kobo.1597.1">the caller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1598.1">
auto MEOrderBook::checkForMatch(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty, Qty new_market_order_id) noexcept {
Â Â auto leaves_qty = qty;</span></pre>
<p><span class="koboSpan" id="kobo.1599.1">We keep iterating through all the ask price levels, arranged from the lowest to the highest prices, starting from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1601.1"> level. </span><span class="koboSpan" id="kobo.1601.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1603.1"> level, we start from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">first_me_order_</span></strong><span class="koboSpan" id="kobo.1605.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1607.1"> type pointer and iterate in the FIFO order, from the lowest to the highest priority. </span><span class="koboSpan" id="kobo.1607.2">For each order that can match against the new aggressive order, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">MEOrder::match()</span></strong><span class="koboSpan" id="kobo.1609.1"> method to perform the actual match. </span><span class="koboSpan" id="kobo.1609.2">We continue doing this till either there is no more </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">leaves_qty</span></strong><span class="koboSpan" id="kobo.1611.1"> left, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">asks_by_price_</span></strong><span class="koboSpan" id="kobo.1613.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">nullptr</span></strong><span class="koboSpan" id="kobo.1615.1"> to signify an empty book side, or the remaining price levels cannot be used to match the </span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">new order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1617.1">
Â Â if (side == Side::BUY) {
Â Â Â Â while (leaves_qty &amp;&amp; asks_by_price_) {
Â Â Â Â Â Â const auto ask_itr = asks_by_price_-&gt;first_me_order_;
Â Â Â Â Â Â if (LIKELY(price &lt; ask_itr-&gt;price_)) {
Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â }
Â Â Â Â Â Â match(ticker_id, client_id, side, client_order_id,
Â Â Â Â Â Â Â Â new_market_order_id, ask_itr, &amp;leaves_qty);
Â Â Â Â }
Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.1618.1">If the new order has a side of sell, we perform the same logic as described previously, except we iterate through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">bids_by_price_</span></strong><span class="koboSpan" id="kobo.1620.1"> price levels, which are arranged from the highest buy price to the lowest buy price, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1622.1">
Â Â if (side == Side::SELL) {
Â Â Â Â while (leaves_qty &amp;&amp; bids_by_price_) {
Â Â Â Â Â Â const auto bid_itr = bids_by_price_-&gt;first_me_order_;
Â Â Â Â Â Â if (LIKELY(price &gt; bid_itr-&gt;price_)) {
Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â }
Â Â Â Â Â Â match(ticker_id, client_id, side, client_order_id,
Â Â Â Â Â Â Â Â new_market_order_id, bid_itr, &amp;leaves_qty);
Â Â Â Â }
Â Â }
Â Â return leaves_qty;
}</span></pre>
<p><span class="koboSpan" id="kobo.1623.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">match()</span></strong><span class="koboSpan" id="kobo.1625.1"> method is called when a new aggressive order matches an existing passive order on the other side of the book. </span><span class="koboSpan" id="kobo.1625.2">It computes the executed quantity, which is the minimum of </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.1626.1">the quantity of the new order and the existing passive </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.1627.1">order it would match against. </span><span class="koboSpan" id="kobo.1627.2">It subtracts this executed quantity from the remaining quantity of the aggressive order, as well as the passive order it matched against. </span><span class="koboSpan" id="kobo.1627.3">It generates two execution order responses and sends them to the matching engine â€“ one for the client who sent the aggressive order and another one for the client whose passive order got executed against the new order. </span><span class="koboSpan" id="kobo.1627.4">It also creates and publishes a market update of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1628.1">MarketUpdateType::TRADE</span></strong><span class="koboSpan" id="kobo.1629.1"> to notify participants about the execution on the public market data feed. </span><span class="koboSpan" id="kobo.1629.2">Finally, it checks whether this trade transaction fully executes the passive order or not, and if there is a full execution, it generates another market update of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">MarketUpdateType::CANCEL</span></strong><span class="koboSpan" id="kobo.1631.1"> to notify participants that the passive order has been removed. </span><span class="koboSpan" id="kobo.1631.2">If the passive order is only partially matched, it instead generates a market update of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">MarketUpdateType::MODIFY</span></strong><span class="koboSpan" id="kobo.1633.1"> with the new remaining quantity of the passive </span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1">limit order.</span></span></p>
<p><span class="koboSpan" id="kobo.1635.1">What this means is that participants who choose to ignore trade messages from the market data stream can still accurately build and maintain the limit order book. </span><span class="koboSpan" id="kobo.1635.2">We could theoretically eliminate the extra cancel or modify market update, but that would require downstream market data consumers to apply trade messages to their order books and </span><span class="No-Break"><span class="koboSpan" id="kobo.1636.1">update them.</span></span></p>
<p><span class="koboSpan" id="kobo.1637.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">MEOrderBook::match()</span></strong><span class="koboSpan" id="kobo.1639.1"> method takes a few arguments to identify the client information, but the key arguments are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1641.1"> pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">itr</span></strong><span class="koboSpan" id="kobo.1643.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1644.1">Qty</span></strong><span class="koboSpan" id="kobo.1645.1"> pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1646.1">leaves_qty</span></strong><span class="koboSpan" id="kobo.1647.1">. </span><span class="koboSpan" id="kobo.1647.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1648.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1649.1"> pointer represents the order in the book that the new order is being matched against, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">Qty</span></strong><span class="koboSpan" id="kobo.1651.1"> represents the remaining quantity on the new order. </span><span class="koboSpan" id="kobo.1651.2">These </span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.1652.1">arguments are passed by pointer because we </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.1653.1">will modify them directly in this method and expect the changes to be reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1654.1">calling method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1655.1">
auto MEOrderBook::match(TickerId ticker_id, ClientId client_id, Side side, OrderId client_order_id, OrderId new_market_order_id, MEOrder* itr, Qty* leaves_qty) noexcept {</span></pre>
<p><span class="koboSpan" id="kobo.1656.1">We compute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1657.1">fill_qty</span></strong><span class="koboSpan" id="kobo.1658.1"> variable to be the minimum of the quantity on the passive order that exists in the book and the new orderâ€™s quantity. </span><span class="koboSpan" id="kobo.1658.2">We then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">fill_qty</span></strong><span class="koboSpan" id="kobo.1660.1"> to decrease both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">leaves_qty</span></strong><span class="koboSpan" id="kobo.1662.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">qty_</span></strong><span class="koboSpan" id="kobo.1664.1"> member on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1665.1">MEOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1667.1">
Â Â const auto order = itr;
Â Â const auto order_qty = order-&gt;qty_;
Â Â const auto fill_qty = std::min(*leaves_qty, order_qty);
Â Â *leaves_qty -= fill_qty;
Â Â order-&gt;qty_ -= fill_qty;</span></pre>
<p><span class="koboSpan" id="kobo.1668.1">We generate a client response message of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1669.1">ClientResponseType::FILLED</span></strong><span class="koboSpan" id="kobo.1670.1">, meant for the client who sent the new order, and dispatch it to the matching engine using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1671.1">sendClientResponse()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1672.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1673.1">
Â Â client_response_ = {ClientResponseType::FILLED,
Â Â Â Â client_id, ticker_id, client_order_id,
Â Â Â Â new_market_order_id, side, itr-&gt;price_, fill_qty,
Â Â Â Â *leaves_qty};
Â Â matching_engine_-&gt;sendClientResponse(&amp;client_response_);</span></pre>
<p><span class="koboSpan" id="kobo.1674.1">We also generate a second client response message of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">type_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1676.1">ClientResponseType::FILLED</span></strong><span class="koboSpan" id="kobo.1677.1">; this one is meant for the client whose order was in the order book and </span><span class="No-Break"><span class="koboSpan" id="kobo.1678.1">got matched:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1679.1">
Â Â client_response_ = {ClientResponseType::FILLED, order
Â Â Â Â -&gt;client_id_, ticker_id, order-&gt;client_order_id_,
Â Â Â Â order-&gt;market_order_id_, order-&gt;side_, itr-&gt;price_,
Â Â Â Â fill_qty, order-&gt;qty_};
Â Â matching_engine_-&gt;sendClientResponse(&amp;client_response_);</span></pre>
<p><span class="koboSpan" id="kobo.1680.1">We will also generate </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.1681.1">a market update of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">MarketUpdateType::TRADE</span></strong><span class="koboSpan" id="kobo.1683.1"> and </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.1684.1">publish it using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">sendMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1686.1">, notifying the participants about the trade transaction that occurred and providing them </span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1688.1">fill_qty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1689.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1690.1">
Â Â market_update_ = {MarketUpdateType::TRADE,
Â Â Â Â OrderId_INVALID, ticker_id, side, itr-&gt;price_,
Â Â Â Â fill_qty, Priority_INVALID};
Â Â matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);</span></pre>
<p><span class="koboSpan" id="kobo.1691.1">Finally, we will generate a market update for the passive client order that existed in the book. </span><span class="koboSpan" id="kobo.1691.2">If there is some quantity remaining on this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1692.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1693.1">, then we generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1694.1">MarketUpdateType::MODIFY</span></strong><span class="koboSpan" id="kobo.1695.1"> message and pass the remaining quantity left on that order. </span><span class="koboSpan" id="kobo.1695.2">If the order is fully executed, then we generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1696.1">MarketUpdateType::CANCEL</span></strong><span class="koboSpan" id="kobo.1697.1"> update, publish it, and also call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1698.1">MEOrderBook::removeOrder()</span></strong><span class="koboSpan" id="kobo.1699.1"> method to remove this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1700.1">MEOrder</span></strong><span class="koboSpan" id="kobo.1701.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1702.1">order book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1703.1">
Â Â if (!order-&gt;qty_) {
Â Â Â Â market_update_ = {MarketUpdateType::CANCEL,
Â Â Â Â Â Â order-&gt;market_order_id_, ticker_id, order-&gt;side_,
Â Â Â Â Â Â order-&gt;price_, order_qty, Priority_INVALID};
Â Â Â Â matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
Â Â Â Â removeOrder(order);
Â Â } else {
Â Â Â Â market_update_ = {MarketUpdateType::MODIFY,
Â Â Â Â Â Â order-&gt;market_order_id_, ticker_id, order-&gt;side_,
Â Â Â Â Â Â order-&gt;price_, order-&gt;qty_, order-&gt;priority_};
Â Â Â Â matching_engine_-&gt;sendMarketUpdate(&amp;market_update_);
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1704.1">This concludes our </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.1705.1">discussion of the operations involved in handling client </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.1706.1">order requests, updating the limit order book inside the matching engine, and generating and publishing order responses and </span><span class="No-Break"><span class="koboSpan" id="kobo.1707.1">market updates.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1708.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1709.1">We started the C++ implementation of our electronic trading ecosystem in this chapter. </span><span class="koboSpan" id="kobo.1709.2">The first component we built was the exchange matching engine in charge of accepting and answering order requests from the order server component in the exchange infrastructure. </span><span class="koboSpan" id="kobo.1709.3">This component is also responsible for generating and publishing market data updates to the market data publisher component in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">exchangeâ€™s infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.1711.1">First, we declared some assumptions in our matching engine and limit order books. </span><span class="koboSpan" id="kobo.1711.2">We also defined a couple of basic </span><strong class="bold"><span class="koboSpan" id="kobo.1712.1">Plain Old Data</span></strong><span class="koboSpan" id="kobo.1713.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1714.1">POD</span></strong><span class="koboSpan" id="kobo.1715.1">)-style structures to encapsulate information for a single order in the limit order book, a single order request sent from the order server, an order response sent back to the order server, and a single market data update. </span><span class="koboSpan" id="kobo.1715.2">We showed how to use the lock-free queue to facilitate communication between the matching engine and order server and market data publisher for order requests, order responses, and market data updates. </span><span class="koboSpan" id="kobo.1715.3">To build the limit order book, we also defined some hash maps to track orders by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">OrderId</span></strong><span class="koboSpan" id="kobo.1717.1"> and chain together orders at the same price inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.1719.1"> structure. </span><span class="koboSpan" id="kobo.1719.2">Reiterating what we already covered, these price levels themselves are maintained in a doubly linked list and a hash map indexed </span><span class="No-Break"><span class="koboSpan" id="kobo.1720.1">by price.</span></span></p>
<p><span class="koboSpan" id="kobo.1721.1">Then, we built the matching engine component, which is an independent thread of execution that consumes updates from the order server and publishes responses and market data updates back to the order server and the market data publisher. </span><span class="koboSpan" id="kobo.1721.2">We also built the main application binary for the electronic trading exchange, which we will enhance in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1723.1">Finally, we laid out the details of the mechanism involved in building and updating the data structures for the limit order book. </span><span class="koboSpan" id="kobo.1723.2">We discussed the tasks involved in handling new order requests and order cancelation requests. </span><span class="koboSpan" id="kobo.1723.3">We also implemented the functionality of the matching engine to perform the actual matching between new aggressive orders against existing passive orders that cross in price. </span><span class="koboSpan" id="kobo.1723.4">Match events generate private execution messages for the market participants involved in a match event. </span><span class="koboSpan" id="kobo.1723.5">Additionally, the event also generates trade messages and order deletion or modification on the public market </span><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">data feed.</span></span></p>
<p><span class="koboSpan" id="kobo.1725.1">In the next chapter, we will build the market data publisher component, which is the component that consumes the market data updates generated from the matching engine and puts them on the wire for participants to consume. </span><span class="koboSpan" id="kobo.1725.2">Additionally, we will also build the order server component that resides in the electronic trading exchange and manages the communication with the different market participant order gateways, forwarding requests and responses to and from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1726.1">matching engine.</span></span></p>
</div>
</body></html>