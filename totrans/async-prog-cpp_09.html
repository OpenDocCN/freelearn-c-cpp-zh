<html><head></head><body>
  <div id="_idContainer059">
   <h1 class="chapter-number" id="_idParaDest-185">
    <a id="_idTextAnchor184">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     9
    </span>
   </h1>
   <h1 id="_idParaDest-186">
    <a id="_idTextAnchor185">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Asynchronous Programming Using Boost.Asio
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.3.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     is a C++ library
    </span>
    <a id="_idIndexMarker628">
    </a>
    <span class="koboSpan" id="kobo.5.1">
     included in the well-known Boost libraries family that simplifies the development of solutions dealing with asynchronous
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      input/output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ) tasks
    </span>
    <a id="_idIndexMarker629">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     managed by the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      operating system
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.13.1">
      OS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     ), making it
    </span>
    <a id="_idIndexMarker630">
    </a>
    <span class="koboSpan" id="kobo.15.1">
     easier to develop asynchronous software that deals with internal and external resources, such as network communications services or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      file operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.17.1">
     For that purpose, Boost.Asio defines OS services (services belonging to and managed by the OS), I/O objects (providing interfaces to OS services), and the I/O execution context object (an object that behaves as a services registry
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.18.1">
      and proxy).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.19.1">
     In the following pages, we will introduce Boost.Asio, describe its main building blocks, and explain some common patterns to develop asynchronous software with this library, which are widely used in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.20.1">
      the industry.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.21.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      What Boost.Asio is and how it simplifies asynchronous programming with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       external resources
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.25.1">
      What I/O objects and I/O execution contexts are, and how they interact with OS services and between
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.26.1">
       each other
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.27.1">
      What the Proactor and Reactor design patterns are, and how they are related
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.28.1">
       to Boost.Asio
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.29.1">
      How to keep the program thread-safe and how to serialize tasks
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       using strands
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.31.1">
      How to efficiently pass data to asynchronous tasks
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       using buffers
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      How to cancel
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       asynchronous operations
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.35.1">
      Examples of common practices with timers and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       networking applications
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-187">
    <a id="_idTextAnchor186">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     For this chapter, we will need to install the Boost C++ libraries.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     The most recent version when writing this book is Boost 1.85.0.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     Here are the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      release notes:
     </span>
    </span>
   </p>
   <p>
    <a href="https://www.boost.org/users/history/version_1_85_0.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.40.1">
       https://www.boost.org/users/history/version_1_85_0.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     For installation instructions in Unix variants systems (Linux, macOS), check out the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      following link:
     </span>
    </span>
   </p>
   <p>
    <a href="https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.43.1">
       https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     For Windows systems, check out
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      this link:
     </span>
    </span>
   </p>
   <p>
    <a href="https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     Also, depending on the project we want to develop, we might need to configure
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.48.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      install dependencies:
     </span>
    </span>
   </p>
   <p>
    <a href="https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.51.1">
       https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     All code shown during this chapter will be supported by the C++20 version.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     Please check the technical requirements section in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.53.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.54.1">
     with some guidance on how to install GCC 13 and Clang
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      8 compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     You can find the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      Chapter_09
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     All source code files can be compiled using CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.63.1">
cmake . </span><span class="koboSpan" id="kobo.63.2">&amp;&amp; cmake —build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     Executable binaries will be generated under the
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.65.1">
       bin
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-188">
    <a id="_idTextAnchor187">
    </a>
    <span class="koboSpan" id="kobo.67.1">
     What is Boost.Asio?
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.68.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     is a
    </span>
    <a id="_idIndexMarker631">
    </a>
    <span class="koboSpan" id="kobo.70.1">
     cross-platform C++ library created by Chris Kohlhoff that provides a portable network and low-level I/O programming, including sockets, timers, hostname resolution, socket iostreams, serial ports, file descriptors, and Windows HANDLEs, providing a consistent asynchronous model.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     It also provides coroutine support, but as we learned in the previous chapter, they are now available in C++20, so we will only introduce them briefly in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     Boost.Asio allows the program to manage long-running operations without the explicit usage of threads and locks.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     Also, as it implements a layer on top of the OS services, it allows portability, efficiency, ease of use, and scalability, using the most appropriate underlying OS mechanisms to achieve these goals, for example, scatter-gather I/O operations or moving data across while minimizing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      costly copies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     Let’s start by learning
    </span>
    <a id="_idIndexMarker632">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     about the basic Boost.Asio blocks, I/O objects, and I/O execution
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      context objects.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-189">
    <a id="_idTextAnchor188">
    </a>
    <span class="koboSpan" id="kobo.77.1">
     I/O objects
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     Sometimes, an application
    </span>
    <a id="_idIndexMarker633">
    </a>
    <span class="koboSpan" id="kobo.79.1">
     needs to access OS services, run asynchronous
    </span>
    <a id="_idIndexMarker634">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     tasks on them, and collect the results or errors.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.81.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.82.1">
     provides a mechanism composed of I/O objects and I/O execution context objects to allow
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      this functionality.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     I/O objects are task-oriented objects representing the actual entities performing I/O operations.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     As we can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.85.1">
       Figure 9
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.86.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.87.1">
     , Boost.Asio provides core classes to manage concurrency, streams, buffers, or other core functionality to the library and also includes portable
    </span>
    <a id="_idIndexMarker635">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     networking classes for
    </span>
    <a id="_idIndexMarker636">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     network communications via
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.90.1">
      Transmission Control Protocol/Internet Protocol
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.92.1">
      TCP/IP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.93.1">
     ),
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.94.1">
      User Datagram Protocol
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.96.1">
      UDP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     ), or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.98.1">
      Internet Control Message Protocol
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.100.1">
      ICMP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     ), classes to define the security layer, the
    </span>
    <a id="_idIndexMarker637">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     transmission protocol and serial port, among other tasks, and also platform-specific classes to deal with specific settings depending on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      underlying OS.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.104.1">
      <img alt="Figure 9.1 – I/O objects" src="image/B22219_09_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.105.1">
     Figure 9.1 – I/O objects
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     The I/O objects do not directly execute their tasks in the OS.
    </span>
    <span class="koboSpan" id="kobo.106.2">
     They need to communicate with the OS via an I/O execution context object.
    </span>
    <span class="koboSpan" id="kobo.106.3">
     An instance of a context object is passed as the first argument in the I/O object constructors.
    </span>
    <span class="koboSpan" id="kobo.106.4">
     Here, we are defining an I/O object (a timer with an expiration time of three seconds) and passing an I/O execution context object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.107.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     ) via
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      its constructor:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.110.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
using namespace std::chrono_literals;
boost::asio::io_context io_context;
boost::asio::steady_timer timer(io_context, 3s);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     Most I/O objects have methods whose name starts with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.112.1">
      async_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.113.1">
     .
    </span>
    <span class="koboSpan" id="kobo.113.2">
     These methods trigger asynchronous operations, which will call a completion handler, a callable object passed as an argument to the method when the operation completes.
    </span>
    <span class="koboSpan" id="kobo.113.3">
     These methods return immediately, not blocking the program flow.
    </span>
    <span class="koboSpan" id="kobo.113.4">
     The current thread can continue performing other tasks while the task is not complete.
    </span>
    <span class="koboSpan" id="kobo.113.5">
     Once completed, the completion handler will be called and executed, dealing with the result or error of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      asynchronous task.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     I/O objects also provide the blocking counterpart methods, which will block until completion.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     These methods do not need to receive a handler as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      a parameter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.117.1">
     As mentioned before, note that the I/O objects don’t interact directly with the OS; they need an I/O execution
    </span>
    <a id="_idIndexMarker638">
    </a>
    <span class="koboSpan" id="kobo.118.1">
     context object.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     Let’s learn about this class
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker639">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      objects.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-190">
    <a id="_idTextAnchor189">
    </a>
    <span class="koboSpan" id="kobo.121.1">
     I/O execution context objects
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.122.1">
     To access the I/O services, the
    </span>
    <a id="_idIndexMarker640">
    </a>
    <span class="koboSpan" id="kobo.123.1">
     program uses at least
    </span>
    <a id="_idIndexMarker641">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     one I/O execution context object that represents the gateway to the OS I/O services.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     It’s implemented with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      boost::asio::io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.126.1">
     class, providing the core I/O functionality of OS services to I/O objects.
    </span>
    <span class="koboSpan" id="kobo.126.2">
     In Windows,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      boost::asio::io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     is based
    </span>
    <a id="_idIndexMarker642">
    </a>
    <span class="koboSpan" id="kobo.129.1">
     in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.130.1">
      I/O completion ports
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.132.1">
      IOCP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     ), on Linux, it is based in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.134.1">
      epoll
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     , and on FreeBSD/macOS, it is based
    </span>
    <a id="_idIndexMarker643">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.136.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.137.1">
       kqueue
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      .
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.139.1">
      <img alt="Figure 9.2 – Boost.Asio architecture" src="image/B22219_09_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.140.1">
     Figure 9.2 – Boost.Asio architecture
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      boost::asio::io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     is a subclass of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      boost::asio::execution_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     , a base class for function object execution also inherited by other execution context objects, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      boost::asio::thread_pool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.147.1">
      boost::asio::system_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.148.1">
     .
    </span>
    <span class="koboSpan" id="kobo.148.2">
     In this chapter, we
    </span>
    <a id="_idIndexMarker644">
    </a>
    <span class="koboSpan" id="kobo.149.1">
     will be using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      boost::asio::io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     as our execution
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      context object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      boost::asio::io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     class has been a replacement for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      boost::asio::io_service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     class since version 1.66.0, embracing more modern features and practices from C++.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      boost::asio::io_service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     is still available for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      backward compatibility.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     As described earlier, Boost.Asio objects can schedule asynchronous operations using methods starting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      async_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     .
    </span>
    <span class="koboSpan" id="kobo.163.2">
     When all the asynchronous tasks are scheduled, the program needs to call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      boost::asio::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     function to execute an event processing loop, allowing the OS to deal with the tasks and pass to the program the results and trigger
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      the handlers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     Coming back to our previous example, we will now set up the completion handler,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      on_timeout()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     , a callable object (in this case a function) that we pass as a parameter when calling the
    </span>
    <a id="_idIndexMarker645">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     asynchronous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     Here
    </span>
    <a id="_idIndexMarker646">
    </a>
    <span class="koboSpan" id="kobo.173.1">
     is the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      code example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.175.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
void on_timeout(const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired.\n" &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Error: " &lt;&lt; ec.message() &lt;&lt; '\n';
    }
}
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context,
                              std::chrono::seconds(3));
    timer.async_wait(&amp;on_timeout);
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     Running this code, we should see the message
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      Timer expired.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     in the console after three seconds, or an error message if the asynchronous call fails for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.179.1">
      any reason.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      boost::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     is a blocking call.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     This is intended to keep the event loop running, allow the asynchronous operations to run, and prevent the program from exiting.
    </span>
    <span class="koboSpan" id="kobo.181.3">
     Obviously, this function can be called in a new thread and leave the main thread unblocked to carry on with other tasks, as we have seen in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      previous chapters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     When there are no pending asynchronous operations,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      boost::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     will return.
    </span>
    <span class="koboSpan" id="kobo.185.2">
     There is a template class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      boost::asio::executor_work_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     , that can keep
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.188.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.189.1">
     busy and avoid it exiting if needed.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     Let’s see how it works with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      an example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     Let’s start by
    </span>
    <a id="_idIndexMarker647">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     defining a background task that will wait
    </span>
    <a id="_idIndexMarker648">
    </a>
    <span class="koboSpan" id="kobo.193.1">
     for two seconds before posting some work through
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.196.1">
       boost::asio::io_context::post()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.198.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void background_task(boost::asio::io_context&amp; io_context) {
    std::this_thread::sleep_for(2s);
    std::cout &lt;&lt; "Posting a background task.\n";
    io_context.post([]() {
        std::cout &lt;&lt; "Background task completed!\n";
    });
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     function, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     object is created, and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      work_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     object is constructed using that
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.206.1">
       io_context
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     Then, two threads are created,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      io_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     runs, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      worker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      background_task()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     will run.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     We also pass
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     as a reference to the background task to post work, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      explained earlier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.220.1">
     With that in place, the main thread does some work (waiting for five seconds) and then removes the work guard by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      reset()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     function, letting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     exit its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     function, and joins
    </span>
    <a id="_idIndexMarker649">
    </a>
    <span class="koboSpan" id="kobo.227.1">
     both threads before exiting, as
    </span>
    <a id="_idIndexMarker650">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.228.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.229.1">
int main() {
    boost::asio::io_context io_context;
    auto work_guard = boost::asio::make_work_guard(
                      io_context);
    std::thread io_thread([&amp;io_context]() {
        std::cout &lt;&lt; "Running io_context.\n";
        io_context.run();
        std::cout &lt;&lt; "io_context stopped.\n";
    });
    std::thread worker(background_task,
                       std::ref(io_context));
    // Main thread doing some work.
</span><span class="koboSpan" id="kobo.229.2">    std::this_thread::sleep_for(5s);
    std::cout &lt;&lt; "Removing work_guard." </span><span class="koboSpan" id="kobo.229.3">&lt;&lt; std::endl;
    work_guard.reset();
    worker.join();
    io_thread.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     If we run the previous code, this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.231.1">
      the output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.232.1">
Running io_context.
</span><span class="koboSpan" id="kobo.232.2">Posting a background task.
</span><span class="koboSpan" id="kobo.232.3">Background task completed!
</span><span class="koboSpan" id="kobo.232.4">Removing work_guard.
</span><span class="koboSpan" id="kobo.232.5">io_context stopped.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     We can see how the background thread posts a background task correctly, and this is completed before the work guard is removed and the I/O context object stops
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      its execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.235.1">
     Another way to keep the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     object alive and servicing requests is to provide asynchronous tasks by continuously calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      async_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     functions or posting work from the completion handlers.
    </span>
    <span class="koboSpan" id="kobo.239.2">
     This is
    </span>
    <a id="_idIndexMarker651">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     a common pattern when
    </span>
    <a id="_idIndexMarker652">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     reading or writing to sockets
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.242.1">
      or streams:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.243.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std::chrono_literals;
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 3s);
    std::function&lt;void(const boost::system::error_code&amp;)&gt;
                  timer_handler;
    timer_handler = [&amp;timer, &amp;timer_handler](
                     const boost::system::error_code&amp; ec) {
        if (!ec) {
            std::cout &lt;&lt; "Handler: Timer expired.\n";
            timer.expires_after(1s);
            timer.async_wait(timer_handler);
        } else {
            std::cerr &lt;&lt; "Handler error: "
                      &lt;&lt; ec.message() &lt;&lt; std::endl;
        }
    };
    timer.async_wait(timer_handler);
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     In this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.245.1">
      timer_handler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.246.1">
     is the completion handler defined as a lambda function that captures the timer and itself.
    </span>
    <span class="koboSpan" id="kobo.246.2">
     Every second, when the timer expires, it prints the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      Handler: Timer expired.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     message and restarts itself by enqueueing a new asynchronous task (using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     function) into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.251.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.252.1">
     object via the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       timer
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.255.1">
     As we have already seen, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.256.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.257.1">
     object can run from any thread.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     By default, this object is thread-safe, but in some scenarios where we want better performance, we might want to avoid
    </span>
    <a id="_idIndexMarker653">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     this safety.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     This can be adjusted
    </span>
    <a id="_idIndexMarker654">
    </a>
    <span class="koboSpan" id="kobo.259.1">
     during its construction, as we will see in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      next section.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.261.1">
     Concurrency hints
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.262.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     constructor
    </span>
    <a id="_idIndexMarker655">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     accepts as an argument a concurrency hint, suggesting to the implementation the number of active threads that should be used for running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      completion handlers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.267.1">
     By default, this value is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      BOOST_ASIO_CONCURRENCY_HINT_SAFE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     (value
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.270.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.271.1">
     ), indicating that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.272.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.273.1">
     object will run from a single thread, enabling several optimizations due to this fact.
    </span>
    <span class="koboSpan" id="kobo.273.2">
     That doesn’t mean that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.274.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.275.1">
     can only be used from one thread; it still provides thread safety, and it can use I/O objects from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      many threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     Other values that can be specified are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.279.1">
       BOOST_ASIO_CONCURRENCY_HINT_UNSAFE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.280.1">
      : Disables locking so all operations on
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.281.1">
       io_context
      </span>
     </strong>
     <span class="koboSpan" id="kobo.282.1">
      or I/O objects must occur in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.283.1">
       same thread.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.284.1">
       BOOST_ASIO_CONCURRENCY_HINT_UNSAFE_IO
      </span>
     </strong>
     <span class="koboSpan" id="kobo.285.1">
      : Disables locking in the reactor but keeps it in the scheduler, so all operations in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.286.1">
       io_context
      </span>
     </strong>
     <span class="koboSpan" id="kobo.287.1">
      object can use different threads apart from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.288.1">
       run()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.289.1">
      function and the other methods related to executing the event processing loop.
     </span>
     <span class="koboSpan" id="kobo.289.2">
      We will learn about schedulers and reactors when explaining the design principles behind
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.290.1">
       the library.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     Let’s now learn about what the event processing loop is and how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      manage it.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor190">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     The event processing loop
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.295.1">
      boost::asio::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.296.1">
     method,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     blocks and keeps
    </span>
    <a id="_idIndexMarker656">
    </a>
    <span class="koboSpan" id="kobo.299.1">
     processing I/O
    </span>
    <a id="_idIndexMarker657">
    </a>
    <span class="koboSpan" id="kobo.300.1">
     asynchronous tasks until all have been completed and the completion handlers have been notified.
    </span>
    <span class="koboSpan" id="kobo.300.2">
     This I/O requests processing is done in an internal event
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.301.1">
      processing loop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     There are other methods to control the event loop and avoid blocking until all asynchronous events are processed.
    </span>
    <span class="koboSpan" id="kobo.302.2">
     These are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.304.1">
       poll
      </span>
     </strong>
     <span class="koboSpan" id="kobo.305.1">
      : Run the event processing loop to execute
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.306.1">
       ready handlers
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.307.1">
       poll_one
      </span>
     </strong>
     <span class="koboSpan" id="kobo.308.1">
      : Run the event processing loop to execute one
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.309.1">
       ready handler
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.310.1">
       run_for
      </span>
     </strong>
     <span class="koboSpan" id="kobo.311.1">
      : Run the event processing loop for a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.312.1">
       specified duration
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.313.1">
       run_until
      </span>
     </strong>
     <span class="koboSpan" id="kobo.314.1">
      : Same as the previous one but only until a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.315.1">
       specified time
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.316.1">
       run_one
      </span>
     </strong>
     <span class="koboSpan" id="kobo.317.1">
      : Run the event processing loop to execute at most
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.318.1">
       one handler
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.319.1">
       run_one_for
      </span>
     </strong>
     <span class="koboSpan" id="kobo.320.1">
      : Same as the previous one but only for a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.321.1">
       specified duration
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.322.1">
       run_one_until
      </span>
     </strong>
     <span class="koboSpan" id="kobo.323.1">
      : Same as the previous one but only until a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.324.1">
       specified time
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.325.1">
     The event loop can also be stopped by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.326.1">
      boost::asio::io_context::stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.327.1">
     method or checking if its status is stopped by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.328.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.329.1">
       boost:asio::io_context::stopped()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     When the event loop is not running, tasks already being scheduled will continue executing.
    </span>
    <span class="koboSpan" id="kobo.331.2">
     Other tasks will remain pending.
    </span>
    <span class="koboSpan" id="kobo.331.3">
     Pending tasks can be resumed and pending results collected by starting the event loop with one of the methods mentioned
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      previously again.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     In previous examples, the application sent some work to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     by calling asynchronous methods
    </span>
    <a id="_idIndexMarker658">
    </a>
    <span class="koboSpan" id="kobo.336.1">
     or by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.337.1">
      post()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.338.2">
     Let’s learn now about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.339.1">
      dispatch()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     and its
    </span>
    <a id="_idIndexMarker659">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     differences
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.343.1">
       post()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.345.1">
     Giving some work to the io_context
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.346.1">
     Apart from
    </span>
    <a id="_idIndexMarker660">
    </a>
    <span class="koboSpan" id="kobo.347.1">
     sending work to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.348.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.349.1">
     via the asynchronous methods from the different I/O objects or by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      executor_work_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     (explained below), we can also use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      boost::asio::post()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.354.1">
      boost::asio::dispatch()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     template methods.
    </span>
    <span class="koboSpan" id="kobo.355.2">
     Both functions are used to schedule some work into an
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.356.1">
       io_context
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.358.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.359.1">
      post()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.360.1">
     function guarantees that the task will be executed.
    </span>
    <span class="koboSpan" id="kobo.360.2">
     It places its completion handler in the execution queue and eventually, it will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      be executed:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.362.1">
boost::asio::io_context io_context;
io_context.post([] {
    std::cout &lt;&lt; "This will always run asynchronously.\n";
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     On the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.364.1">
      dispatch()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     may execute the task immediately if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.366.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     or strand (more on strands later in this chapter) are in the same thread where the task is being dispatched, or otherwise placed in the queue for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      asynchronous execution:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.369.1">
boost::asio::io_context io_context;
io_context.dispatch([] {
    std::cout &lt;&lt; "This might run immediately or be queued.\n";
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     Therefore, using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      dispatch()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     , we can optimize performance by reducing context switching or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      queuing delays.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     Dispatched events can execute directly from the current worker thread even if there are other pending events queued up.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     The posted events must always need to be managed by the I/O execution
    </span>
    <a id="_idIndexMarker661">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     context, waiting until other handlers complete before being allowed to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      be executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     Now that we have already learned about some basic concepts, let’s learn how synchronous and asynchronous operations work under
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      the hood.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-192">
    <a id="_idTextAnchor191">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     Interacting with the OS
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.380.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     can interact with I/O services
    </span>
    <a id="_idIndexMarker662">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     using synchronous and asynchronous operations.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     Let’s learn how they behave and what the main
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      differences are.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-193">
    <a id="_idTextAnchor192">
    </a>
    <span class="koboSpan" id="kobo.384.1">
     Synchronous operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     If the program
    </span>
    <a id="_idIndexMarker663">
    </a>
    <span class="koboSpan" id="kobo.386.1">
     wants to use an I/O service
    </span>
    <a id="_idIndexMarker664">
    </a>
    <span class="koboSpan" id="kobo.387.1">
     in a synchronous way, usually, it will create an I/O object and use its synchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      operation method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.389.1">
boost::asio::io_context io_context;
boost::asio::steady_timer timer(io_context, 3s);
timer.wait();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     When calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      timer.wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     , the request is sent to the I/O execution context object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     ), which calls the OS to perform the operation.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     Once the OS finishes with the task, it returns the result to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     , which then translates the result, or an error if anything went wrong, back to the I/O object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.398.2">
     Errors are of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.399.1">
      boost::system::error_code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     .
    </span>
    <span class="koboSpan" id="kobo.400.2">
     If an error occurs, an exception
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.401.1">
      is thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     If we don’t want exceptions to be thrown, we can pass an error object by reference to the synchronous method to capture the status of the operation and check
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      it afterward:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.404.1">
boost::system::error_code ec;
Timer.wait(server_endpoint, ec);</span></pre>
   <h2 id="_idParaDest-194">
    <a id="_idTextAnchor193">
    </a>
    <span class="koboSpan" id="kobo.405.1">
     Asynchronous operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     In the case
    </span>
    <a id="_idIndexMarker665">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     of asynchronous
    </span>
    <a id="_idIndexMarker666">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     operations, we need to also pass a completion handler to the asynchronous method.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     This completion handler is a callable object that will be invoked by the I/O context object when the asynchronous operation finishes, notifying the program about the result or operation error.
    </span>
    <span class="koboSpan" id="kobo.408.3">
     Its signature is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.410.1">
void completion_handler(
     const boost::system::error_code&amp; ec);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     Continuing with the timer example, now, we need to call the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      asynchronous operation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.413.1">
socket.async_wait(completion_handler);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     Again, the I/O object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.415.1">
      timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     ) forwards the request to the I/O execution context object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.417.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.418.1">
     ).
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.419.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     requests to the OS to start the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.421.1">
      asynchronous operation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.422.1">
     When the operation is finished, the OS places the result in a queue, where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.423.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.424.1">
     is listening.
    </span>
    <span class="koboSpan" id="kobo.424.2">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     dequeues the result, translates the error into an error code object, and triggers the completion handler to notify the program about the completion of the task and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.428.1">
     To allow
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.429.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.430.1">
     to follow these steps, the program must execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      boost::asio::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     (or similar functions introduced earlier that manage the event processing loop) and block the current thread while processing any unfinished asynchronous operation.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     As already commented, if there are no pending asynchronous operations,
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.433.1">
       boost::asio::io_context::run()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      exits.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     Completion handlers are required to be copy-constructible, meaning that a copy-constructor must be available.
    </span>
    <span class="koboSpan" id="kobo.435.2">
     If a temporary resource is needed (such as memory, thread, or file descriptor), this resource is released before calling the completion handler.
    </span>
    <span class="koboSpan" id="kobo.435.3">
     That allows
    </span>
    <a id="_idIndexMarker667">
    </a>
    <span class="koboSpan" id="kobo.436.1">
     us to call
    </span>
    <a id="_idIndexMarker668">
    </a>
    <span class="koboSpan" id="kobo.437.1">
     the same operation without overlapping resource usage, avoiding increasing the peak resource usage in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      the system.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.439.1">
     Error handling
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     As mentioned
    </span>
    <a id="_idIndexMarker669">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     previously,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.442.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     allows users to handle errors in two different ways: by using error codes or throwing exceptions.
    </span>
    <span class="koboSpan" id="kobo.443.2">
     If we pass a reference to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.444.1">
      boost::system::error_code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.445.1">
     object when calling an I/O object method, the implementation will pass errors through that variable; otherwise, an exception will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      be thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     We already implemented some examples following the first approach by checking the error codes.
    </span>
    <span class="koboSpan" id="kobo.447.2">
     Let’s now see how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      catch exceptions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.449.1">
     The following example creates a timer with an expiration period of three seconds.
    </span>
    <span class="koboSpan" id="kobo.449.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.450.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.451.1">
     object is running from the background thread,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.452.1">
      io_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.453.1">
     .
    </span>
    <span class="koboSpan" id="kobo.453.2">
     When the timer starts the asynchronous task by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     function, it passes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.456.1">
      boost::asio::use_future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.457.1">
     argument so the function returns a future object,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.458.1">
      fut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     , that later is used inside a try-catch block to call its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.460.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.461.1">
     function and retrieve the stored result or exception, as we learned in
    </span>
    <a href="B22219_06.xhtml#_idTextAnchor125">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.462.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.463.1">
     .
    </span>
    <span class="koboSpan" id="kobo.463.2">
     After starting the asynchronous operation, the main thread waits for one second and the timer cancels the operation by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      cancel()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.465.2">
     As this happens before its expiration time (three seconds), an exception
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.466.1">
      is thrown:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.467.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 1s);
    auto fut = timer.async_wait(
                     boost::asio::use_future);
    std::thread io_thread([&amp;io_context]() {
                        io_context.run();
    });
    std::this_thread::sleep_for(3s);
    timer.cancel();
    try {
        fut.get();
        std::cout &lt;&lt; "Timer expired successfully!\n";
    } catch (const boost::system::system_error&amp; e) {
        std::cout &lt;&lt; "Timer failed: "
                  &lt;&lt; e.code().message() &lt;&lt; '\n';
    }
    io_thread.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.468.1">
     The exception of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      boost::system::system_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     is caught, and its message is printed.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     If the timer cancels its operation after the asynchronous operation completes (in this example, by sleeping the main thread for more than three seconds), the timer expires successfully, and no exception
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      is thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.472.1">
     Now that we have
    </span>
    <a id="_idIndexMarker670">
    </a>
    <span class="koboSpan" id="kobo.473.1">
     seen the main building blocks of Boost.Asio and how they interact together, let’s recap and understand the design patterns behind
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.474.1">
      its implementation.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-195">
    <a id="_idTextAnchor194">
    </a>
    <span class="koboSpan" id="kobo.475.1">
     The Reactor and Proactor design patterns
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.476.1">
     When using event
    </span>
    <a id="_idIndexMarker671">
    </a>
    <span class="koboSpan" id="kobo.477.1">
     handling
    </span>
    <a id="_idIndexMarker672">
    </a>
    <span class="koboSpan" id="kobo.478.1">
     applications, we can follow two approaches to designing the concurrent solution: the Reactor and Proactor
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.479.1">
      design patterns.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.480.1">
     These patterns describe the mechanisms followed to process events, indicating how these are initiated, received, demultiplexed, and dispatched.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     As the system collects and queues the I/O events coming from different resources, demultiplexing these events means separating them to be dispatched to their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.481.1">
      correct handlers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.483.1">
      Reactor pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     demultiplexes and dispatches synchronously and serially service requests.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     It usually follows a non-blocking synchronous I/O strategy, returning the result if the operation can be executed, or an error if the system has no resources to complete
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.485.1">
      the operation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.486.1">
     On the other hand, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.487.1">
      Proactor pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     allows demultiplexing and dispatching service requests in an efficient asynchronous way by immediately returning the control to the caller, indicating that the operation has been initiated.
    </span>
    <span class="koboSpan" id="kobo.488.2">
     Then, the called system will notify the caller when the operation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.489.1">
      is complete.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.490.1">
     Thus, the Proactor pattern distributes responsibilities among two tasks: the long-duration operations that are executed asynchronously and the completion handlers that process the results
    </span>
    <a id="_idIndexMarker673">
    </a>
    <span class="koboSpan" id="kobo.491.1">
     and
    </span>
    <a id="_idIndexMarker674">
    </a>
    <span class="koboSpan" id="kobo.492.1">
     usually invoke other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      asynchronous operations.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.494.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     implements the Proactor design pattern by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      following elements:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.497.1">
       Initiator
      </span>
     </strong>
     <span class="koboSpan" id="kobo.498.1">
      : An I/O object that initiates the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.499.1">
       asynchronous operation.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.500.1">
       Asynchronous operation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.501.1">
      : A task to run asynchronously by
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       the OS.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.503.1">
       Asynchronous operation processor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.504.1">
      : This executes the asynchronous operation and queues results in the completion
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.505.1">
       event queue.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.506.1">
       Completion event queue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.507.1">
      : An event queue where the asynchronous operation processor pushes events, and the asynchronous event
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.508.1">
       dequeues them.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.509.1">
       Asynchronous event demultiplexer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.510.1">
      : This blocks the I/O context, waiting for events, and returning completed events to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.511.1">
       the caller.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.512.1">
       Completion handler
      </span>
     </strong>
     <span class="koboSpan" id="kobo.513.1">
      : A callable object that will process the results of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.514.1">
       asynchronous operation.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.515.1">
       Proactor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.516.1">
      : This calls the asynchronous event demultiplexer to dequeue events and dispatch them to the completion handler.
     </span>
     <span class="koboSpan" id="kobo.516.2">
      This is what the I/O execution
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.517.1">
       context does.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.518.1">
       Figure 9
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.519.1">
      .3
     </span>
    </em>
    <span class="koboSpan" id="kobo.520.1">
     clearly shows the relationship between all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      these elements:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.522.1">
      <img alt="Figure 9.3 – Proactor design pattern" src="image/B22219_09_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.523.1">
     Figure 9.3 – Proactor design pattern
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.524.1">
     The Proactor pattern increases the separation of concerns at the same time as encapsulating concurrency mechanisms, simplifying application synchronization, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      increasing performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     On the other hand, we have no control over how or when the asynchronous operations are scheduled or how efficiently the OS will perform these operations.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     Also, there is an increase in memory usage due
    </span>
    <a id="_idIndexMarker675">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     to
    </span>
    <a id="_idIndexMarker676">
    </a>
    <span class="koboSpan" id="kobo.528.1">
     the completion event queue and increased complexity in debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      and testing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.530.1">
     Another aspect of the design of Boost.Asio is the thread safety of the execution context objects.
    </span>
    <span class="koboSpan" id="kobo.530.2">
     Let’s now dig into how threading works
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      with Boost.Asio.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-196">
    <a id="_idTextAnchor195">
    </a>
    <span class="koboSpan" id="kobo.532.1">
     Threading with Boost.Asio
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     I/O execution context
    </span>
    <a id="_idIndexMarker677">
    </a>
    <span class="koboSpan" id="kobo.534.1">
     objects are thread-safe; their methods can be called from different threads safely.
    </span>
    <span class="koboSpan" id="kobo.534.2">
     That means that we can use a separate thread to run the blocking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.535.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     method and leave the main thread unblocked to carry on with other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      unrelated tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.538.1">
     Let’s now explain the different ways to configure the asynchronous application in terms of how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.539.1">
      use threads.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-197">
    <a id="_idTextAnchor196">
    </a>
    <span class="koboSpan" id="kobo.540.1">
     Single-threaded approach
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     The starting point
    </span>
    <a id="_idIndexMarker678">
    </a>
    <span class="koboSpan" id="kobo.542.1">
     and preferred solution for any
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.543.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.544.1">
     application should follow a single-threaded approach where the I/O execution context object runs in the same thread where the completion handlers are being processed.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     These handlers must be short and non-blocking.
    </span>
    <span class="koboSpan" id="kobo.544.3">
     Here is an example of a steady timer completion handler running in the same thread as the I/O context, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.545.1">
      main thread:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.546.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
using namespace std::chrono_literals;
void handle_timer_expiry(
            const boost::system::error_code&amp; ec) {
    if (!ec) {
        std::cout &lt;&lt; "Timer expired!\n";
    } else {
        std::cerr &lt;&lt; "Error in timer: "
                  &lt;&lt; ec.message() &lt;&lt; std::endl;
    }
}
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context,
                              std::chrono::seconds(1));
    timer.async_wait(&amp;handle_timer_expiry);
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     As we can see, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      steady_timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     timer calls the asynchronous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     function, setting up the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      handle_timer_expiry()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     completion handler, in the same thread that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     function is being executed in.
    </span>
    <span class="koboSpan" id="kobo.555.2">
     When the asynchronous function finishes, its completion handler will run in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      same thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     As the completion handler is running in the main thread, its execution should be quick to avoid freezing the main thread and other relevant tasks that the program should perform.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     In the next section, we will learn how to deal with long-running tasks or completion handlers
    </span>
    <a id="_idIndexMarker679">
    </a>
    <span class="koboSpan" id="kobo.558.1">
     and keep the main
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.559.1">
      thread responsive.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-198">
    <a id="_idTextAnchor197">
    </a>
    <span class="koboSpan" id="kobo.560.1">
     Threaded long-running tasks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     For long-running tasks, we
    </span>
    <a id="_idIndexMarker680">
    </a>
    <span class="koboSpan" id="kobo.562.1">
     can keep the logic in the main thread but use other threads to pass work and get results back to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.563.1">
      main thread:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.564.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
void long_running_task(boost::asio::io_context&amp; io_context,
                       int task_duration) {
    std::cout &lt;&lt; "Background task started: Duration = "
              &lt;&lt; task_duration &lt;&lt; " seconds.\n";
    std::this_thread::sleep_for(
                      std::chrono::seconds(task_duration));
    io_context.post([&amp;io_context]() {
        std::cout &lt;&lt; "Background task completed.\n";
        io_context.stop();
    });
}
int main() {
    boost::asio::io_context io_context;
    auto work_guard = boost::asio::make_work_guard
                                        (io_context);
    io_context.post([&amp;io_context]() {
        std::thread t(long_running_task,
                      std::ref(io_context), 2);
        std::cout &lt;&lt; "Detaching thread" &lt;&lt; std::endl;
        t.detach();
    });
    std::cout &lt;&lt; "Running io_context...\n";
    io_context.run();
    std::cout &lt;&lt; "io_context exit.\n";
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.565.1">
     In this example, after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     is created, a work guard is used to avoid the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.568.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.569.1">
     function
    </span>
    <a id="_idIndexMarker681">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     to immediately return before any work
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.571.1">
      is posted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.572.1">
     The posted work consists of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.573.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.574.1">
     thread being created to run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.575.1">
      long_running_task()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.576.1">
     function in the background.
    </span>
    <span class="koboSpan" id="kobo.576.2">
     That
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.577.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     thread is detached before the lambda function exits; otherwise, the program
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.579.1">
      would terminate.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     In the background task function, the current thread sleeps for a given period and then posts another task into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.581.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     object to print a message and stop
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.583.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.584.1">
     itself.
    </span>
    <span class="koboSpan" id="kobo.584.2">
     If we don’t call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.585.1">
      io_context.stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.586.1">
     , the event processing loop will continue running forever and the program will not finish, as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.587.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.588.1">
     will
    </span>
    <a id="_idIndexMarker682">
    </a>
    <span class="koboSpan" id="kobo.589.1">
     continue blocking due to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.590.1">
      work guard.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-199">
    <a id="_idTextAnchor198">
    </a>
    <span class="koboSpan" id="kobo.591.1">
     Multiple I/O execution context objects, one per thread
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.592.1">
     This approach is like the
    </span>
    <a id="_idIndexMarker683">
    </a>
    <span class="koboSpan" id="kobo.593.1">
     single-threaded one, where each thread has its own
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.594.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.595.1">
     object and processes short and non-blocking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      completion handlers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.597.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
void background_task(int i) {
    sync_cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; ": Starting...\n";
    boost::asio::io_context io_context;
    auto work_guard =
              boost::asio::make_work_guard(io_context);
    sync_cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; ": Setup timer...\n";
    boost::asio::steady_timer timer(io_context, 1s);
    timer.async_wait(
        [&amp;](const boost::system::error_code&amp; ec) {
            if (!ec) {
                sync_cout &lt;&lt; "Timer expired successfully!"
</span><span class="koboSpan" id="kobo.597.2">                          &lt;&lt; std::endl;
            } else {
                sync_cout &lt;&lt; "Timer error: "
                          &lt;&lt; ec.message() &lt;&lt; ‚\n';
        }
        work_guard.reset();
    });
    sync_cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; ": Running
                      io_context...\n";
    io_context.run();
}
int main() {
    const int num_threads = 4;
    std::vector&lt;std::jthread&gt; threads;
    for (auto i = 0; i &lt; num_threads; ++i) {
        threads.emplace_back(background_task, i);
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.598.1">
     In this example, four threads are created, each one running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.599.1">
      background_task()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     function where an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     object is created, and a timer is set up
    </span>
    <a id="_idIndexMarker684">
    </a>
    <span class="koboSpan" id="kobo.603.1">
     to timeout after one second together with its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.604.1">
      completion handler.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-200">
    <a id="_idTextAnchor199">
    </a>
    <span class="koboSpan" id="kobo.605.1">
     Multiple threads with a single I/O execution context object
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.606.1">
     Now, there is
    </span>
    <a id="_idIndexMarker685">
    </a>
    <span class="koboSpan" id="kobo.607.1">
     only one
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.608.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.609.1">
     object but it is starting the asynchronous tasks from different I/O objects from different threads.
    </span>
    <span class="koboSpan" id="kobo.609.2">
     In this case, the completion handlers can be called from any of those threads.
    </span>
    <span class="koboSpan" id="kobo.609.3">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.610.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.611.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
void background_task(int task_id) {
    boost::asio::post([task_id]() {
        sync_cout &lt;&lt; "Task " &lt;&lt; task_id
                  &lt;&lt; " is being handled in thread "
                  &lt;&lt; std::this_thread::get_id()
                  &lt;&lt; std::endl;
        std::this_thread::sleep_for(2s);
        sync_cout &lt;&lt; "Task " &lt;&lt; task_id
                  &lt;&lt; " complete.\n";
    });
}
int main() {
    boost::asio::io_context io_context;
    auto work_guard = boost::asio::make_work_guard(
                                   io_context);
    std::jthread io_context_thread([&amp;io_context]() {
        io_context.run();
    });
    const int num_threads = 4;
    std::vector&lt;std::jthread&gt; threads;
    for (int i = 0; i &lt; num_threads; ++i) {
        background_task(i);
    }
    std::this_thread::sleep_for(5s);
    work_guard.reset();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.612.1">
     In this example, only
    </span>
    <a id="_idIndexMarker686">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     one
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.614.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.615.1">
     object is created and run in a separate thread,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.616.1">
      io_context_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.617.1">
     .
    </span>
    <span class="koboSpan" id="kobo.617.2">
     Then, an additional four background threads are created, where work is posted into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.618.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.619.2">
     Finally, the main thread waits for five seconds to let all threads finish their work and resets the work guard, letting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.620.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     function return if there is no more pending work.
    </span>
    <span class="koboSpan" id="kobo.621.2">
     When the program exits, all
    </span>
    <a id="_idIndexMarker687">
    </a>
    <span class="koboSpan" id="kobo.622.1">
     threads automatically join, as they are instances
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.623.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.624.1">
       std::jthread
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-201">
    <a id="_idTextAnchor200">
    </a>
    <span class="koboSpan" id="kobo.626.1">
     Parallelizing work done by one I/O execution context
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.627.1">
     In the previous
    </span>
    <a id="_idIndexMarker688">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     example, a unique I/O execution context object was used with its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     function being called from different threads.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     Then, each thread posted some work that completion handlers were executing in available threads at the time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      of completion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     This is a common way to parallelize work done by one I/O execution context, by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.633.1">
      run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.634.1">
     function from multiple threads, distributing the processing of asynchronous operations across those threads.
    </span>
    <span class="koboSpan" id="kobo.634.2">
     This is possible because the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.635.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.636.1">
     object provides a thread-safe event
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      dispatching system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     Here is another example where a pool of threads is created, with each thread running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     , making these threads compete to pull tasks from the queue and execute them.
    </span>
    <span class="koboSpan" id="kobo.640.2">
     In this case, only one asynchronous task is created using a timer that expires in two seconds.
    </span>
    <span class="koboSpan" id="kobo.640.3">
     One of the threads will pick up the task and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.641.1">
      execute it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.642.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std::chrono_literals;
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 2s);
    timer.async_wait(
        [](const boost::system::error_code&amp; /*ec*/) {
            std::cout &lt;&lt; "Timer expired!\n";
    });
    const std::size_t num_threads =
                std::thread::hardware_concurrency();
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0;
         i &lt; std::thread::hardware_concurrency(); ++i) {
            threads.emplace_back([&amp;io_context]() {
                io_context.run();
            });
    }
    for (auto&amp; t : threads) {
        t.join();
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     This technique
    </span>
    <a id="_idIndexMarker689">
    </a>
    <span class="koboSpan" id="kobo.644.1">
     improves scalability, as the application better utilizes multiple cores, and reduces latency by handling asynchronous tasks concurrently.
    </span>
    <span class="koboSpan" id="kobo.644.2">
     Also, contention can be reduced and throughput increased by reducing bottlenecks generated when single-threaded code processes many simultaneous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      I/O operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.646.1">
     Note that the completion handlers also must use synchronization primitives and be thread-safe if they are shared across different threads or modify
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.647.1">
      shared resources.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.648.1">
     Also, there is no guarantee in the order the completion handlers will be executed.
    </span>
    <span class="koboSpan" id="kobo.648.2">
     As many threads can run simultaneously, any of them can complete earlier and call its associated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.649.1">
      completion handler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     As threads are competing to pull tasks from the queue, there might be potential lock contention or context-switching overhead if the thread pool size is not optimal, ideally matching the number of hardware threads, as done in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      this example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     Now, it’s time to
    </span>
    <a id="_idIndexMarker690">
    </a>
    <span class="koboSpan" id="kobo.653.1">
     understand how the objects’ lifetime can affect the stability of our asynchronous programs developed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.654.1">
      with Boost.Asio.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-202">
    <a id="_idTextAnchor201">
    </a>
    <span class="koboSpan" id="kobo.655.1">
     Managing objects’ lifetime
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     One of the main
    </span>
    <a id="_idIndexMarker691">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     disastrous issues that can happen with asynchronous operations is that, when the operation takes place, some of the required objects have been destroyed.
    </span>
    <span class="koboSpan" id="kobo.657.2">
     Therefore, managing objects’ lifetimes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      is crucial.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.659.1">
     In C++, an object’s lifetime begins when the constructor ends and ends when the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.660.1">
      destructor begins.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.661.1">
     A common pattern used to keep objects alive is to let the object create a shared pointer instance to itself, ensuring that the object remains valid as long as there are shared pointers pointing to it, meaning that there are ongoing asynchronous operations needing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.662.1">
      that object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.663.1">
     This technique is called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.664.1">
      shared-from-this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.665.1">
     and uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.666.1">
      std::enable_shared_from_this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.667.1">
     template base class, available since C++11, which provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.668.1">
      shared_from_this()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.669.1">
     method used by the object to obtain a shared pointer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.670.1">
      to itself.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-203">
    <a id="_idTextAnchor202">
    </a>
    <span class="koboSpan" id="kobo.671.1">
     Implementing an echo server – an example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.672.1">
     Let’s see how it works by
    </span>
    <a id="_idIndexMarker692">
    </a>
    <span class="koboSpan" id="kobo.673.1">
     creating an echo server.
    </span>
    <span class="koboSpan" id="kobo.673.2">
     At the same time, we will be discussing this technique, we will also be learning about how to use Boost.Asio
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.674.1">
      for networking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     Transmission of data over a network can take a long time to complete, and several errors can occur.
    </span>
    <span class="koboSpan" id="kobo.675.2">
     That makes network I/O services a special good case to be dealt with by Boost.Asio.
    </span>
    <span class="koboSpan" id="kobo.675.3">
     Network I/O services were the first services to be included in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      the library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     The main common usage of Boost.Asio in the industry is to develop networking applications due to its support for the internet protocols TCP, UDP, and ICMP.
    </span>
    <span class="koboSpan" id="kobo.677.2">
     The library also provides a socket interface based on the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.678.1">
      Berkeley Software Distribution
     </span>
    </strong>
    <span class="koboSpan" id="kobo.679.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.680.1">
      BSD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.681.1">
     ) socket API to
    </span>
    <a id="_idIndexMarker693">
    </a>
    <span class="koboSpan" id="kobo.682.1">
     allow the development of efficient and scalable applications using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      low-level interface.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.684.1">
     However, as, in this book, we are interested in asynchronous programming, let’s focus on implementing an echo server using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      high-level interface.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     An echo server is a program that listens to a specific address and port and writes back everything that it reads from that port.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     For that purpose, we will create a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.687.1">
      TCP server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.688.1">
     The main program will simply create an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     object, set up the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.691.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.692.1">
     object by passing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.693.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.694.1">
     object and a port number to listen from, and call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.695.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.696.1">
     to start
    </span>
    <a id="_idIndexMarker694">
    </a>
    <span class="koboSpan" id="kobo.697.1">
     the event
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.698.1">
      processing loop:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.699.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;memory&gt;
constexpr int port = 1234;
int main() {
    try {
        boost::asio::io_context io_context;
        EchoServer server(io_context, port);
        io_context.run();
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n";
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.700.1">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.701.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.702.1">
     initializes, it will start listening for incoming connections.
    </span>
    <span class="koboSpan" id="kobo.702.2">
     It does that by using a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.703.1">
      boost::asio::tcp::acceptor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.704.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.704.2">
     This object accepts via its constructor an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.705.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     object (as usual for I/O objects) and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.707.1">
      boost::asio::tcp::endpoint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.708.1">
     object, which indicates the connection protocol and port number used for listening.
    </span>
    <span class="koboSpan" id="kobo.708.2">
     As a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.709.1">
      boost::asio::tcp::v4()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.710.1">
     object is used to initialize the endpoint object, the protocol that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.711.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.712.1">
     will use is IPv4.
    </span>
    <span class="koboSpan" id="kobo.712.2">
     The IP address is not specified to the endpoint constructor, therefore the endpoint IP address will be
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.713.1">
      any address
     </span>
    </em>
    <span class="koboSpan" id="kobo.714.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      INADDR_ANY
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     for IPv4 or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      in6addr_any
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     for IPv6).
    </span>
    <span class="koboSpan" id="kobo.718.2">
     Next, the code implementing
    </span>
    <a id="_idIndexMarker695">
    </a>
    <span class="koboSpan" id="kobo.719.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.720.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.721.1">
     constructor is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.722.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.723.1">
using boost::asio::ip::tcp;
class EchoServer {
   public:
    EchoServer(boost::asio::io_context&amp; io_context,
               short port)
        : acceptor_(io_context,
                    tcp::endpoint(tcp::v4(),
                    port)) {
        do_accept();
    }
   private:
    void do_accept() {
        acceptor_.async_accept([this](
                    boost::system::error_code ec,
                    tcp::socket socket) {
            if (!ec) {
                std::make_shared&lt;Session&gt;(
                    std::move(socket))-&gt;start();
            }
            do_accept();
        });
    }
    tcp::acceptor acceptor_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.724.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.725.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.726.1">
     constructor calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.727.1">
      do_accept()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     function after setting up the acceptor object.
    </span>
    <span class="koboSpan" id="kobo.728.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      do_accept()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     function calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.731.1">
      async_accept()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.732.1">
     function waiting for incoming connections.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     When a client connects to the server, the OS returns the connection’s socket (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.733.1">
      boost::asio::tcp::socket
     </span>
    </strong>
    <span class="koboSpan" id="kobo.734.1">
     ) or an error via the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.735.1">
       io_context
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.736.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     If there is no error and a connection is established, a shared pointer of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     object is created, moving the socket into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.740.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.741.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.741.2">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     object runs the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.744.1">
       start()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.745.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.746.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.747.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.748.1">
     object
    </span>
    <a id="_idIndexMarker696">
    </a>
    <span class="koboSpan" id="kobo.749.1">
     encapsulates the state of a particular connection, in this case, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      socket_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     object and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.752.1">
      data_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.753.1">
     buffer.
    </span>
    <span class="koboSpan" id="kobo.753.2">
     It also manages asynchronous reads and writes into that buffer by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.754.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.755.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      do_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     , which we will implement in a moment.
    </span>
    <span class="koboSpan" id="kobo.757.2">
     But before this, comment that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.758.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     inherits from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      std::enable_shared_from_this&lt;Session&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     , allowing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     objects to create shared pointers to themselves, ensuring that the session objects remain alive throughout the lifetime of asynchronous operations needing them, as long as there is at least one shared pointer pointing to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.764.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.765.1">
     instance managing that connection.
    </span>
    <span class="koboSpan" id="kobo.765.2">
     This shared pointer is the one created in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      do_accept()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     function in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     object when the connection was established.
    </span>
    <span class="koboSpan" id="kobo.769.2">
     Here is the implementation of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.770.1">
       Session
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.771.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.772.1">
class Session
    : public std::enable_shared_from_this&lt;Session&gt;
{
   public:
    Session(tcp::socket socket)
        : socket_(std::move(socket)) {}
    void start() { do_read(); }
   private:
    static const size_t max_length = 1024;
    void do_read();
    void do_write(std::size_t length);
    tcp::socket socket_;
    char data_[max_length];
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.773.1">
     Using a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     class allows us to separate the logic that manages the connection from the one that manages the server.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.776.1">
      EchoServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.777.1">
     just needs to accept connections and create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     object per connection.
    </span>
    <span class="koboSpan" id="kobo.779.2">
     That way, a server can manage multiple clients, keeping their connections independent and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.780.1">
      asynchronously managed.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     is the one that
    </span>
    <a id="_idIndexMarker697">
    </a>
    <span class="koboSpan" id="kobo.783.1">
     manages the behavior of that connection using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      do_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     functions.
    </span>
    <span class="koboSpan" id="kobo.787.2">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.788.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.789.1">
     starts, its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.790.1">
      start()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     function calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     function, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.794.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.795.1">
void Session::do_read() {
    auto self(shared_from_this());
    socket_.async_read_some(boost::asio::buffer(data_,
                                          max_length),
        [this, self](boost::system::error_code ec,
                     std::size_t length) {
            if (!ec) {
                do_write(length);
            }
        });
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.796.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     function creates a shared pointer to the current session object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      self
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     ) and uses the socket’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      async_read_some()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     asynchronous function to read some data into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.803.1">
      data_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.804.1">
     buffer.
    </span>
    <span class="koboSpan" id="kobo.804.2">
     If successful, this operation returns the data copied into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.805.1">
      data_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.806.1">
     buffer and the number of read bytes in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.807.1">
       length
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.808.1">
      variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.809.1">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.810.1">
      do_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.811.1">
     is called with that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.812.1">
      length
     </span>
    </strong>
    <span class="koboSpan" id="kobo.813.1">
     variable, asynchronously writing the content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.814.1">
      data_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     buffer into the socket by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.816.1">
      async_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.817.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.817.2">
     When this asynchronous operation succeeds, it restarts the cycle by calling again the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.818.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.819.1">
     function, as
    </span>
    <a id="_idIndexMarker698">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.820.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.821.1">
void Session::do_write(std::size_t length) {
    auto self(shared_from_this());
    boost::asio::async_write(socket_,
                             boost::asio::buffer(data_,
                                                length),
        [this, self](boost::system::error_code ec,
                     std::size_t length) {
            if (!ec) {
                do_read();
            }
        });
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.822.1">
     You might wonder why it is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.823.1">
      self
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     is defined but is not being used.
    </span>
    <span class="koboSpan" id="kobo.824.2">
     It looks like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.825.1">
      self
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     is redundant, but as the lambda function is capturing it by value, a copy is being created, increasing the reference count of the shared pointer to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.827.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.828.1">
     object, ensuring that the session will not be destroyed if the lambda is active.
    </span>
    <span class="koboSpan" id="kobo.828.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.829.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.830.1">
     object is captured to provide access to its members into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.831.1">
      lambda function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.832.1">
     As an exercise, try to implement a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.833.1">
      stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.834.1">
     function that breaks the cycle between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.835.1">
      do_read()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.836.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.837.1">
      do_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     .
    </span>
    <span class="koboSpan" id="kobo.838.2">
     Once all asynchronous operations are complete and the lambda functions exit, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.839.1">
      self
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     objects will be destroyed and there will be no other shared pointers pointing to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.841.1">
      Session
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     object, thus the session will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.843.1">
      be destroyed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.844.1">
     This pattern ensures robust and safe management of objects’ lifetimes during asynchronous operations, avoiding dangling pointers or early destruction, which would lead to undesired behavior
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.845.1">
      or crashes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.846.1">
     To test this server, just start the server, open a new terminal, and use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.847.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     command to connect to the server and send data to it.
    </span>
    <span class="koboSpan" id="kobo.848.2">
     As arguments, we can pass the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.849.1">
      localhost
     </span>
    </strong>
    <span class="koboSpan" id="kobo.850.1">
     address, indicating that we are connecting to a server running on the same machine (IP address of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.851.1">
      127.0.0.1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.852.1">
     ) and the port, in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      case,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.854.1">
       1234
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.855.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.856.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     command will start and show some information about the connection and indicate that we need to hit the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.859.1">
      Ctrl
     </span>
    </em>
    <span class="koboSpan" id="kobo.860.1">
     +
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.861.1">
      }
     </span>
    </em>
    <span class="koboSpan" id="kobo.862.1">
     keys to close
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.863.1">
      the connection.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.864.1">
     Typing anything and hitting the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.865.1">
      Enter
     </span>
    </em>
    <span class="koboSpan" id="kobo.866.1">
     key will send that entered line to the echo server, which will listen and send
    </span>
    <a id="_idIndexMarker699">
    </a>
    <span class="koboSpan" id="kobo.867.1">
     back the same content; in this example, it will be
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.868.1">
       Hello world!
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.869.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.870.1">
     Just close the connection and exit
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.871.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.872.1">
     by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.873.1">
      quit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.874.1">
     command to exit back to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.875.1">
      the terminal:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.876.1">
$ telnet localhost 1234
Trying 127.0.0.1...
</span><span class="koboSpan" id="kobo.876.2">Connected to localhost.
</span><span class="koboSpan" id="kobo.876.3">Escape character is '^]'.
</span><span class="koboSpan" id="kobo.876.4">Hello world!
</span><span class="koboSpan" id="kobo.876.5">Hello world!
</span><span class="koboSpan" id="kobo.876.6">telnet&gt; quit
Connection closed.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.877.1">
     In this example, we have
    </span>
    <a id="_idIndexMarker700">
    </a>
    <span class="koboSpan" id="kobo.878.1">
     already used a buffer.
    </span>
    <span class="koboSpan" id="kobo.878.2">
     Let’s learn a bit more about them in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.879.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-204">
    <a id="_idTextAnchor203">
    </a>
    <span class="koboSpan" id="kobo.880.1">
     Transferring data using buffers
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.881.1">
      Buffers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.882.1">
     are contiguous
    </span>
    <a id="_idIndexMarker701">
    </a>
    <span class="koboSpan" id="kobo.883.1">
     regions of memory used during I/O operations to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      transfer data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.885.1">
     Boost.Asio defines two types of
    </span>
    <a id="_idIndexMarker702">
    </a>
    <span class="koboSpan" id="kobo.886.1">
     buffers:
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.887.1">
      mutable buffers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.888.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.889.1">
      boost::asio::mutable_buffer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.890.1">
     ), where data can be written, and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.891.1">
      constant buffers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.892.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.893.1">
      boost::asio::const_buffers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.894.1">
     ), which
    </span>
    <a id="_idIndexMarker703">
    </a>
    <span class="koboSpan" id="kobo.895.1">
     are used to create read-only buffers.
    </span>
    <span class="koboSpan" id="kobo.895.2">
     Mutable buffers can be converted into constant buffers, but not the opposite.
    </span>
    <span class="koboSpan" id="kobo.895.3">
     Both types of buffers provide protection
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.896.1">
      against overruns.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.897.1">
     There is also the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      boost::buffer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     function to help with the creation of mutable or constant buffers from different data types (a pointer to raw memory and size, a string (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.900.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.901.1">
     ), or an array or vector
    </span>
    <a id="_idIndexMarker704">
    </a>
    <span class="koboSpan" id="kobo.902.1">
     of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.903.1">
      plain old data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.904.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.905.1">
      POD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.906.1">
     ) structures (meaning a type, a structure, or a class that has no user-defined copy assignment operator or destructor, and without private or protected non-static data members).
    </span>
    <span class="koboSpan" id="kobo.906.2">
     For example, to create a buffer from an array of chars, we can use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.907.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.908.1">
char data[1024];
mutable_buffer buffer = buffer(data, sizeof(data));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.909.1">
     Also, note that the buffer’s ownership and lifetime are the responsibility of the program, not the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.910.1">
      Boost.Asio library.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-205">
    <a id="_idTextAnchor204">
    </a>
    <span class="koboSpan" id="kobo.911.1">
     Scatter-gather operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.912.1">
     Buffers can be used
    </span>
    <a id="_idIndexMarker705">
    </a>
    <span class="koboSpan" id="kobo.913.1">
     efficiently by using scatter-gather
    </span>
    <a id="_idIndexMarker706">
    </a>
    <span class="koboSpan" id="kobo.914.1">
     operations where multiple buffers are used together to receive data (scatter-read) or to send
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.915.1">
      data (gather-write).
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.916.1">
      Scatter-read
     </span>
    </strong>
    <span class="koboSpan" id="kobo.917.1">
     is the process of reading data from a unique source into different non-contiguous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.918.1">
      memory buffers.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.919.1">
      Gather-write
     </span>
    </strong>
    <span class="koboSpan" id="kobo.920.1">
     is the opposite
    </span>
    <a id="_idIndexMarker707">
    </a>
    <span class="koboSpan" id="kobo.921.1">
     process; data is gathered from different non-contiguous memory buffers and written into a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.922.1">
      single destination.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.923.1">
     These techniques increase efficiency and performance as they reduce the number of system calls or data copying.
    </span>
    <span class="koboSpan" id="kobo.923.2">
     They are not only used for I/O operations but also in other use cases, such as data processing, machine learning, or parallel algorithms, such as sorting or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.924.1">
      matrix multiplication.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.925.1">
     To allow scatter-gather operations, several buffers can be passed together to the asynchronous operation inside a container (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.926.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.927.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.928.1">
      std::list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.929.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.930.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.931.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.932.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.933.1">
       boost::array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.935.1">
     Here is an example of scatter-read where a socket reads some data asynchronously into both the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.936.1">
      buf1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.937.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.938.1">
       buf2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.939.1">
      buffers:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.940.1">
std::array&lt;char, 128&gt; buf1, buf2;
std::vector&lt;boost::asio::mutable_buffer&gt; buffers = {
    boost::asio::buffer(buf1),
    boost::asio::buffer(buf2)
};
socket.async_read_some(buffers, handler);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.941.1">
     Here is how to achieve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.942.1">
      a gather-read:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.943.1">
std::array&lt;char, 128&gt; buf1, buf2;
std::vector&lt;boost::asio::const_buffer&gt; buffers = {
    boost::asio::buffer(buf1),
    boost::asio::buffer(buf2)
};
socket.async_write_some(buffers, handler);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.944.1">
     Now, the socket
    </span>
    <a id="_idIndexMarker708">
    </a>
    <span class="koboSpan" id="kobo.945.1">
     does the opposite operation, writing
    </span>
    <a id="_idIndexMarker709">
    </a>
    <span class="koboSpan" id="kobo.946.1">
     some data from both buffers into the socket buffer for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.947.1">
      asynchronous sending.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-206">
    <a id="_idTextAnchor205">
    </a>
    <span class="koboSpan" id="kobo.948.1">
     Stream buffers
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.949.1">
     We can also use
    </span>
    <a id="_idIndexMarker710">
    </a>
    <span class="koboSpan" id="kobo.950.1">
     stream buffers to manage data.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.951.1">
      Stream buffers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.952.1">
     are
    </span>
    <a id="_idIndexMarker711">
    </a>
    <span class="koboSpan" id="kobo.953.1">
     defined by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.954.1">
      boost::asio::basic_streambuf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.955.1">
     class, based in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.956.1">
      std::basic_streambuf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.957.1">
     C++ class and defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.958.1">
      &lt;streambuf&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.959.1">
     header file.
    </span>
    <span class="koboSpan" id="kobo.959.2">
     It allows a dynamic buffer where its size can adapt to the amount of data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.960.1">
      being transferred.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.961.1">
     Let’s see in the following example how stream buffers work together with scatter-gather operations.
    </span>
    <span class="koboSpan" id="kobo.961.2">
     In this case, we are implementing a TCP server that listens and accepts clients’ connections from a given port, reads the messages sent by the clients into two stream buffers, and prints their content to the console.
    </span>
    <span class="koboSpan" id="kobo.961.3">
     As we are interested in understanding stream buffers and scatter-gather operations, let’s simplify the example by using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.962.1">
      synchronous operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.963.1">
     As in the previous example, in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.964.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.965.1">
     function, we use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.966.1">
      boost::asio::ip::tcp::acceptor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.967.1">
     object to set up the protocol and port that the TCP server will use to accept connections.
    </span>
    <span class="koboSpan" id="kobo.967.2">
     Then, in an infinite loop, the server uses that acceptor object to attach a TCP socket (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.968.1">
      boost::asio::ip::tcp::socket
     </span>
    </strong>
    <span class="koboSpan" id="kobo.969.1">
     ) and
    </span>
    <a id="_idIndexMarker712">
    </a>
    <span class="koboSpan" id="kobo.970.1">
     call
    </span>
    <a id="_idIndexMarker713">
    </a>
    <span class="koboSpan" id="kobo.971.1">
     the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.972.1">
       handle_client()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.973.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.974.1">
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;boost/asio/streambuf.hpp&gt;
using boost::asio::ip::tcp;
constexpr int port = 1234;
int main() {
    try {
        boost::asio::io_context io_context;
        tcp::acceptor acceptor(io_context,
                      tcp::endpoint(tcp::v4(), port));
        std::cout &lt;&lt; "Server is running on port "
                  &lt;&lt; port &lt;&lt; "...\n";
        while (true) {
            tcp::socket socket(io_context);
            acceptor.accept(socket);
            std::cout &lt;&lt; "Client connected...\n";
            handle_client(socket);
            std::cout &lt;&lt; "Client disconnected...\n";
        }
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.975.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.976.1">
      handle_client()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.977.1">
     function creates two stream buffers:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.978.1">
      buf1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.979.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.980.1">
      buf2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.981.1">
     , and adds them to a container, in this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.982.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.983.1">
     , to be used in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.984.1">
      scatter-gather operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.985.1">
     Then, the synchronous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.986.1">
      read_some()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.987.1">
     function from the socket is called.
    </span>
    <span class="koboSpan" id="kobo.987.2">
     This function returns the number of bytes read from the socket and copies them into the buffers.
    </span>
    <span class="koboSpan" id="kobo.987.3">
     If anything goes wrong with the socket connection, an error will be returned in the error code object,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.988.1">
      ec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.989.1">
     .
    </span>
    <span class="koboSpan" id="kobo.989.2">
     In
    </span>
    <a id="_idIndexMarker714">
    </a>
    <span class="koboSpan" id="kobo.990.1">
     that
    </span>
    <a id="_idIndexMarker715">
    </a>
    <span class="koboSpan" id="kobo.991.1">
     case, the server will print the error message
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.992.1">
      and exit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.993.1">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.994.1">
      the implementation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.995.1">
void handle_client(tcp::socket&amp; socket) {
    const size_t size_buffer = 5;
    boost::asio::streambuf buf1, buf2;
    std::array&lt;boost::asio::mutable_buffer, 2&gt; buffers = {
        buf1.prepare(size_buffer),
        buf2.prepare(size_buffer)
    };
    boost::system::error_code ec;
    size_t bytes_recv = socket.read_some(buffers, ec);
    if (ec) {
        std::cerr &lt;&lt; "Error on receive: "
                  &lt;&lt; ec.message() &lt;&lt; '\n';
        return;
    }
    std::cout &lt;&lt; "Received " &lt;&lt; bytes_recv &lt;&lt; " bytes\n";
    buf1.commit(5);
    buf2.commit(5);
    std::istream is1(&amp;buf1);
    std::istream is2(&amp;buf2);
    std::string data1, data2;
    is1 &gt;&gt; data1;
    is2 &gt;&gt; data2;
    std::cout &lt;&lt; "Buffer 1: " &lt;&lt; data1 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Buffer 2: " &lt;&lt; data2 &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.996.1">
     If there are no
    </span>
    <a id="_idIndexMarker716">
    </a>
    <span class="koboSpan" id="kobo.997.1">
     errors, the
    </span>
    <a id="_idIndexMarker717">
    </a>
    <span class="koboSpan" id="kobo.998.1">
     stream buffers’
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.999.1">
      commit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1000.1">
     function is used to transfer five bytes to each of the stream buffers,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1001.1">
      buf1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1002.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1003.1">
      buf2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1004.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1004.2">
     The contents of these buffers are extracted by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1005.1">
      std::istream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1006.1">
     objects and printed to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1007.1">
      the console.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1008.1">
     To execute this example, we need to open two terminals.
    </span>
    <span class="koboSpan" id="kobo.1008.2">
     In one terminal, we execute the server, and in the other, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1009.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1010.1">
     command, as shown earlier.
    </span>
    <span class="koboSpan" id="kobo.1010.2">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1011.1">
      telnet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1012.1">
     terminal, we can type a message (for example,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1013.1">
      Hello World
     </span>
    </em>
    <span class="koboSpan" id="kobo.1014.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1014.2">
     This message is sent to the server.
    </span>
    <span class="koboSpan" id="kobo.1014.3">
     The server terminal will then show
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1015.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1016.1">
Server is running on port 1234...
</span><span class="koboSpan" id="kobo.1016.2">Client connected...
</span><span class="koboSpan" id="kobo.1016.3">Received 10 bytes
Buffer 1: Hello
Buffer 2: Worl
Client disconnected...</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1017.1">
     As we can see, only 10 bytes are processed and distributed into the two buffers.
    </span>
    <span class="koboSpan" id="kobo.1017.2">
     The space character between the two words is processed but discarded when parsing the input by the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1018.1">
       iostream
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1019.1">
      objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1020.1">
     Stream buffers
    </span>
    <a id="_idIndexMarker718">
    </a>
    <span class="koboSpan" id="kobo.1021.1">
     are useful when the size of the incoming data is
    </span>
    <a id="_idIndexMarker719">
    </a>
    <span class="koboSpan" id="kobo.1022.1">
     variable and unknown in advance.
    </span>
    <span class="koboSpan" id="kobo.1022.2">
     These types of buffers can be used together with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      fixed-sized buffers.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-207">
    <a id="_idTextAnchor206">
    </a>
    <span class="koboSpan" id="kobo.1024.1">
     Signal handling
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1025.1">
      Signal handling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1026.1">
     allows us
    </span>
    <a id="_idIndexMarker720">
    </a>
    <span class="koboSpan" id="kobo.1027.1">
     to catch signals sent by the OS and gracefully shut down
    </span>
    <a id="_idIndexMarker721">
    </a>
    <span class="koboSpan" id="kobo.1028.1">
     the application before the OS decides to kill the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1029.1">
      application’s process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1030.1">
     Boost.Asio provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1031.1">
      boost::asio::signal_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1032.1">
     class for this purpose, which starts an asynchronous wait for one or more signals
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1033.1">
      to occur.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1034.1">
     This is an example of how to handle the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1035.1">
      SIGINT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1036.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1037.1">
       SIGTERM
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1038.1">
      signals:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1039.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
int main() {
    try {
        boost::asio::io_context io_context;
        boost::asio::signal_set signals(io_context,
                                  SIGINT, SIGTERM);
        auto handle_signal = [&amp;](
                const boost::system::error_code&amp; ec,
                int signal) {
            if (!ec) {
                std::cout &lt;&lt; "Signal received: "
                          &lt;&lt; signal &lt;&lt; std::endl;
                // Code to perform cleanup or shutdown.
</span><span class="koboSpan" id="kobo.1039.2">                io_context.stop();
            }
        };
        signals.async_wait(handle_signal);
        std::cout &lt;&lt; "Application is running. </span><span class="koboSpan" id="kobo.1039.3">"
                  &lt;&lt; "Press Ctrl+C to stop...\n";
        io_context.run();
        std::cout &lt;&lt; "Application has exited cleanly.\n";
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1040.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1041.1">
      signals
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1042.1">
     object is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1043.1">
      signal_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1044.1">
     , listing the signals that the program waits for,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1045.1">
      SIGINT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1046.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1047.1">
      SIGTERM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1048.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1048.2">
     This object has an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1049.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1050.1">
     method that asynchronously waits for any of those signals to happen and triggers the completion
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1051.1">
      handler,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1052.1">
       handle_signal()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1053.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1054.1">
     As usual in completion handlers,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1055.1">
      handle_signal()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1056.1">
     checks the error code,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1057.1">
      ec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1058.1">
     , and if there is no error, some cleanup code might execute to cleanly and gracefully exit the program.
    </span>
    <span class="koboSpan" id="kobo.1058.2">
     In this example, we just stop the event processing loop by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1059.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1060.1">
       io_context.stop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1061.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1062.1">
     We could also wait synchronously for signals by using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1063.1">
       signals.wait()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1064.1">
      method.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1065.1">
     If the application is multithreaded, the signals event handler must run in the same thread as
    </span>
    <a id="_idIndexMarker722">
    </a>
    <span class="koboSpan" id="kobo.1066.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1067.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1068.1">
     object, typically
    </span>
    <a id="_idIndexMarker723">
    </a>
    <span class="koboSpan" id="kobo.1069.1">
     being the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1070.1">
      main thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1071.1">
     In the next section, we will learn how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1072.1">
      cancel operations.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-208">
    <a id="_idTextAnchor207">
    </a>
    <span class="koboSpan" id="kobo.1073.1">
     Canceling operations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1074.1">
     Some I/O objects, such
    </span>
    <a id="_idIndexMarker724">
    </a>
    <span class="koboSpan" id="kobo.1075.1">
     as sockets or timers, have object-wide cancellation of
    </span>
    <a id="_idIndexMarker725">
    </a>
    <span class="koboSpan" id="kobo.1076.1">
     outstanding asynchronous operations by calling their
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1077.1">
      close()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1078.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1079.1">
      cancel()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1080.1">
     methods.
    </span>
    <span class="koboSpan" id="kobo.1080.2">
     If an asynchronous operation is canceled, the completion handler will receive an error with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1081.1">
       boost::asio::error::operation_aborted
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1082.1">
      code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1083.1">
     In the following example, a timer is created, and its timeout period is set to five seconds.
    </span>
    <span class="koboSpan" id="kobo.1083.2">
     But after sleeping the main thread for only two seconds, the timer is canceled by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1084.1">
      cancel()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1085.1">
     method, making the completion handler be called with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1086.1">
      boost::asio::error::operation_aborted
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1087.1">
      error code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1088.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void handle_timeout(const boost::system::error_code&amp; ec) {
    if (ec == boost::asio::error::operation_aborted) {
        std::cout &lt;&lt; "Timer canceled.\n";
    } else if (!ec) {
        std::cout &lt;&lt; "Timer expired.\n";
    } else {
        std::cout &lt;&lt; "Error: " &lt;&lt; ec.message()
                  &lt;&lt; std::endl;
    }
}
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 5s);
    timer.async_wait(handle_timeout);
    std::this_thread::sleep_for(2s);
    timer.cancel();
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1089.1">
     But if we want a per-operation cancellation, we need to set up a cancellation slot that will be triggered when a cancellation signal is emitted.
    </span>
    <span class="koboSpan" id="kobo.1089.2">
     This cancellation signal/slot pair composes a lightweight channel to communicate cancellation operations, like the ones created between promises and futures explained in
    </span>
    <a href="B22219_06.xhtml#_idTextAnchor125">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1090.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1091.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1091.2">
     The cancellation framework has been available in Boost.Asio since
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1092.1">
      version 1.75.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1093.1">
     This approach enables a more flexible cancellation mechanism where multiple operations can be canceled using the same signal, and it integrates seamlessly with Boost.Asio’s asynchronous operations.
    </span>
    <span class="koboSpan" id="kobo.1093.2">
     Synchronous operations can only be canceled by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1094.1">
      cancel()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1095.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1096.1">
      close()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1097.1">
     methods described earlier; they are not supported by the cancellation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1098.1">
      slots mechanism.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1099.1">
     Let’s modify the previous example and use a cancellation signal/slot to cancel the timer.
    </span>
    <span class="koboSpan" id="kobo.1099.2">
     We only need to modify the way the timer is canceled in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1100.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1101.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1101.2">
     Now, when the asynchronous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1102.1">
      async_wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1103.1">
     operation is executed, a cancellation slot is created by binding a slot from the cancellation signal and the completion handler using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1104.1">
       boost::asio::bind_cancellation_slot()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1105.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1106.1">
     As before, the timer has an expiration period of five seconds, and again, the main thread only sleeps for two seconds.
    </span>
    <span class="koboSpan" id="kobo.1106.2">
     This time, a cancellation signal is emitted by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1107.1">
      cancel_signal.emit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1108.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1108.2">
     The signal will trigger the counterpart cancellation slot
    </span>
    <a id="_idIndexMarker726">
    </a>
    <span class="koboSpan" id="kobo.1109.1">
     and
    </span>
    <a id="_idIndexMarker727">
    </a>
    <span class="koboSpan" id="kobo.1110.1">
     execute the completion handler with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1111.1">
      boost::asio::error::operation_aborted
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1112.1">
     error code, printing in the console the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1113.1">
      Timer canceled.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1114.1">
     message; see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1115.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1116.1">
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 5s);
    boost::asio::cancellation_signal cancel_signal;
    timer.async_wait(boost::asio::bind_cancellation_slot(
        cancel_signal.slot(),
        handle_timeout
    ));
    std::this_thread::sleep_for(2s);
    cancel_signal.emit(
        boost::asio::cancellation_type::all);
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1117.1">
     When the signal is emitted, a cancellation type must be specified, letting the target operation know what the application requires and the operation guarantees, thus controlling the
    </span>
    <a id="_idIndexMarker728">
    </a>
    <span class="koboSpan" id="kobo.1118.1">
     scope
    </span>
    <a id="_idIndexMarker729">
    </a>
    <span class="koboSpan" id="kobo.1119.1">
     and behavior of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1120.1">
      the cancellation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1121.1">
     The various categories of cancellation are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1122.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1123.1">
       None
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1124.1">
      : No cancellation is performed.
     </span>
     <span class="koboSpan" id="kobo.1124.2">
      It can be useful if we want to test if a cancellation
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1125.1">
       should occur.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1126.1">
       Terminal
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1127.1">
      : The operation has unspecified side effects so the only safe way to cancel the operation is to close or destroy the I/O object, being its result final, for example, completing a task
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1128.1">
       or transaction.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1129.1">
       Partial
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1130.1">
      : The operation has well-defined side effects so the completion handler can take the required actions to resolve the issue, meaning that the operation is partially completed and can be resumed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1131.1">
       or retried.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1132.1">
       Total
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1133.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1134.1">
       All
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1135.1">
      : The operation has no side effects.
     </span>
     <span class="koboSpan" id="kobo.1135.2">
      Cancels both terminal and partial operations, enabling a comprehensive cancellation by stopping all ongoing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1136.1">
       asynchronous operations.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1137.1">
     If the cancellation type is not supported by the asynchronous operation, the cancellation request is discarded.
    </span>
    <span class="koboSpan" id="kobo.1137.2">
     For example, timer operations support all categories of cancellation, but sockets only support
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1138.1">
      Total
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1139.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1140.1">
      All
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1141.1">
     , meaning that if we try to cancel a socket asynchronous operation with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1142.1">
      Partial
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1143.1">
     cancellation, this cancellation will be ignored.
    </span>
    <span class="koboSpan" id="kobo.1143.2">
     This prevents undefined behavior if an I/O system tries to handle an unsupported
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1144.1">
      cancellation request.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1145.1">
     Also, cancellation requests made after the operation is initiated but before it starts, or after its completion, have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1146.1">
      no effect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1147.1">
     Sometimes, we need
    </span>
    <a id="_idIndexMarker730">
    </a>
    <span class="koboSpan" id="kobo.1148.1">
     to run some work sequentially.
    </span>
    <span class="koboSpan" id="kobo.1148.2">
     Next, we will introduce how we
    </span>
    <a id="_idIndexMarker731">
    </a>
    <span class="koboSpan" id="kobo.1149.1">
     can achieve this by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1150.1">
      using strands.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-209">
    <a id="_idTextAnchor208">
    </a>
    <span class="koboSpan" id="kobo.1151.1">
     Serializing workload with strands
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1152.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1153.1">
      strand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1154.1">
     is a strict
    </span>
    <a id="_idIndexMarker732">
    </a>
    <span class="koboSpan" id="kobo.1155.1">
     sequential
    </span>
    <a id="_idIndexMarker733">
    </a>
    <span class="koboSpan" id="kobo.1156.1">
     and non-concurrent invocation of completion handlers.
    </span>
    <span class="koboSpan" id="kobo.1156.2">
     Using strands, asynchronous operations can be sequenced without explicit locking by using mutexes or other synchronization mechanisms seen earlier in this book.
    </span>
    <span class="koboSpan" id="kobo.1156.3">
     Strands can be implicit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1157.1">
      or explicit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1158.1">
     As shown earlier in this chapter, if we execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1159.1">
      boost::asio::io_context::run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1160.1">
     from only one thread, all event handlers will execute in an implicit strand, as they will be sequentially queued one by one and triggered from the I/O
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1161.1">
      execution context.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1162.1">
     Another implicit strand happens when there are chained asynchronous operations where one asynchronous operation schedules the next asynchronous operation, and so on.
    </span>
    <span class="koboSpan" id="kobo.1162.2">
     Some previous examples in this chapter already used this technique, but here there is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1163.1">
      another one.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1164.1">
     In this case, if there are no errors, the timer keeps restarting itself in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1165.1">
      handle_timer_expiry()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1166.1">
     event handler by recursively setting up the expiration time and calling the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1167.1">
       async_wait()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1168.1">
      method:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
using namespace std::chrono_literals;
void handle_timer_expiry(boost::asio::steady_timer&amp; timer,
                        int count) {
    std::cout &lt;&lt; "Timer expired. </span><span class="koboSpan" id="kobo.1169.2">Count: " &lt;&lt; count
              &lt;&lt; std::endl;
    timer.expires_after(1s);
    timer.async_wait([&amp;timer, count](
                const boost::system::error_code&amp; ec) {
        if (!ec) {
            handle_timer_expiry(timer, count + 1);
        } else {
            std::cerr &lt;&lt; „Error: „ &lt;&lt; ec.message()
                      &lt;&lt; std::endl;
        }
    });
}
int main() {
    boost::asio::io_context io_context;
    boost::asio::steady_timer timer(io_context, 1s);
    int count = 0;
    timer.async_wait([&amp;](
                const boost::system::error_code&amp; ec) {
        if (!ec) {
            handle_timer_expiry(timer, count);
        } else {
            std::cerr &lt;&lt; "Error: " &lt;&lt; ec.message()
                      &lt;&lt; std::endl;
        }
    });
    io_context.run();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1170.1">
     Running this example would print the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1171.1">
      Timer expired.
     </span>
     <span class="koboSpan" id="kobo.1171.2">
      Count: &lt;number&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1172.1">
     line every second with the counter increasing on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1173.1">
      each line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1174.1">
     In case some work needs to be serialized but these approaches are not appropriate, we can use explicit strands by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1175.1">
      boost::asio::strand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1176.1">
     or its specialization for I/O context execution objects,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1177.1">
      boost::asio::io_context::strand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1178.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1178.2">
     Posted work using these strand objects will serialize their handler execution in the order they enter the I/O execution
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1179.1">
      context queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1180.1">
     In the following example, we will create a logger that serializes writing operations into a single log file from several threads.
    </span>
    <span class="koboSpan" id="kobo.1180.2">
     We will be logging messages from four threads, writing five messages from each.
    </span>
    <span class="koboSpan" id="kobo.1180.3">
     We expect the output to be correct, but this time without using any
    </span>
    <a id="_idIndexMarker734">
    </a>
    <span class="koboSpan" id="kobo.1181.1">
     mutex or other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1182.1">
      synchronization
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker735">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1183.1">
      mechanism.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1184.1">
     Let’s start by defining the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1185.1">
       Logger
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1186.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1187.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std::chrono_literals;
class Logger {
   public:
    Logger(boost::asio::io_context&amp; io_context,
           const std::string&amp; filename)
        : strand_(io_context), file_(filename
        , std::ios::out | std::ios::app)
    {
        if (!file_.is_open()) {
            throw std::runtime_error(
                      "Failed to open log file");
        }
    }
    void log(const std::string message) {
        strand_.post([this, message](){
            do_log(message);
        });
    }
   private:
    void do_log(const std::string message) {
        file_ &lt;&lt; message &lt;&lt; std::endl;
    }
    boost::asio::io_context::strand strand_;
    std::ofstream file_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1188.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1189.1">
      Logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1190.1">
     constructor accepts an I/O context object, used to create a strand object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1191.1">
      boost::asio::io_context::strand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1192.1">
     ), and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1193.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1194.1">
     , specifying a log filename that is used to open the log file or create it if it does not exist.
    </span>
    <span class="koboSpan" id="kobo.1194.2">
     The log file is open for appending new content.
    </span>
    <span class="koboSpan" id="kobo.1194.3">
     If the file is not open before the constructor finishes, meaning that there was an issue when accessing or creating the file, the constructor throws
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1195.1">
      an exception.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1196.1">
     The logger also provides the public
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1197.1">
      log()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1198.1">
     function that accepts
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1199.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1200.1">
     , specifying a message as a parameter.
    </span>
    <span class="koboSpan" id="kobo.1200.2">
     This function uses the strand to post new work into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1201.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1202.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.1202.2">
     It does that by using a lambda function, capturing by value the logger instance (the object
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1203.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1204.1">
     ) and the message, and calls the private
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1205.1">
      do_log()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1206.1">
     function, where a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1207.1">
      std::fstream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1208.1">
     object is used to write the message into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1209.1">
      output file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1210.1">
     There will be only one instance of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1211.1">
      Logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1212.1">
     class in the program, shared by all threads.
    </span>
    <span class="koboSpan" id="kobo.1212.2">
     That way, the
    </span>
    <a id="_idIndexMarker736">
    </a>
    <span class="koboSpan" id="kobo.1213.1">
     threads will write to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1214.1">
      same
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker737">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1215.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1216.1">
     Let’s define a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1217.1">
      worker()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1218.1">
     function that each thread will run to write
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1219.1">
      num_messages_per_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1220.1">
     messages into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1221.1">
      output file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1222.1">
void worker(std::shared_ptr&lt;Logger&gt; logger, int id) {
    for (unsigned i=0; i &lt; num_messages_per_thread; ++i) {
        std::ostringstream oss;
        oss &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " logging message " &lt;&lt; i;
        logger-&gt;log(oss.str());
        std::this_thread::sleep_for(100ms);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1223.1">
     This function accepts a shared pointer to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1224.1">
      Logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1225.1">
     object and a thread identifier.
    </span>
    <span class="koboSpan" id="kobo.1225.2">
     It prints all the messages using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1226.1">
      Logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1227.1">
     ’s public
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1228.1">
      log()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1229.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1230.1">
      explained earlier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1231.1">
     To interleave the threads executions and rigorously test how the strands work, each thread will sleep for 100 ms after writing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1232.1">
      each message.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1233.1">
     Finally, in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1234.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1235.1">
     function, we start an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1236.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1237.1">
     object and a work guard to avoid an early exit from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1238.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1239.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1239.2">
     Then, a shared pointer to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1240.1">
      Logger
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1241.1">
     instance is created, passing the necessary parameters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1242.1">
      explained earlier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1243.1">
     A thread pool (vector of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1244.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1245.1">
     objects) is created by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1246.1">
      worker()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1247.1">
     function and passing the shared pointer to the logger and a unique identifier for each thread.
    </span>
    <span class="koboSpan" id="kobo.1247.2">
     Also, a thread running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1248.1">
      io_context.run()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1249.1">
     function is added to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1250.1">
      thread pool.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1251.1">
     In the following example, as we know that all messages will be printed out in less than two seconds, we make
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1252.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1253.1">
     run for only that period,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1254.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1255.1">
       io_context.run_for(2s)
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1256.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1257.1">
     When the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1258.1">
      run_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1259.1">
     function
    </span>
    <a id="_idIndexMarker738">
    </a>
    <span class="koboSpan" id="kobo.1260.1">
     exits, the program
    </span>
    <a id="_idIndexMarker739">
    </a>
    <span class="koboSpan" id="kobo.1261.1">
     prints
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1262.1">
      Done!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1263.1">
     to the console
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1264.1">
      and finishes:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
const std::string log_filename = "log.txt";
const unsigned num_threads = 4;
const unsigned num_messages_per_thread = 5;
int main() {
    try {
        boost::asio::io_context io_context;
        auto work_guard = boost::asio::make_work_guard(
                                 io_context);
        std::shared_ptr&lt;Logger&gt; logger =
             std::make_shared&lt;Logger&gt;(
                  io_context, log_filename);
        std::cout &lt;&lt; "Logging "
                  &lt;&lt; num_messages_per_thread
                  &lt;&lt; " messages from " &lt;&lt; num_threads
                  &lt;&lt; " threads\n";
        std::vector&lt;std::jthread&gt; threads;
        for (unsigned i = 0; i &lt; num_threads; ++i) {
            threads.emplace_back(worker, logger, i);
        }
        threads.emplace_back([&amp;]() {
            io_context.run_for(2s);
        });
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
    std::cout &lt;&lt; "Done!" </span><span class="koboSpan" id="kobo.1265.2">&lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1266.1">
     Running this example
    </span>
    <a id="_idIndexMarker740">
    </a>
    <span class="koboSpan" id="kobo.1267.1">
     will show the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1268.1">
      following
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker741">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1269.1">
      output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1270.1">
Logging 5 messages from 4 threads
Done!</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1271.1">
     This is the content of the generated
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1272.1">
      log.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1273.1">
     log file.
    </span>
    <span class="koboSpan" id="kobo.1273.2">
     As the sleep time for each thread is the same, all threads and messages are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1274.1">
      sequentially ordered:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1275.1">
Thread 0 logging message 0
Thread 1 logging message 0
Thread 2 logging message 0
Thread 3 logging message 0
Thread 0 logging message 1
Thread 1 logging message 1
Thread 2 logging message 1
Thread 3 logging message 1
Thread 0 logging message 2
Thread 1 logging message 2
Thread 2 logging message 2
Thread 3 logging message 2
Thread 0 logging message 3
Thread 1 logging message 3
Thread 2 logging message 3
Thread 3 logging message 3
Thread 0 logging message 4
Thread 1 logging message 4
Thread 2 logging message 4
Thread 3 logging message 4</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1276.1">
     If we remove the
    </span>
    <a id="_idIndexMarker742">
    </a>
    <span class="koboSpan" id="kobo.1277.1">
     work guard, the log file only has the
    </span>
    <a id="_idIndexMarker743">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1278.1">
      following content:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1279.1">
Thread 0 logging message 0
Thread 1 logging message 0
Thread 2 logging message 0
Thread 3 logging message 0</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1280.1">
     This happens because the first batch of work is promptly posted and queued into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1281.1">
      io_object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1282.1">
     from each thread, but
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1283.1">
      io_object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1284.1">
     exits after finishing dispatching the work guard and notifying the completion handlers before the second batch of messages
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1285.1">
      is posted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1286.1">
     If we also remove the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1287.1">
      sleep_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1288.1">
     instruction in the worker thread, now, the log file content is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1289.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1290.1">
Thread 0 logging message 0
Thread 0 logging message 1
Thread 0 logging message 2
Thread 0 logging message 3
Thread 0 logging message 4
Thread 1 logging message 0
Thread 1 logging message 1
Thread 1 logging message 2
Thread 1 logging message 3
Thread 1 logging message 4
Thread 2 logging message 0
Thread 2 logging message 1
Thread 2 logging message 2
Thread 2 logging message 3
Thread 2 logging message 4
Thread 3 logging message 0
Thread 3 logging message 1
Thread 3 logging message 2
Thread 3 logging message 3
Thread 3 logging message 4</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1291.1">
     Earlier, the content
    </span>
    <a id="_idIndexMarker744">
    </a>
    <span class="koboSpan" id="kobo.1292.1">
     was
    </span>
    <a id="_idIndexMarker745">
    </a>
    <span class="koboSpan" id="kobo.1293.1">
     sorted by message identifier, and now it’s by thread identifier.
    </span>
    <span class="koboSpan" id="kobo.1293.2">
     This is because now, when a thread starts and runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1294.1">
      worker()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1295.1">
     function, it posts all messages at once, without any delay.
    </span>
    <span class="koboSpan" id="kobo.1295.2">
     Therefore, the first thread (thread
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1296.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1297.1">
     ) enqueues all its work before the second thread has the chance to do that, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1298.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1299.1">
     Continuing with further experiments, when we posted content into the strand, we captured the logger instance and the message by value, by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1300.1">
      following instruction:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1301.1">
strand_.post([this, message]() { do_log(message); });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1302.1">
     Capturing by value allows the lambda function running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1303.1">
      do_log()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1304.1">
     to use a copy of the needed objects, keeping them alive, as commented earlier in this chapter when we discussed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1305.1">
      object lifetimes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1306.1">
     Say, for some reason, we decided to capture by reference using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1307.1">
      following instruction:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1308.1">
strand_.post([&amp;]() { do_log(message); });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1309.1">
     Then, the resulting log file will have incomplete log messages and even incorrect characters because the logger is printing from memory areas that belonged to a message object that no longer exists when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1310.1">
      do_log()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1311.1">
      function executes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1312.1">
     Therefore, always assume asynchronous changes; the OS might perform some changes out of our control, so always know what is under our control and, most importantly,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1313.1">
      what’s not.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1314.1">
     Finally, instead of using a lambda expression and capturing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1315.1">
      this
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1316.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1317.1">
      message
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1318.1">
     objects by value, we could also use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1319.1">
      std::bind
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1320.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1321.1">
strand_.post(std::bind(&amp;Logger::do_log, this, message));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1322.1">
     Let’s learn now how
    </span>
    <a id="_idIndexMarker746">
    </a>
    <span class="koboSpan" id="kobo.1323.1">
     we can simplify the echo server we
    </span>
    <a id="_idIndexMarker747">
    </a>
    <span class="koboSpan" id="kobo.1324.1">
     implemented earlier by using coroutines and improving it by adding a command to exit the connection from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1325.1">
      client’s side.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-210">
    <a id="_idTextAnchor209">
    </a>
    <span class="koboSpan" id="kobo.1326.1">
     Coroutines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1327.1">
     Boost.Asio has also
    </span>
    <a id="_idIndexMarker748">
    </a>
    <span class="koboSpan" id="kobo.1328.1">
     included support for coroutines since version 1.56.0 and
    </span>
    <a id="_idIndexMarker749">
    </a>
    <span class="koboSpan" id="kobo.1329.1">
     supported native coroutines since
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1330.1">
      version 1.75.0.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1331.1">
     As we have learned in the previous chapter, using coroutines simplifies how the program is written as there is no need to add completion handlers and split the flow of the program into different asynchronous functions and callbacks.
    </span>
    <span class="koboSpan" id="kobo.1331.2">
     Instead, with coroutines, the program follows a sequential structure where an asynchronous operation call pauses the execution of the coroutine.
    </span>
    <span class="koboSpan" id="kobo.1331.3">
     When the asynchronous operation completes, the coroutine is resumed, letting the program continue its execution from where it was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1332.1">
      previously paused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1333.1">
     With newer versions (newer than 1.75.0), we can use native C++ coroutines via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1334.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1335.1">
     , to wait for asynchronous operations within a coroutine,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1336.1">
      boost::asio::co_spawn
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1337.1">
     to launch a coroutine, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1338.1">
      boost::asio::use_awaitable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1339.1">
     to let Boost.Asio know that an asynchronous operation will use coroutines.
    </span>
    <span class="koboSpan" id="kobo.1339.2">
     With earlier versions (from 1.56.0), coroutines were available using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1340.1">
      boost::asio::spawn()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1341.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1342.1">
      yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1343.1">
     contexts.
    </span>
    <span class="koboSpan" id="kobo.1343.2">
     As the newer approach is preferred, not only because it supports native C++20 coroutines, but the code is also more modern, clean, and readable, we will focus on this approach in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1344.1">
      this section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1345.1">
     Let’s implement again the echo server, but this time using Boost.Asio’s awaitable interface and coroutines.
    </span>
    <span class="koboSpan" id="kobo.1345.2">
     We will also add some improvements, such as support to close the connection from the client’s side when sending the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1346.1">
      QUIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1347.1">
     command, showing how to process data or commands on the server side, and stopping handling connections and exiting if any exception
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1348.1">
      is thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1349.1">
     Let’s start by implementing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1350.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1351.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1351.2">
     The program starts by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1352.1">
      boost::asio::co_spawn
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1353.1">
     to create a new coroutine-based thread.
    </span>
    <span class="koboSpan" id="kobo.1353.2">
     This function accepts as parameters an execution context (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1354.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1355.1">
     , but can also use a strand), a function with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1356.1">
      boost::asio::awaitable&lt;R,E&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1357.1">
     return type, which will be used as the coroutine’s entry point (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1358.1">
      listener()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1359.1">
     function that we will implement and explain next), and
    </span>
    <a id="_idIndexMarker750">
    </a>
    <span class="koboSpan" id="kobo.1360.1">
     a completion token that will be called when the thread
    </span>
    <a id="_idIndexMarker751">
    </a>
    <span class="koboSpan" id="kobo.1361.1">
     has completed.
    </span>
    <span class="koboSpan" id="kobo.1361.2">
     If we want to run the coroutine without being notified of its completion, we can pass the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1362.1">
       boost::asio::detached
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1363.1">
      token.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1364.1">
     Finally, we start processing asynchronous events by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1365.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1366.1">
       io_context.run()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1367.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1368.1">
     In case there is any exception, it will be caught by the try-catch block, and the event processing loop will be stopped by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1369.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1370.1">
       io_context.stop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1371.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1372.1">
#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using boost::asio::ip::tcp;
int main() {
    boost::asio::io_context io_context;
    try {
        boost::asio::co_spawn(io_context,
                    listener(io_context, 12345),
                    boost::asio::detached);
        io_context.run();
    } catch (std::exception&amp; e) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        io_context.stop();
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1373.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1374.1">
      listener()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1375.1">
     function
    </span>
    <a id="_idIndexMarker752">
    </a>
    <span class="koboSpan" id="kobo.1376.1">
     receives as parameters an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1377.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1378.1">
     object and the
    </span>
    <a id="_idIndexMarker753">
    </a>
    <span class="koboSpan" id="kobo.1379.1">
     port number that the listener will accept connections from, using an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1380.1">
      acceptor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1381.1">
     object as explained earlier.
    </span>
    <span class="koboSpan" id="kobo.1381.2">
     It also must have a return type of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1382.1">
      boost::asio::awaitable&lt;R,E&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1383.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1384.1">
      R
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1385.1">
     is the return type of the coroutine and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1386.1">
      E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1387.1">
     is the exception type that might be thrown.
    </span>
    <span class="koboSpan" id="kobo.1387.2">
     In this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1388.1">
      E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1389.1">
     is set as default, so not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1390.1">
      explicitly specified.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1391.1">
     The connection is accepted by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1392.1">
      async_accept
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1393.1">
     acceptor function.
    </span>
    <span class="koboSpan" id="kobo.1393.2">
     As we are now using a coroutine, we need to specify
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1394.1">
      boost::asio::use_awaitable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1395.1">
     to the asynchronous function and use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1396.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1397.1">
     to stop the coroutine execution until is resumed when the asynchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1398.1">
      task completes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1399.1">
     When the listener coroutine task resumes,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1400.1">
      acceptor.async_accept()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1401.1">
     returns a socket object.
    </span>
    <span class="koboSpan" id="kobo.1401.2">
     The coroutine continues by spawning a new thread, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1402.1">
      boost::asio::co_spawn
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1403.1">
     function, executing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1404.1">
      echo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1405.1">
     function, and passing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1406.1">
      socket
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1407.1">
     object
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1408.1">
      to it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1409.1">
boost::asio::awaitable&lt;void&gt; listener(boost::asio::io_context&amp; io_context, unsigned short port) {
    tcp::acceptor acceptor(io_context,
                           tcp::endpoint(tcp::v4(), port));
    while (true) {
        std::cout &lt;&lt; "Accepting connections...\n";
        tcp::socket socket = co_await
                acceptor.async_accept(
                    boost::asio::use_awaitable);
        std::cout &lt;&lt; "Starting an Echo "
                  &lt;&lt; "connection handler...\n";
        boost::asio::co_spawn(io_context,
                              echo(std::move(socket)),
                              boost::asio::detached);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1410.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1411.1">
      echo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1412.1">
     function is
    </span>
    <a id="_idIndexMarker754">
    </a>
    <span class="koboSpan" id="kobo.1413.1">
     responsible for handling a single client connection.
    </span>
    <span class="koboSpan" id="kobo.1413.2">
     It
    </span>
    <a id="_idIndexMarker755">
    </a>
    <span class="koboSpan" id="kobo.1414.1">
     must follow a similar signature as the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1415.1">
      listener()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1416.1">
     function; it needs a return type of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1417.1">
      boost::asio::awaitable&lt;R,E&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1418.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1418.2">
     As commented earlier, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1419.1">
      socket
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1420.1">
     object is moved into this function from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1421.1">
      the listener.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1422.1">
     The function asynchronously reads content from the socket and writes it back in an infinite loop that only finishes if it receives the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1423.1">
      QUIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1424.1">
     command or an exception
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1425.1">
      is thrown.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1426.1">
     Asynchronous reads are done by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1427.1">
      socket.async_read_some()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1428.1">
     function, which reads data into the data buffer using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1429.1">
      boost::asio::buffer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1430.1">
     and returns the number of bytes read (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1431.1">
      bytes_read
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1432.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1432.2">
     As the asynchronous task is managed by a coroutine,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1433.1">
      boost::asio::use_awaitable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1434.1">
     is passed to the asynchronous operation.
    </span>
    <span class="koboSpan" id="kobo.1434.2">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1435.1">
      co_wait
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1436.1">
     just instructs the coroutine engine to pause the execution until the asynchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1437.1">
      operation finishes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1438.1">
     Once some data is received, the execution of the coroutine resumes, checking if there is really some data to process, otherwise, it finishes the connection by exiting the loop, thus the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1439.1">
      echo()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1440.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1441.1">
      as well.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1442.1">
     If data is read, it converts it into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1443.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1444.1">
     for easy manipulation.
    </span>
    <span class="koboSpan" id="kobo.1444.2">
     It removes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1445.1">
      \r\n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1446.1">
     ending, if present, and compares the string
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1447.1">
      against
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1448.1">
       QUIT
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1449.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1450.1">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1451.1">
      QUIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1452.1">
     is present, it performs an asynchronous write, sends the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1453.1">
      Good bye!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1454.1">
     message, and exits the loop.
    </span>
    <span class="koboSpan" id="kobo.1454.2">
     Otherwise, it sends the received data back to the client.
    </span>
    <span class="koboSpan" id="kobo.1454.3">
     In both cases, an asynchronous write operation is performed by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1455.1">
      boost::asio::async_write()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1456.1">
     function, passing the socket,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1457.1">
      boost:asio::buffer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1458.1">
     wrapping the data buffer to send, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1459.1">
      boost::asio::use_awaitable
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1460.1">
     as with the asynchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1461.1">
      read operation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1462.1">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1463.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1464.1">
     is used again to suspend the execution of the coroutine while the operation is performed.
    </span>
    <span class="koboSpan" id="kobo.1464.2">
     Once
    </span>
    <a id="_idIndexMarker756">
    </a>
    <span class="koboSpan" id="kobo.1465.1">
     completed, the coroutine will resume and repeat
    </span>
    <a id="_idIndexMarker757">
    </a>
    <span class="koboSpan" id="kobo.1466.1">
     these steps in a new
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1467.1">
      loop iteration:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1468.1">
boost::asio::awaitable&lt;void&gt; echo(tcp::socket socket) {
    char data[1024];
    while (true) {
        std::cout &lt;&lt; "Reading data from socket...\n";
        std::size_t bytes_read = co_await
                 socket.async_read_some(
                        boost::asio::buffer(data),
                        boost::asio::use_awaitable);
        if (bytes_read == 0) {
            std::cout &lt;&lt; "No data. </span><span class="koboSpan" id="kobo.1468.2">Exiting loop...\n";
            break;
        }
        std::string str(data, bytes_read);
        if (!str.empty() &amp;&amp; str.back() == '\n') {
            str.pop_back();
        }
        if (!str.empty() &amp;&amp; str.back() == '\r') {
            str.pop_back();
        }
        if (str == "QUIT") {
            std::string bye("Good bye!\n");
            co_await boost::asio::async_write(socket,
                         boost::asio::buffer(bye),
                         boost::asio::use_awaitable);
            break;
        }
        std::cout &lt;&lt; "Writing '" &lt;&lt; str
                  &lt;&lt; "' back into the socket...\n";
        co_await boost::asio::async_write(socket,
                     boost::asio::buffer(data,
                                         bytes_read),
                     boost::asio::use_awaitable);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1469.1">
     The coroutine loops until no data is read, happening when the client closes the connection, when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1470.1">
      QUIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1471.1">
     command is received, or when an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1472.1">
      exception occurs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1473.1">
     Asynchronous operations
    </span>
    <a id="_idIndexMarker758">
    </a>
    <span class="koboSpan" id="kobo.1474.1">
     are used throughout to ensure the server remains
    </span>
    <a id="_idIndexMarker759">
    </a>
    <span class="koboSpan" id="kobo.1475.1">
     responsive, even when handling multiple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1476.1">
      clients simultaneously.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-211">
    <a id="_idTextAnchor210">
    </a>
    <span class="koboSpan" id="kobo.1477.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1478.1">
     In this chapter, we learned about Boost.Asio and how to use this library to manage asynchronous tasks that deal with external resources managed by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1479.1">
      the OS.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1480.1">
     For that purpose, we introduced the I/O objects and I/O execution context objects, with an in-depth explanation of how they work and interact together, how they access and communicate with OS services, what the design principles are behind them, and how to use them properly in single-threaded and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1481.1">
      multi-threaded applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1482.1">
     We also showed different techniques available in Boost.Asio to serialize work using strands, to manage the objects’ lifetimes used by asynchronous operations, how to start, interrupt, or cancel tasks, how to manage the event processing loop that the library uses, and how to handle signals sent by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1483.1">
      the OS.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1484.1">
     Other concepts related to networking and coroutines were also introduced, and we also implemented some useful examples using this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1485.1">
      powerful library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1486.1">
     All these concepts and examples allow us to acquire a deeper knowledge of how to manage asynchronous tasks in C++ and how an extensively used library works under the hood to achieve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1487.1">
      this goal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1488.1">
     In the next chapter, we will learn about another Boost library, Boost.Cobalt, that provides a rich and high-level interface to develop asynchronous software based
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1489.1">
      in coroutines.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-212">
    <a id="_idTextAnchor211">
    </a>
    <span class="koboSpan" id="kobo.1490.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1491.1">
      Boost.Asio official
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1492.1">
       site:
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1493.1">
        https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1494.1">
      Boost.Asio
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1495.1">
       reference:
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1496.1">
        https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1497.1">
      Boost.Asio revision
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1498.1">
       history:
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1499.1">
        https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1500.1">
      Boost.Asio BSD socket
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1501.1">
       API:
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1502.1">
        https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1503.1">
      BSD socket
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1504.1">
       API:
      </span>
     </span>
     <a href="https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1505.1">
        https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1506.1">
       The Boost C++ Libraries, Boris
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1507.1">
        Schälig
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1508.1">
       :
      </span>
     </span>
     <a href="https://theboostcpplibraries.com/boost.asio">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1509.1">
        https://theboostcpplibraries.com/boost.asio
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1510.1">
       Thinking Asynchronously: Designing Applications with Boost.Asio, Christopher
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1511.1">
        Kohlhoff
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1512.1">
       :
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=D-lTwGJRx0o">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1513.1">
        https://www.youtube.com/watch?v=D-lTwGJRx0o
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1514.1">
       CppCon 2016: Asynchronous IO with Boost.Asio, Michael
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1515.1">
        Caisse
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1516.1">
       :
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=rwOv_tw2eA4">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1517.1">
        https://www.youtube.com/watch?v=rwOv_tw2eA4
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1518.1">
       Pattern-Oriented Software Architecture – Patterns for Concurrent and Networked Objects
      </span>
     </em>
     <span class="koboSpan" id="kobo.1519.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1520.1">
       Volume 2
      </span>
     </em>
     <span class="koboSpan" id="kobo.1521.1">
      , D.
     </span>
     <span class="koboSpan" id="kobo.1521.2">
      Schmidt et al,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1522.1">
       Wiley, 2000
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1523.1">
       Boost.Asio C++ Network Programming Cookbook
      </span>
     </em>
     <span class="koboSpan" id="kobo.1524.1">
      , Dmytro Radchuk, Packt
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1525.1">
       Publishing, 2016
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1526.1">
       Proactor: An Object Behavioral Pattern for Demultiplexing and Dispatching handlers for Asynchronous events
      </span>
     </em>
     <span class="koboSpan" id="kobo.1527.1">
      , Irfan Pyarali, Tim Harrison, Douglas C Schmidt, Thomas D
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1528.1">
       Jordan.
      </span>
      <span class="koboSpan" id="kobo.1528.2">
       1997
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1529.1">
       Reactor: An Object Behavioral Pattern for Demultiplexing and Dispatching Handlers for Synchronous events
      </span>
     </em>
     <span class="koboSpan" id="kobo.1530.1">
      , Douglas C
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1531.1">
       Schmidt, 1995
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1532.1">
       Input/Output Completion
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1533.1">
        Port
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1534.1">
       :
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Input/output_completion_port">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1535.1">
        https://en.wikipedia.org/wiki/Input/output_completion_port
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1536.1">
        kqueue
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1537.1">
       :
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Kqueue">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1538.1">
        https://en.wikipedia.org/wiki/Kqueue
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1539.1">
        epoll
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1540.1">
       :
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Epoll">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1541.1">
        https://en.wikipedia.org/wiki/Epoll
       </span>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>