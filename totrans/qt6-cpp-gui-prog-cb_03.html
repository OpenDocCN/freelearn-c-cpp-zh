<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.2.1">States and Animations with Qt and QML</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Qt provides an easy way to animate widgets or any other objects that inherit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">QObject</span></strong><span class="koboSpan" id="kobo.5.1"> class through its powerful animation framework. </span><span class="koboSpan" id="kobo.5.2">The animation can be used either on its own or together with the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">state machine framework</span></strong><span class="koboSpan" id="kobo.7.1">, which allows different animations to be played based on the current active state of the widget. </span><span class="koboSpan" id="kobo.7.2">Qt’s animation framework also supports grouped animation, which allows you to move more than one graphics item simultaneously or move them in sequence, one after </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Property animation </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in Qt</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using easing curves to control </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">property animation</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Creating an </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">animation group</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Creating a nested </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">animation group</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">State machines </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">in Qt</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">States, transitions, and animations </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">in QML</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Animating widget properties </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">using animators</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Sprite animation</span></span></li>
</ul>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">The technical requirements for this chapter include </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Qt 6.6.1 MinGW 64-bit</span></strong><span class="koboSpan" id="kobo.29.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">Qt Creator 12.0.2</span></strong><span class="koboSpan" id="kobo.31.1">, and Windows 11. </span><span class="koboSpan" id="kobo.31.2">All the code used in this chapter can be downloaded from the following GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">at </span></span><a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.33.1">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.34.1">.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.35.1">Property animation in Qt</span></h1>
<p><span class="koboSpan" id="kobo.36.1">In this example, we will learn how to animate our </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Graphical User Interface</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">GUI</span></strong><span class="koboSpan" id="kobo.40.1">) elements using Qt’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">property animation</span></strong><span class="koboSpan" id="kobo.42.1"> class, a</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.43.1"> part of its powerful animation</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.44.1"> framework that</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.45.1"> allows us to create fluid-looking animations with </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">minimal effort.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.47.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.48.1">In the following example, we will create a new widget project and animate the push button by changing </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">its properties:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.50.1">Let’s create a new </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Qt Widgets Application</span></strong><span class="koboSpan" id="kobo.52.1"> project. </span><span class="koboSpan" id="kobo.52.2">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">mainwindow.ui</span></strong><span class="koboSpan" id="kobo.54.1"> with Qt Designer and place a button on the main window, as </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">shown here:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.56.1"><img alt="Figure 3.1 – Dragging and dropping a push button to the UI canvas" src="image/B20976_03_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.57.1">Figure 3.1 – Dragging and dropping a push button to the UI canvas</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.58.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">mainwindow.cpp</span></strong><span class="koboSpan" id="kobo.60.1"> and add the following line of code at the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.62.1">
#include &lt;QPropertyAnimation&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.63.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">mainwindow.cpp</span></strong><span class="koboSpan" id="kobo.65.1"> and add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.67.1">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(10000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
animation-&gt;start();</span></pre></li> </ol>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.68.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.69.1">One of the more</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.70.1"> common methods of animating a GUI element is through the property animation class provided by Qt, known as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">QPropertyAnimation</span></strong><span class="koboSpan" id="kobo.72.1"> class. </span><span class="koboSpan" id="kobo.72.2">This class is part of the animation framework and it makes use of the timer system in Qt to change the properties of a GUI element over a </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">given duration.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">What we are trying to </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.75.1">accomplish here is animating the button from one position to another while, at the same time, enlarging the button size along the way. </span><span class="koboSpan" id="kobo.75.2">By including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">QPropertyAnimation</span></strong><span class="koboSpan" id="kobo.77.1"> header in our source code in </span><em class="italic"><span class="koboSpan" id="kobo.78.1">step 2</span></em><span class="koboSpan" id="kobo.79.1">, we will be able to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">QPropertyAnimation</span></strong><span class="koboSpan" id="kobo.81.1"> class provided by Qt and make use of </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">its functionalities.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">The code in </span><em class="italic"><span class="koboSpan" id="kobo.84.1">step 3</span></em><span class="koboSpan" id="kobo.85.1"> basically creates a new </span><em class="italic"><span class="koboSpan" id="kobo.86.1">property animation</span></em><span class="koboSpan" id="kobo.87.1"> and applies it to the </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">push button</span></strong><span class="koboSpan" id="kobo.89.1"> we just created in Qt Designer. </span><span class="koboSpan" id="kobo.89.2">We specifically request that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">property animation</span></strong><span class="koboSpan" id="kobo.91.1"> class changes the geometry properties of the </span><em class="italic"><span class="koboSpan" id="kobo.92.1">push button</span></em><span class="koboSpan" id="kobo.93.1"> and sets its duration to 3,000 milliseconds (</span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">3 seconds).</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Then, the start value of the animation is set to the initial geometry of the </span><em class="italic"><span class="koboSpan" id="kobo.96.1">push button</span></em><span class="koboSpan" id="kobo.97.1"> because, obviously, we want it to start from where we initially placed the button in Qt Designer. </span><span class="koboSpan" id="kobo.97.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">end</span></strong><span class="koboSpan" id="kobo.99.1"> value is then set to what we want it to become; in this case, we will move the button to a new position at </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">x: 200</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">y: 200</span></strong><span class="koboSpan" id="kobo.103.1"> while changing its size to </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">width: 100</span></strong><span class="koboSpan" id="kobo.105.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">height: 50</span></strong><span class="koboSpan" id="kobo.107.1"> along </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">the way.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">After that, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">animation</span></strong><span class="koboSpan" id="kobo.111.1"> | </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">start()</span></strong><span class="koboSpan" id="kobo.113.1"> to start the animation. </span><span class="koboSpan" id="kobo.113.2">Compile and run the project. </span><span class="koboSpan" id="kobo.113.3">You should see the</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.114.1"> button start to move slowly across the main window while expanding in size a bit</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.115.1"> at a time until it reaches its destination. </span><span class="koboSpan" id="kobo.115.2">You can change the animation duration and the target position and scale by altering the values in the preceding code. </span><span class="koboSpan" id="kobo.115.3">It is really that simple to animate a GUI element using Qt’s property </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">animation system!</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.117.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.118.1">Qt provides us with several different sub-systems to create animations for our GUI, including the timer, timeline, animation framework, state machine framework, and graphics </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">view framework:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Timer</span></strong><span class="koboSpan" id="kobo.121.1">: Qt provides us with </span><em class="italic"><span class="koboSpan" id="kobo.122.1">repetitive and single-shot timers</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">When the timeout value is </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.124.1">reached, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">event callback</span></strong><span class="koboSpan" id="kobo.126.1"> function will be triggered through Qt’s </span><em class="italic"><span class="koboSpan" id="kobo.127.1">signal-and-slot</span></em><span class="koboSpan" id="kobo.128.1"> mechanism. </span><span class="koboSpan" id="kobo.128.2">You can make use of a timer to change the properties (color, position, scale, and so on) of your GUI element within a given interval to create </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">an animation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Timeline</span></strong><span class="koboSpan" id="kobo.131.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Timeline</span></em><span class="koboSpan" id="kobo.133.1"> calls a slot periodically to animate a GUI element. </span><span class="koboSpan" id="kobo.133.2">It is quite similar to a </span><em class="italic"><span class="koboSpan" id="kobo.134.1">repetitive timer</span></em><span class="koboSpan" id="kobo.135.1">, but instead of doing the same thing all of the time when the slot is triggered, the timeline provides a value to the slot to indicate its current </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.136.1">frame index so that you can do different things (such as offset to a different space of the sprite sheet) based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">given value.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Animation framework</span></strong><span class="koboSpan" id="kobo.139.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.140.1">animation framework</span></em><span class="koboSpan" id="kobo.141.1"> makes animating a GUI element easy by allowing</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.142.1"> its properties to be animated. </span><span class="koboSpan" id="kobo.142.2">The animations are controlled by using </span><em class="italic"><span class="koboSpan" id="kobo.143.1">easing curves</span></em><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">Easing curves describe a function that controls what the speed of the animation should be, resulting in different acceleration and deceleration patterns. </span><span class="koboSpan" id="kobo.144.3">The types of easing curves supported by Qt include linear, quadratic, cubic, quartic, sine, exponential, circular, </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">and elastic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.146.1">State machine framework</span></strong><span class="koboSpan" id="kobo.147.1">: Qt provides us with classes for creating and executing state graphs, which</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.148.1"> allow each GUI element to move from one state to another when triggered by signals. </span><span class="koboSpan" id="kobo.148.2">The </span><em class="italic"><span class="koboSpan" id="kobo.149.1">state graph</span></em><span class="koboSpan" id="kobo.150.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.151.1">state machine framework</span></em><span class="koboSpan" id="kobo.152.1"> is hierarchical, which means every state can also be nested inside of </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">other states.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">Graphics view framework</span></strong><span class="koboSpan" id="kobo.155.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.156.1">graphics view framework</span></em><span class="koboSpan" id="kobo.157.1"> is a powerful graphics engine for visualizing </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.158.1">and interacting with a large number of</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.159.1"> custom-made 2D graphical </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.160.1">items. </span><span class="koboSpan" id="kobo.160.2">You can use the graphics view framework to draw your GUI and have them animated in a totally manual way if you are an </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">experienced programmer.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.162.1">By making use of all of the powerful features we’ve mentioned here, we’re able to create an intuitive and modern GUI with ease. </span><span class="koboSpan" id="kobo.162.2">In this chapter, we will look into the practical approaches to animating GUI elements </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">using Qt.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.164.1">Using easing curves to control property animation</span></h1>
<p><span class="koboSpan" id="kobo.165.1">In this example, we will learn how to</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.166.1"> make our animation more interesting by utilizing </span><em class="italic"><span class="koboSpan" id="kobo.167.1">easing curves</span></em><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">We will still use the previous source code, which</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.169.1"> uses the property animation to animate a </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">push button.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.171.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.172.1">In the following example, we will learn how to add an </span><em class="italic"><span class="koboSpan" id="kobo.173.1">easing curve</span></em><span class="koboSpan" id="kobo.174.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">our animation:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.176.1">Define an easing curve and add it to the property animation before calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">start()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.179.1">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</span></pre></li> <li><span class="koboSpan" id="kobo.180.1">Call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">setLoopCount()</span></strong><span class="koboSpan" id="kobo.182.1"> function</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.183.1"> to set how many</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.184.1"> loops you want it to </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">repeat for:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.186.1">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(EasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;setLoopCount(2);
animation-&gt;start();</span></pre></li> <li><span class="koboSpan" id="kobo.187.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">setAmplitude()</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">setOvershoot()</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">setPeriod()</span></strong><span class="koboSpan" id="kobo.193.1"> before applying the easing curve to </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the animation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.195.1">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.196.1">It’s really that easy to </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.197.1">animate a widget or any object in Qt 6 using the built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">easing curves.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.199.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.200.1">To let an easing curve control the </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.201.1">animation, all you need to do is define an easing curve and add it to the property animation before calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">start()</span></strong><span class="koboSpan" id="kobo.203.1"> function. </span><span class="koboSpan" id="kobo.203.2">You can also try several other types of easing curves and see which one suits you best. </span><span class="koboSpan" id="kobo.203.3">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);</span></pre> <p><span class="koboSpan" id="kobo.206.1">If you want the animation to loop after it has finished playing, you can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">setLoopCount()</span></strong><span class="koboSpan" id="kobo.208.1"> function to set how many loops you want it to repeat for or set the value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">-1</span></strong><span class="koboSpan" id="kobo.210.1"> for an </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">infinite loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
animation-&gt;setLoopCount(-1);</span></pre> <p><span class="koboSpan" id="kobo.213.1">There are several parameters that you can set to refine the easing curve before applying it to the property animation. </span><span class="koboSpan" id="kobo.213.2">These parameters include </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">amplitude</span></strong><span class="koboSpan" id="kobo.215.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">overshoot</span></strong><span class="koboSpan" id="kobo.217.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.219.1">period</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Amplitude</span></strong><span class="koboSpan" id="kobo.222.1">: The higher the </span><em class="italic"><span class="koboSpan" id="kobo.223.1">amplitude</span></em><span class="koboSpan" id="kobo.224.1">, the higher the bounce or elastic spring effect that will be applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the</span></span><span class="No-Break"><a id="_idIndexMarker194"/></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1"> animation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">Overshoot</span></strong><span class="koboSpan" id="kobo.228.1">: Some curve functions</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.229.1"> will produce an </span><em class="italic"><span class="koboSpan" id="kobo.230.1">overshoot</span></em><span class="koboSpan" id="kobo.231.1"> (exceeding its final value) curve due to a damping effect. </span><span class="koboSpan" id="kobo.231.2">By adjusting the overshoot value, we are able to increase or decrease </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">this effect.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.233.1">Period</span></strong><span class="koboSpan" id="kobo.234.1">: Setting a small</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.235.1"> period value will give a high frequency to the curve. </span><span class="koboSpan" id="kobo.235.2">A large </span><em class="italic"><span class="koboSpan" id="kobo.236.1">period</span></em><span class="koboSpan" id="kobo.237.1"> will give it a </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">small frequency.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.239.1">These parameters, however, are not applicable to all curve types. </span><span class="koboSpan" id="kobo.239.2">Please refer to the Qt documentation to see which parameter is applicable to which </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">curve type.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.241.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.242.1">While the property </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.243.1">animation works perfectly fine, sometimes it feels a little boring to look at a GUI element being animated at a constant speed. </span><span class="koboSpan" id="kobo.243.2">We can make the animation look more interesting by adding an </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">easing curve</span></strong><span class="koboSpan" id="kobo.245.1"> to</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.246.1"> control the motion. </span><span class="koboSpan" id="kobo.246.2">There are many types of  easing curves that you can use in Qt, and here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">of them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.248.1"><img alt="Figure 3.2 – Different types of easing curves supported by Qt 6" src="image/B20976_03_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Figure 3.2 – Different types of easing curves supported by Qt 6</span></p>
<p><span class="koboSpan" id="kobo.250.1">As you can see from the </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.251.1">preceding diagram, each easing curve produces a different </span><em class="italic"><span class="koboSpan" id="kobo.252.1">ease-in and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.253.1">ease-out</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> effect.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.255.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.256.1">For the full list of easing curves available in Qt, please refer to the Qt documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">at </span></span><a href="http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum"><span class="No-Break"><span class="koboSpan" id="kobo.258.1">http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.259.1">.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.260.1">Creating an animation group</span></h1>
<p><span class="koboSpan" id="kobo.261.1">In this example, we will </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.262.1">learn how to use an </span><em class="italic"><span class="koboSpan" id="kobo.263.1">animation group</span></em><span class="koboSpan" id="kobo.264.1"> to manage the states of the animations contained in </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the group.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.266.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.267.1">Let’s create an </span><em class="italic"><span class="koboSpan" id="kobo.268.1">animation group</span></em><span class="koboSpan" id="kobo.269.1"> by following </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.271.1">We will use the previous example but, this time, we will add two more push buttons to the main window, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 3.3 – Adding three push buttons to the main window" src="image/B20976_03_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 3.3 – Adding three push buttons to the main window</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.275.1">Define the </span><em class="italic"><span class="koboSpan" id="kobo.276.1">animation</span></em><span class="koboSpan" id="kobo.277.1"> for each of the push buttons in the main </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">window’s constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.279.1">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 200, 100, 50));</span></pre></li> <li><span class="koboSpan" id="kobo.280.1">Create an </span><em class="italic"><span class="koboSpan" id="kobo.281.1">easing curve</span></em><span class="koboSpan" id="kobo.282.1"> and </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.283.1">apply the same curve to all </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">three animations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);</span></pre></li> <li><span class="koboSpan" id="kobo.286.1">Once you have applied the easing curve to all three animations, we will then create an </span><em class="italic"><span class="koboSpan" id="kobo.287.1">animation group</span></em><span class="koboSpan" id="kobo.288.1"> and add all three animations to </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the group:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
QParallelAnimationGroup *group = new QParallelAnimationGroup;
group-&gt;addAnimation(animation1);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation3);</span></pre></li> <li><span class="koboSpan" id="kobo.291.1">Call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">start()</span></strong><span class="koboSpan" id="kobo.293.1"> function</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.294.1"> from the animation group we </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">just created:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
group-&gt;start();</span></pre></li> </ol>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.297.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.298.1">Qt allows us to create multiple animations and group them into an animation group. </span><span class="koboSpan" id="kobo.298.2">A group is usually responsible for managing the state of its animations (that is, it decides when to start, stop, resume, and pause them). </span><span class="koboSpan" id="kobo.298.3">Currently, Qt provides two types of classes for animation groups: </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">QParallelAnimationGroup</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.300.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">QSequentialAnimationGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">QParallelAnimationGroup</span></strong><span class="koboSpan" id="kobo.304.1">: As its name implies, a </span><em class="italic"><span class="koboSpan" id="kobo.305.1">parallel animation group</span></em><span class="koboSpan" id="kobo.306.1"> runs all of the animations in its group at the same time. </span><span class="koboSpan" id="kobo.306.2">The group is deemed finished when the longest-lasting animation has </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">finished running.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">QSequentialAnimationGroup</span></strong><span class="koboSpan" id="kobo.309.1">: A </span><em class="italic"><span class="koboSpan" id="kobo.310.1">sequential animation group</span></em><span class="koboSpan" id="kobo.311.1"> runs its animations in sequence, meaning it will only run a single animation at a time and only play the next animation when the current one </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">has finished.</span></span></li>
</ul>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.313.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.314.1">Since we are using an animation group now, we no longer call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">start()</span></strong><span class="koboSpan" id="kobo.316.1"> function from the individual animation. </span><span class="koboSpan" id="kobo.316.2">Instead, we will be calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">start()</span></strong><span class="koboSpan" id="kobo.318.1"> function from the  animation group we just created. </span><span class="koboSpan" id="kobo.318.2">If you compile and run the example now, you will see all three buttons being played at the same</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.319.1"> time. </span><span class="koboSpan" id="kobo.319.2">This is because we are using the </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">parallel</span></strong><strong class="bold"><span class="koboSpan" id="kobo.321.1"> animation group</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">You can replace it with a </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">sequential animation group</span></strong><span class="koboSpan" id="kobo.324.1"> and run </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.325.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">example again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
QSequentialAnimationGroup *group = new QSequentialAnimationGroup;</span></pre> <p><span class="koboSpan" id="kobo.328.1">This time, only a single button will play its animation at a time, while the other buttons will wait patiently for their turn to come. </span><span class="koboSpan" id="kobo.328.2">The priority is set based on which animation is added to the animation group first. </span><span class="koboSpan" id="kobo.328.3">You can change the animation sequence by simply rearranging the</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.329.1"> sequence of an animation that’s being added to the group. </span><span class="koboSpan" id="kobo.329.2">For example, if we want button </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">3</span></strong><span class="koboSpan" id="kobo.331.1"> to start the animation first, followed by button </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">2</span></strong><span class="koboSpan" id="kobo.333.1">, and then button </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">1</span></strong><span class="koboSpan" id="kobo.335.1">, the code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
group-&gt;addAnimation(animation3);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation1);</span></pre> <p><span class="koboSpan" id="kobo.338.1">Since property animations and animation groups are both inherited from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">QAbstractAnimator</span></strong><span class="koboSpan" id="kobo.340.1"> class, it means that you can also add an animation group to another animation group to form a more complex, nested </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">animation group.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.342.1">Creating a nested animation group</span></h1>
<p><span class="koboSpan" id="kobo.343.1">One good example of using a </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">nested animation group</span></strong><span class="koboSpan" id="kobo.345.1"> is when you have several </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">parallel </span></strong><span class="koboSpan" id="kobo.347.1">animation groups and </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.348.1">you want to play the groups in </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">sequential order.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.350.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.351.1">Let’s follow these steps to create a </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">nested animation group</span></strong><span class="koboSpan" id="kobo.353.1"> to play different animation groups in a </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">sequential order:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.355.1">We will use the UI from the previous example and add a few more buttons to the main window, </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">like so:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 3.4 – We need even more buttons this time around" src="image/B20976_03_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 3.4 – We need even more buttons this time around</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.359.1">Create all of the animations</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.360.1"> for the buttons and then create an easing curve and apply it to all of </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the animations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.362.1">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 50, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 50, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 50, 100, 50));</span></pre></li> <li><span class="koboSpan" id="kobo.363.1">Next, apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">following </span></span><span class="No-Break"><a id="_idIndexMarker208"/></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
QPropertyAnimation *animation4 = new
QPropertyAnimation(ui-&gt;pushButton_4, "geometry");
animation4-&gt;setDuration(3000);
animation4-&gt;setStartValue(ui-&gt;pushButton_4-&gt;geometry());
animation4-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation5 = new
QPropertyAnimation(ui-&gt;pushButton_5, "geometry");
animation5-&gt;setDuration(3000);
animation5-&gt;setStartValue(ui-&gt;pushButton_5-&gt;geometry());
animation5-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation6 = new
QPropertyAnimation(ui-&gt;pushButton_6, "geometry");
animation6-&gt;setDuration(3000);
animation6-&gt;setStartValue(ui-&gt;pushButton_6-&gt;geometry());
animation6-&gt;setEndValue(QRect(250, 200, 100, 50));</span></pre></li> <li><span class="koboSpan" id="kobo.367.1">Then, apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);
animation4-&gt;setEasingCurve(curve);
animation5-&gt;setEasingCurve(curve);
animation6-&gt;setEasingCurve(curve);</span></pre></li> <li><span class="koboSpan" id="kobo.370.1">Create two </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">animation groups</span></strong><span class="koboSpan" id="kobo.372.1">, one</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.373.1"> for the buttons in the upper column and another one for the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">lower column:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
QParallelAnimationGroup *group1 = new QParallelAnimationGroup;
group1-&gt;addAnimation(animation1);
group1-&gt;addAnimation(animation2);
group1-&gt;addAnimation(animation3);
QParallelAnimationGroup *group2 = new QParallelAnimationGroup;
group2-&gt;addAnimation(animation4);
group2-&gt;addAnimation(animation5);
group2-&gt;addAnimation(animation6);</span></pre></li> <li><span class="koboSpan" id="kobo.376.1">We will create yet another </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">animation group</span></strong><span class="koboSpan" id="kobo.378.1">, which will be used to store the two animation groups we </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">created previously:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
QSequentialAnimationGroup *groupAll = new
QSequentialAnimationGroup;
groupAll-&gt;addAnimation(group1);
groupAll-&gt;addAnimation(group2);
groupAll-&gt;start();</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.381.1">A Nested animation group allows you to set up a more complex widget animation by combining different types of</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.382.1"> animations and executing them at your </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">desired orders.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.384.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.385.1">What we are trying to do here is play the animation of the buttons in the upper column first, followed by the buttons in the lower column. </span><span class="koboSpan" id="kobo.385.2">Since both of the animation groups are </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">parallel animation groups</span></strong><span class="koboSpan" id="kobo.387.1">, the </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.388.1">buttons belonging to the respective groups will be animated at the same time when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">start()</span></strong><span class="koboSpan" id="kobo.390.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">This time, however, the group is a </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">sequential animation group</span></strong><span class="koboSpan" id="kobo.394.1">, which means only a single parallel animation group will </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.395.1">be played at a time, followed by the other when the first one is finished. </span><span class="koboSpan" id="kobo.395.2">Animation groups are a very handy system that allows us to create very complex GUI animations with simple coding. </span><span class="koboSpan" id="kobo.395.3">Qt will handle the difficult part for us so that we don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">have to.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.397.1">State machines in Qt 6</span></h1>
<p><span class="koboSpan" id="kobo.398.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">state machine</span></strong><span class="koboSpan" id="kobo.400.1"> can be used for</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.401.1"> many purposes but, in this chapter, we will only cover topics</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.402.1"> related </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">to animation.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.404.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.405.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">State machine</span></strong><span class="koboSpan" id="kobo.407.1"> is not that hard to achieve in Qt at all. </span><span class="koboSpan" id="kobo.407.2">Let’s get started by following </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.409.1">We will set up a new user interface for our example program, which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">like this:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.411.1"><img alt="Figure 3.5 – Setting up the GUI for our state machine experiment" src="image/B20976_03_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.412.1">Figure 3.5 – Setting up the GUI for our state machine experiment</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.413.1">We will include</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.414.1"> some headers in our </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
#include &lt;QStateMachine&gt;
#include &lt;QPropertyAnimation&gt;
#include &lt;QEventTransition&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.417.1">In our main window’s constructor, add </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.418.1">the following code to create a </span><em class="italic"><span class="koboSpan" id="kobo.419.1">new state machine</span></em><span class="koboSpan" id="kobo.420.1"> and two </span><em class="italic"><span class="koboSpan" id="kobo.421.1">states</span></em><span class="koboSpan" id="kobo.422.1">, which we will be </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">using later:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
QStateMachine *machine = new QStateMachine(this);
QState *s1 = new QState();
QState *s2 = new QState();</span></pre></li> <li><span class="koboSpan" id="kobo.425.1">We will define what we should do</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.426.1"> within each state, which, in this case, will be to change the</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.427.1"> label’s </span><em class="italic"><span class="koboSpan" id="kobo.428.1">text</span></em><span class="koboSpan" id="kobo.429.1"> and the button’s </span><em class="italic"><span class="koboSpan" id="kobo.430.1">position</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.431.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">size</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.434.1">
QState *s1 = new QState();
s1-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 1");
s1-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(50, 200,
100, 50));
QState *s2 = new QState();
s2-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 2");
s2-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(200, 50,
140, 100));</span></pre></li> <li><span class="koboSpan" id="kobo.435.1">Once you are done with that, let’s proceed by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">event transition</span></strong><span class="koboSpan" id="kobo.437.1"> classes to our </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.439.1">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
s2-&gt;addTransition(t2);</span></pre></li> <li><span class="koboSpan" id="kobo.440.1">Add all of the states we have just created to the state machine and define state 1 as the </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">initial state</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">Then, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">machine-&gt;start()</span></strong><span class="koboSpan" id="kobo.444.1"> to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">state machine:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.446.1">
machine-&gt;addState(s1);
machine-&gt;addState(s2);
machine-&gt;setInitialState(s1);
machine-&gt;start();</span></pre></li> <li><span class="koboSpan" id="kobo.447.1">If you run the example </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.448.1">program now, you will notice that everything works fine, except </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.449.1">the button is not going through a smooth transition and it simply jumps instantly to the position and size we set previously. </span><span class="koboSpan" id="kobo.449.2">This is because we have not used a </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">property animation</span></strong><span class="koboSpan" id="kobo.451.1"> to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">smooth transition.</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">Go back to the event transition step and add the following lines </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">of code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s2-&gt;addTransition(t2);</span></pre></li> <li><span class="koboSpan" id="kobo.456.1">You can also add an </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.457.1">easing curve to the animation to make it look </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">more interesting:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.459.1">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(animation);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(animation);
s2-&gt;addTransition(t2);</span></pre></li> </ol>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.460.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.461.1">There are two push buttons </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.462.1">and a label on the main window layout. </span><span class="koboSpan" id="kobo.462.2">The button in the top-left corner will trigger the state change when pressed, while the label in the top-right corner will change its text to show which state we are currently in. </span><span class="koboSpan" id="kobo.462.3">the button below will animate according to the current state. </span><span class="koboSpan" id="kobo.462.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">QEventTransition</span></strong><span class="koboSpan" id="kobo.464.1"> classes define what will trigger the transition between one state </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">and another.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">In our case, we want the state to change from state 1 to state 2 when the </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">changeState</span></strong><span class="koboSpan" id="kobo.468.1"> button (the one in the upper-left) is clicked. </span><span class="koboSpan" id="kobo.468.2">After that, we also want to change from state 2 back to state 1 </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.469.1">when the same button is pressed again. </span><span class="koboSpan" id="kobo.469.2">This can be achieved by creating another </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.470.1">event transition class and setting the target state back to state 1. </span><span class="koboSpan" id="kobo.470.2">Then, add these transitions to their respective states. </span><span class="koboSpan" id="kobo.470.3">Instead of just assigning the properties directly to the widgets, we tell Qt to use the property animation class to smoothly interpolate the properties toward the target values. </span><span class="koboSpan" id="kobo.470.4">It is that simple! </span><span class="koboSpan" id="kobo.470.5">There is no need to set the start value and end value because we have already called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">assignProperty()</span></strong><span class="koboSpan" id="kobo.472.1"> function, which has automatically assigned the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">end value.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.474.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.475.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">state machine framework</span></strong><span class="koboSpan" id="kobo.477.1"> in Qt </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.478.1">provides classes for creating and executing state graphs. </span><span class="koboSpan" id="kobo.478.2">Qt’s event system is used to drive the state machines, where transitions between states can be triggered by using </span><em class="italic"><span class="koboSpan" id="kobo.479.1">signals</span></em><span class="koboSpan" id="kobo.480.1">, and then the </span><em class="italic"><span class="koboSpan" id="kobo.481.1">slots</span></em><span class="koboSpan" id="kobo.482.1"> on the other end will be invoked by the signals to perform an action, such as playing </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">an animation.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Once you understand the basics of state machines, you can use them to do other things as well. </span><span class="koboSpan" id="kobo.484.2">The state graph in the state machine framework is hierarchical. </span><span class="koboSpan" id="kobo.484.3">Just like the animation group in the previous section, states can also be nested inside of </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">other states:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.486.1"><img alt="Figure 3.6 – Nested state machines explained visually" src="image/B20976_03_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.487.1">Figure 3.6 – Nested state machines explained visually</span></p>
<p><span class="koboSpan" id="kobo.488.1">You can combine nested state machines and animations to create a very sophisticated GUI for </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">your application.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.490.1">States, transitions, and animations in QML</span></h1>
<p><span class="koboSpan" id="kobo.491.1">If you prefer to work with QML instead of C++, Qt also provides similar features in Qt Quick that allow you to easily </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.492.1">animate a GUI element with minimal lines of code. </span><span class="koboSpan" id="kobo.492.2">In this example, we will learn how to achieve this </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">with QML.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.494.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.495.1">Let’s get started by following these steps to create a window that continuously changes its </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">background color:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.497.1">We will create a new </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">Qt Quick Application</span></strong><span class="koboSpan" id="kobo.499.1"> project and set up our user interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">like so:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.501.1"><img alt="Figure 3.7 – A joyful application that constantly changes its background color" src="image/B20976_03_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Figure 3.7 – A joyful application that constantly changes its background color</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.503.1">Here is what </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.504.1">my </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">main.qml</span></strong><span class="koboSpan" id="kobo.506.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">looks like:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
import QtQuick
import QtQuick.Window
Window {
    visible: true
    width: 480;
    height: 320;
    Rectangle {
        id: background;
        anchors.fill: parent;
        color: "blue";
    }
    Text {
        text: qsTr("Hello World");
        anchors.centerIn: parent;
        color: "white";
        font.pointSize: 15;
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.509.1">Add the </span><em class="italic"><span class="koboSpan" id="kobo.510.1">color animation</span></em><span class="koboSpan" id="kobo.511.1"> to</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.512.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Rectangle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.514.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.515.1">
Rectangle {
    id: background;
    anchors.fill: parent;
    color: "blue";
    SequentialAnimation on color {
        ColorAnimation { to: "yellow"; duration: 1000 }
        ColorAnimation { to: "red"; duration: 1000 }
        ColorAnimation { to: "blue"; duration: 1000 }
        loops: Animation.Infinite;
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.516.1">Add a </span><em class="italic"><span class="koboSpan" id="kobo.517.1">number animation</span></em><span class="koboSpan" id="kobo.518.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">text</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.521.1">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.522.1">Add </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.523.1">another </span><em class="italic"><span class="koboSpan" id="kobo.524.1">number animation</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.525.1">to it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.526.1">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
    NumberAnimation on rotation {
        from: 0;
        to: 360;
        duration: 2000;
        loops: Animation.Infinite;
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.527.1">Define two </span><em class="italic"><span class="koboSpan" id="kobo.528.1">states</span></em><span class="koboSpan" id="kobo.529.1">, one called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">PRESSED</span></strong><span class="koboSpan" id="kobo.531.1"> state and another called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">RELEASED</span></strong><span class="koboSpan" id="kobo.533.1"> state. </span><span class="koboSpan" id="kobo.533.2">Then, set</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.534.1"> the default state </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">RELEASED</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.538.1">
Rectangle {
    id: background;
    anchors.fill: parent;
    state: "RELEASED";
    states: [
    State {
        name: "PRESSED"
        PropertyChanges { target: background; color: "blue"}
    },
    State {
        name: "RELEASED"
        PropertyChanges { target: background; color: "red"}
    }
    ]
}</span></pre></li> <li><span class="koboSpan" id="kobo.539.1">After that, create a mouse area within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Rectangle</span></strong><span class="koboSpan" id="kobo.541.1"> object so that we can click </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">on it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.543.1">
MouseArea {
    anchors.fill: parent;
    onPressed: background.state = "PRESSED";
    onReleased: background.state = "RELEASED";
}</span></pre></li> <li><span class="koboSpan" id="kobo.544.1">Add some transitions to</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.545.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">Rectangle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
transitions: [
    Transition {
        from: "PRESSED"
        to: "RELEASED"
        ColorAnimation { target: background; duration: 200}
    },
    Transition {
        from: "RELEASED"
        to: "PRESSED"
        ColorAnimation { target: background; duration: 200}
}
]</span></pre></li> </ol>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.549.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.550.1">The main window consists of a blue rectangle and static text that says </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">Hello World</span></strong><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">We want the background color to change from blue to yellow, then to red, and back to blue in a loop. </span><span class="koboSpan" id="kobo.552.3">This can be easily achieved by using the </span><em class="italic"><span class="koboSpan" id="kobo.553.1">color animation</span></em><span class="koboSpan" id="kobo.554.1"> type in QML. </span><span class="koboSpan" id="kobo.554.2">What we are doing in </span><em class="italic"><span class="koboSpan" id="kobo.555.1">step 3</span></em><span class="koboSpan" id="kobo.556.1"> is basically</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.557.1"> creating a </span><em class="italic"><span class="koboSpan" id="kobo.558.1">sequential animation group</span></em><span class="koboSpan" id="kobo.559.1"> within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Rectangle</span></strong><span class="koboSpan" id="kobo.561.1"> object, then creating three different </span><em class="italic"><span class="koboSpan" id="kobo.562.1">color animations</span></em><span class="koboSpan" id="kobo.563.1"> within the group, which will change the color of the object every 1,000 milliseconds (1 second). </span><span class="koboSpan" id="kobo.563.2">We also set the animations to </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">loop infinitely.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">In </span><em class="italic"><span class="koboSpan" id="kobo.566.1">step 4</span></em><span class="koboSpan" id="kobo.567.1">, we want to use the </span><em class="italic"><span class="koboSpan" id="kobo.568.1">number animation</span></em><span class="koboSpan" id="kobo.569.1"> to animate the alpha value of the static text. </span><span class="koboSpan" id="kobo.569.2">We created another </span><em class="italic"><span class="koboSpan" id="kobo.570.1">sequential animation group</span></em><span class="koboSpan" id="kobo.571.1"> within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Text</span></strong><span class="koboSpan" id="kobo.573.1"> object and created two </span><em class="italic"><span class="koboSpan" id="kobo.574.1">number animations</span></em><span class="koboSpan" id="kobo.575.1"> to animate the alpha value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">0</span></strong><span class="koboSpan" id="kobo.577.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">1</span></strong><span class="koboSpan" id="kobo.579.1"> and back. </span><span class="koboSpan" id="kobo.579.2">Then, we set the animations to </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">loop infinitely.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Then, in </span><em class="italic"><span class="koboSpan" id="kobo.582.1">step 5</span></em><span class="koboSpan" id="kobo.583.1">, we rotate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">Hello World</span></strong><span class="koboSpan" id="kobo.585.1"> text by adding another </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">number animation</span></strong><span class="koboSpan" id="kobo.587.1"> to it. </span><span class="koboSpan" id="kobo.587.2">In </span><em class="italic"><span class="koboSpan" id="kobo.588.1">step 6</span></em><span class="koboSpan" id="kobo.589.1">, we wanted to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Rectangle</span></strong><span class="koboSpan" id="kobo.591.1"> object change from one color to another when we clicked on it. </span><span class="koboSpan" id="kobo.591.2">When the mouse is released, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Rectangle</span></strong><span class="koboSpan" id="kobo.593.1"> object will change back to its initial color. </span><span class="koboSpan" id="kobo.593.2">To achieve that, we first need to define the two states, one called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">PRESSED</span></strong><span class="koboSpan" id="kobo.595.1"> state and another called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">RELEASED</span></strong><span class="koboSpan" id="kobo.597.1"> state. </span><span class="koboSpan" id="kobo.597.2">Then, we set the default state </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">RELEASED</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">Now, when you compile and run the example, the background will instantly change color to blue when pressed and change back to red when the mouse is released. </span><span class="koboSpan" id="kobo.601.2">That works great, and we can further enhance it by giving it a little transition when switching color. </span><span class="koboSpan" id="kobo.601.3">This can be easily achieved by adding transitions to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Rectangle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> object.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.604.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.605.1">In QML, there are eight different types of property animation you can use, and these are </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.607.1">Anchor animation</span></strong><span class="koboSpan" id="kobo.608.1">: Animates</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.609.1"> changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">anchor </span></span><span class="No-Break"><a id="_idIndexMarker234"/></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.612.1">Color animation</span></strong><span class="koboSpan" id="kobo.613.1">: Animates </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.614.1">changes</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.615.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">color values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.617.1">Number animation</span></strong><span class="koboSpan" id="kobo.618.1">: Animates </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.619.1">changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">qreal-type</span></span><span class="No-Break"><a id="_idIndexMarker238"/></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1"> values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.622.1">Parent animation</span></strong><span class="koboSpan" id="kobo.623.1">: Animates </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.624.1">changes</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.625.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">parent values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">Path animation</span></strong><span class="koboSpan" id="kobo.628.1">: Animates</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.629.1"> an item </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.630.1">along </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">a path</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.632.1">Property animation</span></strong><span class="koboSpan" id="kobo.633.1">: Animates </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.634.1">changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">property values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.636.1">Rotation animation</span></strong><span class="koboSpan" id="kobo.637.1">: Animates </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.638.1">changes</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.639.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">rotation values</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.641.1">Vector3d animation</span></strong><span class="koboSpan" id="kobo.642.1">: Animates</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.643.1"> changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">QVector3D</span></span><span class="No-Break"><a id="_idIndexMarker247"/></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> values</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.646.1">Just like the C++ version, these animations can also be grouped together in an animation group to play the animations in sequence or parallel. </span><span class="koboSpan" id="kobo.646.2">You can also control the animations using easing curves and determine when to play these animations using state machines, just like we</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.647.1"> did in the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">previous section.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.649.1">Animating widget properties using animators</span></h1>
<p><span class="koboSpan" id="kobo.650.1">In this recipe, we will learn how to </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.651.1">animate the properties of our GUI </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.652.1">widgets using the animator feature that’s provided </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">by QML.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.654.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.655.1">Animating QML objects is really easy if you perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.657.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Rectangle</span></strong><span class="koboSpan" id="kobo.659.1"> object and add a </span><em class="italic"><span class="koboSpan" id="kobo.660.1">scale animator</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.661.1">to it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
Rectangle {
    id: myBox;
    width: 50;
    height: 50;
    anchors.horizontalCenter: parent.horizontalCenter;
    anchors.verticalCenter: parent.verticalCenter;
    color: "blue";
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
        running: true;
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.663.1">Add a </span><em class="italic"><span class="koboSpan" id="kobo.664.1">rotation animator</span></em><span class="koboSpan" id="kobo.665.1"> and set</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.666.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">running</span></strong><span class="koboSpan" id="kobo.668.1"> value in the parallel animation group, but not in any of </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.669.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">individual animators:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.671.1">
ParallelAnimation {
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
    }
    RotationAnimator {
        target: myBox;
        from: 0;
        to: 360;
        duration: 1000;
    }
    running: true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.672.1">Add an </span><em class="italic"><span class="koboSpan" id="kobo.673.1">easing curve</span></em><span class="koboSpan" id="kobo.674.1"> to</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.675.1"> the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.676.1">scale animator</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.678.1">
ScaleAnimator {
    target: myBox;
    from: 5;
    to: 1;
    duration: 2000;
    easing.type: Easing.InOutElastic;
    easing.amplitude: 2.0;
    easing.period: 1.5;
    running: true;
}</span></pre></li> </ol>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.679.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.680.1">The </span><em class="italic"><span class="koboSpan" id="kobo.681.1">animator</span></em><span class="koboSpan" id="kobo.682.1"> type can be used just like any other </span><em class="italic"><span class="koboSpan" id="kobo.683.1">animation</span></em><span class="koboSpan" id="kobo.684.1"> type. </span><span class="koboSpan" id="kobo.684.2">We want to scale a rectangle from a size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">5</span></strong><span class="koboSpan" id="kobo.686.1"> to a size </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.687.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">1</span></strong><span class="koboSpan" id="kobo.689.1"> within 2,000 milliseconds (2 seconds). </span><span class="koboSpan" id="kobo.689.2">We created a blue </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Rectangle</span></strong><span class="koboSpan" id="kobo.691.1"> object and added a </span><em class="italic"><span class="koboSpan" id="kobo.692.1">scale animator</span></em><span class="koboSpan" id="kobo.693.1"> to it. </span><span class="koboSpan" id="kobo.693.2">We set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">initial</span></strong><span class="koboSpan" id="kobo.695.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">5</span></strong><span class="koboSpan" id="kobo.697.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">final</span></strong><span class="koboSpan" id="kobo.699.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">1</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">Then, we set the animation </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">duration</span></strong><span class="koboSpan" id="kobo.703.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">2000</span></strong><span class="koboSpan" id="kobo.705.1"> and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">running</span></strong><span class="koboSpan" id="kobo.707.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">true</span></strong><span class="koboSpan" id="kobo.709.1"> so that it will be played when the </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">program starts.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">Just like the animation types, animators can also be put into</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.712.1"> groups (that is, </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">parallel </span></strong><strong class="bold"><span class="koboSpan" id="kobo.714.1">animation groups</span></strong><span class="koboSpan" id="kobo.715.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.716.1">sequential animation groups</span></strong><span class="koboSpan" id="kobo.717.1">). </span><span class="koboSpan" id="kobo.717.2">An animation group will also be treated as an animator by QtQuick and </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.718.1">be run on the scene graph’s rendering thread whenever possible. </span><span class="koboSpan" id="kobo.718.2">In step 2, we want to group two different animators into a </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">parallel animation group</span></strong><span class="koboSpan" id="kobo.720.1"> so that they run together at the </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">We will keep the </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">scale animator</span></strong><span class="koboSpan" id="kobo.724.1"> we created previously and add another </span><strong class="bold"><span class="koboSpan" id="kobo.725.1">rotation animator</span></strong><span class="koboSpan" id="kobo.726.1"> to rotate the </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">Rectangle</span></strong><span class="koboSpan" id="kobo.728.1"> object. </span><span class="koboSpan" id="kobo.728.2">This time, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">running</span></strong><span class="koboSpan" id="kobo.730.1"> value in the parallel animation group, but not in any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">individual animators.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Just like the C++ version, QML also supports </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">easing curves</span></strong><span class="koboSpan" id="kobo.734.1">, and they can be easily applied to any of the animations or </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">animator types.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.736.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.737.1">There is something called an </span><em class="italic"><span class="koboSpan" id="kobo.738.1">animator</span></em><span class="koboSpan" id="kobo.739.1"> in QML, which</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.740.1"> is different from the usual </span><em class="italic"><span class="koboSpan" id="kobo.741.1">animation</span></em><span class="koboSpan" id="kobo.742.1"> type, even though there is </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.743.1">some similarity between them. </span><span class="koboSpan" id="kobo.743.2">Unlike regular animation types, animator types</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.744.1"> are directly operated on Qt Quick’s </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">scene graph</span></strong><span class="koboSpan" id="kobo.746.1">, rather than </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.747.1">the QML objects and their properties. </span><span class="koboSpan" id="kobo.747.2">The value of the QML property will not be changed while the animation is running, as it will only change once the animation is finished. </span><span class="koboSpan" id="kobo.747.3">The benefit of using the animator type is that it operates directly </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.748.1">on the scene graph’s rendering thread, which means its performance will be slightly better than running on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.749.1">UI thread</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.751.1">Sprite animation</span></h1>
<p><span class="koboSpan" id="kobo.752.1">In this example, we will learn how</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.753.1"> to create a </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">sprite animation</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.755.1">in </span></span><span class="No-Break"><a id="_idIndexMarker263"/></span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">QML.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.757.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.758.1">Let’s make a horse run across our application window by following </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.760.1">We will need to add our sprite sheet to Qt’s </span><em class="italic"><span class="koboSpan" id="kobo.761.1">resource system</span></em><span class="koboSpan" id="kobo.762.1"> so that it can be used in the program. </span><span class="koboSpan" id="kobo.762.2">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">qml.qrc</span></strong><span class="koboSpan" id="kobo.764.1"> and click the </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">Add</span></strong><span class="koboSpan" id="kobo.766.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">Add Files</span></strong><span class="koboSpan" id="kobo.768.1"> buttons. </span><span class="koboSpan" id="kobo.768.2">Select your sprite sheet image and save the resource file by pressing </span><em class="italic"><span class="koboSpan" id="kobo.769.1">Ctrl</span></em><span class="koboSpan" id="kobo.770.1"> + </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.771.1">S</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.773.1">Create a new empty window </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">main.qml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.777.1">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true
    width: 420
    height: 380
    Rectangle {
        anchors.fill: parent
        color: "white"
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.778.1">Once you are done </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.779.1">with that, we will start creating</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.780.1"> an </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">AnimatedSprite</span></strong><span class="koboSpan" id="kobo.782.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">in QML:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.784.1">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true;
    width: 420;
    height: 380;
    Rectangle {
        anchors.fill: parent;
        color: "white";
     }</span></pre></li> <li><span class="koboSpan" id="kobo.785.1">Then, set </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
     AnimatedSprite {
         id: sprite;
        width: 128;
        height: 128;
        anchors.centerIn: parent;
         source: "qrc:///horse_1.png";
         frameCount: 11;
         frameWidth: 128;
         frameHeight: 128;
         frameRate: 25;
         loops: Animation.Infinite;
         running: true;
     }
}</span></pre></li> <li><span class="koboSpan" id="kobo.788.1">Add a </span><em class="italic"><span class="koboSpan" id="kobo.789.1">mouse area</span></em><span class="koboSpan" id="kobo.790.1"> to </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.791.1">the window and check for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">onClicked</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.793.1"> event:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.794.1">
MouseArea {
    anchors.fill: parent;
    onClicked: {
        if (sprite.paused)
            sprite.resume();
        else
            sprite.pause();
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.795.1">If you compile and run </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.796.1">the example program now, you will see a little pony running in the middle of the window. </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">How fun:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.798.1"><img alt="Figure 3.8 – A horse running across the application window" src="image/B20976_03_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.799.1">Figure 3.8 – A horse running across the application window</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.800.1">Next, we want to try and do </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.801.1">something cool. </span><span class="koboSpan" id="kobo.801.2">We will make the horse run </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.802.1">across the window and loop infinitely while playing its running animation! </span><span class="koboSpan" id="kobo.802.2">First, we need to remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">anchors.centerIn: parent</span></strong><span class="koboSpan" id="kobo.804.1"> from QML and replace it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">x</span></strong><span class="koboSpan" id="kobo.806.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> values:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.809.1">
AnimatedSprite {
    id: sprite;
     width: 128;
     height: 128;
     </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">x: -128;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.811.1">     y: parent.height / 2;</span></strong><span class="koboSpan" id="kobo.812.1">
     source: "qrc:///horse_1.png";
     frameCount: 11;
     frameWidth: 128;
     frameHeight: 128;
     frameRate: 25;
     loops: Animation.Infinite;
     running: true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.813.1">Add a </span><em class="italic"><span class="koboSpan" id="kobo.814.1">number animation</span></em><span class="koboSpan" id="kobo.815.1"> to the sprite</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.816.1"> object and set its properties, </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">as</span></span><span class="No-Break"><a id="_idIndexMarker271"/></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1"> follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.819.1">
NumberAnimation {
    target: sprite;
    property: "x";
     from: -128;
     to: 512;
     duration: 3000;
     loops: Animation.Infinite;
     running: true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.820.1">If you compile and run the example program now, you will see the pony go crazy and start running across </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">the window!</span></span></li>
</ol>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.822.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.823.1">In this recipe, we place the animated sprite object in the middle of the window and set its image source to the sprite sheet that we have just added to the project resource. </span><span class="koboSpan" id="kobo.823.2">Then, we count how many frames there are in the sprite sheet that belong to the running animation, which in this case is 11 frames. </span><span class="koboSpan" id="kobo.823.3">We also inform Qt of the dimensions of each frame of the animation, which in this case are </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">128 x 128</span></strong><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">After that, we set the frame rate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">25</span></strong><span class="koboSpan" id="kobo.827.1"> to get a decent speed and then set it to loop infinitely. </span><span class="koboSpan" id="kobo.827.2">We then set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">running</span></strong><span class="koboSpan" id="kobo.829.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">true</span></strong><span class="koboSpan" id="kobo.831.1"> so that</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.832.1"> the animation will play by default when the program </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">starts running.</span></span></p>
<p><span class="koboSpan" id="kobo.834.1">Then, in </span><em class="italic"><span class="koboSpan" id="kobo.835.1">step 4</span></em><span class="koboSpan" id="kobo.836.1">, we want to be </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.837.1">able to pause the animation and resume it by clicking on the window. </span><span class="koboSpan" id="kobo.837.2">We simply check whether the sprite is currently paused when clicking on the mouse area. </span><span class="koboSpan" id="kobo.837.3">If the sprite animation is paused, then the animation resumes; otherwise, the animation </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">is paused.</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">In </span><em class="italic"><span class="koboSpan" id="kobo.840.1">step 6</span></em><span class="koboSpan" id="kobo.841.1">, we replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">anchors.centerIn</span></strong><span class="koboSpan" id="kobo.843.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">x</span></strong><span class="koboSpan" id="kobo.845.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">y</span></strong><span class="koboSpan" id="kobo.847.1"> values so that the animated sprite object is not anchored to the center of the window, which would make it impossible to move around. </span><span class="koboSpan" id="kobo.847.2">Then, we create a </span><em class="italic"><span class="koboSpan" id="kobo.848.1">number animation</span></em><span class="koboSpan" id="kobo.849.1"> within the animated sprite to animate its </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">x</span></strong><span class="koboSpan" id="kobo.851.1"> property. </span><span class="koboSpan" id="kobo.851.2">We set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">start</span></strong><span class="koboSpan" id="kobo.853.1"> value to somewhere outside the window on the left side, and we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">end</span></strong><span class="koboSpan" id="kobo.855.1"> value to somewhere outside the window on the right side. </span><span class="koboSpan" id="kobo.855.2">After that, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">duration</span></strong><span class="koboSpan" id="kobo.857.1"> to 3,000 milliseconds (3 seconds) and make it </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">loop infinitely.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">Lastly, we also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">running</span></strong><span class="koboSpan" id="kobo.861.1"> value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">true</span></strong><span class="koboSpan" id="kobo.863.1"> so that it plays the animation by default when the program </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">starts running.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.865.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.866.1">Sprite animation is used extensively, especially in game development. </span><span class="koboSpan" id="kobo.866.2">Sprites are used for character animation, particle animation, and even GUI animation. </span><span class="koboSpan" id="kobo.866.3">A sprite sheet consists of many images combined into one, which can then be chopped down and displayed on the screen, one at a time. </span><span class="koboSpan" id="kobo.866.4">The transitions between different images (or sprites) from the sprite sheet creates the illusion of animation, which we usually refer to as a sprite animation. </span><span class="koboSpan" id="kobo.866.5">A Sprite animation can be easily achieved in QML using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">AnimatedSprite</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.868.1"> type.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.869.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.870.1">In this example program, I am using a free</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.871.1"> and open source image that was created by </span><strong class="bold"><span class="koboSpan" id="kobo.872.1">bluecarrot16</span></strong><span class="koboSpan" id="kobo.873.1"> under the </span><em class="italic"><span class="koboSpan" id="kobo.874.1">CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0</span></em><span class="koboSpan" id="kobo.875.1"> license. </span><span class="koboSpan" id="kobo.875.2">The image can be obtained legally </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">at </span></span><a href="http://opengameart.org/content/lpc-horse"><span class="No-Break"><span class="koboSpan" id="kobo.877.1">http://opengameart.org/content/lpc-horse</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.878.1">.</span></span></p>
</div>
</body></html>