<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-55"><a id="_idTextAnchor055"/>3</h1>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>States and Animations with Qt and QML</h1>
<p>Qt provides an easy way to animate widgets or any other objects that inherit the <code>QObject</code> class through its powerful animation framework. The animation can be used either on its own or together with the <strong class="bold">state machine framework</strong>, which allows different animations to be played based on the current active state of the widget. Qt’s animation framework also supports grouped animation, which allows you to move more than one graphics item simultaneously or move them in sequence, one after the other.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Property animation in Qt</li>
<li>Using easing curves to control property animation</li>
<li>Creating an animation group</li>
<li>Creating a nested animation group</li>
<li>State machines in Qt</li>
<li>States, transitions, and animations in QML</li>
<li>Animating widget properties using animators</li>
<li>Sprite animation</li>
</ul>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/>Technical requirements</h1>
<p>The technical requirements for this chapter include <strong class="bold">Qt 6.6.1 MinGW 64-bit</strong>, <strong class="bold">Qt Creator 12.0.2</strong>, and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository at <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03</a>.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Property animation in Qt</h1>
<p>In this example, we will learn how to animate our <code>property animation</code> class, a<a id="_idIndexMarker174"/> part of its powerful animation<a id="_idIndexMarker175"/> framework that<a id="_idIndexMarker176"/> allows us to create fluid-looking animations with minimal effort.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>How to do it…</h2>
<p>In the following example, we will create a new widget project and animate the push button by changing its properties:</p>
<ol>
<li>Let’s create a new <code>mainwindow.ui</code> with Qt Designer and place a button on the main window, as shown here:</li>
</ol>
<div><div><img alt="Figure 3.1 – Dragging and dropping a push button to the UI canvas" src="img/B20976_03_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Dragging and dropping a push button to the UI canvas</p>
<ol>
<li value="2">Open up <code>mainwindow.cpp</code> and add the following line of code at the beginning of the source code:<pre class="source-code">
#include &lt;QPropertyAnimation&gt;</pre></li> <li>After that, open up <code>mainwindow.cpp</code> and add the following code to the constructor:<pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(10000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
animation-&gt;start();</pre></li> </ol>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>How it works…</h2>
<p>One of the more<a id="_idIndexMarker177"/> common methods of animating a GUI element is through the property animation class provided by Qt, known as the <code>QPropertyAnimation</code> class. This class is part of the animation framework and it makes use of the timer system in Qt to change the properties of a GUI element over a given duration.</p>
<p>What we are trying to <a id="_idIndexMarker178"/>accomplish here is animating the button from one position to another while, at the same time, enlarging the button size along the way. By including the <code>QPropertyAnimation</code> header in our source code in <em class="italic">step 2</em>, we will be able to access the <code>QPropertyAnimation</code> class provided by Qt and make use of its functionalities.</p>
<p>The code in <em class="italic">step 3</em> basically creates a new <em class="italic">property animation</em> and applies it to the <code>property animation</code> class changes the geometry properties of the <em class="italic">push button</em> and sets its duration to 3,000 milliseconds (3 seconds).</p>
<p>Then, the start value of the animation is set to the initial geometry of the <em class="italic">push button</em> because, obviously, we want it to start from where we initially placed the button in Qt Designer. The <code>end</code> value is then set to what we want it to become; in this case, we will move the button to a new position at <code>x: 200</code> and <code>y: 200</code> while changing its size to <code>width: 100</code> and <code>height: 50</code> along the way.</p>
<p>After that, call <code>animation</code> | <code>start()</code> to start the animation. Compile and run the project. You should see the<a id="_idIndexMarker179"/> button start to move slowly across the main window while expanding in size a bit<a id="_idIndexMarker180"/> at a time until it reaches its destination. You can change the animation duration and the target position and scale by altering the values in the preceding code. It is really that simple to animate a GUI element using Qt’s property animation system!</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>There’s more…</h2>
<p>Qt provides us with several different sub-systems to create animations for our GUI, including the timer, timeline, animation framework, state machine framework, and graphics view framework:</p>
<ul>
<li><code>event callback</code> function will be triggered through Qt’s <em class="italic">signal-and-slot</em> mechanism. You can make use of a timer to change the properties (color, position, scale, and so on) of your GUI element within a given interval to create an animation.</li>
<li><strong class="bold">Timeline</strong>: The <em class="italic">Timeline</em> calls a slot periodically to animate a GUI element. It is quite similar to a <em class="italic">repetitive timer</em>, but instead of doing the same thing all of the time when the slot is triggered, the timeline provides a value to the slot to indicate its current <a id="_idIndexMarker182"/>frame index so that you can do different things (such as offset to a different space of the sprite sheet) based on the given value.</li>
<li><strong class="bold">Animation framework</strong>: The <em class="italic">animation framework</em> makes animating a GUI element easy by allowing<a id="_idIndexMarker183"/> its properties to be animated. The animations are controlled by using <em class="italic">easing curves</em>. Easing curves describe a function that controls what the speed of the animation should be, resulting in different acceleration and deceleration patterns. The types of easing curves supported by Qt include linear, quadratic, cubic, quartic, sine, exponential, circular, and elastic.</li>
<li><strong class="bold">State machine framework</strong>: Qt provides us with classes for creating and executing state graphs, which<a id="_idIndexMarker184"/> allow each GUI element to move from one state to another when triggered by signals. The <em class="italic">state graph</em> in the <em class="italic">state machine framework</em> is hierarchical, which means every state can also be nested inside of other states.</li>
<li><strong class="bold">Graphics view framework</strong>: The <em class="italic">graphics view framework</em> is a powerful graphics engine for visualizing <a id="_idIndexMarker185"/>and interacting with a large number of<a id="_idIndexMarker186"/> custom-made 2D graphical <a id="_idIndexMarker187"/>items. You can use the graphics view framework to draw your GUI and have them animated in a totally manual way if you are an experienced programmer.</li>
</ul>
<p>By making use of all of the powerful features we’ve mentioned here, we’re able to create an intuitive and modern GUI with ease. In this chapter, we will look into the practical approaches to animating GUI elements using Qt.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Using easing curves to control property animation</h1>
<p>In this example, we will learn how to<a id="_idIndexMarker188"/> make our animation more interesting by utilizing <em class="italic">easing curves</em>. We will still use the previous source code, which<a id="_idIndexMarker189"/> uses the property animation to animate a push button.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>How to do it…</h2>
<p>In the following example, we will learn how to add an <em class="italic">easing curve</em> to our animation:</p>
<ol>
<li>Define an easing curve and add it to the property animation before calling the <code>start()</code> function:<pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre></li> <li>Call the <code>setLoopCount()</code> function<a id="_idIndexMarker190"/> to set how many<a id="_idIndexMarker191"/> loops you want it to repeat for:<pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(EasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;setLoopCount(2);
animation-&gt;start();</pre></li> <li>Call <code>setAmplitude()</code>, <code>setOvershoot()</code>, and <code>setPeriod()</code> before applying the easing curve to the animation:<pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre></li> </ol>
<p>It’s really that easy to <a id="_idIndexMarker192"/>animate a widget or any object in Qt 6 using the built-in easing curves.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>How it works...</h2>
<p>To let an easing curve control the <a id="_idIndexMarker193"/>animation, all you need to do is define an easing curve and add it to the property animation before calling the <code>start()</code> function. You can also try several other types of easing curves and see which one suits you best. Here is an example:</p>
<pre class="source-code">
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);</pre> <p>If you want the animation to loop after it has finished playing, you can call the <code>setLoopCount()</code> function to set how many loops you want it to repeat for or set the value to <code>-1</code> for an infinite loop:</p>
<pre class="source-code">
animation-&gt;setLoopCount(-1);</pre> <p>There are several parameters that you can set to refine the easing curve before applying it to the property animation. These parameters include <strong class="bold">amplitude</strong>, <strong class="bold">overshoot</strong>, and <strong class="bold">period</strong>:</p>
<ul>
<li><strong class="bold">Amplitude</strong>: The higher the <em class="italic">amplitude</em>, the higher the bounce or elastic spring effect that will be applied to the<a id="_idIndexMarker194"/> animation.</li>
<li><strong class="bold">Overshoot</strong>: Some curve functions<a id="_idIndexMarker195"/> will produce an <em class="italic">overshoot</em> (exceeding its final value) curve due to a damping effect. By adjusting the overshoot value, we are able to increase or decrease this effect.</li>
<li><strong class="bold">Period</strong>: Setting a small<a id="_idIndexMarker196"/> period value will give a high frequency to the curve. A large <em class="italic">period</em> will give it a small frequency.</li>
</ul>
<p>These parameters, however, are not applicable to all curve types. Please refer to the Qt documentation to see which parameter is applicable to which curve type.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>There’s more...</h2>
<p>While the property <a id="_idIndexMarker197"/>animation works perfectly fine, sometimes it feels a little boring to look at a GUI element being animated at a constant speed. We can make the animation look more interesting by adding an <strong class="bold">easing curve</strong> to<a id="_idIndexMarker198"/> control the motion. There are many types of  easing curves that you can use in Qt, and here are some of them:</p>
<div><div><img alt="Figure 3.2 – Different types of easing curves supported by Qt 6" src="img/B20976_03_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Different types of easing curves supported by Qt 6</p>
<p>As you can see from the <a id="_idIndexMarker199"/>preceding diagram, each easing curve produces a different <em class="italic">ease-in and </em><em class="italic">ease-out</em> effect.</p>
<p class="callout-heading">Note</p>
<p class="callout">For the full list of easing curves available in Qt, please refer to the Qt documentation at <a href="http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum">http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum</a>.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Creating an animation group</h1>
<p>In this example, we will <a id="_idIndexMarker200"/>learn how to use an <em class="italic">animation group</em> to manage the states of the animations contained in the group.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>How to do it…</h2>
<p>Let’s create an <em class="italic">animation group</em> by following these steps:</p>
<ol>
<li>We will use the previous example but, this time, we will add two more push buttons to the main window, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 3.3 – Adding three push buttons to the main window" src="img/B20976_03_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Adding three push buttons to the main window</p>
<ol>
<li value="2">Define the <em class="italic">animation</em> for each of the push buttons in the main window’s constructor:<pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 200, 100, 50));</pre></li> <li>Create an <em class="italic">easing curve</em> and <a id="_idIndexMarker201"/>apply the same curve to all three animations:<pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);</pre></li> <li>Once you have applied the easing curve to all three animations, we will then create an <em class="italic">animation group</em> and add all three animations to the group:<pre class="source-code">
QParallelAnimationGroup *group = new QParallelAnimationGroup;
group-&gt;addAnimation(animation1);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation3);</pre></li> <li>Call the <code>start()</code> function<a id="_idIndexMarker202"/> from the animation group we just created:<pre class="source-code">
group-&gt;start();</pre></li> </ol>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>How it works…</h2>
<p>Qt allows us to create multiple animations and group them into an animation group. A group is usually responsible for managing the state of its animations (that is, it decides when to start, stop, resume, and pause them). Currently, Qt provides two types of classes for animation groups: <code>QParallelAnimationGroup</code> and <code>QSequentialAnimationGroup</code>:</p>
<ul>
<li><code>QParallelAnimationGroup</code>: As its name implies, a <em class="italic">parallel animation group</em> runs all of the animations in its group at the same time. The group is deemed finished when the longest-lasting animation has finished running.</li>
<li><code>QSequentialAnimationGroup</code>: A <em class="italic">sequential animation group</em> runs its animations in sequence, meaning it will only run a single animation at a time and only play the next animation when the current one has finished.</li>
</ul>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>There’s more…</h2>
<p>Since we are using an animation group now, we no longer call the <code>start()</code> function from the individual animation. Instead, we will be calling the <code>start()</code> function from the  animation group we just created. If you compile and run the example now, you will see all three buttons being played at the same<a id="_idIndexMarker203"/> time. This is because we are using the <strong class="bold">parallel</strong><strong class="bold"> animation group</strong>. You can replace it with a <strong class="bold">sequential animation group</strong> and run <a id="_idIndexMarker204"/>the example again:</p>
<pre class="source-code">
QSequentialAnimationGroup *group = new QSequentialAnimationGroup;</pre> <p>This time, only a single button will play its animation at a time, while the other buttons will wait patiently for their turn to come. The priority is set based on which animation is added to the animation group first. You can change the animation sequence by simply rearranging the<a id="_idIndexMarker205"/> sequence of an animation that’s being added to the group. For example, if we want button <code>3</code> to start the animation first, followed by button <code>2</code>, and then button <code>1</code>, the code will look like this:</p>
<pre class="source-code">
group-&gt;addAnimation(animation3);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation1);</pre> <p>Since property animations and animation groups are both inherited from the <code>QAbstractAnimator</code> class, it means that you can also add an animation group to another animation group to form a more complex, nested animation group.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Creating a nested animation group</h1>
<p>One good example of using a <strong class="bold">nested animation group</strong> is when you have several <strong class="bold">parallel </strong>animation groups and <a id="_idIndexMarker206"/>you want to play the groups in sequential order.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>How to do it…</h2>
<p>Let’s follow these steps to create a <strong class="bold">nested animation group</strong> to play different animation groups in a sequential order:</p>
<ol>
<li>We will use the UI from the previous example and add a few more buttons to the main window, like so:</li>
</ol>
<div><div><img alt="Figure 3.4 – We need even more buttons this time around" src="img/B20976_03_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – We need even more buttons this time around</p>
<ol>
<li value="2">Create all of the animations<a id="_idIndexMarker207"/> for the buttons and then create an easing curve and apply it to all of the animations:<pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 50, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 50, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 50, 100, 50));</pre></li> <li>Next, apply the following <a id="_idIndexMarker208"/>code:<pre class="source-code">
QPropertyAnimation *animation4 = new
QPropertyAnimation(ui-&gt;pushButton_4, "geometry");
animation4-&gt;setDuration(3000);
animation4-&gt;setStartValue(ui-&gt;pushButton_4-&gt;geometry());
animation4-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation5 = new
QPropertyAnimation(ui-&gt;pushButton_5, "geometry");
animation5-&gt;setDuration(3000);
animation5-&gt;setStartValue(ui-&gt;pushButton_5-&gt;geometry());
animation5-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation6 = new
QPropertyAnimation(ui-&gt;pushButton_6, "geometry");
animation6-&gt;setDuration(3000);
animation6-&gt;setStartValue(ui-&gt;pushButton_6-&gt;geometry());
animation6-&gt;setEndValue(QRect(250, 200, 100, 50));</pre></li> <li>Then, apply the following code:<pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);
animation4-&gt;setEasingCurve(curve);
animation5-&gt;setEasingCurve(curve);
animation6-&gt;setEasingCurve(curve);</pre></li> <li>Create two <strong class="bold">animation groups</strong>, one<a id="_idIndexMarker209"/> for the buttons in the upper column and another one for the lower column:<pre class="source-code">
QParallelAnimationGroup *group1 = new QParallelAnimationGroup;
group1-&gt;addAnimation(animation1);
group1-&gt;addAnimation(animation2);
group1-&gt;addAnimation(animation3);
QParallelAnimationGroup *group2 = new QParallelAnimationGroup;
group2-&gt;addAnimation(animation4);
group2-&gt;addAnimation(animation5);
group2-&gt;addAnimation(animation6);</pre></li> <li>We will create yet another <strong class="bold">animation group</strong>, which will be used to store the two animation groups we created previously:<pre class="source-code">
QSequentialAnimationGroup *groupAll = new
QSequentialAnimationGroup;
groupAll-&gt;addAnimation(group1);
groupAll-&gt;addAnimation(group2);
groupAll-&gt;start();</pre></li> </ol>
<p>A Nested animation group allows you to set up a more complex widget animation by combining different types of<a id="_idIndexMarker210"/> animations and executing them at your desired orders.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>How it works…</h2>
<p>What we are trying to do here is play the animation of the buttons in the upper column first, followed by the buttons in the lower column. Since both of the animation groups are <code>start()</code> function is called.</p>
<p>This time, however, the group is a <strong class="bold">sequential animation group</strong>, which means only a single parallel animation group will <a id="_idIndexMarker212"/>be played at a time, followed by the other when the first one is finished. Animation groups are a very handy system that allows us to create very complex GUI animations with simple coding. Qt will handle the difficult part for us so that we don’t have to.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>State machines in Qt 6</h1>
<p>A <strong class="bold">state machine</strong> can be used for<a id="_idIndexMarker213"/> many purposes but, in this chapter, we will only cover topics<a id="_idIndexMarker214"/> related to animation.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>How to do it…</h2>
<p>A <strong class="bold">State machine</strong> is not that hard to achieve in Qt at all. Let’s get started by following these steps:</p>
<ol>
<li>We will set up a new user interface for our example program, which looks like this:</li>
</ol>
<div><div><img alt="Figure 3.5 – Setting up the GUI for our state machine experiment" src="img/B20976_03_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Setting up the GUI for our state machine experiment</p>
<ol>
<li value="2">We will include<a id="_idIndexMarker215"/> some headers in our source code:<pre class="source-code">
#include &lt;QStateMachine&gt;
#include &lt;QPropertyAnimation&gt;
#include &lt;QEventTransition&gt;</pre></li> <li>In our main window’s constructor, add <a id="_idIndexMarker216"/>the following code to create a <em class="italic">new state machine</em> and two <em class="italic">states</em>, which we will be using later:<pre class="source-code">
QStateMachine *machine = new QStateMachine(this);
QState *s1 = new QState();
QState *s2 = new QState();</pre></li> <li>We will define what we should do<a id="_idIndexMarker217"/> within each state, which, in this case, will be to change the<a id="_idIndexMarker218"/> label’s <em class="italic">text</em> and the button’s <em class="italic">position</em> and <em class="italic">size</em>:<pre class="source-code">
QState *s1 = new QState();
s1-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 1");
s1-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(50, 200,
100, 50));
QState *s2 = new QState();
s2-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 2");
s2-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(200, 50,
140, 100));</pre></li> <li>Once you are done with that, let’s proceed by adding <code>event transition</code> classes to our source code:<pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
s2-&gt;addTransition(t2);</pre></li> <li>Add all of the states we have just created to the state machine and define state 1 as the <code>machine-&gt;start()</code> to run the state machine:<pre class="source-code">
machine-&gt;addState(s1);
machine-&gt;addState(s2);
machine-&gt;setInitialState(s1);
machine-&gt;start();</pre></li> <li>If you run the example <a id="_idIndexMarker219"/>program now, you will notice that everything works fine, except <a id="_idIndexMarker220"/>the button is not going through a smooth transition and it simply jumps instantly to the position and size we set previously. This is because we have not used a <strong class="bold">property animation</strong> to create a smooth transition.</li>
<li>Go back to the event transition step and add the following lines of code:<pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s2-&gt;addTransition(t2);</pre></li> <li>You can also add an <a id="_idIndexMarker221"/>easing curve to the animation to make it look more interesting:<pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(animation);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(animation);
s2-&gt;addTransition(t2);</pre></li> </ol>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>How it works…</h2>
<p>There are two push buttons <a id="_idIndexMarker222"/>and a label on the main window layout. The button in the top-left corner will trigger the state change when pressed, while the label in the top-right corner will change its text to show which state we are currently in. the button below will animate according to the current state. The <code>QEventTransition</code> classes define what will trigger the transition between one state and another.</p>
<p>In our case, we want the state to change from state 1 to state 2 when the <code>assignProperty()</code> function, which has automatically assigned the end value.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>There’s more…</h2>
<p>The <strong class="bold">state machine framework</strong> in Qt <a id="_idIndexMarker225"/>provides classes for creating and executing state graphs. Qt’s event system is used to drive the state machines, where transitions between states can be triggered by using <em class="italic">signals</em>, and then the <em class="italic">slots</em> on the other end will be invoked by the signals to perform an action, such as playing an animation.</p>
<p>Once you understand the basics of state machines, you can use them to do other things as well. The state graph in the state machine framework is hierarchical. Just like the animation group in the previous section, states can also be nested inside of other states:</p>
<div><div><img alt="Figure 3.6 – Nested state machines explained visually" src="img/B20976_03_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Nested state machines explained visually</p>
<p>You can combine nested state machines and animations to create a very sophisticated GUI for your application.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>States, transitions, and animations in QML</h1>
<p>If you prefer to work with QML instead of C++, Qt also provides similar features in Qt Quick that allow you to easily <a id="_idIndexMarker226"/>animate a GUI element with minimal lines of code. In this example, we will learn how to achieve this with QML.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>How to do it…</h2>
<p>Let’s get started by following these steps to create a window that continuously changes its background color:</p>
<ol>
<li>We will create a new <strong class="bold">Qt Quick Application</strong> project and set up our user interface, like so:</li>
</ol>
<div><div><img alt="Figure 3.7 – A joyful application that constantly changes its background color" src="img/B20976_03_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – A joyful application that constantly changes its background color</p>
<ol>
<li value="2">Here is what <a id="_idIndexMarker227"/>my <code>main.qml</code> file looks like:<pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    visible: true
    width: 480;
    height: 320;
    Rectangle {
        id: background;
        anchors.fill: parent;
        color: "blue";
    }
    Text {
        text: qsTr("Hello World");
        anchors.centerIn: parent;
        color: "white";
        font.pointSize: 15;
    }
}</pre></li> <li>Add the <em class="italic">color animation</em> to<a id="_idIndexMarker228"/> the <code>Rectangle</code> object:<pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    color: "blue";
    SequentialAnimation on color {
        ColorAnimation { to: "yellow"; duration: 1000 }
        ColorAnimation { to: "red"; duration: 1000 }
        ColorAnimation { to: "blue"; duration: 1000 }
        loops: Animation.Infinite;
    }
}</pre></li> <li>Add a <em class="italic">number animation</em> to the <code>text</code> object:<pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
}</pre></li> <li>Add <a id="_idIndexMarker229"/>another <em class="italic">number animation</em> to it:<pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
    NumberAnimation on rotation {
        from: 0;
        to: 360;
        duration: 2000;
        loops: Animation.Infinite;
    }
}</pre></li> <li>Define two <em class="italic">states</em>, one called the <code>PRESSED</code> state and another called the <code>RELEASED</code> state. Then, set<a id="_idIndexMarker230"/> the default state to <code>RELEASED</code>:<pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    state: "RELEASED";
    states: [
    State {
        name: "PRESSED"
        PropertyChanges { target: background; color: "blue"}
    },
    State {
        name: "RELEASED"
        PropertyChanges { target: background; color: "red"}
    }
    ]
}</pre></li> <li>After that, create a mouse area within the <code>Rectangle</code> object so that we can click on it:<pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onPressed: background.state = "PRESSED";
    onReleased: background.state = "RELEASED";
}</pre></li> <li>Add some transitions to<a id="_idIndexMarker231"/> the <code>Rectangle</code> object:<pre class="source-code">
transitions: [
    Transition {
        from: "PRESSED"
        to: "RELEASED"
        ColorAnimation { target: background; duration: 200}
    },
    Transition {
        from: "RELEASED"
        to: "PRESSED"
        ColorAnimation { target: background; duration: 200}
}
]</pre></li> </ol>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>How it works…</h2>
<p>The main window consists of a blue rectangle and static text that says <code>Rectangle</code> object, then creating three different <em class="italic">color animations</em> within the group, which will change the color of the object every 1,000 milliseconds (1 second). We also set the animations to loop infinitely.</p>
<p>In <em class="italic">step 4</em>, we want to use the <em class="italic">number animation</em> to animate the alpha value of the static text. We created another <em class="italic">sequential animation group</em> within the <code>Text</code> object and created two <em class="italic">number animations</em> to animate the alpha value from <code>0</code> to <code>1</code> and back. Then, we set the animations to loop infinitely.</p>
<p>Then, in <em class="italic">step 5</em>, we rotate the <code>Hello World</code> text by adding another <code>Rectangle</code> object change from one color to another when we clicked on it. When the mouse is released, the <code>Rectangle</code> object will change back to its initial color. To achieve that, we first need to define the two states, one called the <code>PRESSED</code> state and another called the <code>RELEASED</code> state. Then, we set the default state to <code>RELEASED</code>.</p>
<p>Now, when you compile and run the example, the background will instantly change color to blue when pressed and change back to red when the mouse is released. That works great, and we can further enhance it by giving it a little transition when switching color. This can be easily achieved by adding transitions to the <code>Rectangle</code> object.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>There’s more…</h2>
<p>In QML, there are eight different types of property animation you can use, and these are as follows:</p>
<ul>
<li><strong class="bold">Anchor animation</strong>: Animates<a id="_idIndexMarker233"/> changes in anchor <a id="_idIndexMarker234"/>values</li>
<li><strong class="bold">Color animation</strong>: Animates <a id="_idIndexMarker235"/>changes<a id="_idIndexMarker236"/> in color values</li>
<li><strong class="bold">Number animation</strong>: Animates <a id="_idIndexMarker237"/>changes in qreal-type<a id="_idIndexMarker238"/> values</li>
<li><strong class="bold">Parent animation</strong>: Animates <a id="_idIndexMarker239"/>changes<a id="_idIndexMarker240"/> in parent values</li>
<li><strong class="bold">Path animation</strong>: Animates<a id="_idIndexMarker241"/> an item <a id="_idIndexMarker242"/>along a path</li>
<li><strong class="bold">Property animation</strong>: Animates <a id="_idIndexMarker243"/>changes in property values</li>
<li><strong class="bold">Rotation animation</strong>: Animates <a id="_idIndexMarker244"/>changes<a id="_idIndexMarker245"/> in rotation values</li>
<li><strong class="bold">Vector3d animation</strong>: Animates<a id="_idIndexMarker246"/> changes in QVector3D<a id="_idIndexMarker247"/> values</li>
</ul>
<p>Just like the C++ version, these animations can also be grouped together in an animation group to play the animations in sequence or parallel. You can also control the animations using easing curves and determine when to play these animations using state machines, just like we<a id="_idIndexMarker248"/> did in the previous section.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Animating widget properties using animators</h1>
<p>In this recipe, we will learn how to <a id="_idIndexMarker249"/>animate the properties of our GUI <a id="_idIndexMarker250"/>widgets using the animator feature that’s provided by QML.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>How to do it…</h2>
<p>Animating QML objects is really easy if you perform the following steps:</p>
<ol>
<li>Create a <code>Rectangle</code> object and add a <em class="italic">scale animator</em> to it:<pre class="source-code">
Rectangle {
    id: myBox;
    width: 50;
    height: 50;
    anchors.horizontalCenter: parent.horizontalCenter;
    anchors.verticalCenter: parent.verticalCenter;
    color: "blue";
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
        running: true;
    }
}</pre></li> <li>Add a <em class="italic">rotation animator</em> and set<a id="_idIndexMarker251"/> the <code>running</code> value in the parallel animation group, but not in any of <a id="_idIndexMarker252"/>the individual animators:<pre class="source-code">
ParallelAnimation {
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
    }
    RotationAnimator {
        target: myBox;
        from: 0;
        to: 360;
        duration: 1000;
    }
    running: true;
}</pre></li> <li>Add an <em class="italic">easing curve</em> to<a id="_idIndexMarker253"/> the <em class="italic">scale animator</em>:<pre class="source-code">
ScaleAnimator {
    target: myBox;
    from: 5;
    to: 1;
    duration: 2000;
    easing.type: Easing.InOutElastic;
    easing.amplitude: 2.0;
    easing.period: 1.5;
    running: true;
}</pre></li> </ol>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>How it works…</h2>
<p>The <em class="italic">animator</em> type can be used just like any other <em class="italic">animation</em> type. We want to scale a rectangle from a size of <code>5</code> to a size <a id="_idIndexMarker254"/>of <code>1</code> within 2,000 milliseconds (2 seconds). We created a blue <code>Rectangle</code> object and added a <em class="italic">scale animator</em> to it. We set the <code>initial</code> value to <code>5</code> and the <code>final</code> value to <code>1</code>. Then, we set the animation <code>duration</code> to <code>2000</code> and set the <code>running</code> value to <code>true</code> so that it will be played when the program starts.</p>
<p>Just like the animation types, animators can also be put into<a id="_idIndexMarker255"/> groups (that is, <strong class="bold">parallel </strong><strong class="bold">animation groups</strong> or <strong class="bold">sequential animation groups</strong>). An animation group will also be treated as an animator by QtQuick and <a id="_idIndexMarker256"/>be run on the scene graph’s rendering thread whenever possible. In step 2, we want to group two different animators into a <strong class="bold">parallel animation group</strong> so that they run together at the same time.</p>
<p>We will keep the <code>running</code> value in the parallel animation group, but not in any of the individual animators.</p>
<p>Just like the C++ version, QML also supports <strong class="bold">easing curves</strong>, and they can be easily applied to any of the animations or animator types.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>There’s more…</h2>
<p>There is something called an <em class="italic">animator</em> in QML, which<a id="_idIndexMarker257"/> is different from the usual <em class="italic">animation</em> type, even though there is <a id="_idIndexMarker258"/>some similarity between them. Unlike regular animation types, animator types<a id="_idIndexMarker259"/> are directly operated on Qt Quick’s <strong class="bold">scene graph</strong>, rather than <a id="_idIndexMarker260"/>the QML objects and their properties. The value of the QML property will not be changed while the animation is running, as it will only change once the animation is finished. The benefit of using the animator type is that it operates directly <a id="_idIndexMarker261"/>on the scene graph’s rendering thread, which means its performance will be slightly better than running on the <strong class="bold">UI thread</strong>.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Sprite animation</h1>
<p>In this example, we will learn how<a id="_idIndexMarker262"/> to create a <strong class="bold">sprite animation</strong> in <a id="_idIndexMarker263"/>QML.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>How to do it…</h2>
<p>Let’s make a horse run across our application window by following these steps:</p>
<ol>
<li>We will need to add our sprite sheet to Qt’s <em class="italic">resource system</em> so that it can be used in the program. Open up <code>qml.qrc</code> and click the <strong class="bold">Add</strong> | <strong class="bold">Add Files</strong> buttons. Select your sprite sheet image and save the resource file by pressing <em class="italic">Ctrl</em> + <em class="italic">S</em>.</li>
<li>Create a new empty window in <code>main.qml</code>:<pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true
    width: 420
    height: 380
    Rectangle {
        anchors.fill: parent
        color: "white"
    }
}</pre></li> <li>Once you are done <a id="_idIndexMarker264"/>with that, we will start creating<a id="_idIndexMarker265"/> an <code>AnimatedSprite</code> object in QML:<pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true;
    width: 420;
    height: 380;
    Rectangle {
        anchors.fill: parent;
        color: "white";
     }</pre></li> <li>Then, set the following:<pre class="source-code">
     AnimatedSprite {
         id: sprite;
        width: 128;
        height: 128;
        anchors.centerIn: parent;
         source: "qrc:///horse_1.png";
         frameCount: 11;
         frameWidth: 128;
         frameHeight: 128;
         frameRate: 25;
         loops: Animation.Infinite;
         running: true;
     }
}</pre></li> <li>Add a <em class="italic">mouse area</em> to <a id="_idIndexMarker266"/>the window and check for the <code>onClicked</code> event:<pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onClicked: {
        if (sprite.paused)
            sprite.resume();
        else
            sprite.pause();
    }
}</pre></li> <li>If you compile and run <a id="_idIndexMarker267"/>the example program now, you will see a little pony running in the middle of the window. How fun:</li>
</ol>
<div><div><img alt="Figure 3.8 – A horse running across the application window" src="img/B20976_03_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – A horse running across the application window</p>
<ol>
<li value="7">Next, we want to try and do <a id="_idIndexMarker268"/>something cool. We will make the horse run <a id="_idIndexMarker269"/>across the window and loop infinitely while playing its running animation! First, we need to remove <code>anchors.centerIn: parent</code> from QML and replace it with <code>x</code> and <code>y</code> values:<pre class="source-code">
AnimatedSprite {
    id: sprite;
     width: 128;
     height: 128;
     <strong class="bold">x: -128;</strong>
<strong class="bold">     y: parent.height / 2;</strong>
     source: "qrc:///horse_1.png";
     frameCount: 11;
     frameWidth: 128;
     frameHeight: 128;
     frameRate: 25;
     loops: Animation.Infinite;
     running: true;
}</pre></li> <li>Add a <em class="italic">number animation</em> to the sprite<a id="_idIndexMarker270"/> object and set its properties, as<a id="_idIndexMarker271"/> follows:<pre class="source-code">
NumberAnimation {
    target: sprite;
    property: "x";
     from: -128;
     to: 512;
     duration: 3000;
     loops: Animation.Infinite;
     running: true;
}</pre></li> <li>If you compile and run the example program now, you will see the pony go crazy and start running across the window!</li>
</ol>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>How it works…</h2>
<p>In this recipe, we place the animated sprite object in the middle of the window and set its image source to the sprite sheet that we have just added to the project resource. Then, we count how many frames there are in the sprite sheet that belong to the running animation, which in this case is 11 frames. We also inform Qt of the dimensions of each frame of the animation, which in this case are <code>128 x 128</code>. After that, we set the frame rate to <code>25</code> to get a decent speed and then set it to loop infinitely. We then set the <code>running</code> value to <code>true</code> so that<a id="_idIndexMarker272"/> the animation will play by default when the program starts running.</p>
<p>Then, in <em class="italic">step 4</em>, we want to be <a id="_idIndexMarker273"/>able to pause the animation and resume it by clicking on the window. We simply check whether the sprite is currently paused when clicking on the mouse area. If the sprite animation is paused, then the animation resumes; otherwise, the animation is paused.</p>
<p>In <em class="italic">step 6</em>, we replace <code>anchors.centerIn</code> with <code>x</code> and <code>y</code> values so that the animated sprite object is not anchored to the center of the window, which would make it impossible to move around. Then, we create a <em class="italic">number animation</em> within the animated sprite to animate its <code>x</code> property. We set the <code>start</code> value to somewhere outside the window on the left side, and we set the <code>end</code> value to somewhere outside the window on the right side. After that, we set the <code>duration</code> to 3,000 milliseconds (3 seconds) and make it loop infinitely.</p>
<p>Lastly, we also set the <code>running</code> value to <code>true</code> so that it plays the animation by default when the program starts running.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>There’s more…</h2>
<p>Sprite animation is used extensively, especially in game development. Sprites are used for character animation, particle animation, and even GUI animation. A sprite sheet consists of many images combined into one, which can then be chopped down and displayed on the screen, one at a time. The transitions between different images (or sprites) from the sprite sheet creates the illusion of animation, which we usually refer to as a sprite animation. A Sprite animation can be easily achieved in QML using the <code>AnimatedSprite</code> type.</p>
<p class="callout-heading">Note</p>
<p class="callout">In this example program, I am using a free<a id="_idIndexMarker274"/> and open source image that was created by <strong class="bold">bluecarrot16</strong> under the <em class="italic">CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0</em> license. The image can be obtained legally at <a href="http://opengameart.org/content/lpc-horse">http://opengameart.org/content/lpc-horse</a>.</p>
</div>
</body></html>