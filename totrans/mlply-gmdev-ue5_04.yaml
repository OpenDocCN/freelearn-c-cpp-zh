- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Your First Multiplayer Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a full networked game in UE5 can be an intimidating task. It requires
    knowledge of networking, coding, and the engine itself, all of which can be overwhelming
    for even experienced developers. But with the right guidance and some elbow grease,
    it is possible to create an engaging multiplayer experience in no time (well,
    sort of...)!
  prefs: []
  type: TYPE_NORMAL
- en: To prevent multiple issues with rethinking and modifications, the first step
    should be gaining a clear understanding of the project’s topic. This avoids confusion
    from the onset and enables a smoother workflow. After that, you will need to create
    an Unreal project and get things set up properly. This includes creating your
    **Gameplay Framework** (**GF**) classes so that you have access to all the necessary
    features needed for development, as well as configuring your project settings
    to use such classes.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of programming
    in UE with C++ and will have laid the foundation for your multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the next sections, I will present you with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unreal Shadows – Legacy of the Lichlord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding C++ in Unreal Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting your Unreal multiplayer project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the player classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this chapter, you should have set up Visual Studio (or
    JetBrains Rider) with all Unreal dependencies, as explained in [*Chapter 1*](B18203_01.xhtml#_idTextAnchor016),
    *Getting Started with Multiplayer* *Game Development*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be using some starter content available in this book’s companion repository
    located at [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Through this link, locate the section for this chapter and download the following
    `.zip` file: `Unreal Shadows – Starter Content`. If you somehow get lost during
    the progress of this chapter, in the repository, you will also find the up-to-date
    project files here: `Unreal Shadows –` `Chapter` `04` `End`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, to fully understand this chapter, it is necessary to have some basic knowledge
    about C++ programming while I guide you through the key characteristics of the
    main peculiarities of the UE framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unreal Shadows – Legacy of the Lichlord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following passage from a (never published) fantasy book called
    *Unreal Shadows – Legacy of* *the Lichlord*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“The air was thick with the stench of decay as the three thieves made their
    way into the Lichlord’s dungeon. Their mission was clear: infiltrate the fortress,
    find the king’s knight, and bring him back alive. Anything they could find lying
    around was theirs to* *take home.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As they crept through the shadowy corridors, they all knew that they were
    not alone: dozens of undead minions lurked around every corner, their greenish
    eyes* *staring blankly.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The guild had faced their fair share of dangerous foes before, but never had
    they encountered such a formidable army of the undead. Quietly, they slipped past
    the corridors, careful not to attract any attention. The last thing they needed
    was to draw the entire horde down* *upon them.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you have just been hired to create the video game adaptation
    of this best-selling book! And what’s more, it will be a multiplayer game!
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the project brief
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game you’ll be developing will be a **third-person shooter** that will use
    the **hide and seek** gameplay twist, as introduced in [*Chapter 1*](B18203_01.xhtml#_idTextAnchor016),
    *Getting Started with Multiplayer Game Development*. This means that this will
    be a stealth game where players will survive only by moving quietly and carefully.
  prefs: []
  type: TYPE_NORMAL
- en: In this multiplayer game, each participant will play the role of a member of
    the Guild of Thieves, a secret organization of rogues and thieves, infiltrating
    the realm of an undead wizard. The main aim will be to rescue non-player characters
    that are kept (hopefully alive!) in the dungeon prisons. Additionally, players
    will collect treasures and equipment from past and less lucky adventurers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each character will have the ability to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Move around by walking or running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle a weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get power-ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equip new weapons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase skills by means of experience points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary focus of this game will be on stealthy movement, as the undead army
    will prove too strong for the character to engage in direct combat. As a result,
    movement (especially running) and wielding weapons will create noise, making the
    previously unaware enemies instantly alert to the player’s presence.
  prefs: []
  type: TYPE_NORMAL
- en: Enemies will be represented by the Lichlord minions, a horde of undead skeletons
    that will wander around the level unaware of the player characters.
  prefs: []
  type: TYPE_NORMAL
- en: Excessive noise from the characters or falling into traps will alert nearby
    enemies, making it nearly impossible to complete the game. Regrettably for the
    player characters, gaining experience points will only be made possible by defeating
    enemies, adding further engagement to the overall experience!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As this book is about multiplayer game programming rather than game design,
    balancing game mechanics will not be a primary focus of gameplay; instead, the
    focus will be on making things function effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want the game to be visually appealing, but I’m guessing that most of you
    might not have a 3D modeling background (I don’t have one!). That’s why we will
    be using some amazing assets by Kay Lousberg ([https://kaylousberg.com/](https://kaylousberg.com/))
    that are freely available for personal and commercial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.1* shows one of the packs we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The KayKit Dungeon Pack](img/Figure_04.1_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The KayKit Dungeon Pack
  prefs: []
  type: TYPE_NORMAL
- en: You will start by creating a brand-new project starting from the **Blank** template
    available in UE5 and then you will add some assets from the aforementioned kits;
    however, to avoid the tedious task of importing them correctly, I have already
    packaged them for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project files, along with the code for each chapter, can be found on this
    book’s companion project page located here: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: Having established what you will be working on, it is now time to gain an understanding
    of how C++ is used within UE5\. The following section will provide a brief introduction
    to the primary features offered by the engine framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C++ in Unreal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you share my love for game development and programming, you’ll likely find
    that writing C++ code in UE5 is quite fun and actually not too hard to get started
    with. Epic Games made a great job of adding features that make C++ easy to use
    for (almost) everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to write standard C++ code in UE5, to achieve better
    performance with your games, it is advisable to use the engine’s most common features
    such as the built-in Reflection System and memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprints and C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may already know, UE provides two methods for programming your game
    logic: Blueprint Visual Scripting and C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blueprints Visual Scripting** makes it easier for developers who don’t have
    extensive coding experience to create complex game mechanics without writing any
    code. On the other hand, **C++** is an **object-oriented programming** (**OOP**)
    language that requires more technical knowledge but offers much greater control
    over the game engine than Blueprints does.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that C++ and Blueprints are strictly connected, as Blueprints
    provide a visual representation of the underlying C++ code and adhere to its principles,
    including inheritance and polymorphism. While Blueprints do not demand advanced
    coding skills, they do follow the same principles as the programming language
    in terms of data types, pointers, references, and other rules.
  prefs: []
  type: TYPE_NORMAL
- en: Both languages can be used together in UE5 projects and most of the time, what
    you can achieve with C++ can equally be done in Blueprints; however, C++ excels
    in customizing core features of UE or creating plugins that extend its functionality
    even further beyond what’s available out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Although both Blueprint Visual Scripting and C++ offer powerful toolsets when
    working with UE projects, C++ provides lower-level access by way of object-oriented
    coding techniques – that’s why it is very important to have a strong knowledge
    of it once you start developing multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C++ classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Unreal Engine C++ class is, well, a regular C++ class!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have already a good knowledge of OOP in C++, you will feel at home here:
    the process of creating a new UE C++ class begins by first defining what type
    of object it will represent, such as an Actor or a Component. Once the type has
    been defined, variables and methods are declared in the header file (`.h`) and
    code logic is implemented in the source file (`.cpp`).'
  prefs: []
  type: TYPE_NORMAL
- en: While the source file behaves like a regular C++ file of its kind, the header
    file will let you declare additional information for variables and functions that
    will be used by Blueprints inheriting from your class. Additionally, it will ease
    the pain of managing memory at runtime (I will get back to this in a while).
  prefs: []
  type: TYPE_NORMAL
- en: With the release of UE5, Epic Games introduced an amazing inspection tool called
    `BP_BasePickup` created during the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The C++ Header Preview tool in action](img/Figure_04.2_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The C++ Header Preview tool in action
  prefs: []
  type: TYPE_NORMAL
- en: 'In UE, there are three main class types that you’ll be deriving from during
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **UObject** is the base class of UE and provides most of the main features
    available in UE, such as **garbage collection** (**GC**) (yes, UE provides it!),
    networking support, reflection of properties and methods, and so on. An **AActor**
    is a UObject that can be added to a game level either from the Editor or at runtime:
    in this second case, we say that the Actor has been *spawned*. In a multiplayer
    environment, an AActor is the base type that can be replicated during networking
    and it will provide information for any Component that will need synchronization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **UActorComponent** is the basic class for defining Components that will be
    attached to an Actor or to another Component belonging to the Actor itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, you’ll be using these entities:'
  prefs: []
  type: TYPE_NORMAL
- en: A **UStruct** is used to create plain data structures and does not extend from
    any particular class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **UEnum** is used to represent enumerations of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a final note, throughout this book, you will notice that class names start
    with some letters that will not be visible once the class is used in the Editor.
    UE makes use of prefixes to point out the class type. The main prefixes used are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UObject` (for instance, components)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AActor`) and that can be added to a level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FColor` structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TArray` or `TMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I** is used for interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E** is used for enums'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool` or `uint8` (which may be used instead of `bool`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that most of these prefixes are mandatory; if you try to
    name a class deriving from Actor without the `A` prefix, you will get an error.
    UE will hide the prefix once in the Editor. This rule applies only to C++ classes;
    Blueprints can be named without such prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the main types available in UE, it’s time to
    explore the main features of a class header in order to understand its core functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a UE C++ header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++ header of an Actor in UE5 will look like the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are a lot of things going on here.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you will notice a `#include "APickup.generated.h"` declaration.
    This mandatory line of code is autogenerated by the `include` file declared in
    your header or the compiler will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The UHT is a custom parsing and code generation tool that supports the UObject
    system in Unreal Engine. The UHT is used to parse C++ headers for Unreal and generate
    the boilerplate code required for the engine to work with the user-created classes.
  prefs: []
  type: TYPE_NORMAL
- en: The class constructor (in this case, `APickup()`) is used to set default values
    for properties as you may do with a regular C++ class; what’s more, you will be
    using it to create and add Components to the Actor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will find some declarations, such as `UCLASS()`, `GENERATED_BODY()`,
    `UPROPERTY()`, and `UFUNCTION()`, that are used by UE and each has a precise function.
    If you are wondering about the meaning of the attributes called `BlueprintReadOnly`,
    `VisibleAnywhere`, and similar, don’t be afraid! I’ll be explaining their meaning
    in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a* *Multiplayer
    Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, I’ll show you the exact meaning of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The Unreal Engine Reflection System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **Reflection** specifies the capability that allows a program to inspect
    its own structure at runtime. This feature is immensely valuable and serves as
    one of the core technologies employed by UE, supporting a variety of systems such
    as detail panels in the Editor, serialization, garbage collection, network replication,
    and communication between Blueprint and C++.
  prefs: []
  type: TYPE_NORMAL
- en: As there is no native support for Reflection in C++, Epic Games has developed
    its own system for gathering, examining, and altering data related to C++ classes,
    structs, and so on in UE.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Reflection, you will need to annotate any type or property that
    you want to make visible to the system by marking them with annotations such as
    `UCLASS()`, `UFUNCTION()`, or `UPROPERTIES()`.
  prefs: []
  type: TYPE_NORMAL
- en: To enable such annotations, you’ll be using the `#include "APickup.generated.h"`
    declaration I introduced in the last subsection (this declaration is autogenerated
    when you create a class with the Unreal Class Wizard, so you won’t have to worry
    about it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides the fundamental markup elements accessible within
    the Reflection System:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS()`: Used to generate reflection data for a class that needs to derive
    from `UObject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USTRUCT()`: Used to generate reflection data for a struct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GENERATED_BODY()`: This markup will be replaced with all the needed boilerplate
    code for the type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPROPERTY()`: Used to tell the engine that the associated member variable
    will have some additional features, such as Blueprint accessibility or replication
    across the network (and this will mean a lot to you later on!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UFUNCTION()`: Allows, among other things, to call this function from an extending
    Blueprint Class or override the function from the Blueprint itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Reflection System is also used by the garbage collector so you don’t have
    to worry about memory management, as you will see in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management and garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With thousands (sometimes tens of thousands!) of active objects in a game level,
    GC is an essential part of programming. It’s like the janitor of your running
    code – it helps keep everything tidy and organized by automatically collecting
    and disposing of objects that are no longer needed. It’s a great way to make sure
    your program runs smoothly without any memory leaks or performance issues, so
    you can focus on creating awesome features instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ does not natively implement GC, so UE implements its own system: you will
    just need to ensure that valid references to the objects are maintained. In order
    to enable GC for your classes, you need to assure that they inherit from `UObject`;
    then the system will keep a list of objects (also called **root**) that should
    not be garbage-collected. As long as an object is listed in the root, it will
    be preserved from deletion; once it is removed from this list, it will be deleted
    from memory the next time the garbage collector is called (i.e., at certain intervals).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors are only destroyed at the level’s shutdown unless you call the `Destroy()`
    method on them: in this case, they will be immediately removed from the game and
    deleted by the garbage collector when activated.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have introduced you to the main features that distinguish
    an Unreal Engine project from a regular C++ one. In the next section, you will
    begin to apply this knowledge by creating an empty project and extending the main
    Unreal GF classes.
  prefs: []
  type: TYPE_NORMAL
- en: Starting your Unreal multiplayer project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you are finally going to start developing the multiplayer project
    (I know you are eager to begin it!). You’ll be creating an Unreal C++ blank project
    and adding the already packaged assets I will provide you. Then, you’ll be creating
    the GF classes needed to manage a multiplayer session. So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your project file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a blank project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Epic Games Launcher and launch the Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Games** section, select the **Blank** template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Project Defaults**, select **C++** as the project type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the **Starter Content** field is unselected as you won’t be using
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the project a meaningful name (for example, `UnrealShadows_LOTL`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the UE project has been created, get the `UnrealShadows-StarterContent.zip`
    file you downloaded at the beginning of this chapter and unzip it in your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your project `Content` folder located at `[Your Project Path]` |
    `UnrealShadows_LOTL` | `Content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the content of the unzipped file (`_ExternalActors_`, `Blueprints`, `KayKit`,
    and `Maps` folders) into the `Content` folder to add all the needed assets to
    your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have copied the files, they should appear in the UE Editor and be available
    in your project. If the files do not pop up in the Content Browser, simply close
    the Editor and open it again to let UE update the `Content` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that I have already added two levels (`Maps` folder: these
    levels will be used during the book and have been created for ease of development.
    You are free to create your own maps or add additional assets. which can be located
    at **Content** | **KayKit** | **Dungeon Elements**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to check that everything went as expected, open the `Level_01` map and
    you should see the level shown in *Figure 4**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The Level 01 map](img/Image96388.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The Level 01 map
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to add some of the main classes used in any UE5 project, the ones
    that extend the GF elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project game instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you probably already know, in UE5, a **GameInstance** is a class responsible
    for managing high-level data that needs to persist across level changes or game
    sessions. It is essentially a globally accessible UObject that can store any data
    you want to keep across the entire game, such as the player score, and other information
    that needs to be shared across different levels or game sessions.
  prefs: []
  type: TYPE_NORMAL
- en: A class extending a GameInstance can be created as a Blueprint Class or in C++
    and is instantiated when the game is started and is only destroyed when the game
    is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As with most C++ Unreal Engine projects, you will be working with a mix of C++
    classes and Blueprints. C++ classes are located in the **All | C++ classes | UnrealShadows_LOTL**
    folder and can only be added there (or in a subfolder). If you can’t find this
    folder, you have probably created a Blueprint-only project. Don’t despair, once
    the first C++ has been created (more on this in a minute), the Unreal Engine Editor
    will take care of it, transforming your Blueprint-only project into a C++ one
    and everything will be in place!
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your project GameInstance, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On the main menu, select **Tools** | **New** **C++ Class...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `game instance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **GameInstance** class, as shown in *Figure 4**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The class creation wizard](img/Figure_04.4_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The class creation wizard
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to access the **NAME YOUR NEW GAME** **INSTANCE** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `US_GameInstance`. You can leave the other fields as they are so that
    the panel looks like *Figure 4**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Naming your class](img/Figure_04.5_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Naming your class
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create Class** button to generate your class files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll be using the `US_` prefix for most of the classes in the project extending
    the main GF elements: this is just a shorthand for UnrealShadows and will let
    us see that these files are from our project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the creation process has ended, you will get two new files: `US_GameInstance.h`
    and `US_GameInstance.cpp`. Congratulations – you have just created your first
    Unreal C++ class!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the header file, you will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The source file will be empty, apart from the header `#``include` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this class extends the base `GameInstance` class (i.e., `UGameInstance`)
    and it currently does nothing apart from the macro declarations that were introduced
    in the previous section. However, as the project progresses, new features such
    as data collection or online services management will be added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you named your project with a name other than mine (i.e., `UnrealShadows_LOTL`),
    you will get a different API export name in your class declaration; as you can
    see from the previous code, mine is `UNREALSHADOWS_LOTL_API`. Please keep this
    in mind throughout the book, as my code will reference this name and you may get
    a compilation error. To fix this, you should change the `UNREALSHADOWS_LOTL_API`
    text with `YOUR_PROJECT_NAME` (in all caps), with the `_API` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game instance needs to be added to the project settings so it will be
    the one instantiated at runtime. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, open **Project Settings**. Then click on the **Project**
    | **Maps &** **Modes** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Game Instance Class** drop-down menu, select **UG_GameInstance**,
    as depicted in *Figure 4**.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The game instance assigned to the project](img/Figure_04.6_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The game instance assigned to the project
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a game instance assigned to the project, it’s time to create
    a Game Mode for the menu and lobby levels.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Game Mode and the Game State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In UE, a **Game Mode** is a class that controls the game rules, such as how
    a player joins the game, how to transition between levels, and other game-specific
    settings. The Game Mode is typically paired with a **Game State** class, which
    manages the current state of the game, such as the score, time remaining, and
    other important information. Together, the Game Mode and Game State classes allow
    developers to create complex and customized game mechanics in UE.
  prefs: []
  type: TYPE_NORMAL
- en: If you check your `C++ Classes` folder, you will notice that there is already
    a Game Mode named `UnrealShadowsLOTLGameModeBase` (the name may differ slightly
    if you named your project differently from mine). This is an autogenerated class
    extending `AGameModeBase` from the GF.
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t be using this because you need to create a class from `AGameMode`;
    this class extends `AGameModeBase` by adding some features that will enhance the
    multiplayer system, such as game rules and win/lose conditions. To extend the
    Game Mode with your own settings, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C++ class just like you did for the game instance in the previous
    sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **All Classes** section, select **GameMode** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your class `US_GameMode` and click the **CreateClass** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the class has been created, it’s time to set it as the default Game Mode
    for all your levels. To do this, open **Project Settings** and select the **Maps
    &** **Modes** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Default GameMode** drop-down menu and select **US_GameMode**,
    as shown in *Figure 4**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The default game mode](img/Figure_04.7_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The default game mode
  prefs: []
  type: TYPE_NORMAL
- en: Close the **Project** **Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the Game Mode has been defined, it’s time to create a Game State:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another C++ class that will extend from `GameState` (from the **All**
    **Classes** section).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking `US_GameState` and click the **CreateClass** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, declare `US_GameMode` files by double-clicking on the corresponding icon
    in the `C++ Classes` folder of the Unreal Editor. This will open the header and
    source files inside your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a constructor inside `US_GameMode.h` by adding these two lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the constructor inside `US_GameMode.cpp` by adding this piece of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous code essentially declares the Game State class for `US_GameMode`
    to be the previously created `US_GameState`. Keep in mind that this declaration
    can be performed also in child Blueprints; this will enable class switching through
    a drop-down menu in the Editor. Ultimately, this is a matter of personal taste
    as you may be more code-oriented and prefer the code solution or you may want
    to take advantage of the impressive interplay between native code and the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have created the main classes that will be used by the
    system to handle a multiplayer session. At the moment, these are just empty containers
    waiting for some game logic to be added; be patient, we still have so many chapters
    to fill this void!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll be creating the classes needed to handle the character
    input and presence in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the player classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are now ready to create some more main classes used by almost any UE game:
    those dedicated to managing the input from the player and showing the character
    in-game, along with its state.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Player Controller** is responsible for managing input from the player’s
    input devices (such as keyboard and mouse), and for sending commands to the player’s
    character so it will perform the corresponding actions. The Player Controller
    class is typically used to control a **Pawn** class or a **Character** class that
    represents the player in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **Player State** is a class that holds information about a player’s
    game state, such as experience points, score, and other relevant data. It exists
    on both the server and clients to ensure that all players have access to the same
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create these three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a C++ class extending `PlayerController` and name it `US_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another C++ class extending `Character` and name it `US_Character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a C++ class extending `PlayerState` and call it `US_PlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These three classes should be added to the Game Mode, the same way the Game
    State was added, but to get a bit more flexibility to our `Character` class, you’ll
    be creating a Blueprint from it. To get a Blueprint out of a newly created C++
    class, you need to compile the project.
  prefs: []
  type: TYPE_NORMAL
- en: You are now going to compile your source code for the first time to check that
    everything has been properly set.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiling in an Unreal Engine project refers to the process of converting human-readable
    code written in C++ and Blueprint into executable code that the computer can understand
    and run – this is an essential step in the development process. UE provides tools
    to streamline the compiling process and improve the development experience.
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, you can leverage **Live Coding**, a feature that enables your
    application’s C++ code to be rebuilt and its binaries patched while the UE engine
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: With Live Coding, you can modify C++ classes, compile them, and observe the
    changes taking effect while the Editor is running – all without interrupting the
    play-testing sessions or work in progress. This feature boasts enormous advantages
    for iterative development, especially when using C++ runtime logic such as gameplay
    code or frontend user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Live coding is enabled by default, and you can initiate a Live Coding build
    by pressing *Ctrl* +*Alt* + *F11* on your keyboard when utilizing your IDE or
    Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, to start the compilation process with Live Coding disabled,
    you can click the **Compile** button at the bottom right of the Unreal Engine
    Editor, as depicted in *Figure 4**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The Compile button](img/Figure_04.8_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The Compile button
  prefs: []
  type: TYPE_NORMAL
- en: Once the source code has been compiled, you should get a success message. Otherwise,
    you will get the usual errors or warnings from a failed compilation; in this case,
    it is essential to ensure that your code is written correctly and free from errors.
  prefs: []
  type: TYPE_NORMAL
- en: Once your project has been successfully compiled, it’s time to create a Blueprint
    out of your `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Character Blueprint Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ll be working on some customization for your character later on, it’s
    essential to have the extra flexibility provided by a Blueprint Class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have successfully compiled your code, you may expect that the classes
    you created will now be ready to be available in the Blueprint creation wizard.
    This is a correct assumption and you are going to test it right now. Let’s do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Content` | `Blueprints` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Blueprint Class that will inherit from `US_Character` and name it `BP_Character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and close the Blueprint: you are not going to do anything yet on it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This new Blueprint should be added to the Game Mode as the default Pawn to be
    used during a game session. Unfortunately, a Blueprint Class cannot be directly
    referenced in a C++ class. This means you’ll have to find it through a method
    called `FClassFinder` available in the `ConstructorHelpers` utility class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Player classes to the Game Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are now going to declare the newly created classes to the Game Mode. Let’s
    open again the `US_GameMode.cpp` file and add some code logic. In the `declarations`
    section, add the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will declare all the GF classes you will be declaring, and the `ConstructorHelpers`
    utility class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, before the closing bracket of the constructor, add the following block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first two lines of code declare `PlayerStateClass` and `PlayerControllerClass`
    in a similar way as you did in the previous section for `GameStateClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, retrieving a Blueprint reference (i.e., `PlayerPawnBPClass`) from
    a C++ class works differently from how it works for a regular C++ class: you need
    to hardcode a path to your project. This may be not an ideal solution because
    files can be moved around or deleted but, well... it works!'
  prefs: []
  type: TYPE_NORMAL
- en: Just keep in mind that my file path (i.e., `"/Game/Blueprints/BP_Character"`)
    may be slightly different from yours, depending on your folder organization.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Game Mode class has been modified, click the **Compile** button
    in the Unreal Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get a successful result, it’s time to look at the Game Mode instance
    to check that everything is correct. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Project Settings** | **Maps &** **Modes** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **Selected GameMode** field and expand it by clicking the small arrow
    next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that the GF classes we have created are all correctly allocated, as shown
    in *Figure 4**.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The updated default Game Mode](img/Figure_04.9_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The updated default Game Mode
  prefs: []
  type: TYPE_NORMAL
- en: In this last section, you have completed the Game Mode setup by adding all the
    GF classes you’ll be expanding in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you were briefed about the project you’ll be developing through
    the rest of the book: a multiplayer stealth game involving thieves, secret treasures,
    and a ton of undead minions. The road is still long, but the Lichlord must be
    stopped!'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you were introduced to the main topics of the Unreal Engine C++
    “dialect.” There are a lot of additional features involved and many more will
    be discovered throughout the rest of the book. One of the most exciting things
    is that, if things are set up properly, you won’t have to worry about memory management:
    Unreal Engine flawlessly handles it. What’s more, by adding decorations to your
    classes, variables, and functions, you can expose them to the Blueprint system,
    letting your project be more flexible and accessible to non-code-oriented developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you created the main classes that will be used by your game and that
    extend those offered by the GF. Starting from the persistent GameInstance, you
    went to the Game Mode, and then to all the player-oriented elements. You now have
    a solid base to start developing your multiplayer project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will guide you through the creation of the player character
    by presenting how to manage it in a multiplayer environment.
  prefs: []
  type: TYPE_NORMAL
