<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer081">
			<h1 id="_idParaDest-125" class="chapter-number"><a id="_idTextAnchor217"/>7</h1>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor218"/>The General-Purpose Input/Output (GPIO) Peripheral</h1>
			<p>In this chapter, we will explore the <strong class="bold">General-Purpose Input/Output</strong> (<strong class="bold">GPIO</strong>) peripheral, an <a id="_idIndexMarker530"/>essential component in microcontrollers. This peripheral is crucial for interfacing with microcontrollers, making it fundamental to embedded <span class="No-Break">systems development.</span></p>
			<p>We will start by exploring the organization of GPIO ports and pins, covering both the general-purpose and alternate functions of these pins. Next, we will examine the key registers associated with the GPIO peripheral in STM32 microcontrollers. Finally, we will apply this knowledge to develop input and output drivers using the detailed register information we learn in <span class="No-Break">this chapter.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span><a id="_idTextAnchor219"/></p>
			<ul>
				<li>Understanding the <span class="No-Break">GPIO peripheral</span><a id="_idTextAnchor220"/></li>
				<li>The STM32 <span class="No-Break">GPIO registers</span></li>
				<li>Developing input and <span class="No-Break">output drivers</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to use the GPIO peripheral to interface effectively with microcontrollers, which will enable you to handle various input and output tasks <span class="No-Break">with confidence.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor221"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor222"/>Understanding the GPIO peripheral</h1>
			<p>Since we<a id="_idIndexMarker531"/> introduced the GPIO peripheral in <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, this section will reiterate the key points to remember <span class="No-Break">regarding GPIOs.</span></p>
			<p>Microcontroller pins are grouped into ports. For instance, a microcontroller might have ports named <strong class="bold">GPIOA</strong>, <strong class="bold">GPIOB</strong>, and <strong class="bold">GPIOC</strong>. See <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em> in <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. Each port is composed of individual<a id="_idIndexMarker532"/> pins, which are referred to by their port name, followed by their pin<a id="_idIndexMarker533"/> number. The <a id="_idIndexMarker534"/>following are examples of this <span class="No-Break">naming convention:</span></p>
			<ul>
				<li>PA1 refers to port A, <span class="No-Break">pin 1</span></li>
				<li>PD7 refers to port D, <span class="No-Break">pin 7</span></li>
			</ul>
			<p>This naming convention helps in identifying and configuring specific pins for <span class="No-Break">various functions.</span></p>
			<p>The STM32F411xC/E microcontroller series<a id="_idIndexMarker535"/> features six ports: <strong class="bold">PORTA</strong>, <strong class="bold">PORTB</strong>, <strong class="bold">PORTC</strong>, <strong class="bold">PORTD</strong>, <strong class="bold">PORTE</strong>, and <strong class="bold">PORTH</strong>. Each port is equipped with a comprehensive set of registers to manage configuration, data handling, <span class="No-Break">and functionality.</span></p>
			<p>These ports<a id="_idIndexMarker536"/> offer a variety of features designed for versatility and performance. The features offered include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">I/O control</strong>: They allow us to manage up to 16 input/output pins <span class="No-Break">per port.</span></li>
				<li><strong class="bold">Output states</strong>: Pins can be configured for push-pull or open-drain modes, with optional pull-up or <span class="No-Break">pull-down resistors.</span></li>
				<li><strong class="bold">Output data</strong>: Output data is driven by the <strong class="source-inline">GPIOx_ODR</strong> register when the pin is configured as a general-purpose output. For alternate function configurations, the associated peripheral drives the <span class="No-Break">output data.</span></li>
				<li><strong class="bold">Speed selection</strong>: The operating speed for each I/O pin can <span class="No-Break">be set.</span></li>
				<li><strong class="bold">Input states</strong>: Pins can be configured as floating, pull-up, pull-down, or <span class="No-Break">analog inputs.</span></li>
				<li><strong class="bold">Input data</strong>: Data can be read from the <strong class="source-inline">GPIOx_IDR</strong> register or an associated peripheral when configured for alternate <span class="No-Break">function input.</span></li>
				<li><strong class="bold">Configuration locking</strong>: The <strong class="source-inline">GPIOx_LCKR</strong> register can be used to lock the I/O configuration, preventing <span class="No-Break">accidental changes.</span></li>
				<li><strong class="bold">Alternate function selection</strong>: Up to 16 alternate functions per I/O pin can be configured, providing<a id="_idIndexMarker537"/> flexibility in <span class="No-Break">pin usage.</span></li>
			</ul>
			<p>In the next section, we shall explore some of the GPIO registers of the <span class="No-Break">STM32F411 microcontroller.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor223"/>The STM32 GPIO registers</h1>
			<p>In this section, we will<a id="_idIndexMarker538"/> explore the characteristics and functions of some of the common registers within the <span class="No-Break">GPIO peripheral.</span></p>
			<p>Each GPIO port includes a set of 32-bit registers essential for configuration and control. The configuration registers <a id="_idIndexMarker539"/>comprise <span class="No-Break">the f<a id="_idTextAnchor224"/>ollowing:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOx_MODER</strong> (<span class="No-Break">mode register)</span></li>
				<li><strong class="source-inline">GPIOx_OTYPER</strong> (output <span class="No-Break">type register)</span></li>
				<li><strong class="source-inline">GPIOx_OSPEEDR</strong> (output <span class="No-Break">speed register)</span></li>
				<li><strong class="source-inline">GPIOx_PUPDR</strong> (<span class="No-Break">pull-up/pull-down register)</span></li>
			</ul>
			<p>The <a id="_idIndexMarker540"/>data registers include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOx_IDR</strong> (input <span class="No-Break">data register)</span></li>
				<li><strong class="source-inline">GPIOx_ODR</strong> (output <span class="No-Break">data register)</span></li>
			</ul>
			<p><strong class="source-inline">GPIOx_BSRR</strong> (the bit-set/reset register) and <strong class="source-inline">GPIOx_LCKR</strong> (the locking register) are used to control pin states and access. Additionally, the alternate function selection registers, <strong class="source-inline">GPIOx_AFRH</strong> and <strong class="source-inline">GPIOx_AFRL</strong>, manage the alternate function assignments for the pins within the <span class="No-Break">GPIO port.</span></p>
			<p>Letâ€™s start with the GPIO <span class="No-Break">mode register.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor225"/>The GPIO mode register (GPIOx_MODER)</h2>
			<p>The <a id="_idIndexMarker541"/>GPIO port mode register (<strong class="source-inline">GPIOx_MODER</strong>) is an important register for configuring the mode of each pin in the GPIO port. This register allows us to set each pin in different modes, such as <strong class="bold">input</strong>, <strong class="bold">output</strong>, <strong class="bold">alternate function</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="bold">analog</strong></span><span class="No-Break">.</span></p>
			<p>It is a 32-bit register divided into 16 pairs of bits. Each pair of bits corresponds to a specific pin in the GPIO port, allowing the individual configuration of each pin. See <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.17</em> in <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
			<p>The possible configurations for these bits are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">00</strong>: Input mode (<span class="No-Break">reset state)</span><p class="list-inset">In this mode, the pin is configured as an input, which can be used to read signals from external devices such as a <span class="No-Break">push button.</span></p></li>
				<li><strong class="bold">01</strong>: General-purpose <span class="No-Break">output mode</span><p class="list-inset">This mode configures the pin as an output, which can be used to drive external signals or components such as <span class="No-Break">an LED.</span></p></li>
				<li><strong class="bold">10</strong>: Alternate <span class="No-Break">function mode</span><p class="list-inset">This mode sets the pin to an alternate function, allowing it to interface with various peripherals such as UART, SPI, <span class="No-Break">or I2C.</span></p></li>
				<li><strong class="bold">11</strong>: <span class="No-Break">Analog mode</span><p class="list-inset">This mode configures the pin for<a id="_idIndexMarker542"/> analog input, which is useful for <strong class="bold">analog-to-digital converter</strong> (<span class="No-Break"><strong class="bold">ADC</strong></span><span class="No-Break">) operations.</span></p></li>
			</ul>
			<p>Letâ€™s see a <span class="No-Break">practical example.</span></p>
			<p>Consider configuring a pin (e.g., <strong class="bold">PA5</strong>) on <span class="No-Break">port A:</span></p>
			<ol>
				<li>To set <strong class="bold">PA5</strong> as a general-purpose output (<strong class="bold">01</strong>), we can follow <span class="No-Break">these steps:</span><ul><li>Locate the bit pair corresponding to <strong class="bold">PA5 (MODER5[1:0])</strong>; these are <strong class="bold">bit11</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">bit10</strong></span></li><li>Write <strong class="bold">0</strong> to <strong class="bold">bit11</strong> and <strong class="bold">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">bit10</strong></span></li></ul></li>
				<li>To set <strong class="bold">PA5</strong> as an alternate function (<strong class="bold">10</strong>), we should write <strong class="bold">1</strong> to <strong class="bold">bit11</strong> and <strong class="bold">0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">bit10</strong></span><span class="No-Break">.</span></li>
				<li>To set <strong class="bold">PA5</strong> as an analog input (<strong class="bold">11</strong>), we should write <strong class="bold">1</strong> to <strong class="bold">bit11</strong> and <strong class="bold">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">bit10</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>This is all there<a id="_idIndexMarker543"/> is to know about the <span class="No-Break"><strong class="source-inline">GPIOx_MODER</strong></span><span class="No-Break"> register.</span></p>
			<p>Letâ€™s move on to examine two other important registers: the output data register (<strong class="source-inline">GPIOx_ODR</strong>) and the input data <span class="No-Break">register (</span><span class="No-Break"><strong class="source-inline">GPIOx_IDR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor226"/>The GPIO output data register (GPIOx_ODR) and the GPIO input data register (G<a id="_idTextAnchor227"/>PIOx_IDR)</h2>
			<p>The GPIO<a id="_idIndexMarker544"/> output data register (<strong class="source-inline">GPIOx_ODR</strong>) and GPIO input data register (<strong class="source-inline">GPIOx_IDR</strong>) are essential for managing the data flow through the GPIO pins. These registers allow for reading the state of pins and setting the state of pins, enabling our microcontroller to interact with external <span class="No-Break">devices effectively.</span></p>
			<p><strong class="source-inline">GPIOx_ODR</strong> is a 32-bit register, but only the lower 16 bits are used to control the output state of the pins. Each bit in the register corresponds to a pin in the <span class="No-Break">GPIO port.</span></p>
			<p>By writing to this register, we can set the logic level (high or low) of each pin configured<a id="_idTextAnchor228"/> as an output. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> shows the structure of the <a id="_idIndexMarker545"/>GPIO <strong class="bold">output data register</strong> (<strong class="bold">ODR</strong>) extracted from the <span class="No-Break">reference manual.</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B21914_07_1.jpg" alt="Figure 7.1: GPIO ODR" width="1650" height="229"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: GPIO ODR</p>
			<p>Take the <span class="No-Break">following examples:</span></p>
			<ul>
				<li>Writing <strong class="bold">1</strong> to <strong class="source-inline">bit5(ODR5)</strong> sets <strong class="bold">PA5</strong> to a <span class="No-Break">high state</span></li>
				<li>Writing <strong class="bold">0</strong> to <strong class="source-inline">bit5(ODR5)</strong> sets <strong class="bold">PA5</strong> to a <span class="No-Break">low state</span></li>
			</ul>
			<p><em class="italic">How about the GPIO input </em><span class="No-Break"><em class="italic">data register?</em></span></p>
			<p>The GPIO input data register (<strong class="source-inline">GPIOx_IDR</strong>) is <a id="_idIndexMarker546"/>used to read the current state of the GPIO pins configured as inputs. By reading from this register, we can determine whether each input is at a high or low <span class="No-Break">logic level.</span></p>
			<p>It is a 32-bit register, but similar to the ODR, only the lower 16 bits are used to read the state of the pins. Each bit in the register corresponds to a pin in the <span class="No-Break">GPIO port.</span></p>
			<p>A bit value of <strong class="bold">1</strong> indicates that the corresponding pin is at a high logic level, while a bit value of <strong class="bold">0</strong> indicates that it is at a l<a id="_idTextAnchor229"/>ow <span class="No-Break">logic level.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> shows the structure of the GPIO input <span class="No-Break">data register:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B21914_07_2.jpg" alt="Figure 7.2: GPIO input data register" width="1246" height="176"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: GPIO input data register</p>
			<p>Take the <span class="No-Break">following examples:</span></p>
			<ul>
				<li>If <strong class="source-inline">bit5(IDR5)</strong> reads <strong class="bold">1</strong>, <strong class="bold">PA5</strong> is at a <span class="No-Break">high state</span></li>
				<li>If <strong class="source-inline">bit5(IDR5)</strong> reads <strong class="bold">0</strong>, <strong class="bold">PA5</strong> is at a <span class="No-Break">low state</span></li>
			</ul>
			<p>Another commonly used register is the GPIO bit set/reset register (<strong class="source-inline">GPIOx_BSRR</strong>). Letâ€™s examine this register in the <span class="No-Break">next sec<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/><a id="_idTextAnchor232"/>tion.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor233"/>The GPIO bit-set/reset register (GPIOx_BSRR)</h2>
			<p>The <a id="_idIndexMarker547"/>GPIO bit-set/reset register (<strong class="source-inline">GPIOx_BSRR</strong>) is a crucial register for controlling the state of GPIO pins. It provides atomic bitwise operations to set or reset individual bits, which ensures that no interrupts can disrupt the operation, maintaining data integrity <span class="No-Break">during modifications.</span></p>
			<p><strong class="source-inline">GPIOx_BSRR</strong> is a 32-bit register<a id="_idIndexMarker548"/> divided into two <span class="No-Break">16-bit sections:</span></p>
			<ul>
				<li><strong class="bold">Bits 15:0 (BSy)</strong>: These bits are used to set the corresponding <span class="No-Break">GPIO pin</span></li>
				<li><strong class="bold">Bits 31:16 (BRy)</strong>: These bits are used to reset the corresponding <span class="No-Break">GPIO pin</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em> shows the <a id="_idIndexMarker549"/>structure of the GPIO <strong class="bold">bit-set/reset </strong><span class="No-Break"><strong class="bold">register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">BSRR</strong></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B21914_07_3.jpg" alt="Figure 7.3: BSRR" width="1242" height="210"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: BSRR</p>
			<p>Letâ€™s analyze the bits in <span class="No-Break">the register:</span></p>
			<ul>
				<li><strong class="bold">Bits 31:16 (BRy)</strong>: Writing <strong class="bold">1</strong> to any of the upper 16 bits resets the corresponding pin to a <span class="No-Break">low state</span></li>
				<li><strong class="bold">Bits 15:0 (BSy)</strong>: Writing <strong class="bold">1</strong> to any of the lower 16 bits sets the corresponding pin to a <span class="No-Break">high state</span></li>
			</ul>
			<p>For example, letâ€™s see how to set PA5 as high and low using <span class="No-Break">the BSRR:</span></p>
			<ul>
				<li>To set PA5 as <strong class="bold">high</strong>: We write <strong class="bold">1</strong> to <strong class="bold">bit5(BS5)</strong> in the <span class="No-Break"><strong class="source-inline">GPIOA_BSRR</strong></span><span class="No-Break"> register</span></li>
				<li>To set PA5 as <strong class="bold">low</strong>: We write <strong class="bold">1</strong> to <strong class="bold">bit21(BR21)</strong> in the <span class="No-Break"><strong class="source-inline">GPIOA_BSRR</strong></span><span class="No-Break"> register</span></li>
			</ul>
			<p>The GPIO BSRR (<strong class="source-inline">GPIOx_BSRR</strong>) provides a robust mechanism for controlling the state of GPIO pins. By understanding its structure and functionality, we can perform efficient and atomic operations to set or reset <span class="No-Break">individual pins.</span></p>
			<p>Another pair of commonly used GPIO registers are the GPIO alternate function high and alternate function low registers. Letâ€™s explore them in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-133">The GPIO alternate fun<a id="_idTextAnchor234"/>ction registers (GPIOx_AFRL and GPIOx_AFRH)</h2>
			<p>The GPIO <strong class="bold">alternate function registers</strong> (<strong class="bold">AFRs</strong>) are <a id="_idIndexMarker550"/>important for configuring the alternate functions of the GPIO pins in STM32 microcontrollers. These registers allow each pin to be assigned a specific peripheral function, enhancing the versatility and functionality of <span class="No-Break">the microcontroller.</span></p>
			<p>Each<a id="_idIndexMarker551"/> GPIO port<a id="_idIndexMarker552"/> has <span class="No-Break">two AFRs:</span></p>
			<ul>
				<li><strong class="bold">GPIOx_AFRL</strong>: <strong class="bold">Alternate function low register</strong> (<strong class="bold">AFRL</strong>), for<a id="_idIndexMarker553"/> pins 0 <span class="No-Break">to 7</span></li>
				<li><strong class="bold">GPIOx_AFRH</strong>: <strong class="bold">Alternate function high register</strong> (<strong class="bold">AFRH</strong>), for <a id="_idIndexMarker554"/>pins 8 <span class="No-Break">to 15</span></li>
			</ul>
			<p>These registers enable the selection of alternate functions for each pin, facilitating the use of the pins for various peripheral interfaces such as UART, I2C, <span class="No-Break">and SPI.</span></p>
			<p><strong class="source-inline">GPIOx_AFRL</strong> is a 32-bit register, divided into eight 4-bit fields. Each 4-bit field corresponds to one pin in the range of pins 0 to 7 in the <span class="No-Break">GPIO port.</span></p>
			<p><strong class="source-inline">GPIOx_AFRH</strong> is also a 32-bit register, divided into eight 4-bit fields. Here, each 4-bit field corresponds to one pin in the range of pins 8 to 15 in the <span class="No-Break">GPIO port.</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B21914_07_4.jpg" alt="Figure 7.4: Alternate function low register" width="1314" height="223"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Alternate function low register</p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.4</em> illustrates the AFRL. To understand the various alternate functions each pin can assume based on the values of the corresponding 4-bit fields, we will refer to <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em> as <span class="No-Break">our guide:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B21914_07_5.jpg" alt="Figure 7.5: Alternate function selection" width="655" height="1023"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Alternate function selection</p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.5</em> shows a <a id="_idIndexMarker555"/>diagram with two multiplexers. The first multiplexer represents the selector for the AFRL, while the second represents the selector for the AFRH. This diagram is sourced from page 150 of the reference manual. It effectively demonstrates how to configure GPIO pins for alternate functions on STM32F411 microcontrollers using <span class="No-Break">these registers.</span></p>
			<p>Letâ€™s break down what <span class="No-Break">we see.</span></p>
			<p>For both <strong class="source-inline">GPIOx_AFRL</strong> and <strong class="source-inline">GPIOx_AFRH</strong>, the diagram provides a list of the possible alternate functions that can be selected for each pin. The alternate functions are designated by <strong class="bold">AF0</strong> through <strong class="bold">AF15</strong>, each associated with specific peripheral functions, <span class="No-Break">as follows:</span></p>
			<table id="table001-4" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Alternate </strong><span class="No-Break"><strong class="bold">function description</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Binary value</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF0: <span class="No-Break">System functions</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0000</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF1: TIM1/TIM2</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0001</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF2: TIM3/TIM4/TIM5</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0010</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF3: TIM9/TIM10/TIM11</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0011</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF4: I2C1/I2C2/I2C3</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0100</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF5: SPI1/SPI2/SPI3/SPI4</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0101</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF6: SPI3/SPI4/SPI5</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0110</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF7: USART1/USART2</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0111</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF8: USART6</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1000</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF9: I2C2/I2C3</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1001</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF10: OTG_FS</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1010</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF11: Reserved</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1011</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF12: SDIO</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1100</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF13: Reserved</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1101</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF14: Reserved</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1110</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">AF15: EVENTOUT</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">1111</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1: Alternate function selection</p>
			<p>For example, to<a id="_idIndexMarker556"/> configure pin 5 (<strong class="bold">PA5</strong>) to be used by TIM9 (<strong class="bold">AF3</strong>), we write the value <strong class="bold">0011</strong> to bits [23:20] of the <strong class="source-inline">GPIOA_AFRL</strong> register. We use <strong class="source-inline">GPIOA_AFRL</strong> because PA5 falls within the range of pins 0 to 7, which are managed by this register. To configure pin 10 (<strong class="bold">PA10</strong>) to be used by the USART1 peripheral (<strong class="bold">AF7</strong>), we write the value <strong class="bold">0111</strong> to bits [7:4] of the <strong class="source-inline">GPIOA_AFRH</strong> register. This is because <strong class="bold">PA10</strong> falls within the range of pins 8 to 15, which are managed by the <span class="No-Break"><strong class="source-inline">GPIOA_AFRH</strong></span><span class="No-Break"> register.</span></p>
			<p>In this section, we explored the characteristics and functions of several essential registers within the STM32 GPIO peripheral. We began with the GPIO mode register (<strong class="source-inline">GPIOx_MODER</strong>), which configures the mode of each GPIO pin, allowing settings for the input, output, alternate function, or analog mode. We then examined the GPIO output data register (<strong class="source-inline">GPIOx_ODR</strong>) and input data register (<strong class="source-inline">GPIOx_IDR</strong>), which manage the data flow through the GPIO pins by setting and reading pin states. Next, we looked at the GPIO BSRR (<strong class="source-inline">GPIOx_BSRR</strong>), which provides atomic operations for setting and resetting individual pin states. Finally, we covered the GPIO alternate function registers (<strong class="source-inline">GPIOx_AFRL</strong> and <strong class="source-inline">GPIOx_AFRH</strong>), which assign specific peripheral functions to each pin, enhancing the <span class="No-Break">microcontrollerâ€™s versatility.</span></p>
			<p>In the next section, we will develop GPIO drivers using the knowledge gained in this section. Specifically, we will focus on creating input and output drivers. We will explore the practical usage of the alternate function registers in the chapters dedicated to <span class="No-Break">communication peripherals.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor235"/>Developing input and output drivers</h1>
			<p>In this section, we will apply the knowledge gained about the GPIO peripheral to develop practical input and output drivers for STM32 microcontrollers. Since we are already familiar with developing the output driver to toggle an LED using the ODR, this section will focus on developing the output driver using <span class="No-Break">the BSRR.</span><a id="_idTextAnchor236"/></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor237"/>The GPIO output driver using the BSRR</h2>
			<p>Letâ€™s <a id="_idIndexMarker557"/>start by making a copy of our last project in <span class="No-Break">our IDE:</span></p>
			<ol>
				<li>Right-click on the last project and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Copy</strong></span><span class="No-Break">.</span></li>
				<li>Right-click in the <strong class="bold">Project Explorer</strong> pane and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Paste</strong></span><span class="No-Break">.</span></li>
				<li>Rename the copied project <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">GpioInput-Output</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Next, we will modularize our code by creating dedicated files for the GPIO <span class="No-Break">driver code:</span></p>
			<ol>
				<li>Right-click on the <strong class="source-inline">Src</strong> folder in the project and select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">File Name</strong> field, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">gpio.c</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Then, we will create the corresponding <span class="No-Break">header file:</span></p>
			<ol>
				<li>Right-click on the <strong class="source-inline">Inc</strong> folder in the project and select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">File Name</strong> field, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">gpio.h</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Our next task is to implement the driver code in the <strong class="source-inline">gpio.c</strong> file and declare the public functions in the <span class="No-Break"><strong class="source-inline">gpio.h</strong></span><span class="No-Break"> file.</span></p>
			<p>Populate<a id="_idIndexMarker558"/> your <strong class="source-inline">gpio.c</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
#include "gpio.h"
#define GPIOAENÂ Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;0)
#define LED_BS5Â Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;5)Â Â /*Bit Set Pin 5*/
#define LED_BR5Â Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;21) /*Bit Reset Pin 5*/
void led_init(void)
{
Â Â Â Â /*Enable clock access to GPIOA*/
Â Â Â Â RCC-&gt;AHB1ENR |= GPIOAEN;
Â Â Â Â /*Set PA5 mode to output mode*/
Â Â Â Â GPIOA-&gt;MODER |=(1U&lt;&lt;10);
Â Â Â Â GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;11);
}
void led_on(void)
{
Â Â Â Â /*Set PA5 high*/
Â Â Â Â GPIOA-&gt;BSRR |=LED_BS5;
}
void led_off(void)
{
Â Â Â Â /*Set PA5 high*/
Â Â Â Â GPIOA-&gt;BSRR |=LED_BR5;
}</pre>			<p>Letâ€™s break<a id="_idIndexMarker559"/> down the unique elements of the <strong class="source-inline">gpio.c</strong> file, focusing on the usage of the BSRR. We start with the header <span class="No-Break">file inclusion:</span></p>
			<pre class="source-code">
#include "gpio.h"</pre>			<p>This line includes the <strong class="source-inline">gpio.h</strong> header file, which in turn includes <strong class="source-inline">stm32fxx.h</strong> to provide access to the <span class="No-Break">register definitions.</span></p>
			<p>Next, we define all the macros <span class="No-Break">we need:</span></p>
			<pre class="source-code">
#define GPIOAENÂ Â Â Â Â Â Â Â Â (1U&lt;&lt;0)
#define LED_BS5Â Â Â Â Â Â Â Â Â (1U&lt;&lt;5)Â Â /* Bit Set Pin 5 */
#define LED_BR5Â Â Â Â Â Â Â Â Â (1U&lt;&lt;21) /* Bit Reset Pin 5 */</pre>			<p>Letâ€™s break these <span class="No-Break">macros down:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOAEN</strong>: This macro is used to enable the clock for GPIOA by writing to the <span class="No-Break"><strong class="source-inline">AHB1ENR</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">LED_BS5</strong>: This macro represents the bit-set operation for pin PA5. Writing this value to the BSRR sets PA5 to high, turning the <span class="No-Break">LED on.</span></li>
				<li><strong class="source-inline">LED_BR5</strong>: This macro represents the bit-reset operation for pin PA5. Writing this value to the BSRR resets PA5 to low, turning the <span class="No-Break">LED off.</span></li>
			</ul>
			<p>Next, we implement the function for turning on <span class="No-Break">the LED:</span></p>
			<pre class="source-code">
void led_on(void)
{
Â Â Â Â /* Set PA5 high */
Â Â Â Â GPIOA-&gt;BSRR |= LED_BS5;
}</pre>			<p>The <strong class="source-inline">GPIOA-&gt;BSRR |= LED_BS5</strong> line uses the BSRR to set PA5 to high. Writing <strong class="bold">1</strong> to bit 5 of the<a id="_idIndexMarker560"/> BSRR sets the corresponding pin (PA5) to high, turning the <span class="No-Break">LED on.</span></p>
			<p>And then we implement the function to turn the <span class="No-Break">LED off:</span></p>
			<pre class="source-code">
void led_off(void)
{
Â Â Â Â /* Set PA5 low */
Â Â Â Â GPIOA-&gt;BSRR |= LED_BR5;
}</pre>			<p>Similarly, <strong class="source-inline">GPIOA-&gt;BSRR |= LED_BR5</strong> uses the BSRR to reset PA5 to low. Writing <strong class="bold">1</strong> to bit 21 of the BSRR resets the corresponding pin (PA5) to low, turning the <span class="No-Break">LED off.</span></p>
			<p>Here is the content for the <span class="No-Break"><strong class="source-inline">gpio.h</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
#ifndef GPIO_H_
#define GPIO_H_
#include "stm32f4xx.h"
void led_init(void);
void led_on(void);
void led_off(void);
#endif /* GPIO_H_ */</pre>			<p>Letâ€™s break it down, starting with the <span class="No-Break">header guard:</span></p>
			<pre class="source-code">
#ifndef GPIO_H_
#define GPIO_H_
...
#endif /* GPIO_H_ */</pre>			<p>The header guards prevent multiple inclusions of the same header file, which can lead to errors and redundant declarations. The <strong class="source-inline">#ifndef GPIO_H_</strong> directive checks whether <strong class="source-inline">GPIO_H_</strong> has been defined yet. If it hasnâ€™t, it proceeds to define <strong class="source-inline">GPIO_H_</strong> and includes the rest of the file. The <strong class="source-inline">#endif</strong> directive at the end closes the conditional directive that began <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">#ifndef</strong></span><span class="No-Break">.</span></p>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">include</strong></span><span class="No-Break"> directive:</span></p>
			<pre class="source-code">
#include "stm32f4xx.h"</pre>			<p>This directive<a id="_idIndexMarker561"/> includes the <strong class="source-inline">stm32f4xx.h</strong> header file, which in turn includes the <strong class="source-inline">stm32f411xe.h</strong> header file, which provides definitions and declarations for all the registers in <span class="No-Break">our microcontroller.</span></p>
			<p>And then we have the <span class="No-Break">function declarations:</span></p>
			<pre class="source-code">
void led_init(void);
void led_on(void);
void led_off(void);</pre>			<p>These declarations allow us to access the functions defined in the <strong class="source-inline">gpio.c</strong> file from other files, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break">.</span></p>
			<p>Now that our GPIO output driver for PA5 is complete, letâ€™s test it by updating the <strong class="source-inline">main.c</strong> file to call the functions defined in the <strong class="source-inline">gpio.c</strong> file. Here is the updated <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "gpio.h"
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
Â Â Â Â /*Initialize LED*/
Â Â Â Â led_init();
Â Â Â Â <strong class="bold">while</strong>(1)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â led_on();
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 100000; i++){}
Â Â Â Â Â Â Â Â Â Â Â Â led_off();
Â Â Â Â Â Â Â Â Â Â Â Â <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 100000; i++){}
Â Â Â Â }
}</pre>			<p>The code begins by including the <strong class="source-inline">gpio.h</strong> header file to access the GPIO functions defined in <strong class="source-inline">gpio.c</strong>. Within the <strong class="source-inline">main</strong> function, it first calls <strong class="source-inline">led_init()</strong> to initialize PA5 as an output pin. Then, it enters an infinite loop where it alternately turns the LED on and off by calling <strong class="source-inline">led_on()</strong> and <strong class="source-inline">led_off()</strong>, respectively. We use simple delay loops between these calls to keep the LED on and off for visible durations, effectively making the <a id="_idIndexMarker562"/>LED <span class="No-Break">blink continuously.</span></p>
			<p>Proc<a id="_idTextAnchor238"/>eed to build the project and run it on the development board. You should see the green <span class="No-Break">LED blinking.</span></p>
			<p>In the next section, we shall develop the GPIO input driver using <strong class="bold">PC13</strong>. We are using <strong class="bold">PC13</strong> because the blue push button of the development board is connected to <span class="No-Break">this pin.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor239"/>The GPIO input driver</h2>
			<p>Letâ€™s start by analyzing the<a id="_idIndexMarker563"/> initialization function. Add this function to the <span class="No-Break"><strong class="source-inline">gpio.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#define</strong> GPIOAENÂ Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;0)
<strong class="bold">#define GPIOCENÂ Â Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;2)</strong>
<strong class="bold">#define BTN_PINÂ Â Â Â Â Â Â Â Â Â Â Â Â (1U&lt;&lt;13)</strong>
void button_init(void)
{
Â Â Â Â /*Enable clock access to PORTC*/
Â Â Â Â RCC-&gt;AHB1ENR |=GPIOCEN;
Â Â Â Â /*Set PC13 as an input pin*/
Â Â Â Â GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;26);
Â Â Â Â GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;27);
}</pre>			<p>This function enables clock access to GPIO port C and configures pin PC13 as an <span class="No-Break">input pin:</span></p>
			<ul>
				<li><strong class="bold">GPIOC-&gt;MODER</strong>: This is the GPIO port mode register for port C. Each pair of bits in this register corresponds to the mode configuration of a <span class="No-Break">specific pin.</span></li>
				<li><strong class="bold">Clearing bits 26 and 27</strong>: The bits corresponding to pin 13 in the <strong class="bold">GPIOC-&gt;MODER</strong> register are bits <strong class="bold">26</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">27</strong></span><span class="No-Break">.</span><p class="list-inset">The bitwise AND operator combined with the bitwise NOT operator (<strong class="bold">&amp;=~</strong>) clears these bits, setting them to <strong class="bold">00</strong>. As we learned earlier, configuring these bits to <strong class="bold">00</strong> sets PC13 as an <span class="No-Break">input pin.</span></p></li>
			</ul>
			<p>Next, add the function for reading the state of <span class="No-Break">the pin:</span></p>
			<pre class="source-code">
bool get_btn_state(void)
{
Â Â Â Â /*Note : BTN is active low*/
Â Â Â Â /*Check if button is pressed*/
Â Â Â Â if(GPIOC-&gt;IDR &amp; BTN_PIN)
Â Â Â Â {
Â Â Â Â Â Â Â Â return false;
Â Â Â Â }
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â Â Â return true;
Â Â Â Â }
}</pre>			<p>This function <a id="_idIndexMarker564"/>reads the state of the button. The button is internally connected as an active-low input. This means the pin reads at a low logic level (0) when the button is pressed and a high logic level (1) when it is <span class="No-Break">not pressed.</span></p>
			<ul>
				<li><strong class="bold">GPIOC-&gt;IDR</strong>: This is the input data register for GPIO port C. It holds the current state of all the pins in <span class="No-Break">the port.</span></li>
				<li><strong class="bold">Bitwise AND Operator (&amp;)</strong>: This checks whether the bit corresponding to <strong class="bold">BTN_PIN</strong> in the IDR register is set <span class="No-Break">to high.</span></li>
				<li><span class="No-Break"><strong class="bold">Return values</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">false</strong>: If the bit is set, the button is <span class="No-Break">not pressed</span></li><li><strong class="source-inline">true</strong>: If the bit is not set, the button <span class="No-Break">is pressed</span></li></ul></li>
			</ul>
			<p>To be able to access these new functions from other files, such as <strong class="source-inline">main.c</strong>, we need to add their prototypes to the <span class="No-Break"><strong class="source-inline">gpio.h</strong></span><span class="No-Break"> file.</span></p>
			<p>Add the following lines <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">gpio.h</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;stdbool.h&gt;
void button_init(void);
bool get_btn_state(void);</pre>			<p>Now, letâ€™s test the<a id="_idIndexMarker565"/> new functions by updating the <strong class="source-inline">main.c</strong> file to <span class="No-Break">call them.</span></p>
			<p>The following is the updated <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
#include "gpio.h"
bool btn_state;
int main(void)
{
Â Â Â Â /*Initialize LED*/
Â Â Â Â led_init();
Â Â Â Â /*Initialize Pushbutton*/
Â Â Â Â button_init();
Â Â Â Â while(1)
Â Â Â Â {
Â Â Â Â Â Â Â Â /*Get Pushbutton State*/
Â Â Â Â Â Â Â Â btn_state = get_btn_state();
Â Â Â Â Â Â Â Â if(btn_state)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â led_on();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â led_off();
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>			<p>Letâ€™s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">bool btn_state</strong>: This variable holds the state of the <span class="No-Break">push button</span></li>
				<li><strong class="source-inline">led_init()</strong>: Configures PA5 as an <span class="No-Break">output pin</span></li>
				<li><strong class="source-inline">button_init()</strong>: Configures PC13 as an <span class="No-Break">input pin</span></li>
				<li><span class="No-Break"><strong class="source-inline">while(1){â€¦}</strong></span><span class="No-Break">:</span><ul><li>Continuously reads the state of the push button <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">get_btn_state()</strong></span></li><li>Turns the LED on if the button is pressed (<strong class="source-inline">btn_state</strong> <span class="No-Break">is true)</span></li><li>Turns the <a id="_idIndexMarker566"/>LED off if the button is not pressed (<strong class="source-inline">btn_state</strong> <span class="No-Break">is false)</span></li></ul></li>
			</ul>
			<p>Build the project and run it on the development board. You should see the green LED light up only when you press the <span class="No-Break">push button.</span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor240"/>Summary</h1>
			<p>In this chapter, we explored the GPIO peripheral, a critical peripheral in microcontrollers that is essential for interfacing with various external components. We began by understanding the organization of GPIO ports and pins, covering both general-purpose and <span class="No-Break">alternate functions.</span></p>
			<p>The STM32F411 microcontroller series features several ports, each equipped with registers to manage configuration, data handling, <span class="No-Break">and functionality.</span></p>
			<p>We introduced the registers associated with the GPIO peripheral, including configuration registers such as <strong class="source-inline">GPIOx_MODER</strong>, <strong class="source-inline">GPIOx_OTYPER</strong>, <strong class="source-inline">GPIOx_OSPEEDR</strong>, and <strong class="source-inline">GPIOx_PUPDR</strong>, as well as data registers such as <strong class="source-inline">GPIOx_IDR</strong> and <strong class="source-inline">GPIOx_ODR</strong>. We also covered <strong class="source-inline">GPIOx_BSRR</strong> (bit-set/reset register) for atomic pin state control and <strong class="source-inline">GPIOx_LCKR</strong> (locking register) for preventing accidental configuration changes. Additionally, we explored the GPIO alternate function registers (<strong class="source-inline">GPIOx_AFRL</strong> and <strong class="source-inline">GPIOx_AFRH</strong>), which enable versatile pin usage by assigning specific <span class="No-Break">peripheral functions.</span></p>
			<p>In practical terms, we developed both output and input drivers. We first created an output driver using the <strong class="source-inline">GPIOx_BSRR</strong> register to control the LED connected to pin PA5. This involved setting up the necessary macros, implementing initialization and control functions, and testing the driver by making the LED blink. We then developed an input driver for reading the state of the push button connected to pin PC13. This included configuring PC13 as an input pin, implementing a function to read the button state, and testing the driver by making the LED respond to <span class="No-Break">button presses.</span></p>
			<p>In the next chapter, we shall explore another important peripheral: the <strong class="bold">system tick </strong>(<span class="No-Break"><strong class="bold">SysTick</strong></span><span class="No-Break">) timer.</span></p>
		</div>
	</div>
</div>
</body></html>