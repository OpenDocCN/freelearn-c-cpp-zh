<html><head></head><body>
<div><div><div><h1 id="_idParaDest-125" class="chapter-number"><a id="_idTextAnchor217"/>7</h1>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor218"/>The General-Purpose Input/Output (GPIO) Peripheral</h1>
			<p>In this chapter, we will explore the <strong class="bold">General-Purpose Input/Output</strong> (<strong class="bold">GPIO</strong>) peripheral, an <a id="_idIndexMarker530"/>essential component in microcontrollers. This peripheral is crucial for interfacing with microcontrollers, making it fundamental to embedded systems development.</p>
			<p>We will start by exploring the organization of GPIO ports and pins, covering both the general-purpose and alternate functions of these pins. Next, we will examine the key registers associated with the GPIO peripheral in STM32 microcontrollers. Finally, we will apply this knowledge to develop input and output drivers using the detailed register information we learn in this chapter.</p>
			<p>In this chapter, we will cover the following main topics:<a id="_idTextAnchor219"/></p>
			<ul>
				<li>Understanding the GPIO peripheral<a id="_idTextAnchor220"/></li>
				<li>The STM32 GPIO registers</li>
				<li>Developing input and output drivers</li>
			</ul>
			<p>By the end of this chapter, you will be able to use the GPIO peripheral to interface effectively with microcontrollers, which will enable you to handle various input and output tasks with confidence.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor221"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor222"/>Understanding the GPIO peripheral</h1>
			<p>Since we<a id="_idIndexMarker531"/> introduced the GPIO peripheral in <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, this section will reiterate the key points to remember regarding GPIOs.</p>
			<p>Microcontroller pins are grouped into ports. For instance, a microcontroller might have ports named <strong class="bold">GPIOA</strong>, <strong class="bold">GPIOB</strong>, and <strong class="bold">GPIOC</strong>. See <em class="italic">Figure 2</em><em class="italic">.10</em> in <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>. Each port is composed of individual<a id="_idIndexMarker532"/> pins, which are referred to by their port name, followed by their pin<a id="_idIndexMarker533"/> number. The <a id="_idIndexMarker534"/>following are examples of this naming convention:</p>
			<ul>
				<li>PA1 refers to port A, pin 1</li>
				<li>PD7 refers to port D, pin 7</li>
			</ul>
			<p>This naming convention helps in identifying and configuring specific pins for various functions.</p>
			<p>The STM32F411xC/E microcontroller series<a id="_idIndexMarker535"/> features six ports: <strong class="bold">PORTA</strong>, <strong class="bold">PORTB</strong>, <strong class="bold">PORTC</strong>, <strong class="bold">PORTD</strong>, <strong class="bold">PORTE</strong>, and <strong class="bold">PORTH</strong>. Each port is equipped with a comprehensive set of registers to manage configuration, data handling, and functionality.</p>
			<p>These ports<a id="_idIndexMarker536"/> offer a variety of features designed for versatility and performance. The features offered include the following:</p>
			<ul>
				<li><strong class="bold">I/O control</strong>: They allow us to manage up to 16 input/output pins per port.</li>
				<li><strong class="bold">Output states</strong>: Pins can be configured for push-pull or open-drain modes, with optional pull-up or pull-down resistors.</li>
				<li><code>GPIOx_ODR</code> register when the pin is configured as a general-purpose output. For alternate function configurations, the associated peripheral drives the output data.</li>
				<li><strong class="bold">Speed selection</strong>: The operating speed for each I/O pin can be set.</li>
				<li><strong class="bold">Input states</strong>: Pins can be configured as floating, pull-up, pull-down, or analog inputs.</li>
				<li><code>GPIOx_IDR</code> register or an associated peripheral when configured for alternate function input.</li>
				<li><code>GPIOx_LCKR</code> register can be used to lock the I/O configuration, preventing accidental changes.</li>
				<li><strong class="bold">Alternate function selection</strong>: Up to 16 alternate functions per I/O pin can be configured, providing<a id="_idIndexMarker537"/> flexibility in pin usage.</li>
			</ul>
			<p>In the next section, we shall explore some of the GPIO registers of the STM32F411 microcontroller.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor223"/>The STM32 GPIO registers</h1>
			<p>In this section, we will<a id="_idIndexMarker538"/> explore the characteristics and functions of some of the common registers within the GPIO peripheral.</p>
			<p>Each GPIO port includes a set of 32-bit registers essential for configuration and control. The configuration registers <a id="_idIndexMarker539"/>comprise the f<a id="_idTextAnchor224"/>ollowing:</p>
			<ul>
				<li><code>GPIOx_MODER</code> (mode register)</li>
				<li><code>GPIOx_OTYPER</code> (output type register)</li>
				<li><code>GPIOx_OSPEEDR</code> (output speed register)</li>
				<li><code>GPIOx_PUPDR</code> (pull-up/pull-down register)</li>
			</ul>
			<p>The <a id="_idIndexMarker540"/>data registers include the following:</p>
			<ul>
				<li><code>GPIOx_IDR</code> (input data register)</li>
				<li><code>GPIOx_ODR</code> (output data register)</li>
			</ul>
			<p><code>GPIOx_BSRR</code> (the bit-set/reset register) and <code>GPIOx_LCKR</code> (the locking register) are used to control pin states and access. Additionally, the alternate function selection registers, <code>GPIOx_AFRH</code> and <code>GPIOx_AFRL</code>, manage the alternate function assignments for the pins within the GPIO port.</p>
			<p>Let’s start with the GPIO mode register.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor225"/>The GPIO mode register (GPIOx_MODER)</h2>
			<p>The <a id="_idIndexMarker541"/>GPIO port mode register (<code>GPIOx_MODER</code>) is an important register for configuring the mode of each pin in the GPIO port. This register allows us to set each pin in different modes, such as <strong class="bold">input</strong>, <strong class="bold">output</strong>, <strong class="bold">alternate function</strong>, or <strong class="bold">analog</strong>.</p>
			<p>It is a 32-bit register divided into 16 pairs of bits. Each pair of bits corresponds to a specific pin in the GPIO port, allowing the individual configuration of each pin. See <em class="italic">Figure 2</em><em class="italic">.17</em> in <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>.</p>
			<p>The possible configurations for these bits are the following:</p>
			<ul>
				<li><strong class="bold">00</strong>: Input mode (reset state)<p class="list-inset">In this mode, the pin is configured as an input, which can be used to read signals from external devices such as a push button.</p></li>
				<li><strong class="bold">01</strong>: General-purpose output mode<p class="list-inset">This mode configures the pin as an output, which can be used to drive external signals or components such as an LED.</p></li>
				<li><strong class="bold">10</strong>: Alternate function mode<p class="list-inset">This mode sets the pin to an alternate function, allowing it to interface with various peripherals such as UART, SPI, or I2C.</p></li>
				<li><strong class="bold">11</strong>: Analog mode<p class="list-inset">This mode configures the pin for<a id="_idIndexMarker542"/> analog input, which is useful for <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>) operations.</p></li>
			</ul>
			<p>Let’s see a practical example.</p>
			<p>Consider configuring a pin (e.g., <strong class="bold">PA5</strong>) on port A:</p>
			<ol>
				<li>To set <strong class="bold">PA5</strong> as a general-purpose output (<strong class="bold">01</strong>), we can follow these steps:<ul><li>Locate the bit pair corresponding to <strong class="bold">PA5 (MODER5[1:0])</strong>; these are <strong class="bold">bit11</strong> and <strong class="bold">bit10</strong></li><li>Write <strong class="bold">0</strong> to <strong class="bold">bit11</strong> and <strong class="bold">1</strong> to <strong class="bold">bit10</strong></li></ul></li>
				<li>To set <strong class="bold">PA5</strong> as an alternate function (<strong class="bold">10</strong>), we should write <strong class="bold">1</strong> to <strong class="bold">bit11</strong> and <strong class="bold">0</strong> to <strong class="bold">bit10</strong>.</li>
				<li>To set <strong class="bold">PA5</strong> as an analog input (<strong class="bold">11</strong>), we should write <strong class="bold">1</strong> to <strong class="bold">bit11</strong> and <strong class="bold">1</strong> to <strong class="bold">bit10</strong>.</li>
			</ol>
			<p>This is all there<a id="_idIndexMarker543"/> is to know about the <code>GPIOx_MODER</code> register.</p>
			<p>Let’s move on to examine two other important registers: the output data register (<code>GPIOx_ODR</code>) and the input data register (<code>GPIOx_IDR</code>).</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor226"/>The GPIO output data register (GPIOx_ODR) and the GPIO input data register (G<a id="_idTextAnchor227"/>PIOx_IDR)</h2>
			<p>The GPIO<a id="_idIndexMarker544"/> output data register (<code>GPIOx_ODR</code>) and GPIO input data register (<code>GPIOx_IDR</code>) are essential for managing the data flow through the GPIO pins. These registers allow for reading the state of pins and setting the state of pins, enabling our microcontroller to interact with external devices effectively.</p>
			<p><code>GPIOx_ODR</code> is a 32-bit register, but only the lower 16 bits are used to control the output state of the pins. Each bit in the register corresponds to a pin in the GPIO port.</p>
			<p>By writing to this register, we can set the logic level (high or low) of each pin configured<a id="_idTextAnchor228"/> as an output. <em class="italic">Figure 7</em><em class="italic">.1</em> shows the structure of the <a id="_idIndexMarker545"/>GPIO <strong class="bold">output data register</strong> (<strong class="bold">ODR</strong>) extracted from the reference manual.</p>
			<div><div><img src="img/B21914_07_1.jpg" alt="Figure 7.1: GPIO ODR" width="1650" height="229"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: GPIO ODR</p>
			<p>Take the following examples:</p>
			<ul>
				<li>Writing <code>bit5(ODR5)</code> sets <strong class="bold">PA5</strong> to a high state</li>
				<li>Writing <code>bit5(ODR5)</code> sets <strong class="bold">PA5</strong> to a low state</li>
			</ul>
			<p><em class="italic">How about the GPIO input </em><em class="italic">data register?</em></p>
			<p>The GPIO input data register (<code>GPIOx_IDR</code>) is <a id="_idIndexMarker546"/>used to read the current state of the GPIO pins configured as inputs. By reading from this register, we can determine whether each input is at a high or low logic level.</p>
			<p>It is a 32-bit register, but similar to the ODR, only the lower 16 bits are used to read the state of the pins. Each bit in the register corresponds to a pin in the GPIO port.</p>
			<p>A bit value of <strong class="bold">1</strong> indicates that the corresponding pin is at a high logic level, while a bit value of <strong class="bold">0</strong> indicates that it is at a l<a id="_idTextAnchor229"/>ow logic level.</p>
			<p><em class="italic">Figure 7</em><em class="italic">.2</em> shows the structure of the GPIO input data register:</p>
			<div><div><img src="img/B21914_07_2.jpg" alt="Figure 7.2: GPIO input data register" width="1246" height="176"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: GPIO input data register</p>
			<p>Take the following examples:</p>
			<ul>
				<li>If <code>bit5(IDR5)</code> reads <strong class="bold">1</strong>, <strong class="bold">PA5</strong> is at a high state</li>
				<li>If <code>bit5(IDR5)</code> reads <strong class="bold">0</strong>, <strong class="bold">PA5</strong> is at a low state</li>
			</ul>
			<p>Another commonly used register is the GPIO bit set/reset register (<code>GPIOx_BSRR</code>). Let’s examine this register in the next sec<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/><a id="_idTextAnchor232"/>tion.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor233"/>The GPIO bit-set/reset register (GPIOx_BSRR)</h2>
			<p>The <a id="_idIndexMarker547"/>GPIO bit-set/reset register (<code>GPIOx_BSRR</code>) is a crucial register for controlling the state of GPIO pins. It provides atomic bitwise operations to set or reset individual bits, which ensures that no interrupts can disrupt the operation, maintaining data integrity during modifications.</p>
			<p><code>GPIOx_BSRR</code> is a 32-bit register<a id="_idIndexMarker548"/> divided into two 16-bit sections:</p>
			<ul>
				<li><strong class="bold">Bits 15:0 (BSy)</strong>: These bits are used to set the corresponding GPIO pin</li>
				<li><strong class="bold">Bits 31:16 (BRy)</strong>: These bits are used to reset the corresponding GPIO pin</li>
			</ul>
			<p><em class="italic">Figure 7</em><em class="italic">.3</em> shows the <a id="_idIndexMarker549"/>structure of the GPIO <strong class="bold">bit-set/reset </strong><strong class="bold">register</strong> (<strong class="bold">BSRR</strong>).</p>
			<div><div><img src="img/B21914_07_3.jpg" alt="Figure 7.3: BSRR" width="1242" height="210"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: BSRR</p>
			<p>Let’s analyze the bits in the register:</p>
			<ul>
				<li><strong class="bold">Bits 31:16 (BRy)</strong>: Writing <strong class="bold">1</strong> to any of the upper 16 bits resets the corresponding pin to a low state</li>
				<li><strong class="bold">Bits 15:0 (BSy)</strong>: Writing <strong class="bold">1</strong> to any of the lower 16 bits sets the corresponding pin to a high state</li>
			</ul>
			<p>For example, let’s see how to set PA5 as high and low using the BSRR:</p>
			<ul>
				<li>To set PA5 as <code>GPIOA_BSRR</code> register</li>
				<li>To set PA5 as <code>GPIOA_BSRR</code> register</li>
			</ul>
			<p>The GPIO BSRR (<code>GPIOx_BSRR</code>) provides a robust mechanism for controlling the state of GPIO pins. By understanding its structure and functionality, we can perform efficient and atomic operations to set or reset individual pins.</p>
			<p>Another pair of commonly used GPIO registers are the GPIO alternate function high and alternate function low registers. Let’s explore them in the next section.</p>
			<h2 id="_idParaDest-133">The GPIO alternate fun<a id="_idTextAnchor234"/>ction registers (GPIOx_AFRL and GPIOx_AFRH)</h2>
			<p>The GPIO <strong class="bold">alternate function registers</strong> (<strong class="bold">AFRs</strong>) are <a id="_idIndexMarker550"/>important for configuring the alternate functions of the GPIO pins in STM32 microcontrollers. These registers allow each pin to be assigned a specific peripheral function, enhancing the versatility and functionality of the microcontroller.</p>
			<p>Each<a id="_idIndexMarker551"/> GPIO port<a id="_idIndexMarker552"/> has two AFRs:</p>
			<ul>
				<li><strong class="bold">GPIOx_AFRL</strong>: <strong class="bold">Alternate function low register</strong> (<strong class="bold">AFRL</strong>), for<a id="_idIndexMarker553"/> pins 0 to 7</li>
				<li><strong class="bold">GPIOx_AFRH</strong>: <strong class="bold">Alternate function high register</strong> (<strong class="bold">AFRH</strong>), for <a id="_idIndexMarker554"/>pins 8 to 15</li>
			</ul>
			<p>These registers enable the selection of alternate functions for each pin, facilitating the use of the pins for various peripheral interfaces such as UART, I2C, and SPI.</p>
			<p><code>GPIOx_AFRL</code> is a 32-bit register, divided into eight 4-bit fields. Each 4-bit field corresponds to one pin in the range of pins 0 to 7 in the GPIO port.</p>
			<p><code>GPIOx_AFRH</code> is also a 32-bit register, divided into eight 4-bit fields. Here, each 4-bit field corresponds to one pin in the range of pins 8 to 15 in the GPIO port.</p>
			<div><div><img src="img/B21914_07_4.jpg" alt="Figure 7.4: Alternate function low register" width="1314" height="223"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Alternate function low register</p>
			<p><em class="italic">Figure 7</em><em class="italic">.4</em> illustrates the AFRL. To understand the various alternate functions each pin can assume based on the values of the corresponding 4-bit fields, we will refer to <em class="italic">Figure 7</em><em class="italic">.5</em> as our guide:</p>
			<div><div><img src="img/B21914_07_5.jpg" alt="Figure 7.5: Alternate function selection" width="655" height="1023"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Alternate function selection</p>
			<p><em class="italic">Figure 7</em><em class="italic">.5</em> shows a <a id="_idIndexMarker555"/>diagram with two multiplexers. The first multiplexer represents the selector for the AFRL, while the second represents the selector for the AFRH. This diagram is sourced from page 150 of the reference manual. It effectively demonstrates how to configure GPIO pins for alternate functions on STM32F411 microcontrollers using these registers.</p>
			<p>Let’s break down what we see.</p>
			<p>For both <code>GPIOx_AFRL</code> and <code>GPIOx_AFRH</code>, the diagram provides a list of the possible alternate functions that can be selected for each pin. The alternate functions are designated by <strong class="bold">AF0</strong> through <strong class="bold">AF15</strong>, each associated with specific peripheral functions, as follows:</p>
			<table id="table001-4" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Alternate </strong><strong class="bold">function description</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">Binary value</strong></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF0: System functions</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0000</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF1: TIM1/TIM2</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0001</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF2: TIM3/TIM4/TIM5</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0010</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF3: TIM9/TIM10/TIM11</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0011</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF4: I2C1/I2C2/I2C3</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0100</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF5: SPI1/SPI2/SPI3/SPI4</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0101</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF6: SPI3/SPI4/SPI5</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0110</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF7: USART1/USART2</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0111</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF8: USART6</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1000</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF9: I2C2/I2C3</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1001</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF10: OTG_FS</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1010</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF11: Reserved</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1011</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF12: SDIO</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1100</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF13: Reserved</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1101</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF14: Reserved</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1110</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>AF15: EVENTOUT</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>1111</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1: Alternate function selection</p>
			<p>For example, to<a id="_idIndexMarker556"/> configure pin 5 (<code>GPIOA_AFRL</code> register. We use <code>GPIOA_AFRL</code> because PA5 falls within the range of pins 0 to 7, which are managed by this register. To configure pin 10 (<code>GPIOA_AFRH</code> register. This is because <code>GPIOA_AFRH</code> register.</p>
			<p>In this section, we explored the characteristics and functions of several essential registers within the STM32 GPIO peripheral. We began with the GPIO mode register (<code>GPIOx_MODER</code>), which configures the mode of each GPIO pin, allowing settings for the input, output, alternate function, or analog mode. We then examined the GPIO output data register (<code>GPIOx_ODR</code>) and input data register (<code>GPIOx_IDR</code>), which manage the data flow through the GPIO pins by setting and reading pin states. Next, we looked at the GPIO BSRR (<code>GPIOx_BSRR</code>), which provides atomic operations for setting and resetting individual pin states. Finally, we covered the GPIO alternate function registers (<code>GPIOx_AFRL</code> and <code>GPIOx_AFRH</code>), which assign specific peripheral functions to each pin, enhancing the microcontroller’s versatility.</p>
			<p>In the next section, we will develop GPIO drivers using the knowledge gained in this section. Specifically, we will focus on creating input and output drivers. We will explore the practical usage of the alternate function registers in the chapters dedicated to communication peripherals.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor235"/>Developing input and output drivers</h1>
			<p>In this section, we will apply the knowledge gained about the GPIO peripheral to develop practical input and output drivers for STM32 microcontrollers. Since we are already familiar with developing the output driver to toggle an LED using the ODR, this section will focus on developing the output driver using the BSRR.<a id="_idTextAnchor236"/></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor237"/>The GPIO output driver using the BSRR</h2>
			<p>Let’s <a id="_idIndexMarker557"/>start by making a copy of our last project in our IDE:</p>
			<ol>
				<li>Right-click on the last project and select <strong class="bold">Copy</strong>.</li>
				<li>Right-click in the <strong class="bold">Project Explorer</strong> pane and select <strong class="bold">Paste</strong>.</li>
				<li>Rename the copied project to <code>GpioInput-Output</code>.</li>
			</ol>
			<p>Next, we will modularize our code by creating dedicated files for the GPIO driver code:</p>
			<ol>
				<li>Right-click on the <code>Src</code> folder in the project and select <strong class="bold">New</strong> | <strong class="bold">File</strong>.</li>
				<li>In the <code>gpio.c</code>.</li>
			</ol>
			<p>Then, we will create the corresponding header file:</p>
			<ol>
				<li>Right-click on the <code>Inc</code> folder in the project and select <strong class="bold">New</strong> | <strong class="bold">File</strong>.</li>
				<li>In the <code>gpio.h</code>.</li>
			</ol>
			<p>Our next task is to implement the driver code in the <code>gpio.c</code> file and declare the public functions in the <code>gpio.h</code> file.</p>
			<p>Populate<a id="_idIndexMarker558"/> your <code>gpio.c</code> with the following code:</p>
			<pre class="source-code">
#include "gpio.h"
#define GPIOAEN            (1U&lt;&lt;0)
#define LED_BS5            (1U&lt;&lt;5)  /*Bit Set Pin 5*/
#define LED_BR5            (1U&lt;&lt;21) /*Bit Reset Pin 5*/
void led_init(void)
{
    /*Enable clock access to GPIOA*/
    RCC-&gt;AHB1ENR |= GPIOAEN;
    /*Set PA5 mode to output mode*/
    GPIOA-&gt;MODER |=(1U&lt;&lt;10);
    GPIOA-&gt;MODER &amp;=~(1U&lt;&lt;11);
}
void led_on(void)
{
    /*Set PA5 high*/
    GPIOA-&gt;BSRR |=LED_BS5;
}
void led_off(void)
{
    /*Set PA5 high*/
    GPIOA-&gt;BSRR |=LED_BR5;
}</pre>			<p>Let’s break<a id="_idIndexMarker559"/> down the unique elements of the <code>gpio.c</code> file, focusing on the usage of the BSRR. We start with the header file inclusion:</p>
			<pre class="source-code">
#include "gpio.h"</pre>			<p>This line includes the <code>gpio.h</code> header file, which in turn includes <code>stm32fxx.h</code> to provide access to the register definitions.</p>
			<p>Next, we define all the macros we need:</p>
			<pre class="source-code">
#define GPIOAEN         (1U&lt;&lt;0)
#define LED_BS5         (1U&lt;&lt;5)  /* Bit Set Pin 5 */
#define LED_BR5         (1U&lt;&lt;21) /* Bit Reset Pin 5 */</pre>			<p>Let’s break these macros down:</p>
			<ul>
				<li><code>GPIOAEN</code>: This macro is used to enable the clock for GPIOA by writing to the <code>AHB1ENR</code> register.</li>
				<li><code>LED_BS5</code>: This macro represents the bit-set operation for pin PA5. Writing this value to the BSRR sets PA5 to high, turning the LED on.</li>
				<li><code>LED_BR5</code>: This macro represents the bit-reset operation for pin PA5. Writing this value to the BSRR resets PA5 to low, turning the LED off.</li>
			</ul>
			<p>Next, we implement the function for turning on the LED:</p>
			<pre class="source-code">
void led_on(void)
{
    /* Set PA5 high */
    GPIOA-&gt;BSRR |= LED_BS5;
}</pre>			<p>The <code>GPIOA-&gt;BSRR |= LED_BS5</code> line uses the BSRR to set PA5 to high. Writing <strong class="bold">1</strong> to bit 5 of the<a id="_idIndexMarker560"/> BSRR sets the corresponding pin (PA5) to high, turning the LED on.</p>
			<p>And then we implement the function to turn the LED off:</p>
			<pre class="source-code">
void led_off(void)
{
    /* Set PA5 low */
    GPIOA-&gt;BSRR |= LED_BR5;
}</pre>			<p>Similarly, <code>GPIOA-&gt;BSRR |= LED_BR5</code> uses the BSRR to reset PA5 to low. Writing <strong class="bold">1</strong> to bit 21 of the BSRR resets the corresponding pin (PA5) to low, turning the LED off.</p>
			<p>Here is the content for the <code>gpio.h</code> file:</p>
			<pre class="source-code">
#ifndef GPIO_H_
#define GPIO_H_
#include "stm32f4xx.h"
void led_init(void);
void led_on(void);
void led_off(void);
#endif /* GPIO_H_ */</pre>			<p>Let’s break it down, starting with the header guard:</p>
			<pre class="source-code">
#ifndef GPIO_H_
#define GPIO_H_
...
#endif /* GPIO_H_ */</pre>			<p>The header guards prevent multiple inclusions of the same header file, which can lead to errors and redundant declarations. The <code>#ifndef GPIO_H_</code> directive checks whether <code>GPIO_H_</code> has been defined yet. If it hasn’t, it proceeds to define <code>GPIO_H_</code> and includes the rest of the file. The <code>#endif</code> directive at the end closes the conditional directive that began with <code>#ifndef</code>.</p>
			<p>Next, we have the <code>include</code> directive:</p>
			<pre class="source-code">
#include "stm32f4xx.h"</pre>			<p>This directive<a id="_idIndexMarker561"/> includes the <code>stm32f4xx.h</code> header file, which in turn includes the <code>stm32f411xe.h</code> header file, which provides definitions and declarations for all the registers in our microcontroller.</p>
			<p>And then we have the function declarations:</p>
			<pre class="source-code">
void led_init(void);
void led_on(void);
void led_off(void);</pre>			<p>These declarations allow us to access the functions defined in the <code>gpio.c</code> file from other files, such as <code>main.c</code>.</p>
			<p>Now that our GPIO output driver for PA5 is complete, let’s test it by updating the <code>main.c</code> file to call the functions defined in the <code>gpio.c</code> file. Here is the updated <code>main.c</code> code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "gpio.h"
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize LED*/
    led_init();
    <strong class="bold">while</strong>(1)
    {
            led_on();
            <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 100000; i++){}
            led_off();
            <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 100000; i++){}
    }
}</pre>			<p>The code begins by including the <code>gpio.h</code> header file to access the GPIO functions defined in <code>gpio.c</code>. Within the <code>main</code> function, it first calls <code>led_init()</code> to initialize PA5 as an output pin. Then, it enters an infinite loop where it alternately turns the LED on and off by calling <code>led_on()</code> and <code>led_off()</code>, respectively. We use simple delay loops between these calls to keep the LED on and off for visible durations, effectively making the <a id="_idIndexMarker562"/>LED blink continuously.</p>
			<p>Proc<a id="_idTextAnchor238"/>eed to build the project and run it on the development board. You should see the green LED blinking.</p>
			<p>In the next section, we shall develop the GPIO input driver using <strong class="bold">PC13</strong>. We are using <strong class="bold">PC13</strong> because the blue push button of the development board is connected to this pin.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor239"/>The GPIO input driver</h2>
			<p>Let’s start by analyzing the<a id="_idIndexMarker563"/> initialization function. Add this function to the <code>gpio.c</code> file:</p>
			<pre class="source-code">
<strong class="bold">#define</strong> GPIOAEN            (1U&lt;&lt;0)
<strong class="bold">#define GPIOCEN             (1U&lt;&lt;2)</strong>
<strong class="bold">#define BTN_PIN             (1U&lt;&lt;13)</strong>
void button_init(void)
{
    /*Enable clock access to PORTC*/
    RCC-&gt;AHB1ENR |=GPIOCEN;
    /*Set PC13 as an input pin*/
    GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;26);
    GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;27);
}</pre>			<p>This function enables clock access to GPIO port C and configures pin PC13 as an input pin:</p>
			<ul>
				<li><strong class="bold">GPIOC-&gt;MODER</strong>: This is the GPIO port mode register for port C. Each pair of bits in this register corresponds to the mode configuration of a specific pin.</li>
				<li><strong class="bold">Clearing bits 26 and 27</strong>: The bits corresponding to pin 13 in the <strong class="bold">GPIOC-&gt;MODER</strong> register are bits <strong class="bold">26</strong> and <strong class="bold">27</strong>.<p class="list-inset">The bitwise AND operator combined with the bitwise NOT operator (<strong class="bold">&amp;=~</strong>) clears these bits, setting them to <strong class="bold">00</strong>. As we learned earlier, configuring these bits to <strong class="bold">00</strong> sets PC13 as an input pin.</p></li>
			</ul>
			<p>Next, add the function for reading the state of the pin:</p>
			<pre class="source-code">
bool get_btn_state(void)
{
    /*Note : BTN is active low*/
    /*Check if button is pressed*/
    if(GPIOC-&gt;IDR &amp; BTN_PIN)
    {
        return false;
    }
    else
    {
        return true;
    }
}</pre>			<p>This function <a id="_idIndexMarker564"/>reads the state of the button. The button is internally connected as an active-low input. This means the pin reads at a low logic level (0) when the button is pressed and a high logic level (1) when it is not pressed.</p>
			<ul>
				<li><strong class="bold">GPIOC-&gt;IDR</strong>: This is the input data register for GPIO port C. It holds the current state of all the pins in the port.</li>
				<li><strong class="bold">Bitwise AND Operator (&amp;)</strong>: This checks whether the bit corresponding to <strong class="bold">BTN_PIN</strong> in the IDR register is set to high.</li>
				<li><code>false</code>: If the bit is set, the button is not pressed</li><li><code>true</code>: If the bit is not set, the button is pressed</li></ul></li>
			</ul>
			<p>To be able to access these new functions from other files, such as <code>main.c</code>, we need to add their prototypes to the <code>gpio.h</code> file.</p>
			<p>Add the following lines to <code>gpio.h</code>:</p>
			<pre class="source-code">
#include &lt;stdbool.h&gt;
void button_init(void);
bool get_btn_state(void);</pre>			<p>Now, let’s test the<a id="_idIndexMarker565"/> new functions by updating the <code>main.c</code> file to call them.</p>
			<p>The following is the updated <code>main.c</code> code:</p>
			<pre class="source-code">
#include "gpio.h"
bool btn_state;
int main(void)
{
    /*Initialize LED*/
    led_init();
    /*Initialize Pushbutton*/
    button_init();
    while(1)
    {
        /*Get Pushbutton State*/
        btn_state = get_btn_state();
        if(btn_state)
        {
            led_on();
        }
        else
        {
            led_off();
        }
    }
}</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><code>bool btn_state</code>: This variable holds the state of the push button</li>
				<li><code>led_init()</code>: Configures PA5 as an output pin</li>
				<li><code>button_init()</code>: Configures PC13 as an input pin</li>
				<li><code>while(1){…}</code>:<ul><li>Continuously reads the state of the push button using <code>get_btn_state()</code></li><li>Turns the LED on if the button is pressed (<code>btn_state</code> is true)</li><li>Turns the <a id="_idIndexMarker566"/>LED off if the button is not pressed (<code>btn_state</code> is false)</li></ul></li>
			</ul>
			<p>Build the project and run it on the development board. You should see the green LED light up only when you press the push button.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor240"/>Summary</h1>
			<p>In this chapter, we explored the GPIO peripheral, a critical peripheral in microcontrollers that is essential for interfacing with various external components. We began by understanding the organization of GPIO ports and pins, covering both general-purpose and alternate functions.</p>
			<p>The STM32F411 microcontroller series features several ports, each equipped with registers to manage configuration, data handling, and functionality.</p>
			<p>We introduced the registers associated with the GPIO peripheral, including configuration registers such as <code>GPIOx_MODER</code>, <code>GPIOx_OTYPER</code>, <code>GPIOx_OSPEEDR</code>, and <code>GPIOx_PUPDR</code>, as well as data registers such as <code>GPIOx_IDR</code> and <code>GPIOx_ODR</code>. We also covered <code>GPIOx_BSRR</code> (bit-set/reset register) for atomic pin state control and <code>GPIOx_LCKR</code> (locking register) for preventing accidental configuration changes. Additionally, we explored the GPIO alternate function registers (<code>GPIOx_AFRL</code> and <code>GPIOx_AFRH</code>), which enable versatile pin usage by assigning specific peripheral functions.</p>
			<p>In practical terms, we developed both output and input drivers. We first created an output driver using the <code>GPIOx_BSRR</code> register to control the LED connected to pin PA5. This involved setting up the necessary macros, implementing initialization and control functions, and testing the driver by making the LED blink. We then developed an input driver for reading the state of the push button connected to pin PC13. This included configuring PC13 as an input pin, implementing a function to read the button state, and testing the driver by making the LED respond to button presses.</p>
			<p>In the next chapter, we shall explore another important peripheral: the <strong class="bold">system tick </strong>(<strong class="bold">SysTick</strong>) timer.</p>
		</div>
	</div>
</div>
</body></html>