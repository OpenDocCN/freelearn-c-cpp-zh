["```cpp\n    QT += core gui opengl\n    ```", "```cpp\n    LIBS += -lopengl32 -lglu32\n    ```", "```cpp\n    #include <QtOpenGL>\n    ```", "```cpp\n    #include <QApplication>\n    #include <QtOpenGL>\n    int main(int argc, char *argv[])\n    {\n        QApplication app(argc, argv);\n        QOpenGLWindow window;\n        window.setTitle(\"Hello World!\");\n        window.resize(640, 480);\n        window.show();\n        return app.exec();\n    }\n    ```", "```cpp\n    #include <GL/glu.h>\n    #include <QtOpenGL>\n    #include <QSurfaceFormat>\n    #include <QOpenGLFunctions>\n    #include <QOpenGLWindow>\n    #include <QOpenGLBuffer>\n    #include <QOpenGLVertexArrayObject>\n    #include <QOpenGLShader>\n    #include <QOpenGLShaderProgram>\n    ```", "```cpp\n    class RenderWindow : public QOpenGLWindow {\n    public:\n        RenderWindow();\n    protected:\n        void initializeGL();\n        void paintGL();\n        void paintEvent(QPaintEvent *event);\n        void resizeEvent(QResizeEvent *event);\n    ```", "```cpp\n    private:\n        QOpenGLContext* openGLContext;\n        QOpenGLFunctions* openGLFunctions;\n        QOpenGLShaderProgram* shaderProgram;\n        QOpenGLVertexArrayObject* vao;\n        QOpenGLBuffer* vbo_vertices;\n    };\n    ```", "```cpp\n    RenderWindow::RenderWindow() {\n        setSurfaceType(QWindow::OpenGLSurface);\n        QSurfaceFormat format;\n        format.setProfile(QSurfaceFormat::CoreProfile);\n        format.setVersion(3, 2);\n        setFormat(format);\n        openGLContext = new QOpenGLContext();\n        openGLContext->setFormat(format);\n        openGLContext->create();\n        openGLContext->makeCurrent(this);\n    }\n    ```", "```cpp\n    void RenderWindow::initializeGL() {\n        openGLFunctions = openGLContext->functions();\n        static const char *vertexShaderSource =\n        \"#version 330 core\\n\"\n        \"layout(location = 0) in vec2 posAttr;\\n\"\n        \"void main() {\\n\"\n        \"gl_Position = vec4(posAttr, 0.0, 1.0); }\";\n        static const char *fragmentShaderSource =\n        \"#version 330 core\\n\"\n        \"out vec4 col;\\n\"\n        \"void main() {\\n\"\n        \"col = vec4(1.0, 0.0, 0.0, 1.0); }\";\n    ```", "```cpp\n        shaderProgram = new QOpenGLShaderProgram(this);\n        shaderProgram->addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource);\n        shaderProgram->addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource);\n        shaderProgram->link();\n    // The vertex coordinates of our triangle\n        GLfloat vertices[] = {\n        -1.0f, -1.0f,\n        1.0f, -1.0f,\n        0.0f, 1.0f };\n        vao = new QOpenGLVertexArrayObject();\n        vao->create();\n        vao->bind();\n    ```", "```cpp\n        vbo_vertices = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);\n        vbo_vertices->create();\n        vbo_vertices->setUsagePattern(QOpenGLBuffer::StaticDraw);\n        vbo_vertices->bind();\n        vbo_vertices->allocate(vertices, sizeof(vertices) *\n        sizeof(GLfloat));\n        vao->release();\n    }\n    ```", "```cpp\n    void RenderWindow::paintEvent(QPaintEvent *event) {\n        Q_UNUSED(event);\n        glViewport(0, 0, width(), height());\n        // Clear our screen with corn flower blue color\n        glClearColor(0.39f, 0.58f, 0.93f, 1.f);\n        glClear(GL_COLOR_BUFFER_BIT);\n    ```", "```cpp\n        vao->bind();\n        shaderProgram->bind();\n        shaderProgram->bindAttributeLocation(\"posAttr\", 0);\n        shaderProgram->enableAttributeArray(0);\n        shaderProgram->setAttributeBuffer(0, GL_FLOAT, 0, 2);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n        shaderProgram->release();\n        vao->release();\n    }\n    ```", "```cpp\n    void RenderWindow::resizeEvent(QResizeEvent *event) {\n        Q_UNUSED(event);\n        glViewport(0, 0, this->width(), this->height());\n        this->update();\n    }\n    ```", "```cpp\n    private:\n        QOpenGLContext* openGLContext;\n        QOpenGLFunctions* openGLFunctions;\n        QOpenGLShaderProgram* shaderProgram;\n        QOpenGLVertexArrayObject* vao;\n        QOpenGLBuffer* vbo_vertices;\n        QOpenGLBuffer* vbo_vertices2;\n        renderwindow.cpp and add the following code to the shader code, as highlighted in the following snippet:\n\n    ```", "```cpp\n\n    ```", "```cpp\n        static const char *fragmentShaderSource =\n        \"#version 330 core\\n\"\n        \"in vec3 fragCol;\\n\"\n        \"out vec4 col;\\n\"\n        \"void main() {\\n\"\n        \"col = vec4(fragCol, 1.0); }\";\n    ```", "```cpp\n        GLfloat vertices[] = {\n        -0.3f, -0.5f,\n        0.8f, -0.4f,\n        0.2f, 0.6f };\n        GLfloat vertices2[] = {\n        0.5f, 0.3f,\n        0.4f, -0.8f,\n        -0.6f, -0.2f };\n        GLfloat colors[] = {\n        1.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 1.0f };\n    ```", "```cpp\n        vbo_vertices2 = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);\n        vbo_vertices2->create();\n        vbo_vertices2->setUsagePattern(QOpenGLBuffer::StaticDraw);\n        vbo_vertices2->bind();\n        vbo_vertices2->allocate(vertices2, sizeof(vertices2) *\n        sizeof(GLfloat));\n        vbo_colors = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);\n        vbo_colors->create();\n        vbo_colors->setUsagePattern(QOpenGLBuffer::StaticDraw);\n        vbo_colors->bind();\n        vbo_colors->allocate(colors, sizeof(colors) * sizeof(GLfloat));\n    ```", "```cpp\n        vbo_vertices->bind();\n        shaderProgram->bindAttributeLocation(\"posAttr\", 0);\n        shaderProgram->enableAttributeArray(0);\n        shaderProgram->setAttributeBuffer(0, GL_FLOAT, 0, 2);\n        vbo_colors->bind();\n        shaderProgram->bindAttributeLocation(\"colAttr\", 1);\n        shaderProgram->enableAttributeArray(1);\n        shaderProgram->setAttributeBuffer(1, GL_FLOAT, 0, 3);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n    ```", "```cpp\n        vbo_vertices2->bind();\n        shaderProgram->bindAttributeLocation(\"posAttr\", 0);\n        shaderProgram->enableAttributeArray(0);\n        shaderProgram->setAttributeBuffer(0, GL_FLOAT, 0, 2);\n        vbo_colors->bind();\n        shaderProgram->bindAttributeLocation(\"colAttr\", 1);\n        shaderProgram->enableAttributeArray(1);\n        shaderProgram->setAttributeBuffer(1, GL_FLOAT, 0, 3);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n    ```", "```cpp\n    void RenderWindow::initializeGL() {\n        openGLFunctions = openGLContext->functions();\n        GL_DEPTH_TEST in the preceding step, we must also set the depth buffer size when setting the OpenGL profile:\n\n    ```", "```cpp\n        GLfloat vertices[] = {\n         -1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f, 1.0f,\n         1.0f,-1.0f,-1.0f,1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f,\n         -1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f,-1.0f,\n         1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f, 1.0f,\n         -1.0f,-1.0f, 1.0f,1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,\n         1.0f,-1.0f, 1.0f,1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f,\n         -1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f,-1.0f,-1.0f,\n         1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f, 1.0f,-1.0f,\n         -1.0f,-1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f,-1.0f,-1.0f,\n         -1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,\n         1.0f,-1.0f, 1.0f,1.0f,-1.0f,-1.0f,1.0f, 1.0f,-1.0f,\n         1.0f,-1.0f, 1.0f,1.0f, 1.0f,-1.0f,1.0f, 1.0f, 1.0f\n     };\n    ```", "```cpp\n\n    ```", "```cpp\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    ```", "```cpp\n        QMatrix4x4 matrixMVP;\n        QMatrix4x4 model, view, projection;\n        model.translate(0, 1, 0);\n        model.rotate(45, 0, 1, 0);\n        view.lookAt(QVector3D(4, 4, 0), QVector3D(0, 0, 0),\n        QVector3D(0, 1, 0));\n        projection.perspective(60.0f,\n         ((float)this->width()/(float)this->height()), 0.1f, 100.0f);\n        matrixMVP = projection * view * model;\n        shaderProgram->setUniformValue(\"matrix\", matrixMVP);\n    ```", "```cpp\n        glDrawArrays(GL_TRIANGLES, 0, 36);\n    ```", "```cpp\n        static const char *vertexShaderSource =\n        \"#version 330 core\\n\"\n        \"layout(location = 0) in vec3 posAttr;\\n\"\n        \"uniform mat4 matrix;\\n\"\n        \"out vec3 fragPos;\\n\"\n        \"void main() {\\n\"\n        \"fragPos = posAttr;\\n\"\n        \"gl_Position = matrix * vec4(posAttr, 1.0); }\";\n        static const char *fragmentShaderSource =\n        \"#version 330 core\\n\"\n        \"in vec3 fragPos;\\n\"\n        \"out vec4 col;\\n\"\n        \"void main() {\\n\"\n        \"col = vec4(fragPos, 1.0); }\";\n    ```", "```cpp\n    #include <QElapsedTimer>\n    ```", "```cpp\n        QElapsedTimer* time;\n        int currentTime = 0;\n        int oldTime = 0;\n        float deltaTime = 0;\n        float rotation = 0;\n    ```", "```cpp\n        openGLContext = new QOpenGLContext();\n        openGLContext->setFormat(format);\n        openGLContext->create();\n        openGLContext->makeCurrent(this);\n        time = new QElapsedTimer();\n        paintEvent() function. deltaTime is the value of the elapsed time of each frame, which is used to make animation speed consistent, regardless of frame rate performance:\n\n    ```", "```cpp\n        rotation += deltaTime * 50;\n        QMatrix4x4 matrixMVP;\n        QMatrix4x4 model, view, projection;\n        model.translate(0, 1, 0);\n        model.rotate(rotation, 0, 1, 0);\n    ```", "```cpp\n\n    ```", "```cpp\n        glDrawArrays(GL_TRIANGLES, 0, 36);\n        shaderProgram->release();\n        vao->release();\n        this->update();\n    }\n    ```", "```cpp\n        QOpenGLContext* openGLContext;\n        QOpenGLFunctions* openGLFunctions;\n        QOpenGLShaderProgram* shaderProgram;\n        QOpenGLVertexArrayObject* vao;\n        QOpenGLBuffer* vbo_vertices;\n        QOpenGLBuffer* vbo_uvs;\n        glEnable(GL_TEXTURE_2D) in the initializeGL() function to enable the texture mapping feature:\n\n    ```", "```cpp\n        texture = new QOpenGLTexture(QImage(qApp->applicationDirPath() + \"/brick.jpg\").mirrored());\n        texture->setMinificationFilter(QOpenGLTexture::Nearest);\n        texture->setMagnificationFilter(QOpenGLTexture::Linear);\n    ```", "```cpp\n\n    ```", "```cpp\n        GLfloat uvs[] = {\n         0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n         1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,\n         0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,\n         1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,\n         1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,\n         0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,\n         0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,\n         1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,\n         0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,\n         0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,\n         1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,\n         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f\n    };\n    ```", "```cpp\n        static const char *vertexShaderSource =\n        \"#version 330 core\\n\"\n        \"layout(location = 0) in vec3 posAttr;\\n\"\n        \"layout(location = 1) in vec2 uvAttr;\\n\"\n        \"uniform mat4 matrix;\\n\"\n        \"out vec3 fragPos;\\n\"\n        \"out vec2 fragUV;\\n\"\n        \"void main() {\\n\"\n        \"fragPos = posAttr;\\n\"\n        \"fragUV = uvAttr;\\n\"\n        \"gl_Position = matrix * vec4(posAttr, 1.0); }\";\n    ```", "```cpp\n        static const char *fragmentShaderSource =\n        \"#version 330 core\\n\"\n        \"in vec3 fragPos;\\n\"\n        \"in vec2 fragUV;\\n\"\n        \"uniform sampler2D tex;\\n\"\n        \"out vec4 col;\\n\"\n        \"void main() {\\n\"\n        \"vec4 texCol = texture(tex, fragUV);\\n\"\n        \"col = texCol; }\";\n    ```", "```cpp\n        vbo_uvs = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);\n        vbo_uvs->create();\n        vbo_uvs->setUsagePattern(QOpenGLBuffer::StaticDraw);\n        vbo_uvs->bind();\n        vbo_uvs->allocate(uvs, sizeof(uvs) * sizeof(GLfloat));\n    ```", "```cpp\n        vbo_uvs->bind();\n        shaderProgram->bindAttributeLocation(\"uvAttr\", 1);\n        shaderProgram->enableAttributeArray(1);\n        shaderProgram->setAttributeBuffer(1, GL_FLOAT, 0, 2);\n        texture->bind();\n        glDrawArrays(GL_TRIANGLES, 0, 36);\n    ```", "```cpp\n        QOpenGLBuffer* vbo_uvs;\n        QOpenGLBuffer* vbo_normals;\n        QOpenGLTexture* texture;\n    ```", "```cpp\n        GLfloat normals[] = {\n         0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,\n         0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,\n         0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,\n         0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,\n         1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n         1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n         0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n         0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,\n         -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,\n         -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,\n         0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f,\n         0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f\n    };\n    ```", "```cpp\n        vbo_normals = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);\n        vbo_normals->create();\n        vbo_normals->setUsagePattern(QOpenGLBuffer::StaticDraw);\n        vbo_normals->bind();\n        vbo_normals->allocate(normals, sizeof(normals) * sizeof(GLfloat));\n    ```", "```cpp\n        shaderProgram = new QOpenGLShaderProgram(this);\n        shaderProgram->addShaderFromSourceFile(QOpenGLShader::Vertex,\n        qApp->applicationDirPath() + \"/vertex.txt\");\n        shaderProgram->addShaderFromSourceFile(QOpenGLShader::Fragment,\n        qApp->applicationDirPath() + \"/fragment.txt\");\n    shaderProgram->link();\n    ```", "```cpp\n        vbo_normals->bind();\n        shaderProgram->bindAttributeLocation(\"normalAttr\", 2);\n        shaderProgram->enableAttributeArray(2);\n        shaderProgram->setAttributeBuffer(2, GL_FLOAT, 0, 3);\n    ```", "```cpp\n        #version 330 core\n        layout(location = 0) in vec3 posAttr;\n        layout(location = 1) in vec2 uvAttr;\n        layout(location = 2) in vec3 normalAttr;\n        uniform mat4 matrix;\n        out vec3 fragPos;\n        out vec2 fragUV;\n        out vec3 fragNormal;\n    void main() {\n        fragPos = posAttr;\n        fragUV = uvAttr;\n        fragNormal = normalAttr;\n        gl_Position = matrix * vec4(posAttr, 1.0);\n    }\n    ```", "```cpp\n        #version 330 core\n        in vec3 fragPos;\n        in vec2 fragUV;\n        in vec3 fragNormal;\n        uniform sampler2D tex;\n        out vec4 col;\n        vec4 calcPointLight() {\n        vec4 texCol = texture(tex, fragUV);\n        vec3 lightPos = vec3(1.0, 2.0, 1.5);\n        vec3 lightDir = normalize(lightPos - fragPos);\n        vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);\n        calcPointLight() and output the resulting fragment to the col variable, as follows:\n\n    ```", "```cpp\n\n    ```", "```cpp\n        QElapsedTimer* time;\n        int currentTime = 0;\n        int oldTime = 0;\n        float deltaTime = 0;\n        float rotation = 0;\n        float moveX = 0;\n        float moveZ = 0;\n        keyPressEvent() and keyReleaseEvent():\n\n    ```", "```cpp\n\n    ```", "```cpp\n    void RenderWindow::keyPressEvent(QKeyEvent *event) {\n        if (event->key() == Qt::Key_W) { moveZ = -10; }\n        if (event->key() == Qt::Key_S) { moveZ = 10; }\n        if (event->key() == Qt::Key_A) { moveX = -10; }\n        if (event->key() == Qt::Key_D) { moveX = 10; }\n    }\n    ```", "```cpp\n    void RenderWindow::keyReleaseEvent(QKeyEvent *event) {\n        if (event->key() == Qt::Key_W) { moveZ = 0; }\n        if (event->key() == Qt::Key_S) { moveZ = 0; }\n        if (event->key() == Qt::Key_A) { moveX = 0; }\n        if (event->key() == Qt::Key_D) { moveX = 0; }\n    }\n    ```", "```cpp\n        //rotation += deltaTime * 50;\n        movement.setX(movement.x() + moveX * deltaTime);\n        movement.setZ(movement.z() + moveZ * deltaTime);\n        QMatrix4x4 matrixMVP;\n        QMatrix4x4 model, view, projection;\n        model.translate(movement.x(), 1, movement.z());\n    ```", "```cpp\n    import QtQuick\n    import QtQuick3D\n    Window {\n        width: 640\n        height: 480\n        visible: true\n        title: qsTr(\"Hello World\")\n        View3D {\n            id: view\n            anchors.fill: parent\n        }\n    }\n    ```", "```cpp\n    environment: SceneEnvironment {\n        clearColor: \"skyblue\"\n        backgroundMode: SceneEnvironment.Color\n    }\n    ```", "```cpp\n    Model {\n        position: Qt.vector3d(0, 0, 0)\n        source: \"#Cube\"\n        eulerRotation.y: -30\n        materials: PrincipledMaterial {\n            baseColorMap: Texture {\n                source: \"qrc:/brick.jpg\"\n            }\n        }\n    }\n    ```", "```cpp\n    PerspectiveCamera {\n        position: Qt.vector3d(0, 200, 300)\n        eulerRotation.x: -30\n    }\n    DirectionalLight {\n        eulerRotation.x: -10\n        eulerRotation.y: -20\n    }\n    ```", "```cpp\n    Model {\n        position: Qt.vector3d(0, 0, 0)\n        source: \"#Cube\"\n        eulerRotation.y: -30\n        materials: PrincipledMaterial {\n            baseColorMap: Texture {\n                source: \"qrc:/brick.jpg\"\n            }\n        }\n        NumberAnimation on eulerRotation.y {\n            duration: 3000\n            to: 360\n            from: 0\n            easing.type:Easing.Linear\n            loops: Animation.Infinite\n        }\n    }\n    ```"]