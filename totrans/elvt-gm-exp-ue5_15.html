<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer500">
<h1 class="chapter-number" id="_idParaDest-294"><a id="_idTextAnchor322"/>15</h1>
<h1 id="_idParaDest-295"><a id="_idTextAnchor323"/>Exploring Collectibles, Power-Ups, and Pickups</h1>
<p>In the previous chapter, you created the player projectile and used <strong class="source-inline">Anim Notifies</strong> to spawn the player projectile during the <strong class="source-inline">Throw</strong> animation. The player projectile will serve as the player’s main offensive gameplay mechanic to use against the enemies throughout the level. Due to the combination of default <strong class="source-inline">Anim Notifies</strong> provided by UE5 and your own custom <strong class="source-inline">Anim_ProjectileNotify</strong> class, the player projectile mechanic looks and feels great. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to create and integrate UI elements using the <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>) UI Designer system within UE5.</li>
<li>Use the lessons learned from this project to create an interesting power-up that will increase the players’ movement speed and jump height.</li>
<li>How to use inheritance in C++ to derive multiple classes from one parent base class for both collectibles and power-ups. You will also be adding visual and audio elements to both the collectible and the power-up so that they are more polished.</li>
<li>How to use <strong class="source-inline">URotatingMovementComponent</strong> to add rotation to actors in a very optimized and straightforward way.</li>
</ul>
<p>By the end of this chapter, you will have the finished <strong class="bold">SuperSideScroller</strong> game project, complete with coin collectibles and a corresponding UI to track the number of coins collected, a new potion power-up that increases the player’s movement speed and jump height, as well as a base class in which to derive potentially new power-ups and collectibles for the game.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor324"/>Technical requirements</h1>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
<li>Unreal Engine 4.27 installed</li>
</ul>
<p>Let’s begin this chapter by learning more about <strong class="source-inline">URotatingMovementComponent</strong>, which we will use for our collectibles.</p>
<p>The project for this chapter can be found in the Chapter15 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor325"/>Understanding URotatingMovementComponent</h1>
<p><strong class="source-inline">URotatingMovementComponent</strong> is one of a few movement components that exists within UE5. You are <a id="_idIndexMarker1263"/>already familiar with <strong class="source-inline">CharacterMovementComponent</strong> and <strong class="source-inline">ProjectileMovementComponent</strong> from the <strong class="bold">SuperSideScroller</strong> game project alone, and <strong class="source-inline">RotatingMovementComponent</strong> is just that – another movement component. As a refresher, movement components allow different types of movements to occur on actors, or characters, that they belong to.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="source-inline">CharacterMovementComponent</strong>, which allows you to control the movement parameters of your character, such as their movement speed and jump height, was covered in <a href="B18531_10.xhtml#_idTextAnchor199"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating the SuperSideScroller Game</em>, when you created the <strong class="bold">SuperSideScroller</strong> player character. <strong class="source-inline">ProjectileMovementComponent</strong>, which allows you to add projectile-based movement functionality to actors, such as speed and gravity, was covered in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, when you developed the player projectile.</p>
<p><strong class="source-inline">RotatingMovementComponent</strong> is a very simple movement component compared to <strong class="source-inline">CharacterMovementComponent</strong> and that’s because it only involves rotating the actor that <strong class="source-inline">RotatingMovementComponent</strong> is a part of; nothing more. <strong class="source-inline">RotatingMovementComponent</strong> continuously rotates a component based on the defined <strong class="source-inline">Rotation Rate</strong>, pivot translation, and the option to use rotation in local space or world space. Additionally, <strong class="source-inline">RotatingMovementComponent</strong> is much more efficient compared to other methods <a id="_idIndexMarker1264"/>of rotating an actor, such as through <strong class="source-inline">Event Tick</strong> or <strong class="source-inline">Timelines</strong> within Blueprints.</p>
<p class="callout-heading">Note</p>
<p class="callout">More information about <a id="_idIndexMarker1265"/>movement components can be found here: <a href="https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent">https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent</a>.</p>
<p>We will be <a id="_idIndexMarker1266"/>using <strong class="source-inline">RotatingMovementComponent</strong> to allow the coin collectible and potion power-up to rotate in place along the <em class="italic">Z</em>-axis. This rotation will draw the player’s attention to the collectible and give them a visual cue that the collectible is important.</p>
<p>Now that you have a better understanding of <strong class="source-inline">RotatingMovementComponent</strong>, let’s move on and create the <strong class="source-inline">PickableActor_Base</strong> class, which is what the coin collectible and the potion power-up will derive from.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor326"/>Exercise 15.01 – creating the PickableActor_Base class and adding URotatingMovementComponent</h2>
<p>In this exercise, you will<a id="_idIndexMarker1267"/> be creating the <strong class="source-inline">PickableActor_Base</strong> actor class, which will be used as the base <a id="_idIndexMarker1268"/>class that both the collectible coin and potion power-up will derive from. You will also create a<a id="_idIndexMarker1269"/> Blueprint class from this C++ base class to preview how <strong class="source-inline">URotatingMovementComponent</strong> works. Follow these steps to complete this exercise:</p>
<p class="callout-heading">Note</p>
<p class="callout">You have performed many of the following steps numerous times throughout the <strong class="bold">SuperSideScroller</strong> game project, so there will be limited screenshots to help guide you. Only when introducing a new concept will there be an accompanying screenshot.</p>
<ol>
<li>Inside the UE5 editor, click the <strong class="bold">Tools</strong> option at the top of the editor and then choose <strong class="bold">New C++ Class</strong>. </li>
<li>From the <strong class="bold">Choose Parent Class</strong> window, select the <strong class="bold">Actor</strong> option, and then click the <strong class="bold">Next</strong> button at the bottom of this window.</li>
<li>Name this class <strong class="source-inline">PickableActor_Base</strong> and leave the default <strong class="source-inline">Path</strong> directory as-is. Then, select the <strong class="bold">Create Class</strong> button at the bottom of this window.</li>
<li>After selecting <a id="_idIndexMarker1270"/>the <strong class="bold">Create Class</strong> button, UE5 will recompile the project code and <a id="_idIndexMarker1271"/>automatically open Visual Studio with both the header and source files for the <strong class="source-inline">PickableActor_Base</strong> class.</li>
<li>By default, <strong class="source-inline">Actor</strong> classes provide you with the <strong class="source-inline">virtual void Tick(float DeltaTime) override;</strong> function declaration inside the header file. For the <strong class="source-inline">PickableActor_Base</strong> class, we will not require the <strong class="source-inline">Tick</strong> function, so remove this function declaration from the <strong class="source-inline">PickableActor_Base.h</strong> header file.</li>
<li>Next, you will need to remove the function from the <strong class="source-inline">PickableActor_Base.cpp</strong> file; otherwise, you will receive a compile error. In this source file, find and remove the following code:<p class="source-code">void PickableActor_Base::Tick(float DeltaTime)</p><p class="source-code">{</p><p class="source-code">  Super::Tick(DeltaTime);</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">In many cases, the use of the <strong class="source-inline">Tick()</strong> function for movement updates can lead to performance issues as the <strong class="source-inline">Tick()</strong> function is called every single frame. Instead, try using <strong class="source-inline">Gameplay Timer</strong> functions to perform certain updates at specified intervals, rather than on each frame. You can learn more about <strong class="source-inline">Gameplay Timers</strong> here: <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/</a>.</p>
<ol>
<li value="7">Now, it is time to add the components that the <strong class="source-inline">PickableActor_Base</strong> class requires. Let’s start with <strong class="source-inline">USphereComponent</strong>, which you will use to detect overlap collision <a id="_idIndexMarker1272"/>with the player. Add the following code underneath the <strong class="source-inline">Protected</strong> access<a id="_idIndexMarker1273"/> modifier inside the <strong class="source-inline">PickableActor_Base.h</strong> header file:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)</p><p class="source-code">class USphereComponent* CollisionComp;</p></li>
</ol>
<p>The declaration of <strong class="source-inline">USphereComponent</strong> should be very familiar to you by now; we’ve done this in previous chapters, such as <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, when we created the <strong class="source-inline">PlayerProjectile</strong> class.</p>
<ol>
<li value="8">Next, add the following code underneath the declaration of <strong class="source-inline">USphereComponent</strong> to create a new <strong class="source-inline">UStaticMeshComponent</strong>. This will be used to visually represent either the coin collectible or the potion power-up:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)</p><p class="source-code">class UStaticMeshComponent* MeshComp;</p></li>
<li>Finally, add the following code underneath the declaration of <strong class="source-inline">UStaticMeshComponent</strong> to create a new <strong class="source-inline">URotatingMovementComponent</strong>. This will be used to give the collectible coin and potion power-up simple rotational movement:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)</p><p class="source-code">class URotatingMovementComponent* RotationComp;</p></li>
<li>Now that you have the components declared inside the <strong class="source-inline">PickableActor_Base.h</strong> header file, navigate to the <strong class="source-inline">PickableActor_Base.cpp</strong> source file so that you can add the required <strong class="source-inline">#include</strong> statements for these added components. Add the following lines after <strong class="source-inline">#include “PickableActor_Base.h”</strong>, at the top of the source file:<p class="source-code">#include "Components/SphereComponent.h"</p><p class="source-code">#include "Components/StaticMeshComponent.h"</p><p class="source-code">#include "GameFramework/RotatingMovementComponent.h"</p></li>
<li>Now that you have<a id="_idIndexMarker1274"/> the necessary <strong class="source-inline">#include</strong> files for the components, you can add the <a id="_idIndexMarker1275"/>necessary code to initialize these components within the <strong class="source-inline">APickableActor_Base::APickableActor_Base()</strong> constructor function:<p class="source-code">APickableActor_Base::APickableActor_Base()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>First, initialize the <strong class="source-inline">USphereComponent</strong> component variable, <strong class="source-inline">CollisionComp</strong>, by adding the following code to <strong class="source-inline">APickableActor_Base::APickableActor_Base()</strong>:<p class="source-code">CollisionComp = CreateDefaultSubobject</p><p class="source-code">  &lt;USphereComponent&gt;(TEXT("SphereComp"));</p></li>
<li>Next, initialize <strong class="source-inline">USphereComponent</strong> with a default sphere radius of <strong class="source-inline">30.0f</strong> by adding the following code underneath the code provided in the previous step:<p class="source-code">CollisionComp-&gt;InitSphereRadius(30.0f);</p></li>
<li>Since the player character needs to overlap with this component, you will need to add the following code so that, by default, <strong class="source-inline">USphereComponent</strong> has the collision settings for <strong class="source-inline">Overlap All Dynamic</strong>:<p class="source-code">CollisionComp-&gt;BodyInstance.SetCollisionProfileName("OverlapAllDynamic");</p></li>
<li>Lastly, <strong class="source-inline">CollisionComp USphereComponent</strong> should be the root component of this actor. Add the following code to assign this:<p class="source-code">RootComponent = CollisionComp;</p></li>
<li>Now that <strong class="source-inline">CollisionComp USphereComponent</strong> has been initialized, let’s do the same<a id="_idIndexMarker1276"/> for <strong class="source-inline">MeshComp UStaticMeshComponent</strong>. Add the following code. After, we’ll discuss what the code is doing for us:<p class="source-code">MeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("MeshComp"));</p><p class="source-code">MeshComp-&gt;AttachToComponent(RootComponent, </p><p class="source-code">  FAttachmentTransformRules::KeepWorldTransform);</p><p class="source-code">MeshComp-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);</p></li>
</ol>
<p>The first line initializes <strong class="source-inline">MeshComp UStaticMeshComponent</strong> using the <strong class="source-inline">CreateDefaultSubobject()</strong> template function. Next, you are attaching <strong class="source-inline">MeshComp</strong> to the root<a id="_idIndexMarker1277"/> component, which you made for <strong class="source-inline">CollisionComp</strong>, using the <strong class="source-inline">AttachTo()</strong> function. Lastly, <strong class="source-inline">MeshComp UStaticMeshComponent</strong> should not have any collision by default, so you are using the <strong class="source-inline">SetCollisionEnabled()</strong> function and passing in the <strong class="source-inline">ECollisionEnable::NoCollision</strong> enumerator value.</p>
<ol>
<li value="17">Lastly, we can initialize <strong class="source-inline">URotatingMovementComponent RotationComp</strong> by adding the following code:<p class="source-code">RotationComp = </p><p class="source-code">  CreateDefaultSubobject&lt;URotatingMovementComponent&gt;(</p><p class="source-code">  TEXT("RotationComp"));</p></li>
<li>With all the components initialized, compile the C++ code and return to the UE5 editor. After compilation succeeds, you can start creating a Blueprint class for <strong class="source-inline">PickableActor_Base</strong>.</li>
<li>In the <strong class="bold">Content Drawer</strong> area, create <a id="_idIndexMarker1278"/>a new folder called <strong class="source-inline">PickableItems</strong> by <em class="italic">right-clicking</em> on the <strong class="source-inline">Content</strong> folder and selecting the <strong class="bold">New Folder</strong> option.</li>
<li>In the <strong class="source-inline">PickableItems</strong> folder, <em class="italic">right-click</em> and select <strong class="bold">Blueprint Class</strong>. From the <strong class="bold">Pick Parent Class</strong> window, search<a id="_idIndexMarker1279"/> for the <strong class="source-inline">PickableActor_Base</strong> class and <em class="italic">left-click</em> <strong class="bold">Select</strong> to create a new Blueprint. </li>
<li>Name this Blueprint <strong class="source-inline">BP_PickableActor_Base</strong> and <em class="italic">double-left-click</em> the Blueprint to open it.</li>
<li>In the <strong class="bold">Components</strong> tab, select <strong class="bold">MeshComp UStaticMeshComponent</strong> and assign the <strong class="source-inline">Shape_Cone</strong> static mesh to the <strong class="source-inline">Static Mesh</strong> parameter in the <strong class="bold">Details</strong> panel. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer469">
<img alt="Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent " height="485" src="image/Figure_15.01_B18531.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent</p>
<ol>
<li value="23">Next, select <strong class="bold">RotationComp URotatingMovementComponent</strong> and find the <strong class="bold">Rotation Rate</strong> parameter in the <strong class="bold">Rotating Component</strong> category of the <strong class="bold">Details</strong> panel.</li>
<li>Set<strong class="bold"> Rotation Rate</strong> to the following values:<p class="source-code">(X=100.000000,Y=100.000000,Z=100.000000)</p></li>
</ol>
<p>These values determine<a id="_idIndexMarker1280"/> how fast the actor will rotate along each axis per second. This means<a id="_idIndexMarker1281"/> that the cone-shaped actor will rotate along each axis at 100 degrees per second on each axis.</p>
<ol>
<li value="25">Compile the <strong class="source-inline">PickableActor_Base</strong> Blueprint and add this actor to your level.</li>
<li>Now, if you use <strong class="source-inline">PIE</strong> and look at the <strong class="source-inline">PickableActor_Base</strong> actor in the level, you will see that it is rotating. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer470">
<img alt="Figure 15.2 – The BP_PickableActor_Base rotating in place " height="382" src="image/Figure_15.02_B18531.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – The BP_PickableActor_Base rotating in place</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01</a>.</p>
<p>With this exercise <a id="_idIndexMarker1282"/>complete, you’ve created <a id="_idIndexMarker1283"/>the base components required for the <strong class="source-inline">PickableActor_Base</strong> class and learned how to implement and use <strong class="source-inline">URotatingMovementComponent</strong>. With the <strong class="source-inline">PickableActor_Base</strong> class ready, and with <strong class="source-inline">URotatingMovementComponent</strong> implemented on the Blueprint actor, we can complete the class by adding overlap detection functionality, destroying the collectible actor, and spawning audio effects when the actor is picked up by the player. In the following activity, you will add the remaining functionality required for the <strong class="source-inline">PickableActor_Base</strong> class.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor327"/>Activity 15.01 – player overlap detection and spawning effects in PickableActor_Base</h2>
<p>Now that the <strong class="source-inline">PickableActor_Base</strong> class has all the<a id="_idIndexMarker1284"/> required components and has its constructor initializing the components, it is time to add<a id="_idIndexMarker1285"/> the remaining aspects of its functionality. These will be inherited by the coin collectible and potion power-up later in this chapter. This additional functionality includes player overlap detection, destroying the collectible actor, and spawning an audio effect to give feedback to the player that it has been successfully picked up. Perform the following steps to add functionality that allows a <strong class="source-inline">USoundBase</strong> class object to be played<a id="_idIndexMarker1286"/> when the collectible overlaps with the player:</p>
<ol>
<li value="1">Create a new function in the <strong class="source-inline">PickableActor_Base</strong> class that takes in a reference to the player as an input parameter. Call this function <strong class="source-inline">PlayerPickedUp</strong>.</li>
<li>Create a new <strong class="source-inline">UFUNCTION</strong> called <strong class="source-inline">BeginOverlap()</strong>. Make sure to include all the required input<a id="_idIndexMarker1287"/> parameters for this function before moving on. Refer to <a href="B18531_06.xhtml#_idTextAnchor134"><em class="italic">Chapter 6</em></a>, <em class="italic">Setting Up Collision Objects</em>, where you used this function inside the <strong class="source-inline">VictoryBox</strong> class.</li>
<li>Add a new <strong class="source-inline">UPROPERTY()</strong> for the <strong class="source-inline">USoundBase</strong> class and name it <strong class="source-inline">PickupSound</strong>. </li>
<li>In the <strong class="source-inline">PickableActor_Base.cpp</strong> source file, create the definitions for both the <strong class="source-inline">BeginOverlap()</strong> and <strong class="source-inline">PlayerPickedUp()</strong> functions.</li>
<li>Now, add the required <strong class="source-inline">#include</strong> files for the <strong class="source-inline">SuperSideScroller_Player</strong> class and the <strong class="source-inline">GameplayStatics</strong> class at the top of the source file.</li>
<li>In the <strong class="source-inline">BeginOverlap()</strong> function, create a reference to the player using the <strong class="source-inline">OtherActor</strong> input parameter of the function.</li>
<li>Next, if the player reference is valid, make a call to the <strong class="source-inline">PlayerPickedUp()</strong> function, passing in the player variable.</li>
<li>In the <strong class="source-inline">PlayerPickedUp()</strong> function, create a variable for the <strong class="source-inline">UWorld*</strong> object that’s returned by the <strong class="source-inline">GetWorld()</strong> function.</li>
<li>Use the <strong class="source-inline">UGameplayStatics</strong> library to spawn <strong class="source-inline">PickUpSound</strong> at the location of the <strong class="source-inline">PickableActor_Base</strong> actor.</li>
<li>Then, call the <strong class="source-inline">Destroy()</strong> function so that the actor gets destroyed and removed from the world.</li>
<li>Finally, in the <strong class="source-inline">APickableActor_Base::APickableActor_Base()</strong> constructor, bind the <strong class="source-inline">OnComponentBeginOverlap</strong> event of <strong class="source-inline">CollisionComp</strong> to the <strong class="source-inline">BeginOverlap()</strong> function. </li>
<li>Download and install the <strong class="source-inline">Unreal Match 3</strong> project from the <strong class="bold">Samples</strong> tab of <strong class="bold">Epic Games Launcher</strong> under the <strong class="bold">UE Legacy Samples</strong> section. Migrate the <strong class="source-inline">Match_Combo</strong> soundwave asset from this project into your <strong class="bold">SuperSideScroller</strong> project using the knowledge you gained in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>.</li>
<li>Apply this sound<a id="_idIndexMarker1288"/> to the <strong class="source-inline">PickupSound</strong> parameter of the <strong class="source-inline">BP_PickableActor_Base</strong> Blueprint.</li>
<li>Compile the Blueprint, and if one<a id="_idIndexMarker1289"/> does not exist in your level, add the <strong class="source-inline">BP_PickableActor_Base</strong> actor to your level now.</li>
<li>In <strong class="source-inline">PIE</strong>, have your character overlap with the <strong class="source-inline">BP_PickableActor_Base</strong> actor. </li>
</ol>
<p>Expected output:</p>
<div>
<div class="IMG---Figure" id="_idContainer471">
<img alt="Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player " height="305" src="image/Figure_15.03_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you have proven your knowledge regarding how to add the <strong class="source-inline">OnBeginOverlap()</strong> functionality to your actor classes and how to use this function to perform logic for your actor. In the case of <strong class="source-inline">PickableActor_Base</strong>, we added logic that will spawn a custom sound and destroy the actor. </p>
<p>Now that the <strong class="source-inline">PickableActor_Base</strong> class is set and ready, it is time to develop the collectible coin and power-up potion classes that will derive from it. The coin collectible class will inherit from the <strong class="source-inline">PickableActor_Base</strong> class you have just created. It will override key<a id="_idIndexMarker1290"/> functionality, such as the <strong class="source-inline">PlayerPickedUp()</strong> function, so that we can implement unique logic for the collectible when<a id="_idIndexMarker1291"/> it’s picked up by the player. In addition to overriding functionality from the inherited parent <strong class="source-inline">PickableActor_Base</strong> class, the coin collectible class will have its own unique set of properties, such as its current coin value and unique pickup sound. We’ll create the coin collectible class together in the next exercise. </p>
<p>Exercise 15.02 – creating the PickableActor_Collectable class</p>
<p>In this exercise, you will be creating the <strong class="source-inline">PickableActor_Collectable</strong> class, which will be derived from the <strong class="source-inline">PickableActor_Base</strong> class you created in <em class="italic">Exercise 15.01 – creating the PickableActor_Base class and adding URotatingMovement</em>, and finished in <em class="italic">Activity 15.01 – player overlap detection and spawning effects in PickableActor_Base</em>. This class<a id="_idIndexMarker1292"/> will be used as the main collectible coin that the player can collect within the level. Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Inside the UE5 editor, click the <strong class="bold">Tools</strong> option at the top of the editor and choose <strong class="bold">New C++ Class</strong>.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> window, select the <strong class="bold">PickableActor_Base</strong> option, and then click the <strong class="bold">Next</strong> button at the bottom of this window.</li>
<li>Name this class <strong class="source-inline">PickableActor_Collectable</strong> and leave the default <strong class="source-inline">Path</strong> directory as-is. Then, select the <strong class="bold">Create Class</strong> button at the bottom of this window.</li>
<li>After selecting the <strong class="bold">Create Class</strong> button, UE5 will recompile the project code and will automatically open Visual Studio with both the header and source files for the <strong class="source-inline">PickableActor_Collectable</strong> class.</li>
<li>By default, the <strong class="source-inline">PickableActor_Collectable.h</strong> header file has no declared functions or <a id="_idIndexMarker1293"/>variables within its class declaration. You will need to add the override for the <strong class="source-inline">BeginPlay()</strong> function underneath a new <strong class="source-inline">Protected Access Modifier</strong>. Add the following code:<p class="source-code">protected:</p><p class="source-code">  virtual void BeginPlay() override;</p></li>
</ol>
<p>The reason we are overriding the <strong class="source-inline">BeginPlay()</strong> function is that <strong class="source-inline">URotatingMovementComponent</strong> requires the actor to initialize and use <strong class="source-inline">BeginPlay()</strong> to correctly rotate the actor. Therefore, we need to create the override declaration of this function and create a basic definition inside the source file. First, however, we need to override another important function from the <strong class="source-inline">PickableActor_Base</strong> parent class.</p>
<ol>
<li value="6">Override the <strong class="source-inline">PlayerPickedUp()</strong> function from the <strong class="source-inline">PickableActor_Base</strong> parent class by adding the following code under <strong class="source-inline">Protected Access Modifier</strong>:<p class="source-code">virtual void PlayerPickedUp(class ASuperSideScroller_Player* Player)override; </p><p class="source-code">  </p></li>
</ol>
<p>With this, we are saying that we are going to use, and override, the functionality of the <strong class="source-inline">PlayerPickedUp()</strong> function.</p>
<ol>
<li value="7">Lastly, create a new integer called <strong class="source-inline">UPROPERTY()</strong> that will hold the value that the coin collectible will have; in this case, it will have a value of <strong class="source-inline">1</strong>. Add the following code to do this:<p class="source-code">public:</p><p class="source-code">  UPROPERTY(EditAnywhere, Category = Collectable)</p><p class="source-code">  int32 CollectableValue = 1;</p></li>
</ol>
<p>Here, we are creating the integer variable that will be accessible in Blueprints and has a default value of <strong class="source-inline">1</strong>. If you so choose, with the <strong class="source-inline">EditAnywhere UPROPERTY()</strong> keyword, you can change how much a coin collectible is worth.</p>
<ol>
<li value="8">Now, we can move<a id="_idIndexMarker1294"/> on to the <strong class="source-inline">PickableActor_Collectable.cpp</strong> source file and create the definition of the overridden <strong class="source-inline">PlayerPickedUp()</strong> function. Add the following code to the source file:<p class="source-code">void APickableActor_Collectable::PlayerPickedUp(class </p><p class="source-code">  ASuperSideScroller_Player* Player)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>For now, we need to make a call to the <strong class="source-inline">PlayerPickedUp()</strong> parent function by using the <strong class="source-inline">Super</strong> keyword. Add the following code to the <strong class="source-inline">PlayerPicked()</strong> function:<p class="source-code">Super::PlayerPickedUp(Player);</p></li>
</ol>
<p>The call to the parent function, which uses <strong class="source-inline">Super::PlayerPickedUp(Player)</strong>, will ensure that the functionality you created in the <strong class="source-inline">PickableActor_Base</strong> class is called. As you may recall, the <strong class="source-inline">PlayerPickedUp()</strong> function in the parent class makes a call to spawn the <strong class="source-inline">PickupSound</strong> sound object and destroys the actor.</p>
<ol>
<li value="10">Next, create the definition of the <strong class="source-inline">BeginPlay()</strong> function inside the source file by adding the following code:<p class="source-code">void APickableActor_Collectable::BeginPlay()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Finally, in C++, once again make the call to the <strong class="source-inline">BeginPlay()</strong> parent function using the <strong class="source-inline">Super</strong> keyword. Add<a id="_idIndexMarker1295"/> the following code to the <strong class="source-inline">BeginPlay()</strong> function inside the <strong class="source-inline">PickableActor_Collectable</strong> class:<p class="source-code">Super::BeginPlay();</p></li>
<li>Compile the C++ code and return to the editor.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise at the following link: <a href="https://packt.live/35fRN3E">https://packt.live/35fRN3E</a>.</p>
<p>Now that you’ve successfully compiled the <strong class="source-inline">PickableActor_Collectable</strong> class, you have created the framework needed for the coin collectible. In the following activity, you will create a Blueprint from this class and finalize the coin collectible actor.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor328"/>Activity 15.02 – finalizing the PickableActor_Collectable actor</h2>
<p>Now that the <strong class="source-inline">PickableActor_Collectable</strong> class has all of the necessary inherited functionality<a id="_idIndexMarker1296"/> and unique properties it needs, it is time to create the Blueprint from this class and add a <strong class="source-inline">Static Mesh</strong>, update its <strong class="source-inline">URotatingMovementComponent</strong>, and apply a sound to the <strong class="source-inline">PickUpSound</strong> property. Perform the following steps to finalize the <strong class="source-inline">PickableActor_Collectable</strong> actor:</p>
<ol>
<li value="1">From <strong class="bold">Epic Games Launcher</strong>, find the <strong class="bold">Content Examples</strong> project in the <strong class="bold">Samples</strong> tab, underneath the <strong class="bold">Engine Feature Samples</strong> category.</li>
<li>Create and install a new project from the <strong class="bold">Content Examples</strong> project.</li>
<li>Migrate the <strong class="source-inline">SM_Pickup_Coin</strong> asset and all its referenced assets from the <strong class="bold">Content Examples</strong> project to your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Create a new folder within the <strong class="source-inline">Content/PickableItems</strong> directory in the <strong class="bold">Content Drawer</strong> window and name it <strong class="source-inline">Collectable</strong>.</li>
<li>In this new <strong class="source-inline">Collectable</strong> folder, create a new Blueprint from the <strong class="source-inline">PickableActor_Collectable</strong> class that you created in <em class="italic">Exercise 15.02 – creating the PickableActor_Collectable class</em>. Name this new Blueprint <strong class="source-inline">BP_Collectable</strong>.</li>
<li>In this Blueprint, set the <strong class="source-inline">Static Mesh</strong> parameter of the <strong class="source-inline">MeshComp</strong> component <a id="_idIndexMarker1297"/>to the <strong class="source-inline">SM_Pickup_Coin</strong> mesh you imported earlier in this activity.</li>
<li>Next, add the <strong class="source-inline">Match_Combo</strong> sound asset to the <strong class="source-inline">PickupSound</strong> parameter of the collectible.</li>
<li>Lastly, update the <strong class="source-inline">RotationComp</strong> component so that the actor rotates along the <em class="italic">Z</em>-axis at 90 degrees per second.</li>
<li>Compile the Blueprint, place <strong class="source-inline">BP_Collectable</strong> in your level, and use <strong class="source-inline">PIE</strong>. </li>
<li>Overlap the player character with the <strong class="source-inline">BP_Collectable</strong> actor and observe the results.</li>
</ol>
<p>Expected output:</p>
<div>
<div class="IMG---Figure" id="_idContainer472">
<img alt="Figure 15.4 – The coin collectible rotates and can be overlapped by the player " height="347" src="image/Figure_15.04_B18531.jpg" width="504"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The coin collectible rotates and can be overlapped by the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity<a id="_idIndexMarker1298"/> complete, you have proven that you know how to migrate assets into your UE5 project and how to use and update <strong class="source-inline">URotatingMovementComponent</strong> to fit the needs of the coin collectible. Now that the coin collectible actor is complete, it is time to add functionality to the player so that the player can keep track of how many coins they have collected. </p>
<p>First, we will create the logic that will count the coins using <strong class="source-inline">UE_LOG</strong>. Later, we will implement the coin counter<a id="_idIndexMarker1299"/> using the <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>) UI Designer system on the game’s UI.</p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor329"/>Logging variables using UE_LOG</h1>
<p>In <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>, we used and learned about the <strong class="source-inline">UE_LOG</strong> function to log when the player should throw the projectile. Then, we <a id="_idIndexMarker1300"/>used the <strong class="source-inline">UE_LOG</strong> function in <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, to log when the player projectile hit an object. <strong class="source-inline">UE_LOG</strong> is a<a id="_idIndexMarker1301"/> robust logging tool we can use to output important information from our C++ functions into the <strong class="bold">Output Log</strong> window inside the editor when playing our game. So far, we have only logged <strong class="source-inline">FStrings</strong> to display general text in the <strong class="bold">Output Log</strong> window to know that our functions were being called. Now, it is time to learn how to log variables to debug how many coins the player has collected.</p>
<p class="callout-heading">Note</p>
<p class="callout">There is another useful debug function available in C++ with UE5 known as <strong class="source-inline">AddOnScreenDebugMessage</strong>. You can learn more about this function here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml</a>.</p>
<p>When creating the <strong class="source-inline">FString</strong> syntax <a id="_idIndexMarker1302"/>used by the <strong class="source-inline">TEXT()</strong> macro, we can add format specifiers to log <a id="_idIndexMarker1303"/>different types of variables. We will only be discussing how to add the format specifier for integer variables.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on how to specify other variable types by reading the following documentation: <a href="https://www.ue4community.wiki/Logging#Logging_an_FString">https://www.ue4community.wiki/Logging#Logging_an_FString</a>.</p>
<p>This is what <strong class="source-inline">UE_LOG()</strong> looks like when passing in <strong class="source-inline">FString “Example Text”</strong>: </p>
<p class="source-code">UE_LOG(LogTemp, Warning, TEXT("Example Text"));</p>
<p>Here, you have <strong class="source-inline">Log Category</strong>, <strong class="source-inline">Log Verbose Level</strong>, and the actual <strong class="source-inline">FString</strong>,<strong class="source-inline"> “Example Text”</strong>, to display in the log. To log an integer variable, you need to add <strong class="source-inline">%d</strong> to your <strong class="source-inline">FString</strong> within the <strong class="source-inline">TEXT()</strong> macro, followed by the integer variable name outside the <strong class="source-inline">TEXT()</strong> macro, separated by a comma. Here is an example:</p>
<p class="source-code">UE_LOG(LogTemp, Warning, TEXT("My integer variable %d), MyInteger);</p>
<p>The format specifier is identified by the <strong class="source-inline">%</strong> symbol, and each variable type has a designated letter that corresponds with it. In the case of integers, the letter <strong class="source-inline">d</strong> is used, representing a digit. You will be using this method of logging integer variables to log the number of coin collectibles the player has in the next exercise.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor330"/>Exercise 15.03 – tracking the number of coins for the player</h2>
<p>In this exercise, you <a id="_idIndexMarker1304"/>will be creating the necessary properties and functions that will allow you to track how many coins the player collects throughout the level. You will use this tracking to show the player using UMG later in this chapter. Follow these steps to complete this exercise:</p>
<ol>
<li value="1">In Visual Studio, find and open the <strong class="source-inline">SuperSideScroller_Player.h</strong> header file.</li>
<li>Under <strong class="source-inline">Private Access Modifier</strong>, create a new <strong class="source-inline">int</strong> variable called <strong class="source-inline">NumberofCollectables</strong>, as shown here:<p class="source-code">int32 NumberofCollectables;</p></li>
</ol>
<p>This will be a private property that will keep track of the current number of coins the player has collected. You will be creating a public function that will return this integer value. We do this for safety reasons to ensure that no other classes can modify this value.</p>
<ol>
<li value="3">Next, under the existing <strong class="source-inline">public</strong> access modifier, create a new <strong class="source-inline">UFUNCTION()</strong> using the <strong class="source-inline">BlueprintPure</strong> keyword called <strong class="source-inline">GetCurrentNumberOfCollectables()</strong>. This function will return an <strong class="source-inline">int</strong>. The following code adds this as an inline function:<p class="source-code">UFUNCTION(BlueprintPure)</p><p class="source-code">int32 GetCurrentNumberofCollectables() { return NumberofCollectables; };</p></li>
</ol>
<p>Here, we are using <strong class="source-inline">UFUNCTION()</strong> and the <strong class="source-inline">BlueprintPure</strong> keyword to expose this function to Blueprints so that we can use it later in UMG.</p>
<ol>
<li value="4">Declare a new <strong class="source-inline">void</strong> function, under the <strong class="source-inline">public</strong> access modifier, called <strong class="source-inline">IncrementNumberofCollectables()</strong> that takes in a single integer parameter called <strong class="source-inline">Value</strong>:<p class="source-code">void IncrementNumberofCollectables(int32  Value);</p></li>
</ol>
<p>This is the main function you will use to keep track of how many coins the player has collected. We will also add some safety measures to ensure this value is never negative.</p>
<ol>
<li value="5">With the <strong class="source-inline">IncrementNumberofCollectables()</strong> function declared, let’s create the definition of this function inside the <strong class="source-inline">SuperSideScroller_Player.cpp</strong> source file.</li>
<li>Write the following code to<a id="_idIndexMarker1305"/> create the definition of the <strong class="source-inline">IncrementNumberofCollectables</strong> function:<p class="source-code">void ASuperSideScroller_Player::IncrementNumberofCollectables(int32 Value)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>The main case to handle here is if the integer value that’s passed into this function is less than or equal to <strong class="source-inline">0</strong>. In this case, we do not want to bother incrementing the <strong class="source-inline">NumberofCollectables</strong> variable. Add the following code to the <strong class="source-inline">IncrementNumberofCollectables()</strong> function:<p class="source-code">if(Value == 0)</p><p class="source-code">{</p><p class="source-code">  return;</p><p class="source-code">}</p></li>
</ol>
<p>This <strong class="source-inline">if()</strong> statement says that if the <strong class="source-inline">value</strong> input parameter is less than or equal to <strong class="source-inline">0</strong>, the function will end. With the <strong class="source-inline">IncrementNumberofCollectables()</strong> function returning <strong class="source-inline">void</strong>, it is perfectly okay to use the <strong class="source-inline">return</strong> keyword in this way.</p>
<p>We’re adding this check of ensuring the <strong class="source-inline">value</strong> parameter that’s passed into the <strong class="source-inline">IncrementNumberofCollectables()</strong> function is neither 0 nor negative because it is important to establish good coding practices; this guarantees that all possible outcomes are handled. In an actual development environment, there could be designers or other programmers who attempt to use the <strong class="source-inline">IncrementNumberofCollectables()</strong> function and try to pass in a negative value, or a value that equals 0. If the function does not take these possibilities into account, there is potential for bugs later on in development.</p>
<ol>
<li value="8">Now that we’ve handled the <a id="_idIndexMarker1306"/>edge case where <strong class="source-inline">value</strong> is less than or equal to <strong class="source-inline">0</strong>, let’s continue with the function using an <strong class="source-inline">else()</strong> statement to increase <strong class="source-inline">NumberofCollectables</strong>. Add the following code under the <strong class="source-inline">if()</strong> statement from the previous step:<p class="source-code">else</p><p class="source-code">{</p><p class="source-code">  NumberofCollectables += Value;</p><p class="source-code">}</p></li>
<li>Next, let’s log <strong class="source-inline">NumberofCollectables</strong> using <strong class="source-inline">UE_LOG</strong> and the knowledge we learned about logging variables. Add the following code after the <strong class="source-inline">else()</strong> statement to properly log <strong class="source-inline">NumberofCollectables</strong>:<p class="source-code">UE_LOG(LogTemp, Warning, TEXT("Number of Coins: %d"), NumberofCollectables);</p></li>
</ol>
<p>With this <strong class="source-inline">UE_LOG()</strong>, we are making a more robust log to track the number of coins. This lays out the groundwork of how the UI will work. This is because we will be logging the same information to the player using UMG later in this chapter.</p>
<p>With <strong class="source-inline">UE_LOG()</strong> added, all we need to do is call the <strong class="source-inline">IncrementNumberofCollectables()</strong> function inside the <strong class="source-inline">PickableActor_Collectable</strong> class.</p>
<ol>
<li value="10">In the <strong class="source-inline">PickableActor_Collectable.cpp</strong> source file, add the following header:<p class="source-code">#include "SuperSideScroller_Player.h"</p></li>
<li>Next, inside the <strong class="source-inline">PlayerPickedUp()</strong> function, add the following function call before the <strong class="source-inline">Super::PlayerPickedUp(Player)</strong> line:<p class="source-code">Player-&gt;IncrementNumberofCollectables(CollectableValue);</p></li>
<li>Now that our <strong class="source-inline">PickableActor_Collectable</strong> class is calling our player’s <strong class="source-inline">IncrementNumberofCollectables</strong> function, recompile the C++ code and return to the UE5 editor.</li>
<li>Within the UE5 editor, open the <strong class="bold">Output Log</strong> window by clicking <strong class="bold">Window</strong>, and then select <strong class="bold">Output Log</strong>.</li>
<li>Now, add multiple <strong class="bold">BP_Collectable</strong> actors to your level and use <strong class="source-inline">PIE</strong>.</li>
<li>When you overlap<a id="_idIndexMarker1307"/> over each coin collectible, observe the <strong class="bold">Output Log</strong> window to find that each time you collect a coin, the <strong class="bold">Output Log</strong> window will show you how many coins you’ve collected. </li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03</a>.</p>
<p>With this exercise <a id="_idIndexMarker1308"/>completed, you have now completed half of the work needed to develop the UI element of tracking the number of coins collected by the player. The next half will involve using the functionality developed in this activity inside UMG to show this information to the player on-screen. To do this, we need to learn more about UMG inside UE5.</p>
<h1 id="_idParaDest-303"><a id="_idTextAnchor331"/>Introducing Unreal Motion Graphics UI</h1>
<p>UMG <a id="_idIndexMarker1309"/>UI Designer is UE5’s main tool for creating UI menus, in-game HUD elements such as health bars, and other user interfaces you may want to present to the player.</p>
<p>In the <strong class="bold">SuperSideScroller</strong> game, we will only be using the <strong class="bold">Text widget</strong> to construct our <strong class="bold">Coin Collection UI</strong> in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>. We’ll learn more about the <strong class="bold">Text widget</strong> in the next section.</p>
<h1 id="_idParaDest-304"><a id="_idTextAnchor332"/>Understanding the Text widget</h1>
<p>The <strong class="bold">Text widget</strong> is one of the simpler widgets that exists. This is because it only allows you to display text information to the user <a id="_idIndexMarker1310"/>and customize the visuals of this text. Almost every single game uses text in one way or another to display information to its players. <strong class="bold">Overwatch</strong>, for example, uses a text-based UI to display crucial match data to its players. Without the use of text, it would be very difficult – maybe even impossible – to convey key pieces of statistical data to the player, such as total damage dealt, total time playing the game, and much more. </p>
<p>The <strong class="bold">Text </strong><strong class="bold">widget</strong> appears in the <strong class="bold">Palette</strong> tab within UMG. When you add a <strong class="bold">Text widget</strong> to the <strong class="bold">Canvas</strong> panel, it will display the text <strong class="source-inline">Text Block</strong> by default. You can customize this text by adding your text to the <strong class="source-inline">Text</strong> parameter of the widget. Alternatively, you can use <strong class="source-inline">Function Binding</strong> to display more robust text that can reference internal or external variables. <strong class="source-inline">Function Binding</strong> should be used whenever you need to display information that can change; this could be text that represents a player’s score, how much money the player has, or in our case, the number of coins the player has collected:</p>
<p>You will be using the <strong class="source-inline">Function Binding</strong> functionality of the <strong class="bold">Text widget</strong> to display the number of coins collected by the player using the <strong class="source-inline">GetCurrentNumberofCollectables()</strong> function you created in <em class="italic">Exercise 15.03 – tracking the number of coins for the player</em>.</p>
<p>Now that we have the <strong class="bold">Text widget</strong> in the <strong class="bold">Canvas</strong> panel, it is time to position this widget where we need it to be. For this, we will take advantage of anchors.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor333"/>Anchors</h2>
<p>Anchors are used to <a id="_idIndexMarker1311"/>define where a widget’s desired location should<a id="_idIndexMarker1312"/> be on the <strong class="bold">Canvas</strong> panel. Once defined, this <strong class="source-inline">Anchor</strong> point will ensure that the widget will maintain this position with varying screen sizes through different platform devices such as phones, tablets, and computers. Without an anchor, a widget’s position can become inconsistent between different screen resolutions, which is never desired.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about<a id="_idIndexMarker1313"/> anchors, please refer to the following documentation: <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml</a>.</p>
<p>For our<strong class="bold"> Coin Collection UI</strong> and the <strong class="bold">Text widget</strong> you will use, the <strong class="source-inline">Anchor</strong> point will be at the top-left<a id="_idIndexMarker1314"/> corner of the screen. You will <a id="_idIndexMarker1315"/>also add a position offset from this <strong class="source-inline">Anchor</strong> point so that the text is more visible and readable to the player. Before moving on to creating our <strong class="bold">Coin Collection UI</strong>, let’s learn about <strong class="source-inline">Text</strong> <strong class="source-inline">Formatting</strong>, which you will use to display the current number of collected coins to the player.</p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor334"/>Text formatting</h2>
<p>Much like the <strong class="source-inline">UE_LOG()</strong> macro available<a id="_idIndexMarker1316"/> to us in C++, Blueprints offers a similar solution to display text and format it to allow custom variables to be added to it. The <strong class="source-inline">Format Text</strong> function takes in a single text input labeled <strong class="source-inline">Format</strong> and returns the <strong class="source-inline">Result</strong> text. This can be used to display information:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer473">
<img alt="Figure 15.5 – The Format Text function " height="77" src="image/Figure_15.05_B18531.jpg" width="226"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – The Format Text function</p>
<p>Instead of using the <strong class="source-inline">%</strong> symbol like <strong class="source-inline">UE_LOG()</strong> does, the <strong class="source-inline">Format Text</strong> function uses the <strong class="source-inline">{}</strong> symbols to denote arguments that can be passed into the string. In-between the <strong class="source-inline">{}</strong> symbols, you need to add an argument name; this can be anything you want, but it should be representative of what the argument is. Refer to the example shown in the following screenshot: </p>
<div>
<div class="IMG---Figure" id="_idContainer474">
<img alt="Figure 15.6 – An example integer in the Format Text function " height="128" src="image/Figure_15.06_B18531.jpg" width="526"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – An example integer in the Format Text function</p>
<p>The <strong class="source-inline">Format Text</strong> function only supports <strong class="source-inline">Byte</strong>, <strong class="source-inline">Integer</strong>, <strong class="source-inline">Float</strong>, <strong class="source-inline">Text</strong>, or <strong class="source-inline">EText Gender</strong> variable types, so if you <a id="_idIndexMarker1317"/>are attempting to pass any other type of variable into the function as an argument, you must convert it into one of the supported types.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">Format Text</strong> function is also used for <strong class="bold">Text Localization</strong>, where you can support multiple languages for your game. More information about how this can be done in both C++ and Blueprints can be found here: <a href="https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml">https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml</a>.</p>
<p>You will be using the <strong class="source-inline">Format Text</strong> function in conjunction with the <strong class="bold">Text widget</strong> in UMG in the next exercise, where we will be creating the <strong class="source-inline">Coin Counter UI</strong> widget to display the number of coins that have been collected by the player. You will also be using <strong class="source-inline">Anchor</strong> points to position the <strong class="bold">Text widget</strong> at the top-left corner of the screen.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor335"/>Exercise 15.04 – creating the Coin Counter UI HUD element</h2>
<p>In this exercise, you will be <a id="_idIndexMarker1318"/>creating the UMG UI asset, which will display and update the number of coins collected by the player. You will use the <strong class="source-inline">GetCurrentNumberofCollectables()</strong> inline function you created in <em class="italic">Exercise 15.02 – creating the PickableActor_Collectable class</em>, to display this value on the screen using a simple <strong class="bold">Text widget</strong>. Follow these steps to accomplish this:</p>
<ol>
<li value="1">Let’s start by creating a new folder inside the <strong class="bold">Content Drawer</strong> area called <strong class="source-inline">UI</strong>. Do this by <em class="italic">right-clicking</em> on the <strong class="source-inline">Content</strong> folder at the top of the browser directory in the editor and selecting <strong class="bold">New Folder</strong>.</li>
<li>Inside the new <strong class="source-inline">/Content/UI</strong> directory, <em class="italic">right-click</em> and, instead of selecting <strong class="bold">Blueprint Class</strong>, hover over the <strong class="bold">User Interface</strong> option at the bottom of this list and <em class="italic">left-click</em> the <strong class="bold">Widget Blueprint</strong> option.</li>
<li>Name this new <strong class="bold">Widget Blueprint</strong> <strong class="source-inline">BP_UI_CoinCollection</strong>, and then <em class="italic">double-left-click</em> the asset to open the UMG editor.</li>
<li>By default, the <strong class="bold">Widget</strong> panel is empty, and you will find an empty hierarchy on the left-hand side, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer475">
<img alt="Figure 15.7 – The Widget panel’s empty hierarchy " height="84" src="image/Figure_15.07_B18531.jpg" width="289"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – The Widget panel’s empty hierarchy</p>
<ol>
<li value="5">Above the <strong class="bold">Hierarchy</strong> tab is the <strong class="bold">Palette</strong> tab, which lists all the available widgets you can use inside your UI. We will only focus on the <strong class="bold">Text widget</strong>, which is listed under the <strong class="bold">Common</strong> category. Do not mistake this option with the <strong class="bold">Rich Text Block</strong> widget.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">For a more detailed reference regarding all the available widgets inside UMG, please read the following documentation from Epic Games: <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml</a>.</p>
<ol>
<li value="6">If one is not automatically created, add a <strong class="bold">Canvas Panel</strong> widget as the base of the <strong class="bold">Hierarchy</strong> area.</li>
<li>Add the <strong class="bold">Text </strong><strong class="bold">widget</strong><a id="_idIndexMarker1319"/> to the <strong class="bold">UI</strong> panel by either <em class="italic">left-clicking</em> and dragging the <strong class="bold">Text widget</strong> from the <strong class="bold">Palette</strong> tab to the <strong class="bold">Hierarchy</strong> tab underneath the <strong class="bold">Canvas</strong> panel root, or by <em class="italic">left-clicking</em> and dragging the <strong class="bold">Text widget</strong> directly into the <strong class="bold">Canvas</strong> panel itself in the middle of the UMG editor. </li>
</ol>
<p>Before changing the text of this widget, we need to update its anchor, position, and font size so that it fits the needs we have for displaying the necessary information to the player.</p>
<ol>
<li value="8">With the <strong class="bold">Text widget</strong> selected, you will see many options under its <strong class="bold">Details</strong> panel to customize it. The first thing to do here is anchor the <strong class="bold">Text widget</strong> to the top-left corner of the <strong class="bold">Canvas</strong> panel. <em class="italic">Left-click</em> on the <strong class="bold">Anchors</strong> dropdown and select the top-left anchoring option, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer476">
<img alt="Figure 15.8 – By default, there are options to anchor a widget at different locations on the screen " height="322" src="image/Figure_15.08_B18531.jpg" width="287"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – By default, there are options to anchor a widget at different locations on the screen</p>
<p>Anchoring allows the widget to <a id="_idIndexMarker1320"/>maintain its desired location within the <strong class="bold">Canvas</strong> panel, regardless of varying screen sizes.</p>
<p>Now that the <strong class="bold">Text widget</strong> is anchored to the top-left corner, we need to set its relative position to this anchor so that there is an offset for better positioning and readability of the text.</p>
<ol>
<li value="9">In the <strong class="bold">Details</strong> panel, underneath the <strong class="bold">Anchors</strong> option, are parameters for <strong class="source-inline">Position X</strong> and <strong class="source-inline">Position Y</strong>. Set both these parameters to <strong class="source-inline">100.0f</strong>.</li>
<li>Next, enable the <strong class="bold">Size To Content</strong> parameter so that the <strong class="bold">Text widget</strong> will automatically resize itself depending on the size of the text it is displaying, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer477">
<img alt="Figure 15.9 – The Size To Content parameter will ensure that the Text widget won’t be cut off " height="88" src="image/Figure_15.09_B18531.jpg" width="437"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – The Size To Content parameter will ensure that the Text widget won’t be cut off</p>
<ol>
<li value="11">Lastly, we must update the size of the font that’s used for the <strong class="bold">Text widget</strong>. Underneath the <strong class="bold">Appearance</strong> tab<a id="_idIndexMarker1321"/> of the <strong class="bold">Details</strong> panel for the <strong class="bold">Text widget</strong>, you will find the <strong class="bold">Size</strong> parameter. Set its value to <strong class="source-inline">48</strong>.</li>
<li>The final <strong class="bold">Text widget</strong> will look like this:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer478">
<img alt="Figure 15.10 – The Text widget is now anchored to the top left of the Canvas panel " height="549" src="image/Figure_15.10_B18531.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – The Text widget is now anchored to the top left of the Canvas panel</p>
<p>Now that we have the <strong class="bold">Text</strong><strong class="bold"> widget</strong> positioned and sized the way we need it to be, let’s add a new binding to the text so that it will automatically update and match the value of the number of collectibles the player has.</p>
<ol>
<li value="13">With the <strong class="bold">Text</strong> widget selected, find the <strong class="bold">Text</strong> parameter in its <strong class="bold">Details</strong> panel, under the <strong class="bold">Content</strong> category. There, you will find the <strong class="bold">Bind</strong> option.</li>
<li><em class="italic">Left-click</em> the <strong class="bold">Bind</strong> option and select <strong class="bold">Create Binding</strong>. When doing this, the new <strong class="source-inline">Function Binding</strong> will be created automatically and be given the name <strong class="source-inline">GetText_0</strong>. Please refer to the <a id="_idIndexMarker1322"/>following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer479">
<img alt="Figure 15.11 – The new bound function of the text " height="102" src="image/Figure_15.11_B18531.jpg" width="428"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 – The new bound function of the text</p>
<ol>
<li value="15">Rename this function <strong class="source-inline">Get Number of Collectables</strong>.</li>
<li>Before continuing with this function, create a new object reference variable called <strong class="source-inline">Player</strong> that’s of the <strong class="source-inline">SuperSideScroller_Player</strong> type. Make this variable <strong class="bold">Public</strong> and exposable on spawn by enabling both the <strong class="bold">Instance Editable</strong> and <strong class="bold">Expose on Spawn</strong> parameters of the variable, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer480">
<img alt="Figure 15.12 – The Player variable with the Instance Editable and Expose on Spawn parameters enabled " height="441" src="image/Figure_15.12_B18531.jpg" width="531"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – The Player variable with the Instance Editable and Expose on Spawn parameters enabled</p>
<p>By making the <strong class="source-inline">Player</strong> variable <strong class="bold">Public</strong> and exposed on spawn, you will be able to assign this variable when creating the widget and adding it to the screen. We will do this in <em class="italic">Exercise 15.05 – adding the coin counter UI to the player screen</em>.</p>
<p>Now that we have a<a id="_idIndexMarker1323"/> reference variable to <strong class="source-inline">SuperSideScroller_Player</strong>, let’s continue with the <strong class="source-inline">Get Number of Collectables</strong> bind function.</p>
<ol>
<li value="17">Add a <strong class="bold">Getter</strong> of the <strong class="source-inline">Player</strong> variable to the <strong class="source-inline">Get Number of Collectables</strong> function.</li>
<li>From this variable, <em class="italic">left-click</em> and drag and from the context-sensitive drop-down menu, and find and select the <strong class="source-inline">Get Current Number of Collectables</strong> function. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer481">
<img alt="Figure 15.13 – The Get Current Number of Collectables function you created in Exercise 15.03 " height="268" src="image/Figure_15.13_B18531.jpg" width="736"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – The Get Current Number of Collectables function you created in Exercise 15.03</p>
<ol>
<li value="19">Next, <em class="italic">left-click</em> and drag out the <strong class="source-inline">Return Value</strong> text parameter of <strong class="source-inline">Get Number of Collectables</strong> to <strong class="source-inline">Return Node</strong>. From the context-sensitive drop-down menu, search<a id="_idIndexMarker1324"/> for and select the <strong class="bold">Format Text</strong> option, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer482">
<img alt="Figure 15.14 – Now, we can create customized and formatted text " height="266" src="image/Figure_15.14_B18531.jpg" width="726"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – Now, we can create customized and formatted text</p>
<ol>
<li value="20">Within the <strong class="source-inline">Format Text</strong> function, add the following text:<p class="source-code">Coins: {coins}</p></li>
</ol>
<p>Please refer to the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer483">
<img alt="Figure 15.15 – Now, there is a new input argument for the formatted text " height="399" src="image/Figure_15.15_B18531.jpg" width="1126"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – Now, there is a new input argument for the formatted text</p>
<p>Remember that <a id="_idIndexMarker1325"/>using the <strong class="source-inline">{}</strong> symbols denotes a text argument that allows you to pass variables into the text.</p>
<ol>
<li value="21">Finally, connect the <strong class="source-inline">Return Value</strong> int of the <strong class="source-inline">GetCurrentNumberofCollectables()</strong> function to the wildcard <strong class="source-inline">coins</strong> input pin of the <strong class="source-inline">Format Text</strong> function, as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer484">
<img alt="Figure 15.16 – The Text widget will update automatically based on the Get Current Number of Collectables function " height="399" src="image/Figure_15.16_B18531.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – The Text widget will update automatically based on the Get Current Number of Collectables function</p>
<ol>
<li value="22">Compile and <a id="_idIndexMarker1326"/>save the <strong class="source-inline">BP_UI_CoinCollection</strong> widget Blueprint.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://packt.live/3eQJjTU">https://packt.live/3eQJjTU</a>.</p>
<p>With this exercise completed, you have created the <strong class="source-inline">UI UMG</strong> widget needed to display the current number of coins collected by the player. By using the <strong class="source-inline">GetCurrentNumberofCollectables()</strong> C++ function and the binding functionality of the <strong class="bold">Text widget</strong>, the UI will always update its value based on the number of coins collected. In the next exercise, we will add this UI to the player’s screen, but first, we’ll briefly learn about how to add and remove UMG from the player screen.</p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor336"/>Adding and creating UMG user widgets</h1>
<p>Now that we have<a id="_idIndexMarker1327"/> created <strong class="bold">Coin Collection UI</strong> in UMG, it is time to learn how to add and remove the UI to and from <a id="_idIndexMarker1328"/>the player screen, respectively. By adding <strong class="bold">Coin Collection UI</strong> to the player screen, the UI becomes visible to the player and can be updated as the player collects coins. </p>
<p>In Blueprints, there is a function called <strong class="source-inline">Create Widget</strong>, as shown in the following screenshot. Without a class assigned, it will be labeled <strong class="source-inline">Construct None</strong>, but do not let this confuse you:</p>
<div>
<div class="IMG---Figure" id="_idContainer485">
<img alt="Figure 15.17 – The Create Widget function as-is by default, without a class applied " height="209" src="image/Figure_15.17_B18531.jpg" width="430"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – The Create Widget function as-is by default, without a class applied</p>
<p>This function requires the <a id="_idIndexMarker1329"/>class of the <strong class="source-inline">User</strong> widget to be created and requires a <strong class="source-inline">Player Controller</strong> that will be referenced as the owning player of this UI. This function then returns the spawned user widget as its <strong class="source-inline">Return Value</strong>, where you can then add it to the player’s viewport using the <strong class="source-inline">Add to Viewport</strong> function. The <strong class="source-inline">Create Widget</strong> function only instantiates the widget object; it does not add this widget to the player’s screen. It is the <strong class="source-inline">Add to Viewport</strong> function that makes this widget visible on the player’s screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer486">
<img alt="Figure 15.18 – The Add to Viewport function with ZOrder " height="245" src="image/Figure_15.18_B18531.jpg" width="287"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 – The Add to Viewport function with ZOrder</p>
<p>The viewport is the game screen that overlays your view of the game world, and it uses what is called <strong class="source-inline">ZOrder</strong> to determine the overlay depth in cases where multiple UI elements need to overlap above or below one another. By default, the <strong class="source-inline">Add to Viewport</strong> function will add the <strong class="source-inline">User</strong> widget to the screen and make it fill the entire screen – that is, unless<a id="_idIndexMarker1330"/> the <strong class="source-inline">Set Desired Size In Viewport</strong> function is called to set the size that it should fill manually:</p>
<div>
<div class="IMG---Figure" id="_idContainer487">
<img alt="Figure 15.19 – The Size parameter determines the desired size of the passed in the User widget " height="239" src="image/Figure_15.19_B18531.jpg" width="801"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.19 – The Size parameter determines the desired size of the passed in the User widget</p>
<p>In C++, you also have a function called <strong class="source-inline">CreateWidget()</strong>:</p>
<pre class="source-code">
template&lt;typename WidgetT, typename OwnerT&gt;
WidgetT * CreateWidget
(
  OwnerT * OwningObject,
  TSubclassOf &lt; UUserWidget &gt; UserWidgetClass,
  FName WidgetName
)</pre>
<p>The <strong class="source-inline">CreateWidget()</strong> function is available through the <strong class="source-inline">UserWidget</strong> class, which can be found in <strong class="source-inline">/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h</strong>.</p>
<p>An example of this can be found in <a href="B18531_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating User Interfaces with UMG</em>, where you used the <strong class="source-inline">CreateWidget()</strong> function to create <strong class="source-inline">BP_HUDWidget</strong>:</p>
<p class="source-code">HUDWidget = CreateWidget&lt;UHUDWidget&gt;(this, BP_HUDWidget);</p>
<p>Refer back to <a href="B18531_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating User Interfaces with UMG</em>, and <em class="italic">Exercise 8.06 – creating the health bar C++ logic</em>, for more information regarding the <strong class="source-inline">CreateWidget()</strong> function in C++.</p>
<p>This function works <a id="_idIndexMarker1331"/>almost identically to its Blueprint counterpart because it takes in the <strong class="source-inline">Owning Object</strong> parameter, much like the <strong class="source-inline">Owning Player</strong> parameter of the Blueprint function, and it requires the <strong class="source-inline">User Widget</strong> class to be created. The C++ <strong class="source-inline">CreateWidget()</strong> function also takes in an <strong class="source-inline">FName</strong> parameter to represent the widget’s name.</p>
<p>Now that we have learned about the methods to use to add a UI to the player screen, let’s put this knowledge to the test. In the following exercise, you will be implementing the <strong class="source-inline">Create Widget</strong> and <strong class="source-inline">Add to Viewport</strong> Blueprint functions so that we can add the <strong class="bold">coin collection UI</strong> that we created in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>, to the player screen.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor337"/>Exercise 15.05 – Adding Coin Counter UI to the player screen</h2>
<p>In this exercise, you <a id="_idIndexMarker1332"/>will be creating a new <strong class="source-inline">Player Controller</strong> class so that you can use the player controller to add the <strong class="source-inline">BP_UI_CoinCollection</strong> widget Blueprint to the player’s screen. From there, you will also create a new <strong class="source-inline">Game Mode</strong> class and apply this game mode to the <strong class="bold">SuperSideScroller</strong> project. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">In the UE5 editor, navigate to <strong class="bold">Tools</strong> and then <strong class="bold">New C++ Class</strong>.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> dialog window, find and select the <strong class="bold">Player Controller</strong> option.</li>
<li>Name the new <strong class="source-inline">Player Controller</strong> class <strong class="source-inline">SuperSideScroller_Controller</strong> and then click the <strong class="bold">Create Class</strong> button. Visual Studio will automatically generate and open the source and header files for the <strong class="source-inline">SuperSideScroller_Controller</strong> class, but for now, we will stay inside the UE5 editor.</li>
<li>In the <strong class="bold">Content Drawer</strong> area, under the <strong class="source-inline">MainCharacter</strong> folder directory, create a new folder called <strong class="source-inline">PlayerController</strong>.</li>
<li>In the <strong class="source-inline">PlayerController</strong> folder, <em class="italic">right-click</em> and create a new <strong class="source-inline">Blueprint Class</strong> using the <a id="_idIndexMarker1333"/>new <strong class="source-inline">SuperSideScroller_Controller</strong> class. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer488">
<img alt="Figure 15.20 – Finding the new SuperSideScroller_Controller class to create a new Blueprint from " height="229" src="image/Figure_15.20_B18531.jpg" width="394"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.20 – Finding the new SuperSideScroller_Controller class to create a new Blueprint from</p>
<ol>
<li value="6">Name this new Blueprint <strong class="source-inline">BP_SuperSideScroller_PC</strong> and then <em class="italic">double-left-click</em> the asset to open it.</li>
</ol>
<p>To add the <strong class="source-inline">BP_UI_CoinCollection</strong> widget to the screen, we need to use the <strong class="source-inline">Add to Viewport</strong> function and the <strong class="source-inline">Create Widget</strong> function. We want the UI to be added to the player’s screen after the player character has been <strong class="source-inline">Possessed</strong> by the player controller. </p>
<ol>
<li value="7"><em class="italic">Right-click</em> inside the<a id="_idIndexMarker1334"/> Blueprint graph and, from the context-sensitive menu, find the <strong class="bold">Event On Possess</strong> option and <em class="italic">left-click</em> to add it to the graph. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer489">
<img alt="Figure 15.21 – Event On Possess  " height="99" src="image/Figure_15.21_B18531.jpg" width="188"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.21 – Event On Possess </p>
<p>The <strong class="bold">Event On Possess</strong> event node returns <strong class="bold">Possessed Pawn</strong>. We will use this <strong class="bold">Possessed Pawn</strong> to pass into our BP_UI_CoinCollection UI Widget, but first, we need to <strong class="bold">Cast To the SuperSideScroller_Player</strong> class.</p>
<ol>
<li value="8"><em class="italic">Left-click</em> and drag the <strong class="bold">Possessed Pawn</strong> parameter of the <strong class="source-inline">Event On Possess</strong> node from the output. Then, search for and find the <strong class="source-inline">Cast to SuperSideScroller_Player</strong> node. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer490">
<img alt="Figure 15.22 – We need to Cast To SuperSideScroller_Player " height="172" src="image/Figure_15.22_B18531.jpg" width="723"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.22 – We need to Cast To SuperSideScroller_Player</p>
<ol>
<li value="9">Now, <em class="italic">right-click</em> and search for the <strong class="source-inline">Create Widget</strong> function to add it to the Blueprint graph. </li>
<li>From the drop-down class parameter, find and assign the <strong class="source-inline">BP_UI_CoinCollection</strong> asset you created in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer491">
<img alt="Figure 15.23 – The Create Widget function  " height="255" src="image/Figure_15.23_B18531.jpg" width="455"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.23 – The Create Widget function </p>
<p>After updating the <strong class="source-inline">Class</strong> parameter to the <strong class="source-inline">BP_UI_CoinCollection</strong> class, you will notice<a id="_idIndexMarker1335"/> that the <strong class="source-inline">Create Widget</strong> function will update to show the <strong class="source-inline">Player</strong> variable you created, set to <strong class="source-inline">Exposed on Spawn</strong>.</p>
<ol>
<li value="11"><em class="italic">Right-click</em> in the Blueprint graph to search for and find the <strong class="source-inline">Self</strong> reference variable from the context-sensitive drop-down menu. Connect the <strong class="source-inline">Self</strong> object variable to the <strong class="source-inline">Owning Player</strong> parameter of the <strong class="source-inline">Create Widget</strong> function, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer492">
<img alt="Figure 15.24 – The Owning Player input parameter is of the Player Controller type " height="259" src="image/Figure_15.24_B18531.jpg" width="744"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.24 – The Owning Player input parameter is of the Player Controller type</p>
<p>The Owning <a id="_idIndexMarker1336"/>Player parameter refers to the Player Controller type that will show and own this UI object. Since we are adding this UI to the <strong class="bold">SuperSideScroller_Controller</strong> Blueprint, we can just use the <strong class="bold">Self</strong> reference variable to pass into the function.</p>
<ol>
<li value="12">Next, pass in the returned <strong class="source-inline">SuperSideScroller_Player</strong> variable from the <strong class="source-inline">Cast</strong> node to the <strong class="source-inline">Player</strong> input node of the <strong class="source-inline">Create Widget</strong> function. Then, connect the execution pins of the <strong class="source-inline">Cast</strong> node and the <strong class="source-inline">Create Widget</strong> function, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer493">
<img alt="Figure 15.25 – Creating the BP_UI_CoinCollection widget " height="231" src="image/Figure_15.25_B18531.jpg" width="1369"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.25 – Creating the BP_UI_CoinCollection widget</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png</a>.</p>
<ol>
<li value="13">Upon <a id="_idIndexMarker1337"/>pulling the <strong class="source-inline">Create Widget</strong> function from the <strong class="source-inline">Return Value</strong> parameter, search for and find the <strong class="source-inline">Add to Viewport</strong> function so that you can place it in the graph.</li>
<li>Connect the output <strong class="source-inline">Return Value</strong> parameter of the <strong class="source-inline">Create Widget</strong> function to the <strong class="source-inline">Target</strong> input parameter of the <strong class="source-inline">Add to Viewport</strong> function; do not change the <strong class="source-inline">ZOrder</strong> parameter.</li>
<li>Lastly, connect the execution pins of the <strong class="source-inline">Create Widget</strong> and <strong class="source-inline">Add to Viewport</strong> functions, as shown here:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer494">
<img alt="Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add it to the player viewport " height="197" src="image/Figure_15.26_B18531.jpg" width="1291"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add it to the player viewport</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/2UwufBd">https://packt.live/2UwufBd</a>.</p>
<p>Now that the player controller adds the <strong class="source-inline">BP_UI_CoinCollection</strong> widget to the player’s viewport, we need to create a <strong class="source-inline">GameMode</strong> Blueprint and apply both the <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong> and <strong class="source-inline">BP_SuperSideScroller_PC</strong> classes to this game mode.</p>
<ol>
<li value="16">In the <strong class="bold">Content Drawer</strong> area, create a new folder by <em class="italic">right-clicking</em> the <strong class="source-inline">Content</strong> folder and selecting <strong class="bold">New Folder</strong>. Name this folder <strong class="source-inline">GameMode</strong>.</li>
<li>Next, <em class="italic">right-click</em> and<a id="_idIndexMarker1338"/> select <strong class="bold">Blueprint Class</strong> to begin creating the game mode Blueprint. From the <strong class="bold">Pick Parent Class</strong> dialog window, search for and find <strong class="source-inline">SuperSideScrollerGameMode</strong> under <strong class="source-inline">All Classes</strong>.</li>
<li>Name this new <strong class="source-inline">GameMode</strong> Blueprint <strong class="source-inline">BP_SuperSideScroller_GameMode</strong>. <em class="italic">Double-left-click</em> this asset to open it.</li>
</ol>
<p>The <strong class="source-inline">GameMode</strong> Blueprint contains a list of classes that you can customize with your unique classes. For now, we will only worry about <strong class="source-inline">Player Controller Class</strong> and <strong class="source-inline">Default Pawn Class</strong>.</p>
<ol>
<li value="19">Click the <strong class="bold">Player Controller Class</strong> dropdown to find and select the <strong class="source-inline">BP_SuperSideScroller_PC</strong> Blueprint you created earlier in this exercise.</li>
<li>Then, click the <strong class="bold">Default Pawn Class</strong> dropdown to find and select the <strong class="source-inline">BP_SuperSideScroller_MainCharacter</strong> Blueprint.</li>
</ol>
<p>Now that we have a custom <strong class="source-inline">GameMode</strong> that utilizes our custom <strong class="source-inline">Player Controller</strong> and <strong class="source-inline">Player Character</strong> classes, let’s add this game mode to the <strong class="bold">Project Settings</strong> window so that the game mode is used by default when using <strong class="source-inline">PIE</strong> and when cooking builds of the project.</p>
<ol>
<li value="21">From the UE5 editor, navigate to the <strong class="bold">Edit</strong> option at the top of the screen. Click this option and from the drop-down menu, find and select the <strong class="bold">Project Settings</strong> option.</li>
<li>On the left-hand side <a id="_idIndexMarker1339"/>of the <strong class="bold">Project Settings</strong> window, you will be provided with a list of categories divided into sections. Under the <strong class="bold">Project</strong> section, click the <strong class="bold">Maps &amp; Modes</strong> category.</li>
<li>In the <strong class="bold">Maps &amp; Modes</strong> section, you have a handful of parameters related to your project’s default maps and game mode. At the top of this section, you have the <strong class="bold">Default GameMode</strong> option. Click this dropdown to find and select the <strong class="bold">SuperSideScroller_GameMode</strong> Blueprint you created earlier in this exercise. </li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Changes made to the <strong class="bold">Maps &amp; Modes</strong> section are automatically saved and written to the <strong class="source-inline">DefaultEngine.ini</strong> file, which can be found in your project’s <strong class="source-inline">Config</strong> folder. <strong class="source-inline">Default GameMode</strong> can be overwritten per level by updating the <strong class="bold">GameMode Override</strong> parameter, which can be found in the <strong class="bold">World Settings</strong> window of your level.</p>
<ol>
<li value="24">Close the <strong class="bold">Project Settings</strong> window and return to your level. Use <strong class="source-inline">PIE</strong> and start collecting coins. Observe that the <strong class="bold">BP_UI_CoinCollection</strong> widget is shown and updated each time you collect a coin, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer495">
<img alt="Figure 15.27 – Now, every coin you collect will appear on the player UI " height="659" src="image/Figure_15.27_B18531.jpg" width="1095"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.27 – Now, every coin you collect will appear on the player UI</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05</a>.</p>
<p>With this exercise complete, you<a id="_idIndexMarker1340"/> have created the <strong class="source-inline">UI UMG</strong> widget needed to display the current number of coins collected by the player. By using the <strong class="source-inline">GetCurrentNumberofCollectables()</strong> C++ function and the binding functionality of the <strong class="bold">Text widget</strong>, the UI will always update its value based on the number of coins collected. </p>
<p>So far, we have focused on the collectible coin and allowing players to collect these coins and add the total coins collected to the player’s UI. Now, we will focus on the potion power-up and granting<a id="_idIndexMarker1341"/> movement speed and jump height increases to the player for a short period. To implement this functionality, we first need to study timers.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor338"/>Using timers</h1>
<p>Timers in UE5 allow you to <a id="_idIndexMarker1342"/>perform actions after a delay or every <em class="italic">X</em> number of seconds. In the case of the <strong class="bold">SuperSideScroller</strong> potion power-up, a timer will be used to restore the player’s movement and jump to their defaults after 8 seconds.</p>
<p class="callout-heading">Note</p>
<p class="callout">In Blueprints, you can use a <strong class="source-inline">Delay</strong> node in addition to timer handles to achieve the same results. However, in C++, timers are the best means to achieve delays and reoccurring logic.</p>
<p>Timers are managed by <strong class="source-inline">Timer Manager</strong>, or <strong class="source-inline">FTimerManager</strong>, which exists in the <strong class="source-inline">UWorld</strong> object. There are two main functions that you will be using from the <strong class="source-inline">FTimerManager</strong> class, called <strong class="source-inline">SetTimer()</strong> and <strong class="source-inline">ClearTimer()</strong>:</p>
<pre class="source-code">
void SetTimer
(
    FTimerHandle &amp; InOutHandle,
    TFunction &lt; void )&gt; &amp;&amp; Callback,
    float InRate,
    bool InbLoop,
    float InFirstDelay
)
void ClearTimer(FTimerHandle&amp; InHandle)</pre>
<p>You may have noticed that, in both functions, there is a required <strong class="source-inline">FTimerHandle</strong>. This handle is used to control the timer you have set. Using this handle, you can pause, resume, clear, and even extend the timer.</p>
<p>The <strong class="source-inline">SetTimer()</strong> function also has other parameters to help you customize this timer when initially setting it. The callback function will be called after the timer has been completed, and if the <strong class="source-inline">InbLoop</strong> parameter is <strong class="source-inline">True</strong>, it will continue to call the callback function indefinitely, until the timer has been stopped. The <strong class="source-inline">InRate</strong> parameter is the duration of the<a id="_idIndexMarker1343"/> timer itself, while <strong class="source-inline">InFirstDelay</strong> is an initial delay that’s applied to the timer before it begins its timer for <strong class="source-inline">InRate</strong>.</p>
<p>The header file for the <strong class="source-inline">FTimerManager</strong> class can be found here: <strong class="source-inline">/Engine/Source/Runtime/Engine/Public/TimerManager.h</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about timers and <strong class="source-inline">FTimerHandle</strong> by reading the documentation here: <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/</a>.</p>
<p>In the following exercise, you will create your own <strong class="source-inline">FTimerHandle</strong> in the <strong class="source-inline">SuperSideScroller_Player</strong> class and use it to control how long the effects of the potion power-up last on the player.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor339"/>Exercise 15.06 – adding the potion power-up behavior to the player</h2>
<p>In this exercise, you will be <a id="_idIndexMarker1344"/>creating the logic behind the potion power-up and how it will affect the player’s character. You will take advantage of timers and timer handles to ensure that the power-up effects only last for a short duration. Follow these steps to accomplish this:</p>
<ol>
<li value="1">In Visual Studio, navigate to and open the <strong class="source-inline">SuperSideScroller_Player.h</strong> header file.</li>
<li>Under our <strong class="source-inline">Private Access Modifier</strong>, add a new variable of the <strong class="source-inline">FTimerHandle</strong> type and name it <strong class="source-inline">PowerupHandle</strong>:<p class="source-code">FTimerHandle PowerupHandle;</p></li>
</ol>
<p>This timer handle will be responsible for keeping track of how much time has elapsed since it was initiated. This will allow us to control how long the potion power-up’s effects will last.</p>
<ol>
<li value="3">Next, add a Boolean variable under our <strong class="source-inline">Private Access Modifier</strong> called <strong class="source-inline">bHasPowerupActive</strong>:<p class="source-code">bool bHasPowerupActive;</p></li>
</ol>
<p>We will use this Boolean variable when updating the <strong class="source-inline">Sprint()</strong> and <strong class="source-inline">StopSprinting()</strong> functions<a id="_idIndexMarker1345"/> to ensure we update the player’s sprint movement speed appropriately based on whether the power-up is active.</p>
<ol>
<li value="4">Next, declare a new void function called <strong class="source-inline">IncreaseMovementPowerup()</strong> under our <strong class="source-inline">Public Access Modifier</strong>:<p class="source-code">void IncreaseMovementPowerup();</p></li>
</ol>
<p>This is the function that will be called from the potion power-up class to enable the effects of the power-up for the player.</p>
<ol>
<li value="5">Finally, you need to create a function that handles when the power-up effects end. Create a function called <strong class="source-inline">EndPowerup()</strong> under <strong class="source-inline">Protected Access Modifier</strong>:<p class="source-code">void EndPowerup();</p></li>
</ol>
<p>With all the necessary variables and functions declared, it’s time to start defining these new functions and handling the power-up effects on the player.</p>
<ol>
<li value="6">Navigate to the <strong class="source-inline">SuperSideScroller_Player.cpp</strong> source file.</li>
<li>First, add the <strong class="source-inline">#include “TimerManager.h”</strong> header file to the top of the source file; we will need this class to use the timers.</li>
<li>Define the <strong class="source-inline">IncreaseMovementPowerup()</strong> function by adding the following code to the source file:<p class="source-code">void ASuperSideScroller_Player::IncreaseMovementPowerup()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>When this function is called, the first thing we need to do is set the <strong class="source-inline">bHasPowerupActive</strong> variable to <strong class="source-inline">true</strong>. Add the following code to the <strong class="source-inline">IncreaseMovementPowerup()</strong> function:<p class="source-code">bHasPowerupActive = true;</p></li>
<li>Next, add the following code to increase both the <strong class="source-inline">MaxWalkSpeed</strong> and <strong class="source-inline">JumpZVelocity</strong> components of the player character’s movement component:<p class="source-code">GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;</p><p class="source-code">GetCharacterMovement()-&gt;JumpZVelocity = 1500.0f;</p></li>
</ol>
<p>Here, we are changing <strong class="source-inline">MaxWalkSpeed</strong> from the default value of <strong class="source-inline">300.0f</strong> to <strong class="source-inline">500.0f</strong>. As you may recall, the <a id="_idIndexMarker1346"/>default sprinting speed is also <strong class="source-inline">500.0f</strong>. We will address this later in this activity to increase the sprinting speed when the power-up is active.</p>
<ol>
<li value="11">To take advantage of timers, we need to get a reference to the <strong class="source-inline">UWorld</strong> object. Add the following code:<p class="source-code">UWorld* World = GetWorld();</p><p class="source-code">if (World)</p><p class="source-code">{</p><p class="source-code">}</p></li>
</ol>
<p>As we’ve done many times before in this project, we’re using the <strong class="source-inline">GetWorld()</strong> function to get a reference to the <strong class="source-inline">UWorld</strong> object and saving this reference in its variable.</p>
<ol>
<li value="12">Now that we have the reference to the <strong class="source-inline">World</strong> object and have performed a validity check, it is safe to use <strong class="source-inline">TimerManager</strong> to set the power-up timer. Add the following code within the <strong class="source-inline">if()</strong> statement shown in the previous step:<p class="source-code">World-&gt;GetTimerManager().SetTimer(PowerupHandle, this, </p><p class="source-code">  &amp;ASuperSideScroller_Player::EndPowerup, 8.0f, false);</p></li>
</ol>
<p>Here, you are using the TimerManager class to set a timer. The <strong class="source-inline">SetTimer()</strong> function takes in the <strong class="source-inline">FTimerHandle</strong> component to use; in this case, the <strong class="source-inline">PowerupHandle</strong> variable you created. Next, we need to pass in a reference to the player class by<a id="_idIndexMarker1347"/> using the <strong class="source-inline">this</strong> keyword. Then, we need to provide the callback function to call after the timer has ended, which in this case is the <strong class="source-inline">&amp;ASuperSideScroller_Player::EndPowerup</strong> function. <strong class="source-inline">8.0f</strong> represents the duration of the timer; feel free to adjust this as you see fit, but for now, 8 seconds is fine. Lastly, there is the final boolean parameter of the <strong class="source-inline">SetTimer()</strong> function that determines whether this timer should loop; in this case, it should not.</p>
<ol>
<li value="13">Create the function definition for the <strong class="source-inline">EndPowerup()</strong> function:<p class="source-code">void ASuperSideScroller_Player::EndPowerup()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>The first thing to do when the <strong class="source-inline">EndPowerup()</strong> function is called is set the <strong class="source-inline">bHasPowerupActive</strong> variable to <strong class="source-inline">false</strong>. Add the following code within the <strong class="source-inline">EndPowerup()</strong> function:<p class="source-code">bHasPowerupActive = false;</p></li>
<li>Next, change the <strong class="source-inline">MaxWalkSpeed</strong> and <strong class="source-inline">JumpZVelocity</strong> parameters of the character movement component back to their default values. Add the following code:<p class="source-code">GetCharacterMovement()-&gt;MaxWalkSpeed = 300.0f;</p><p class="source-code">GetCharacterMovement()-&gt;JumpZVelocity = 1000.0f;</p></li>
</ol>
<p>Here, we are changing both the <strong class="source-inline">MaxWalkSpeed</strong> and <strong class="source-inline">JumpZVelocity</strong> parameters of the character movement component to their default values.</p>
<ol>
<li value="16">Again, to take advantage of the timers and to clear the timer to handle <strong class="source-inline">PowerupHandle</strong>, we need to get a reference to the <strong class="source-inline">UWorld</strong> object. Add the following code:<p class="source-code">UWorld* World = GetWorld();</p><p class="source-code">if (World)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Finally, we can add the code to clear the timer handle’s <strong class="source-inline">PowerupHandle</strong>:<p class="source-code">World-&gt;GetTimerManager().ClearTimer(PowerupHandle);</p></li>
</ol>
<p>By using the <strong class="source-inline">ClearTimer()</strong> function and passing in <strong class="source-inline">PowerupHandle</strong>, we are ensuring that this timer is no longer valid and will no longer affect the player.</p>
<p>Now that we have<a id="_idIndexMarker1348"/> created the functions that handle the power-up effects and the timer associated with the effects, we need to update both the <strong class="source-inline">Sprint()</strong> and <strong class="source-inline">StopSprinting()</strong> functions so that they also take into account the speed of the player when the power-up is active.</p>
<ol>
<li value="18">Update the <strong class="source-inline">Sprint()</strong> function to the following:<p class="source-code">void ASuperSideScroller_Player::Sprint()</p><p class="source-code">{</p><p class="source-code">  if (!bIsSprinting)</p><p class="source-code">  {</p><p class="source-code">    bIsSprinting = true;</p><p class="source-code">    if (bHasPowerupActive)</p><p class="source-code">    {</p><p class="source-code">      GetCharacterMovement()-&gt;MaxWalkSpeed = 900.0f;</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">      GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>Here, we are updating the <strong class="source-inline">Sprint()</strong> function to take into account whether <strong class="source-inline">bHasPowerupActive</strong> is <strong class="source-inline">true</strong>. If this<a id="_idIndexMarker1349"/> variable is <strong class="source-inline">true</strong>, then we increase <strong class="source-inline">MaxWalkSpeed</strong> while sprinting from <strong class="source-inline">500.0f</strong> to <strong class="source-inline">900.0f</strong>, as shown here:</p>
<p class="source-code">if (bHasPowerupActive)</p>
<p class="source-code">{</p>
<p class="source-code">  GetCharacterMovement()-&gt;MaxWalkSpeed = 900.0f;</p>
<p class="source-code">}</p>
<p>If <strong class="source-inline">bHasPowerupActive</strong> is false, then we increase <strong class="source-inline">MaxWalkSpeed</strong> to <strong class="source-inline">500.0f</strong>, as we did by default.</p>
<ol>
<li value="19">Update the <strong class="source-inline">StopSprinting()</strong> function to the following:<p class="source-code">void ASuperSideScroller_Player::StopSprinting()</p><p class="source-code">{</p><p class="source-code">  if (bIsSprinting)</p><p class="source-code">  {</p><p class="source-code">    bIsSprinting = false;</p><p class="source-code">    if (bHasPowerupActive)</p><p class="source-code">    {</p><p class="source-code">      GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">      GetCharacterMovement()-&gt;MaxWalkSpeed = 300.0f;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>Here, we are updating<a id="_idIndexMarker1350"/> the <strong class="source-inline">StopSprinting()</strong> function to take into account whether <strong class="source-inline">bHasPowerupActive</strong> is true. If this variable is true, then we set the <strong class="source-inline">MaxWalkSpeed</strong> value to <strong class="source-inline">500.0f</strong> instead of <strong class="source-inline">300.0f</strong>, as shown here:</p>
<p class="source-code">if (bHasPowerupActive)</p>
<p class="source-code">{</p>
<p class="source-code">  GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;</p>
<p class="source-code">}</p>
<p>If <strong class="source-inline">bHasPowerupActive</strong> is false, then we set <strong class="source-inline">MaxWalkSpeed</strong> to <strong class="source-inline">300.0f</strong>, as we did by default.</p>
<ol>
<li value="20">Finally, all we need to do is recompile the C++ code.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06</a>.</p>
<p>With this exercise complete, you<a id="_idIndexMarker1351"/> have created the potion power-up effects within the player character. The power-up increases both the default movement speed of the player and increases their jump height. Moreover, the effects of the power-up increase the sprinting speed. By using timer handles, you were able to control how long the power-up effect would last. </p>
<p>Now, it is time to create the potion power-up actor so that we can have a representation of this power-up in the game.</p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor340"/>Activity 15.03 – creating the potion power-up actor</h2>
<p>Now that the <strong class="source-inline">SuperSideScroller_Player</strong> class handles the effects of the potion power-up, it’s time to create the<a id="_idIndexMarker1352"/> potion power-up class and Blueprint. This activity aims to create the potion power-up class, inherit from the <strong class="source-inline">PickableActor_Base</strong> class, implement the overlapping functionality to grant the movement effects that you implemented in <em class="italic">Exercise 15.06 – adding the potion power-up behavior to the player</em>, and create the Blueprint actor for the potion power-up. Follow these steps to create the potion power-up class and create the potion Blueprint actor:</p>
<ol>
<li value="1">Create a new C++ class that inherits from the <strong class="source-inline">PickableActor_Base</strong> class and name this new class <strong class="source-inline">PickableActor_Powerup</strong>.</li>
<li>Add the override function declarations for both the <strong class="source-inline">BeginPlay()</strong> and <strong class="source-inline">PlayerPickedUp()</strong> functions.</li>
<li>Create the function definition for the <strong class="source-inline">BeginPlay()</strong> function. Within the <strong class="source-inline">BeginPlay()</strong> function, add the call to the parent class function of <strong class="source-inline">BeginPlay()</strong>.</li>
<li>Create the function definition for the <strong class="source-inline">PlayerPickedUp()</strong> function. Within the <strong class="source-inline">PlayerPickedUp()</strong> function, add the call to the <strong class="source-inline">PlayerPickedUp()</strong> parent class function.</li>
<li>Next, add the necessary <strong class="source-inline">#include</strong> file for the <strong class="source-inline">SuperSideScroller_Player</strong> class so that we can reference the player class and its functions.</li>
<li>In the <strong class="source-inline">PlayerPickedUp()</strong> function, use the <strong class="source-inline">Player</strong> input parameter of the function itself to make the function call to <strong class="source-inline">IncreaseMovementPowerup()</strong>.</li>
<li>From <strong class="bold">Epic Games Launcher</strong>, find the <strong class="bold">Action RPG</strong> project from the <strong class="bold">Samples</strong> tab, under the <strong class="bold">UE Legacy Samples</strong> category. Use this to create and install a new project. </li>
<li>Migrate the <strong class="source-inline">A_Character_Heal_Mana_Cue</strong> and <strong class="source-inline">SM_PotionBottle</strong> assets, as well as all of<a id="_idIndexMarker1353"/> their referenced assets, from the <strong class="bold">Action RPG</strong> project to your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Create a new folder in the <strong class="bold">Content Drawer</strong> area within the <strong class="source-inline">PickableItems</strong> directory called <strong class="source-inline">Powerup</strong>. Create a new Blueprint within this directory based on the <strong class="source-inline">PickableActor_Powerup</strong> class and name this asset <strong class="source-inline">BP_Powerup</strong>.</li>
<li>In <strong class="source-inline">BP_Powerup</strong>, update the <strong class="source-inline">MeshComp</strong> component so that it uses the <strong class="source-inline">SM_PotionBottle</strong> static mesh. </li>
<li>Next, add <strong class="source-inline">A_Character_Heal_Mana_Cue</strong>, which you imported as the <strong class="source-inline">Pickup Sound</strong> parameter.</li>
<li>Finally, update the <strong class="source-inline">RotationComp</strong> component so that the actor will rotate 60 degrees per second around the <strong class="source-inline">Pitch</strong> axis (<strong class="source-inline">Y</strong> axis) and rotate 180 degrees per second around the <strong class="source-inline">Yaw</strong> axis (<strong class="source-inline">X</strong> axis).</li>
<li>Add <strong class="source-inline">BP_Powerup</strong> to your level and use <strong class="source-inline">PIE</strong> to observe the results when overlapping with the power-up.</li>
</ol>
<p>Expected output:</p>
<div>
<div class="IMG---Figure" id="_idContainer496">
<img alt="Figure 15.28 – The potion power-up  " height="366" src="image/Figure_15.28_B18531.jpg" width="474"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.28 – The potion power-up </p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you <a id="_idIndexMarker1354"/>were able to put your knowledge to the test in terms of creating a new C++ class that inherits from the <strong class="source-inline">PickableActor_Base</strong> class and overrides the <strong class="source-inline">PlayerPickedUp()</strong> function to add custom logic. By adding the call to the <strong class="source-inline">IncreaseMovementPowerup()</strong> function from the player class, you were able to add the movement power-up effects to the player when overlapping with the actor. Then, by using a custom mesh, material, and audio assets, you were able to bring the Blueprint actor to life from the <strong class="source-inline">PickableActor_Powerup</strong> class.</p>
<p>Now that we have created the coin collectible and the potion power-up, we need to implement a new gameplay feature into the project: the <strong class="source-inline">Brick</strong> class. In games such as <em class="italic">Super Mario</em>, bricks contain hidden coins and power-ups for the players to find. These bricks also serve as a means of reaching elevated platforms and areas within the level. In our <strong class="bold">SuperSideScroller</strong> project, the <strong class="source-inline">Brick</strong> class will serve the purpose of containing hidden coin collectibles for the player, and as a means of allowing the player to reach areas of the level by using the bricks as paths to access hard-to-reach locations. So, in the next section, we will create the <strong class="source-inline">Brick</strong> class, which needs to be broken to find the hidden coins.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor341"/>Exercise 15.07 – creating the Brick class</h2>
<p>Now that we have created the <a id="_idIndexMarker1355"/>coin collectible and the potion power-up, it is time to create the <strong class="source-inline">Brick</strong> class, which will contain hidden coins for the player to collect. The brick is the final gameplay element of the <strong class="bold">SuperSideScroller</strong> project. In this exercise, you will be creating the <strong class="source-inline">Brick</strong> class, which will be used as part of the platforming mechanic of the <strong class="bold">SuperSideScroller</strong> game project, but also as a means to hold collectibles for players to find. Follow these steps to create this <strong class="source-inline">Brick</strong> class and its Blueprint:</p>
<ol>
<li value="1">In the UE5 editor, navigate to <strong class="bold">Tools</strong> and then <strong class="bold">New C++ Class</strong>.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> dialog window, find and select the <strong class="source-inline">Actor</strong> class.</li>
<li>Name this class <strong class="source-inline">SuperSideScroller_Brick</strong> and click <strong class="bold">Create Class</strong>. Visual Studio and Unreal Engine will recompile the code and open this class for you.</li>
</ol>
<p>By default, the <strong class="source-inline">SuperSideScroller_Brick</strong> class comes with the <strong class="source-inline">Tick()</strong> function, but we will not need this function for the <strong class="source-inline">Brick</strong> class. Remove the function declaration for <strong class="source-inline">Tick()</strong> from the <strong class="source-inline">SuperSideScroller_Brick.h</strong> header file and remove the function definition from the <strong class="source-inline">SuperSideScroller_Brick.cpp</strong> source file before continuing.</p>
<ol>
<li value="4">Under <strong class="source-inline">Private Access Modifier</strong> for the <strong class="source-inline">SuperSideScroller_Brick.h</strong> file, add the following code to declare a new <strong class="source-inline">UStaticMeshComponent* UPROPERTY()</strong> function to represent the brick in our game world:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = Brick)</p><p class="source-code">class UStaticMeshComponent* BrickMesh;</p></li>
<li>Next, we need to create a <strong class="source-inline">UBoxComponent UPROPERTY()</strong> that will handle the collision with the player character. Add the following code to add this component under our <strong class="source-inline">Private Access Modifier</strong>:<p class="source-code">UPROPERTY(VisibleDefaultsOnly, Category = Brick)</p><p class="source-code">class UBoxComponent* BrickCollision;</p></li>
<li>Create the <strong class="source-inline">UFUNCTION()</strong> declaration for the <strong class="source-inline">OnHit()</strong> function under our <strong class="source-inline">Private Access Modifier</strong>. This will be used to determine when <strong class="source-inline">UBoxComponent</strong> is hit by the player:<p class="source-code">UFUNCTION()</p><p class="source-code">void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, </p><p class="source-code">  UPrimitiveComponent* OtherComp, FVector </p><p class="source-code">  NormalImpulse, </p><p class="source-code">  const FHitResult&amp; Hit);</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Recall that you used the <strong class="source-inline">OnHit()</strong> function when developing the <strong class="source-inline">PlayerProjectile</strong> class in <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, for this project. Please review that chapter for more information about the <strong class="source-inline">OnHit()</strong> function.</p>
<ol>
<li value="7">Next, create a new <a id="_idIndexMarker1356"/>Boolean called <strong class="source-inline">UPROPERTY()</strong> under our <strong class="source-inline">Private Access Modifier</strong> using the <strong class="source-inline">EditAnywhere</strong> keyword called <strong class="source-inline">bHasCollectable</strong>:<p class="source-code">UPROPERTY(EditAnywhere)</p><p class="source-code">bool bHasCollectable;</p></li>
</ol>
<p>This Boolean will determine whether the brick contains a coin collectible for the player.</p>
<ol>
<li value="8">Now, we need a variable that holds how many coin collectibles are available within this brick for the player. We will do this by creating an integer variable called <strong class="source-inline">Collectable Value</strong>. Make this a <strong class="source-inline">UPROPERTY()</strong>, under <strong class="source-inline">Private Access Modifier</strong>, with the <strong class="source-inline">EditAnywhere</strong> keyword, and give it a default value of <strong class="source-inline">1</strong>, as shown here:<p class="source-code">UPROPERTY(EditAnywhere)</p><p class="source-code">int32 CollectableValue = 1;</p></li>
</ol>
<p>The brick will need to <a id="_idIndexMarker1357"/>contain a unique sound and particle system so that it has a nice layer of polish for when the brick is destroyed by the player. We’ll add these properties next.</p>
<ol>
<li value="9">Create a new <strong class="source-inline">Public Access Modifier</strong> in the <strong class="source-inline">SuperSideScroller_Brick.h</strong> header file.</li>
<li>Next, create a new <strong class="source-inline">UPROPERTY()</strong> using the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">BlueprintReadOnly</strong> keywords for a variable of the <strong class="source-inline">USoundBase</strong> class. Name this variable <strong class="source-inline">HitSound</strong>, as shown here:<p class="source-code">UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Brick)</p><p class="source-code">class USoundBase* HitSound;</p></li>
<li>Then, create a new <strong class="source-inline">UPROPERTY()</strong> using the <strong class="source-inline">EditAnywhere</strong> and <strong class="source-inline">BlueprintReadOnly</strong> keywords for a variable of the <strong class="source-inline">UParticleSystem</strong> class. Make sure to put this under <strong class="source-inline">Public Access Modifier</strong> and name this variable <strong class="source-inline">Explosion</strong>, as shown here:<p class="source-code">UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Brick)</p><p class="source-code">class UParticleSystem* Explosion;</p></li>
</ol>
<p>Now that we have all the necessary properties for the <strong class="source-inline">Brick</strong> class, let’s move on to the <strong class="source-inline">SuperSideScroller_Brick.cpp</strong> source file, where we will initialize the components.</p>
<ol>
<li value="12">Let’s start by adding the following <strong class="source-inline">#include</strong> directories for <strong class="source-inline">StaticMeshComponent</strong> and <strong class="source-inline">BoxComponent</strong>. Add the following code to the <strong class="source-inline">#include</strong> list of the source file:<p class="source-code">#include "Components/StaticMeshComponent.h"</p><p class="source-code">#include "Components/BoxComponent.h"</p></li>
<li>First, initialize the <strong class="source-inline">BrickMesh</strong> component by adding the following code to the <strong class="source-inline">ASuperSideScroller_Brick::ASuperSideScroller_Brick()</strong> constructor function:<p class="source-code">BrickMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("BrickMesh"));</p></li>
<li>Next, the <strong class="source-inline">BrickMesh</strong> component should have a collision so that the player can walk on top of it for<a id="_idIndexMarker1358"/> platforming gameplay purposes. To ensure this occurs by default, add the following code to set the collision to <strong class="source-inline">“BlockAll”</strong>:<p class="source-code">BrickMesh-&gt;SetCollisionProfileName("BlockAll");</p></li>
<li>Lastly, the <strong class="source-inline">BrickMesh</strong> component will serve as the root component of the <strong class="source-inline">Brick</strong> actor. Add the following code to do this:<p class="source-code">RootComponent = BrickMesh;</p></li>
<li>Now, add the following code to the constructor function to initialize our <strong class="source-inline">BrickCollision UBoxComponent</strong>:<p class="source-code">BrickCollision = CreateDefaultSubobject&lt;UBoxComponent&gt;</p><p class="source-code">  (TEXT("BrickCollision"));</p></li>
<li>Just like the <strong class="source-inline">BrickMesh</strong> component, the <strong class="source-inline">BrickCollision</strong> component will also need to have its collision set to <strong class="source-inline">“BlockAll”</strong> to receive the <strong class="source-inline">OnHit()</strong> callback events we will be adding later in this exercise. Add the following code:<p class="source-code">BrickCollision-&gt;SetCollisionProfileName("BlockAll");</p></li>
<li>Next, the <strong class="source-inline">BrickCollision</strong> component needs to be attached to the <strong class="source-inline">BrickMesh</strong> component. We can do this by adding the following code:<p class="source-code">BrickCollision-&gt;AttachToComponent(RootComponent, </p><p class="source-code">  FAttachmentTransformRules::KeepWorldTransform);</p></li>
<li>Before we can finish the initialization of the <strong class="source-inline">BrickCollision</strong> component, we need to add the function <a id="_idIndexMarker1359"/>definition for the <strong class="source-inline">OnHit()</strong> function. Add the following definition to the source file:<p class="source-code">void ASuperSideScroller_Brick::OnHit(UPrimitiveComponent* HitComp, AActor* </p><p class="source-code">  OtherActor, UPrimitiveComponent* OtherComp, FVector </p><p class="source-code">  NormalImpulse, const </p><p class="source-code">  FHitResult&amp; Hit)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Now that we have defined the <strong class="source-inline">OnHit()</strong> function, we can assign the <strong class="source-inline">OnComponentHit</strong> callback to the <strong class="source-inline">BrickCollision</strong> component. Add the following code to the constructor function:<p class="source-code">BrickCollision-&gt;OnComponentHit.AddDynamic(this, </p><p class="source-code">  &amp;ASuperSideScroller_Brick::OnHit);</p></li>
<li>Compile the C++ code for the <strong class="source-inline">SuperSideScroller_Brick</strong> class and return to the UE5 editor.</li>
<li>In the <strong class="bold">Content Drawer</strong> area, <em class="italic">right-click</em> on the <strong class="source-inline">Content</strong> folder and select the <strong class="bold">New Folder</strong> option. Name this folder <strong class="source-inline">Brick</strong>.</li>
<li><em class="italic">Right-click</em> inside the <strong class="source-inline">Brick</strong> folder and select <strong class="source-inline">Blueprint Class</strong>. From the <strong class="source-inline">All Classes</strong> search bar in the <strong class="bold">Pick Parent Class</strong> dialog window, search for and select the <strong class="source-inline">SuperSideScroller_Brick</strong> class.</li>
<li>Name this new Blueprint <strong class="source-inline">BP_Brick</strong>, and then <em class="italic">double-left-click</em> the asset to open it.</li>
<li>Select the <strong class="source-inline">BrickMesh</strong> component from the <strong class="bold">Components</strong> tab and set its <strong class="source-inline">Static Mesh</strong> parameter to the <strong class="source-inline">Shape_Cube</strong> mesh.</li>
<li>With the <strong class="source-inline">BrickMesh</strong> component still selected, set the <strong class="source-inline">Element 0</strong> material parameter to <strong class="source-inline">M_Brick_Clay_Beveled</strong>. This material is provided by Epic Games by default when creating a new project. It can be found within the <strong class="source-inline">StarterContent</strong> directory, in the <strong class="bold">Content Drawer</strong> area.</li>
</ol>
<p>The last thing we need to do with the <strong class="source-inline">BrickMesh</strong> component is adjust its scale so that it fits the<a id="_idIndexMarker1360"/> needs of the player character, as well as the platforming mechanics of the <strong class="bold">SuperSideScroller</strong> game project.</p>
<ol>
<li value="27">With the <strong class="source-inline">BrickMesh</strong> component selected, make the following change to its <strong class="source-inline">Scale</strong> parameter:<p class="source-code">(X=0.750000,Y=0.750000,Z=0.750000)</p></li>
</ol>
<p>Now that the <strong class="source-inline">BrickMesh</strong> component is <strong class="source-inline">75%</strong> of its normal size, the <strong class="source-inline">Brick</strong> actor will become more manageable for us as designers when we place the actor into the game world, as well as when we’re developing interesting platforming sections within the level.</p>
<p>The final step here is to update the location of the <strong class="source-inline">BrickCollision</strong> component so that it only has some of its collision sticking out from the bottom of the <strong class="source-inline">BrickMesh</strong> component.</p>
<ol>
<li value="28">Select the <strong class="source-inline">BrickCollision</strong> component from the <strong class="bold">Components</strong> tab and update its <strong class="source-inline">Location</strong> parameter to the following values:<p class="source-code">(X=0.000000,Y=0.000000,Z=30.000000)</p></li>
</ol>
<p>The <strong class="source-inline">BrickCollision</strong> component should now be positioned as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer497">
<img alt="Figure 15.29 – Now, the BrickCollision component is just barely outside the BrickMesh component " height="495" src="image/Figure_15.29_B18531.jpg" width="707"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.29 – Now, the BrickCollision component is just barely outside the BrickMesh component</p>
<p>We are making this adjustment to the position of the <strong class="source-inline">BrickCollision</strong> component so that the player can only hit <strong class="source-inline">UBoxComponent</strong> when jumping underneath the brick. By making it slightly <a id="_idIndexMarker1361"/>outside of the <strong class="source-inline">BrickMesh</strong> component, we can control it better and ensure that this component cannot be hit by the player in any other way.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07</a>.</p>
<p>With this exercise complete, you were able to create the base framework for the <strong class="source-inline">SuperSideScroller_Brick</strong> class and put together the Blueprint actor to represent the brick in the game world. By adding a cube mesh and brick material, you added a nice visual polish to the brick. In the following exercise, you will add the remaining C++ logic to the brick. This will allow the player to destroy the brick and obtain a collectible.</p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor342"/>Exercise 15.08 – adding the Brick class’s C++ logic</h2>
<p>In the previous exercise, you created the base<a id="_idIndexMarker1362"/> framework for the <strong class="source-inline">SuperSideScroller_Brick</strong> class by adding the necessary components and creating the <strong class="source-inline">BP_Brick</strong> Blueprint actor. In this exercise, you will add on top of the C++ code of <em class="italic">Exercise 15.07 – creating the Brick class</em>, to grant logic to the <strong class="source-inline">Brick</strong> class. This will allow the brick to give players coin collectibles. Perform the following steps to accomplish this:</p>
<ol>
<li value="1">To begin, we need to create a function that will add the collectible to the player. Add the following function declaration to the <strong class="source-inline">SuperSideScroller_Brick.h</strong> header file, under our <strong class="source-inline">Private Access Modifier</strong>:<p class="source-code">void AddCollectable(class ASuperSideScroller_Player* Player);</p></li>
</ol>
<p>We want to pass in a reference to the <strong class="source-inline">SuperSideScroller_Player</strong> class so that we can call the <strong class="source-inline">IncrementNumberofCollectables()</strong> function from that class.</p>
<ol>
<li value="2">Next, create a void function declaration called <strong class="source-inline">PlayHitSound()</strong> under our <strong class="source-inline">Private Access Modifier</strong>:<p class="source-code">void PlayHitSound();</p></li>
</ol>
<p>The <strong class="source-inline">PlayHitSound()</strong> function will be responsible for spawning the <strong class="source-inline">HitSound</strong> property you created in <em class="italic">Exercise 15.07 – creating the Brick class</em>.</p>
<ol>
<li value="3">Finally, create another void function declaration called <strong class="source-inline">PlayHitExplosion()</strong> under our <strong class="source-inline">Private Access Modifier</strong>:<p class="source-code">void PlayHitExplosion();</p></li>
</ol>
<p>The <strong class="source-inline">PlayHitExplosion()</strong> function will be responsible for spawning the <strong class="source-inline">Explosion</strong> property you created in <em class="italic">Exercise 15.07 – creating the Brick class</em>.</p>
<p>With the remaining functions needed for the <strong class="source-inline">SuperSideScroller_Brick</strong> class declared in the header file, let’s move on and define these functions inside the source file.</p>
<ol>
<li value="4">At the top of the <strong class="source-inline">SuperSideScroller_Brick.cpp</strong> source file, add the following <strong class="source-inline">#include</strong> statements to the list of <strong class="source-inline">#include</strong> directories that already exist for this class:<p class="source-code">#include "Engine/World.h"</p><p class="source-code">#include "Kismet/GameplayStatics.h"</p><p class="source-code">#include "SuperSideScroller_Player.h"</p></li>
</ol>
<p>The includes for the <strong class="source-inline">World</strong> and <strong class="source-inline">GameplayStatics</strong> classes are necessary to spawn both the <strong class="source-inline">HitSound</strong> and the <strong class="source-inline">Explosion</strong> effects for the brick. Including the <strong class="source-inline">SuperSideScroller_Player</strong> class is required to make the call to the <strong class="source-inline">IncrementNumberofCollectables()</strong> class function.</p>
<ol>
<li value="5">Let’s start with the<a id="_idIndexMarker1363"/> function definition for the <strong class="source-inline">AddCollectable()</strong> function. Add the following code:<p class="source-code">void ASuperSideScroller_Brick::AddCollectable(class </p><p class="source-code">  ASuperSideScroller_Player* Player)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Now, make the call to the <strong class="source-inline">IncrementNumberofCollectables()</strong> function by using the <strong class="source-inline">Player</strong> function input parameter:<p class="source-code">Player-&gt;IncrementNumberofCollectables(CollectableValue);</p></li>
<li>For the <strong class="source-inline">PlayHitSound()</strong> function, you will need to get a reference to the <strong class="source-inline">UWorld*</strong> object and verify whether the <strong class="source-inline">HitSound</strong> property is valid before making the function call to <strong class="source-inline">SpawnSoundAtLocation</strong> from the <strong class="source-inline">UGameplayStatics</strong> class. This is a process you have done many times, so this is the entire function code:<p class="source-code">void ASuperSideScroller_Brick::PlayHitSound()</p><p class="source-code">{</p><p class="source-code">  UWorld* World = GetWorld();</p><p class="source-code">  if (World &amp;&amp; HitSound)</p><p class="source-code">  {</p><p class="source-code">      UGameplayStatics::SpawnSoundAtLocation(World, </p><p class="source-code">      HitSound, </p><p class="source-code">        GetActorLocation());</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Just like the <strong class="source-inline">PlayHitSound()</strong> function, the <strong class="source-inline">PlayHitExplosion()</strong> function will work in<a id="_idIndexMarker1364"/> an almost similar way, and it’s a process you have done many times in this project. Add the following code to create the function definition:<p class="source-code">void ASuperSideScroller_Brick::PlayHitExplosion()</p><p class="source-code">{</p><p class="source-code">  UWorld* World = GetWorld();</p><p class="source-code">  if (World &amp;&amp; Explosion)</p><p class="source-code">  {</p><p class="source-code">      UGameplayStatics::SpawnEmitterAtLocation(World, </p><p class="source-code">      Explosion, </p><p class="source-code">        GetActorTransform());</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>With these functions defined, let’s update the <strong class="source-inline">OnHit()</strong> function so that if the player does hit the <strong class="source-inline">BrickCollision</strong> component, we can spawn <strong class="source-inline">HitSound</strong> and <strong class="source-inline">Explosion</strong>, and also add a coin collectible to the player’s collection.</p>
<ol>
<li value="9">First, in the <strong class="source-inline">OnHit()</strong> function, create a new variable called <strong class="source-inline">Player</strong> of the <strong class="source-inline">ASuperSideScroller_Player</strong> type that equals <strong class="source-inline">Cast</strong> of the <strong class="source-inline">OtherActor</strong> input parameter of the function, as shown here:<p class="source-code">ASuperSideScroller_Player* Player = </p><p class="source-code">  Cast&lt;ASuperSideScroller_Player&gt;(OtherActor);</p></li>
<li>Next, we only want to<a id="_idIndexMarker1365"/> continue with this function if <strong class="source-inline">Player</strong> is valid and <strong class="source-inline">bHasCollectable</strong> is <strong class="source-inline">True</strong>. Add the following <strong class="source-inline">if()</strong> statement:<p class="source-code">if (Player &amp;&amp; bHasCollectable)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>If the conditions in the <strong class="source-inline">if()</strong> statement are met, that is when we need to make the calls to the <strong class="source-inline">AddCollectable()</strong>, <strong class="source-inline">PlayHitSound()</strong>, and <strong class="source-inline">PlayHitExplosion()</strong> functions. Make sure to also pass the <strong class="source-inline">Player</strong> variable inside the <strong class="source-inline">AddCollectable()</strong> function:<p class="source-code">AddCollectable(Player);</p><p class="source-code">PlayHitSound();</p><p class="source-code">PlayHitExplosion();</p></li>
<li>Finally, add the function call to destroy the brick inside the <strong class="source-inline">if()</strong> statement:<p class="source-code">Destroy();</p></li>
<li>With the <strong class="source-inline">OnHit()</strong> function defined as we need, recompile the C++ code but do not return to the UE5 editor just yet.</li>
<li>For the VFX and SFX of the brick’s explosion, we will need to migrate assets from two separate projects available to us from <strong class="bold">Epic Games Launcher</strong>: the <strong class="bold">Blueprints</strong> project and the <strong class="bold">Content Examples</strong> project.</li>
<li>Using your knowledge from previous exercises, download and install these projects using Unreal Engine version 4.24. Both projects can be found in the <strong class="bold">Samples</strong> tab, in the <strong class="bold">UE Legacy Samples</strong> and <strong class="bold">UE Feature Samples</strong> categories, respectively.</li>
<li>Once installed, open<a id="_idIndexMarker1366"/> the <strong class="bold">Content Examples</strong> project and find the <strong class="source-inline">P_Pixel_Explosion</strong> asset in the <strong class="bold">Content Drawer</strong> area.</li>
<li><em class="italic">Right-click</em> this asset and select <strong class="bold">Asset Actions</strong>, then <strong class="bold">Migrate</strong>. Migrate this asset and all its referenced assets into your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Once this asset has been successfully migrated, close the <strong class="bold">Content Examples</strong> project and open the <strong class="source-inline">Blueprints</strong> project.</li>
<li>From the <strong class="bold">Content Drawer</strong> area of the <strong class="source-inline">Blueprints</strong> project, find the <strong class="source-inline">Blueprints_TextPop01</strong> asset.</li>
<li><em class="italic">Right-click</em> this asset, then select <strong class="bold">Asset Actions</strong>, and then <strong class="bold">Migrate</strong>. Migrate this asset and all its referenced assets into your <strong class="bold">SuperSideScroller</strong> project.</li>
</ol>
<p>With these assets migrated to your project, return to the Unreal Engine 5 editor of your <strong class="bold">SuperSideScroller </strong>project.</p>
<ol>
<li value="21">Navigate to the <strong class="source-inline">Brick</strong> folder in the <strong class="bold">Content Drawer</strong> window and <em class="italic">double-left-click</em> the <strong class="source-inline">BP_Brick</strong> asset to open it.</li>
<li>In the <strong class="bold">Details</strong> panel of the actor, find the <strong class="bold">Super Side Scroller Brick</strong> section and set the <strong class="source-inline">HitSound</strong> parameter to the <strong class="source-inline">Blueprints_TextPop01</strong> soundwave you imported.</li>
<li>Next, add the <strong class="source-inline">P_Pixel_Explosion</strong> particle you imported into the <strong class="source-inline">Explosion</strong> parameter.</li>
<li>Recompile the <strong class="source-inline">BP_Brick</strong> Blueprint and add two of these actors to your level.</li>
<li>Set one of the <a id="_idIndexMarker1367"/>bricks so that the <strong class="source-inline">bHasCollectable</strong> parameter is <strong class="source-inline">True</strong>; set the other to <strong class="source-inline">False</strong>. Please refer to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer498">
<img alt="Figure 15.30 – This Brick actor is set to have a collectible spawn " height="125" src="image/Figure_15.30_B18531.jpg" width="769"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.30 – This Brick actor is set to have a collectible spawn</p>
<ol>
<li value="26">Using <strong class="source-inline">PIE</strong>, observe the differences in behavior between the two brick actors when you attempt to hit the bottom of the brick with the character’s head when jumping, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer499">
<img alt="Figure 15.31 – Now, the player can hit the brick and it will be destroyed " height="589" src="image/Figure_15.31_B18531.jpg" width="845"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.31 – Now, the player can hit the brick and it will be destroyed</p>
<p>When <strong class="source-inline">bHasCollectable</strong> is <strong class="source-inline">True</strong>, <strong class="source-inline">SuperSideScroller_Brick</strong> will play our <strong class="source-inline">HitSound</strong>, spawn the <strong class="source-inline">Explosion</strong> particle system, add a coin collectible to the player, and be destroyed.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08</a>.</p>
<p>With this exercise complete, you have now finished developing the gameplay mechanics for the <strong class="bold">SuperSideScroller</strong> game project. Now, the <strong class="source-inline">SuperSideScroller_Brick</strong> class can be used for both the platforming gameplay and the coin-collecting mechanic that we want for the game. </p>
<p>Now that the brick can be <a id="_idIndexMarker1368"/>destroyed and hidden coins can be collected, all the gameplay elements that we set out to create for the <strong class="bold">SuperSideScroller</strong> game project are complete. </p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor343"/>Summary</h1>
<p>In this chapter, you put your knowledge to the test to create the remaining gameplay mechanics for the <strong class="bold">SuperSideScroller</strong> game project. Using a combination of C++ and Blueprints, you developed the potion power-up and coins for the player to collect in the level. Also, by using your knowledge from <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, you added unique audio and visual assets to these collectible items to add a nice layer of polish to the game.</p>
<p>You learned and took advantage of the UMG UI system within UE5 to create a simple, yet effective, UI feedback system to display the number of coins that the player has collected. By using the binding feature of the <strong class="bold">Text widget</strong>, you were able to keep the UI updated with the number of coins the player has currently collected. Lastly, you created a <strong class="source-inline">Brick</strong> class using the knowledge you learned from the <strong class="bold">SuperSideScroller</strong> project to hide coins for the player so that they can collect and find them.</p>
<p>The <strong class="bold">SuperSideScroller</strong> project has been an extensive project that expanded upon many of the tools and practices available within UE5. In <a href="B18531_10.xhtml#_idTextAnchor199"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating the SuperSideScroller Game</em>, we imported custom skeleton and animation assets to use in developing the Animation Blueprint of the player character. In <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>, we used Blend Spaces to allow the player character to blend between idle, walking, and sprinting animations, while also using an <strong class="source-inline">Animation State Machine</strong> to handle the jumping and movement states of the player character. We then learned how to control the player’s movement and jump height using the character movement component.</p>
<p>In <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, we learned more about animation blending inside <strong class="source-inline">Animation Blueprints</strong> by using the <strong class="source-inline">Layered Blend per Bone</strong> function and <strong class="source-inline">Saved Cached Poses</strong>. By adding a new <strong class="source-inline">AnimSlot</strong> for the upper body animation of the player character’s throw animation, we were able to have both the player movement animations and the throw animation blend together smoothly. In <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, we used the robust systems of behavior trees and Blackboards to develop AI behavior for the enemy. We created a <strong class="source-inline">Task</strong> that will allow the enemy AI to move in-between points from a custom Blueprint that we also developed to determine patrol points for the AI. </p>
<p>In <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, we learned how to create an <strong class="source-inline">Anim Notify</strong> and how to implement this notify in our <strong class="source-inline">Animation Montage</strong> for the player character’s throw to spawn the player projectile. Then, we learned about how to create projectiles and how to use <strong class="bold">Projectile Movement Component</strong> to have the player projectile move in the game world.</p>
<p>Finally, in this chapter, we learned how to create UI using the <strong class="source-inline">UMG</strong> toolset for the coin collectible, as well as how to manipulate our <strong class="bold">Character Movement Component</strong> to create the potion power-up for the player. Lastly, you created a <strong class="source-inline">Brick</strong> class that can be used to hide coins for the player to find and collect.</p>
<p>In the next chapter, you will learn about the basics of multiplayer, server-client architectures, and the gameplay framework classes used for multiplayer inside UE5. You will use this knowledge to expand upon the multiplayer FPS project in UE5.</p>
<p>This summarization only really scratches the surface of what we learned and accomplished in the <strong class="bold">SuperSideScroller</strong> project. Before you move on, here are some challenges for you to test your knowledge and expand upon the project:</p>
<h1 id="_idParaDest-316"><a id="_idTextAnchor344"/>Additional Challenges</h1>
<p>Test your knowledge from this section by adding the following functionality to the SuperSideScroller project.</p>
<ol>
<li value="1">Add a new power-up that lowers the gravity that’s applied to the player character. Import a custom mesh and audio assets to give this power-up a unique look compared to the potion power-up you made.</li>
<li>When the player character collects 10 coins, grant the player a power-up.</li>
<li>Implement the functionality that allows the player to be destroyed when it’s overlapping with the AI. Include being able to respawn the player when this happens.</li>
<li>Add another power-up that gives immunity to the player so that they cannot be destroyed when they’re overlapping with an enemy. (In fact, when overlapping an enemy with this power-up, it could destroy the enemy.)</li>
<li>Using all the gameplay elements you’ve developed for the <strong class="bold">SuperSideScroller</strong> project, create a new level that takes advantage of these elements to make an interesting platforming arena to play in. </li>
<li>Add multiple enemies with interesting patrol points to challenge the player when they’re navigating the area.</li>
<li>Place power-ups in hard-to-reach areas so that players need to improve their platforming skills to obtain them.</li>
<li>Create dangerous pitfalls for the player to navigate across and add functionality that will destroy the player if they fall off the map.</li>
</ol>
</div>
<div>
<div id="_idContainer501">
</div>
</div>
</div></body></html>