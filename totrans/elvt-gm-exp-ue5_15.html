<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-294"><a id="_idTextAnchor322"/>15</h1>
<h1 id="_idParaDest-295"><a id="_idTextAnchor323"/>Exploring Collectibles, Power-Ups, and Pickups</h1>
<p>In the previous chapter, you created the player projectile and used <code>Anim Notifies</code> to spawn the player projectile during the <code>Throw</code> animation. The player projectile will serve as the player’s main offensive gameplay mechanic to use against the enemies throughout the level. Due to the combination of default <code>Anim Notifies</code> provided by UE5 and your own custom <code>Anim_ProjectileNotify</code> class, the player projectile mechanic looks and feels great. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to create and integrate UI elements using the <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>) UI Designer system within UE5.</li>
<li>Use the lessons learned from this project to create an interesting power-up that will increase the players’ movement speed and jump height.</li>
<li>How to use inheritance in C++ to derive multiple classes from one parent base class for both collectibles and power-ups. You will also be adding visual and audio elements to both the collectible and the power-up so that they are more polished.</li>
<li>How to use <code>URotatingMovementComponent</code> to add rotation to actors in a very optimized and straightforward way.</li>
</ul>
<p>By the end of this chapter, you will have the finished <strong class="bold">SuperSideScroller</strong> game project, complete with coin collectibles and a corresponding UI to track the number of coins collected, a new potion power-up that increases the player’s movement speed and jump height, as well as a base class in which to derive potentially new power-ups and collectibles for the game.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor324"/>Technical requirements</h1>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
<li>Unreal Engine 4.27 installed</li>
</ul>
<p>Let’s begin this chapter by learning more about <code>URotatingMovementComponent</code>, which we will use for our collectibles.</p>
<p>The project for this chapter can be found in the Chapter15 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor325"/>Understanding URotatingMovementComponent</h1>
<p><code>URotatingMovementComponent</code> is one of a few movement components that exists within UE5. You are <a id="_idIndexMarker1263"/>already familiar with <code>CharacterMovementComponent</code> and <code>ProjectileMovementComponent</code> from the <code>RotatingMovementComponent</code> is just that – another movement component. As a refresher, movement components allow different types of movements to occur on actors, or characters, that they belong to.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>CharacterMovementComponent</code>, which allows you to control the movement parameters of your character, such as their movement speed and jump height, was covered in <a href="B18531_10.xhtml#_idTextAnchor199"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating the SuperSideScroller Game</em>, when you created the <code>ProjectileMovementComponent</code>, which allows you to add projectile-based movement functionality to actors, such as speed and gravity, was covered in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, when you developed the player projectile.</p>
<p><code>RotatingMovementComponent</code> is a very simple movement component compared to <code>CharacterMovementComponent</code> and that’s because it only involves rotating the actor that <code>RotatingMovementComponent</code> is a part of; nothing more. <code>RotatingMovementComponent</code> continuously rotates a component based on the defined <code>Rotation Rate</code>, pivot translation, and the option to use rotation in local space or world space. Additionally, <code>RotatingMovementComponent</code> is much more efficient compared to other methods <a id="_idIndexMarker1264"/>of rotating an actor, such as through <code>Event Tick</code> or <code>Timelines</code> within Blueprints.</p>
<p class="callout-heading">Note</p>
<p class="callout">More information about <a id="_idIndexMarker1265"/>movement components can be found here: <a href="https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent">https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent</a>.</p>
<p>We will be <a id="_idIndexMarker1266"/>using <code>RotatingMovementComponent</code> to allow the coin collectible and potion power-up to rotate in place along the <em class="italic">Z</em>-axis. This rotation will draw the player’s attention to the collectible and give them a visual cue that the collectible is important.</p>
<p>Now that you have a better understanding of <code>RotatingMovementComponent</code>, let’s move on and create the <code>PickableActor_Base</code> class, which is what the coin collectible and the potion power-up will derive from.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor326"/>Exercise 15.01 – creating the PickableActor_Base class and adding URotatingMovementComponent</h2>
<p>In this exercise, you will<a id="_idIndexMarker1267"/> be creating the <code>PickableActor_Base</code> actor class, which will be used as the base <a id="_idIndexMarker1268"/>class that both the collectible coin and potion power-up will derive from. You will also create a<a id="_idIndexMarker1269"/> Blueprint class from this C++ base class to preview how <code>URotatingMovementComponent</code> works. Follow these steps to complete this exercise:</p>
<p class="callout-heading">Note</p>
<p class="callout">You have performed many of the following steps numerous times throughout the <strong class="bold">SuperSideScroller</strong> game project, so there will be limited screenshots to help guide you. Only when introducing a new concept will there be an accompanying screenshot.</p>
<ol>
<li>Inside the UE5 editor, click the <strong class="bold">Tools</strong> option at the top of the editor and then choose <strong class="bold">New C++ Class</strong>. </li>
<li>From the <strong class="bold">Choose Parent Class</strong> window, select the <strong class="bold">Actor</strong> option, and then click the <strong class="bold">Next</strong> button at the bottom of this window.</li>
<li>Name this class <code>PickableActor_Base</code> and leave the default <code>Path</code> directory as-is. Then, select the <strong class="bold">Create Class</strong> button at the bottom of this window.</li>
<li>After selecting <a id="_idIndexMarker1270"/>the <code>PickableActor_Base</code> class.</li>
<li>By default, <code>Actor</code> classes provide you with the <code>virtual void Tick(float DeltaTime) override;</code> function declaration inside the header file. For the <code>PickableActor_Base</code> class, we will not require the <code>Tick</code> function, so remove this function declaration from the <code>PickableActor_Base.h</code> header file.</li>
<li>Next, you will need to remove the function from the <code>PickableActor_Base.cpp</code> file; otherwise, you will receive a compile error. In this source file, find and remove the following code:<pre>void PickableActor_Base::Tick(float DeltaTime)
{
  Super::Tick(DeltaTime);
}</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">In many cases, the use of the <code>Tick()</code> function for movement updates can lead to performance issues as the <code>Tick()</code> function is called every single frame. Instead, try using <code>Gameplay Timer</code> functions to perform certain updates at specified intervals, rather than on each frame. You can learn more about <code>Gameplay Timers</code> here: <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/</a>.</p>
<ol>
<li value="7">Now, it is time to add the components that the <code>PickableActor_Base</code> class requires. Let’s start with <code>USphereComponent</code>, which you will use to detect overlap collision <a id="_idIndexMarker1272"/>with the player. Add the following code underneath the <code>Protected</code> access<a id="_idIndexMarker1273"/> modifier inside the <code>PickableActor_Base.h</code> header file:<pre>UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)
class USphereComponent* CollisionComp;</pre></li>
</ol>
<p>The declaration of <code>USphereComponent</code> should be very familiar to you by now; we’ve done this in previous chapters, such as <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, when we created the <code>PlayerProjectile</code> class.</p>
<ol>
<li value="8">Next, add the following code underneath the declaration of <code>USphereComponent</code> to create a new <code>UStaticMeshComponent</code>. This will be used to visually represent either the coin collectible or the potion power-up:<pre>UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)
class UStaticMeshComponent* MeshComp;</pre></li>
<li>Finally, add the following code underneath the declaration of <code>UStaticMeshComponent</code> to create a new <code>URotatingMovementComponent</code>. This will be used to give the collectible coin and potion power-up simple rotational movement:<pre>UPROPERTY(VisibleDefaultsOnly, Category = PickableItem)
class URotatingMovementComponent* RotationComp;</pre></li>
<li>Now that you have the components declared inside the <code>PickableActor_Base.h</code> header file, navigate to the <code>PickableActor_Base.cpp</code> source file so that you can add the required <code>#include</code> statements for these added components. Add the following lines after <code>#include “PickableActor_Base.h”</code>, at the top of the source file:<pre>#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"
#include "GameFramework/RotatingMovementComponent.h"</pre></li>
<li>Now that you have<a id="_idIndexMarker1274"/> the necessary <code>#include</code> files for the components, you can add the <a id="_idIndexMarker1275"/>necessary code to initialize these components within the <code>APickableActor_Base::APickableActor_Base()</code> constructor function:<pre>APickableActor_Base::APickableActor_Base()
{
}</pre></li>
<li>First, initialize the <code>USphereComponent</code> component variable, <code>CollisionComp</code>, by adding the following code to <code>APickableActor_Base::APickableActor_Base()</code>:<pre>CollisionComp = CreateDefaultSubobject
  &lt;USphereComponent&gt;(TEXT("SphereComp"));</pre></li>
<li>Next, initialize <code>USphereComponent</code> with a default sphere radius of <code>30.0f</code> by adding the following code underneath the code provided in the previous step:<pre>CollisionComp-&gt;InitSphereRadius(30.0f);</pre></li>
<li>Since the player character needs to overlap with this component, you will need to add the following code so that, by default, <code>USphereComponent</code> has the collision settings for <code>Overlap All Dynamic</code>:<pre>CollisionComp-&gt;BodyInstance.SetCollisionProfileName("OverlapAllDynamic");</pre></li>
<li>Lastly, <code>CollisionComp USphereComponent</code> should be the root component of this actor. Add the following code to assign this:<pre>RootComponent = CollisionComp;</pre></li>
<li>Now that <code>CollisionComp USphereComponent</code> has been initialized, let’s do the same<a id="_idIndexMarker1276"/> for <code>MeshComp UStaticMeshComponent</code>. Add the following code. After, we’ll discuss what the code is doing for us:<pre>MeshComp = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("MeshComp"));
MeshComp-&gt;AttachToComponent(RootComponent, 
  FAttachmentTransformRules::KeepWorldTransform);
MeshComp-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);</pre></li>
</ol>
<p>The first line initializes <code>MeshComp UStaticMeshComponent</code> using the <code>CreateDefaultSubobject()</code> template function. Next, you are attaching <code>MeshComp</code> to the root<a id="_idIndexMarker1277"/> component, which you made for <code>CollisionComp</code>, using the <code>AttachTo()</code> function. Lastly, <code>MeshComp UStaticMeshComponent</code> should not have any collision by default, so you are using the <code>SetCollisionEnabled()</code> function and passing in the <code>ECollisionEnable::NoCollision</code> enumerator value.</p>
<ol>
<li value="17">Lastly, we can initialize <code>URotatingMovementComponent RotationComp</code> by adding the following code:<pre>RotationComp = 
  CreateDefaultSubobject&lt;URotatingMovementComponent&gt;(
  TEXT("RotationComp"));</pre></li>
<li>With all the components initialized, compile the C++ code and return to the UE5 editor. After compilation succeeds, you can start creating a Blueprint class for <code>PickableActor_Base</code>.</li>
<li>In the <code>PickableItems</code> by <em class="italic">right-clicking</em> on the <code>Content</code> folder and selecting the <strong class="bold">New Folder</strong> option.</li>
<li>In the <code>PickableItems</code> folder, <em class="italic">right-click</em> and select <code>PickableActor_Base</code> class and <em class="italic">left-click</em> <strong class="bold">Select</strong> to create a new Blueprint. </li>
<li>Name this Blueprint <code>BP_PickableActor_Base</code> and <em class="italic">double-left-click</em> the Blueprint to open it.</li>
<li>In the <code>Shape_Cone</code> static mesh to the <code>Static Mesh</code> parameter in the <strong class="bold">Details</strong> panel. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent " height="485" src="img/Figure_15.01_B18531.jpg" width="603"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent</p>
<ol>
<li value="23">Next, select <strong class="bold">RotationComp URotatingMovementComponent</strong> and find the <strong class="bold">Rotation Rate</strong> parameter in the <strong class="bold">Rotating Component</strong> category of the <strong class="bold">Details</strong> panel.</li>
<li>Set<strong class="bold"> Rotation Rate</strong> to the following values:<pre>(X=100.000000,Y=100.000000,Z=100.000000)</pre></li>
</ol>
<p>These values determine<a id="_idIndexMarker1280"/> how fast the actor will rotate along each axis per second. This means<a id="_idIndexMarker1281"/> that the cone-shaped actor will rotate along each axis at 100 degrees per second on each axis.</p>
<ol>
<li value="25">Compile the <code>PickableActor_Base</code> Blueprint and add this actor to your level.</li>
<li>Now, if you use <code>PIE</code> and look at the <code>PickableActor_Base</code> actor in the level, you will see that it is rotating. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.2 – The BP_PickableActor_Base rotating in place " height="382" src="img/Figure_15.02_B18531.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – The BP_PickableActor_Base rotating in place</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01</a>.</p>
<p>With this exercise <a id="_idIndexMarker1282"/>complete, you’ve created <a id="_idIndexMarker1283"/>the base components required for the <code>PickableActor_Base</code> class and learned how to implement and use <code>URotatingMovementComponent</code>. With the <code>PickableActor_Base</code> class ready, and with <code>URotatingMovementComponent</code> implemented on the Blueprint actor, we can complete the class by adding overlap detection functionality, destroying the collectible actor, and spawning audio effects when the actor is picked up by the player. In the following activity, you will add the remaining functionality required for the <code>PickableActor_Base</code> class.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor327"/>Activity 15.01 – player overlap detection and spawning effects in PickableActor_Base</h2>
<p>Now that the <code>PickableActor_Base</code> class has all the<a id="_idIndexMarker1284"/> required components and has its constructor initializing the components, it is time to add<a id="_idIndexMarker1285"/> the remaining aspects of its functionality. These will be inherited by the coin collectible and potion power-up later in this chapter. This additional functionality includes player overlap detection, destroying the collectible actor, and spawning an audio effect to give feedback to the player that it has been successfully picked up. Perform the following steps to add functionality that allows a <code>USoundBase</code> class object to be played<a id="_idIndexMarker1286"/> when the collectible overlaps with the player:</p>
<ol>
<li value="1">Create a new function in the <code>PickableActor_Base</code> class that takes in a reference to the player as an input parameter. Call this function <code>PlayerPickedUp</code>.</li>
<li>Create a new <code>UFUNCTION</code> called <code>BeginOverlap()</code>. Make sure to include all the required input<a id="_idIndexMarker1287"/> parameters for this function before moving on. Refer to <a href="B18531_06.xhtml#_idTextAnchor134"><em class="italic">Chapter 6</em></a>, <em class="italic">Setting Up Collision Objects</em>, where you used this function inside the <code>VictoryBox</code> class.</li>
<li>Add a new <code>UPROPERTY()</code> for the <code>USoundBase</code> class and name it <code>PickupSound</code>. </li>
<li>In the <code>PickableActor_Base.cpp</code> source file, create the definitions for both the <code>BeginOverlap()</code> and <code>PlayerPickedUp()</code> functions.</li>
<li>Now, add the required <code>#include</code> files for the <code>SuperSideScroller_Player</code> class and the <code>GameplayStatics</code> class at the top of the source file.</li>
<li>In the <code>BeginOverlap()</code> function, create a reference to the player using the <code>OtherActor</code> input parameter of the function.</li>
<li>Next, if the player reference is valid, make a call to the <code>PlayerPickedUp()</code> function, passing in the player variable.</li>
<li>In the <code>PlayerPickedUp()</code> function, create a variable for the <code>UWorld*</code> object that’s returned by the <code>GetWorld()</code> function.</li>
<li>Use the <code>UGameplayStatics</code> library to spawn <code>PickUpSound</code> at the location of the <code>PickableActor_Base</code> actor.</li>
<li>Then, call the <code>Destroy()</code> function so that the actor gets destroyed and removed from the world.</li>
<li>Finally, in the <code>APickableActor_Base::APickableActor_Base()</code> constructor, bind the <code>OnComponentBeginOverlap</code> event of <code>CollisionComp</code> to the <code>BeginOverlap()</code> function. </li>
<li>Download and install the <code>Unreal Match 3</code> project from the <code>Match_Combo</code> soundwave asset from this project into your <strong class="bold">SuperSideScroller</strong> project using the knowledge you gained in <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>.</li>
<li>Apply this sound<a id="_idIndexMarker1288"/> to the <code>PickupSound</code> parameter of the <code>BP_PickableActor_Base</code> Blueprint.</li>
<li>Compile the Blueprint, and if one<a id="_idIndexMarker1289"/> does not exist in your level, add the <code>BP_PickableActor_Base</code> actor to your level now.</li>
<li>In <code>PIE</code>, have your character overlap with the <code>BP_PickableActor_Base</code> actor. </li>
</ol>
<p>Expected output:</p>
<div><div><img alt="Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player " height="305" src="img/Figure_15.03_B18531.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you have proven your knowledge regarding how to add the <code>OnBeginOverlap()</code> functionality to your actor classes and how to use this function to perform logic for your actor. In the case of <code>PickableActor_Base</code>, we added logic that will spawn a custom sound and destroy the actor. </p>
<p>Now that the <code>PickableActor_Base</code> class is set and ready, it is time to develop the collectible coin and power-up potion classes that will derive from it. The coin collectible class will inherit from the <code>PickableActor_Base</code> class you have just created. It will override key<a id="_idIndexMarker1290"/> functionality, such as the <code>PlayerPickedUp()</code> function, so that we can implement unique logic for the collectible when<a id="_idIndexMarker1291"/> it’s picked up by the player. In addition to overriding functionality from the inherited parent <code>PickableActor_Base</code> class, the coin collectible class will have its own unique set of properties, such as its current coin value and unique pickup sound. We’ll create the coin collectible class together in the next exercise. </p>
<p>Exercise 15.02 – creating the PickableActor_Collectable class</p>
<p>In this exercise, you will be creating the <code>PickableActor_Collectable</code> class, which will be derived from the <code>PickableActor_Base</code> class you created in <em class="italic">Exercise 15.01 – creating the PickableActor_Base class and adding URotatingMovement</em>, and finished in <em class="italic">Activity 15.01 – player overlap detection and spawning effects in PickableActor_Base</em>. This class<a id="_idIndexMarker1292"/> will be used as the main collectible coin that the player can collect within the level. Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Inside the UE5 editor, click the <strong class="bold">Tools</strong> option at the top of the editor and choose <strong class="bold">New C++ Class</strong>.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> window, select the <strong class="bold">PickableActor_Base</strong> option, and then click the <strong class="bold">Next</strong> button at the bottom of this window.</li>
<li>Name this class <code>PickableActor_Collectable</code> and leave the default <code>Path</code> directory as-is. Then, select the <strong class="bold">Create Class</strong> button at the bottom of this window.</li>
<li>After selecting the <code>PickableActor_Collectable</code> class.</li>
<li>By default, the <code>PickableActor_Collectable.h</code> header file has no declared functions or <a id="_idIndexMarker1293"/>variables within its class declaration. You will need to add the override for the <code>BeginPlay()</code> function underneath a new <code>Protected Access Modifier</code>. Add the following code:<pre>protected:
  virtual void BeginPlay() override;</pre></li>
</ol>
<p>The reason we are overriding the <code>BeginPlay()</code> function is that <code>URotatingMovementComponent</code> requires the actor to initialize and use <code>BeginPlay()</code> to correctly rotate the actor. Therefore, we need to create the override declaration of this function and create a basic definition inside the source file. First, however, we need to override another important function from the <code>PickableActor_Base</code> parent class.</p>
<ol>
<li value="6">Override the <code>PlayerPickedUp()</code> function from the <code>PickableActor_Base</code> parent class by adding the following code under <code>Protected Access Modifier</code>:<pre>virtual void PlayerPickedUp(class ASuperSideScroller_Player* Player)override; 
  </pre></li>
</ol>
<p>With this, we are saying that we are going to use, and override, the functionality of the <code>PlayerPickedUp()</code> function.</p>
<ol>
<li value="7">Lastly, create a new integer called <code>UPROPERTY()</code> that will hold the value that the coin collectible will have; in this case, it will have a value of <code>1</code>. Add the following code to do this:<pre>public:
  UPROPERTY(EditAnywhere, Category = Collectable)
  int32 CollectableValue = 1;</pre></li>
</ol>
<p>Here, we are creating the integer variable that will be accessible in Blueprints and has a default value of <code>1</code>. If you so choose, with the <code>EditAnywhere UPROPERTY()</code> keyword, you can change how much a coin collectible is worth.</p>
<ol>
<li value="8">Now, we can move<a id="_idIndexMarker1294"/> on to the <code>PickableActor_Collectable.cpp</code> source file and create the definition of the overridden <code>PlayerPickedUp()</code> function. Add the following code to the source file:<pre>void APickableActor_Collectable::PlayerPickedUp(class 
  ASuperSideScroller_Player* Player)
{
}</pre></li>
<li>For now, we need to make a call to the <code>PlayerPickedUp()</code> parent function by using the <code>Super</code> keyword. Add the following code to the <code>PlayerPicked()</code> function:<pre>Super::PlayerPickedUp(Player);</pre></li>
</ol>
<p>The call to the parent function, which uses <code>Super::PlayerPickedUp(Player)</code>, will ensure that the functionality you created in the <code>PickableActor_Base</code> class is called. As you may recall, the <code>PlayerPickedUp()</code> function in the parent class makes a call to spawn the <code>PickupSound</code> sound object and destroys the actor.</p>
<ol>
<li value="10">Next, create the definition of the <code>BeginPlay()</code> function inside the source file by adding the following code:<pre>void APickableActor_Collectable::BeginPlay()
{
}</pre></li>
<li>Finally, in C++, once again make the call to the <code>BeginPlay()</code> parent function using the <code>Super</code> keyword. Add<a id="_idIndexMarker1295"/> the following code to the <code>BeginPlay()</code> function inside the <code>PickableActor_Collectable</code> class:<pre>Super::BeginPlay();</pre></li>
<li>Compile the C++ code and return to the editor.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise at the following link: <a href="https://packt.live/35fRN3E">https://packt.live/35fRN3E</a>.</p>
<p>Now that you’ve successfully compiled the <code>PickableActor_Collectable</code> class, you have created the framework needed for the coin collectible. In the following activity, you will create a Blueprint from this class and finalize the coin collectible actor.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor328"/>Activity 15.02 – finalizing the PickableActor_Collectable actor</h2>
<p>Now that the <code>PickableActor_Collectable</code> class has all of the necessary inherited functionality<a id="_idIndexMarker1296"/> and unique properties it needs, it is time to create the Blueprint from this class and add a <code>Static Mesh</code>, update its <code>URotatingMovementComponent</code>, and apply a sound to the <code>PickUpSound</code> property. Perform the following steps to finalize the <code>PickableActor_Collectable</code> actor:</p>
<ol>
<li value="1">From <strong class="bold">Epic Games Launcher</strong>, find the <strong class="bold">Content Examples</strong> project in the <strong class="bold">Samples</strong> tab, underneath the <strong class="bold">Engine Feature Samples</strong> category.</li>
<li>Create and install a new project from the <strong class="bold">Content Examples</strong> project.</li>
<li>Migrate the <code>SM_Pickup_Coin</code> asset and all its referenced assets from the <strong class="bold">Content Examples</strong> project to your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Create a new folder within the <code>Content/PickableItems</code> directory in the <code>Collectable</code>.</li>
<li>In this new <code>Collectable</code> folder, create a new Blueprint from the <code>PickableActor_Collectable</code> class that you created in <em class="italic">Exercise 15.02 – creating the PickableActor_Collectable class</em>. Name this new Blueprint <code>BP_Collectable</code>.</li>
<li>In this Blueprint, set the <code>Static Mesh</code> parameter of the <code>MeshComp</code> component <a id="_idIndexMarker1297"/>to the <code>SM_Pickup_Coin</code> mesh you imported earlier in this activity.</li>
<li>Next, add the <code>Match_Combo</code> sound asset to the <code>PickupSound</code> parameter of the collectible.</li>
<li>Lastly, update the <code>RotationComp</code> component so that the actor rotates along the <em class="italic">Z</em>-axis at 90 degrees per second.</li>
<li>Compile the Blueprint, place <code>BP_Collectable</code> in your level, and use <code>PIE</code>. </li>
<li>Overlap the player character with the <code>BP_Collectable</code> actor and observe the results.</li>
</ol>
<p>Expected output:</p>
<div><div><img alt="Figure 15.4 – The coin collectible rotates and can be overlapped by the player " height="347" src="img/Figure_15.04_B18531.jpg" width="504"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The coin collectible rotates and can be overlapped by the player</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity<a id="_idIndexMarker1298"/> complete, you have proven that you know how to migrate assets into your UE5 project and how to use and update <code>URotatingMovementComponent</code> to fit the needs of the coin collectible. Now that the coin collectible actor is complete, it is time to add functionality to the player so that the player can keep track of how many coins they have collected. </p>
<p>First, we will create the logic that will count the coins using <code>UE_LOG</code>. Later, we will implement the coin counter<a id="_idIndexMarker1299"/> using the <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>) UI Designer system on the game’s UI.</p>
<h1 id="_idParaDest-301"><a id="_idTextAnchor329"/>Logging variables using UE_LOG</h1>
<p>In <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with Blend Space 1D, Key Bindings, and State Machines</em>, we used and learned about the <code>UE_LOG</code> function to log when the player should throw the projectile. Then, we <a id="_idIndexMarker1300"/>used the <code>UE_LOG</code> function in <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, to log when the player projectile hit an object. <code>UE_LOG</code> is a<a id="_idIndexMarker1301"/> robust logging tool we can use to output important information from our C++ functions into the <code>FStrings</code> to display general text in the <strong class="bold">Output Log</strong> window to know that our functions were being called. Now, it is time to learn how to log variables to debug how many coins the player has collected.</p>
<p class="callout-heading">Note</p>
<p class="callout">There is another useful debug function available in C++ with UE5 known as <code>AddOnScreenDebugMessage</code>. You can learn more about this function here: <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml</a>.</p>
<p>When creating the <code>FString</code> syntax <a id="_idIndexMarker1302"/>used by the <code>TEXT()</code> macro, we can add format specifiers to log <a id="_idIndexMarker1303"/>different types of variables. We will only be discussing how to add the format specifier for integer variables.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on how to specify other variable types by reading the following documentation: <a href="https://www.ue4community.wiki/Logging#Logging_an_FString">https://www.ue4community.wiki/Logging#Logging_an_FString</a>.</p>
<p>This is what <code>UE_LOG()</code> looks like when passing in <code>FString “Example Text”</code>: </p>
<pre>UE_LOG(LogTemp, Warning, TEXT("Example Text"));</pre>
<p>Here, you have <code>Log Category</code>, <code>Log Verbose Level</code>, and the actual <code>FString</code>,<code> “Example Text”</code>, to display in the log. To log an integer variable, you need to add <code>%d</code> to your <code>FString</code> within the <code>TEXT()</code> macro, followed by the integer variable name outside the <code>TEXT()</code> macro, separated by a comma. Here is an example:</p>
<pre>UE_LOG(LogTemp, Warning, TEXT("My integer variable %d), MyInteger);</pre>
<p>The format specifier is identified by the <code>%</code> symbol, and each variable type has a designated letter that corresponds with it. In the case of integers, the letter <code>d</code> is used, representing a digit. You will be using this method of logging integer variables to log the number of coin collectibles the player has in the next exercise.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor330"/>Exercise 15.03 – tracking the number of coins for the player</h2>
<p>In this exercise, you <a id="_idIndexMarker1304"/>will be creating the necessary properties and functions that will allow you to track how many coins the player collects throughout the level. You will use this tracking to show the player using UMG later in this chapter. Follow these steps to complete this exercise:</p>
<ol>
<li value="1">In Visual Studio, find and open the <code>SuperSideScroller_Player.h</code> header file.</li>
<li>Under <code>Private Access Modifier</code>, create a new <code>int</code> variable called <code>NumberofCollectables</code>, as shown here:<pre>int32 NumberofCollectables;</pre></li>
</ol>
<p>This will be a private property that will keep track of the current number of coins the player has collected. You will be creating a public function that will return this integer value. We do this for safety reasons to ensure that no other classes can modify this value.</p>
<ol>
<li value="3">Next, under the existing <code>public</code> access modifier, create a new <code>UFUNCTION()</code> using the <code>BlueprintPure</code> keyword called <code>GetCurrentNumberOfCollectables()</code>. This function will return an <code>int</code>. The following code adds this as an inline function:<pre>UFUNCTION(BlueprintPure)
int32 GetCurrentNumberofCollectables() { return NumberofCollectables; };</pre></li>
</ol>
<p>Here, we are using <code>UFUNCTION()</code> and the <code>BlueprintPure</code> keyword to expose this function to Blueprints so that we can use it later in UMG.</p>
<ol>
<li value="4">Declare a new <code>void</code> function, under the <code>public</code> access modifier, called <code>IncrementNumberofCollectables()</code> that takes in a single integer parameter called <code>Value</code>:<pre>void IncrementNumberofCollectables(int32  Value);</pre></li>
</ol>
<p>This is the main function you will use to keep track of how many coins the player has collected. We will also add some safety measures to ensure this value is never negative.</p>
<ol>
<li value="5">With the <code>IncrementNumberofCollectables()</code> function declared, let’s create the definition of this function inside the <code>SuperSideScroller_Player.cpp</code> source file.</li>
<li>Write the following code to<a id="_idIndexMarker1305"/> create the definition of the <code>IncrementNumberofCollectables</code> function:<pre>void ASuperSideScroller_Player::IncrementNumberofCollectables(int32 Value)
{
}</pre></li>
<li>The main case to handle here is if the integer value that’s passed into this function is less than or equal to <code>0</code>. In this case, we do not want to bother incrementing the <code>NumberofCollectables</code> variable. Add the following code to the <code>IncrementNumberofCollectables()</code> function:<pre>if(Value == 0)
{
  return;
}</pre></li>
</ol>
<p>This <code>if()</code> statement says that if the <code>value</code> input parameter is less than or equal to <code>0</code>, the function will end. With the <code>IncrementNumberofCollectables()</code> function returning <code>void</code>, it is perfectly okay to use the <code>return</code> keyword in this way.</p>
<p>We’re adding this check of ensuring the <code>value</code> parameter that’s passed into the <code>IncrementNumberofCollectables()</code> function is neither 0 nor negative because it is important to establish good coding practices; this guarantees that all possible outcomes are handled. In an actual development environment, there could be designers or other programmers who attempt to use the <code>IncrementNumberofCollectables()</code> function and try to pass in a negative value, or a value that equals 0. If the function does not take these possibilities into account, there is potential for bugs later on in development.</p>
<ol>
<li value="8">Now that we’ve handled the <a id="_idIndexMarker1306"/>edge case where <code>value</code> is less than or equal to <code>0</code>, let’s continue with the function using an <code>else()</code> statement to increase <code>NumberofCollectables</code>. Add the following code under the <code>if()</code> statement from the previous step:<pre>else
{
  NumberofCollectables += Value;
}</pre></li>
<li>Next, let’s log <code>NumberofCollectables</code> using <code>UE_LOG</code> and the knowledge we learned about logging variables. Add the following code after the <code>else()</code> statement to properly log <code>NumberofCollectables</code>:<pre>UE_LOG(LogTemp, Warning, TEXT("Number of Coins: %d"), NumberofCollectables);</pre></li>
</ol>
<p>With this <code>UE_LOG()</code>, we are making a more robust log to track the number of coins. This lays out the groundwork of how the UI will work. This is because we will be logging the same information to the player using UMG later in this chapter.</p>
<p>With <code>UE_LOG()</code> added, all we need to do is call the <code>IncrementNumberofCollectables()</code> function inside the <code>PickableActor_Collectable</code> class.</p>
<ol>
<li value="10">In the <code>PickableActor_Collectable.cpp</code> source file, add the following header:<pre>#include "SuperSideScroller_Player.h"</pre></li>
<li>Next, inside the <code>PlayerPickedUp()</code> function, add the following function call before the <code>Super::PlayerPickedUp(Player)</code> line:<pre>Player-&gt;IncrementNumberofCollectables(CollectableValue);</pre></li>
<li>Now that our <code>PickableActor_Collectable</code> class is calling our player’s <code>IncrementNumberofCollectables</code> function, recompile the C++ code and return to the UE5 editor.</li>
<li>Within the UE5 editor, open the <strong class="bold">Output Log</strong> window by clicking <strong class="bold">Window</strong>, and then select <strong class="bold">Output Log</strong>.</li>
<li>Now, add multiple <code>PIE</code>.</li>
<li>When you overlap<a id="_idIndexMarker1307"/> over each coin collectible, observe the <strong class="bold">Output Log</strong> window to find that each time you collect a coin, the <strong class="bold">Output Log</strong> window will show you how many coins you’ve collected. </li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03</a>.</p>
<p>With this exercise <a id="_idIndexMarker1308"/>completed, you have now completed half of the work needed to develop the UI element of tracking the number of coins collected by the player. The next half will involve using the functionality developed in this activity inside UMG to show this information to the player on-screen. To do this, we need to learn more about UMG inside UE5.</p>
<h1 id="_idParaDest-303"><a id="_idTextAnchor331"/>Introducing Unreal Motion Graphics UI</h1>
<p>UMG <a id="_idIndexMarker1309"/>UI Designer is UE5’s main tool for creating UI menus, in-game HUD elements such as health bars, and other user interfaces you may want to present to the player.</p>
<p>In the <strong class="bold">SuperSideScroller</strong> game, we will only be using the <strong class="bold">Text widget</strong> to construct our <strong class="bold">Coin Collection UI</strong> in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>. We’ll learn more about the <strong class="bold">Text widget</strong> in the next section.</p>
<h1 id="_idParaDest-304"><a id="_idTextAnchor332"/>Understanding the Text widget</h1>
<p>The <strong class="bold">Text widget</strong> is one of the simpler widgets that exists. This is because it only allows you to display text information to the user <a id="_idIndexMarker1310"/>and customize the visuals of this text. Almost every single game uses text in one way or another to display information to its players. <strong class="bold">Overwatch</strong>, for example, uses a text-based UI to display crucial match data to its players. Without the use of text, it would be very difficult – maybe even impossible – to convey key pieces of statistical data to the player, such as total damage dealt, total time playing the game, and much more. </p>
<p>The <code>Text Block</code> by default. You can customize this text by adding your text to the <code>Text</code> parameter of the widget. Alternatively, you can use <code>Function Binding</code> to display more robust text that can reference internal or external variables. <code>Function Binding</code> should be used whenever you need to display information that can change; this could be text that represents a player’s score, how much money the player has, or in our case, the number of coins the player has collected:</p>
<p>You will be using the <code>Function Binding</code> functionality of the <code>GetCurrentNumberofCollectables()</code> function you created in <em class="italic">Exercise 15.03 – tracking the number of coins for the player</em>.</p>
<p>Now that we have the <strong class="bold">Text widget</strong> in the <strong class="bold">Canvas</strong> panel, it is time to position this widget where we need it to be. For this, we will take advantage of anchors.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor333"/>Anchors</h2>
<p>Anchors are used to <a id="_idIndexMarker1311"/>define where a widget’s desired location should<a id="_idIndexMarker1312"/> be on the <code>Anchor</code> point will ensure that the widget will maintain this position with varying screen sizes through different platform devices such as phones, tablets, and computers. Without an anchor, a widget’s position can become inconsistent between different screen resolutions, which is never desired.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about<a id="_idIndexMarker1313"/> anchors, please refer to the following documentation: <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml</a>.</p>
<p>For our<code>Anchor</code> point will be at the top-left<a id="_idIndexMarker1314"/> corner of the screen. You will <a id="_idIndexMarker1315"/>also add a position offset from this <code>Anchor</code> point so that the text is more visible and readable to the player. Before moving on to creating our <code>Text</code> <code>Formatting</code>, which you will use to display the current number of collected coins to the player.</p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor334"/>Text formatting</h2>
<p>Much like the <code>UE_LOG()</code> macro available<a id="_idIndexMarker1316"/> to us in C++, Blueprints offers a similar solution to display text and format it to allow custom variables to be added to it. The <code>Format Text</code> function takes in a single text input labeled <code>Format</code> and returns the <code>Result</code> text. This can be used to display information:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div><div><img alt="Figure 15.5 – The Format Text function " height="77" src="img/Figure_15.05_B18531.jpg" width="226"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – The Format Text function</p>
<p>Instead of using the <code>%</code> symbol like <code>UE_LOG()</code> does, the <code>Format Text</code> function uses the <code>{}</code> symbols to denote arguments that can be passed into the string. In-between the <code>{}</code> symbols, you need to add an argument name; this can be anything you want, but it should be representative of what the argument is. Refer to the example shown in the following screenshot: </p>
<div><div><img alt="Figure 15.6 – An example integer in the Format Text function " height="128" src="img/Figure_15.06_B18531.jpg" width="526"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – An example integer in the Format Text function</p>
<p>The <code>Format Text</code> function only supports <code>Byte</code>, <code>Integer</code>, <code>Float</code>, <code>Text</code>, or <code>EText Gender</code> variable types, so if you <a id="_idIndexMarker1317"/>are attempting to pass any other type of variable into the function as an argument, you must convert it into one of the supported types.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Format Text</code> function is also used for <strong class="bold">Text Localization</strong>, where you can support multiple languages for your game. More information about how this can be done in both C++ and Blueprints can be found here: <a href="https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml">https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml</a>.</p>
<p>You will be using the <code>Format Text</code> function in conjunction with the <code>Coin Counter UI</code> widget to display the number of coins that have been collected by the player. You will also be using <code>Anchor</code> points to position the <strong class="bold">Text widget</strong> at the top-left corner of the screen.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor335"/>Exercise 15.04 – creating the Coin Counter UI HUD element</h2>
<p>In this exercise, you will be <a id="_idIndexMarker1318"/>creating the UMG UI asset, which will display and update the number of coins collected by the player. You will use the <code>GetCurrentNumberofCollectables()</code> inline function you created in <em class="italic">Exercise 15.02 – creating the PickableActor_Collectable class</em>, to display this value on the screen using a simple <strong class="bold">Text widget</strong>. Follow these steps to accomplish this:</p>
<ol>
<li value="1">Let’s start by creating a new folder inside the <code>UI</code>. Do this by <em class="italic">right-clicking</em> on the <code>Content</code> folder at the top of the browser directory in the editor and selecting <strong class="bold">New Folder</strong>.</li>
<li>Inside the new <code>/Content/UI</code> directory, <em class="italic">right-click</em> and, instead of selecting <strong class="bold">Blueprint Class</strong>, hover over the <strong class="bold">User Interface</strong> option at the bottom of this list and <em class="italic">left-click</em> the <strong class="bold">Widget Blueprint</strong> option.</li>
<li>Name this new <code>BP_UI_CoinCollection</code>, and then <em class="italic">double-left-click</em> the asset to open the UMG editor.</li>
<li>By default, the <strong class="bold">Widget</strong> panel is empty, and you will find an empty hierarchy on the left-hand side, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 15.7 – The Widget panel’s empty hierarchy " height="84" src="img/Figure_15.07_B18531.jpg" width="289"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – The Widget panel’s empty hierarchy</p>
<ol>
<li value="5">Above the <strong class="bold">Hierarchy</strong> tab is the <strong class="bold">Palette</strong> tab, which lists all the available widgets you can use inside your UI. We will only focus on the <strong class="bold">Text widget</strong>, which is listed under the <strong class="bold">Common</strong> category. Do not mistake this option with the <strong class="bold">Rich Text Block</strong> widget.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">For a more detailed reference regarding all the available widgets inside UMG, please read the following documentation from Epic Games: <a href="https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml">https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml</a>.</p>
<ol>
<li value="6">If one is not automatically created, add a <strong class="bold">Canvas Panel</strong> widget as the base of the <strong class="bold">Hierarchy</strong> area.</li>
<li>Add the <strong class="bold">Text </strong><strong class="bold">widget</strong><a id="_idIndexMarker1319"/> to the <strong class="bold">UI</strong> panel by either <em class="italic">left-clicking</em> and dragging the <strong class="bold">Text widget</strong> from the <strong class="bold">Palette</strong> tab to the <strong class="bold">Hierarchy</strong> tab underneath the <strong class="bold">Canvas</strong> panel root, or by <em class="italic">left-clicking</em> and dragging the <strong class="bold">Text widget</strong> directly into the <strong class="bold">Canvas</strong> panel itself in the middle of the UMG editor. </li>
</ol>
<p>Before changing the text of this widget, we need to update its anchor, position, and font size so that it fits the needs we have for displaying the necessary information to the player.</p>
<ol>
<li value="8">With the <strong class="bold">Text widget</strong> selected, you will see many options under its <strong class="bold">Details</strong> panel to customize it. The first thing to do here is anchor the <strong class="bold">Text widget</strong> to the top-left corner of the <strong class="bold">Canvas</strong> panel. <em class="italic">Left-click</em> on the <strong class="bold">Anchors</strong> dropdown and select the top-left anchoring option, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 15.8 – By default, there are options to anchor a widget at different locations on the screen " height="322" src="img/Figure_15.08_B18531.jpg" width="287"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – By default, there are options to anchor a widget at different locations on the screen</p>
<p>Anchoring allows the widget to <a id="_idIndexMarker1320"/>maintain its desired location within the <strong class="bold">Canvas</strong> panel, regardless of varying screen sizes.</p>
<p>Now that the <strong class="bold">Text widget</strong> is anchored to the top-left corner, we need to set its relative position to this anchor so that there is an offset for better positioning and readability of the text.</p>
<ol>
<li value="9">In the <code>Position X</code> and <code>Position Y</code>. Set both these parameters to <code>100.0f</code>.</li>
<li>Next, enable the <strong class="bold">Size To Content</strong> parameter so that the <strong class="bold">Text widget</strong> will automatically resize itself depending on the size of the text it is displaying, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.9 – The Size To Content parameter will ensure that the Text widget won’t be cut off " height="88" src="img/Figure_15.09_B18531.jpg" width="437"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – The Size To Content parameter will ensure that the Text widget won’t be cut off</p>
<ol>
<li value="11">Lastly, we must update the size of the font that’s used for the <code>48</code>.</li>
<li>The final <strong class="bold">Text widget</strong> will look like this:</li>
</ol>
<div><div><img alt="Figure 15.10 – The Text widget is now anchored to the top left of the Canvas panel " height="549" src="img/Figure_15.10_B18531.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – The Text widget is now anchored to the top left of the Canvas panel</p>
<p>Now that we have the <strong class="bold">Text</strong><strong class="bold"> widget</strong> positioned and sized the way we need it to be, let’s add a new binding to the text so that it will automatically update and match the value of the number of collectibles the player has.</p>
<ol>
<li value="13">With the <strong class="bold">Text</strong> widget selected, find the <strong class="bold">Text</strong> parameter in its <strong class="bold">Details</strong> panel, under the <strong class="bold">Content</strong> category. There, you will find the <strong class="bold">Bind</strong> option.</li>
<li><em class="italic">Left-click</em> the <code>Function Binding</code> will be created automatically and be given the name <code>GetText_0</code>. Please refer to the <a id="_idIndexMarker1322"/>following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.11 – The new bound function of the text " height="102" src="img/Figure_15.11_B18531.jpg" width="428"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 – The new bound function of the text</p>
<ol>
<li value="15">Rename this function <code>Get Number of Collectables</code>.</li>
<li>Before continuing with this function, create a new object reference variable called <code>Player</code> that’s of the <code>SuperSideScroller_Player</code> type. Make this variable <strong class="bold">Public</strong> and exposable on spawn by enabling both the <strong class="bold">Instance Editable</strong> and <strong class="bold">Expose on Spawn</strong> parameters of the variable, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.12 – The Player variable with the Instance Editable and Expose on Spawn parameters enabled " height="441" src="img/Figure_15.12_B18531.jpg" width="531"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – The Player variable with the Instance Editable and Expose on Spawn parameters enabled</p>
<p>By making the <code>Player</code> variable <strong class="bold">Public</strong> and exposed on spawn, you will be able to assign this variable when creating the widget and adding it to the screen. We will do this in <em class="italic">Exercise 15.05 – adding the coin counter UI to the player screen</em>.</p>
<p>Now that we have a<a id="_idIndexMarker1323"/> reference variable to <code>SuperSideScroller_Player</code>, let’s continue with the <code>Get Number of Collectables</code> bind function.</p>
<ol>
<li value="17">Add a <code>Player</code> variable to the <code>Get Number of Collectables</code> function.</li>
<li>From this variable, <em class="italic">left-click</em> and drag and from the context-sensitive drop-down menu, and find and select the <code>Get Current Number of Collectables</code> function. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.13 – The Get Current Number of Collectables function you created in Exercise 15.03 " height="268" src="img/Figure_15.13_B18531.jpg" width="736"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – The Get Current Number of Collectables function you created in Exercise 15.03</p>
<ol>
<li value="19">Next, <em class="italic">left-click</em> and drag out the <code>Return Value</code> text parameter of <code>Get Number of Collectables</code> to <code>Return Node</code>. From the context-sensitive drop-down menu, search<a id="_idIndexMarker1324"/> for and select the <strong class="bold">Format Text</strong> option, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.14 – Now, we can create customized and formatted text " height="266" src="img/Figure_15.14_B18531.jpg" width="726"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – Now, we can create customized and formatted text</p>
<ol>
<li value="20">Within the <code>Format Text</code> function, add the following text:<pre>Coins: {coins}</pre></li>
</ol>
<p>Please refer to the following screenshot:</p>
<div><div><img alt="Figure 15.15 – Now, there is a new input argument for the formatted text " height="399" src="img/Figure_15.15_B18531.jpg" width="1126"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – Now, there is a new input argument for the formatted text</p>
<p>Remember that <a id="_idIndexMarker1325"/>using the <code>{}</code> symbols denotes a text argument that allows you to pass variables into the text.</p>
<ol>
<li value="21">Finally, connect the <code>Return Value</code> int of the <code>GetCurrentNumberofCollectables()</code> function to the wildcard <code>coins</code> input pin of the <code>Format Text</code> function, as shown here:</li>
</ol>
<div><div><img alt="Figure 15.16 – The Text widget will update automatically based on the Get Current Number of Collectables function " height="399" src="img/Figure_15.16_B18531.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – The Text widget will update automatically based on the Get Current Number of Collectables function</p>
<ol>
<li value="22">Compile and <a id="_idIndexMarker1326"/>save the <code>BP_UI_CoinCollection</code> widget Blueprint.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://packt.live/3eQJjTU">https://packt.live/3eQJjTU</a>.</p>
<p>With this exercise completed, you have created the <code>UI UMG</code> widget needed to display the current number of coins collected by the player. By using the <code>GetCurrentNumberofCollectables()</code> C++ function and the binding functionality of the <strong class="bold">Text widget</strong>, the UI will always update its value based on the number of coins collected. In the next exercise, we will add this UI to the player’s screen, but first, we’ll briefly learn about how to add and remove UMG from the player screen.</p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor336"/>Adding and creating UMG user widgets</h1>
<p>Now that we have<a id="_idIndexMarker1327"/> created <strong class="bold">Coin Collection UI</strong> in UMG, it is time to learn how to add and remove the UI to and from <a id="_idIndexMarker1328"/>the player screen, respectively. By adding <strong class="bold">Coin Collection UI</strong> to the player screen, the UI becomes visible to the player and can be updated as the player collects coins. </p>
<p>In Blueprints, there is a function called <code>Create Widget</code>, as shown in the following screenshot. Without a class assigned, it will be labeled <code>Construct None</code>, but do not let this confuse you:</p>
<div><div><img alt="Figure 15.17 – The Create Widget function as-is by default, without a class applied " height="209" src="img/Figure_15.17_B18531.jpg" width="430"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – The Create Widget function as-is by default, without a class applied</p>
<p>This function requires the <a id="_idIndexMarker1329"/>class of the <code>User</code> widget to be created and requires a <code>Player Controller</code> that will be referenced as the owning player of this UI. This function then returns the spawned user widget as its <code>Return Value</code>, where you can then add it to the player’s viewport using the <code>Add to Viewport</code> function. The <code>Create Widget</code> function only instantiates the widget object; it does not add this widget to the player’s screen. It is the <code>Add to Viewport</code> function that makes this widget visible on the player’s screen:</p>
<div><div><img alt="Figure 15.18 – The Add to Viewport function with ZOrder " height="245" src="img/Figure_15.18_B18531.jpg" width="287"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 – The Add to Viewport function with ZOrder</p>
<p>The viewport is the game screen that overlays your view of the game world, and it uses what is called <code>ZOrder</code> to determine the overlay depth in cases where multiple UI elements need to overlap above or below one another. By default, the <code>Add to Viewport</code> function will add the <code>User</code> widget to the screen and make it fill the entire screen – that is, unless<a id="_idIndexMarker1330"/> the <code>Set Desired Size In Viewport</code> function is called to set the size that it should fill manually:</p>
<div><div><img alt="Figure 15.19 – The Size parameter determines the desired size of the passed in the User widget " height="239" src="img/Figure_15.19_B18531.jpg" width="801"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.19 – The Size parameter determines the desired size of the passed in the User widget</p>
<p>In C++, you also have a function called <code>CreateWidget()</code>:</p>
<pre class="source-code">
template&lt;typename WidgetT, typename OwnerT&gt;
WidgetT * CreateWidget
(
  OwnerT * OwningObject,
  TSubclassOf &lt; UUserWidget &gt; UserWidgetClass,
  FName WidgetName
)</pre>
<p>The <code>CreateWidget()</code> function is available through the <code>UserWidget</code> class, which can be found in <code>/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h</code>.</p>
<p>An example of this can be found in <a href="B18531_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating User Interfaces with UMG</em>, where you used the <code>CreateWidget()</code> function to create <code>BP_HUDWidget</code>:</p>
<pre>HUDWidget = CreateWidget&lt;UHUDWidget&gt;(this, BP_HUDWidget);</pre>
<p>Refer back to <a href="B18531_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating User Interfaces with UMG</em>, and <em class="italic">Exercise 8.06 – creating the health bar C++ logic</em>, for more information regarding the <code>CreateWidget()</code> function in C++.</p>
<p>This function works <a id="_idIndexMarker1331"/>almost identically to its Blueprint counterpart because it takes in the <code>Owning Object</code> parameter, much like the <code>Owning Player</code> parameter of the Blueprint function, and it requires the <code>User Widget</code> class to be created. The C++ <code>CreateWidget()</code> function also takes in an <code>FName</code> parameter to represent the widget’s name.</p>
<p>Now that we have learned about the methods to use to add a UI to the player screen, let’s put this knowledge to the test. In the following exercise, you will be implementing the <code>Create Widget</code> and <code>Add to Viewport</code> Blueprint functions so that we can add the <strong class="bold">coin collection UI</strong> that we created in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>, to the player screen.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor337"/>Exercise 15.05 – Adding Coin Counter UI to the player screen</h2>
<p>In this exercise, you <a id="_idIndexMarker1332"/>will be creating a new <code>Player Controller</code> class so that you can use the player controller to add the <code>BP_UI_CoinCollection</code> widget Blueprint to the player’s screen. From there, you will also create a new <code>Game Mode</code> class and apply this game mode to the <strong class="bold">SuperSideScroller</strong> project. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">In the UE5 editor, navigate to <strong class="bold">Tools</strong> and then <strong class="bold">New C++ Class</strong>.</li>
<li>From the <strong class="bold">Choose Parent Class</strong> dialog window, find and select the <strong class="bold">Player Controller</strong> option.</li>
<li>Name the new <code>Player Controller</code> class <code>SuperSideScroller_Controller</code> and then click the <code>SuperSideScroller_Controller</code> class, but for now, we will stay inside the UE5 editor.</li>
<li>In the <code>MainCharacter</code> folder directory, create a new folder called <code>PlayerController</code>.</li>
<li>In the <code>PlayerController</code> folder, <em class="italic">right-click</em> and create a new <code>Blueprint Class</code> using the <a id="_idIndexMarker1333"/>new <code>SuperSideScroller_Controller</code> class. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.20 – Finding the new SuperSideScroller_Controller class to create a new Blueprint from " height="229" src="img/Figure_15.20_B18531.jpg" width="394"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.20 – Finding the new SuperSideScroller_Controller class to create a new Blueprint from</p>
<ol>
<li value="6">Name this new Blueprint <code>BP_SuperSideScroller_PC</code> and then <em class="italic">double-left-click</em> the asset to open it.</li>
</ol>
<p>To add the <code>BP_UI_CoinCollection</code> widget to the screen, we need to use the <code>Add to Viewport</code> function and the <code>Create Widget</code> function. We want the UI to be added to the player’s screen after the player character has been <code>Possessed</code> by the player controller. </p>
<ol>
<li value="7"><em class="italic">Right-click</em> inside the<a id="_idIndexMarker1334"/> Blueprint graph and, from the context-sensitive menu, find the <strong class="bold">Event On Possess</strong> option and <em class="italic">left-click</em> to add it to the graph. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.21 – Event On Possess  " height="99" src="img/Figure_15.21_B18531.jpg" width="188"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.21 – Event On Possess </p>
<p>The <strong class="bold">Event On Possess</strong> event node returns <strong class="bold">Possessed Pawn</strong>. We will use this <strong class="bold">Possessed Pawn</strong> to pass into our BP_UI_CoinCollection UI Widget, but first, we need to <strong class="bold">Cast To the SuperSideScroller_Player</strong> class.</p>
<ol>
<li value="8"><em class="italic">Left-click</em> and drag the <code>Event On Possess</code> node from the output. Then, search for and find the <code>Cast to SuperSideScroller_Player</code> node. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.22 – We need to Cast To SuperSideScroller_Player " height="172" src="img/Figure_15.22_B18531.jpg" width="723"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.22 – We need to Cast To SuperSideScroller_Player</p>
<ol>
<li value="9">Now, <em class="italic">right-click</em> and search for the <code>Create Widget</code> function to add it to the Blueprint graph. </li>
<li>From the drop-down class parameter, find and assign the <code>BP_UI_CoinCollection</code> asset you created in <em class="italic">Exercise 15.04 – creating the Coin Counter UI HUD element</em>. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.23 – The Create Widget function  " height="255" src="img/Figure_15.23_B18531.jpg" width="455"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.23 – The Create Widget function </p>
<p>After updating the <code>Class</code> parameter to the <code>BP_UI_CoinCollection</code> class, you will notice<a id="_idIndexMarker1335"/> that the <code>Create Widget</code> function will update to show the <code>Player</code> variable you created, set to <code>Exposed on Spawn</code>.</p>
<ol>
<li value="11"><em class="italic">Right-click</em> in the Blueprint graph to search for and find the <code>Self</code> reference variable from the context-sensitive drop-down menu. Connect the <code>Self</code> object variable to the <code>Owning Player</code> parameter of the <code>Create Widget</code> function, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 15.24 – The Owning Player input parameter is of the Player Controller type " height="259" src="img/Figure_15.24_B18531.jpg" width="744"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.24 – The Owning Player input parameter is of the Player Controller type</p>
<p>The Owning <a id="_idIndexMarker1336"/>Player parameter refers to the Player Controller type that will show and own this UI object. Since we are adding this UI to the <strong class="bold">SuperSideScroller_Controller</strong> Blueprint, we can just use the <strong class="bold">Self</strong> reference variable to pass into the function.</p>
<ol>
<li value="12">Next, pass in the returned <code>SuperSideScroller_Player</code> variable from the <code>Cast</code> node to the <code>Player</code> input node of the <code>Create Widget</code> function. Then, connect the execution pins of the <code>Cast</code> node and the <code>Create Widget</code> function, as shown in the following screenshot: </li>
</ol>
<div><div><img alt="Figure 15.25 – Creating the BP_UI_CoinCollection widget " height="231" src="img/Figure_15.25_B18531.jpg" width="1369"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.25 – Creating the BP_UI_CoinCollection widget</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png</a>.</p>
<ol>
<li value="13">Upon <a id="_idIndexMarker1337"/>pulling the <code>Create Widget</code> function from the <code>Return Value</code> parameter, search for and find the <code>Add to Viewport</code> function so that you can place it in the graph.</li>
<li>Connect the output <code>Return Value</code> parameter of the <code>Create Widget</code> function to the <code>Target</code> input parameter of the <code>Add to Viewport</code> function; do not change the <code>ZOrder</code> parameter.</li>
<li>Lastly, connect the execution pins of the <code>Create Widget</code> and <code>Add to Viewport</code> functions, as shown here:</li>
</ol>
<div><div><img alt="Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add it to the player viewport " height="197" src="img/Figure_15.26_B18531.jpg" width="1291"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add it to the player viewport</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the preceding screenshot in full resolution for better viewing at the following link: <a href="https://packt.live/2UwufBd">https://packt.live/2UwufBd</a>.</p>
<p>Now that the player controller adds the <code>BP_UI_CoinCollection</code> widget to the player’s viewport, we need to create a <code>GameMode</code> Blueprint and apply both the <code>BP_SuperSideScroller_MainCharacter</code> and <code>BP_SuperSideScroller_PC</code> classes to this game mode.</p>
<ol>
<li value="16">In the <code>Content</code> folder and selecting <code>GameMode</code>.</li>
<li>Next, <em class="italic">right-click</em> and<a id="_idIndexMarker1338"/> select <code>SuperSideScrollerGameMode</code> under <code>All Classes</code>.</li>
<li>Name this new <code>GameMode</code> Blueprint <code>BP_SuperSideScroller_GameMode</code>. <em class="italic">Double-left-click</em> this asset to open it.</li>
</ol>
<p>The <code>GameMode</code> Blueprint contains a list of classes that you can customize with your unique classes. For now, we will only worry about <code>Player Controller Class</code> and <code>Default Pawn Class</code>.</p>
<ol>
<li value="19">Click the <code>BP_SuperSideScroller_PC</code> Blueprint you created earlier in this exercise.</li>
<li>Then, click the <code>BP_SuperSideScroller_MainCharacter</code> Blueprint.</li>
</ol>
<p>Now that we have a custom <code>GameMode</code> that utilizes our custom <code>Player Controller</code> and <code>Player Character</code> classes, let’s add this game mode to the <code>PIE</code> and when cooking builds of the project.</p>
<ol>
<li value="21">From the UE5 editor, navigate to the <strong class="bold">Edit</strong> option at the top of the screen. Click this option and from the drop-down menu, find and select the <strong class="bold">Project Settings</strong> option.</li>
<li>On the left-hand side <a id="_idIndexMarker1339"/>of the <strong class="bold">Project Settings</strong> window, you will be provided with a list of categories divided into sections. Under the <strong class="bold">Project</strong> section, click the <strong class="bold">Maps &amp; Modes</strong> category.</li>
<li>In the <strong class="bold">Maps &amp; Modes</strong> section, you have a handful of parameters related to your project’s default maps and game mode. At the top of this section, you have the <strong class="bold">Default GameMode</strong> option. Click this dropdown to find and select the <strong class="bold">SuperSideScroller_GameMode</strong> Blueprint you created earlier in this exercise. </li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Changes made to the <code>DefaultEngine.ini</code> file, which can be found in your project’s <code>Config</code> folder. <code>Default GameMode</code> can be overwritten per level by updating the <strong class="bold">GameMode Override</strong> parameter, which can be found in the <strong class="bold">World Settings</strong> window of your level.</p>
<ol>
<li value="24">Close the <code>PIE</code> and start collecting coins. Observe that the <strong class="bold">BP_UI_CoinCollection</strong> widget is shown and updated each time you collect a coin, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.27 – Now, every coin you collect will appear on the player UI " height="659" src="img/Figure_15.27_B18531.jpg" width="1095"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.27 – Now, every coin you collect will appear on the player UI</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05</a>.</p>
<p>With this exercise complete, you<a id="_idIndexMarker1340"/> have created the <code>UI UMG</code> widget needed to display the current number of coins collected by the player. By using the <code>GetCurrentNumberofCollectables()</code> C++ function and the binding functionality of the <strong class="bold">Text widget</strong>, the UI will always update its value based on the number of coins collected. </p>
<p>So far, we have focused on the collectible coin and allowing players to collect these coins and add the total coins collected to the player’s UI. Now, we will focus on the potion power-up and granting<a id="_idIndexMarker1341"/> movement speed and jump height increases to the player for a short period. To implement this functionality, we first need to study timers.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor338"/>Using timers</h1>
<p>Timers in UE5 allow you to <a id="_idIndexMarker1342"/>perform actions after a delay or every <em class="italic">X</em> number of seconds. In the case of the <strong class="bold">SuperSideScroller</strong> potion power-up, a timer will be used to restore the player’s movement and jump to their defaults after 8 seconds.</p>
<p class="callout-heading">Note</p>
<p class="callout">In Blueprints, you can use a <code>Delay</code> node in addition to timer handles to achieve the same results. However, in C++, timers are the best means to achieve delays and reoccurring logic.</p>
<p>Timers are managed by <code>Timer Manager</code>, or <code>FTimerManager</code>, which exists in the <code>UWorld</code> object. There are two main functions that you will be using from the <code>FTimerManager</code> class, called <code>SetTimer()</code> and <code>ClearTimer()</code>:</p>
<pre class="source-code">
void SetTimer
(
    FTimerHandle &amp; InOutHandle,
    TFunction &lt; void )&gt; &amp;&amp; Callback,
    float InRate,
    bool InbLoop,
    float InFirstDelay
)
void ClearTimer(FTimerHandle&amp; InHandle)</pre>
<p>You may have noticed that, in both functions, there is a required <code>FTimerHandle</code>. This handle is used to control the timer you have set. Using this handle, you can pause, resume, clear, and even extend the timer.</p>
<p>The <code>SetTimer()</code> function also has other parameters to help you customize this timer when initially setting it. The callback function will be called after the timer has been completed, and if the <code>InbLoop</code> parameter is <code>True</code>, it will continue to call the callback function indefinitely, until the timer has been stopped. The <code>InRate</code> parameter is the duration of the<a id="_idIndexMarker1343"/> timer itself, while <code>InFirstDelay</code> is an initial delay that’s applied to the timer before it begins its timer for <code>InRate</code>.</p>
<p>The header file for the <code>FTimerManager</code> class can be found here: <code>/Engine/Source/Runtime/Engine/Public/TimerManager.h</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about timers and <code>FTimerHandle</code> by reading the documentation here: <a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/">https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/</a>.</p>
<p>In the following exercise, you will create your own <code>FTimerHandle</code> in the <code>SuperSideScroller_Player</code> class and use it to control how long the effects of the potion power-up last on the player.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor339"/>Exercise 15.06 – adding the potion power-up behavior to the player</h2>
<p>In this exercise, you will be <a id="_idIndexMarker1344"/>creating the logic behind the potion power-up and how it will affect the player’s character. You will take advantage of timers and timer handles to ensure that the power-up effects only last for a short duration. Follow these steps to accomplish this:</p>
<ol>
<li value="1">In Visual Studio, navigate to and open the <code>SuperSideScroller_Player.h</code> header file.</li>
<li>Under our <code>Private Access Modifier</code>, add a new variable of the <code>FTimerHandle</code> type and name it <code>PowerupHandle</code>:<pre>FTimerHandle PowerupHandle;</pre></li>
</ol>
<p>This timer handle will be responsible for keeping track of how much time has elapsed since it was initiated. This will allow us to control how long the potion power-up’s effects will last.</p>
<ol>
<li value="3">Next, add a Boolean variable under our <code>Private Access Modifier</code> called <code>bHasPowerupActive</code>:<pre>bool bHasPowerupActive;</pre></li>
</ol>
<p>We will use this Boolean variable when updating the <code>Sprint()</code> and <code>StopSprinting()</code> functions<a id="_idIndexMarker1345"/> to ensure we update the player’s sprint movement speed appropriately based on whether the power-up is active.</p>
<ol>
<li value="4">Next, declare a new void function called <code>IncreaseMovementPowerup()</code> under our <code>Public Access Modifier</code>:<pre>void IncreaseMovementPowerup();</pre></li>
</ol>
<p>This is the function that will be called from the potion power-up class to enable the effects of the power-up for the player.</p>
<ol>
<li value="5">Finally, you need to create a function that handles when the power-up effects end. Create a function called <code>EndPowerup()</code> under <code>Protected Access Modifier</code>:<pre>void EndPowerup();</pre></li>
</ol>
<p>With all the necessary variables and functions declared, it’s time to start defining these new functions and handling the power-up effects on the player.</p>
<ol>
<li value="6">Navigate to the <code>SuperSideScroller_Player.cpp</code> source file.</li>
<li>First, add the <code>#include “TimerManager.h”</code> header file to the top of the source file; we will need this class to use the timers.</li>
<li>Define the <code>IncreaseMovementPowerup()</code> function by adding the following code to the source file:<pre>void ASuperSideScroller_Player::IncreaseMovementPowerup()
{
}</pre></li>
<li>When this function is called, the first thing we need to do is set the <code>bHasPowerupActive</code> variable to <code>true</code>. Add the following code to the <code>IncreaseMovementPowerup()</code> function:<pre>bHasPowerupActive = true;</pre></li>
<li>Next, add the following code to increase both the <code>MaxWalkSpeed</code> and <code>JumpZVelocity</code> components of the player character’s movement component:<pre>GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;
GetCharacterMovement()-&gt;JumpZVelocity = 1500.0f;</pre></li>
</ol>
<p>Here, we are changing <code>MaxWalkSpeed</code> from the default value of <code>300.0f</code> to <code>500.0f</code>. As you may recall, the <a id="_idIndexMarker1346"/>default sprinting speed is also <code>500.0f</code>. We will address this later in this activity to increase the sprinting speed when the power-up is active.</p>
<ol>
<li value="11">To take advantage of timers, we need to get a reference to the <code>UWorld</code> object. Add the following code:<pre>UWorld* World = GetWorld();
if (World)
{
}</pre></li>
</ol>
<p>As we’ve done many times before in this project, we’re using the <code>GetWorld()</code> function to get a reference to the <code>UWorld</code> object and saving this reference in its variable.</p>
<ol>
<li value="12">Now that we have the reference to the <code>World</code> object and have performed a validity check, it is safe to use <code>TimerManager</code> to set the power-up timer. Add the following code within the <code>if()</code> statement shown in the previous step:<pre>World-&gt;GetTimerManager().SetTimer(PowerupHandle, this, 
  &amp;ASuperSideScroller_Player::EndPowerup, 8.0f, false);</pre></li>
</ol>
<p>Here, you are using the TimerManager class to set a timer. The <code>SetTimer()</code> function takes in the <code>FTimerHandle</code> component to use; in this case, the <code>PowerupHandle</code> variable you created. Next, we need to pass in a reference to the player class by<a id="_idIndexMarker1347"/> using the <code>this</code> keyword. Then, we need to provide the callback function to call after the timer has ended, which in this case is the <code>&amp;ASuperSideScroller_Player::EndPowerup</code> function. <code>8.0f</code> represents the duration of the timer; feel free to adjust this as you see fit, but for now, 8 seconds is fine. Lastly, there is the final boolean parameter of the <code>SetTimer()</code> function that determines whether this timer should loop; in this case, it should not.</p>
<ol>
<li value="13">Create the function definition for the <code>EndPowerup()</code> function:<pre>void ASuperSideScroller_Player::EndPowerup()
{
}</pre></li>
<li>The first thing to do when the <code>EndPowerup()</code> function is called is set the <code>bHasPowerupActive</code> variable to <code>false</code>. Add the following code within the <code>EndPowerup()</code> function:<pre>bHasPowerupActive = false;</pre></li>
<li>Next, change the <code>MaxWalkSpeed</code> and <code>JumpZVelocity</code> parameters of the character movement component back to their default values. Add the following code:<pre>GetCharacterMovement()-&gt;MaxWalkSpeed = 300.0f;
GetCharacterMovement()-&gt;JumpZVelocity = 1000.0f;</pre></li>
</ol>
<p>Here, we are changing both the <code>MaxWalkSpeed</code> and <code>JumpZVelocity</code> parameters of the character movement component to their default values.</p>
<ol>
<li value="16">Again, to take advantage of the timers and to clear the timer to handle <code>PowerupHandle</code>, we need to get a reference to the <code>UWorld</code> object. Add the following code:<pre>UWorld* World = GetWorld();
if (World)
{
}</pre></li>
<li>Finally, we can add the code to clear the timer handle’s <code>PowerupHandle</code>:<pre>World-&gt;GetTimerManager().ClearTimer(PowerupHandle);</pre></li>
</ol>
<p>By using the <code>ClearTimer()</code> function and passing in <code>PowerupHandle</code>, we are ensuring that this timer is no longer valid and will no longer affect the player.</p>
<p>Now that we have<a id="_idIndexMarker1348"/> created the functions that handle the power-up effects and the timer associated with the effects, we need to update both the <code>Sprint()</code> and <code>StopSprinting()</code> functions so that they also take into account the speed of the player when the power-up is active.</p>
<ol>
<li value="18">Update the <code>Sprint()</code> function to the following:<pre>void ASuperSideScroller_Player::Sprint()
{
  if (!bIsSprinting)
  {
    bIsSprinting = true;
    if (bHasPowerupActive)
    {
      GetCharacterMovement()-&gt;MaxWalkSpeed = 900.0f;
    }
    else
    {
      GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;
    }
  }
}</pre></li>
</ol>
<p>Here, we are updating the <code>Sprint()</code> function to take into account whether <code>bHasPowerupActive</code> is <code>true</code>. If this<a id="_idIndexMarker1349"/> variable is <code>true</code>, then we increase <code>MaxWalkSpeed</code> while sprinting from <code>500.0f</code> to <code>900.0f</code>, as shown here:</p>
<pre>if (bHasPowerupActive)
{
  GetCharacterMovement()-&gt;MaxWalkSpeed = 900.0f;
}</pre>
<p>If <code>bHasPowerupActive</code> is false, then we increase <code>MaxWalkSpeed</code> to <code>500.0f</code>, as we did by default.</p>
<ol>
<li value="19">Update the <code>StopSprinting()</code> function to the following:<pre>void ASuperSideScroller_Player::StopSprinting()
{
  if (bIsSprinting)
  {
    bIsSprinting = false;
    if (bHasPowerupActive)
    {
      GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;
    }
    else
    {
      GetCharacterMovement()-&gt;MaxWalkSpeed = 300.0f;
    }
  }
}</pre></li>
</ol>
<p>Here, we are updating<a id="_idIndexMarker1350"/> the <code>StopSprinting()</code> function to take into account whether <code>bHasPowerupActive</code> is true. If this variable is true, then we set the <code>MaxWalkSpeed</code> value to <code>500.0f</code> instead of <code>300.0f</code>, as shown here:</p>
<pre>if (bHasPowerupActive)
{
  GetCharacterMovement()-&gt;MaxWalkSpeed = 500.0f;
}</pre>
<p>If <code>bHasPowerupActive</code> is false, then we set <code>MaxWalkSpeed</code> to <code>300.0f</code>, as we did by default.</p>
<ol>
<li value="20">Finally, all we need to do is recompile the C++ code.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06</a>.</p>
<p>With this exercise complete, you<a id="_idIndexMarker1351"/> have created the potion power-up effects within the player character. The power-up increases both the default movement speed of the player and increases their jump height. Moreover, the effects of the power-up increase the sprinting speed. By using timer handles, you were able to control how long the power-up effect would last. </p>
<p>Now, it is time to create the potion power-up actor so that we can have a representation of this power-up in the game.</p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor340"/>Activity 15.03 – creating the potion power-up actor</h2>
<p>Now that the <code>SuperSideScroller_Player</code> class handles the effects of the potion power-up, it’s time to create the<a id="_idIndexMarker1352"/> potion power-up class and Blueprint. This activity aims to create the potion power-up class, inherit from the <code>PickableActor_Base</code> class, implement the overlapping functionality to grant the movement effects that you implemented in <em class="italic">Exercise 15.06 – adding the potion power-up behavior to the player</em>, and create the Blueprint actor for the potion power-up. Follow these steps to create the potion power-up class and create the potion Blueprint actor:</p>
<ol>
<li value="1">Create a new C++ class that inherits from the <code>PickableActor_Base</code> class and name this new class <code>PickableActor_Powerup</code>.</li>
<li>Add the override function declarations for both the <code>BeginPlay()</code> and <code>PlayerPickedUp()</code> functions.</li>
<li>Create the function definition for the <code>BeginPlay()</code> function. Within the <code>BeginPlay()</code> function, add the call to the parent class function of <code>BeginPlay()</code>.</li>
<li>Create the function definition for the <code>PlayerPickedUp()</code> function. Within the <code>PlayerPickedUp()</code> function, add the call to the <code>PlayerPickedUp()</code> parent class function.</li>
<li>Next, add the necessary <code>#include</code> file for the <code>SuperSideScroller_Player</code> class so that we can reference the player class and its functions.</li>
<li>In the <code>PlayerPickedUp()</code> function, use the <code>Player</code> input parameter of the function itself to make the function call to <code>IncreaseMovementPowerup()</code>.</li>
<li>From <strong class="bold">Epic Games Launcher</strong>, find the <strong class="bold">Action RPG</strong> project from the <strong class="bold">Samples</strong> tab, under the <strong class="bold">UE Legacy Samples</strong> category. Use this to create and install a new project. </li>
<li>Migrate the <code>A_Character_Heal_Mana_Cue</code> and <code>SM_PotionBottle</code> assets, as well as all of<a id="_idIndexMarker1353"/> their referenced assets, from the <strong class="bold">Action RPG</strong> project to your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Create a new folder in the <code>PickableItems</code> directory called <code>Powerup</code>. Create a new Blueprint within this directory based on the <code>PickableActor_Powerup</code> class and name this asset <code>BP_Powerup</code>.</li>
<li>In <code>BP_Powerup</code>, update the <code>MeshComp</code> component so that it uses the <code>SM_PotionBottle</code> static mesh. </li>
<li>Next, add <code>A_Character_Heal_Mana_Cue</code>, which you imported as the <code>Pickup Sound</code> parameter.</li>
<li>Finally, update the <code>RotationComp</code> component so that the actor will rotate 60 degrees per second around the <code>Pitch</code> axis (<code>Y</code> axis) and rotate 180 degrees per second around the <code>Yaw</code> axis (<code>X</code> axis).</li>
<li>Add <code>BP_Powerup</code> to your level and use <code>PIE</code> to observe the results when overlapping with the power-up.</li>
</ol>
<p>Expected output:</p>
<div><div><img alt="Figure 15.28 – The potion power-up  " height="366" src="img/Figure_15.28_B18531.jpg" width="474"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.28 – The potion power-up </p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>With this activity complete, you <a id="_idIndexMarker1354"/>were able to put your knowledge to the test in terms of creating a new C++ class that inherits from the <code>PickableActor_Base</code> class and overrides the <code>PlayerPickedUp()</code> function to add custom logic. By adding the call to the <code>IncreaseMovementPowerup()</code> function from the player class, you were able to add the movement power-up effects to the player when overlapping with the actor. Then, by using a custom mesh, material, and audio assets, you were able to bring the Blueprint actor to life from the <code>PickableActor_Powerup</code> class.</p>
<p>Now that we have created the coin collectible and the potion power-up, we need to implement a new gameplay feature into the project: the <code>Brick</code> class. In games such as <em class="italic">Super Mario</em>, bricks contain hidden coins and power-ups for the players to find. These bricks also serve as a means of reaching elevated platforms and areas within the level. In our <code>Brick</code> class will serve the purpose of containing hidden coin collectibles for the player, and as a means of allowing the player to reach areas of the level by using the bricks as paths to access hard-to-reach locations. So, in the next section, we will create the <code>Brick</code> class, which needs to be broken to find the hidden coins.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor341"/>Exercise 15.07 – creating the Brick class</h2>
<p>Now that we have created the <a id="_idIndexMarker1355"/>coin collectible and the potion power-up, it is time to create the <code>Brick</code> class, which will contain hidden coins for the player to collect. The brick is the final gameplay element of the <code>Brick</code> class, which will be used as part of the platforming mechanic of the <code>Brick</code> class and its Blueprint:</p>
<ol>
<li value="1">In the UE5 editor, navigate to <strong class="bold">Tools</strong> and then <strong class="bold">New C++ Class</strong>.</li>
<li>From the <code>Actor</code> class.</li>
<li>Name this class <code>SuperSideScroller_Brick</code> and click <strong class="bold">Create Class</strong>. Visual Studio and Unreal Engine will recompile the code and open this class for you.</li>
</ol>
<p>By default, the <code>SuperSideScroller_Brick</code> class comes with the <code>Tick()</code> function, but we will not need this function for the <code>Brick</code> class. Remove the function declaration for <code>Tick()</code> from the <code>SuperSideScroller_Brick.h</code> header file and remove the function definition from the <code>SuperSideScroller_Brick.cpp</code> source file before continuing.</p>
<ol>
<li value="4">Under <code>Private Access Modifier</code> for the <code>SuperSideScroller_Brick.h</code> file, add the following code to declare a new <code>UStaticMeshComponent* UPROPERTY()</code> function to represent the brick in our game world:<pre>UPROPERTY(VisibleDefaultsOnly, Category = Brick)
class UStaticMeshComponent* BrickMesh;</pre></li>
<li>Next, we need to create a <code>UBoxComponent UPROPERTY()</code> that will handle the collision with the player character. Add the following code to add this component under our <code>Private Access Modifier</code>:<pre>UPROPERTY(VisibleDefaultsOnly, Category = Brick)
class UBoxComponent* BrickCollision;</pre></li>
<li>Create the <code>UFUNCTION()</code> declaration for the <code>OnHit()</code> function under our <code>Private Access Modifier</code>. This will be used to determine when <code>UBoxComponent</code> is hit by the player:<pre>UFUNCTION()
void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, 
  UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, 
  const FHitResult&amp; Hit);</pre></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Recall that you used the <code>OnHit()</code> function when developing the <code>PlayerProjectile</code> class in <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, for this project. Please review that chapter for more information about the <code>OnHit()</code> function.</p>
<ol>
<li value="7">Next, create a new <a id="_idIndexMarker1356"/>Boolean called <code>UPROPERTY()</code> under our <code>Private Access Modifier</code> using the <code>EditAnywhere</code> keyword called <code>bHasCollectable</code>:<pre>UPROPERTY(EditAnywhere)
bool bHasCollectable;</pre></li>
</ol>
<p>This Boolean will determine whether the brick contains a coin collectible for the player.</p>
<ol>
<li value="8">Now, we need a variable that holds how many coin collectibles are available within this brick for the player. We will do this by creating an integer variable called <code>Collectable Value</code>. Make this a <code>UPROPERTY()</code>, under <code>Private Access Modifier</code>, with the <code>EditAnywhere</code> keyword, and give it a default value of <code>1</code>, as shown here:<pre>UPROPERTY(EditAnywhere)
int32 CollectableValue = 1;</pre></li>
</ol>
<p>The brick will need to <a id="_idIndexMarker1357"/>contain a unique sound and particle system so that it has a nice layer of polish for when the brick is destroyed by the player. We’ll add these properties next.</p>
<ol>
<li value="9">Create a new <code>Public Access Modifier</code> in the <code>SuperSideScroller_Brick.h</code> header file.</li>
<li>Next, create a new <code>UPROPERTY()</code> using the <code>EditAnywhere</code> and <code>BlueprintReadOnly</code> keywords for a variable of the <code>USoundBase</code> class. Name this variable <code>HitSound</code>, as shown here:<pre>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Brick)
class USoundBase* HitSound;</pre></li>
<li>Then, create a new <code>UPROPERTY()</code> using the <code>EditAnywhere</code> and <code>BlueprintReadOnly</code> keywords for a variable of the <code>UParticleSystem</code> class. Make sure to put this under <code>Public Access Modifier</code> and name this variable <code>Explosion</code>, as shown here:<pre>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Brick)
class UParticleSystem* Explosion;</pre></li>
</ol>
<p>Now that we have all the necessary properties for the <code>Brick</code> class, let’s move on to the <code>SuperSideScroller_Brick.cpp</code> source file, where we will initialize the components.</p>
<ol>
<li value="12">Let’s start by adding the following <code>#include</code> directories for <code>StaticMeshComponent</code> and <code>BoxComponent</code>. Add the following code to the <code>#include</code> list of the source file:<pre>#include "Components/StaticMeshComponent.h"
#include "Components/BoxComponent.h"</pre></li>
<li>First, initialize the <code>BrickMesh</code> component by adding the following code to the <code>ASuperSideScroller_Brick::ASuperSideScroller_Brick()</code> constructor function:<pre>BrickMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("BrickMesh"));</pre></li>
<li>Next, the <code>BrickMesh</code> component should have a collision so that the player can walk on top of it for<a id="_idIndexMarker1358"/> platforming gameplay purposes. To ensure this occurs by default, add the following code to set the collision to <code>“BlockAll”</code>:<pre>BrickMesh-&gt;SetCollisionProfileName("BlockAll");</pre></li>
<li>Lastly, the <code>BrickMesh</code> component will serve as the root component of the <code>Brick</code> actor. Add the following code to do this:<pre>RootComponent = BrickMesh;</pre></li>
<li>Now, add the following code to the constructor function to initialize our <code>BrickCollision UBoxComponent</code>:<pre>BrickCollision = CreateDefaultSubobject&lt;UBoxComponent&gt;
  (TEXT("BrickCollision"));</pre></li>
<li>Just like the <code>BrickMesh</code> component, the <code>BrickCollision</code> component will also need to have its collision set to <code>“BlockAll”</code> to receive the <code>OnHit()</code> callback events we will be adding later in this exercise. Add the following code:<pre>BrickCollision-&gt;SetCollisionProfileName("BlockAll");</pre></li>
<li>Next, the <code>BrickCollision</code> component needs to be attached to the <code>BrickMesh</code> component. We can do this by adding the following code:<pre>BrickCollision-&gt;AttachToComponent(RootComponent, 
  FAttachmentTransformRules::KeepWorldTransform);</pre></li>
<li>Before we can finish the initialization of the <code>BrickCollision</code> component, we need to add the function <a id="_idIndexMarker1359"/>definition for the <code>OnHit()</code> function. Add the following definition to the source file:<pre>void ASuperSideScroller_Brick::OnHit(UPrimitiveComponent* HitComp, AActor* 
  OtherActor, UPrimitiveComponent* OtherComp, FVector 
  NormalImpulse, const 
  FHitResult&amp; Hit)
{
}</pre></li>
<li>Now that we have defined the <code>OnHit()</code> function, we can assign the <code>OnComponentHit</code> callback to the <code>BrickCollision</code> component. Add the following code to the constructor function:<pre>BrickCollision-&gt;OnComponentHit.AddDynamic(this, 
  &amp;ASuperSideScroller_Brick::OnHit);</pre></li>
<li>Compile the C++ code for the <code>SuperSideScroller_Brick</code> class and return to the UE5 editor.</li>
<li>In the <code>Content</code> folder and select the <code>Brick</code>.</li>
<li><em class="italic">Right-click</em> inside the <code>Brick</code> folder and select <code>Blueprint Class</code>. From the <code>All Classes</code> search bar in the <code>SuperSideScroller_Brick</code> class.</li>
<li>Name this new Blueprint <code>BP_Brick</code>, and then <em class="italic">double-left-click</em> the asset to open it.</li>
<li>Select the <code>BrickMesh</code> component from the <code>Static Mesh</code> parameter to the <code>Shape_Cube</code> mesh.</li>
<li>With the <code>BrickMesh</code> component still selected, set the <code>Element 0</code> material parameter to <code>M_Brick_Clay_Beveled</code>. This material is provided by Epic Games by default when creating a new project. It can be found within the <code>StarterContent</code> directory, in the <strong class="bold">Content Drawer</strong> area.</li>
</ol>
<p>The last thing we need to do with the <code>BrickMesh</code> component is adjust its scale so that it fits the<a id="_idIndexMarker1360"/> needs of the player character, as well as the platforming mechanics of the <strong class="bold">SuperSideScroller</strong> game project.</p>
<ol>
<li value="27">With the <code>BrickMesh</code> component selected, make the following change to its <code>Scale</code> parameter:<pre>(X=0.750000,Y=0.750000,Z=0.750000)</pre></li>
</ol>
<p>Now that the <code>BrickMesh</code> component is <code>75%</code> of its normal size, the <code>Brick</code> actor will become more manageable for us as designers when we place the actor into the game world, as well as when we’re developing interesting platforming sections within the level.</p>
<p>The final step here is to update the location of the <code>BrickCollision</code> component so that it only has some of its collision sticking out from the bottom of the <code>BrickMesh</code> component.</p>
<ol>
<li value="28">Select the <code>BrickCollision</code> component from the <code>Location</code> parameter to the following values:<pre>(X=0.000000,Y=0.000000,Z=30.000000)</pre></li>
</ol>
<p>The <code>BrickCollision</code> component should now be positioned as follows:</p>
<div><div><img alt="Figure 15.29 – Now, the BrickCollision component is just barely outside the BrickMesh component " height="495" src="img/Figure_15.29_B18531.jpg" width="707"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.29 – Now, the BrickCollision component is just barely outside the BrickMesh component</p>
<p>We are making this adjustment to the position of the <code>BrickCollision</code> component so that the player can only hit <code>UBoxComponent</code> when jumping underneath the brick. By making it slightly <a id="_idIndexMarker1361"/>outside of the <code>BrickMesh</code> component, we can control it better and ensure that this component cannot be hit by the player in any other way.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07</a>.</p>
<p>With this exercise complete, you were able to create the base framework for the <code>SuperSideScroller_Brick</code> class and put together the Blueprint actor to represent the brick in the game world. By adding a cube mesh and brick material, you added a nice visual polish to the brick. In the following exercise, you will add the remaining C++ logic to the brick. This will allow the player to destroy the brick and obtain a collectible.</p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor342"/>Exercise 15.08 – adding the Brick class’s C++ logic</h2>
<p>In the previous exercise, you created the base<a id="_idIndexMarker1362"/> framework for the <code>SuperSideScroller_Brick</code> class by adding the necessary components and creating the <code>BP_Brick</code> Blueprint actor. In this exercise, you will add on top of the C++ code of <em class="italic">Exercise 15.07 – creating the Brick class</em>, to grant logic to the <code>Brick</code> class. This will allow the brick to give players coin collectibles. Perform the following steps to accomplish this:</p>
<ol>
<li value="1">To begin, we need to create a function that will add the collectible to the player. Add the following function declaration to the <code>SuperSideScroller_Brick.h</code> header file, under our <code>Private Access Modifier</code>:<pre>void AddCollectable(class ASuperSideScroller_Player* Player);</pre></li>
</ol>
<p>We want to pass in a reference to the <code>SuperSideScroller_Player</code> class so that we can call the <code>IncrementNumberofCollectables()</code> function from that class.</p>
<ol>
<li value="2">Next, create a void function declaration called <code>PlayHitSound()</code> under our <code>Private Access Modifier</code>:<pre>void PlayHitSound();</pre></li>
</ol>
<p>The <code>PlayHitSound()</code> function will be responsible for spawning the <code>HitSound</code> property you created in <em class="italic">Exercise 15.07 – creating the Brick class</em>.</p>
<ol>
<li value="3">Finally, create another void function declaration called <code>PlayHitExplosion()</code> under our <code>Private Access Modifier</code>:<pre>void PlayHitExplosion();</pre></li>
</ol>
<p>The <code>PlayHitExplosion()</code> function will be responsible for spawning the <code>Explosion</code> property you created in <em class="italic">Exercise 15.07 – creating the Brick class</em>.</p>
<p>With the remaining functions needed for the <code>SuperSideScroller_Brick</code> class declared in the header file, let’s move on and define these functions inside the source file.</p>
<ol>
<li value="4">At the top of the <code>SuperSideScroller_Brick.cpp</code> source file, add the following <code>#include</code> statements to the list of <code>#include</code> directories that already exist for this class:<pre>#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"
#include "SuperSideScroller_Player.h"</pre></li>
</ol>
<p>The includes for the <code>World</code> and <code>GameplayStatics</code> classes are necessary to spawn both the <code>HitSound</code> and the <code>Explosion</code> effects for the brick. Including the <code>SuperSideScroller_Player</code> class is required to make the call to the <code>IncrementNumberofCollectables()</code> class function.</p>
<ol>
<li value="5">Let’s start with the<a id="_idIndexMarker1363"/> function definition for the <code>AddCollectable()</code> function. Add the following code:<pre>void ASuperSideScroller_Brick::AddCollectable(class 
  ASuperSideScroller_Player* Player)
{
}</pre></li>
<li>Now, make the call to the <code>IncrementNumberofCollectables()</code> function by using the <code>Player</code> function input parameter:<pre>Player-&gt;IncrementNumberofCollectables(CollectableValue);</pre></li>
<li>For the <code>PlayHitSound()</code> function, you will need to get a reference to the <code>UWorld*</code> object and verify whether the <code>HitSound</code> property is valid before making the function call to <code>SpawnSoundAtLocation</code> from the <code>UGameplayStatics</code> class. This is a process you have done many times, so this is the entire function code:<pre>void ASuperSideScroller_Brick::PlayHitSound()
{
  UWorld* World = GetWorld();
  if (World &amp;&amp; HitSound)
  {
      UGameplayStatics::SpawnSoundAtLocation(World, 
      HitSound, 
        GetActorLocation());
  }
}</pre></li>
<li>Just like the <code>PlayHitSound()</code> function, the <code>PlayHitExplosion()</code> function will work in<a id="_idIndexMarker1364"/> an almost similar way, and it’s a process you have done many times in this project. Add the following code to create the function definition:<pre>void ASuperSideScroller_Brick::PlayHitExplosion()
{
  UWorld* World = GetWorld();
  if (World &amp;&amp; Explosion)
  {
      UGameplayStatics::SpawnEmitterAtLocation(World, 
      Explosion, 
        GetActorTransform());
  }
}</pre></li>
</ol>
<p>With these functions defined, let’s update the <code>OnHit()</code> function so that if the player does hit the <code>BrickCollision</code> component, we can spawn <code>HitSound</code> and <code>Explosion</code>, and also add a coin collectible to the player’s collection.</p>
<ol>
<li value="9">First, in the <code>OnHit()</code> function, create a new variable called <code>Player</code> of the <code>ASuperSideScroller_Player</code> type that equals <code>Cast</code> of the <code>OtherActor</code> input parameter of the function, as shown here:<pre>ASuperSideScroller_Player* Player = 
  Cast&lt;ASuperSideScroller_Player&gt;(OtherActor);</pre></li>
<li>Next, we only want to<a id="_idIndexMarker1365"/> continue with this function if <code>Player</code> is valid and <code>bHasCollectable</code> is <code>True</code>. Add the following <code>if()</code> statement:<pre>if (Player &amp;&amp; bHasCollectable)
{
}</pre></li>
<li>If the conditions in the <code>if()</code> statement are met, that is when we need to make the calls to the <code>AddCollectable()</code>, <code>PlayHitSound()</code>, and <code>PlayHitExplosion()</code> functions. Make sure to also pass the <code>Player</code> variable inside the <code>AddCollectable()</code> function:<pre>AddCollectable(Player);
PlayHitSound();
PlayHitExplosion();</pre></li>
<li>Finally, add the function call to destroy the brick inside the <code>if()</code> statement:<pre>Destroy();</pre></li>
<li>With the <code>OnHit()</code> function defined as we need, recompile the C++ code but do not return to the UE5 editor just yet.</li>
<li>For the VFX and SFX of the brick’s explosion, we will need to migrate assets from two separate projects available to us from <strong class="bold">Epic Games Launcher</strong>: the <strong class="bold">Blueprints</strong> project and the <strong class="bold">Content Examples</strong> project.</li>
<li>Using your knowledge from previous exercises, download and install these projects using Unreal Engine version 4.24. Both projects can be found in the <strong class="bold">Samples</strong> tab, in the <strong class="bold">UE Legacy Samples</strong> and <strong class="bold">UE Feature Samples</strong> categories, respectively.</li>
<li>Once installed, open<a id="_idIndexMarker1366"/> the <code>P_Pixel_Explosion</code> asset in the <strong class="bold">Content Drawer</strong> area.</li>
<li><em class="italic">Right-click</em> this asset and select <strong class="bold">Asset Actions</strong>, then <strong class="bold">Migrate</strong>. Migrate this asset and all its referenced assets into your <strong class="bold">SuperSideScroller</strong> project.</li>
<li>Once this asset has been successfully migrated, close the <code>Blueprints</code> project.</li>
<li>From the <code>Blueprints</code> project, find the <code>Blueprints_TextPop01</code> asset.</li>
<li><em class="italic">Right-click</em> this asset, then select <strong class="bold">Asset Actions</strong>, and then <strong class="bold">Migrate</strong>. Migrate this asset and all its referenced assets into your <strong class="bold">SuperSideScroller</strong> project.</li>
</ol>
<p>With these assets migrated to your project, return to the Unreal Engine 5 editor of your <strong class="bold">SuperSideScroller </strong>project.</p>
<ol>
<li value="21">Navigate to the <code>Brick</code> folder in the <code>BP_Brick</code> asset to open it.</li>
<li>In the <code>HitSound</code> parameter to the <code>Blueprints_TextPop01</code> soundwave you imported.</li>
<li>Next, add the <code>P_Pixel_Explosion</code> particle you imported into the <code>Explosion</code> parameter.</li>
<li>Recompile the <code>BP_Brick</code> Blueprint and add two of these actors to your level.</li>
<li>Set one of the <a id="_idIndexMarker1367"/>bricks so that the <code>bHasCollectable</code> parameter is <code>True</code>; set the other to <code>False</code>. Please refer to the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.30 – This Brick actor is set to have a collectible spawn " height="125" src="img/Figure_15.30_B18531.jpg" width="769"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.30 – This Brick actor is set to have a collectible spawn</p>
<ol>
<li value="26">Using <code>PIE</code>, observe the differences in behavior between the two brick actors when you attempt to hit the bottom of the brick with the character’s head when jumping, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.31 – Now, the player can hit the brick and it will be destroyed " height="589" src="img/Figure_15.31_B18531.jpg" width="845"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.31 – Now, the player can hit the brick and it will be destroyed</p>
<p>When <code>bHasCollectable</code> is <code>True</code>, <code>SuperSideScroller_Brick</code> will play our <code>HitSound</code>, spawn the <code>Explosion</code> particle system, add a coin collectible to the player, and be destroyed.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the assets and code for this exercise here: <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08</a>.</p>
<p>With this exercise complete, you have now finished developing the gameplay mechanics for the <code>SuperSideScroller_Brick</code> class can be used for both the platforming gameplay and the coin-collecting mechanic that we want for the game. </p>
<p>Now that the brick can be <a id="_idIndexMarker1368"/>destroyed and hidden coins can be collected, all the gameplay elements that we set out to create for the <strong class="bold">SuperSideScroller</strong> game project are complete. </p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor343"/>Summary</h1>
<p>In this chapter, you put your knowledge to the test to create the remaining gameplay mechanics for the <strong class="bold">SuperSideScroller</strong> game project. Using a combination of C++ and Blueprints, you developed the potion power-up and coins for the player to collect in the level. Also, by using your knowledge from <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, you added unique audio and visual assets to these collectible items to add a nice layer of polish to the game.</p>
<p>You learned and took advantage of the UMG UI system within UE5 to create a simple, yet effective, UI feedback system to display the number of coins that the player has collected. By using the binding feature of the <code>Brick</code> class using the knowledge you learned from the <strong class="bold">SuperSideScroller</strong> project to hide coins for the player so that they can collect and find them.</p>
<p>The <code>Animation State Machine</code> to handle the jumping and movement states of the player character. We then learned how to control the player’s movement and jump height using the character movement component.</p>
<p>In <a href="B18531_12.xhtml#_idTextAnchor247"><em class="italic">Chapter 12</em></a>, <em class="italic">Animation Blending and Montages</em>, we learned more about animation blending inside <code>Animation Blueprints</code> by using the <code>Layered Blend per Bone</code> function and <code>Saved Cached Poses</code>. By adding a new <code>AnimSlot</code> for the upper body animation of the player character’s throw animation, we were able to have both the player movement animations and the throw animation blend together smoothly. In <a href="B18531_13.xhtml#_idTextAnchor268"><em class="italic">Chapter 13</em></a>, <em class="italic">Creating and Adding the Enemy Artificial Intelligence</em>, we used the robust systems of behavior trees and Blackboards to develop AI behavior for the enemy. We created a <code>Task</code> that will allow the enemy AI to move in-between points from a custom Blueprint that we also developed to determine patrol points for the AI. </p>
<p>In <a href="B18531_14.xhtml#_idTextAnchor298"><em class="italic">Chapter 14</em></a>, <em class="italic">Spawning the Player Projectile</em>, we learned how to create an <code>Anim Notify</code> and how to implement this notify in our <code>Animation Montage</code> for the player character’s throw to spawn the player projectile. Then, we learned about how to create projectiles and how to use <strong class="bold">Projectile Movement Component</strong> to have the player projectile move in the game world.</p>
<p>Finally, in this chapter, we learned how to create UI using the <code>UMG</code> toolset for the coin collectible, as well as how to manipulate our <code>Brick</code> class that can be used to hide coins for the player to find and collect.</p>
<p>In the next chapter, you will learn about the basics of multiplayer, server-client architectures, and the gameplay framework classes used for multiplayer inside UE5. You will use this knowledge to expand upon the multiplayer FPS project in UE5.</p>
<p>This summarization only really scratches the surface of what we learned and accomplished in the <strong class="bold">SuperSideScroller</strong> project. Before you move on, here are some challenges for you to test your knowledge and expand upon the project:</p>
<h1 id="_idParaDest-316"><a id="_idTextAnchor344"/>Additional Challenges</h1>
<p>Test your knowledge from this section by adding the following functionality to the SuperSideScroller project.</p>
<ol>
<li value="1">Add a new power-up that lowers the gravity that’s applied to the player character. Import a custom mesh and audio assets to give this power-up a unique look compared to the potion power-up you made.</li>
<li>When the player character collects 10 coins, grant the player a power-up.</li>
<li>Implement the functionality that allows the player to be destroyed when it’s overlapping with the AI. Include being able to respawn the player when this happens.</li>
<li>Add another power-up that gives immunity to the player so that they cannot be destroyed when they’re overlapping with an enemy. (In fact, when overlapping an enemy with this power-up, it could destroy the enemy.)</li>
<li>Using all the gameplay elements you’ve developed for the <strong class="bold">SuperSideScroller</strong> project, create a new level that takes advantage of these elements to make an interesting platforming arena to play in. </li>
<li>Add multiple enemies with interesting patrol points to challenge the player when they’re navigating the area.</li>
<li>Place power-ups in hard-to-reach areas so that players need to improve their platforming skills to obtain them.</li>
<li>Create dangerous pitfalls for the player to navigate across and add functionality that will destroy the player if they fall off the map.</li>
</ol>
</div>
<div><div></div>
</div>
</div></body></html>