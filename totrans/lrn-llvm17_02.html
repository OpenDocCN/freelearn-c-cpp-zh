<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor017"/>1</h1>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Installing LLVM</h1>&#13;
			<p>In order to learn how to work with LLVM, it is best to begin by compiling LLVM from source. LLVM is an umbrella project and the GitHub repository contains the source of all projects belonging to LLVM. Each LLVM project is in a top-level directory of the repository. Besides cloning the repository, your system must also have all tools installed that are required by the build system. In this chapter, you will learn about the following topics:</p>&#13;
			<ul>&#13;
				<li>Getting the prerequisites ready, which will show you how to set up your build system</li>&#13;
				<li>Cloning the repository and building from source, which will cover how to get the LLVM source code, and how to compile and install the LLVM core libraries and clang with CMake and Ninja</li>&#13;
				<li>Customizing the build process, which will talk about the various possibilities for influencing the build process</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Compiling LLVM versus installing binaries</h1>&#13;
			<p>You can install LLVM binaries from various sources. If you are using Linux, then your distribution contains the LLVM libraries. Why bother compiling LLVM yourself?</p>&#13;
			<p>First, not all install <a id="_idIndexMarker000"/>packages contain all the files required for developing with LLVM. Compiling and installing LLVM yourself prevents this problem. Another reason stems from the fact that LLVM is highly customizable. With building LLVM, you learn how you can customize LLVM, and this will enable you to diagnose problems <a id="_idIndexMarker001"/>that may arise if you bring your LLVM application to another platform. And last, in the third part of this book, you will extend LLVM itself, and for this, you need the skill of building LLVM yourself.</p>&#13;
			<p>However, it is perfectly fine to avoid compiling LLVM for the first steps. If you want to go on this route, then you only need to install the prerequisites as described in the next section.</p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">Many Linux distributions split LLVM into several packages. Please make sure that you install the development package. For example, on Ubuntu, you need to install the <code>llvm-dev</code> package. Please also make sure that you install LLVM 17. For other versions, the examples in this book may require changes.</p>&#13;
			<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/>Getting the prerequisites ready</h1>&#13;
			<p>To work with LLVM, your development system should run a common operating system such as Linux, FreeBSD, macOS, or Windows. You can build LLVM and clang in different modes. A build with debug symbols enabled can take up to 30 GB of space. The required disk space depends <a id="_idIndexMarker002"/>heavily on the chosen build options. For example, building only the LLVM core libraries in release mode, targeting only one platform, requires about 2 GB of free disk space, which is the bare minimum needed.</p>&#13;
			<p>To reduce compile times, a fast CPU (such as a quad-core CPU with a 2.5 GHz clock speed) and a fast SSD are also helpful. It is even possible to build LLVM on a small device such as a Raspberry Pi – it only takes a lot of time. The examples within this book were developed on a laptop with an Intel quad-core CPU running at a 2.7 GHz clock speed, with 40 GB RAM and 2.5 TB SSD disk space. This system is well suited for the development task.</p>&#13;
			<p>Your development system must have some prerequisite software installed. Let’s review the minimal required version of these software packages.</p>&#13;
			<p>To check out the <a id="_idIndexMarker003"/>source from GitHub, you need <strong class="bold">Git</strong> (<a href="https://git-scm.com/">https://git-scm.com/</a>). There is no requirement for a specific version. The GitHub help pages recommend using at least version 1.17.10. Due to known security issues found in the past, it is recommended to use the latest available version, which is 2.39.1 at the time of writing.</p>&#13;
			<p>The LLVM <a id="_idIndexMarker004"/>project uses <strong class="bold">CMake</strong> (<a href="https://cmake.org/">https://cmake.org/</a>) as the build file generator. At least the 3.20.0 version is required. CMake can generate build files for <a id="_idIndexMarker005"/>various build systems. In this book, <strong class="bold">Ninja</strong> (<a href="https://ninja-build.org/">https://ninja-build.org/</a>) is used because it is fast and available on all platforms. The latest version, 1.11.1, is recommended.</p>&#13;
			<p>Obviously, you also <a id="_idIndexMarker006"/>need a <strong class="bold">C/C++ compiler</strong>. The LLVM projects are written in modern C++, based on the C++17 standard. A conforming compiler and standard library <a id="_idIndexMarker007"/>are required. The following compilers are known to work with LLVM 17:</p>&#13;
			<ul>&#13;
				<li>gcc 7.1.0 or later</li>&#13;
				<li>clang 5.0 or later</li>&#13;
				<li>Apple clang 10.0 or later</li>&#13;
				<li>Visual Studio 2019 16.7 or later</li>&#13;
			</ul>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">Please be aware that with further development of the LLVM project, the requirements for the compiler are most likely to change. In general, you should use the latest compiler version available for your system.</p>&#13;
			<p><strong class="bold">Python</strong> (<a href="https://python.org/">https://python.org/</a>) is used <a id="_idIndexMarker008"/>during the generation of the build files and for running the test suite. It should be at least the 3.8 version.</p>&#13;
			<p>Although not covered in this book, there can be reasons that you need to use Make instead of Ninja. In this <a id="_idIndexMarker009"/>case, you need to use <code>ninja</code> in each command with <code>make</code> for the scenarios described below.</p>&#13;
			<p>LLVM also <a id="_idIndexMarker010"/>depends on the <code>zlib</code> library (<a href="https://www.zlib.net/">https://www.zlib.net/</a>). You should have at least version 1.2.3.4 installed. As usual, we recommend using the latest version, 1.2.13.</p>&#13;
			<p>To install the prerequisite software, the easiest way is to use the package manager from your operating system. In the following sections, the commands required to install the software are shown for the most popular operating systems.</p>&#13;
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Ubuntu</h2>&#13;
			<p>Ubuntu 22.04 uses the <code>apt</code> package manager. Most of the basic utilities are already installed; only the <a id="_idIndexMarker011"/>development tools are missing. To install all <a id="_idIndexMarker012"/>packages at once, you type the following:</p>&#13;
			<pre class="console">&#13;
$ sudo apt -y install gcc g++ git cmake ninja-build zlib1g-dev</pre>			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Fedora and RedHat</h2>&#13;
			<p>The package <a id="_idIndexMarker013"/>manager of <a id="_idIndexMarker014"/>Fedora 37 and RedHat <a id="_idIndexMarker015"/>Enterprise Linux 9 is called <code>dnf</code>. Like Ubuntu, most <a id="_idIndexMarker016"/>of the basic utilities are already installed. To install all packages at once, you type the following:</p>&#13;
			<pre class="console">&#13;
$ sudo dnf –y install gcc gcc-c++ git cmake ninja-build \&#13;
  zlib-devel</pre>			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>FreeBSD</h2>&#13;
			<p>On FreeBSD 13 or later, you have to use the <code>pkg</code> package manager. FreeBSD differs from <a id="_idIndexMarker017"/>Linux-based systems in that the clang compiler is already <a id="_idIndexMarker018"/>installed. To install all other packages at once, you type the following:</p>&#13;
			<pre class="console">&#13;
$ sudo pkg install –y git cmake ninja zlib-ng</pre>			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>OS X</h2>&#13;
			<p>For development <a id="_idIndexMarker019"/>on OS X, it is best <a id="_idIndexMarker020"/>to install <strong class="bold">Xcode</strong> from the Apple store. While the <a id="_idIndexMarker021"/>Xcode IDE is not used in this book, it comes with the required C/C++ compilers and supporting utilities. For installation of <a id="_idIndexMarker022"/>the other tools, the package manager <strong class="bold">Homebrew</strong> (<a href="https://brew.sh/">https://brew.sh/</a>) can be used. To install all packages at once, you type the following:</p>&#13;
			<pre class="console">&#13;
$ brew install git cmake ninja zlib</pre>			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Windows</h2>&#13;
			<p>Like OS X, Windows <a id="_idIndexMarker023"/>does not come with a package manager. For the C/C++ compiler, you <a id="_idIndexMarker024"/>need to download <strong class="bold">Visual Studio Community 2022</strong> (<a href="https://visualstudio.microsoft.com/vs/community/">https://visualstudio.microsoft.com/vs/community/</a>), which is free for personal use. Please make sure that you install the workload named <strong class="bold">Desktop Development with C++</strong>. You can <a id="_idIndexMarker025"/>use the package manager <strong class="bold">Scoop</strong> (<a href="https://scoop.sh/">https://scoop.sh/</a>) to install the other packages. After installing Scoop as described on the website, you open <strong class="bold">x64 Native Tools Command Prompt for VS 2022</strong> from your Windows menu. To install the required packages, you type the following:</p>&#13;
			<pre class="console">&#13;
$ scoop install git cmake ninja python gzip bzip2 coreutils&#13;
$ scoop bucket add extras&#13;
$ scoop install zlib</pre>			<p>Please watch <a id="_idIndexMarker026"/>the output from Scoop closely. For the Python and <code>zlib</code> packages, it advises adding some registry keys. These entries are needed so that other software can find these packages. To add the registry keys, you’d best copy and paste the output from Scoop, which looks like the following:</p>&#13;
			<pre class="console">&#13;
$ %HOMEPATH%\scoop\apps\python\current\install-pep-514.reg&#13;
$ %HOMEPATH%\scoop\apps\zlib\current\register.reg</pre>			<p>After each command, a message window from the registry editor will pop up asking whether you really want to import those registry keys. You need to click on <strong class="bold">Yes</strong> to finish the import. Now all prerequisites are installed.</p>&#13;
			<p>For all <a id="_idIndexMarker027"/>examples in this book, you must use the <strong class="bold">x64 Native Tools Command Prompt </strong>for VS 2022. Using this command prompt, the compiler is automatically added to the search path.</p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">The LLVM code base is very large. To comfortably navigate the source, we recommend using an IDE <a id="_idIndexMarker028"/>that allows you to jump to the definition of classes and search through the source. We find <strong class="bold">Visual Studio Code</strong> (<a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a>), which is an extensible cross-platform IDE, very comfortable to use. However, this is no requirement for following the examples in this book.</p>&#13;
			<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/>Cloning the repository and building from source</h1>&#13;
			<p>With the <a id="_idIndexMarker029"/>build tools ready, you can now check out all LLVM projects from GitHub and build LLVM. This process is essentially the same on all platforms:</p>&#13;
			<ol>&#13;
				<li>Configure Git.</li>&#13;
				<li>Clone the repository.</li>&#13;
				<li>Create the build directory.</li>&#13;
				<li>Generate the build system files.</li>&#13;
				<li>Finally, build and install LLVM.</li>&#13;
			</ol>&#13;
			<p>Let’s begin with configuring Git.</p>&#13;
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Configuring Git</h2>&#13;
			<p>The LLVM project uses Git for version control. If you have not used Git before, then you should do some <a id="_idIndexMarker030"/>basic configuration of Git first before continuing: to set the username and email address. Both pieces of information are used if you commit changes.</p>&#13;
			<p>One can check whether they previously had an email and username already configured in Git with the following commands:</p>&#13;
			<pre class="console">&#13;
$ git config user.email&#13;
$ git config user.name</pre>			<p>The preceding commands will output the respective email and username that you already have set when using Git. However, in the event that you are setting the username and email for the first time, the following commands can be entered for first-time configuration. In the following commands, you can simply replace <code>Jane</code> with your name and <code>jane@email.org</code> with your email:</p>&#13;
			<pre class="console">&#13;
$ git config --global user.email "jane@email.org"&#13;
$ git config --global user.name "Jane"</pre>			<p>These commands <a id="_idIndexMarker031"/>change the global Git configuration. Inside a Git repository, you can locally overwrite those values by not specifying the <code>--</code><code>global</code> option.</p>&#13;
			<p>By default, Git uses the <strong class="bold">vi</strong> editor for commit messages. If you prefer another editor, then you can change the configuration in a similar way. To use the <strong class="bold">nano</strong> editor, you type the following:</p>&#13;
			<pre class="console">&#13;
$ git config --global core.editor nano</pre>			<p>For more information about Git, please see the <em class="italic">Git Version Control </em><em class="italic">Cookbook</em> (<a href="https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545">https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545</a>).</p>&#13;
			<p>Now you are ready to clone the LLVM repository from GitHub.</p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Cloning the repository</h2>&#13;
			<p>The command to clone the repository is essentially the same on all platforms. Only on Windows, it is <a id="_idIndexMarker032"/>recommended to turn off the auto-translation of line endings.</p>&#13;
			<p>On all non-Windows platforms, you type the following command to clone the repository:</p>&#13;
			<pre class="console">&#13;
$ git clone https://github.com/llvm/llvm-project.git</pre>			<p>Only on Windows, add the option to disable auto-translation of line endings. Here, you type the following:</p>&#13;
			<pre class="console">&#13;
$ git clone --config core.autocrlf=false \&#13;
  https://github.com/llvm/llvm-project.git</pre>			<p>This Git command clones the latest source code from GitHub into a local directory named <code>llvm-project</code>. Now change the current directory into the new <code>llvm-project</code> directory with the following command:</p>&#13;
			<pre class="console">&#13;
$ cd llvm-project</pre>			<p>Inside the directory are all LLVM projects, each one in its own directory. Most notably, the LLVM core libraries are in the <code>llvm</code> subdirectory. The LLVM project uses branches for subsequent release development (“release/17.x”) and tags (“llvmorg-17.0.1”) to mark a certain release. With the preceding clone command, you get the current development state. This book uses LLVM 17. To check out the first release of LLVM 17 into a branch called <a id="_idTextAnchor029"/><code>llvm-17</code>, you type the following:</p>&#13;
			<pre class="console">&#13;
$ git checkout -b llvm-17 llvmorg-17.0.1</pre>			<p>With the previous steps, you cloned the whole repository and created a branch from a tag. This is the most flexible approach.</p>&#13;
			<p>Git also allows <a id="_idIndexMarker033"/>you to clone only a branch or a tag (including history). With <code>git clone --branch release/17.x https://github.com/llvm/llvm-project</code>, you only clone the <code>release/17.x</code> branch and its history. You then have the latest state of the LLVM 17 release branch, so you only need to create a branch from the release tag like before if you need the exact release version. With the additional <code>–-depth=1</code> option, which is <a id="_idIndexMarker034"/>known as a <strong class="bold">shallow clone with Git</strong>, you prevent the cloning of the history, too. This saves time and space but obviously limits what you can do locally, including checking out a branch based on the release tags.</p>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/>Creating a build directory</h2>&#13;
			<p>Unlike many other projects, LLVM does not support inline builds and requires a separate build directory. Most easily, this is created inside the <code>llvm-project</code> directory, which is your <a id="_idIndexMarker035"/>current directory. Let us name the build directory, <code>build</code>, for simplicity. Here, the commands for Unix and Windows systems differ. On a Unix-like system, you use the following:</p>&#13;
			<pre class="console">&#13;
$ mkdir build</pre>			<p>And on Windows, use the following:</p>&#13;
			<pre class="console">&#13;
$ md build</pre>			<p>Now you are ready to create the build system files with the CMake tool inside this directory.</p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Generating the build system files</h2>&#13;
			<p>In order to <a id="_idIndexMarker036"/>generate build system files to compile LLVM and clang using Ninja, you run the following:</p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \&#13;
  -DLLVM_ENABLE_PROJECTS=clang -B build -S llvm</pre>			<p>The <code>-G</code> option tells CMake for which system to generate build files. Often-used values for that option are as follows:</p>&#13;
			<ul>&#13;
				<li><code>Ninja</code> – for the Ninja build system</li>&#13;
				<li><code>Unix Makefiles</code> – for GNU Make</li>&#13;
				<li><code>Visual Studio 17 VS2022</code> – for Visual Studio and MS Build</li>&#13;
				<li><code>Xcode</code> – for Xcode projects</li>&#13;
			</ul>&#13;
			<p>With the <code>–B</code> option, you tell CMake the path of the build directory. Similarly, you specify the source directory with the <code>–S</code> option. The generation process can be influenced by setting various variables with the <code>–D</code> option. Usually, they are prefixed with <code>CMAKE_</code> (if defined by CMake) or <code>LLVM_</code> (if defined by LLVM).</p>&#13;
			<p>As mentioned previously, we are also interested in compiling clang alongside LLVM. With the <code>LLVM_ENABLE_PROJECTS=clang</code> variable setting, this allows CMake to generate the build files for clang in addition to LLVM. Furthermore, the <code>CMAKE_BUILD_TYPE=Release</code> variable tells CMake that it should generate build files for a release build.</p>&#13;
			<p>The default value for the <code>–G</code> option depends on your platform, and the default value for the build type depends on the toolchain. However, you can define your own preference with environment variables. The <code>CMAKE_GENERATOR</code> variable controls the generator, and the <code>CMAKE_BUILD_TYPE</code> variable specifies the build type. If you use <strong class="bold">bash</strong> or a similar shell, then you can set the variables with the following:</p>&#13;
			<pre class="console">&#13;
$ export CMAKE_GENERATOR=Ninja&#13;
$ export CMAKE_BUILD_TYPE=Release</pre>			<p>If you are using the Windows command prompt instead, then you set the variables with the following:</p>&#13;
			<pre class="console">&#13;
$ set CMAKE_GENERATOR=Ninja&#13;
$ set CMAKE_BUILD_TYPE=Release</pre>			<p>With these <a id="_idIndexMarker037"/>settings, the command to create the build system files becomes the following, which is easier to type:</p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_ENABLE_PROJECTS=clang -B build -S llvm</pre>			<p>You will find more about CMake variables in the <em class="italic">Customizing the build </em><em class="italic">process</em> section.</p>&#13;
			<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/>Compiling and installing LLVM</h2>&#13;
			<p>After the build files are generated, LLVM and clang can be compiled with the following:</p>&#13;
			<pre class="console">&#13;
$ cmake –-build build</pre>			<p>This command <a id="_idIndexMarker038"/>runs Ninja under the hood because we told CMake to generate Ninja files in the configuration step. However, if you generate build files for <a id="_idIndexMarker039"/>a system such as Visual Studio, which supports multiple build configurations, then you need to specify the configuration to use for the build with the <code>--config</code> option. Depending on the hardware resources, this command runs for between 15 minutes (server with lots of CPU cores, memory, and fast storage) and several hours (dual-core Windows notebook with limited memory).</p>&#13;
			<p>By default, Ninja utilizes all available CPU cores. This is good for the speed of compilation but may prevent other tasks from running; for example, on a Windows-based notebook, it is almost impossible to surf the internet while Ninja is running. Fortunately, you can limit the resource usage with the <code>–</code><code>j</code> option.</p>&#13;
			<p>Let’s assume you have four CPU cores available and Ninja should only use two (because you have parallel tasks to run); you then use this command for compilation:</p>&#13;
			<pre class="console">&#13;
$ cmake --build build –j2</pre>			<p>After compilation is finished, a best practice is to run the test suite to check whether everything works as expected:</p>&#13;
			<pre class="console">&#13;
$ cmake --build build --target check-all</pre>			<p>Again, the runtime of this command varies widely with the available hardware resources. The <code>check-all</code> Ninja target runs all test cases. Targets are generated for each directory containing test cases. Using <code>check-llvm</code> instead of <code>check-all</code> runs the LLVM tests but not the clang tests; <code>check-llvm-codegen</code> runs only the tests in the <code>CodeGen</code> directory from LLVM (that is, the <code>llvm/test/CodeGen</code> directory).</p>&#13;
			<p>You can also do a quick manual check. One of the LLVM applications is <code>-version</code> option, it shows the LLVM version, the host CPU, and all supported architectures:</p>&#13;
			<pre class="console">&#13;
$ build/bin/llc --version</pre>			<p>If you have <a id="_idIndexMarker041"/>trouble getting LLVM compiled, then you should consult the <em class="italic">Common Problems </em>section of the <em class="italic">Getting Started with the LLVM System</em> documentation https://releases.llvm.org/17.0.1/docs/GettingStarted.html#common-problems) for solutions to typical problems.</p>&#13;
			<p>As the last step, you can install the binaries:</p>&#13;
			<pre class="console">&#13;
$ cmake --install build</pre>			<p>On a Unix-like system, the install directory is <code>/usr/local</code>. On Windows, <code>C:\Program Files\LLVM</code> is used. This can be changed, of course. The next section explains how.</p>&#13;
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Customizing the build process</h1>&#13;
			<p>The CMake system uses a project description in the <code>CMakeLists.txt</code> file. The top-level file <a id="_idIndexMarker042"/>is in the <code>llvm</code> directory, <code>llvm/CMakeLists.txt</code>. Other directories also have <code>CMakeLists.txt</code> files, which are recursively included during the generation process.</p>&#13;
			<p>Based on the information provided in the project description, CMake checks which compilers are installed, detects libraries and symbols, and creates the build system files, for example, <code>build.ninja</code> or <code>Makefile</code> (depending on the chosen generator). It is also possible to define reusable modules, for example, a function to detect whether LLVM is installed. These scripts are placed in the special <code>cmake</code> directory (<code>llvm/cmake</code>), which is searched automatically during the generation process.</p>&#13;
			<p>The build process can be customized with the definition of CMake variables. The command-line option <code>–D</code> is used to set a variable to a value. The variables are used in the CMake scripts. Variables defined by CMake itself are almost always prefixed with <code>CMAKE_</code> and these variables can be used in all projects. Variables defined by LLVM are prefixed with <code>LLVM_</code> but they can only be used if the project definition includes the use of LLVM.</p>&#13;
			<h2 id="_idParaDest-32"><a id="_idTextAnchor034"/>Variables defined by CMake</h2>&#13;
			<p>Some variables are initialized with the value of environment variables. Most notable are <code>CC</code> and <code>CXX</code>, which define the C and C++ compilers to be used for building. CMake tries to locate a C and a C++ compiler automatically, using the current shell search path. It picks the <a id="_idIndexMarker043"/>first compiler found. If you have several compilers installed, for example, gcc and clang or different versions of clang, then this might not be the compiler you want for building LLVM.</p>&#13;
			<p>Suppose you like to use clang17 as a C compiler and clang++17 as a C++ compiler. Then, you can invoke CMake in a Unix shell in the following way:</p>&#13;
			<pre class="console">&#13;
$ CC=clang17 CXX=clang++17 cmake –B build –S llvm</pre>			<p>This sets the value of the environment variables only for the invocation of <code>cmake</code>. If necessary, you can specify an absolute path for the compiler executables.</p>&#13;
			<p><code>CC</code> is the default value of the <code>CMAKE_C_COMPILER</code> CMake variable, and <code>CXX</code> is the default value of the <code>CMAKE_CXX_COMPILER</code> CMake variable. Instead of using the environment variables, you can set the CMake variables directly. This is equivalent to the preceding call:</p>&#13;
			<pre class="console">&#13;
$ cmake –DCMAKE_C_COMPILER=clang17 \&#13;
  -DCMAKE_CXX_COMPILER=clang++17 –B build –S llvm</pre>			<p>Other useful variables defined by CMake are as follows:</p>&#13;
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Variable name</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Purpose</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>CMAKE_INSTALL_PREFIX</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This is a path prefix that is prepended to every path during installation. The default is <code>/usr/local</code> on Unix and <code>C:\Program Files\&lt;Project&gt;</code> on Windows. To install LLVM in the <code>/opt/llvm</code> directory, you specify <code>-DCMAKE_INSTALL_PREFIX=/opt/llvm</code>. The binaries are copied to <code>/opt/llvm/bin</code>, library files to <code>/opt/llvm/lib</code>, and so on.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>CMAKE_BUILD_TYPE</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Different types of build require different settings. For example, a debug build needs to specify options to generate debug symbols and usually link against debug versions of system libraries. In contrast, a release build uses optimization flags and links against production versions of libraries. This variable is only used for build systems that can only handle one build type, for example, Ninja or Make. For IDE build systems, all variants are generated and you have to use the mechanism of the IDE to switch between build types. Possible values are as follows:</p>&#13;
							<p><code>DEBUG</code>: build with debug symbols</p>&#13;
							<p><code>RELEASE</code>: build with optimization for speed</p>&#13;
							<p><code>RELWITHDEBINFO</code>: release build with debug symbols</p>&#13;
							<p><code>MINSIZEREL</code>: build with optimization for size</p>&#13;
							<p>The default build type is taken from the <code>CMAKE_BUILD_TYPE</code> environment variable. If this variable is not set, then the default depends on the used toolchain and is often empty. In order to generate build files for a release build, you specify <code>-DCMAKE_BUILD_TYPE=RELEASE</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>CMAKE_C_FLAGS</code></p>&#13;
							<p><code>CMAKE_CXX_FLAGS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>These are extra flags used when compiling C and C++ source files. The initial values are taken from the <code>CFLAGS</code> and <code>CXXFLAGS</code> environment variables, which can be used as an alternative.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>CMAKE_MODULE_PATH</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This specifies additional directories that are searched for CMake modules. The specified directories are searched before the default ones. The value is a semicolon-separated list of directories.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>PYTHON_EXECUTABLE</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If the Python interpreter is not found or if the wrong one is picked in case you have installed multiple versions, you can set this variable to the path of the Python binary. This variable only has an effect if the Python module of CMake is included (which is the case for LLVM).</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 - Additional useful variables provided by CMake</p>&#13;
			<p>CMake provides <a id="_idIndexMarker044"/>built-in help for variables. The <code>--help-variable var</code> option prints help for the <code>var</code> variable. For instance, you can type the following to get help for <code>CMAKE_BUILD_TYPE</code>:</p>&#13;
			<pre class="console">&#13;
$ cmake --help-variable CMAKE_BUILD_TYPE</pre>			<p>You can also list all variables with the following command:</p>&#13;
			<pre class="console">&#13;
$ cmake --help-variable-list</pre>			<p>This list is very long. You may want to pipe the output to <code>more</code> or a similar program.</p>&#13;
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Using LLVM-defined build configuration variables</h2>&#13;
			<p>The build <a id="_idIndexMarker045"/>configuration variables <a id="_idIndexMarker046"/>defined by LLVM work in the same way as those defined by CMake except that there is no built-in help. The most useful variables are found in the following tables, where they are divided into variables that <a id="_idIndexMarker047"/>are useful for first-time users installing LLVM, and also variables for more advanced LLVM users.</p>&#13;
			<h3>Variables useful for first-time users installing LLVM</h3>&#13;
			<table id="table002" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Variable name</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><strong class="bold">Purpose</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_TARGETS_TO_BUILD</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM supports code generation for different CPU architectures. By default, all these targets are built. Use this variable to specify the list of targets to build, separated by semicolons. The current targets are <code>AArch64</code>, <code>AMDGPU</code>, <code>ARM</code>, <code>AVR,</code> <code>BPF</code>, <code>Hexagon</code>, <code>Lanai</code>, <code>LoongArch</code>, <code>Mips</code>, <code>MSP430</code>, <code>NVPTX</code>, <code>PowerPC</code>, <code>RISCV</code>, <code>Sparc</code>, <code>SystemZ</code>, <code>VE</code>, <code>WebAssembly</code>, <code>X86</code>, and <code>XCore</code>. <code>all</code> can be used as shorthand for all targets. The names are case-sensitive. To only enable the PowerPC and the System Z target, you specify <code>-DLLVM_TARGETS_TO_BUILD="PowerPC;SystemZ"</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_EXPERIMENTAL_TARGETS_TO_BUILD</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>In addition to the official targets, the LLVM source tree also contains experimental targets. These targets are under development and often do not yet support the full functionality of a backend. The current list of experimental targets is <code>ARC</code>, <code>CSKY</code>, <code>DirectX</code>, <code>M68k</code>, <code>SPIRV</code>, and <code>Xtensa</code>. To build the <code>M68k</code> target, you specify <code>-</code><code>D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M68k</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_PROJECTS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This is a list of the projects you want to build, separated by semicolons. The source for the projects must be on the same level as the <code>llvm</code> directory (side-by-side layout). The current list is <code>bolt</code>, <code>clang</code>, <code>clang-tools-extra</code>, <code>compiler-rt</code>, <code>cross-project-tests</code>, <code>libc</code>, <code>libclc</code>, <code>lld</code>, <code>lldb</code>, <code>mlir</code>, <code>openmp</code>, <code>polly</code>, and <code>pstl</code>. <code>all</code> can be used as shorthand for all projects in this list. Additionally, you can specify the <code>flang</code> project here. Due to some special build requirements, it is not yet part of the <code>all</code> list.</p>&#13;
							<p>To build clang and bolt together with LLVM, you specify <code>-DLLVM_ENABLE_PROJECT="clang;bolt"</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2 - Useful variables for first-time LLVM users</p>&#13;
			<h3>Variables for advanced users of LLVM</h3>&#13;
			<table id="table003" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_ASSERTIONS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If set to <code>ON</code>, then assertion checks are enabled. These checks help to find errors and are very useful during development. The default value is <code>ON</code> for a <code>DEBUG</code> build and otherwise <code>OFF</code>. To turn assertion checks on (e.g. for a <code>RELEASE</code> build), you specify <code>–DLLVM_ENABLE_ASSERTIONS=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_EXPENSIVE_CHECKS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This enables some expensive checks that can really slow down compilation speed or consume large amounts of memory. The default value is <code>OFF</code>. To turn these checks on, you specify <code>-DLLVM_ENABLE_EXPENSIVE_CHECKS=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_APPEND_VC_REV</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM tools such as <code>llc</code> display the LLVM version they are based on besides other information if the <code>–version</code> command-line option is given. This version information is based on the <code>LLVM_REVISION</code> C macro. By default, not only the LLVM version but also the current Git hash is part of the version information. This is handy in case you are following the development of the master branch because it makes clear on which Git commit the tool is based. If not needed, then this can be turned off with <code>–DLLVM_APPEND_VC_REV=OFF</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_THREADS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM automatically includes thread support if a threading library is detected (usually the <code>pthreads</code> library). Further, LLVM assumes in this case that the compiler supports <code>-DLLVM_ENABLE_THREADS=OFF</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_EH</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>The LLVM projects do not use C++ exception handling and therefore turn exception support off by default. This setting can be incompatible with other libraries your project is linking with. If needed, you can enable exception support by specifying <code>–DLLVM_ENABLE_EH=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_RTTI</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM uses a lightweight, self-build system for runtime type information. The generation of C++ RTTI is turned off by default. Like the exception handling support, this may be incompatible with other libraries. To turn generation of C++ RTTI on, you specify <code>–DLLVM_ENABLE_RTTI=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_WARNINGS</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Compiling LLVM should generate no warning messages if possible. The option to print warning messages is therefore turned on by default. To turn it off, you specify <code>–DLLVM_ENABLE_WARNINGS=OFF</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_PEDANTIC</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>The LLVM source should be C/C++ language standard-conforming; hence, pedantic checking of the source is enabled by default. If possible, compiler-specific extensions are also disabled. To reverse this setting, you specify <code>–DLLVM_ENABLE_PEDANTIC=OFF</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_ENABLE_WERROR</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If set to <code>ON</code>, then all warnings are treated as errors – the compilation aborts as soon as warnings are found. It helps to find all remaining warnings in the source. By default, it is turned off. To turn it on, you specify <code>–DLLVM_ENABLE_WERROR=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_OPTIMIZED_TABLEGEN</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Usually, the tablegen tool is built with the same options as all other parts of LLVM. At the same time, tablegen is used to generate large parts of the code generator. As a result, tablegen is much slower in a debug build, increasing the compile time noticeably. If this option is set to <code>ON</code>, then tablegen is compiled with optimization turned on even for a debug build, possibly reducing compile time. The default is <code>OFF</code>. To turn it on, you specify <code>–DLLVM_OPTIMIZED_TABLEGEN=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><code>LLVM_USE_SPLIT_DWARF</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If the build compiler is gcc or clang, then turning on this option will instruct the compiler to generate the DWARF debug information in a separate file. The reduced size of the object files reduces the link time of debug builds significantly. The default is <code>OFF</code>. To turn it on, you specify <code>-LLVM_USE_SPLIT_DWARF=ON</code>.</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.3 - Useful variables for advanced LLVM users</p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">LLVM defines <a id="_idIndexMarker048"/>many more CMake <a id="_idIndexMarker049"/>variables. You can find the complete list in the LLVM documentation about CMake <a href="https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables">https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables</a>. The preceding list contains only the ones you are most likely to need.</p>&#13;
			<h1 id="_idParaDest-34"><a id="_idTextAnchor036"/>Summary</h1>&#13;
			<p>In this chapter, you prepared your development machine to compile LLVM. You cloned the GitHub repository and compiled your own version of LLVM and clang. The build process can be customized with CMake variables. You learned about useful variables and how to change them. Equipped with this knowledge, you can tweak LLVM to your needs.</p>&#13;
			<p>In the next section, we will be taking a closer look at the structure of a compiler. We will be exploring the different components found inside the compiler, as well as different types of analyses that occur in it – specifically, the lexical, syntactical, and semantic analyses. Finally, we will also briefly touch on interfacing with an LLVM backend for code generation.</p>&#13;
		</p>&#13;
	</div></body></html>