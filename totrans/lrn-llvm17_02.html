<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer007">&#13;
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor017"/>1</h1>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Installing LLVM</h1>&#13;
			<p>In order to learn how to work with LLVM, it is best to begin by compiling LLVM from source. LLVM is an umbrella project and the GitHub repository contains the source of all projects belonging to LLVM. Each LLVM project is in a top-level directory of the repository. Besides cloning the repository, your system must also have all tools installed that are required by the build system. In this chapter, you will learn about the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Getting the prerequisites ready, which will show you how to set up your <span class="No-Break">build system</span></li>&#13;
				<li>Cloning the repository and building from source, which will cover how to get the LLVM source code, and how to compile and install the LLVM core libraries and clang with CMake <span class="No-Break">and Ninja</span></li>&#13;
				<li>Customizing the build process, which will talk about the various possibilities for influencing the <span class="No-Break">build process</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Compiling LLVM versus installing binaries</h1>&#13;
			<p>You can install LLVM binaries from various sources. If you are using Linux, then your distribution contains the LLVM libraries. Why bother compiling <span class="No-Break">LLVM yourself?</span></p>&#13;
			<p>First, not all install <a id="_idIndexMarker000"/>packages contain all the files required for developing with LLVM. Compiling and installing LLVM yourself prevents this problem. Another reason stems from the fact that LLVM is highly customizable. With building LLVM, you learn how you can customize LLVM, and this will enable you to diagnose problems <a id="_idIndexMarker001"/>that may arise if you bring your LLVM application to another platform. And last, in the third part of this book, you will extend LLVM itself, and for this, you need the skill of building <span class="No-Break">LLVM yourself.</span></p>&#13;
			<p>However, it is perfectly fine to avoid compiling LLVM for the first steps. If you want to go on this route, then you only need to install the prerequisites as described in the <span class="No-Break">next section.</span></p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">Many Linux distributions split LLVM into several packages. Please make sure that you install the development package. For example, on Ubuntu, you need to install the <strong class="source-inline">llvm-dev</strong> package. Please also make sure that you install LLVM 17. For other versions, the examples in this book may <span class="No-Break">require changes.</span></p>&#13;
			<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/>Getting the prerequisites ready</h1>&#13;
			<p>To work with LLVM, your development system should run a common operating system such as Linux, FreeBSD, macOS, or Windows. You can build LLVM and clang in different modes. A build with debug symbols enabled can take up to 30 GB of space. The required disk space depends <a id="_idIndexMarker002"/>heavily on the chosen build options. For example, building only the LLVM core libraries in release mode, targeting only one platform, requires about 2 GB of free disk space, which is the bare <span class="No-Break">minimum needed.</span></p>&#13;
			<p>To reduce compile times, a fast CPU (such as a quad-core CPU with a 2.5 GHz clock speed) and a fast SSD are also helpful. It is even possible to build LLVM on a small device such as a Raspberry Pi – it only takes a lot of time. The examples within this book were developed on a laptop with an Intel quad-core CPU running at a 2.7 GHz clock speed, with 40 GB RAM and 2.5 TB SSD disk space. This system is well suited for the <span class="No-Break">development task.</span></p>&#13;
			<p>Your development system must have some prerequisite software installed. Let’s review the minimal required version of these <span class="No-Break">software packages.</span></p>&#13;
			<p>To check out the <a id="_idIndexMarker003"/>source from GitHub, you need <strong class="bold">Git</strong> (<a href="https://git-scm.com/">https://git-scm.com/</a>). There is no requirement for a specific version. The GitHub help pages recommend using at least version 1.17.10. Due to known security issues found in the past, it is recommended to use the latest available version, which is 2.39.1 at the time <span class="No-Break">of writing.</span></p>&#13;
			<p>The LLVM <a id="_idIndexMarker004"/>project uses <strong class="bold">CMake</strong> (<a href="https://cmake.org/">https://cmake.org/</a>) as the build file generator. At least the 3.20.0 version is required. CMake can generate build files for <a id="_idIndexMarker005"/>various build systems. In this book, <strong class="bold">Ninja</strong> (<a href="https://ninja-build.org/">https://ninja-build.org/</a>) is used because it is fast and available on all platforms. The latest version, 1.11.1, <span class="No-Break">is recommended.</span></p>&#13;
			<p>Obviously, you also <a id="_idIndexMarker006"/>need a <strong class="bold">C/C++ compiler</strong>. The LLVM projects are written in modern C++, based on the C++17 standard. A conforming compiler and standard library <a id="_idIndexMarker007"/>are required. The following compilers are known to work with <span class="No-Break">LLVM 17:</span></p>&#13;
			<ul>&#13;
				<li>gcc 7.1.0 <span class="No-Break">or later</span></li>&#13;
				<li>clang 5.0 <span class="No-Break">or later</span></li>&#13;
				<li>Apple clang 10.0 <span class="No-Break">or later</span></li>&#13;
				<li>Visual Studio 2019 16.7 <span class="No-Break">or later</span></li>&#13;
			</ul>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">Please be aware that with further development of the LLVM project, the requirements for the compiler are most likely to change. In general, you should use the latest compiler version available for <span class="No-Break">your system.</span></p>&#13;
			<p><strong class="bold">Python</strong> (<a href="https://python.org/">https://python.org/</a>) is used <a id="_idIndexMarker008"/>during the generation of the build files and for running the test suite. It should be at least the <span class="No-Break">3.8 version.</span></p>&#13;
			<p>Although not covered in this book, there can be reasons that you need to use Make instead of Ninja. In this <a id="_idIndexMarker009"/>case, you need to use <strong class="bold">GNU Make</strong> (<a href="https://www.gnu.org/software/make/">https://www.gnu.org/software/make/</a>) version 3.79 or later. The usage of both build tools is very similar. It is sufficient to replace <strong class="source-inline">ninja</strong> in each command with <strong class="source-inline">make</strong> for the scenarios <span class="No-Break">described below.</span></p>&#13;
			<p>LLVM also <a id="_idIndexMarker010"/>depends on the <strong class="source-inline">zlib</strong> library (<a href="https://www.zlib.net/">https://www.zlib.net/</a>). You should have at least version 1.2.3.4 installed. As usual, we recommend using the latest <span class="No-Break">version, 1.2.13.</span></p>&#13;
			<p>To install the prerequisite software, the easiest way is to use the package manager from your operating system. In the following sections, the commands required to install the software are shown for the most popular <span class="No-Break">operating systems.</span></p>&#13;
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Ubuntu</h2>&#13;
			<p>Ubuntu 22.04 uses the <strong class="source-inline">apt</strong> package manager. Most of the basic utilities are already installed; only the <a id="_idIndexMarker011"/>development tools are missing. To install all <a id="_idIndexMarker012"/>packages at once, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ sudo apt -y install gcc g++ git cmake ninja-build zlib1g-dev</pre>			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Fedora and RedHat</h2>&#13;
			<p>The package <a id="_idIndexMarker013"/>manager of <a id="_idIndexMarker014"/>Fedora 37 and RedHat <a id="_idIndexMarker015"/>Enterprise Linux 9 is called <strong class="source-inline">dnf</strong>. Like Ubuntu, most <a id="_idIndexMarker016"/>of the basic utilities are already installed. To install all packages at once, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ sudo dnf –y install gcc gcc-c++ git cmake ninja-build \&#13;
  zlib-devel</pre>			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>FreeBSD</h2>&#13;
			<p>On FreeBSD 13 or later, you have to use the <strong class="source-inline">pkg</strong> package manager. FreeBSD differs from <a id="_idIndexMarker017"/>Linux-based systems in that the clang compiler is already <a id="_idIndexMarker018"/>installed. To install all other packages at once, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ sudo pkg install –y git cmake ninja zlib-ng</pre>			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>OS X</h2>&#13;
			<p>For development <a id="_idIndexMarker019"/>on OS X, it is best <a id="_idIndexMarker020"/>to install <strong class="bold">Xcode</strong> from the Apple store. While the <a id="_idIndexMarker021"/>Xcode IDE is not used in this book, it comes with the required C/C++ compilers and supporting utilities. For installation of <a id="_idIndexMarker022"/>the other tools, the package manager <strong class="bold">Homebrew</strong> (<a href="https://brew.sh/">https://brew.sh/</a>) can be used. To install all packages at once, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ brew install git cmake ninja zlib</pre>			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Windows</h2>&#13;
			<p>Like OS X, Windows <a id="_idIndexMarker023"/>does not come with a package manager. For the C/C++ compiler, you <a id="_idIndexMarker024"/>need to download <strong class="bold">Visual Studio Community 2022</strong> (<a href="https://visualstudio.microsoft.com/vs/community/">https://visualstudio.microsoft.com/vs/community/</a>), which is free for personal use. Please make sure that you install the workload named <strong class="bold">Desktop Development with C++</strong>. You can <a id="_idIndexMarker025"/>use the package manager <strong class="bold">Scoop</strong> (<a href="https://scoop.sh/">https://scoop.sh/</a>) to install the other packages. After installing Scoop as described on the website, you open <strong class="bold">x64 Native Tools Command Prompt for VS 2022</strong> from your Windows menu. To install the required packages, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ scoop install git cmake ninja python gzip bzip2 coreutils&#13;
$ scoop bucket add extras&#13;
$ scoop install zlib</pre>			<p>Please watch <a id="_idIndexMarker026"/>the output from Scoop closely. For the Python and <strong class="source-inline">zlib</strong> packages, it advises adding some registry keys. These entries are needed so that other software can find these packages. To add the registry keys, you’d best copy and paste the output from Scoop, which looks like <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ %HOMEPATH%\scoop\apps\python\current\install-pep-514.reg&#13;
$ %HOMEPATH%\scoop\apps\zlib\current\register.reg</pre>			<p>After each command, a message window from the registry editor will pop up asking whether you really want to import those registry keys. You need to click on <strong class="bold">Yes</strong> to finish the import. Now all prerequisites <span class="No-Break">are installed.</span></p>&#13;
			<p>For all <a id="_idIndexMarker027"/>examples in this book, you must use the <strong class="bold">x64 Native Tools Command Prompt </strong>for VS 2022. Using this command prompt, the compiler is automatically added to the <span class="No-Break">search path.</span></p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">The LLVM code base is very large. To comfortably navigate the source, we recommend using an IDE <a id="_idIndexMarker028"/>that allows you to jump to the definition of classes and search through the source. We find <strong class="bold">Visual Studio Code</strong> (<a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a>), which is an extensible cross-platform IDE, very comfortable to use. However, this is no requirement for following the examples in <span class="No-Break">this book.</span></p>&#13;
			<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/>Cloning the repository and building from source</h1>&#13;
			<p>With the <a id="_idIndexMarker029"/>build tools ready, you can now check out all LLVM projects from GitHub and build LLVM. This process is essentially the same on <span class="No-Break">all platforms:</span></p>&#13;
			<ol>&#13;
				<li><span class="No-Break">Configure Git.</span></li>&#13;
				<li>Clone <span class="No-Break">the repository.</span></li>&#13;
				<li>Create the <span class="No-Break">build directory.</span></li>&#13;
				<li>Generate the build <span class="No-Break">system files.</span></li>&#13;
				<li>Finally, build and <span class="No-Break">install LLVM.</span></li>&#13;
			</ol>&#13;
			<p>Let’s begin with <span class="No-Break">configuring Git.</span></p>&#13;
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Configuring Git</h2>&#13;
			<p>The LLVM project uses Git for version control. If you have not used Git before, then you should do some <a id="_idIndexMarker030"/>basic configuration of Git first before continuing: to set the username and email address. Both pieces of information are used if you <span class="No-Break">commit changes.</span></p>&#13;
			<p>One can check whether they previously had an email and username already configured in Git with the <span class="No-Break">following commands:</span></p>&#13;
			<pre class="console">&#13;
$ git config user.email&#13;
$ git config user.name</pre>			<p>The preceding commands will output the respective email and username that you already have set when using Git. However, in the event that you are setting the username and email for the first time, the following commands can be entered for first-time configuration. In the following commands, you can simply replace <strong class="source-inline">Jane</strong> with your name and <strong class="source-inline">jane@email.org</strong> with <span class="No-Break">your email:</span></p>&#13;
			<pre class="console">&#13;
$ git config --global user.email "jane@email.org"&#13;
$ git config --global user.name "Jane"</pre>			<p>These commands <a id="_idIndexMarker031"/>change the global Git configuration. Inside a Git repository, you can locally overwrite those values by not specifying the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">global</strong></span><span class="No-Break"> option.</span></p>&#13;
			<p>By default, Git uses the <strong class="bold">vi</strong> editor for commit messages. If you prefer another editor, then you can change the configuration in a similar way. To use the <strong class="bold">nano</strong> editor, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ git config --global core.editor nano</pre>			<p>For more information about Git, please see the <em class="italic">Git Version Control </em><span class="No-Break"><em class="italic">Cookbook</em></span><span class="No-Break"> (</span><a href="https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545"><span class="No-Break">https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545</span></a><span class="No-Break">).</span></p>&#13;
			<p>Now you are ready to clone the LLVM repository <span class="No-Break">from GitHub.</span></p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Cloning the repository</h2>&#13;
			<p>The command to clone the repository is essentially the same on all platforms. Only on Windows, it is <a id="_idIndexMarker032"/>recommended to turn off the auto-translation of <span class="No-Break">line endings.</span></p>&#13;
			<p>On all non-Windows platforms, you type the following command to clone <span class="No-Break">the repository:</span></p>&#13;
			<pre class="console">&#13;
$ git clone https://github.com/llvm/llvm-project.git</pre>			<p>Only on Windows, add the option to disable auto-translation of line endings. Here, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ git clone --config core.autocrlf=false \&#13;
  https://github.com/llvm/llvm-project.git</pre>			<p>This Git command clones the latest source code from GitHub into a local directory named <strong class="source-inline">llvm-project</strong>. Now change the current directory into the new <strong class="source-inline">llvm-project</strong> directory with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="console">&#13;
$ cd llvm-project</pre>			<p>Inside the directory are all LLVM projects, each one in its own directory. Most notably, the LLVM core libraries are in the <strong class="source-inline">llvm</strong> subdirectory. The LLVM project uses branches for subsequent release development (“release/17.x”) and tags (“llvmorg-17.0.1”) to mark a certain release. With the preceding clone command, you get the current development state. This book uses LLVM 17. To check out the first release of LLVM 17 into a branch called <a id="_idTextAnchor029"/><strong class="source-inline">llvm-17</strong>, you type <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ git checkout -b llvm-17 llvmorg-17.0.1</pre>			<p>With the previous steps, you cloned the whole repository and created a branch from a tag. This is the most <span class="No-Break">flexible approach.</span></p>&#13;
			<p>Git also allows <a id="_idIndexMarker033"/>you to clone only a branch or a tag (including history). With <strong class="source-inline">git clone --branch release/17.x https://github.com/llvm/llvm-project</strong>, you only clone the <strong class="source-inline">release/17.x</strong> branch and its history. You then have the latest state of the LLVM 17 release branch, so you only need to create a branch from the release tag like before if you need the exact release version. With the additional <strong class="source-inline">–-depth=1</strong> option, which is <a id="_idIndexMarker034"/>known as a <strong class="bold">shallow clone with Git</strong>, you prevent the cloning of the history, too. This saves time and space but obviously limits what you can do locally, including checking out a branch based on the <span class="No-Break">release tags.</span></p>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/>Creating a build directory</h2>&#13;
			<p>Unlike many other projects, LLVM does not support inline builds and requires a separate build directory. Most easily, this is created inside the <strong class="source-inline">llvm-project</strong> directory, which is your <a id="_idIndexMarker035"/>current directory. Let us name the build directory, <strong class="source-inline">build</strong>, for simplicity. Here, the commands for Unix and Windows systems differ. On a Unix-like system, you use <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ mkdir build</pre>			<p>And on Windows, use <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ md build</pre>			<p>Now you are ready to create the build system files with the CMake tool inside <span class="No-Break">this directory.</span></p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Generating the build system files</h2>&#13;
			<p>In order to <a id="_idIndexMarker036"/>generate build system files to compile LLVM and clang using Ninja, you run <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \&#13;
  -DLLVM_ENABLE_PROJECTS=clang -B build -S llvm</pre>			<p>The <strong class="source-inline">-G</strong> option tells CMake for which system to generate build files. Often-used values for that option are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">Ninja</strong> – for the Ninja <span class="No-Break">build system</span></li>&#13;
				<li><strong class="source-inline">Unix Makefiles</strong> – for <span class="No-Break">GNU Make</span></li>&#13;
				<li><strong class="source-inline">Visual Studio 17 VS2022</strong> – for Visual Studio and <span class="No-Break">MS Build</span></li>&#13;
				<li><strong class="source-inline">Xcode</strong> – for <span class="No-Break">Xcode projects</span></li>&#13;
			</ul>&#13;
			<p>With the <strong class="source-inline">–B</strong> option, you tell CMake the path of the build directory. Similarly, you specify the source directory with the <strong class="source-inline">–S</strong> option. The generation process can be influenced by setting various variables with the <strong class="source-inline">–D</strong> option. Usually, they are prefixed with <strong class="source-inline">CMAKE_</strong> (if defined by CMake) or <strong class="source-inline">LLVM_</strong> (if defined <span class="No-Break">by LLVM).</span></p>&#13;
			<p>As mentioned previously, we are also interested in compiling clang alongside LLVM. With the <strong class="source-inline">LLVM_ENABLE_PROJECTS=clang</strong> variable setting, this allows CMake to generate the build files for clang in addition to LLVM. Furthermore, the <strong class="source-inline">CMAKE_BUILD_TYPE=Release</strong> variable tells CMake that it should generate build files for a <span class="No-Break">release build.</span></p>&#13;
			<p>The default value for the <strong class="source-inline">–G</strong> option depends on your platform, and the default value for the build type depends on the toolchain. However, you can define your own preference with environment variables. The <strong class="source-inline">CMAKE_GENERATOR</strong> variable controls the generator, and the <strong class="source-inline">CMAKE_BUILD_TYPE</strong> variable specifies the build type. If you use <strong class="bold">bash</strong> or a similar shell, then you can set the variables with <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ export CMAKE_GENERATOR=Ninja&#13;
$ export CMAKE_BUILD_TYPE=Release</pre>			<p>If you are using the Windows command prompt instead, then you set the variables with <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ set CMAKE_GENERATOR=Ninja&#13;
$ set CMAKE_BUILD_TYPE=Release</pre>			<p>With these <a id="_idIndexMarker037"/>settings, the command to create the build system files becomes the following, which is easier <span class="No-Break">to type:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_ENABLE_PROJECTS=clang -B build -S llvm</pre>			<p>You will find more about CMake variables in the <em class="italic">Customizing the build </em><span class="No-Break"><em class="italic">process</em></span><span class="No-Break"> section.</span></p>&#13;
			<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/>Compiling and installing LLVM</h2>&#13;
			<p>After the build files are generated, LLVM and clang can be compiled with <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ cmake –-build build</pre>			<p>This command <a id="_idIndexMarker038"/>runs Ninja under the hood because we told CMake to generate Ninja files in the configuration step. However, if you generate build files for <a id="_idIndexMarker039"/>a system such as Visual Studio, which supports multiple build configurations, then you need to specify the configuration to use for the build with the <strong class="source-inline">--config</strong> option. Depending on the hardware resources, this command runs for between 15 minutes (server with lots of CPU cores, memory, and fast storage) and several hours (dual-core Windows notebook with <span class="No-Break">limited memory).</span></p>&#13;
			<p>By default, Ninja utilizes all available CPU cores. This is good for the speed of compilation but may prevent other tasks from running; for example, on a Windows-based notebook, it is almost impossible to surf the internet while Ninja is running. Fortunately, you can limit the resource usage with the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">j</strong></span><span class="No-Break"> option.</span></p>&#13;
			<p>Let’s assume you have four CPU cores available and Ninja should only use two (because you have parallel tasks to run); you then use this command <span class="No-Break">for compilation:</span></p>&#13;
			<pre class="console">&#13;
$ cmake --build build –j2</pre>			<p>After compilation is finished, a best practice is to run the test suite to check whether everything works <span class="No-Break">as expected:</span></p>&#13;
			<pre class="console">&#13;
$ cmake --build build --target check-all</pre>			<p>Again, the runtime of this command varies widely with the available hardware resources. The <strong class="source-inline">check-all</strong> Ninja target runs all test cases. Targets are generated for each directory containing test cases. Using <strong class="source-inline">check-llvm</strong> instead of <strong class="source-inline">check-all</strong> runs the LLVM tests but not the clang tests; <strong class="source-inline">check-llvm-codegen</strong> runs only the tests in the <strong class="source-inline">CodeGen</strong> directory from LLVM (that is, the <span class="No-Break"><strong class="source-inline">llvm/test/CodeGen</strong></span><span class="No-Break"> directory).</span></p>&#13;
			<p>You can also do a quick manual check. One of the LLVM applications is <strong class="bold">llc</strong>, the LLVM compiler. If you <a id="_idIndexMarker040"/>run it with the <strong class="source-inline">-version</strong> option, it shows the LLVM version, the host CPU, and all <span class="No-Break">supported architectures:</span></p>&#13;
			<pre class="console">&#13;
$ build/bin/llc --version</pre>			<p>If you have <a id="_idIndexMarker041"/>trouble getting LLVM compiled, then you should consult the <em class="italic">Common Problems </em>section of the <em class="italic">Getting Started with the LLVM System</em> documentation https://releases.llvm.org/17.0.1/docs/GettingStarted.html#common-problems) for solutions to <span class="No-Break">typical problems.</span></p>&#13;
			<p>As the last step, you can install <span class="No-Break">the binaries:</span></p>&#13;
			<pre class="console">&#13;
$ cmake --install build</pre>			<p>On a Unix-like system, the install directory is <strong class="source-inline">/usr/local</strong>. On Windows, <strong class="source-inline">C:\Program Files\LLVM</strong> is used. This can be changed, of course. The next section <span class="No-Break">explains how.</span></p>&#13;
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Customizing the build process</h1>&#13;
			<p>The CMake system uses a project description in the <strong class="source-inline">CMakeLists.txt</strong> file. The top-level file <a id="_idIndexMarker042"/>is in the <strong class="source-inline">llvm</strong> directory, <strong class="source-inline">llvm/CMakeLists.txt</strong>. Other directories also have <strong class="source-inline">CMakeLists.txt</strong> files, which are recursively included during the <span class="No-Break">generation process.</span></p>&#13;
			<p>Based on the information provided in the project description, CMake checks which compilers are installed, detects libraries and symbols, and creates the build system files, for example, <strong class="source-inline">build.ninja</strong> or <strong class="source-inline">Makefile</strong> (depending on the chosen generator). It is also possible to define reusable modules, for example, a function to detect whether LLVM is installed. These scripts are placed in the special <strong class="source-inline">cmake</strong> directory (<strong class="source-inline">llvm/cmake</strong>), which is searched automatically during the <span class="No-Break">generation process.</span></p>&#13;
			<p>The build process can be customized with the definition of CMake variables. The command-line option <strong class="source-inline">–D</strong> is used to set a variable to a value. The variables are used in the CMake scripts. Variables defined by CMake itself are almost always prefixed with <strong class="source-inline">CMAKE_</strong> and these variables can be used in all projects. Variables defined by LLVM are prefixed with <strong class="source-inline">LLVM_</strong> but they can only be used if the project definition includes the use <span class="No-Break">of LLVM.</span></p>&#13;
			<h2 id="_idParaDest-32"><a id="_idTextAnchor034"/>Variables defined by CMake</h2>&#13;
			<p>Some variables are initialized with the value of environment variables. Most notable are <strong class="source-inline">CC</strong> and <strong class="source-inline">CXX</strong>, which define the C and C++ compilers to be used for building. CMake tries to locate a C and a C++ compiler automatically, using the current shell search path. It picks the <a id="_idIndexMarker043"/>first compiler found. If you have several compilers installed, for example, gcc and clang or different versions of clang, then this might not be the compiler you want for <span class="No-Break">building LLVM.</span></p>&#13;
			<p>Suppose you like to use clang17 as a C compiler and clang++17 as a C++ compiler. Then, you can invoke CMake in a Unix shell in the <span class="No-Break">following way:</span></p>&#13;
			<pre class="console">&#13;
$ CC=clang17 CXX=clang++17 cmake –B build –S llvm</pre>			<p>This sets the value of the environment variables only for the invocation of <strong class="source-inline">cmake</strong>. If necessary, you can specify an absolute path for the <span class="No-Break">compiler executables.</span></p>&#13;
			<p><strong class="source-inline">CC</strong> is the default value of the <strong class="source-inline">CMAKE_C_COMPILER</strong> CMake variable, and <strong class="source-inline">CXX</strong> is the default value of the <strong class="source-inline">CMAKE_CXX_COMPILER</strong> CMake variable. Instead of using the environment variables, you can set the CMake variables directly. This is equivalent to the <span class="No-Break">preceding call:</span></p>&#13;
			<pre class="console">&#13;
$ cmake –DCMAKE_C_COMPILER=clang17 \&#13;
  -DCMAKE_CXX_COMPILER=clang++17 –B build –S llvm</pre>			<p>Other useful variables defined by CMake are <span class="No-Break">as follows:</span></p>&#13;
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="bold">Variable name</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">CMAKE_INSTALL_PREFIX</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This is a path prefix that is prepended to every path during installation. The default is <strong class="source-inline">/usr/local</strong> on Unix and <strong class="source-inline">C:\Program Files\&lt;Project&gt;</strong> on Windows. To install LLVM in the <strong class="source-inline">/opt/llvm</strong> directory, you specify <strong class="source-inline">-DCMAKE_INSTALL_PREFIX=/opt/llvm</strong>. The binaries are copied to <strong class="source-inline">/opt/llvm/bin</strong>, library files to <strong class="source-inline">/opt/llvm/lib</strong>, and <span class="No-Break">so on.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">CMAKE_BUILD_TYPE</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Different types of build require different settings. For example, a debug build needs to specify options to generate debug symbols and usually link against debug versions of system libraries. In contrast, a release build uses optimization flags and links against production versions of libraries. This variable is only used for build systems that can only handle one build type, for example, Ninja or Make. For IDE build systems, all variants are generated and you have to use the mechanism of the IDE to switch between build types. Possible values are <span class="No-Break">as follows:</span></p>&#13;
							<p><strong class="source-inline">DEBUG</strong>: build with <span class="No-Break">debug symbols</span></p>&#13;
							<p><strong class="source-inline">RELEASE</strong>: build with optimization <span class="No-Break">for speed</span></p>&#13;
							<p><strong class="source-inline">RELWITHDEBINFO</strong>: release build with <span class="No-Break">debug symbols</span></p>&#13;
							<p><strong class="source-inline">MINSIZEREL</strong>: build with optimization <span class="No-Break">for size</span></p>&#13;
							<p>The default build type is taken from the <strong class="source-inline">CMAKE_BUILD_TYPE</strong> environment variable. If this variable is not set, then the default depends on the used toolchain and is often empty. In order to generate build files for a release build, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">-DCMAKE_BUILD_TYPE=RELEASE</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">CMAKE_C_FLAGS</strong></span></p>&#13;
							<p><span class="No-Break"><strong class="source-inline">CMAKE_CXX_FLAGS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>These are extra flags used when compiling C and C++ source files. The initial values are taken from the <strong class="source-inline">CFLAGS</strong> and <strong class="source-inline">CXXFLAGS</strong> environment variables, which can be used as <span class="No-Break">an alternative.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">CMAKE_MODULE_PATH</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This specifies additional directories that are searched for CMake modules. The specified directories are searched before the default ones. The value is a semicolon-separated list <span class="No-Break">of directories.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">PYTHON_EXECUTABLE</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If the Python interpreter is not found or if the wrong one is picked in case you have installed multiple versions, you can set this variable to the path of the Python binary. This variable only has an effect if the Python module of CMake is included (which is the case <span class="No-Break">for LLVM).</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 - Additional useful variables provided by CMake</p>&#13;
			<p>CMake provides <a id="_idIndexMarker044"/>built-in help for variables. The <strong class="source-inline">--help-variable var</strong> option prints help for the <strong class="source-inline">var</strong> variable. For instance, you can type the following to get help <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">CMAKE_BUILD_TYPE</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
$ cmake --help-variable CMAKE_BUILD_TYPE</pre>			<p>You can also list all variables with the <span class="No-Break">following command:</span></p>&#13;
			<pre class="console">&#13;
$ cmake --help-variable-list</pre>			<p>This list is very long. You may want to pipe the output to <strong class="source-inline">more</strong> or a <span class="No-Break">similar program.</span></p>&#13;
			<h2 id="_idParaDest-33"><a id="_idTextAnchor035"/>Using LLVM-defined build configuration variables</h2>&#13;
			<p>The build <a id="_idIndexMarker045"/>configuration variables <a id="_idIndexMarker046"/>defined by LLVM work in the same way as those defined by CMake except that there is no built-in help. The most useful variables are found in the following tables, where they are divided into variables that <a id="_idIndexMarker047"/>are useful for first-time users installing LLVM, and also variables for more advanced <span class="No-Break">LLVM users.</span></p>&#13;
			<h3>Variables useful for first-time users installing LLVM</h3>&#13;
			<table id="table002" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="bold">Variable name</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_TARGETS_TO_BUILD</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM supports code generation for different CPU architectures. By default, all these targets are built. Use this variable to specify the list of targets to build, separated by semicolons. The current targets are <strong class="source-inline">AArch64</strong>, <strong class="source-inline">AMDGPU</strong>, <strong class="source-inline">ARM</strong>, <strong class="source-inline">AVR,</strong> <strong class="source-inline">BPF</strong>, <strong class="source-inline">Hexagon</strong>, <strong class="source-inline">Lanai</strong>, <strong class="source-inline">LoongArch</strong>, <strong class="source-inline">Mips</strong>, <strong class="source-inline">MSP430</strong>, <strong class="source-inline">NVPTX</strong>, <strong class="source-inline">PowerPC</strong>, <strong class="source-inline">RISCV</strong>, <strong class="source-inline">Sparc</strong>, <strong class="source-inline">SystemZ</strong>, <strong class="source-inline">VE</strong>, <strong class="source-inline">WebAssembly</strong>, <strong class="source-inline">X86</strong>, and <strong class="source-inline">XCore</strong>. <strong class="source-inline">all</strong> can be used as shorthand for all targets. The names are case-sensitive. To only enable the PowerPC and the System Z target, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">-DLLVM_TARGETS_TO_BUILD="PowerPC;SystemZ"</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_EXPERIMENTAL_TARGETS_TO_BUILD</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>In addition to the official targets, the LLVM source tree also contains experimental targets. These targets are under development and often do not yet support the full functionality of a backend. The current list of experimental targets is <strong class="source-inline">ARC</strong>, <strong class="source-inline">CSKY</strong>, <strong class="source-inline">DirectX</strong>, <strong class="source-inline">M68k</strong>, <strong class="source-inline">SPIRV</strong>, and <strong class="source-inline">Xtensa</strong>. To build the <strong class="source-inline">M68k</strong> target, you specify <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M68k</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_PROJECTS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This is a list of the projects you want to build, separated by semicolons. The source for the projects must be on the same level as the <strong class="source-inline">llvm</strong> directory (side-by-side layout). The current list is <strong class="source-inline">bolt</strong>, <strong class="source-inline">clang</strong>, <strong class="source-inline">clang-tools-extra</strong>, <strong class="source-inline">compiler-rt</strong>, <strong class="source-inline">cross-project-tests</strong>, <strong class="source-inline">libc</strong>, <strong class="source-inline">libclc</strong>, <strong class="source-inline">lld</strong>, <strong class="source-inline">lldb</strong>, <strong class="source-inline">mlir</strong>, <strong class="source-inline">openmp</strong>, <strong class="source-inline">polly</strong>, and <strong class="source-inline">pstl</strong>. <strong class="source-inline">all</strong> can be used as shorthand for all projects in this list. Additionally, you can specify the <strong class="source-inline">flang</strong> project here. Due to some special build requirements, it is not yet part of the <span class="No-Break"><strong class="source-inline">all</strong></span><span class="No-Break"> list.</span></p>&#13;
							<p>To build clang and bolt together with LLVM, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">-DLLVM_ENABLE_PROJECT="clang;bolt"</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.2 - Useful variables for first-time LLVM users</p>&#13;
			<h3>Variables for advanced users of LLVM</h3>&#13;
			<table id="table003" class="No-Table-Style _idGenTablePara-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_ASSERTIONS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If set to <strong class="source-inline">ON</strong>, then assertion checks are enabled. These checks help to find errors and are very useful during development. The default value is <strong class="source-inline">ON</strong> for a <strong class="source-inline">DEBUG</strong> build and otherwise <strong class="source-inline">OFF</strong>. To turn assertion checks on (e.g. for a <strong class="source-inline">RELEASE</strong> build), you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_ASSERTIONS=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_EXPENSIVE_CHECKS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>This enables some expensive checks that can really slow down compilation speed or consume large amounts of memory. The default value is <strong class="source-inline">OFF</strong>. To turn these checks on, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">-DLLVM_ENABLE_EXPENSIVE_CHECKS=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_APPEND_VC_REV</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM tools such as <strong class="source-inline">llc</strong> display the LLVM version they are based on besides other information if the <strong class="source-inline">–version</strong> command-line option is given. This version information is based on the <strong class="source-inline">LLVM_REVISION</strong> C macro. By default, not only the LLVM version but also the current Git hash is part of the version information. This is handy in case you are following the development of the master branch because it makes clear on which Git commit the tool is based. If not needed, then this can be turned off <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">–DLLVM_APPEND_VC_REV=OFF</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_THREADS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM automatically includes thread support if a threading library is detected (usually the <strong class="source-inline">pthreads</strong> library). Further, LLVM assumes in this case that the compiler supports <strong class="bold">TLS</strong> (<strong class="bold">thread-local storage</strong>). If you don’t want thread support or your compiler does not support TLS, then you can turn it off <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">-DLLVM_ENABLE_THREADS=OFF</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_EH</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>The LLVM projects do not use C++ exception handling and therefore turn exception support off by default. This setting can be incompatible with other libraries your project is linking with. If needed, you can enable exception support by <span class="No-Break">specifying </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_EH=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_RTTI</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>LLVM uses a lightweight, self-build system for runtime type information. The generation of C++ RTTI is turned off by default. Like the exception handling support, this may be incompatible with other libraries. To turn generation of C++ RTTI on, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_RTTI=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_WARNINGS</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Compiling LLVM should generate no warning messages if possible. The option to print warning messages is therefore turned on by default. To turn it off, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_WARNINGS=OFF</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_PEDANTIC</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>The LLVM source should be C/C++ language standard-conforming; hence, pedantic checking of the source is enabled by default. If possible, compiler-specific extensions are also disabled. To reverse this setting, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_PEDANTIC=OFF</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_ENABLE_WERROR</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If set to <strong class="source-inline">ON</strong>, then all warnings are treated as errors – the compilation aborts as soon as warnings are found. It helps to find all remaining warnings in the source. By default, it is turned off. To turn it on, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_ENABLE_WERROR=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_OPTIMIZED_TABLEGEN</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>Usually, the tablegen tool is built with the same options as all other parts of LLVM. At the same time, tablegen is used to generate large parts of the code generator. As a result, tablegen is much slower in a debug build, increasing the compile time noticeably. If this option is set to <strong class="source-inline">ON</strong>, then tablegen is compiled with optimization turned on even for a debug build, possibly reducing compile time. The default is <strong class="source-inline">OFF</strong>. To turn it on, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">–DLLVM_OPTIMIZED_TABLEGEN=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style">&#13;
							<p><span class="No-Break"><strong class="source-inline">LLVM_USE_SPLIT_DWARF</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style">&#13;
							<p>If the build compiler is gcc or clang, then turning on this option will instruct the compiler to generate the DWARF debug information in a separate file. The reduced size of the object files reduces the link time of debug builds significantly. The default is <strong class="source-inline">OFF</strong>. To turn it on, you <span class="No-Break">specify </span><span class="No-Break"><strong class="source-inline">-LLVM_USE_SPLIT_DWARF=ON</strong></span><span class="No-Break">.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.3 - Useful variables for advanced LLVM users</p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">LLVM defines <a id="_idIndexMarker048"/>many more CMake <a id="_idIndexMarker049"/>variables. You can find the complete list in the LLVM documentation about CMake <a href="https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables">https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables</a>. The preceding list contains only the ones you are most likely <span class="No-Break">to need.</span></p>&#13;
			<h1 id="_idParaDest-34"><a id="_idTextAnchor036"/>Summary</h1>&#13;
			<p>In this chapter, you prepared your development machine to compile LLVM. You cloned the GitHub repository and compiled your own version of LLVM and clang. The build process can be customized with CMake variables. You learned about useful variables and how to change them. Equipped with this knowledge, you can tweak LLVM to <span class="No-Break">your needs.</span></p>&#13;
			<p>In the next section, we will be taking a closer look at the structure of a compiler. We will be exploring the different components found inside the compiler, as well as different types of analyses that occur in it – specifically, the lexical, syntactical, and semantic analyses. Finally, we will also briefly touch on interfacing with an LLVM backend for <span class="No-Break">code generation.</span></p>&#13;
		</div>&#13;
	</div></body></html>