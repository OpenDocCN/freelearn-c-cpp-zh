["```cpp\n// Example 01\nclass Base {\n  public:\n  bool TheAlgorithm() {\n    if (!Step1()) return false; // Step 1 failed\n    Step2();\n    return true;\n  }\n};\n```", "```cpp\n// Example 01\nclass Base {\n  public:\n  ...\n  virtual bool Step1() { return true };\n  virtual void Step2() = 0;\n};\nclass Derived1 : public Base {\n  public:\n  void Step2() override { ... do the work ... }\n};\nclass Derived2 : public Base {\n  public:\n  bool Step1() override { ... check preconditions ... }\n  void Step2() override { ... do the work ... }\n};\n```", "```cpp\n// Example 02\nclass Character {\n  public:\n  virtual void CombatTurn() = 0;\n  protected:\n  int health_;\n};\nclass Swordsman : public Character {\n  bool wielded_sword_;\n  public:\n  void CombatTurn() override {\n    if (health_ < 5) { // Critically injured\n      Flee();\n      return;\n    }\n    if (!wielded_sword_) {\n      Wield();\n      return; // Wielding takes a full turn\n    }\n    Attack();\n  }\n};\nclass Wizard : public Character {\n  int mana_;\n  bool scroll_ready_;\n  public:\n  void CombatTurn() override {\n    if (health_ < 2 ||\n        mana_ == 0) { // Critically injured or out of mana\n      Flee();\n      return;\n    }\n    if (!scroll_ready_) {\n      ReadScroll();\n      return; // Reading takes a full turn\n    }\n    CastSpell();\n  }\n};\n```", "```cpp\n// Example 03\nclass Character {\n  public:\n  void CombatTurn() {\n    if (MustFlee()) {\n      Flee();\n      return;\n    }\n    if (!Ready()) {\n      GetReady();\n      return; // Getting ready takes a full turn\n    }\n    CombatAction();\n  }\n  virtual bool MustFlee() const = 0;\n  virtual bool Ready() const = 0;\n  virtual void GetReady() = 0;\n  virtual void CombatAction() = 0;\n  protected:\n  int health_;\n};\n```", "```cpp\n// Example 03\nclass Swordsman : public Character {\n  bool wielded_sword_;\n  public:\n  bool MustFlee() const override { return health_ < 5; }\n  bool Ready() const override { return wielded_sword_; }\n  void GetReady()override { Wield(); }\n  void CombatAction()override { Attack(); }\n};\nclass Wizard : public Character {\n  int mana_;\n  bool scroll_ready_;\n  public:\n  bool MustFlee() const override { return health_ < 2 ||\n                                          mana_ == 0; }\n  bool Ready() const override { return scroll_ready_; }\n  void GetReady() override { ReadScroll(); }\n  void CombatAction() override { CastSpell(); }\n};\n```", "```cpp\n// Example 04\nclass Base {\n  public:\n  void VerifiedAction() {\n    assert(StateIsValid());\n    ActionImpl();\n    assert(StateIsValid());\n  }\n  virtual void ActionImpl() = 0;\n};\nclass Derived : public Base {\n  public:\n  void ActionImpl() override { ... real implementation ...}\n};\n```", "```cpp\n// Example 04\nclass Base {\n  bool StateIsValid() const {\n    return actions_started_ == actions_completed_;\n  }\n  protected:\n  size_t actions_started_ = 0;\n  size_t actions_completed_ = 0;\n  public:\n  void VerifiedAction() {\n    assert(StateIsValid());\n    ActionImpl();\n    assert(StateIsValid());\n  }\n  virtual void ActionImpl() = 0;\n};\nclass Derived : public Base {\n  public:\n  void ActionImpl() override {\n    ++actions_started_;\n    ... perform the action ...\n    ++actions_completed_;\n  }\n};\n```", "```cpp\n// Example 05\nclass Base {\n  bool StateIsValid() const {\n    return actions_started_ ==\n      actions_completed_ + actions_failed_;\n  }\n  protected:\n  size_t actions_started_ = 0;\n  size_t actions_completed_ = 0;\n  size_t actions_failed_ = 0;\n  ...\n};\nclass Derived : public Base {\n  public:\n  void ActionImpl() override {\n    ++actions_started_;\n    try {\n      ... perform the action – may throw ...\n      ++actions_completed_;\n    } catch (...) {\n      ++actions_failed_;\n    }\n  }\n};\n```", "```cpp\n// Example 06\nclass FileWriter {\n  public:\n  void Write(const char* data) {\n    Preamble(data);\n    ... write data to a file ...\n    Postscript(data);\n  }\n  virtual void Preamble(const char* data) {}\n  virtual void Postscript(const char* data) {}\n};\nclass LoggingFileWriter : public FileWriter {\n  public:\n  using FileWriter::FileWriter;\n  void Preamble(const char* data) override {\n    std::cout << \"Writing \" << data << \" to the file\" <<\n      std::endl;\n  }\n  void Postscript (const char*) override {\n    std::cout << \"Writing done\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 07\nclass Base {\n  public:\n  void method1() { method2(); method3(); }\n  virtual void method2() { ... }\n  private:\n  virtual void method3() { ... }\n};\nclass Derived : public Base {\n  private:\n  void method2() override { ... }\n  void method3() override { ... }\n};\n```", "```cpp\n// Example 07\nDerived* d = new Derived;\nBase* b = d;\nb->method2();    // OK, calls Derived::method2()\nd->method2();    // Does not compile – private function\n```", "```cpp\n// Example 08 (NVI version of example 01)\nclass Base {\n  public:\n  bool TheAlgorithm() {\n    if (!Step1()) return false; // Step 1 failed\n    Step2();\n    return true;\n  }\n  private:\n  virtual bool Step1() { return true };\n  virtual void Step2() = 0;\n};\nclass Derived1 : public Base {\n  void Step2() override { ... do the work ... }\n};\nclass Derived2 : public Base {\n  bool Step1() override { ... check preconditions ... }\n  void Step2() override { ... do the work ... }\n};\n```", "```cpp\n// Example 09 (NVI version of example 06)\nclass FileWriter {\n  virtual void Preamble(const char* data) {}\n  virtual void Postscript(const char* data) {}\n  public:\n  void Write(const char* data) {\n    Preamble(data);\n    ... write data to a file ...\n    Postscript(data);\n  }\n};\nclass LoggingFileWriter : public FileWriter {\n  using FileWriter::FileWriter;\n  void Preamble(const char* data) override {\n    std::cout << \"Writing \" << data << \" to the file\" <<\n      std::endl;\n  }\n  void Postscript (const char*) override {\n    std::cout << \"Writing done\" << std::endl;\n  }\n};\n```", "```cpp\n// Example 10\nclass Base {\n  public:\n  void Send() { // Template Method used here\n    ... open connection ...\n    SendData(); // Customization point\n    ... close connection ...\n  }\n  protected:\n  virtual void SendData() { ... send base class data ... }\n  private:\n  ... data ...\n};\nclass Derived : public Base {\n  protected:\n  void SendData() {\n    Base::SendData();\n    ... send derived class data ...\n  }\n};\n```", "```cpp\n// Example 11\nclass CommunicationStrategy {\n  public:\n  virtual void Open() = 0;\n  virtual void Close() = 0;\n  virtual void Send(int v) = 0;\n  virtual void Send(long v) = 0;\n  virtual void Send(double v) = 0;\n  ... Send other types ...\n};\n```", "```cpp\n// Example 11\nclass Base {\n  public:\n  void Send(CommunicationStrategy* comm) {\n    comm->Open();\n    SendData(comm);\n    comm->Close();\n  }\n  protected:\n  virtual void SendData(CommunicationStrategy* comm) {\n    comm->Send(i_);\n    ... send all data ...\n  }\n  private:\n  int i_;\n  ... other data members ...\n};\n```", "```cpp\n// Example 12\nclass Base {\n  public:\n  ~Base() { // Non-virtual interface!\n    std::cout << \"Deleting now\" << std::endl;\n    clear(); // Employing Template Method here\n    std::cout << \"Deleting done\" << std::endl;\n  }\n  protected:\n  virtual void clear() { ... } // Customizable part\n};\nclass Derived : public Base {\n  private:\n  void clear() override {\n    ...\n    Base::clear();\n  }\n};\n```", "```cpp\nclass CountingFileWriter : public FileWriter {\n  size_t count_ = 0;\n  void Preamble(const char* data) {\n    count_ += strlen(data);\n  }\n};\n```", "```cpp\nclass CountingLoggingFileWriter : public LoggingFileWriter {\n  size_t count_ = 0;\n  void Preamble(const char* data) {\n    count_ += strlen(data);\n    LoggingFileWriter::Preamble(data);\n  }\n};\n```", "```cpp\nclass FileWriter {\n  public:\n  void Write(const char* data) {\n    Preamble(data);\n    ... write data to a file ...\n    Postscript(data);\n  }\n  void Write(std::vector<const char*> huge_data) {\n    Preamble(huge_data);\n    for (auto data: huge_data) {\n      ... write data to file ...\n    }\n    Postscript(huge_data);\n  }\n  private:\n  virtual void Preamble(std::vector<const char*> data) {}\n  virtual void Postscript(std::vector<const char*> data) {}\n  virtual void Preamble(const char* data) {}\n  virtual void Postscript(const char* data) {}\n};\n```", "```cpp\nclass CountingFileWriter : public FileWriter {\n  size_t count_ = 0;\n  void Preamble(std::vector<const char*> huge_data) {\n    for (auto data: huge_data) count_ += strlen(data);\n  }\n  void Preamble(const char* data) {\n    count_ += strlen(data);\n  }\n};\n```", "```cpp\nclass FileWriter {\n  public:\n  void Write(const char* data) { ... no changes here ... }\n  void Write(std::vector<const char*> huge_data) {\n    Preamble(huge_data);\n    for (auto data: huge_data) Write(data); // Code reuse!\n    Postscript(huge_data);\n  }\n  private:\n  ... no changes here ...\n};\n```", "```cpp\nstd::vector<int> v = ... some data ...\nauto it = std::find_if(v.begin(), v.end(),\n                       [](int i) { return i & 1; });\nif (it != v.end()) { ... } // even value found\n```", "```cpp\n// Example 15\nvoid f() { ... }\ntemplate <typename T> struct A {\n  void f() const { ... }\n};\ntemplate <typename T> struct B : public A<T> {\n  void h() { f(); }\n};\nB<int> b;\nb.h();\n```", "```cpp\n// Example 15\n// No f() here!\ntemplate <typename T> struct A {\n  void f() const { ... }\n};\ntemplate <typename T> struct B : public A<T> {\n  void h() { f(); } // Should not compile!\n};\nB<int> b;\nb.h();\n```", "```cpp\n// Example 15\ntemplate <typename T> struct A {\n  void f() const { ... }\n};\ntemplate <typename T> struct B : public A<T> {\n  void h() { this->f(); } // Definitely A::f()\n};\nB<int> b;\nb.h();\n```"]