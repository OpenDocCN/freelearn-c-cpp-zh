- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Working with C Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与C库协同工作
- en: In [*Chapter 6*](Chapter_06.xhtml), we discussed interoperability between C
    and C++. We learned about language linkage and how to use it to include C libraries
    in a C++ project. From the technical standpoint, that’s all we need to use C in
    C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](Chapter_06.xhtml)中，我们讨论了C和C++之间的互操作性。我们学习了语言链接以及如何使用它将C库包含在C++项目中。从技术角度来看，这就是我们在C++中使用C所需的一切。
- en: In this chapter, we’ll focus on software development techniques for integrating
    C libraries into a C++ project to enhance code flexibility. Since many C++ projects
    still rely on vendor-provided C **hardware abstraction layers** (**HALs**), we’ll
    concentrate on how to effectively incorporate these C libraries into our projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注将C库集成到C++项目中以增强代码灵活性的软件开发技术。由于许多C++项目仍然依赖于供应商提供的C **硬件抽象层**（**HALs**），我们将集中讨论如何有效地将这些C库集成到我们的项目中。
- en: Additionally, this chapter will cover the **Resource Acquisition is Initialization**
    (**RAII**) paradigm and explain why it’s particularly beneficial in embedded systems.
    By automatically managing resource allocation and deallocation, RAII greatly reduces
    the risk of leaks and other resource misuse issues, which is especially important
    in resource-limited embedded environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还将涵盖**资源获取即初始化**（**RAII**）范式，并解释为什么它在嵌入式系统中特别有益。通过自动管理资源分配和释放，RAII大大降低了泄漏和其他资源误用问题的风险，这在资源受限的嵌入式环境中尤为重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Using C HAL in C++ projects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++项目中使用C HAL
- en: Static classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类
- en: Using RAII for wrapping `LittleFs` C library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RAII封装`LittleFs` C库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13)).
    To get the most out of this chapter, run the examples in the Renode simulator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13)）。为了充分利用本章内容，请在Renode模拟器中运行示例。
- en: Using C HAL in C++ projects
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++项目中使用C HAL
- en: In [*Chapter 12*](Chapter_12.xhtml), we explored the benefits of using C++ for
    HAL development. However, despite these advantages, target vendors provide HALs
    as C libraries. These libraries have been thoroughly tested on millions of devices
    worldwide, and vendors usually maintain them well, offering regular updates. Thus,
    it makes more sense to use them rather than re-implement the HAL in C++.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](Chapter_12.xhtml)中，我们探讨了使用C++进行HAL开发的优点。然而，尽管有这些优点，目标供应商提供的HALs是以C库的形式。这些库在全球数百万台设备上经过了彻底测试，供应商通常维护得很好，提供定期更新。因此，使用它们而不是在C++中重新实现HAL更有意义。
- en: Next, we will create an interface-based design for the UART peripheral, which
    will provide us with a more flexible software design and allow us to decouple
    components that are using the UART interface from low-level details.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为UART外设创建一个基于接口的设计，这将为我们提供一个更灵活的软件设计，并允许我们将使用UART接口的组件与底层细节解耦。
- en: UART interface for flexible software design
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于灵活软件设计的UART接口
- en: In [*Chapter 5*](Chapter_05.xhtml), we covered the importance of interfaces
    for flexible software design. There, we had an `uart` interface class that was
    implemented by the `uart_stm32` class. The `gsm_lib` class depended on the `uart`
    interface, meaning we can reuse it with different `uart` interface implementations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](Chapter_05.xhtml)中，我们讨论了接口对于灵活软件设计的重要性。在那里，我们有一个由`uart_stm32`类实现的`uart`接口类。`gsm_lib`类依赖于`uart`接口，这意味着我们可以与不同的`uart`接口实现重用它。
- en: 'The `uart_stm32` class from [*Chapter 5*](Chapter_05.xhtml) had a simple implementation
    for demo purposes. It used the `printf` and `putc` functions from the C standard
    library to write messages on standard output. We will now go through the actual
    implementation of the `uart_stm32` class that’s already been used in all the examples
    in the book’s GitHub repo, enabling us to see the output in the Renode simulator.
    Let’s start from the `uart` interface `class` with the code shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[*第5章*](Chapter_05.xhtml)的`uart_stm32`类为了演示目的具有简单的实现。它使用C标准库中的`printf`和`putc`函数在标准输出上写入消息。现在，我们将通过实际实现`uart_stm32`类，该类已在书中GitHub仓库的所有示例中使用，使我们能够在Renode模拟器中看到输出。让我们从以下代码所示的`uart`接口`class`开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `uart` interface is a simple class with two virtual methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`uart` 接口是一个简单的类，包含两个虚拟方法：'
- en: '`virtual void init(std::uint32_t baudrate)`: A method used to initialize the
    UART peripheral with a single parameter – `baudrate`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual void init(std::uint32_t baudrate)`: 用于使用单个参数 `baudrate` 初始化 UART 外设的函数。'
- en: '`virtual void write(std::span<const char> data)`: A method used to send data
    over the UART peripheral. It has a `std::span<const char>` parameter in contrast
    to the usual C approach with a pointer to the data buffer and length. Using `std::span`
    increases the memory safety of the code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual void write(std::span<const char> data)`: 用于通过 UART 外设发送数据的函数。它有一个
    `std::span<const char>` 参数，与通常的 C 方法中使用数据缓冲区指针和长度的方法不同。使用 `std::span` 提高了代码的内存安全性。'
- en: 'Next, let us go through the `uart_stm32` class definition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过 `uart_stm32` 类的定义来了解其实现：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `uart_stm32` class definition, we can notice the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uart_stm32` 类定义中，我们可以注意到以下内容：
- en: Overridden virtual methods `init` and `write` from the `uart` interface.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写了 `uart` 接口的虚拟方法 `init` 和 `write`。
- en: A constructor accepting a pointer to `USART_TypeDef`. This type is a `struct`
    that describes the UART peripheral register layout in the CMSIS header `stm32f072xb.h`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 `USART_TypeDef` 指针的构造函数。此类型是一个 `struct`，它描述了 CMSIS 头文件 `stm32f072xb.h` 中
    UART 外设寄存器布局。
- en: Among the private members, we see `UART_HandleTypeDef`, a type defined in ST
    HAL in the file `stm32f0xx_hal_uart.h`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在私有成员中，我们看到 `UART_HandleTypeDef`，这是一个在 `stm32f0xx_hal_uart.h` 文件中定义的类型，由 ST
    HAL 提供。
- en: 'Next, let us go through the implementation of the constructor and methods from
    the `uart_stm32` class in this code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过这段代码中的 `uart_stm32` 类的构造函数和方法的实现来了解其实现过程：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we see the implementation of the `uart_stm32` constructor. It
    just sets the private member `USART_TypeDef *instance_` using the initializer
    list syntax. CMSIS defines the macros `USART1`, `USART2`, `USART3`, and `USART4`,
    which specify the addresses of these peripherals and which we can use to initialize
    the `uart_stm32` object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们看到 `uart_stm32` 构造函数的实现。它只是使用初始化列表语法设置私有成员 `USART_TypeDef *instance_`。CMSIS
    定义了宏 `USART1`、`USART2`、`USART3` 和 `USART4`，它们指定了这些外设的地址，我们可以使用它们来初始化 `uart_stm32`
    对象。
- en: 'The `uart` interface defines the `init` method, as UART peripheral initialization
    depends on other hardware initializations (i.e., clock configuration). If we implemented
    the initialization within the constructor, we might run into issues if someone
    defines a `global` or `static` `uart_stm32` object. The `init` method is shown
    here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`uart` 接口定义了 `init` 方法，因为 UART 外设初始化依赖于其他硬件初始化（例如时钟配置）。如果我们将在构造函数中实现初始化，那么如果有人定义了一个
    `global` 或 `static` 的 `uart_stm32` 对象，我们可能会遇到问题。`init` 方法如下所示：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `init` method, we initialize the member `UART_HandleTypeDef huart_`
    with the following configuration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 方法中，我们使用以下配置初始化成员 `UART_HandleTypeDef huart_`：
- en: '`instance_`: The address to the UART peripheral selected in the constructor'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance_`: 构造函数中选择的 UART 外设的地址'
- en: '`baudrate`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baudrate`'
- en: 8-bit word length
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 位字长
- en: 1 stop bit
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个停止位
- en: Both TX and RX mode
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时启用 TX 和 RX 模式
- en: No hardware control
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无硬件控制
- en: We also set `MspInitCallback` to `nullptr`. We make a call to the ST HAL `HAL_UART_Init`
    function providing it with a pointer to `huart_`. Please note that for the sake
    of example simplicity, there is no error handling. Error handling is an important
    step, and return codes from HAL should be appropriately handled in code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `MspInitCallback` 设置为 `nullptr`。我们调用 ST HAL 的 `HAL_UART_Init` 函数，并提供 `huart_`
    的指针。请注意，为了示例的简单性，这里没有错误处理。错误处理是一个重要的步骤，HAL 的返回代码应该在代码中适当处理。
- en: 'Next, we will go through the implementation of the `write` method shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过以下内容了解 `write` 方法的实现：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `write` method, we are making a call to `HAL_UART_Transmit` from ST HAL,
    by passing the data pointer and data size from the `std::span<const char> data`
    parameter. It’s worth noting that we need to cast away constness as the C `HAL_UART_Transmit`
    function doesn’t accept the const pointer to data. This is only safe to do if
    we are sure that the function we are passing the pointer with cast away constness
    is not trying to modify its content.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `write` 方法中，我们通过传递 `std::span<const char> data` 参数中的数据指针和数据大小，调用 ST HAL 的
    `HAL_UART_Transmit` 函数。值得注意的是，我们需要取消 const 属性，因为 C 的 `HAL_UART_Transmit` 函数不接受指向数据的
    const 指针。只有在确定我们将指针传递给取消 const 属性的函数不会修改其内容时，这样做才是安全的。
- en: Next, we will analyze this approach from the perspective of software design
    and patterns used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从软件设计和使用的模式的角度分析这种方法。
- en: The UART interface in the Adapter pattern
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式中的UART接口
- en: 'The relationship between all the software components in this example (the `uart`
    interface, the `uart_stm32` implementation of the interface, and the ST HAL) can
    be represented by the following UML diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中所有软件组件之间的关系（`uart`接口、接口的实现`uart_stm32`和ST HAL）可以用以下UML图表示：
- en: '![Figure 13.1 – The uart_stm32 class diagram](img/B22402_13_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – `uart_stm32`类图](img/B22402_13_01.png)'
- en: Figure 13.1 – The uart_stm32 class diagram
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – `uart_stm32`类图
- en: In *Figure 13.1*, we see the UML class diagram of the `uart_stm32` class. This
    class effectively implements the **Adapter design pattern**, which is a structural
    design pattern used to allow classes with incompatible interfaces to work together.
    The Adapter pattern involves creating an adapter class that wraps an existing
    class (or module) and provides a new interface that the client expects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.1*中，我们看到`uart_stm32`类的UML类图。这个类有效地实现了**适配器设计模式**，这是一种结构设计模式，用于允许具有不兼容接口的类协同工作。适配器模式涉及创建一个适配器类，它包装现有的类（或模块），并提供客户端期望的新接口。
- en: In our case, even though `stm32f0xx_hal_uart` is a C module rather than a C++
    class, the `uart_stm32` class serves as an adapter by encapsulating the C-based
    HAL code and exposing it through the C++ `uart` interface. This adaptation allows
    other classes or clients in the system, such as a `GSM` library, to interact with
    the UART hardware using the standardized C++ interface, without needing to concern
    themselves with the underlying C implementation details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，即使`stm32f0xx_hal_uart`是一个C模块而不是C++类，`uart_stm32`类通过封装基于C的HAL代码并通过C++
    `uart`接口暴露它来充当适配器。这种适配允许系统中的其他类或客户端，如`GSM`库，使用标准化的C++接口与UART硬件交互，而不必关心底层的C实现细节。
- en: 'Let us analyze this approach from the perspective of the `uart` interface client,
    such as a `GSM` library that is implemented in the `gsm_lib` class, with this
    definition:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`uart`接口客户端的角度来分析这种方法，例如在`gsm_lib`类中实现的`GSM`库，其定义如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we see an example of a simple client of the `uart` interface
    – `gsm_lib` – with a constructor that initializes the reference `hal::uart &uart_`.
    This approach is called **dependency injection**. The dependency of the `gsm_lib`
    class is constructed externally and supplied to the class as a reference through
    the constructor. Depending on the interface also enables loose coupling, which
    brings the following benefits:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们看到`uart`接口的一个简单客户端示例 – `gsm_lib` – 它有一个构造函数，用于初始化引用`hal::uart &uart_`。这种方法被称为**依赖注入**。`gsm_lib`类的依赖外部构建并通过构造函数作为引用提供给类。根据接口的依赖也允许松耦合，这带来了以下好处：
- en: '`gsm_lib` is not interested in the implementation details of the `uart` interface.
    It doesn’t need to know about baud rate, hardware settings, etc.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsm_lib`对`uart`接口的实现细节不感兴趣。它不需要了解波特率、硬件设置等。'
- en: '`gsm_lib` is not tied to a particular target. We can reuse it on different
    platforms by implementing the `uart` interface on those platforms.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsm_lib`与特定目标无关。我们可以通过在这些平台上实现`uart`接口来在不同的平台上重用它。'
- en: Software testing of `gsm_lib` is easy as we can mock the `uart` interface and
    instantiate the `gsm_lib` object with the mocked object used in tests.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`gsm_lib`的软件测试很容易，因为我们可以在测试中使用模拟的`uart`接口，并用模拟对象实例化`gsm_lib`对象。
- en: Instead of directly using the C HAL library in the `uart_stm32` class, we can
    wrap the functions from the C library in a so-called `static` class with the direct
    mapping of all parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`uart_stm32`类中，我们不是直接使用C HAL库，而是可以将C库中的函数包装在一个所谓的`static`类中，该类具有所有参数的直接映射。
- en: Introducing static classes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入静态类
- en: The `static` class concept that we will discuss here doesn’t exist in the C++
    language standard. We are borrowing it from languages such as C#, where it is
    defined as a class that contains only `static` members and methods. It can’t be
    instantiated. In C#, a `static` class is declared using the `static` keyword.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的`static`类概念在C++语言标准中并不存在。我们是从像C#这样的语言中借用的它，在C#中，它被定义为只包含`static`成员和方法的类。它不能被实例化。在C#中，使用`static`关键字来声明一个`static`类。
- en: 'In C++, a `static` class can be created by defining a class with all `static`
    methods and members and by deleting the default constructor. Deleting the constructor
    ensures that no instances of the class can be created, enforcing this at compile
    time. Disabling instantiation signals a clear intent to the user: *This is a*
    `static` *class. The functions you’re using don’t rely on any instance-specific
    states, as no instances exist. If there’s any internal state, it’s shared and
    will affect everyone using the class*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以通过定义一个具有所有`static`方法和成员的类并删除默认构造函数来创建一个`static`类。删除构造函数确保无法创建类的实例，在编译时强制执行。禁用实例化向用户明确表示：*这是一个*
    `static` *类。你使用的函数不依赖于任何特定实例的状态，因为没有实例存在。如果存在任何内部状态，它是共享的，并将影响所有使用该类的用户*。
- en: 'We will modify the previous example and create a `uart_c_hal` `static` class
    to wrap UART C HAL functions, as shown in this code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改之前的示例，创建一个`uart_c_hal` `static`类来封装UART C HAL函数，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this code, we simply mapped C functions in `static` methods of the class
    `uart_c_hal`. Next, we will modify the `uart_stm32` class to use `uart_c_hal`,
    as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们简单地将`uart_c_hal`类的`static`方法中的C函数进行了映射。接下来，我们将修改`uart_stm32`类以使用`uart_c_hal`，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code, we see that `uart_stm32` is now a template class that uses the
    methods `init` and `transmit` from the template parameter `HalUart`. Now we can
    use the class template, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们看到`uart_stm32`现在是一个模板类，它使用了模板参数`HalUart`中的`init`和`transmit`方法。现在我们可以使用类模板，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `uart_stm32` class template still implements the `uart` interface, meaning
    we can still use it with the `gsm_lib` class. Wrapping C HAL functions in a `static`
    class and adjusting `uart_stm32` to use it through a template parameter decouples
    C HAL from the `uart_stm32` implementation. This makes it possible to test the
    `uart_stm32` class off-target, as it doesn’t depend on platform-specific code
    anymore.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`uart_stm32`类模板仍然实现了`uart`接口，这意味着我们仍然可以使用它与`gsm_lib`类一起使用。在`static`类中封装C HAL函数并将`uart_stm32`调整为通过模板参数使用它，解耦了C
    HAL与`uart_stm32`实现。这使得可以在目标之外测试`uart_stm32`类，因为它不再依赖于特定平台的代码了。'
- en: Static classes are one way of using C libraries in C++ projects. They allow
    us to encapsulate functions from C libraries in types that can be passed to C++
    classes through template arguments, making the code more flexible and easier to
    test.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类是在C++项目中使用C库的一种方式。它们允许我们将C库中的函数封装在可以通过模板参数传递给C++类的类型中，使代码更加灵活且易于测试。
- en: Next, we will see how to apply the RAII technique to effectively wrap the **little
    fail-safe** (`littlefs`) filesystem C library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何应用RAII技术来有效地封装**little fail-safe** (`littlefs`) 文件系统C库。
- en: Using RAII for wrapping the littlefs C library
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RAII封装littlefs C库
- en: RAII is a simple yet powerful C++ technique used to manage resources through
    an object’s lifetime. Resources can represent different things. Resources are
    acquired when an object’s lifetime begins, and they are released when the object’s
    lifetime ends.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是一种简单而强大的C++技术，用于通过对象的生命周期来管理资源。资源可以代表不同的事物。资源在对象的生命周期开始时获取，在对象的生命周期结束时释放。
- en: The technique is used to manage resources such as dynamically allocated memory.
    To ensure that the memory is released and avoid memory leaks, the recommendation
    is to use dynamic allocation only internally in classes. When an object is instantiated,
    the constructor will allocate memory, and when the object goes out of scope, the
    destructor will release the allocated memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术用于管理如动态分配内存等资源。为确保内存被释放并避免内存泄漏，建议仅在类内部使用动态分配。当对象被实例化时，构造函数将分配内存，当对象超出作用域时，析构函数将释放分配的内存。
- en: The RAII technique can be applied to other resources beyond the dynamically
    allocated memory, such as files, and we will apply it to the `littlefs` filesystem
    library ([https://github.com/littlefs-project/littlefs](https://github.com/littlefs-project/littlefs)).
    We will start with a short overview of `littlefs` – a filesystem designed for
    microcontrollers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: RAII技术可以应用于动态分配内存以外的其他资源，例如文件，我们将将其应用于`littlefs`文件系统库（[https://github.com/littlefs-project/littlefs](https://github.com/littlefs-project/littlefs)）。我们将从对`littlefs`的简要概述开始——这是一个为微控制器设计的文件系统。
- en: LittleFS – a filesystem for microcontrollers
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LittleFS – 用于微控制器的文件系统
- en: 'The `littlefs` filesystem is designed for microcontrollers featuring the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`littlefs`文件系统是为具有以下特点的微控制器设计的：'
- en: '**Power-loss resilience**: It is built to handle unexpected power failures.
    In the case of power loss, it will fall back to the last known good state.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断电恢复性**：它被构建来处理意外的断电。在断电的情况下，它将回退到最后已知的好状态。'
- en: '**Dynamic wear leveling**: It is optimized for flash memory, offering wear
    leveling across dynamic blocks. It also includes mechanisms to detect and bypass
    bad blocks, ensuring reliable performance over time.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态磨损均衡**：它针对闪存进行了优化，提供跨动态块的磨损均衡。它还包括检测和绕过坏块机制，确保长期可靠性能。'
- en: '**Bounded RAM/ROM**: It is optimized for low memory usage. RAM consumption
    remains constant, regardless of filesystem size, with no unbounded recursion.
    Dynamic memory is limited to configurable buffers, which can be set up as `static`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限 RAM/ROM**：它针对低内存使用进行了优化。无论文件系统大小如何，RAM 消耗保持恒定，没有无界递归。动态内存限制在可配置的缓冲区中，可以设置为
    `static`。'
- en: 'We will first go through the basic usage of `littlefs` and then see how we
    can apply RAII in a C++ wrapper class. We will go through an example of using
    `littlefs` that will:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍 `littlefs` 的基本用法，然后看看我们如何在 C++ 包装类中应用 RAII。我们将通过以下示例使用 `littlefs`：
- en: Format and mount filesystem.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化和挂载文件系统。
- en: Create a file, write some content to it, and then close it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个文件，向其中写入一些内容，然后关闭它。
- en: Open a file, read content from it, and then close it.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个文件，从中读取内容，然后关闭它。
- en: 'The full example is contained in `Chapter13/lfs_raii/app/src/main.cpp`. Let
    us start with code that formats and mounts the filesystem, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例包含在 `Chapter13/lfs_raii/app/src/main.cpp` 中。让我们从以下代码开始，它格式化和挂载文件系统，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code performs the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下步骤：
- en: It declares a filesystem object named `lfs` of type `lfs_t`. This object will
    be used to interact with the `littlefs` filesystem. It holds the state of the
    filesystem and is required for all subsequent filesystem operations.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了一个名为 `lfs` 的文件系统对象，类型为 `lfs_t`。此对象将用于与 `littlefs` 文件系统交互。它包含文件系统的状态，并且对于所有后续的文件系统操作都是必需的。
- en: The function `get_ramfs_lfs_config()` returns a pointer to the `lfs_config`
    structure that contains all the necessary configuration parameters for `littlefs`
    to operate on a RAM storage medium. This includes function pointers for reading,
    writing, and erasing, as well as parameters like block size, block count, and
    cache size. In the project setup, we are using a portion of RAM as the storage
    medium. The RAM-based `littlefs` configuration is defined in the C file `Chapter13/lfs_raii/app/src/lfs_ramfs.c`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `get_ramfs_lfs_config()` 返回一个指向 `lfs_config` 结构的指针，该结构包含 `littlefs` 在 RAM
    存储介质上运行所需的所有配置参数。这包括读取、写入和擦除的功能指针，以及如块大小、块计数和缓存大小等参数。在项目设置中，我们使用 RAM 的一部分作为存储介质。基于
    RAM 的 `littlefs` 配置定义在 C 文件 `Chapter13/lfs_raii/app/src/lfs_ramfs.c` 中。
- en: It formats the storage medium to prepare it for use with `littlefs`. The `lfs_format`
    function initializes the filesystem structures on the storage medium. This process
    erases any existing data and sets up the necessary metadata structures. Formatting
    is typically done once before the first use of the filesystem or when resetting
    it.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化存储介质，以便与 `littlefs` 一起使用。`lfs_format` 函数在存储介质上初始化文件系统结构。此过程擦除任何现有数据并设置必要的元数据结构。格式化通常在第一次使用文件系统之前或重置时进行一次。
- en: It mounts the filesystem to make it ready for file operations. The `lfs_mount`
    function initializes the filesystem state in RAM based on the existing structures
    on the storage medium. This step is necessary before performing any file operations
    like reading or writing.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它挂载文件系统，使其准备好进行文件操作。`lfs_mount` 函数根据存储介质上的现有结构在 RAM 中初始化文件系统状态。在执行任何读取或写入等文件操作之前，此步骤是必需的。
- en: 'Next, let us go over creating a file and writing some data to it. The code
    is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何创建一个文件并向其中写入一些数据。代码如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code performs the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下步骤：
- en: Declares a file object named `file` of type `lfs_file_t`. This object represents
    a file within the `littlefs` filesystem. It holds the state of the file and is
    required for performing file operations like reading and writing.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明了一个名为 `file` 的文件对象，类型为 `lfs_file_t`。此对象代表 `littlefs` 文件系统中的一个文件。它包含文件的状态，并且对于执行读取和写入等文件操作是必需的。
- en: 'Attempts to open a file named `“song.txt”` for writing using the function `lfs_file_open`.
    The function is provided with the following arguments:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数 `lfs_file_open` 尝试打开名为 `“song.txt”` 的文件进行写入。该函数提供了以下参数：
- en: '`&lfs`: A pointer to the filesystem object, initialized and mounted earlier.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&lfs`：指向之前初始化和挂载的文件系统对象的指针。'
- en: '`&file`: A pointer to the file object that will be associated with the opened
    file.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&file`：指向将关联到打开文件的文件对象的指针。'
- en: '`“song.txt”`: The name of the file to open.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`“song.txt”`：要打开的文件名。'
- en: '`LFS_O_WRONLY | LFS_O_CREAT`: Flags specifying to open the file in write-only
    mode, and to create a file if it doesn’t exist already.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LFS_O_WRONLY | LFS_O_CREAT`：指定以只写模式打开文件，如果文件不存在则创建文件。'
- en: If the `lfs_file_open` function returns a non-negative value, the code attempts
    to write some data to it using the `lfs_file_write` function.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `lfs_file_open` 函数返回非负值，则代码尝试使用 `lfs_file_write` 函数向其写入一些数据。
- en: We declare the content to write as a `file_content` string literal.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将写入的内容声明为 `file_content` 字符串字面量。
- en: 'The function `lfs_file_write` is provided with the following arguments:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `lfs_file_write` 提供以下参数：
- en: '`&lfs`: A pointer to the filesystem object.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&lfs`：指向文件系统对象的指针。'
- en: '`&file`: A pointer to the file object associated with the opened file.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&file`：指向与打开文件关联的文件对象的指针。'
- en: '`reinterpret_cast<const void *>(file_content)`: Casts the character string
    to a `const void*` pointer as required by the function.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast<const void *>(file_content)`：将字符字符串转换为函数所需的 `const void*`
    指针。'
- en: '`strlen(file_content)`: The number of bytes to write, calculated based on the
    length of the string.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strlen(file_content)`：要写入的字节数，基于字符串的长度计算。'
- en: Closes the file after writing to ensure data integrity. `lfs_file_close` flushes
    any pending writes to the storage medium and releases resources associated with
    the file.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写入后关闭文件以确保数据完整性。`lfs_file_close` 将任何挂起的写入刷新到存储介质，并释放与文件关联的资源。
- en: 'After writing data to a file, we will attempt to open the same file in read
    mode and read the data from it. The code for reading a file is shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据写入文件后，我们将尝试以读取模式打开相同的文件并从中读取数据。读取文件的代码如下所示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code performs the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下步骤：
- en: Attempts to open the file `“song.txt”` for read-only access using the function
    `lfs_file_open` and providing it with the flag `LFS_O_RDONLY`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用带有标志 `LFS_O_RDONLY` 的函数 `lfs_file_open` 打开文件 `“song.txt”` 以进行只读访问。
- en: If the `lfs_file_open` function returns a non-negative value, the code attempts
    to read data from the opened file.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `lfs_file_open` 函数返回非负值，则代码尝试从打开的文件中读取数据。
- en: '`std::array<char, 64> buff = {0}` declares an array named `buff` with a fixed
    size of `64` characters and initializes all elements to zero (`‘\0’`), ensuring
    the buffer is null-terminated if treated as a C string.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::array<char, 64> buff = {0}` 声明了一个名为 `buff` 的数组，大小固定为 `64` 个字符，并将所有元素初始化为零（`‘\0’`），确保如果将其作为
    C 字符串处理，则缓冲区为空终止。'
- en: 'Reads data from opened files in the `buff` array using the function `lfs_file_read`.
    The function is provided with the following arguments:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数 `lfs_file_read` 从 `buff` 数组中读取打开的文件数据。该函数提供了以下参数：
- en: '`&lfs`: A pointer to the filesystem object.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&lfs`：指向文件系统对象的指针。'
- en: '`&file`: A pointer to the file object associated with the opened file.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&file`：指向与打开文件关联的文件对象的指针。'
- en: '`reinterpret_cast<const void *>(buff.data())`: Casts the `buff` underlying
    data array pointer to a const void* pointer as required by the function.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast<const void *>(buff.data())`：将 `buff` 的底层数据数组指针转换为函数所需的 `const
    void*` 指针。'
- en: '`buff.size() – 1`: The number of bytes to read from the file. Subtracting 1
    reserves space for a null terminator (`‘\0’`) at the end of the string.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buff.size() – 1`：从文件中读取的字节数。减去 1 为字符串末尾的空终止符（`‘\0’`）保留空间。'
- en: Closes the file after reading to ensure data integrity.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取数据后关闭文件以确保数据完整性。
- en: 'You can run the full example in the Renode simulator. Start Visual Studio Code,
    attach it to the running container, open the `Chapter13/lfs_raii` project, as
    described in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in
    the Visual Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Renode 模拟器中运行完整示例。启动 Visual Studio Code，将其附加到正在运行的容器，打开 `Chapter13/lfs_raii`
    项目，如 [*第 4 章*](Chapter_04.xhtml) 中所述，然后在 Visual Studio Code 终端中运行以下命令，或者在容器终端中直接运行：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Introducing an RAII-based C++ wrapper
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入基于 RAII 的 C++ 包装器
- en: 'Now, we will wrap the `littlefs` functionality in a simple C++ wrapper applying
    the RAII technique. We will create an `fs` namespace with types `lfs` and `file`
    in it. Let us start with the `lfs` `struct` code shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 RAII 技术将 `littlefs` 功能包装在一个简单的 C++ 包装器中。我们将创建一个包含 `lfs` 和 `file` 类型的
    `fs` 命名空间。让我们从以下所示的 `lfs` `struct` 代码开始：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The purpose of the `struct` `lfs` is to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` `lfs`的目的如下：'
- en: Hold an instance of a filesystem object named `fs_lfs` of type `lfs_t` used
    to interact with the `littlefs` filesystem.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有一个名为`fs_lfs`的`lfs_t`类型文件系统对象的实例，用于与`littlefs`文件系统交互。
- en: Implement the `static` method `init` used to initialize the filesystem by calling
    the `lfs_format` and `lfs_mount` functions. The `init` method must be called before
    any file operations are performed.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用于通过调用`lfs_format`和`lfs_mount`函数来初始化文件系统的`static`方法`init`。必须在执行任何文件操作之前调用`init`方法。
- en: 'Next, let’s go over the `file` class definition:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`file`类的定义：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code shows methods and data members of the class file. Next, we will go
    through them, starting with the constructor shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码展示了类文件的特性和数据成员。接下来，我们将逐一介绍它们，从下面所示的构造函数开始：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `file` constructor shown opens a file with the specified `filename` and
    `flags`. It sets `is_open_` to true if the file opens successfully. Next, let’s
    go over the destructor shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面所示的`file`构造函数打开一个指定`filename`和`flags`的文件。如果文件打开成功，则将`is_open_`设置为true。接下来，让我们看看下面所示的析构函数：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The destructor shown will close the file if it’s already opened. It calls `lfs_file_close`
    to close the file and release resources. The constructor and destructor implement
    the RAII technique – creating an object will acquire resources, and when the object’s
    lifetime ends, the destructor will release them. Next, let’s go over the read
    and write methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面所示的析构函数将在文件已打开时关闭文件。它调用`lfs_file_close`来关闭文件并释放资源。构造函数和析构函数实现了RAII技术——创建对象将获取资源，当对象的生命周期结束时，析构函数将释放它们。接下来，让我们看看读取和写入方法：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `read` and `write` methods are simple wrappers for the `lfs_file_read` and
    `lfs_file_write` functions. Both `read` and `write` use `std::span` as function
    parameters for increased type safety and better flexibility, as we can simply
    provide it with `std::array`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`和`write`方法是对`lfs_file_read`和`lfs_file_write`函数的简单包装。`read`和`write`都使用`std::span`作为函数参数，以提高类型安全性和更好的灵活性，因为我们只需提供`std::array`即可。'
- en: Cleaner file management with RAII
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RAII进行更清晰的文件管理
- en: 'Now, we will see how we can use the `fs` and `file` wrappers to work with the
    `littlefs` filesystem. The code is shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何使用`fs`和`file`包装器与`littlefs`文件系统一起工作。代码如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We first initialize the filesystem by calling `fs::lfs::init()`. Next, we introduce
    local scope to demonstrate a call to destructor and perform the next steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`fs::lfs::init()`初始化文件系统。接下来，我们引入局部作用域以演示对析构函数的调用并执行后续步骤：
- en: Open `“song.txt”` for writing (creating it if it doesn’t exist).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以写入模式打开`“song.txt”`（如果不存在则创建它）。
- en: Write a string literal in the file if it was opened successfully.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件成功打开，则在文件中写入一个字符串字面量。
- en: Upon exit from the scope, the destructor is called, ensuring the file is closed.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当退出作用域时，将调用析构函数，确保文件被关闭。
- en: 'Next, we will open the file and read data from it. The code is shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打开文件并从中读取数据。代码如下所示：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code performs the next steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下步骤：
- en: Opens `“song.txt”` for reading (default mode).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以读取模式打开`“song.txt”`。
- en: Declares `std::array<char, 64> buff`, initialized to zeros.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明`std::array<char, 64> buff`，初始化为零。
- en: Reads the data from the file in `buff` if the file is opened successfully.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件打开成功，则从文件中读取`buff`中的数据。
- en: 'You can run the full example in the Renode simulator. Start Visual Studio Code,
    attach it to the running container, open the `Chapter13/lfs_raii` project, as
    described in [*Chapter 4*](Chapter_04.xhtml), and run the following commands in
    the Visual Studio Code terminal, or run them directly in the container terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Renode模拟器中运行完整示例。启动Visual Studio Code，将其附加到正在运行的容器，打开`Chapter13/lfs_raii`项目，如[*第4章*](Chapter_04.xhtml)中所述，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The simple C++ wrapper we wrote for the `littlefs` library applies RAII principles,
    ensuring proper handling of resources as the destructor is called when an object’s
    lifetime ends. This ensures the file is closed even when there are multiple return
    paths from a code. It also simplifies the development experience as the code is
    less verbose and cleaner. The usage of `std:span` increases safety.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`littlefs`库编写的简单C++包装器应用了RAII原则，确保在对象的生命周期结束时调用析构函数，从而正确处理资源。这确保了即使在代码中有多个返回路径的情况下，文件也会被关闭。它还简化了开发体验，因为代码更简洁、更清晰。使用`std::span`增加了安全性。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered several techniques for using C libraries in C++
    projects. By wrapping C code in C++ classes, we can organize our code better in
    loosely coupled software modules. C++ increases type safety and compile-time features
    allow us to easily organize C wrappers in `static` classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在C++项目中使用C库的几种技术。通过将C代码封装在C++类中，我们可以在松散耦合的软件模块中更好地组织我们的代码。C++增加了类型安全性，编译时特性使我们能够轻松地将C封装器组织在`static`类中。
- en: Applying RAII is simple and provides us with a powerful mechanism that takes
    care of resource management, as we saw in the example of the `littlefs` filesystem.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用RAII（资源获取即初始化）非常简单，它为我们提供了一个强大的机制来处理资源管理，正如我们在`littlefs`文件系统示例中所见。
- en: In the next chapter, we will go over super-loop in bare metal firmware and see
    how we can enhance it with mechanisms such as sequencer in C++.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨裸机固件中的超级循环，并看看我们如何通过C++中的序列器等机制来增强它。
- en: Join our community on Discord
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[嵌入式系统](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Discord二维码](img/QR_code_Discord.png)'
