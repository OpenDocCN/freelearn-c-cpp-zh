["```cpp\nMEMORY\n{\n  name (attributes) : ORIGIN = origin, LENGTH = length\n}\n```", "```cpp\nMEMORY\n{\n  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 256K\n  SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 64K\n}\n```", "```cpp\nENTRY(SymbolName)\n```", "```cpp\nENTRY(Reset_Handler)\n```", "```cpp\nSECTIONS\n{\n  .output_section_name address :\n  {\n    input_section_information\n  } >memory_region [AT>load_address] [ALIGN(expression)] [:phdr_\n    expression] [=fill_expression]\n}\n```", "```cpp\nSECTIONS\n{\n  .text 0x08000000 :\n  {\n    *(.text)\n  } >FLASH\n}\n```", "```cpp\n  .data :\n  {\n    . = ALIGN(4);\n    _sdata = .;  /* create a global symbol at data start */\n    *(.data)           /* .data sections */\n    *(.data*)          /* .data* sections */\n    *(.RamFunc)        /* .RamFunc sections */\n    *(.RamFunc*)       /* .RamFunc* sections */\n    . = ALIGN(4);\n    _edata = .;  /* define a global symbol at data end */\n  } >SRAM AT> FLASH\n```", "```cpp\nKEEP(section)\n```", "```cpp\nKEEP(*(.isr_vector))\n```", "```cpp\nsection >region\n```", "```cpp\n.data :\n{\n  *(.data)\n} >SRAM\n```", "```cpp\n. = ALIGN(expression);\n```", "```cpp\n. = ALIGN(4);\n```", "```cpp\nPROVIDE(symbol = expression);\n```", "```cpp\nPROVIDE(_stack_end = ORIGIN(RAM) + LENGTH(RAM));\n```", "```cpp\nsection AT> lma_region\n```", "```cpp\n.data : AT> FLASH\n{\n  *(.data)\n} >SRAM\n```", "```cpp\n/*Specifying the firmware's entry point*/\nENTRY(Reset_Handler)\n/*Detailing the available memory*/\nMEMORY\n{\n    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K\n    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K\n}\n_estack = ORIGIN(SRAM)+LENGTH(SRAM);\n/*Specifying the necessary heap and stack sizes*/\n__max_heap_size = 0x200;\n__max_stack_size = 0x400;\n/*Defining output sections*/\nSECTIONS\n{\n    .text :\n    {\n     . = ALIGN(4);\n      *(.isr_vector_tbl)\n      *(.text)\n      *(.rodata)\n      . = ALIGN(4);\n     _etext = .;\n    }>FLASH\n    .data :\n    {\n     . = ALIGN(4);\n    _sdata = .;\n      *(.data)\n     . = ALIGN(4);\n    _edata = .;\n    } > SRAM AT> FLASH  /*>(vma) AT> (lma)*/\n        .bss :\n    {\n     . = ALIGN(4);\n    _sbss = .;\n    *(.bss)\n     . = ALIGN(4);\n    _ebss = .;\n    }> SRAM\n}\n```", "```cpp\nENTRY(Reset_Handler)\n```", "```cpp\nMEMORY\n{\n    FLASH(rx):ORIGIN =0x08000000,LENGTH =512K\n    SRAM(rwx):ORIGIN =0x20000000,LENGTH =128K\n}\n```", "```cpp\n_estack = ORIGIN(SRAM)+LENGTH(SRAM);\n```", "```cpp\n__max_heap_size = 0x200;\n__max_stack_size = 0x400;\n```", "```cpp\n.text :\n{\n  . = ALIGN(4);\n  *(.isr_vector_tbl)  /*merge all .isr_vector_tbl sections of input \n  files*/\n  *(.text)   /*merge all .text sections of input files*/\n  *(.rodata) /*merge all .rodata sections of input files*/\n  . = ALIGN(4);\n _etext = .;  /*Create a global symbol to hold end of text section*/\n}>FLASH\n```", "```cpp\n    .data :\n    {\n     . = ALIGN(4);\n    _sdata = .;   /*Create a global symbol to hold start of data \n    section*/\n      *(.data)\n     . = ALIGN(4);\n    _edata = .;   /*Create a global symbol to hold end of data \n    section*/\n    } > SRAM AT> FLASH  /*>(VMA) AT> (LMA)*/\n```", "```cpp\n.bss :\n{\n . = ALIGN(4);\n_sbss = .;\n*(.bss)\n . = ALIGN(4);\n_ebss = .;\n}> SRAM\n```", "```cpp\nextern uint32_t _estack;\nextern uint32_t _etext;\nextern uint32_t _sdata;\nextern uint32_t _edata;\nextern uint32_t _sbss;\nextern uint32_t _ebss;\nvoid Reset_Handler(void);\nint main(void);\nvoid NMI_Handler(void)__attribute__((weak,\nalias(\"Default_Handler\")));\nvoid HardFault_Handler (void) __attribute__ ((weak, alias(\"Default_Handler\")));\nvoid MemManage_Handler (void) __attribute__ ((weak, alias(\"Default_Handler\")));\n.\n.\n.\nuint32_t vector_tbl[] __attribute__((section(\".isr_vector_tbl\"))) = {\n    (uint32_t)&_estack,\n    (uint32_t)&Reset_Handler,\n    (uint32_t)&NMI_Handler,\n    (uint32_t)&HardFault_Handler,\n    (uint32_t)&MemManage_Handler,\n.\n.\n.\n};\nvoid Default_Handler(void) {\n    while(1) {\n    }\n}\nvoid Reset_Handler(void)\n{\n    // Calculate the sizes of the .data and .bss sections\n    uint32_t data_mem_size =  (uint32_t)&_edata - (uint32_t)&_sdata;\n    uint32_t bss_mem_size  =   (uint32_t)&_ebss - (uint32_t)&_sbss;\n    // Initialize pointers to the source and destination of the .data \n    // section\n    uint32_t *p_src_mem =  (uint32_t *)&_etext;\n    uint32_t *p_dest_mem = (uint32_t *)&_sdata;\n    /*Copy .data section from FLASH to SRAM*/\n    for(uint32_t i = 0; i < data_mem_size; i++  )\n    {\n         *p_dest_mem++ = *p_src_mem++;\n    }\n    // Initialize the .bss section to zero in SRAM\n    p_dest_mem =  (uint32_t *)&_sbss;\n    for(uint32_t i = 0; i < bss_mem_size; i++)\n    {\n         /*Set bss section to zero*/\n        *p_dest_mem++ = 0;\n    }\n        // Call the application's main function.\n    main();\n}\n```", "```cpp\nextern uint32_t _estack;\nextern uint32_t _etext;\nextern uint32_t _sdata;\nextern uint32_t _edata;\nextern uint32_t _sbss;\nextern uint32_t _ebss;\n```", "```cpp\nvoid Reset_Handler(void);\nint main(void);\nvoid NMI_Handler(void)__attribute__((weak,\nalias(\"Default_Handler\")));\nvoid HardFault_Handler (void) __attribute__ ((weak, alias(\"Default_Handler\")));\nvoid MemManage_Handler (void) __attribute__ ((weak, alias(\"Default_Handler\")));\n.\n.\n.\n```", "```cpp\nuint32_t vector_tbl[] __attribute__((section(\".isr_vector_tbl\"))) = {\n    (uint32_t)&_estack,\n    (uint32_t)&Reset_Handler,\n    (uint32_t)&NMI_Handler,\n    (uint32_t)&HardFault_Handler,\n    (uint32_t)&MemManage_Handler,\n…\n};\n```", "```cpp\nuint32_t vector_tbl[] __attribute__((section(\".isr_vector_tbl\")))={…}\n```", "```cpp\nvoid Default_Handler(void) {\n    while(1) {\n        // Infinite loop\n    }\n}\n```", "```cpp\nvoid Reset_Handler(void) {\n    uint32_t data_mem_size =  (uint32_t)&_edata - (uint32_t)&_sdata;\n    uint32_t bss_mem_size  =   (uint32_t)&_ebss - (uint32_t)&_sbss;\n    uint32_t *p_src_mem =  (uint32_t *)&_etext;\n    uint32_t *p_dest_mem = (uint32_t *)&_sdata;\n    for(uint32_t i = 0; i < data_mem_size; i++  ) {\n        *p_dest_mem++ = *p_src_mem++;\n    }\n    p_dest_mem =  (uint32_t *)&_sbss;\n    for(uint32_t i = 0; i < bss_mem_size; i++) {\n        *p_dest_mem++ = 0;\n    }\n    main();\n}\n```", "```cpp\n    uint32_t data_mem_size =  (uint32_t)&_edata - (uint32_t)&_sdata;\n    uint32_t bss_mem_size  =   (uint32_t)&_ebss - (uint32_t)&_sbss;\n```", "```cpp\n        uint32_t *p_src_mem =  (uint32_t *)&_etext;\n        uint32_t *p_dest_mem = (uint32_t *)&_sdata;\n    ```", "```cpp\n        for(uint32_t i = 0; i < data_mem_size; i++  ) {\n            *p_dest_mem++ = *p_src_mem++;\n        }\n    ```", "```cpp\n    p_dest_mem =  (uint32_t *)&_sbss;\n```", "```cpp\n    for(uint32_t i = 0; i < bss_mem_size; i++) {\n        *p_dest_mem++ = 0;\n    }\n```", "```cpp\n    main();\n```", "```cpp\n                //  22: Toggle PA5(LED_PIN)\n                GPIOA_OD_R ^= LED_PIN;\n            for(int i = 0; i < 100000; i++){}\n        ```", "```cpp\n            //  22: Toggle PA5(LED_PIN)\n            GPIOA_OD_R ^= LED_PIN;\n        for(int i = 0; i < main.c file.\n    ```", "```cpp\narm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -o main.o\n```", "```cpp\narm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c -o stm32f411_startup.o\n```", "```cpp\narm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o 3_LinkerAndStartup.elf.elf\n```", "```cpp\nopenocd -f board/st_nucleo_f4.cfg\n```", "```cpp\narm-none-eabi-gdb\n```", "```cpp\ntarget remote localhost:3333\n```", "```cpp\nmonitor reset init\n```", "```cpp\nmonitor flash write_image erase 3_LinkerAndStartup.elf\n```", "```cpp\nmonitor reset init\n```", "```cpp\nmonitor resume\n```"]