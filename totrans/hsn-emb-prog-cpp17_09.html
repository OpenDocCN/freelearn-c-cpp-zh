<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing Resource-Restricted Platforms</h1>
                </header>
            
            <article>
                
<p>Developing for MCUs and similar resource-restricted platforms is pretty much exclusively done on regular PCs, except for testing and debugging. The question is when one should be testing on the physical device and when one should be looking at alternative means of testing and debugging code in order to speed up development and debugging efforts.</p>
<p>In this chapter we will cover the following topics:</p>
<ul>
<li>Understanding the resource needs of specific code</li>
<li>Effectively using Linux-based tools to test cross-platform code</li>
<li>Using remote debugging</li>
<li>Using cross-compilers</li>
<li>Creating a platform-independent build system</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing wear</h1>
                </header>
            
            <article>
                
<p>Often, during development, there comes that point where one is fixing an issue in a system and have to go through the same tweak-compile-deploy-test cycle, over and over. Here are the main problems that are introduced with this approach:</p>
<ul>
<li><strong>It's not fun</strong>: It's frustrating to have to constantly wait for results without a clear idea of whether it will actually be fixed this time.</li>
<li><strong>It's not productive</strong>: You spend a lot of time waiting for results you wouldn't need if you could just analyze the problem better.</li>
<li><strong>It wears down the hardware</strong>: After removing and reinserting the same connectors dozens of times, writing and overwriting the same sections of the ROM chip countless times, and power cycling the system hundreds of times, the hardware's lifespan is reduced significantly, along with one's own patience, and new errors are introduced.</li>
<li><strong>Fiddling with test hardware isn't fun</strong>: The best-case scenario for any embedded setup is to be able to take the development board, plug in all the peripherals and wiring, flash the ROM with the application, and power it up to see it work. Any deviation from this scenario is frustrating and time-consuming.</li>
</ul>
<p>Avoiding such cycles during development is therefore essential. The question is how we can most effectively get to a point where we can produce code for something such as an 8-bit MCU or a larger 32-bit ARM MCU without ever touching the hardware until the final stages of testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Planning out a design</h1>
                </header>
            
            <article>
                
<p>In <a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml"/><a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml"/><a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml"><span>C</span><span class="ChapterrefPACKT">hapter</span> <span class="ChapterrefPACKT">4</span></a><span class="ChapterrefPACKT">, <em>Resource-Restricted Embedded Systems</em>,</span> <span class="ChapterrefPACKT">we </span><span>looked at how to pick an appropriate microcontroller for an embedded platform</span><span>. While designing the firmware for the MCU, it's essential that we consider not only the resource requirements of specific codes, but also the ease of debugging.</span></p>
<p>An important advantage of using C++ is the abstractions it offers, including the ability to subdivide the code into logical classes, namespaces, and other abstractions that allow us to easily reuse, test, and debug the code. This is a crucial aspect in any design, and an aspect that needs to be implemented fully before one can proceed with actually implementing the design.</p>
<p>Depending on the design, it can be either very easy or frustratingly hard to debug any issue, or anything in between. If there's a clean separation between all the functionality, without leaky APIs or similar problems that could leak internal, private data, creating different versions of fundamental classes for things such as integration and unit testing will be easy.</p>
<p>Simply using classes and the like is no guarantee for a design that is modular. Even with such a design one can still end up passing internal class data between classes, thus breaking modularity. When this happens, i will complicate the overall design as the level of dependencies increases with changes to data structures and data formats potentially causing issues elsewhere in the application and will require creative hacks while writing tests and reimplementing APIs as part of larger integration tests.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In <a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml"><span>C</span><span class="ChapterrefPACKT">hapter</span><span> </span><span class="ChapterrefPACKT">4</span></a><span class="ChapterrefPACKT">,<span> </span><em>Resource-Restricted Embedded Systems</em></span>, we looked at how to pick the proper MCU. The points of RAM, ROM, and floating-point usage are obviously down to the design we picked to fit the project. As we covered in <a href="cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml"/><a href="cae3bf4a-2936-42b4-a33e-569e693bfcc8.xhtml">C<span class="ChapterrefPACKT">hapter 2</span></a><span class="ChapterrefPACKT">, <em><span>C++ as an Embedded Language</span></em></span>, it's important to understand what the code we write is compiled into. This understanding allows one to get an intuitive feeling for what the resource cost of a line of code is going to be like without having to step through the generated machine code and create an exact clock cycle count from there.</p>
<p>It should be obvious at this point that before one can pick an MCU, one must have a pretty good idea of the overall design and the resource requirements, so starting off with a solid design is essential.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Platform-independent build systems</h1>
                </header>
            
            <article>
                
<p>Ideally, the project and build system we choose could be used to build the target platform on any desktop platform. Usually, the main consideration here is the availability of the same toolchain and programmer for each development platform. Fortunately, for AVR- and ARM-based MCU platforms, the same GCC-based toolchain is available, so that we do not have to take different toolchains with different naming conventions, flags and settings into account.</p>
<p>The remaining challenge is simply to invoke the toolchain, and subsequently the programmer utility, in a way that doesn't require any knowledge of the underlying OS.</p>
<p>In <a href="7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml"/><a href="7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml"/><a href="7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml">Chapter 6</a><span class="ChapterrefPACKT">, <em>Testing OS-Based Applications</em></span>, we looked at a multitarget build system, which could produce binaries for a wide variety of targets with minimal effort for each new target. For an MCU target, there would only be the following two targets:</p>
<ul>
<li>The physical MCU target</li>
<li>The local OS target</li>
</ul>
<p>Here, the first target is obviously fixed, as we picked out the MCU that we wanted to target. Barring any unpleasant surprises, we will be using this one target for the entire development process. In addition, we will want to preform local testing on our development PC. This is the second target.</p>
<p>Here it would be great if there is a version of the same or similar  C++ toolchain on each mainstream desktop OS. Fortunately, we find that GCC is available on just about any platform imaginable, with the Clang C++ frontend of the LLVM toolchain using regular GCC-style flags, providing us with broad compatibility.</p>
<p class="mce-root"/>
<p>Instead of requiring the complexity of a multitarget build system, as we saw in <a href="7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml">Chapter 6</a><span class="ChapterrefPACKT">,<span> </span><em>Testing OS-Based Applications</em></span><span>,</span> we can simplify it so it that  just uses GCC, which would allow us to use that toolchain on Linux- and BSD-based OSes, along with Windows (MinGW via MSYS2 or equivalent) and macOS (after installing GCC).</p>
<p>For full compatibility on macOS, the use of GCC is recommended, due to small issues in the Clang implementation. One of these current issues is the <kbd>__forceinline</kbd> macro attribute being broken, for example, which would break a lot of code that assumes the GCC compiler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using cross-compilers</h1>
                </header>
            
            <article>
                
<p>Every compiler toolchain consists of a side (frontend) that takes in the source code and a side that outputs the binary format for the target platform (backend). There's no reason why the backend couldn't work on any other platform than the one it's targeting. In the end, one merely transforms text files into sequences of bytes.</p>
<p>Cross-compiling in this fashion is an essential feature with MCU-oriented development, as compiling directly on those MCUs would be highly inefficient. There is, however, nothing magical about this process. In the case of GCC-based and GCC-compatible toolchains, one would still be interacting with the same interfaces on the toolchain, just with the tools usually prefixed with the target platform name to distinguish them from other toolchains for different targets. Essentially, instead of <kbd>g++</kbd> one would use <kbd>arm-none-eabi-g++</kbd></p>
<p>The resulting binaries would be in the format appropriate for that target platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local and on-chip debugging</h1>
                </header>
            
            <article>
                
<p>In <a href="7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml">Chapter 6</a><span class="ChapterrefPACKT">,<span> </span><em>Testing OS-Based Applications</em></span>, we looked at debugging applications using Valgrind and similar tools, as well as GDB and kin. With the OS-based integration tests for MCU-based projects, such as those demonstrated in the <em>Example <span>–</span><span> </span>ESP8266 integration test</em> section, we can use the exact same techniques, profiling and debugging the code without concerning ourselves just yet with the fact that the same code will be running on a much slower and more limited platform during final integration testing on real hardware.</p>
<p>The real challenge comes during that final integration stage, when the firmware—which we have been debugging on our fast desktop system using Valgrind and other highly capable tools—is now running on a paltry 16 MHz ATmega MCU without the ability to quickly launch the code with a Valgrind tool or within a GDB session.</p>
<p>As one will inevitably encounter bugs and issues during this stage, we need to be prepared to deal with this situation. Often, one has to resort to <strong>on-chip debugging</strong> (<strong>OCD</strong>), which can be performed over whichever debugging interface the MCU provides. This can be JTAG, DebugWire or SWD, PDI, or some other type. In <a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml"/><a href="bb67db6a-7c71-4519-80c3-7cd571cddfc0.xhtml">C<span class="ChapterrefPACKT">hapter 4</span></a><span class="ChapterrefPACKT">, <em>Resource-Restricted Embedded Systems</em></span>, we looked at some of those interfaces in the context of programming these MCUs.</p>
<p>Embedded IDEs will provide the ability to perform OCD right out of the box, connecting with the target hardware, allowing one to set breakpoints, much like one would be used to setting for a local process. Of course, it's also possible to use GDB from the command line to do the same thing, using a program such as OpenOCD (<a href="http://openocd.org/">http://openocd.org/</a>), which provides a <kbd>gdbserver</kbd> interface for GDB while interfacing with a wide variety of debug interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example – ESP8266 integration test</h1>
                </header>
            
            <article>
                
<p>In this example project, we will look at creating an implementation of the Arduino-like APIs of the Sming framework, which we first looked at it in <a href="886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml">C<span class="ChapterrefPACKT">hapter 5</span></a><span class="ChapterrefPACKT">, <em>Example - Soil Humidity Monitor with Wi-Fi</em></span>. The goal of this is to provide a native framework implementation for desktop <strong>operating systems</strong> (<strong>OSes</strong>), allowing the firmware to be compiled to an executable and run locally.</p>
<p>In addition, we want to have simulated sensors and actuators that the firmware can connect to in order to read out environmental data and send data to actuators as part of the BMaC project, which we had a glimpse of in <a href="886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml">C<span class="ChapterrefPACKT">hapter 5</span></a><span class="ChapterrefPACKT">,<span> </span><em>Example - Soil Humidity Monitor with WiFi</em></span>, and which we will look at in more detail in <a href="d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml">C<span class="ChapterrefPACKT">hapter 9</span></a><span class="ChapterrefPACKT">, <em>Example - Building Monitoring and Control</em></span>. For this, we also need to have a central service that keeps track of such information. This way, we can also have multiple firmware processes running, to simulate entire rooms full of devices.</p>
<p>The reason for this scope of the simulation is due to not having the physical hardware. Without a physical MCU system, we don't have physical sensors, and these sensors would not exist in a physical room. Ergo we have to generate plausible input for the sensors and simulate the effect of any actuators.  This does however come with a lot of advantages.</p>
<p>Having this scaling ability is useful in that it allows us to validate the firmware not only as a standalone system, but also as part of the system it would be installed in. In the case of BMaC, this would mean a single node installed in a room of a building, with dozens to hundreds of further nodes installed in the same and other rooms across the building's floors, along with accompanying backend services running on the same network.</p>
<p>With this kind of large-scale simulation ability, one can test not only the basic correctness of the firmware by itself, but also that of the system as a whole, with the different firmware types or even versions running in tandem with the various sensors and actuators (for air-conditioning units, fans, coffee machines, switches, and so on). In addition to this, the backend services would be directing the nodes according to the data being passed to them from the same nodes.</p>
<p>Within the simulated building, one could then configure specific rooms to have particular environmental conditions, run through a working day with people entering, working, and leaving, to determine the effect of different levels of building occupation, outside conditions, and so on. You could also do this with the firmware and backend services that would be used for the final production system. While testing a system this way won't fully eliminate any potential problems, it should at least validate that the software side of the system is functionally correct.</p>
<div class="packt_infobox">As embedded systems are by definition part of a larger (hardware-based) system, a full integration test will involve the actual hardware or its equivalent. One could therefore consider this example the software integration test, prior to deploying the firmware to the target hardware in a physical building.</div>
<p>Both the simulation server and the individual firmware processes have their own main function and run independently from each other. This allows us to inspect the functioning of the firmware with as little interference as possible and promotes a clean design. To allow efficient communication between these processes, we use a <strong>remote procedure call</strong> (<strong>RPC</strong>) library, which essentially creates a connection between the firmware and the I2C, SPI, and UART-based devices in the simulated room. The RPC library used with this example is NymphRPC, an RPC library developed by the author. The source for the current version has been included with the source code for this chapter. The current version of the NymphRPC library can be found at its GitHub repository at <span class="URLPACKT"><a href="https://github.com/MayaPosch/NymphRPC">https://github.com/MayaPosch/NymphRPC</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The server</h1>
                </header>
            
            <article>
                
<p>We will first look at the server for this integration test. Its role is to run the RPC server and to maintain the state of each of the sensor and actuator devices, as well as the rooms.</p>
<p>The main file, <kbd>simulation.cpp</kbd>, sets up the RPC configuration as well as the main loop, as shown in the following code:</p>
<pre>#include "config.h"<br/>#include "building.h"<br/>#include "nodes.h"<br/>#include &lt;nymph/nymph.h&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;condition_variable&gt;<br/>#include &lt;mutex&gt;<br/>std::condition_variable gCon;<br/>std::mutex gMutex;<br/>bool gPredicate = false;<br/>void signal_handler(int signal) {<br/>    gPredicate = true;<br/>    gCon.notify_one();<br/>}<br/>void logFunction(int level, string logStr) {<br/>    std::cout &lt;&lt; level &lt;&lt; " - " &lt;&lt; logStr &lt;&lt; endl;<br/>}</pre>
<p>The includes at the top shows us the basic structure and dependencies. We have a custom configuration class, a class defining the building, a static class for the nodes, and finally the multithreading headers (available since C++11) and the NymphRPC RPC header to gain access to its functionality.</p>
<p>A signal handler function is defined to be used with the waiting condition later on, allowing the server to be terminated with a simple control signal. Finally, a logging function is defined for use with the NymphRPC server.</p>
<p>Next, we define the callback functions for the RPC server, as follows:</p>
<pre>NymphMessage* getNewMac(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = Nodes::getMAC();<br/>    Nodes::registerSession(mac, session);<br/><br/>    returnMsg-&gt;setResultValue(new NymphString(mac));<br/>    return returnMsg;<br/> }</pre>
<p>This is the initial function that the clients will call on the server. It will check the global, static <kbd>Nodes</kbd> class for an available MAC address. This address uniquely identifies a new node instance, the way a device on the network would also be identified by its unique Ethernet MAC address. This is an internal function that will not require modification of the firmware, but shifts the ability to assign MACs to the server, instead of­ having them hardcoded somewhere. When a new MAC has been assigned, it gets associated with the NymphRPC session ID so that we can later use the MAC to find the appropriate session ID and, with it, the client to call for events generated by simulated devices.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, we also see the basic signature of a NymphRPC callback function as used on a server instance. It obviously returns the return message, and it receives as its parameters the session ID associated with the connected client, the message received from this client, and some user-defined data, as shown in the following code:</p>
<pre>NymphMessage* writeUart(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/>    std::string bytes = ((NymphString*) msg-&gt;parameters()[1])-&gt;getValue();<br/>    returnMsg-&gt;setResultValue(new NymphBoolean(Nodes::writeUart(mac, bytes)));<br/>    return returnMsg;<br/> }</pre>
<p>This callback implements a way to write to the UART interface of a simulated node within the simulation, addressing whichever simulated device is hooked up to it.</p>
<p>To find the node, we use the MAC address and send it, along with the bytes, to be written to the appropriate <kbd>Nodes</kbd> class function, as shown in the following code:</p>
<pre>NymphMessage* writeSPI(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/>    std::string bytes = ((NymphString*) msg-&gt;parameters()[1])-&gt;getValue();<br/>    returnMsg-&gt;setResultValue(new NymphBoolean(Nodes::writeSPI(mac, bytes)));<br/>    return returnMsg;<br/> }<br/> NymphMessage* readSPI(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/>    returnMsg-&gt;setResultValue(new NymphString(Nodes::readSPI(mac)));<br/>    return returnMsg;<br/> }</pre>
<p>For the SPI bus, a similar system is used for writing and reading. The MAC identifies the node and either a string is sent to the bus or is received from it. One limitation here is that we assume the presence of only a single SPI device, since there is no way to select a different SPI <strong>chip-select</strong> (<strong>CS</strong>) line. A separate CS parameter would have to be passed here to enable more than one SPI device. Let's look at the following code:</p>
<pre>NymphMessage* writeI2C(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/>    int i2cAddress = ((NymphSint32*) msg-&gt;parameters()[1])-&gt;getValue();<br/>    std::string bytes = ((NymphString*) msg-&gt;parameters()[2])-&gt;getValue();<br/>    returnMsg-&gt;setResultValue(new NymphBoolean(Nodes::writeI2C(mac, i2cAddress, bytes)));<br/>    return returnMsg;<br/> }<br/><br/><br/> NymphMessage* readI2C(int session, NymphMessage* msg, void* data) {<br/>    NymphMessage* returnMsg = msg-&gt;getReplyMessage();<br/><br/>    std::string mac = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/>    int i2cAddress = ((NymphSint32*) msg-&gt;parameters()[1])-&gt;getValue();<br/>    int length = ((NymphSint32*) msg-&gt;parameters()[2])-&gt;getValue();<br/>    returnMsg-&gt;setResultValue(new NymphString(Nodes::readI2C(mac, i2cAddress, length)));<br/>    return returnMsg;<br/> }</pre>
<p>For the I2C bus version, we pass the I2C slave device address to allow us to use more than a single I2C device.</p>
<p>Finally, the main function registers the RPC methods, starts the simulation, and then enters a waiting condition, as shown in the following code:</p>
<pre>int main() {<br/>    Config config;<br/>    config.load("config.cfg");</pre>
<p>We first get the configuration data for this simulation using the following code. This is all defined in a separate file, that we will load using the special <kbd>Config</kbd> class, which we will take a more detailed look at in a moment when we look at the configuration parser.</p>
<pre>   vector&lt;NymphTypes&gt; parameters;<br/>    NymphMethod getNewMacFunction("getNewMac", parameters, NYMPH_STRING);<br/>    getNewMacFunction.setCallback(getNewMac);<br/>    NymphRemoteClient::registerMethod("getNewMac", getNewMacFunction);<br/><br/>    parameters.push_back(NYMPH_STRING);<br/>    NymphMethod serialRxCallback("serialRxCallback", parameters, NYMPH_NULL);<br/>    serialRxCallback.enableCallback();<br/>    NymphRemoteClient::registerCallback("serialRxCallback", serialRxCallback);<br/><br/>    // string readI2C(string MAC, int i2cAddress, int length)<br/>    parameters.push_back(NYMPH_SINT32);<br/>    parameters.push_back(NYMPH_SINT32);<br/>    NymphMethod readI2CFunction("readI2C", parameters, NYMPH_STRING);<br/>    readI2CFunction.setCallback(readI2C);<br/>    NymphRemoteClient::registerMethod("readI2C", readI2CFunction);<br/><br/>    // bool writeUart(string MAC, string bytes)<br/>    parameters.clear();<br/>    parameters.push_back(NYMPH_STRING);<br/>    parameters.push_back(NYMPH_STRING);<br/>    NymphMethod writeUartFunction("writeUart", parameters, NYMPH_BOOL);<br/>    writeUartFunction.setCallback(writeUart);<br/>    NymphRemoteClient::registerMethod("writeUart", writeUartFunction);<br/><br/>    // bool writeSPI(string MAC, string bytes)<br/>    NymphMethod writeSPIFunction("writeSPI", parameters, NYMPH_BOOL);<br/>    writeSPIFunction.setCallback(writeSPI);<br/>    NymphRemoteClient::registerMethod("writeSPI", writeSPIFunction);<br/><br/>    // bool writeI2C(string MAC, int i2cAddress, string bytes)<br/>    parameters.clear();<br/>    parameters.push_back(NYMPH_STRING);<br/>    parameters.push_back(NYMPH_SINT32);<br/>    parameters.push_back(NYMPH_SINT32);<br/>    NymphMethod writeI2CFunction("writeI2C", parameters, NYMPH_BOOL);<br/>    writeI2CFunction.setCallback(writeI2C);<br/>    NymphRemoteClient::registerMethod("writeI2C", writeI2CFunction);</pre>
<p>With this code, we register the further methods we wish to provide to the client node processes, allowing these to call the functions we looked at earlier in this source file. In order to register a server-side function with NymphRPC, we have to define the parameter types (in order) and use these to define a new <kbd>NymphMethod</kbd> instance, which we provide with this parameter type list, the function name, and the return type.</p>
<p>These method instances are then registered with <kbd>NymphRemoteClient</kbd>, which is the top-level class for the server-side NymphRPC, as shown in the following code:</p>
<pre><br/>    signal(SIGINT, signal_handler);<br/><br/>    NymphRemoteClient::start(4004);<br/><br/>    Building building(config);<br/><br/>    std::unique_lock&lt;std::mutex&gt; lock(gMutex);<br/>    while (!gPredicate) {<br/>          gCon.wait(lock);<br/>    }<br/><br/>    NymphRemoteClient::shutdown();<br/><br/><br/>    Thread::sleep(2000); <br/><br/>    return 0;<br/> }</pre>
<p>Finally, we install the signal handler for SIGINT (<em>Ctrl</em> + <em>c</em>) signals. The NymphRPC server is started on port 4004, all interfaces. Next, a <kbd>Building</kbd> instance is created, providing it with the instance of the configuration we loaded earlier with the configuration parser class.</p>
<p>We then start a loop that checks whether the value of the <kbd>gPredicate</kbd> global variable has changed to <kbd>true</kbd>, which will be the case if the signal handler has been triggered, and this Boolean variable has been set to <kbd>true</kbd>. A condition variable is used to allow us to block the main thread execution as much as possible by having the signal handler notify this condition variable.</p>
<p>By having the condition variable's wait condition inside a loop, we ensure that even if the condition variable's wait condition suffers a spurious wake up, it'll simply go back to waiting to be notified.</p>
<p>Lastly, if the server is requested to terminate, we shut down the NymphRPC server, before giving all active threads an additional two seconds to cleanly terminate. After this, the server shuts down.</p>
<p>Next, let's look at the <kbd>config.cfg</kbd> file that we loaded for this simulation, as shown in the following code:</p>
<pre>[Building]<br/> floors=2<br/><br/><br/> [Floor_1]<br/> rooms=1,2<br/><br/> [Floor_2]<br/> rooms=2,3<br/><br/><br/> [Room_1]<br/> ; Define the room configuration.<br/> ; Sensors and actuators use the format:<br/> ; &lt;device_id&gt;:&lt;node_id&gt;<br/> nodes=1<br/> devices=1:1<br/><br/> [Room_2]<br/> nodes=2<br/><br/> [Room_3]<br/> nodes=3<br/><br/> [Room_4]<br/> nodes=4<br/><br/><br/> [Node_1]<br/> mac=600912760001<br/> sensors=1<br/><br/> [Node_2]<br/> mac=600912760002<br/> sensors=1<br/><br/> [Node_3]<br/> mac=600912760003<br/> sensors=1<br/><br/> [Node_4]<br/> mac=600912760004<br/> sensors=1<br/><br/><br/> [Device_1]<br/> type=i2c<br/> address=0x20<br/> device=bme280<br/><br/> [Device_2]<br/> type=spi<br/> cs_gpio=1<br/><br/> [Device_3]<br/> type=uart<br/> uart=0<br/> baud=9600<br/> device=mh-z19<br/><br/> [Device_4]<br/> type=uart<br/> uart=0<br/> baud=9600<br/> device=jura<br/><br/></pre>
<p class="mce-root"/>
<p>As we can see, this configuration file uses the standard INI configuration file format. It defines a building with two floors, each with two rooms. Each room has a single node and each node has a BME280 sensor attached to it on the I2C bus.</p>
<p>More devices are defined, but are left unused here.</p>
<p>Let's look at the configuration parser shown in the following code, which parses the preceding format, declared in <span class="packt_screen">config.h</span>:</p>
<pre>#include &lt;string&gt; 
#include &lt;memory&gt; 
#include &lt;sstream&gt; 
#include &lt;iostream&gt; 
#include &lt;type_traits&gt; 
 
#include &lt;Poco/Util/IniFileConfiguration.h&gt; 
#include &lt;Poco/AutoPtr.h&gt; 
 
using Poco::AutoPtr; 
using namespace Poco::Util; 
 
class Config { 
   AutoPtr&lt;IniFileConfiguration&gt; parser; 
    
public: 
   Config(); 
    
   bool load(std::string filename); 
    
   template&lt;typename T&gt; 
   auto getValue(std::string key, T defaultValue) -&gt; T { 
         std::string value; 
         try { 
               value = parser-&gt;getRawString(key); 
         } 
         catch (Poco::NotFoundException &amp;e) { 
               return defaultValue; 
         } 
          
         // Convert the value to our output type, if possible. 
         std::stringstream ss; 
         if (value[0] == '0' &amp;&amp; value[1] == 'x') { 
               value.erase(0, 2); 
               ss &lt;&lt; std::hex &lt;&lt; value; // Read as hexadecimal. 
         } 
         else { 
               ss.str(value); 
         } 
          
         T retVal; 
         if constexpr (std::is_same&lt;T, std::string&gt;::value) { retVal = ss.str(); } 
         else { ss &gt;&gt; retVal; } 
          
         return retVal; 
   } 
}; </pre>
<p>Here, we see an interesting use of templates, as well as one of their limitations. The type passed to the template is used both for the default parameter and the return type, allowing the template to cast the raw string obtained from the configuration file to the desired type, while also avoiding the issue of incomplete templates by only using the type in the return type of the function.</p>
<p>Due to the limitation of C++, where every function with the same name must have a different set of parameters even if their return value differs, we must use the default value parameter here to circumvent that issue. As most of the time we want to provide a default value for the keys we are trying to read, this isn't much of an issue here.</p>
<p>Finally, we do a bit of type comparison with <kbd>std::is_same</kbd> to ensure that if the target return type is a string, we copy the string straight out of <kbd>stringstream</kbd> instead of trying to convert it using formatted output. As we read the values from the INI file using the POCO INI file reader as raw strings, there's no need to do any kind of conversion on this.</p>
<p>Its implementation in <kbd>config.cpp</kbd> is pretty small, as a result of templates having to be defined in the header file. You can see this in the following code:</p>
<pre>#include "config.h" 
 
Config::Config() { 
   parser = new IniFileConfiguration(); 
} 
 
bool Config::load(std::string filename) { 
   try { 
         parser-&gt;load(filename); 
   } 
   catch (...) { 
         // An exception has occurred. Return false. 
         return false; 
   } 
    
   return true; 
} </pre>
<p>We just implement the method here, which actually loads the configuration file from the filename string. In this implementation, we create an instance of the POCO <kbd>IniFileConfiguration</kbd> class on the assumption that we are trying to parse an INI file. If loading the configuration file fails for whatever reason, we return an error.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In a more fleshed-out version of this parser, we would maybe support different configuration types or even sources, with advanced error handling. For our purposes, the humble INI format more than suffices.</p>
<p>Moving on, the following code shows the <kbd>Building</kbd> class:</p>
<pre>#include &lt;vector&gt;<br/> #include &lt;string&gt;<br/><br/> #include "floor.h"<br/><br/><br/> class Building {<br/>    std::vector&lt;Floor&gt; floors;<br/><br/> public:<br/>    Building(Config &amp;cfg);<br/> };</pre>
<p>Because we haven't added any advanced features to the simulation server, there isn't much to see here yet, nor in its implementation, as shown in the following code:</p>
<pre>#include "building.h"<br/> #include "floor.h"<br/> Building::Building(Config &amp;config) {<br/>    int floor_count = config.getValue&lt;int&gt;("Building.floors", 0);<br/><br/>    for (int i = 0; i &lt; floor_count; ++i) {<br/>          Floor floor(i + 1, config); // Floor numbering starts at 1.<br/>          floors.push_back(floor);<br/>    }<br/> }</pre>
<p>Here, we read each floor definition from the file and create a <kbd>Floor</kbd> instance for it, which we add to an array. The instances also receive a reference to the configuration object.</p>
<p>The <kbd>Floor</kbd> class is basic as well, for the same reason, as you can see in the following code:</p>
<pre>#include &lt;vector&gt;<br/> #include &lt;cstdint&gt;<br/><br/> #include "room.h"<br/><br/><br/> class Floor {<br/>    std::vector&lt;Room&gt; rooms;<br/><br/> public:<br/>    Floor(uint32_t level, Config &amp;config);<br/> };<br/><br/></pre>
<p>Here's its implementation:</p>
<pre>#include "floor.h"<br/> #include "utility.h"<br/><br/> #include &lt;string&gt;<br/><br/><br/> Floor::Floor(uint32_t level, Config &amp;config) {<br/>    std::string floor_cat = "Floor_" + std::to_string(level);<br/>    std::string roomsStr = config.getValue&lt;std::string&gt;(floor_cat + ".rooms", 0);<br/><br/><br/>    std::vector&lt;std::string&gt; room_ids;<br/>    split_string(roomsStr, ',', room_ids);    <br/>    int room_count = room_ids.size();<br/><br/>    if (room_count &gt; 0) {   <br/>          for (int i = 0; i &lt; room_count; ++i) {<br/>                Room room(std::stoi(room_ids.at(i)), config);<br/>                rooms.push_back(room);<br/>          }<br/>    }<br/> }</pre>
<p>Of note is the way that the central configuration file is being parsed one part at a time by each individual class, with each class instance only caring about the small section that it has been instructed to care about by the ID.</p>
<p>Here, we are only concerned with the rooms that are defined for this floor ID. We extract the IDs for those rooms, then create new class instances for those rooms, saving a copy of each room in a vector. In a more advanced implementation of the simulation server, we could implement floor-wide events here, for example.</p>
<p>The utility header here defines a simple method for splitting strings, as shown in the following code:</p>
<pre>#include &lt;string&gt;<br/> #include &lt;vector&gt;<br/><br/><br/> void split_string(const std::string&amp; str, char chr, std::vector&lt;std::string&gt;&amp; vec);<br/><br/></pre>
<p>Here's its implementation:</p>
<pre>#include "utility.h"<br/><br/> #include &lt;algorithm&gt;<br/><br/> void split_string(const std::string&amp; str, char chr, std::vector&lt;std::string&gt;&amp; vec) {<br/>     std::string::const_iterator first = str.cbegin();<br/>     std::string::const_iterator second = std::find(first + 1, str.cend(), chr);<br/><br/>     while (second != str.cend()) {<br/>         vec.emplace_back(first, second);<br/>         first = second;<br/>         second = std::find(second + 1, str.cend(), chr);<br/>     }<br/><br/>     vec.emplace_back(first, str.cend());<br/> }</pre>
<p>This function is quite simple, using the provided separator to take a string and separate it into parts defined by said separator, which then get copied into a vector using emplacement.</p>
<p>Next, here's the <kbd>Room</kbd> class, as declared in <kbd>room.h</kbd>:</p>
<pre>#include "node.h"<br/> #include "devices/device.h"<br/><br/> #include &lt;vector&gt;<br/> #include &lt;map&gt;<br/> #include &lt;cstdint&gt;<br/><br/><br/> class Room {<br/>    std::map&lt;std::string, Node&gt; nodes;<br/>    std::vector&lt;Device&gt; devices;<br/>    std::shared_ptr&lt;RoomState&gt; state;<br/><br/> public:<br/>    Room(uint32_t type, Config &amp;config);<br/><br/> };</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's its implementation:</p>
<pre>#include "room.h"<br/><br/> #include "utility.h"<br/><br/><br/> Room::Room(uint32_t type, Config &amp;config) {<br/>    std::string room_cat = "Room_" + std::to_string(type);<br/>    std::string nodeStr = config.getValue&lt;std::string&gt;(room_cat + ".nodes", "");<br/><br/>    state-&gt;setTemperature(24.3);<br/>    state-&gt;setHumidity(51.2);<br/>    std::string sensors;<br/>    std::string actuators;<br/>    std::string node_cat;<br/>    if (!nodeStr.empty()) {<br/>          std::vector&lt;std::string&gt; node_ids;<br/>          split_string(nodeStr, ',', node_ids);<br/>          int node_count = node_ids.size();<br/><br/>          for (int i = 0; i &lt; node_count; ++i) {<br/>                Node node(node_ids.at(i), config);  <br/>                node_cat = "Node_" + node_ids.at(i);                  <br/>                nodes.insert(std::map&lt;std::string, Node&gt;::value_type(node_ids.at(i), node));<br/>          }<br/><br/>          std::string devicesStr = config.getValue&lt;std::string&gt;(node_cat + ".devices", "");<br/>          if (!devicesStr.empty()) {<br/>                std::vector&lt;std::string&gt; device_ids;<br/>                split_string(devicesStr, ':', device_ids);<br/>                int device_count = device_ids.size();<br/><br/>                for (int i = 0; i &lt; device_count; ++i) {<br/>                      std::vector&lt;std::string&gt; device_data;<br/>                      split_string(device_ids.at(i), ':', device_data);<br/>                      if (device_data.size() != 2) {<br/>                            // Incorrect data. Abort.<br/>                            continue;<br/>                      }<br/><br/>                      Device device(device_data[0], config, state);<br/><br/>                      nodes.at(device_data[1]).addDevice(std::move(device));<br/><br/>                      devices.push_back(device);<br/>                }<br/>          }<br/>    }<br/><br/> }</pre>
<p>In this class' constructor, we start off by setting the initial conditions of this room, specifically the temperature and humidity values. Next, we read out the nodes and devices for this room ID, creating instances of each. It starts by getting the list of nodes for this room, then for each node we get the list of devices, splitting this string into the individual device IDs.</p>
<p>Each device ID has a device class instantiated for it, with this instance added to the node that uses it. This finishes the basic initialization of the simulation server.</p>
<p>Next, here's the <kbd>Device</kbd> class:</p>
<pre>#include "config.h"<br/> #include "types.h"<br/><br/><br/> class Device {<br/>    std::shared_ptr&lt;RoomState&gt; roomState;<br/>    Connection connType;<br/>    std::string device;<br/>    std::string mac;<br/>    int spi_cs;<br/>    int i2c_address;<br/>    int uart_baud;          // UART baud rate.<br/>    int uart_dev;           // UART peripheral (0, 1, etc.)<br/>    Config devConf;<br/>    bool deviceState;<br/>    uint8_t i2c_register;<br/><br/>    void send(std::string data);<br/><br/> public:<br/>    Device() { }<br/>    Device(std::string id, Config &amp;config, std::shared_ptr&lt;RoomState&gt; rs);<br/>    void setMAC(std::string mac);<br/>    Connection connectionType() { return connType; }<br/>    int spiCS() { return spi_cs; }<br/>    int i2cAddress() { return i2c_address; }<br/><br/>    bool write(std::string bytes);<br/>    std::string read();<br/>    std::string read(int length);<br/> };</pre>
<p>Here's its definition:</p>
<pre>#include "device.h"<br/> #include "nodes.h"<br/><br/><br/> Device::Device(std::string id, Config &amp;config, std::shared_ptr&lt;RoomState&gt; rs) : <br/>                                                                                           roomState(rs),<br/>                                                                                           spi_cs(0) {<br/>    std::string cat = "Device_" + id;<br/>    std::string type = config.getValue&lt;std::string&gt;(cat + ".type", "");<br/>    if (type == "spi") {<br/>          connType = CONN_SPI;<br/>          spi_cs = config.getValue&lt;int&gt;(cat + ".cs_gpio", 0);<br/>          device = config.getValue&lt;std::string&gt;(cat + ".device", "");<br/>    }<br/>    else if (type == "i2c") {<br/>          connType == CONN_I2C;<br/>          i2c_address = config.getValue&lt;int&gt;(cat + ".address", 0);<br/>          device = config.getValue&lt;std::string&gt;(cat + ".device", "");<br/>    }<br/>    else if (type == "uart") {<br/>          connType == CONN_UART;<br/>          uart_baud = config.getValue&lt;int&gt;(cat + ".baud", 0);<br/>          uart_dev = config.getValue&lt;int&gt;(cat + ".uart", 0);<br/>          device = config.getValue&lt;std::string&gt;(cat + ".device", "");<br/>    }<br/>    else {<br/>          // Error. Invalid type.<br/>    }<br/><br/> }</pre>
<p>In the constructor, we read out the information for this specific device using the provided device ID. Depending on the device type, we look for specific keys. These are all stored inside member variables, as shown in the following code:</p>
<pre><br/> void Device::setMAC(std::string mac) {<br/>    this-&gt;mac = mac;<br/> }<br/><br/><br/> // Called when the device (UART-based) wishes to send data.<br/> void Device::send(std::string data) {<br/>    Nodes::sendUart(mac, data);<br/> }</pre>
<p>After a simple setter method for the MAC of the connected node, we get a method that allows generated UART events to trigger a callback to the node process via an RPC callback method (as we will see in more detail in a moment when we look at the <kbd>Nodes</kbd> class). This is shown in the following code:</p>
<pre><br/> bool Device::write(std::string bytes) {<br/>    if (!deviceState) { return false; }<br/><br/>    // The first byte contains the register to read/write with I2C. Keep it as reference.<br/>    if (connType == CONN_I2C &amp;&amp; bytes.length() &gt; 0) {<br/>          i2c_register = bytes[0];<br/>    }<br/>    else if (connType == CONN_SPI) {<br/>          // .<br/>    }<br/>    else if (connType == CONN_UART) {<br/>          //<br/>    }<br/>    else { return false; }<br/><br/>    return true;<br/> }</pre>
<p>We define a generic method to write to the device, regardless of the type. Here, we only handle the I2C interface to obtain the device register that's being addressed, as shown in the following code:</p>
<pre>std::string Device::read(int length) {<br/>    if (!deviceState) { return std::string(); }<br/><br/>    switch (connType) {<br/>          case CONN_SPI:<br/>                return std::string();<br/>                break;<br/>          case CONN_I2C:<br/>          {<br/>                // Get the specified values from the room state instance.<br/>                // Here we hard code a BME280 sensor.<br/>                // Which value we return depends on the register set.<br/>                uint8_t zero = 0x0;<br/>                switch (i2c_register) {<br/>                      case 0xFA: // Temperature. MSB, LSB, XLSB.<br/>                      {<br/>                            std::string ret = std::to_string(roomState-&gt;getTemperature()); // MSB<br/>                            ret.append(std::to_string(zero)); // LSB<br/>                            ret.append(std::to_string(zero)); // XLSB<br/>                            return ret;<br/>                            break;<br/>                      }<br/>                      case 0xF7: // Pressure. MSB, LSB, XLSB.<br/>                      {<br/>                            std::string ret = std::to_string(roomState-&gt;getPressure()); // MSB<br/>                            ret.append(std::to_string(zero)); // LSB<br/>                            ret.append(std::to_string(zero)); // XLSB<br/>                            return ret;<br/>                            break;<br/>                      }<br/>                      case 0xFD: // Humidity. MSB, LSB.<br/>                      {<br/>                            std::string ret = std::to_string(roomState-&gt;getHumidity()); // MSB<br/>                            ret.append(std::to_string(zero)); // LSB<br/>                            return ret;<br/>                            break;<br/>                      }<br/>                      default:<br/>                            return std::string();<br/>                            break;<br/>                }<br/><br/>                break;<br/>          }<br/>          case CONN_UART:<br/>                // <br/><br/>                break;<br/>          default:<br/>                // Error.<br/>                return std::string();<br/>    };<br/><br/>    return std::string();<br/> }<br/><br/> std::string Device::read() {<br/>    return read(0);<br/> }</pre>
<p class="mce-root"/>
<p>The <kbd>read</kbd> methods come with a version that defines a length parameter for the bytes to be read and a version without parameters, instead passing a zero to the first method. This parameter would be useful for a UART, where a fixed buffer size would be used for the data.</p>
<p>For simplicity's sake, we have hardcoded the response for a BME280 combined thermometer, hygrometer, and air pressure meter device. We check the value of the register that was sent over with an earlier <kbd>write</kbd> command, then return the value appropriate to it, reading the current room values as appropriate.</p>
<p>There are many more devices possible, we would want to implement them in their own configuration files or dedicated classes instead of hardcoding them all here like this.</p>
<p>Custom types for the application are defined in the <kbd>types.h</kbd> header, as shown in the following code:</p>
<pre><br/> #include &lt;memory&gt;<br/> #include &lt;thread&gt;<br/> #include &lt;mutex&gt;<br/><br/><br/> enum Connection {<br/>    CONN_NC = 0,<br/>    CONN_SPI = 1,<br/>    CONN_I2C = 2,<br/>    CONN_UART = 3<br/> };<br/><br/><br/> class RoomState {<br/>    float temperature;      // Room temperature<br/>    float humidity;         // Relatively humidity (0.00 - 100.00%)<br/>    uint16_t pressure;      // Air pressure.<br/>    std::mutex tmtx;<br/>    std::mutex hmtx;<br/>    std::mutex pmtx;<br/><br/> public:<br/>    RoomState() : <br/>          temperature(0),<br/>          humidity(0),<br/>          pressure(1000) {<br/>          //<br/>    }<br/><br/>    float getTemperature() {<br/>          std::lock_guard&lt;std::mutex&gt; lk(tmtx); <br/>          return temperature; <br/><br/>    }<br/><br/>    void setTemperature(float t) {<br/>          std::lock_guard&lt;std::mutex&gt; lk(tmtx); <br/>          temperature = t; <br/>    }<br/><br/>    float getHumidity() {<br/>          std::lock_guard&lt;std::mutex&gt; lk(hmtx); <br/>          return humidity;<br/>    }<br/><br/>    void setHumidity(float h) {<br/>          std::lock_guard&lt;std::mutex&gt; lk(hmtx);<br/>          temperature = h; <br/>    }     <br/><br/>    float getPressure() {<br/>          std::lock_guard&lt;std::mutex&gt; lk(pmtx); <br/>          return pressure;<br/>    }<br/><br/>    void setPressure(uint16_t p) {<br/>          std::lock_guard&lt;std::mutex&gt; lk(pmtx);<br/>          pressure = p;<br/>    }<br/> };</pre>
<p>Here, we see the enumeration for the different connection types, as well as the <kbd>RoomState</kbd> class, which defines a basic getter/setter-based construction, with a mutex providing thread-safe access to the individual values, as multiple nodes can try to access the same values while the room itself tries to update them.</p>
<p>Next, here's the <kbd>Node</kbd> class:</p>
<pre>#include "config.h"<br/> #include "devices/device.h"<br/><br/> #include &lt;string&gt;<br/> #include &lt;vector&gt;<br/> #include &lt;map&gt;<br/><br/><br/> class Node {<br/>    std::string mac;<br/>    bool uart0_active;<br/>    Device uart0;<br/>    std::map&lt;int, Device&gt; i2c;<br/>    std::map&lt;int, Device&gt; spi;<br/>    std::vector&lt;Device&gt; devices;<br/><br/> public:<br/>    Node(std::string id, Config &amp;config);<br/>    bool addDevice(Device &amp;&amp;device);<br/><br/>    bool writeUart(std::string bytes);<br/>    bool writeSPI(std::string bytes);<br/>    std::string readSPI();<br/>    bool writeI2C(int i2cAddress, std::string bytes);<br/>    std::string readI2C(int i2cAddress, int length);<br/> };</pre>
<p>Here's its implementation:</p>
<pre>#include "node.h"<br/> #include "nodes.h"<br/><br/> #include &lt;cstdlib&gt;<br/> #include &lt;utility&gt;<br/><br/><br/> Node::Node(std::string id, Config &amp;config) : uart0_active(false) {<br/>    std::string node_cat = "Node_" + id;<br/>    mac = config.getValue&lt;std::string&gt;(node_cat + ".mac", "");<br/><br/>    Nodes::addNode(mac, this);<br/>    std::system("esp8266");<br/> };</pre>
<p>When a new class instance is created, it obtains its MAC address, adds it to its own local variable, and registers it with the <kbd>Nodes</kbd> class. A new instance of the node executable (in our case, called <kbd>esp8266</kbd>) is launched using the native system call, which will cause the OS to start this new process.</p>
<p>As the new process starts, it will connect to the RPC server and obtain the MAC using the RPC functions that we looked at earlier in this section. After this, the class instance and the remote process act as mirror images of each other:</p>
<pre>bool Node::addDevice(Device &amp;&amp;device) {<br/>    device.setMAC(mac);<br/><br/>    switch (device.connectionType()) {<br/>          case CONN_SPI:<br/>                spi.insert(std::pair&lt;int, Device&gt;(device.spiCS(), std::move(device)));<br/>                break;<br/>          case CONN_I2C:<br/>                i2c.insert(std::pair&lt;int, Device&gt;(device.i2cAddress(), std::move(device)));<br/>                break;<br/>          case CONN_UART:<br/>                uart0 = std::move(device);<br/>                uart0_active = true;<br/>                break;<br/>          default:<br/>                // Error.<br/>                break;<br/>    }<br/><br/>    return true;<br/> }</pre>
<p>When the <kbd>Room</kbd> class assigns a new device to the node, we assign our MAC to it to act as an identifier for which node it belongs to. After this, we query the device to see which type of interface it has, so that we can add it to the proper interface, taking into account the CS line (if used) for SPI and the bus address for I2C.</p>
<p>Using move semantics, we ensure that we aren't merely mindlessly making copies of the same device class instance, but essentially shifting ownership of the original instance, thus improving efficiency. Let's look at the following code:</p>
<pre>bool Node::writeUart(std::string bytes) {<br/>    if (!uart0_active) { return false; }<br/><br/>    uart0.write(bytes);<br/><br/>    return true;<br/> }<br/><br/><br/> bool Node::writeSPI(std::string bytes) {<br/>    if (spi.size() == 1) {<br/>          spi[0].write(bytes);<br/>    }<br/>    else {<br/>          return false; <br/>    }<br/><br/>    return true;<br/> }<br/><br/><br/> std::string Node::readSPI() {<br/>    if (spi.size() == 1) {<br/>          return spi[0].read();<br/>    }<br/>    else {<br/>          return std::string();<br/>    }<br/> }<br/><br/><br/> bool Node::writeI2C(int i2cAddress, std::string bytes) {<br/>    if (i2c.find(i2cAddress) == i2c.end()) { return false; }<br/><br/>    i2c[i2cAddress].write(bytes);<br/>    return true;<br/> }<br/><br/><br/> std::string Node::readI2C(int i2cAddress, int length) {<br/>    if (i2c.count(i2cAddress) || length &lt; 1) { return std::string(); }<br/><br/>    return i2c[i2cAddress].read(length);<br/> }<br/><br/></pre>
<p>For the writing and reading functionality, not a lot is involved. Using the CS (SPI), the bus address (I2C), or neither (UART), we know which type of device to access and call its respective methods.</p>
<p>Finally, here's the <kbd>Nodes</kbd> class that ties everything together:</p>
<pre>#include &lt;map&gt;<br/> #include &lt;string&gt;<br/> #include &lt;queue&gt;<br/><br/><br/> class Node;<br/><br/><br/> class Nodes {<br/>    static Node* getNode(std::string mac);<br/><br/>    static std::map&lt;std::string, Node*&gt; nodes;<br/>    static std::queue&lt;std::string&gt; macs;<br/>    static std::map&lt;std::string, int&gt; sessions;<br/><br/> public:<br/>    static bool addNode(std::string mac, Node* node);<br/>    static bool removeNode(std::string mac);<br/>    static void registerSession(std::string mac, int session);<br/>    static bool writeUart(std::string mac, std::string bytes);<br/>    static bool sendUart(std::string mac, std::string bytes);<br/>    static bool writeSPI(std::string mac, std::string bytes);<br/>    static std::string readSPI(std::string mac);<br/>    static bool writeI2C(std::string mac, int i2cAddress, std::string bytes);<br/>    static std::string readI2C(std::string mac, int i2cAddress, int length);<br/>    static void addMAC(std::string mac);<br/>    static std::string getMAC();<br/> };</pre>
<p>Here's its definition:</p>
<pre>#include "nodes.h"<br/> #include "node.h"<br/> #include &lt;nymph/nymph.h&gt;<br/><br/><br/> // Static initialisations.<br/> std::map&lt;std::string, Node*&gt; Nodes::nodes;<br/> std::queue&lt;std::string&gt; Nodes::macs;<br/> std::map&lt;std::string, int&gt; Nodes::sessions;<br/><br/><br/> Node* Nodes::getNode(std::string mac) {<br/>    std::map&lt;std::string, Node*&gt;::iterator it;<br/>    it = nodes.find(mac);<br/>    if (it == nodes.end()) { return 0; }<br/><br/>    return it-&gt;second;<br/> }<br/><br/><br/> bool Nodes::addNode(std::string mac, Node* node) {<br/>    std::pair&lt;std::map&lt;std::string, Node*&gt;::iterator, bool&gt; ret;<br/>    ret = nodes.insert(std::pair&lt;std::string, Node*&gt;(mac, node));<br/>    if (ret.second) { macs.push(mac); }<br/>    return ret.second;<br/> }<br/><br/><br/> bool Nodes::removeNode(std::string mac) {<br/>    std::map&lt;std::string, Node*&gt;::iterator it;<br/>    it = nodes.find(mac);<br/>    if (it == nodes.end()) { return false; }  <br/>    nodes.erase(it);<br/>    return true;<br/> }</pre>
<p>With the following methods, we can set and remove node class instances:</p>
<pre>void Nodes::registerSession(std::string mac, int session) {<br/>    sessions.insert(std::pair&lt;std::string, int&gt;(mac, session));<br/> }</pre>
<p>New MAC and RPC session IDs are registered with the following function:</p>
<pre>bool Nodes::writeUart(std::string mac, std::string bytes) {<br/>    Node* node = getNode(mac);<br/>    if (!node) { return false; }<br/><br/>    node-&gt;writeUart(bytes);<br/><br/>    return true;<br/> }<br/><br/><br/> bool Nodes::sendUart(std::string mac, std::string bytes) {<br/>    std::map&lt;std::string, int&gt;::iterator it;<br/>    it = sessions.find(mac);<br/>    if (it == sessions.end()) { return false; }<br/><br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(bytes));<br/>    string result;<br/>    NymphBoolean* world = 0;<br/>    if (!NymphRemoteClient::callCallback(it-&gt;second, "serialRxCallback", values, result)) {<br/>          // <br/>    }<br/><br/>    return true;<br/> }<br/><br/><br/> bool Nodes::writeSPI(std::string mac, std::string bytes) {<br/>    Node* node = getNode(mac);<br/>    if (!node) { return false; }<br/><br/>    node-&gt;writeSPI(bytes);<br/><br/>    return true;<br/> }<br/><br/><br/> std::string Nodes::readSPI(std::string mac) {<br/>    Node* node = getNode(mac);<br/>    if (!node) { return std::string(); }<br/><br/>    return node-&gt;readSPI();<br/> }<br/><br/><br/> bool Nodes::writeI2C(std::string mac, int i2cAddress, std::string bytes) {<br/>    Node* node = getNode(mac);<br/>    if (!node) { return false; }<br/><br/>    node-&gt;writeI2C(i2cAddress, bytes);<br/><br/>    return true;<br/> }<br/><br/><br/> std::string Nodes::readI2C(std::string mac, int i2cAddress, int length) {<br/>    Node* node = getNode(mac);<br/>    if (!node) { return std::string(); }<br/><br/>    return node-&gt;readI2C(i2cAddress, length);<br/> }</pre>
<p>The methods for writing and reading from the different interfaces are basically pass-through methods, merely using the MAC address to find the appropriate <kbd>Node</kbd> instance to call the method on.</p>
<p>Of note here is the <kbd>sendUart()</kbd> method, which uses the NymphRPC server to call the callback method on the appropriate node process to trigger its UART receive callback, as shown in the following code:</p>
<pre>void Nodes::addMAC(std::string mac) {<br/>    macs.push(mac);<br/> }<br/><br/><br/> std::string Nodes::getMAC() {<br/>     if (macs.empty()) { return std::string(); }<br/><br/>     std::string val = macs.front();<br/>     macs.pop();<br/>     return val;<br/>  }</pre>
<p>Finally, we got the methods used to set and get the MAC address for new nodes.</p>
<p>With this, we have the basics of the full integration server. In the next section, we will take a look at the firmware and client side of the system before looking at how everything fits together.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Makefile</h1>
                </header>
            
            <article>
                
<p>The Makefile for this part of the project looks as follows:</p>
<pre>export TOP := $(CURDIR)<br/><br/> GPP = g++<br/> GCC = gcc<br/> MAKEDIR = mkdir -p<br/> RM = rm<br/><br/> OUTPUT = bmac_server<br/> INCLUDE = -I .<br/> FLAGS := $(INCLUDE) -g3 -std=c++17 -U__STRICT_ANSI__<br/> LIB := -lnymphrpc -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON<br/> CPPFLAGS := $(FLAGS)<br/> CFLAGS := -g3 <br/> CPP_SOURCES := $(wildcard *.cpp) $(wildcard devices/*.cpp)<br/> CPP_OBJECTS := $(addprefix obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))<br/><br/> all: makedir $(C_OBJECTS) $(CPP_OBJECTS) bin/$(OUTPUT)<br/><br/> obj/%.o: %.cpp<br/>    $(GPP) -c -o $@ $&lt; $(CPPFLAGS)<br/><br/> bin/$(OUTPUT):<br/>    -rm -f $@<br/>    $(GPP) -o $@ $(C_OBJECTS) $(CPP_OBJECTS) $(LIB)<br/><br/> makedir:<br/>    $(MAKEDIR) bin<br/>    $(MAKEDIR) obj/devices<br/><br/> clean:<br/>    $(RM) $(CPP_OBJECTS)</pre>
<p>This is a rather simple Makefile as we have no special demands. We gather the source files, determine the names of the resulting object files, and compile all of them before generating a binary out of these object files.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The node</h1>
                </header>
            
            <article>
                
<p>This section covers the firmware for the integration test<span> s</span>pecifically the reimplementation of the (Arduino) APIs used in the Sming framework.</p>
<p>Most crucial here is that we don't in any way modify the firmware code itself. The only parts that we wish to change from the original firmware image for the ESP8266 MCU are the APIs that our own code interacts with.</p>
<p>This means that we have to first determine the APIs that our code interacts with and reimplement these in a way that is supported on the target (desktop) platform. For our ESP8266-based firmware, this means, for example, that the Wi-Fi network side is left unimplemented, as we are using the local network stack of the OS and therefore don't care about such details.</p>
<p>Similarly, the I2C, SPI, and UART interfaces are implemented as mere stubs that call their respective counterparts on the RPC interface, which we looked at in the previous section. For the MQTT protocol client, we could use the <kbd>emqtt</kbd> MQTT library that is part of the Sming framework, but as one will quickly find out, this library is meant to be used on embedded systems where the code using it is responsible for connecting it to the network stack.</p>
<p>Our code interacts with the API offered by the <kbd>MqttClient</kbd> class in Sming. It uses <kbd>emqtt</kbd> for the MQTT protocol, and inherits from the <kbd>TcpClient</kbd> class. Following the code down the hierarchy, one will end up at the TCP connection class before diving into the underlying LWIP network library stack.</p>
<p>In order to save ourselves a lot of trouble, it's easiest to just use an alternative MQTT library, such as the Mosquitto client library, which is meant to be run on a desktop OS, and will therefore use the OS-provided sockets API. This will cleanly map to the methods provided by Sming's MQTT client class.</p>
<p>We can leave the header for this class almost entirely untouched, just adding our modifications to integrate the Mosquitto library, as follows:</p>
<pre>class TcpClient;<br/> #include "../Delegate.h"<br/> #include "../../Wiring/WString.h"<br/> #include "../../Wiring/WHashMap.h"<br/> #include "libmosquitto/cpp/mosquittopp.h"<br/> #include "URL.h"<br/><br/> typedef Delegate&lt;void(String topic, String message)&gt; MqttStringSubscriptionCallback;<br/> typedef Delegate&lt;void(uint16_t msgId, int type)&gt; MqttMessageDeliveredCallback;<br/> typedef Delegate&lt;void(TcpClient&amp; client, bool successful)&gt; TcpClientCompleteDelegate;<br/><br/> class MqttClient;<br/> class URL;<br/><br/> class MqttClient : public mosqpp::mosquittopp {<br/> public:<br/>    MqttClient(bool autoDestruct = false);<br/>    MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback = NULL);<br/>    virtual ~MqttClient();<br/><br/>    void setCallback(MqttStringSubscriptionCallback subscriptionCallback = NULL);<br/><br/>    void setCompleteDelegate(TcpClientCompleteDelegate completeCb);<br/><br/>    void setKeepAlive(int seconds);     <br/>    void setPingRepeatTime(int seconds);<br/>    bool setWill(const String&amp; topic, const String&amp; message, int QoS, bool retained = false);<br/>    bool connect(const URL&amp; url, const String&amp; uniqueClientName, uint32_t sslOptions = 0);<br/>    bool connect(const String&amp; clientName, bool useSsl = false, uint32_t sslOptions = 0);<br/>    bool connect(const String&amp; clientName, const String&amp; username, const String&amp; password, bool useSsl = false,<br/>                       uint32_t sslOptions = 0);<br/><br/>    bool publish(String topic, String message, bool retained = false);<br/>    bool publishWithQoS(String topic, String message, int QoS, bool retained = false,<br/>                                  MqttMessageDeliveredCallback onDelivery = NULL);<br/><br/>    bool subscribe(const String&amp; topic);<br/>    bool unsubscribe(const String&amp; topic);<br/><br/>    void on_message(const struct mosquitto_message* message);<br/><br/> protected:<br/>    void debugPrintResponseType(int type, int len);<br/>    static int staticSendPacket(void* userInfo, const void* buf, unsigned int count);<br/><br/> private:<br/>    bool privateConnect(const String&amp; clientName, const String&amp; username, const String&amp; password,<br/>                                  bool useSsl = false, uint32_t sslOptions = 0);<br/><br/>    URL url;<br/>    mosqpp::mosquittopp mqtt;<br/>    int waitingSize;<br/>    uint8_t buffer[MQTT_MAX_BUFFER_SIZE + 1];<br/>    uint8_t* current;<br/>    int posHeader;<br/>    MqttStringSubscriptionCallback callback;<br/>    TcpClientCompleteDelegate completed = nullptr;<br/>    int keepAlive = 60;<br/>    int pingRepeatTime = 20;<br/>    unsigned long lastMessage = 0;<br/>    HashMap&lt;uint16_t, MqttMessageDeliveredCallback&gt; onDeliveryQueue;<br/> };</pre>
<p>We're including the header file for the C++-based wrapper for the Mosquitto client library here from the version of the Mosquitto library that is included in the project for this chapter. This is because the official version of the library doesn't support building with MinGW.</p>
<p>With the header included, we have the class derive from the Mosquitto MQTT client class instead.</p>
<p>Naturally, the implementation of the Sming MQTT client class has been completely changed, as you can see in the following code:</p>
<pre>#include "MqttClient.h"<br/> #include "../Clock.h"<br/> #include &lt;algorithm&gt;<br/> #include &lt;cstring&gt;<br/><br/> MqttClient::MqttClient(bool autoDestruct /* = false*/)<br/> {<br/>    memset(buffer, 0, MQTT_MAX_BUFFER_SIZE + 1);<br/>    waitingSize = 0;<br/>    posHeader = 0;<br/>    current = NULL;<br/><br/>    mosqpp::lib_init();<br/> }<br/><br/> MqttClient::MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback /* = NULL*/)<br/>    {<br/>    url.Host = serverHost;<br/>    url.Port = serverPort;<br/>    this-&gt;callback = callback;<br/>    waitingSize = 0;<br/>    posHeader = 0;<br/>    current = NULL;<br/><br/>    mosqpp::lib_init();<br/> }</pre>
<p>The constructor simply initializes the Mosquitto library, with no further input required:</p>
<pre><br/> MqttClient::~MqttClient() {<br/>    mqtt.loop_stop();<br/>    mosqpp::lib_cleanup();<br/> }</pre>
<p>In the destructor (shown in the following code) we stop the MQTT client-listening thread that we launched when we connect to an MQTT broker and clean up the resources that were used by the library:</p>
<pre><br/> void MqttClient::setCallback(MqttStringSubscriptionCallback callback) {<br/>    this-&gt;callback = callback;<br/> }<br/><br/> void MqttClient::setCompleteDelegate(TcpClientCompleteDelegate completeCb) {<br/>    completed = completeCb;<br/> }<br/><br/> void MqttClient::setKeepAlive(int seconds) {<br/>    keepAlive = seconds;<br/> }<br/><br/> void MqttClient::setPingRepeatTime(int seconds) {<br/>    if(pingRepeatTime &gt; keepAlive) {<br/>          pingRepeatTime = keepAlive;<br/>    } else {<br/>          pingRepeatTime = seconds;<br/>    }<br/> }<br/><br/> bool MqttClient::setWill(const String&amp; topic, const String&amp; message, int QoS, bool retained /* = false*/)<br/> {<br/>    return mqtt.will_set(topic.c_str(), message.length(), message.c_str(), QoS, retained);<br/> }</pre>
<p>We have a number of utility functions, not all of which are being utilized, but they are still implemented here for the sake of completeness. It's also hard to predict which ones will be required, therefore it's often better to implement more than strictly necessary, especially if they are small functions that take less time to implement than to find out whether that function or method is used at all. Let's look at the following code:</p>
<pre><br/> bool MqttClient::connect(const URL&amp; url, const String&amp; clientName, uint32_t sslOptions) {<br/>    this-&gt;url = url;<br/>    if(!(url.Protocol == "mqtt" || url.Protocol == "mqtts")) {<br/>          return false;<br/>    }<br/><br/>    waitingSize = 0;<br/>    posHeader = 0;<br/>    current = NULL;<br/><br/>    bool useSsl = (url.Protocol == "mqtts");<br/>    return privateConnect(clientName, url.User, url.Password, useSsl, sslOptions);<br/> }<br/><br/> bool MqttClient::connect(const String&amp; clientName, bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)<br/> {<br/>    return MqttClient::connect(clientName, "", "", useSsl, sslOptions);<br/> }<br/><br/> bool MqttClient::connect(const String&amp; clientName, const String&amp; username, const String&amp; password,<br/>                                   bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)<br/> {<br/>    return privateConnect(clientName, username, password, useSsl, sslOptions);<br/> }</pre>
<p>The <kbd>connect</kbd> methods remain the same, as they all use the same <kbd>private</kbd> method of the class to perform the actual connection operation, as shown in the following code:</p>
<pre><br/> bool MqttClient::privateConnect(const String&amp; clientName, const String&amp; username, const String&amp; password,<br/>                                              bool useSsl /* = false */, uint32_t sslOptions /* = 0 */) {<br/>    if (clientName.length() &gt; 0) {<br/>          mqtt.reinitialise(clientName.c_str(), false);<br/>    }<br/><br/>    if (username.length() &gt; 0) {<br/>          mqtt.username_pw_set(username.c_str(), password.c_str());<br/>    }<br/><br/>    if (useSsl) {<br/>          //<br/>    }<br/><br/>    mqtt.connect(url.Host.c_str(), url.Port, keepAlive);<br/>    mqtt.loop_start();<br/>    return true;<br/> }</pre>
<p>This is the first section where we directly use the Mosquitto library. We reinitialize the instance either without a password or TLS (anonymous broker access), or with a password, or with TLS (left unimplemented here, as we don't need it).</p>
<p>In this method, we also start the listening thread for the MQTT client, which will handle all incoming messages so that we don't have to further concern ourselves with this aspect of the process. Let's look at the following code:</p>
<pre><br/> bool MqttClient::publish(String topic, String message, bool retained /* = false*/) {<br/>    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), 0, retained);<br/>    return res &gt; 0;<br/> }<br/><br/> bool MqttClient::publishWithQoS(String topic, String message, int QoS, bool retained /* = false*/,<br/>                                              MqttMessageDeliveredCallback onDelivery /* = NULL */)<br/> {<br/>    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), QoS, retained);<br/><br/>    return res &gt; 0;<br/> }</pre>
<p class="mce-root"/>
<p>The MQTT message-publish functionality directly maps to the Mosquitto library's methods:</p>
<pre><br/> bool MqttClient::subscribe(const String&amp; topic) {<br/>    int res = mqtt.subscribe(0, topic.c_str());<br/>    return res &gt; 0;<br/> }<br/><br/> bool MqttClient::unsubscribe(const String&amp; topic) {<br/>    int res = mqtt.unsubscribe(0, topic.c_str());<br/>    return res &gt; 0;<br/> }</pre>
<p>Subscribing and unsubscribing both also map easily to the MQTT client instance, as shown in the following code:</p>
<pre><br/><br/> void MqttClient::on_message(const struct mosquitto_message* message) {<br/>    if (callback) {<br/>          callback(String(message-&gt;topic), String((char*) message-&gt;payload, message-&gt;payloadlen));<br/>    }<br/> }<br/><br/></pre>
<p>Finally, we implement the Mosquitto <kbd>callback</kbd> method for when we receive a new message from the broker. For each received message, we then call the registered <kbd>callback</kbd> method (from the firmware code) to provide it with the payload and topic.</p>
<p>This takes care of the MQTT client aspect of the firmware. Next, we need to make the rest of the APIs compatible with a desktop OS.</p>
<p>The headers of the Sming framework that the firmware uses are as follows:</p>
<pre>#include &lt;user_config.h&gt;<br/> #include &lt;SmingCore/SmingCore.h&gt;</pre>
<p>The first header file defines some platform-related features that we don't need. The second header is the one that we will add everything that we need to.</p>
<p>To check the firmware's code for API dependencies, we use standard text searching tools to find all function calls, filtering out any that do not call into our code but into the Sming framework. After doing this we can write the following <span class="packt_screen">SmingCore.h</span> file with these dependencies:</p>
<pre>#include &lt;cstdint&gt;<br/> #include &lt;cstdio&gt;<br/> #include &lt;string&gt;<br/> #include &lt;iostream&gt;<br/> #include "wiring/WString.h"<br/> #include "wiring/WVector.h"<br/> #include "wiring/WHashMap.h"<br/> #include "FileSystem.h"<br/> #include "wiring/Stream.h"<br/> #include "Delegate.h"<br/> #include "Network/MqttClient.h"<br/> #include "Timer.h"<br/> #include "WConstants.h"<br/> #include "Clock.h"<br/><br/> #include &lt;nymph/nymph.h&gt;<br/><br/></pre>
<p>We start off with a combination of standard C library and STL includes, along with a number of headers that define the rest of the API that we are implementing. We also directly use a number of header files that define classes that are used throughout these APIs, but not by the firmware itself.</p>
<p>A class like the <kbd>Delegate</kbd> class is sufficiently abstract that it can be used as is. As we will see, the <kbd>Filesystem</kbd> and <kbd>Timer</kbd> classes required a fair bit of reworking to make them work for our purposes. We already looked at the modifications to the MQTT client earlier.</p>
<p>Naturally, we also include the header file for the NymphRPC library, which will allow us to communicate with the server side of the integration test, as shown in the following code:</p>
<pre>typedef uint8_t uint8;<br/> typedef uint16_t uint16;<br/> typedef uint32_t uint32;<br/> typedef int8_t int8;<br/> typedef int16_t int16;<br/> typedef int32_t int32;<br/> typedef uint32_t u32_t;</pre>
<p>For compatibility reasons, we need to define a range of types that are used throughout the firmware code. These are equivalent to the types in <kbd>cstdint</kbd> from the C library, so we can use simple <kbd>typedefs</kbd>, as follows:</p>
<pre>#define UART_ID_0 0 ///&lt; ID of UART 0<br/> #define UART_ID_1 1 ///&lt; ID of UART 1<br/> #define SERIAL_BAUD_RATE 115200<br/><br/> typedef Delegate&lt;void(Stream&amp; source, char arrivedChar, uint16_t availableCharsCount)&gt; StreamDataReceivedDelegate;<br/><br/> class SerialStream : public Stream {<br/>    //<br/><br/> public:<br/>    SerialStream();<br/>    size_t write(uint8_t);<br/>    int available();<br/>    int read();<br/>    void flush();<br/>    int peek();<br/> };<br/><br/> class HardwareSerial {<br/>    int uart;<br/>    uint32_t baud;<br/>    static StreamDataReceivedDelegate HWSDelegate;<br/>    static std::string rxBuffer;<br/><br/> public:<br/>    HardwareSerial(const int uartPort);<br/>    void begin(uint32_t baud = 9600);<br/>    void systemDebugOutput(bool enable);<br/>    void end();<br/>    size_t printf(const char *fmt, ...);<br/>    void print(String str);<br/>    void println(String str);<br/>    void println(const char* str);<br/>    void println(int16_t ch);<br/>    void setCallback(StreamDataReceivedDelegate dataReceivedDelegate);<br/>    static void dataReceivedCallback(NymphMessage* msg, void* data);<br/>    size_t write(const uint8_t* buffer, size_t size);<br/>    size_t readBytes(char *buffer, size_t length);<br/> };<br/><br/> extern HardwareSerial Serial;</pre>
<p>The first API we fully reimplement is the hardware-based serial device. Since this communicates directly with the virtual interface in the server, we just need to provide the methods here, with the definition in the source file, as we will see in a moment.</p>
<p>We also declare a global instantiation of this serial object class, identical to how the original framework implementation handles it, as shown in the following code:</p>
<pre> struct rboot_config {<br/>    uint8 current_rom;<br/>    uint32 roms[2];<br/> };<br/><br/> int rboot_get_current_rom();<br/> void rboot_set_current_rom(int slot);<br/> rboot_config rboot_get_config();<br/><br/> class rBootHttpUpdate;<br/> typedef Delegate&lt;void(rBootHttpUpdate&amp; client, bool result)&gt; OtaUpdateDelegate;<br/> class rBootHttpUpdate {<br/>    //<br/><br/> public:<br/>    void addItem(int offset, String firmwareFileUrl);<br/>    void setCallback(OtaUpdateDelegate reqUpdateDelegate);<br/>    void start();<br/> };<br/><br/><br/> void spiffs_mount_manual(u32_t offset, int count);</pre>
<p>The rboot boot manager and SPIFFS filesystem-related functionality has no equivalent on a desktop system, so we declare them here (but as we'll see in a moment, they are left as empty stubs):</p>
<pre><br/> class StationClass {<br/>    String mac;<br/>    bool enabled;<br/><br/> public:<br/>    void enable(bool enable);<br/>    void enable(bool enable, bool save);<br/>    bool config(const String&amp; ssid, const String&amp; password, bool autoConnectOnStartup = true,<br/>                                    bool save = true);<br/>    bool connect();<br/>    String getMAC();<br/><br/>    static int handle;<br/> };<br/><br/> extern StationClass WifiStation;<br/><br/><br/> class AccessPointClass {<br/>    bool enabled;<br/><br/> public:<br/>    void enable(bool enable, bool save);<br/>    void enable(bool enable);<br/> };<br/><br/> extern AccessPointClass WifiAccessPoint;<br/><br/><br/> class IPAddress {<br/>    //<br/> public:<br/>    String toString();<br/> };<br/><br/> typedef Delegate&lt;void(uint8_t[6], uint8_t)&gt; AccessPointDisconnectDelegate;<br/> typedef Delegate&lt;void(String, uint8_t, uint8_t[6], uint8_t)&gt; StationDisconnectDelegate;<br/> typedef Delegate&lt;void(IPAddress, IPAddress, IPAddress)&gt; StationGotIPDelegate;<br/> class WifiEventsClass {<br/>    //<br/><br/> public:<br/>    void onStationGotIP(StationGotIPDelegate delegateFunction); <br/>    void onStationDisconnect(StationDisconnectDelegate delegateFunction);<br/> };<br/><br/> extern WifiEventsClass WifiEvents;</pre>
<p>On the network side, we have to provide all of the class instances and related information that are normally used to connect to a WiFi access point and ensure that we are connected. As we aren't testing <span><span>WiFi functionality</span></span> here, these methods are of little use, but are needed to satisfy the firmware code and the compiler:</p>
<pre><br/> void debugf(const char *fmt, ...);<br/><br/><br/> class WDTClass {<br/>    //<br/><br/> public:<br/>    void alive();<br/> };<br/><br/> extern WDTClass WDT;</pre>
<p>We then declare the debug-related output function as well as the watchdog class using the following code:</p>
<pre><br/> class TwoWire {<br/>    uint8_t rxBufferIndex;<br/>    std::string buffer;<br/>    int i2cAddress;<br/><br/> public:<br/>    void pins(int sda, int scl);<br/>    void begin();<br/>    void beginTransmission(int address);<br/>    size_t write(uint8_t data);<br/>    size_t write(int data);<br/>    size_t endTransmission();<br/>    size_t requestFrom(int address, int length);<br/>    int available();<br/>    int read();<br/> };<br/><br/> extern TwoWire Wire;<br/><br/><br/> class SPISettings {<br/>    //<br/> public:<br/>    //<br/> };<br/><br/> class SPIClass {<br/>    //<br/><br/> public:<br/>    void begin();<br/>    void end();<br/>    void beginTransaction(SPISettings mySettings);<br/>    void endTransaction();<br/>    void transfer(uint8* buffer, size_t numberBytes);<br/> };<br/><br/> extern SPIClass SPI;</pre>
<p>We declare the two types of communication buses here, as shown in the following code. Again, we declare that there is a global instantiation of each:</p>
<pre>void pinMode(uint16_t pin, uint8_t mode);<br/> void digitalWrite(uint16_t pin, uint8_t val);<br/> uint8_t digitalRead(uint16_t pin);<br/><br/><br/> uint16_t analogRead(uint16_t pin);</pre>
<p>Since the firmware contains code that uses the GPIO and ADC pins, <span><span>the above </span></span>functions are needed as well.</p>
<pre>String system_get_sdk_version();<br/> int system_get_free_heap_size();<br/> int system_get_cpu_freq();<br/> int system_get_chip_id();<br/> int spi_flash_get_id();<br/><br/> class SystemClass {<br/>    //<br/><br/> public:<br/>    void restart();<br/> };<br/><br/> extern SystemClass System;<br/><br/><br/> // --- TcpClient ---<br/> class TcpClient {<br/>    //<br/><br/> public:<br/>    //<br/> };<br/><br/><br/> extern void init();</pre>
<p>Finally, we declare a number of classes and functions that are mostly there to satisfy the compiler as they have no practical use for our purposes, though we could potentially implement advanced test scenarios this way.</p>
<p>Next, we'll look at the implementation of these functions using the following code:</p>
<pre><br/> #include "SmingCore.h"<br/><br/> #include &lt;iostream&gt;<br/> #include &lt;cstdio&gt;<br/> #include &lt;cstdarg&gt;<br/><br/><br/> int StationClass::handle;</pre>
<p>The <kbd>handle</kbd> variable is the one variable we declare as being static in this compile unit. Its purpose is to store the remote server handle ID for future operations after we connect to the RPC server, as shown in the following code:</p>
<pre><br/> void logFunction(int level, string logStr) {<br/>    std::cout &lt;&lt; level &lt;&lt; " - " &lt;&lt; logStr &lt;&lt; std::endl;<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Just like in the server-side code, we define a simple logging function to use with NymphRPC, as shown in the following code:</p>
<pre><br/> void debugf(const char *fmt, ...) { <br/>    va_list ap;<br/>    va_start(ap, fmt);<br/>    int written = vfprintf(stdout, fmt, ap);<br/>    va_end(ap);<br/> }</pre>
<p>We implement the simple debug output function using C-style string formatting features to fit the function's signature, as shown in the following code:</p>
<pre><br/> StreamDataReceivedDelegate HardwareSerial::HWSDelegate = nullptr;<br/> std::string HardwareSerial::rxBuffer;<br/> HardwareSerial Serial(0);</pre>
<p>We define the serial callback delegate along with the serial receive buffer as static, as we assume the presence of a single UART capable of <strong>receiving data</strong> (RX), which happens to be the case on the ESP8266 MCU. We also create a single instance of the <kbd>HardwareSerial</kbd> class, for UART 0, as shown in the following code:</p>
<pre><br/> SerialStream::SerialStream() { }<br/> size_t SerialStream::write(uint8_t) { return 1; }<br/> int SerialStream::available() { return 0; }<br/> int SerialStream::read() { return 0; }<br/> void SerialStream::flush() { }<br/> int SerialStream::peek() { return 0; }</pre>
<p>This class is just there to act as a stub. As none of the code actually uses this object's methods, we can leave them all unimplemented, as shown in the following code:</p>
<pre>HardwareSerial::HardwareSerial(const int uartPort) { <br/>    uart = uartPort; <br/> }<br/><br/> void HardwareSerial::begin(uint32_t baud/* = 9600*/) { <br/>    this-&gt;baud = baud;<br/> }<br/><br/><br/> void HardwareSerial::systemDebugOutput(bool enable) { }<br/> void HardwareSerial::end() { }<br/> size_t HardwareSerial::printf(const char *fmt, ...) { <br/>    va_list ap;<br/>    va_start(ap, fmt);<br/>          int written = vfprintf(stdout, fmt, ap);<br/>          va_end(ap);<br/><br/>    return written;<br/> }<br/><br/><br/> void HardwareSerial::print(String str) {<br/>    std::cout &lt;&lt; str.c_str();<br/> }<br/><br/><br/> void HardwareSerial::println(String str) {<br/>    std::cout &lt;&lt; str.c_str() &lt;&lt; std::endl;<br/> }<br/><br/><br/> void HardwareSerial::println(const char* str) {<br/>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br/> }<br/><br/><br/> void HardwareSerial::println(int16_t ch) {<br/>    std::cout &lt;&lt; std::hex &lt;&lt; ch &lt;&lt; std::endl;<br/> }<br/><br/><br/> void HardwareSerial::setCallback(StreamDataReceivedDelegate dataReceivedDelegate) {<br/>    HWSDelegate = dataReceivedDelegate;<br/> }</pre>
<p>A lot of the methods in this class are simple enough that they can be implemented as a simple write to the standard (system) output or with an assignment to a variable. Occasionally a method is left unaltered from the original, though even for the setting of the callback delegate function in the last method in this group, the original code is called into the C-based low-level APIs of the ESP8266's SDK. Let's look at the following code:</p>
<pre><br/> void HardwareSerial::dataReceivedCallback(NymphMessage* msg, void* data) {<br/>    rxBuffer = ((NymphString*) msg-&gt;parameters()[0])-&gt;getValue();<br/><br/>    SerialStream stream;<br/>    int length = rxBuffer.length();<br/>    int i = 0;<br/>    HWSDelegate(stream, rxBuffer[i], length - i);<br/> }</pre>
<p class="mce-root"/>
<p>To receive UART messages, we define a NymphRPC callback function, which for that reason is defined as being static. Since the ESP8266 only has a single UART capable of receiving data this suffices.</p>
<p>When called, this method reads out the payload being received on the UART and calls the <kbd>callback</kbd> function that the firmware registered previously, as shown in the following code:</p>
<pre><br/> size_t HardwareSerial::write(const uint8_t* buffer, size_t size) {<br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(WifiStation.getMAC().c_str()));<br/>    values.push_back(new NymphString(std::string((const char*) buffer, size)));<br/>    NymphType* returnValue = 0;<br/>    std::string result;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeUart", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_BOOL) {<br/>          std::cout &lt;&lt; "Return value wasn't a boolean. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    return size;<br/> }</pre>
<p>Writing to the remote UART is done using an RPC call. To do this, we create an STL vector and fill it with the parameters to pass in the proper order—in this case, the node's MAC address and the data that we wish to send on the remote UART.</p>
<p>After this, we use the NymphRPC handle that we got when we connected to call the RPC server and wait for the response from the remote function, as shown in the following code:</p>
<pre><br/> size_t HardwareSerial::readBytes(char* buffer, size_t length) {<br/>    buffer = rxBuffer.data();<br/>    return rxBuffer.length();<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Reading from the UART is done after we've received data on the UART, after which we can read it out with the following method, just as we would with the original code:</p>
<pre>int rboot_get_current_rom() { return 0; }<br/> void rboot_set_current_rom(int slot) { }<br/> rboot_config rboot_get_config() {<br/>    rboot_config cfg;<br/>    cfg.current_rom = 0;<br/>    cfg.roms[0] = 0x1000;<br/>    cfg.roms[1] = 0x3000;<br/>    return cfg;<br/> }<br/><br/> void rBootHttpUpdate::addItem(int offset, String firmwareFileUrl) { }<br/> void rBootHttpUpdate::setCallback(OtaUpdateDelegate reqUpdateDelegate) { }<br/> void rBootHttpUpdate::start() { }<br/><br/> void spiffs_mount_manual(u32_t offset, int count) { }</pre>
<p>Both the rboot boot manager and the SPIFFS filesystem are not used, so they can just return safe values, as shown in the following code. The <strong>over-the-air</strong> (<strong>OTA</strong>) functionality could potentially be implemented as well, depending on the kind of features of the system one would want to test:</p>
<pre><br/> StationClass WifiStation;<br/><br/> void StationClass::enable(bool enable) { enabled = enable; }<br/> void StationClass::enable(bool enable, bool save) { enabled = enable; }<br/> String StationClass::getMAC() { return mac; }<br/><br/> bool StationClass::config(const String&amp; ssid, const String&amp; password, bool autoConnectOnStartup /* = true*/,<br/>                                    bool save /* = true */) {<br/>    //<br/><br/>    return true;<br/> }</pre>
<p>Since we don't have a Wi-Fi adapter that we want to use directly and are just using the OS's network capabilities, the <kbd>WiFiStation</kbd> object doesn't do a lot for most of its methods, except for when we actually connect to the RPC server, which is done using the following method:</p>
<pre><br/> bool StationClass::connect() {<br/>    long timeout = 5000; // 5 seconds.<br/>    NymphRemoteServer::init(logFunction, NYMPH_LOG_LEVEL_TRACE, timeout);<br/>    std::string result;<br/>    if (!NymphRemoteServer::connect("localhost", 4004, StationClass::handle, 0, result)) {<br/>          cout &lt;&lt; "Connecting to remote server failed: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return false;<br/>    }<br/><br/>    vector&lt;NymphType*&gt; values;<br/>    NymphType* returnValue = 0;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "getNewMac", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return false;<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_STRING) {<br/>          std::cout &lt;&lt; "Return value wasn't a string. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return false;<br/>    }<br/><br/>    std::string macStr = ((NymphString*) returnValue)-&gt;getValue();<br/>    mac = String(macStr.data(), macStr.length());<br/><br/>    delete returnValue;<br/>    returnValue = 0;<br/><br/>    // Set the serial interface callback.<br/>    NymphRemoteServer::registerCallback("serialRxCallback", HardwareSerial::dataReceivedCallback, 0);<br/><br/>    return true;<br/> }</pre>
<p>This is one of the first methods that gets called in the firmware when it tries to connect to the Wi-Fi access point. Instead of connecting to a Wi-Fi access point, we use this method to connect to the RPC server instead.</p>
<p class="mce-root"/>
<p>We start by initializing the NymphRPC library, calling the initialization method on its <kbd>NymphRemoteServer</kbd> class, and then connecting to the RPC server using the hardcoded location and port number. Upon successfully connecting to the RPC server, this client will receive a list of the available methods on the RPC server—in this case, all of the methods we registered, as we saw in the previous section on the simulation server.</p>
<p>Next, we request our MAC address from the server, verify that it's a string that we received, and set it for later use. Finally, we locally register the callback for the UART with NymphRPC, as shown in the following code. As we saw in the <span><span>simulation server's </span></span>section, the <kbd>Nodes</kbd> class on the server expects this callback to exist on the client:</p>
<pre><br/> AccessPointClass WifiAccessPoint;<br/><br/> void AccessPointClass::enable(bool enable, bool save) {<br/>    enabled = enable;<br/> }<br/><br/> void AccessPointClass::enable(bool enable) {<br/>    enabled = enable;<br/> }<br/><br/><br/> WifiEventsClass WifiEvents;<br/><br/> String IPAddress::toString() { return "192.168.0.32"; }<br/><br/> void WifiEventsClass::onStationGotIP(StationGotIPDelegate delegateFunction) {<br/>    // Immediately call the callback.<br/>    IPAddress ip;<br/>    delegateFunction(ip, ip, ip);<br/> }<br/><br/> void WifiEventsClass::onStationDisconnect(StationDisconnectDelegate delegateFunction) {<br/>    //<br/> }<br/><br/><br/> WDTClass WDT;<br/><br/> void WDTClass::alive() { }</pre>
<p class="mce-root"/>
<p>We conclude this networking section with some more stub classes and, finally, the watchdog class, which might make for a nice point for advanced testing, including soft reset testing for long-running code. Of course, such advanced tests would also require that the code runs with the performance of the ESP8266's sub-100 MHz processor.</p>
<p>Of note here is the Wi-Fi events class, where we immediately call the <kbd>callback</kbd> function for a successful connection to the Wi-Fi access point, or at least pretend to. Without this step, the firmware would forever wait for something to happen. Let's look at the following code:</p>
<pre><br/> void SPIClass::begin() { }<br/> void SPIClass::end() { }<br/> void SPIClass::beginTransaction(SPISettings mySettings) { }<br/> void SPIClass::endTransaction() { }<br/> void SPIClass::transfer(uint8* buffer, size_t numberBytes) {<br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(WifiStation.getMAC().c_str()));<br/>    values.push_back(new NymphString(std::string((char*) buffer, numberBytes)));<br/>    NymphType* returnValue = 0;<br/>    std::string result;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeSPI", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return;<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_BOOL) {<br/>          std::cout &lt;&lt; "Return value wasn't a boolean. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return;<br/>    }<br/> }<br/><br/> SPIClass SPI;</pre>
<p>To write on the SPI bus, we again just call the RPC method on the server, getting the response once that call has been completed, as shown in the following code. For simplicity's sake, no SPI read functionality is implemented in this example project:</p>
<pre> void TwoWire::pins(int sda, int scl) { }<br/> void TwoWire::begin() { }<br/> void TwoWire::beginTransmission(int address) { i2cAddress = address; }<br/> size_t TwoWire::write(uint8_t data) {<br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(WifiStation.getMAC().c_str()));<br/>    values.push_back(new NymphSint32(i2cAddress));<br/>    values.push_back(new NymphString(std::to_string(data)));<br/>    NymphType* returnValue = 0;<br/>    std::string result;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeI2C", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_BOOL) {<br/>          std::cout &lt;&lt; "Return value wasn't a boolean. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    return 1;<br/> }<br/><br/><br/> size_t TwoWire::write(int data) {<br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(WifiStation.getMAC().c_str()));<br/>    values.push_back(new NymphSint32(i2cAddress));<br/>    values.push_back(new NymphString(std::to_string(data)));<br/>    NymphType* returnValue = 0;<br/>    std::string result;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeI2C", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_BOOL) {<br/>          std::cout &lt;&lt; "Return value wasn't a boolean. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          return 0;<br/>    }<br/><br/>    return 1;<br/> }</pre>
<p>After some stub methods in the I2C class, we find the <kbd>write</kbd> methods. These are essentially the same methods, calling the <kbd>remote</kbd> method to send the data to the simulated I2C bus on the server, as shown in the following code:</p>
<pre><br/><br/> size_t TwoWire::endTransmission() { return 0; }<br/> size_t TwoWire::requestFrom(int address, int length) {<br/>    write(address);<br/><br/>    vector&lt;NymphType*&gt; values;<br/>    values.push_back(new NymphString(WifiStation.getMAC().c_str()));<br/>    values.push_back(new NymphSint32(address));<br/>    values.push_back(new NymphSint32(length));<br/>    NymphType* returnValue = 0;<br/>    std::string result;<br/>    if (!NymphRemoteServer::callMethod(StationClass::handle, "readI2C", values, returnValue, result)) {<br/>          std::cout &lt;&lt; "Error calling remote method: " &lt;&lt; result &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          exit(1);<br/>    }<br/><br/>    if (returnValue-&gt;type() != NYMPH_STRING) {<br/>          std::cout &lt;&lt; "Return value wasn't a string. Type: " &lt;&lt; returnValue-&gt;type() &lt;&lt; std::endl;<br/>          NymphRemoteServer::disconnect(StationClass::handle, result);<br/>          NymphRemoteServer::shutdown();<br/>          exit(1);<br/>    }<br/><br/>    rxBufferIndex = 0;<br/>    buffer = ((NymphString*) returnValue)-&gt;getValue();<br/>    return buffer.size();<br/> }</pre>
<p class="mce-root"/>
<p>To read from the I2C bus, we use the preceding method, first writing the I2C address we wish to write to, then calling the RPC function to read from the simulated I2C device that should have data available to read, as shown in the following code:</p>
<pre><br/> int TwoWire::available() {<br/>    return buffer.length() - rxBufferIndex;<br/> }<br/><br/><br/> int TwoWire::read() {<br/>    int value = -1;<br/>    if (rxBufferIndex &lt; buffer.length()) {<br/>          value = buffer.at(rxBufferIndex);<br/>          ++rxBufferIndex;<br/>    }<br/><br/>    return value;<br/> }<br/><br/> TwoWire Wire;</pre>
<p>The I2C read functionality is essentially the same as it was in the original implementation, as both just interact with a local buffer, as shown in the following code:</p>
<pre>String system_get_sdk_version() { return "SIM_0.1"; }<br/> int system_get_free_heap_size() { return 20000; }<br/> int system_get_cpu_freq() { return 1200000; }<br/> int system_get_chip_id() { return 42; }<br/> int spi_flash_get_id() { return 42; }<br/><br/> void SystemClass::restart() { }<br/><br/> SystemClass System;</pre>
<p>Here are more stub implementations that could be of use for specific test scenarios:</p>
<pre>void pinMode(uint16_t pin, uint8_t mode) { }<br/> void digitalWrite(uint16_t pin, uint8_t val) { }<br/> uint8_t digitalRead(uint16_t pin) { return 1; }<br/><br/> uint16_t analogRead(uint16_t pin) { return 1000; }</pre>
<p>We left these functions unimplemented, but they could implement GPIO and ADC pins that are connected to virtual GPIO pins on the server side, to control devices and record data that does not use a UART, SPI, or I2C interface. The same would work for PWM functionality.</p>
<p class="mce-root"/>
<p>Moving on to the final part in this source file, we implement the main function as follows:</p>
<pre><br/> int main() {<br/>    // Start the firmware image.<br/>    init();<br/><br/>    return 0;<br/> }<br/><br/></pre>
<p>Just like the Sming version of the entry point, we call the global <kbd>init()</kbd> function in the custom firmware code, which serves as the entrance point there. Conceivably, we could also perform various types of initialization in this main function if we needed to.</p>
<p>The filesystem class methods are implemented using a mixture of C-style file access and C++17-style filesystem operations, as shown in the following code:</p>
<pre>#include "FileSystem.h"<br/> #include "../Wiring/WString.h"<br/><br/> #include &lt;filesystem&gt;<br/> #include &lt;iostream&gt;<br/> #include &lt;fstream&gt;<br/><br/> namespace fs = std::filesystem;<br/><br/><br/> file_t fileOpen(const String&amp; name, FileOpenFlags flags) {<br/>    file_t res;<br/><br/>    if ((flags &amp; eFO_CreateNewAlways) == eFO_CreateNewAlways) {<br/>          if (fileExist(name)) {<br/>                fileDelete(name);<br/>          }<br/><br/>          flags = (FileOpenFlags)((int)flags &amp; ~eFO_Truncate);<br/>    }<br/><br/>    res = std::fopen(name.c_str(), "r+b");<br/>    return res;<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To simplify this method, we ignore the provided flags and always open the file in full read and write mode (one would only implement the full set of flags if it contributed to the integration test in some way). Let's look at the following code:</p>
<pre><br/> void fileClose(file_t file) {<br/>    std::fclose(file);<br/> }<br/><br/> size_t fileWrite(file_t file, const void* data, size_t size) {<br/>    int res = std::fwrite((void*) data, size, size, file);      <br/>    return res;<br/> }<br/><br/> size_t fileRead(file_t file, void* data, size_t size) {<br/>    int res = std::fread(data, size, size, file);<br/>    return res;<br/> }<br/><br/> int fileSeek(file_t file, int offset, SeekOriginFlags origin) {<br/>    return std::fseek(file, offset, origin);<br/> }<br/><br/> bool fileIsEOF(file_t file) {<br/>    return true;<br/> }<br/><br/> int32_t fileTell(file_t file) {<br/>    return 0;<br/> }<br/><br/> int fileFlush(file_t file) {<br/>    return 0; <br/> }<br/><br/> void fileDelete(const String&amp; name) {<br/>    fs::remove(name.c_str());<br/> }<br/><br/> void fileDelete(file_t file) {<br/>    //<br/> }<br/><br/> bool fileExist(const String&amp; name) {<br/>    std::error_code ec;<br/>    bool ret = fs::is_regular_file(name.c_str(), ec);<br/>    return ret;<br/> }<br/><br/> int fileLastError(file_t fd) {<br/>    return 0;<br/> }<br/><br/> void fileClearLastError(file_t fd) {<br/>    //<br/> }<br/><br/> void fileSetContent(const String&amp; fileName, const String&amp; content) {<br/>    fileSetContent(fileName, content.c_str());<br/> }<br/><br/> void fileSetContent(const String&amp; fileName, const char* content) {<br/>    file_t file = fileOpen(fileName.c_str(), eFO_CreateNewAlways | eFO_WriteOnly);<br/>    fileWrite(file, content, strlen(content));<br/>    fileClose(file);<br/> }<br/><br/> uint32_t fileGetSize(const String&amp; fileName) {<br/>    int size = 0;<br/>    try {<br/>         size = fs::file_size(fileName.c_str());<br/>     } <br/>    catch (fs::filesystem_error&amp; e) {<br/>         std::cout &lt;&lt; e.what() &lt;&lt; std::endl;<br/>     }<br/><br/>    return size;<br/> }<br/><br/> void fileRename(const String&amp; oldName, const String&amp; newName) {<br/>    try {<br/>          fs::rename(oldName.c_str(), newName.c_str());<br/>    }<br/>    catch (fs::filesystem_error&amp; e) {<br/>          std::cout &lt;&lt; e.what() &lt;&lt; std::endl;<br/>    }<br/> }<br/><br/> Vector&lt;String&gt; fileList() {<br/>    Vector&lt;String&gt; result;<br/>    return result;<br/> }<br/><br/> String fileGetContent(const String&amp; fileName) {<br/>    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);<br/><br/>     std::ifstream::pos_type fileSize = ifs.tellg();<br/>     ifs.seekg(0, std::ios::beg);<br/>     std::vector&lt;char&gt; bytes(fileSize);<br/>     ifs.read(bytes.data(), fileSize);<br/><br/>     return String(bytes.data(), fileSize);<br/> }<br/><br/> int fileGetContent(const String&amp; fileName, char* buffer, int bufSize) {<br/>    if (buffer == NULL || bufSize == 0) { return 0; }<br/>    *buffer = 0;<br/><br/>    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);<br/><br/>     std::ifstream::pos_type fileSize = ifs.tellg();<br/>    if (fileSize &lt;= 0 || bufSize &lt;= fileSize) {<br/>          return 0;<br/>    }<br/><br/>     buffer[fileSize] = 0;<br/>     ifs.seekg(0, std::ios::beg);<br/>    ifs.read(buffer, fileSize);<br/>    ifs.close();<br/><br/>     return (int) fileSize;<br/> }</pre>
<p>These are all standard file operations, so they don't require a lot of explanation. The main reason why both C-style and C++17-style file access are used is because the original API methods assume a C-style way of handling things, and also because of the underlying, C-based SDK functionality.</p>
<p>We would map all API methods to a pure C++17 filesystem functionality, but this would be an additional time investment without any obvious payoff.</p>
<p>The timer functionality uses POCO's <kbd>Timer</kbd> class in Sming's <kbd>SimpleTimer</kbd> class to implement an equivalent functionality, as shown in the following code:</p>
<pre>#include "Poco/Timer.h"<br/> #include &lt;iostream&gt;<br/><br/><br/> typedef void (*os_timer_func_t)(void* timer_arg);<br/><br/> class SimpleTimer {<br/> public:<br/>    SimpleTimer() : timer(0) {<br/>          cb = new Poco::TimerCallback&lt;SimpleTimer&gt;(*this, &amp;SimpleTimer::onTimer);<br/>    }<br/><br/>    ~SimpleTimer() {<br/>          stop();<br/>          delete cb;<br/>          if (timer) {<br/>                delete timer;<br/>          }<br/>    }<br/><br/>    __forceinline void startMs(uint32_t milliseconds, bool repeating = false) {<br/>          stop();<br/>          if (repeating) {<br/>                timer = new Poco::Timer(milliseconds, 0);<br/>          }<br/>          else {<br/>                timer = new Poco::Timer(milliseconds, milliseconds);<br/>          }<br/><br/>          timer-&gt;start(*cb);<br/>    }<br/><br/>    __forceinline void startUs(uint32_t microseconds, bool repeating = false) {<br/>          stop();<br/>          uint32_t milliseconds = microseconds / 1000;<br/>          if (repeating) {<br/>                timer = new Poco::Timer(milliseconds, 0);<br/>          }<br/>          else {<br/>                timer = new Poco::Timer(milliseconds, milliseconds);<br/>          }<br/><br/>          timer-&gt;start(*cb);<br/>    }<br/><br/>    __forceinline void stop() {<br/>          timer-&gt;stop();<br/>          delete timer;<br/>          timer = 0;<br/>    }<br/><br/>    void setCallback(os_timer_func_t callback, void* arg = nullptr)   {<br/>          stop();<br/>          userCb = callback;<br/>          userCbArg = arg;<br/>    }<br/><br/> private:<br/>    void onTimer(Poco::Timer &amp;timer) {<br/>          userCb(userCbArg);<br/>    }<br/><br/>    Poco::Timer* timer;<br/>    Poco::TimerCallback&lt;SimpleTimer&gt;* cb;<br/>    os_timer_func_t userCb;<br/>    void* userCbArg;<br/> };</pre>
<p>Finally, for the reimplementation of the <kbd>Clock</kbd> class, we use STL's chrono functionality, as shown in the following code:</p>
<pre>#include "Clock.h"<br/> #include &lt;chrono&gt;<br/><br/> unsigned long millis() {<br/>    unsigned long now = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();<br/>    return now;<br/> }<br/><br/> unsigned long micros() {<br/>    unsigned long now = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::system_clock::now().time_since_epoch()).count();<br/>    return now;<br/> }<br/><br/> void delay(uint32_t milliseconds) {<br/>    //<br/> }<br/><br/> void delayMicroseconds(uint32_t time) {   //<br/> }</pre>
<p>Here, we leave the <kbd>delay</kbd> functions unimplemented since we don't need them at this point.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Makefile</h1>
                </header>
            
            <article>
                
<p>The Makefile for this part of the project looks like this:</p>
<pre>GPP = g++<br/> GCC = gcc<br/> MAKEDIR = mkdir -p<br/> RM = rm<br/> AR = ar<br/> ROOT = test/node<br/> OUTPUT = bmac_esp8266<br/> OUTLIB = lib$(OUTPUT).a<br/> INCLUDE = -I $(ROOT)/ \<br/>                -I $(ROOT)/SmingCore/ \<br/>                -I $(ROOT)/SmingCore/network \<br/>                -I $(ROOT)/SmingCore/network/Http \<br/>                -I $(ROOT)/SmingCore/network/Http/Websocket \<br/>                -I $(ROOT)/SmingCore/network/libmosquitto \<br/>                -I $(ROOT)/SmingCore/network/libmosquitto/cpp \<br/>                -I $(ROOT)/SmingCore/wiring \<br/>                -I $(ROOT)/Libraries/BME280 \<br/>                -I $(ROOT)/esp8266/app<br/> FLAGS := $(INCLUDE) -g3 -U__STRICT_ANSI__<br/> LIB := -L$(ROOT)/lib -l$(OUTPUT) -lmosquittopp -lmosquitto  -lnymphrpc \<br/>          -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON -lstdc++fs \<br/>          -lssl -lcrypto<br/> LIB_WIN :=  -lws2_32<br/> ifeq ($(OS),Windows_NT)<br/>    LIB := $(LIB) $(LIB_WIN)<br/> endif<br/> include ./esp8266/version<br/> include ./Makefile-user.mk<br/> CPPFLAGS := $(FLAGS) -DVERSION="\"$(VERSION)\"" $(USER_CFLAGS) -std=c++17 -Wl,--gc-sections<br/> CFLAGS := -g3 <br/> CPP_SOURCES := $(wildcard $(ROOT)/SmingCore/*.cpp) \<br/>                $(wildcard $(ROOT)/SmingCore/network/*.cpp) \<br/>                $(wildcard $(ROOT)/SmingCore/network/Http/*.cpp) \<br/>                $(wildcard $(ROOT)/SmingCore/wiring/*.cpp) \<br/>                $(wildcard $(ROOT)/Libraries/BME280/*.cpp)<br/> FW_SOURCES := $(wildcard esp8266/app/*.cpp)<br/> CPP_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))<br/> FW_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(FW_SOURCES:.cpp=.o))<br/> all: makedir $(FW_OBJECTS) $(CPP_OBJECTS) $(ROOT)/lib/$(OUTLIB) $(ROOT)/bin/$(OUTPUT)<br/> $(ROOT)/obj/%.o: %.cpp<br/>    $(GPP) -c -o $@ $&lt; $(CPPFLAGS)<br/> $(ROOT)/obj/%.o: %.c<br/>    $(GCC) -c -o $@ $&lt; $(CFLAGS)<br/> $(ROOT)/lib/$(OUTLIB): $(CPP_OBJECTS)<br/>    -rm -f $@<br/>    $(AR) rcs $@ $^<br/> $(ROOT)/bin/$(OUTPUT):<br/>    -rm -f $@<br/>    $(GPP) -o $@ $(CPPFLAGS) $(FW_SOURCES) $(LIB)<br/> makedir:<br/>    $(MAKEDIR) $(ROOT)/bin<br/>    $(MAKEDIR) $(ROOT)/lib<br/>    $(MAKEDIR) $(ROOT)/obj<br/>    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/network<br/>    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/wiring<br/>    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/Libraries/BME280<br/>    $(MAKEDIR) $(ROOT)/obj/esp8266/app<br/> clean:<br/>    $(RM) $(CPP_OBJECTS) $(FW_OBJECTS)</pre>
<p>The main thing to note about this Makefile is that it gathers source files from two different source folders, both for the test API and for the firmware source. The former source files are first compiled to object files, which are assembled into an archive. The firmware source is used directly along with this test framework library, though we also have the firmware object files available if we need them.</p>
<p>The reason for creating an archive of the test API before linking it has to do with the way that the linker finds symbols. By using the AR tool, it will create an index of all symbols in the object files inside the archive, ensuring that we will not get any linker errors. Especially for large projects this is often a requirement to have the object files successfully link into a binary.</p>
<p>Compiling to object files first is also helpful with larger projects, as Make will ensure that only files that have actually changed will be recompiled, which can really speed up development time. Since the target firmware source for this project is fairly minimal, we can compile directly from the source files here.</p>
<p>We also include two more Makefiles from this one. The first includes the version number of the firmware source we are compiling with, which is useful since it'll ensure that the produced node binary will report the exact same version as the version installed on an ESP8266 module would. This making validation of a specific firmware version much easier.</p>
<p class="mce-root"/>
<p>The second is the Makefile with user-definable settings, copied <em>verbatim</em> from the firmware project Makefile, but with just the variables we need for the firmware source to compile and work, as shown in the following code:</p>
<pre>WIFI_SSID = MyWi-FiNetwork<br/> WIFI_PWD = MyWi-FiPassword<br/><br/> MQTT_HOST = localhost<br/> # For SSL support, uncomment the following line or compile with this parameter.<br/> #ENABLE_SSL=1<br/> # MQTT SSL port (for example):<br/> ifdef ENABLE_SSL<br/> MQTT_PORT = 8883 <br/> else<br/> MQTT_PORT = 1883<br/> endif<br/><br/> # Uncomment if password authentication is used.<br/> # USE_MQTT_PASSWORD=1<br/> # MQTT username &amp; password (if needed):<br/> # MQTT_USERNAME = esp8266<br/> # MQTT_PWD = ESPassword<br/><br/> # MQTT topic prefix: added to all MQTT subscriptions and publications.<br/> # Can be left empty, but must be defined.<br/> # If not left empty, should end with a '/' to avoid merging with topic names.<br/> MQTT_PREFIX = <br/><br/> # OTA (update) URL. Only change the host name (and port).<br/> OTA_URL = http://ota.host.net/ota.php?uid=<br/><br/> USER_CFLAGS := $(USER_CFLAGS) -DWIFI_SSID="\"$(WIFI_SSID)"\"<br/> USER_CFLAGS := $(USER_CFLAGS) -DWIFI_PWD="\"$(WIFI_PWD)"\"<br/> USER_CFLAGS := $(USER_CFLAGS) -DMQTT_HOST="\"$(MQTT_HOST)"\"<br/> USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PORT="$(MQTT_PORT)"<br/> USER_CFLAGS := $(USER_CFLAGS) -DMQTT_USERNAME="\"$(MQTT_USERNAME)"\"<br/> USER_CFLAGS := $(USER_CFLAGS) -DOTA_URL="\"$(OTA_URL)"\"<br/> USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PWD="\"$(MQTT_PWD)"\"<br/> ifdef USE_MQTT_PASSWORD<br/> USER_CFLAGS := $(USER_CFLAGS) -DUSE_MQTT_PASSWORD="\"$(USE_MQTT_PASSWORD)"\"<br/> endif<br/> SER_CFLAGS := $(USER_CFLAGS) -DMQTT_PREFIX="\"$(MQTT_PREFIX)"\"</pre>
<p class="mce-root"/>
<p>Including this Makefile sets all of these defines to be passed to the compiler. These are all preprocessor statements that are used to set strings or to change which parts of the code will be compiled, such as the SSL code.</p>
<p>However, for simplicity's sake, we aren't implementing SSL functionality for this example project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the project</h1>
                </header>
            
            <article>
                
<p>For the server side, we have the following library dependencies:</p>
<ul>
<li>NymphRPC</li>
<li>POCO</li>
</ul>
<p>For the node, we have the following dependencies:</p>
<ul>
<li>NymphRPC</li>
<li>POCO</li>
<li>Mosquitto</li>
</ul>
<p>The NymphRPC library (described at the beginning of this section) is compiled according to the project's instructions and installed in a place where the linker can find it. The POCO libraries are installed using the system's package manager (Linux, BSD, or MSYS2) or by hand.</p>
<p>For the Mosquitto library dependency, we can compile the <kbd>libmosquitto</kbd> and <kbd>libmosquittopp</kbd> library files using the project's library version by using the Makefile in the <kbd>test/SmingCore/network/libmosquitto</kbd> folder. Again you should install the resulting library files where the linker can find them.</p>
<p>When not using MinGW, one can also use the generally available version via the OS's package manager or similar.</p>
<p>After these steps, we can compile the server and client using the following command-line command from the root of the project:</p>
<pre><strong>make</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This should compile both the server and node projects using the top-level Makefile, resulting in an executable for each in their respective <kbd>bin/</kbd> folder. You should ensure that the executable name and path in the server's <kbd>Node</kbd> class match that of the node executable's location.</p>
<p>We should now be able to run the project and start to collect test results. The project includes a stripped version of the ESP8266-based BMAC firmware, which we'll be covering in detail in <a href="d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml">Chapter 9</a>, <em><span class="ChapterrefPACKT">Example - Building Monitoring and Control</span></em>. Please refer to that chapter to understand how to communicate with the simulated nodes via MQTT, how to turn on modules inside the firmware and how to interpret the data sent over MQTT by the modules.</p>
<p>After setting things up as described in that chapter - requiring at the least an MQTT broker and a suitable MQTT client - and turning on the BME280 module in the simulated node, we expect it to start sending over MQTT the temperature, humidity and air pressure values we set for the room the simulated node is in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at how to effectively develop for MCU-based targets in a way that allows us to test them without expensive and long-winded development cycles. We learned how to implement an integration environment that allows us to debug MCU-based applications from the comfort of a desktop OS and the tools it provides.</p>
<p>The reader should now be able to develop integration tests for MCU-based projects and effectively use OS-based tools to profile and debug them before doing final integration work on real hardware. The reader should also be able to perform on-chip debugging, and have a feel for the relative cost of specific software implementations.</p>
<p>In the next chapter, we'll develop a simple infotainment system, based on an SBC platform.</p>


            </article>

            
        </section>
    </body></html>