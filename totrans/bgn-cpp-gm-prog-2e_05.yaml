- en: '*Chapter 4*: Loops, Arrays, Switches, Enumerations, and Functions – Implementing
    Game Mechanics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：循环、数组、开关、枚举和函数——实现游戏机制'
- en: This chapter probably has more C++ information in it than any other chapter
    in this book. It is packed with fundamental concepts that will move our understanding
    on enormously. It will also begin to shed light on some of the murky areas we
    have been skipping over a little bit, such as functions and the game loop.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能比本书中任何其他章节都包含更多的C++信息。它充满了基本概念，将极大地推动我们的理解。它还将开始揭示我们一直略过的一些模糊区域，例如函数和游戏循环。
- en: Once we have explored a whole list of C++ language necessities, we will then
    use everything we know to make the main game mechanic—the tree branches—move.
    By the end of this chapter, we will be ready for the final phase and the completion
    of Timber!!!.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们探索了整个C++语言必需品的列表，我们就会使用我们所知道的一切来制作主要游戏机制——树分支。到本章结束时，我们将为最终阶段和Timber!!!的完成做好准备。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Loops
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Making decisions with `switch`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switch`做出决定
- en: Enumerations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Getting started with functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用函数
- en: Creating and moving the tree branches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和移动树分支
- en: Loops
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'In programming, we often need to do the same thing more than once. The obvious
    example that we have seen so far is the game loop. With all the code stripped
    out, our game loop looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们经常需要多次执行相同的事情。我们迄今为止看到的明显例子是游戏循环。去掉所有代码后，我们的游戏循环看起来像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a few different types of loops, and we will look at the most commonly
    used ones here. The correct term for this type of loop is a **while** loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的循环类型，我们在这里将查看最常用的几种。这种类型的循环的正确术语是**while**循环。
- en: while loops
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: The `while` loop is quite straightforward. Think back to the `if` statements
    and their expressions that evaluated to either `true` or `false`. We can use the
    exact same combination of operators and variables in the conditional expressions
    of our `while` loops.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环相当简单。回想一下`if`语句及其评估为`true`或`false`的表达式。我们可以在`while`循环的条件表达式中使用完全相同的运算符和变量的组合。'
- en: Like `if` statements, if the expression is `true`, the code executes. The difference
    with a `while` loop, however, is that the C++ code within it will repeatedly execute
    until the condition is false. Take a look at the following code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句类似，如果表达式为`true`，则代码执行。然而，与`while`循环的区别在于，其中的C++代码将反复执行，直到条件为`false`。看看下面的代码。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's go over what's happening in the previous code. Outside of the `while`
    loop, `int numberOfZombies` is declared and initialized to `100`. Then, the `while`
    loop begins. Its conditional expression is `numberOfZombies > 0`. Consequently,
    the `while` loop will continue looping through the code in its body until the
    condition evaluates to `false`. This means that the preceding code will execute
    100 times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前一段代码中发生的事情。在`while`循环外部，`int numberOfZombies`被声明并初始化为`100`。然后，`while`循环开始。它的条件表达式是`numberOfZombies
    > 0`。因此，`while`循环将继续循环通过其体内的代码，直到条件评估为`false`。这意味着前面的代码将执行100次。
- en: On the first pass through the loop, `numberOfZombies` equals 100, then 99, then
    98, and so on. But once `numberOfZombies` is equal to zero, it is, of course,
    no longer *greater* than zero. Then, the code will break out of the `while` loop
    and continue to run, after the closing curly brace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第一遍中，`numberOfZombies`等于100，然后是99，然后是98，以此类推。但是一旦`numberOfZombies`等于零，它当然就不再是*大于*零了。然后，代码将跳出`while`循环，并在闭合的大括号之后继续运行。
- en: 'Just like an `if` statement, it is possible that the `while` loop will not
    execute even once. Take a look at the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`if`语句一样，`while`循环甚至可能一次都不会执行。看看下面的代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code inside the `while` loop will not execute because the condition
    is false.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内部的先前代码将不会执行，因为条件是错误的。
- en: 'Note that there is no limit to the complexity of the expression or the amount
    of code that can go in the loop body. Consider the following hypothetical variation
    of our game loop:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表达式或循环体内的代码量的复杂性没有限制。考虑以下假设的游戏循环变体：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous `while` loop would continue to execute until either `playerLives`
    or `alienShips` was equal to zero. As soon as one of those conditions occurred,
    the expression would evaluate to `false` and the program would continue to execute
    from the first line of code after the `while` loop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete at least once, even if the expression evaluates to false partway
    through, as it is not tested again until the code tries to start another pass.
    Let''s take a look at an example of this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous loop body will execute once. We can also set up a `while` loop
    that will run forever, and unsurprisingly is called an **infinite loop**. Here
    is an example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you find the preceding loop confusing, just think of it literally. A loop
    executes when its condition is `true`. Well, `true` is always `true`, and will
    therefore keep executing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out of a while loop
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might use an infinite loop so that we can decide when to exit the loop from
    within its body rather than in the expression. We would do this by using the **break**
    keyword when we are ready to leave the loop body, perhaps like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the code inside the loop will execute once, upto and
    including the `break` statement, and then execution will continue after the closing
    curly brace of the `while` loop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have been able to guess, we can combine any of the C++ decision-making
    tools such as `if`, `else`, and another that we will learn about shortly, known
    as `switch`, within our `while` loops and other loop types as well. Consider the
    following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, the `if` condition decides if and when the `break` statement
    is executed. In this case, the code will keep looping until `max` reaches 10.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We could go on for a long time looking at the various permutations of C++ `while`
    loops, but, at some point, we want to get back to making games. So, let''s move
    on to another type of loop: the `for` loop.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop because it takes three parts to set one up. Take a look at
    the following code first. We will break it apart after:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is what all the parts of the `for` loop condition do:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To clarify this further, here is a table to explain each of the three key parts,
    as they appear in the previous `for` loop example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_03_1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'We can vary `for` loops so that they do many more things. Here is another simple
    example that counts down from 10:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `for` loop takes control of initialization, condition evaluation, and the
    control variable. We will use `for` loops in our game, later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can move on to the topic of C++ arrays, which help us store large amounts
    of related data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a variable is a box in which we can store a value of a specific type, such
    as `int`, `float`, or `char`, then we can think of an array as a row of boxes.
    The rows of boxes can be of almost any size and type, including objects made from
    classes. However, all the boxes must be of the same type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量是一个可以存储特定类型值的盒子，例如`int`、`float`或`char`，那么我们可以将数组想象成一排盒子。这些盒子的行可以几乎任何大小和类型，包括由类创建的对象。然而，所有的盒子必须是同一类型的。
- en: Tip
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The limitation of having to use the same type in each box can be circumvented
    to an extent once we learn some more advanced C++ in the penultimate project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们学习了更多高级的C++，就可以在一定程度上绕过必须在每个盒子中使用相同类型的限制。
- en: This array sounds like it could have been useful for our clouds in [*Chapter
    2*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)*, Variables, Operators, and
    Decisions – Animating Sprites*. So, how do we go about creating and using an array?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组听起来可能对我们[*第2章*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)中的云很有用，变量、运算符和决策——精灵动画。那么，我们如何创建和使用数组呢？
- en: Declaring an array
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个数组
- en: 'We can declare an array of `int` type variables like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个`int`类型的变量数组如下：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we have an array called `someInts` that can store ten `int` values. Currently,
    however, it is empty.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`someInts`的数组，可以存储十个`int`值。然而，目前它是空的。
- en: Initializing the elements of an array
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数组的元素
- en: 'To add values to the elements of an array, we can use the type of syntax we
    are already familiar with while introducing some new syntax, known as `99` in
    the first **element** of the array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要向数组的元素中添加值，我们可以使用我们已熟悉的语法类型，同时引入一些新的语法，称为数组第一个**元素**中的`99`：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to store a value of 999 in the second element, we need to use the
    following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在第二个元素中存储值999，我们需要使用以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can store a value of 3 in the last element like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将值3存储在最后一个元素中，如下所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the elements of an array always start at zero and go upto the size
    of the array minus one. Similar to ordinary variables, we can manipulate the values
    stored in an array. The only difference is that we would use the array notation
    to do so because although our array has a name— `someInts`— the individual elements
    do not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数组的元素始终从零开始，到数组大小减一。类似于普通变量，我们可以操作数组中存储的值。唯一的区别是我们会使用数组表示法来这样做，因为尽管我们的数组有一个名字——`someInts`——但各个元素没有。
- en: 'In the following code, we add the first and second elements together and store
    the answer in the third:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将第一个和第二个元素相加，并将结果存储在第三个：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Arrays can also interact seamlessly with regular variables, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以与普通变量无缝交互，例如：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are more ways we can initialize arrays, so let's look at one way now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以更多的方式初始化数组，现在让我们看看其中一种方法。
- en: Quickly initializing the elements of an array
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速初始化数组的元素
- en: 'We can quickly add values to the elements as follows. This example uses a `float`
    array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速向元素中添加值，如下所示。此示例使用一个`float`数组：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the `3.14`, `1.63`, and `99.0` values are stored in the first, second,
    and third positions, respectively. Remember that, when using an array notation
    to access these values, we would use [0], [1], and [2].
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`3.14`、`1.63`和`99.0`值分别存储在第一个、第二个和第三个位置。记住，当我们使用数组表示法来访问这些值时，我们会使用[0]、[1]和[2]。
- en: 'There are other ways to initialize the elements of an array. This slightly
    abstract example shows using a `for` loop to put the values 0 through 9 into the
    `uselessArray` array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组元素的其他方法。这个稍微抽象的例子展示了使用`for`循环将值0到9放入`uselessArray`数组中：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code assumes that `uslessArray` had previously been initialized
    to hold at least 10 `int` variables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设`uslessArray`之前已经被初始化，以存储至少10个`int`变量。
- en: But why do we need arrays?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要数组？
- en: What do these arrays really do for our games?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些数组对我们游戏到底有什么作用？
- en: 'We can use arrays anywhere a regular variable can be used – perhaps in an expression
    like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何可以使用普通变量的地方使用数组——例如在以下表达式中使用：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One of the biggest benefits of arrays in game code was hinted at at the start
    of this section. Arrays can hold objects (instances of classes). Let''s imagine
    that we have a `Zombie` class and we want to store a whole bunch of them. We can
    do so like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头暗示了数组在游戏代码中的一个最大好处。数组可以存储对象（类的实例）。让我们想象我们有一个`Zombie`类，我们想要存储一大堆。我们可以这样做：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `horde` array now holds a load of instances of the `Zombie` class. Each
    one is a separate, living (kind of), breathing, self-determining `Zombie` object.
    We could then loop through the `horde` array, each of which passes through the
    game loop, move the zombies, and check if their heads have met with an axe or
    if they have managed to catch the player.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`horde`数组包含了大量的`Zombie`类实例。每一个都是一个独立的、活着的（某种程度上）、呼吸的、自我决定的`Zombie`对象。然后我们可以遍历`horde`数组，每个对象都会通过游戏循环，移动僵尸，并检查它们的头部是否遇到了斧头，或者它们是否设法抓住了玩家。
- en: Arrays, had we known about them at the time, would have been perfect for handling
    our clouds in [*Chapter 2*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070), *Variables,
    Operators, and Decisions – Animating Sprites*. We could have had as many clouds
    as we wanted and written less code than we did for our three measly clouds.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们当时就知道它们，数组将完美地用于处理我们的云朵，请参阅[*第2章*](B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070)，“变量、运算符和决策
    – 动画精灵”。我们可以拥有我们想要的任意数量的云朵，并且编写的代码比我们为那三个可怜的云朵编写的代码要少。
- en: Tip
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To check out this improved cloud code in full and in action, look at the enhanced
    version of Timber!!! (code and playable game) in the download bundle. Alternatively,
    you can try to implement the clouds using arrays yourself before looking at the
    code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看改进后的云代码的完整内容和实际应用，请查看下载包中的Timber!!!（代码和可玩游戏）的增强版本。或者，您可以在查看代码之前尝试自己使用数组实现云朵。
- en: The best way to get a feel for all of this array stuff is to see it in action.
    We will do this when we implement our tree branches.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是看到所有这些数组功能在实际中的应用。我们将在我们实现树分支时这样做。
- en: For now, we will leave our cloud code as it is so that we can get back to adding
    features to the game as soon as possible. But first, let's do a bit more C++ decision-making
    with **switch**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将保持我们的云代码不变，以便我们能够尽快回到添加游戏功能的工作中。但首先，让我们用**switch**做一些更多的C++决策。
- en: Making decisions with switch
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switch进行决策
- en: We have already looked at `if`, which allows us to decide whether to execute
    a block of code based upon the result of its expression. But sometimes, a decision
    in C++ can be made in other ways that are better.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`if`，它允许我们根据其表达式的结果决定是否执行代码块。但有时，C++中的决策可以通过其他更好的方式来实现。
- en: 'When we must make a decision based on a clear list of possible outcomes that
    don''t involve complex combinations or wide ranges of values, then `switch` is
    usually the way to go. We can start a `switch` decision as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须根据一个清晰的可能结果列表做出决策，而这些结果不涉及复杂的组合或广泛的值范围时，`switch`通常是最佳选择。我们可以这样开始一个`switch`决策：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the previous example, `expression` could be an actual expression or just
    a variable. Then, within the curly braces, we can make decisions based on the
    result of the expression or value of the variable. We do this with the `case`
    and `break` keywords:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`expression`可以是实际的表达式，也可以只是一个变量。然后，在大括号内，我们可以根据表达式的结果或变量的值做出决策。我们使用`case`和`break`关键字来完成这项工作：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, each `case` states a possible result and each `break` denotes
    the end of that `case` and the point that the execution leaves the `switch` block.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个`case`都声明了一个可能的结果，每个`break`都表示该`case`的结束以及执行离开`switch`块的时刻。
- en: 'Optionally, we can also use the `default` keyword without a value to run some
    code in case none of the `case` statements evaluate to `true`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们也可以使用不带值的`default`关键字来运行一些代码，以防没有`case`语句评估为`true`，如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As a final and less abstract example for `switch`, consider a retro text adventure
    where the player enters a letter such as "n", "e", "s", or "w" to move North,
    East, South, or West. A `switch` block could be used to handle each possible input
    from the player:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`switch`的最后一个和更具体的例子，考虑一个复古文字冒险游戏，玩家输入字母“n”、“e”、“s”或“w”来向北、向东、向南或向西移动。可以使用`switch`块来处理玩家可能的每个输入：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The best way of understanding all we have seen regarding `switch` is by putting
    it into action, along with all the other new concepts we are learning about.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们关于`switch`所看到的一切的最佳方式是将它们付诸实践，同时结合我们正在学习的所有其他新概念。
- en: Next, we will learn about another C++ concept we need to understand before we
    write some more code. Let's look at class enumerations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习另一个在编写更多代码之前我们需要理解的C++概念。让我们看看类枚举。
- en: Class enumerations
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类枚举
- en: An **enumeration** is a list of all the possible values in a logical collection.
    C++ enumerations are a great way of, well, enumerating things. For example, if
    our game uses variables that can only be in a specific range of values and if
    those values could logically form a collection or a set, then enumerations are
    probably appropriate to use. They will make your code clearer and less error-prone.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**是一个逻辑集合中所有可能值的列表。C++枚举是列举事物的一种很好的方式。例如，如果我们的游戏使用的变量只能在一个特定的值范围内，并且这些值可以逻辑上形成一个集合或一组，那么枚举可能就是合适的。它们会使你的代码更清晰，更不容易出错。'
- en: To declare a class enumeration in C++, we can use these two keywords, `enum
    class`, together, followed by the name of the enumeration, followed by the values
    the enumeration can contain, enclosed in a pair of curly braces `{...}`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中声明类枚举时，我们可以使用这两个关键字`enum class`一起，后面跟着枚举的名称，然后是枚举可以包含的值，用一对花括号 `{...}`
    括起来。
- en: 'As an example, examine the following enumeration declaration. Note that it
    is convention to declare the possible values from the enumeration in uppercase:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查以下枚举声明。请注意，按照惯例，枚举的可能值应该使用大写字母声明：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that, at this point, we have not declared any instances of `zombieType`,
    just the type itself. If that sounds odd, think about it like this. SFML created
    the `Sprite`, `RectangleShape`, and `RenderWindow` classes, but to use any of
    those classes, we had to declare an object/instance of the class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，到目前为止，我们还没有声明`zombieType`的任何实例，只是声明了类型本身。如果这听起来很奇怪，可以这样想。SFML创建了`Sprite`、`RectangleShape`和`RenderWindow`类，但为了使用这些类，我们必须声明一个对象/实例。
- en: 'At this point, we have created a new type called `zombieTypes`, but we have
    no instances of it. So, let''s do that now:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个名为`zombieTypes`的新类型，但我们还没有它的实例。所以，让我们现在就做：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next is a sneak preview of the type of code we will soon be adding to Timber!!!.
    We will want to track which side of the tree a branch or the player is on, so
    we will declare an enumeration called `side`, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是即将添加到Timber!!!的代码类型的预览。我们希望跟踪树枝或玩家在树的哪一侧，因此我们将声明一个名为`side`的枚举，如下所示：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could position the player on the left like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将玩家定位在左侧，如下所示：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could make the fourth level (arrays start from zero) of an array of branch
    positions have no branch at all, like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使树枝位置数组的第四级（数组从零开始）没有任何树枝，如下所示：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use enumerations in expressions as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在表达式中使用枚举：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code tests whether the branch in position [5] element of the array
    is on the same side as the player.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码测试数组位置[5]的分支是否与玩家在同一个方向上。
- en: We will look at one more vital C++ topic, that is, functions, and then we will
    get back to coding the game. When we want to compartmentalize some code that does
    one specific thing, we can use a function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一个重要的C++主题，那就是函数，然后我们将回到编写游戏代码。当我们想要将一些执行特定任务的代码封装起来时，我们可以使用函数。
- en: Getting started with functions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习函数
- en: 'What exactly are C++ functions? A function is a collection of variables, expressions,
    and **control flow statements** (loops and branches). In fact, any of the code
    we have learned about in this book so far can be used in a function. The first
    part of a function that we write is called the **signature**. Here is an example
    function signature:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++函数究竟是什么？函数是一系列变量、表达式和**控制流语句**（循环和分支）的集合。实际上，我们在本书中到目前为止所学的任何代码都可以用在函数中。我们编写的函数的第一部分被称为**签名**。以下是一个函数签名的示例：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we add an opening and closing pair of curly braces `{...}` along with some
    code that the function performs, we will have a complete function, that is, a
    **definition**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在函数执行的一些代码旁边添加一对开闭花括号 `{...}`，我们就会得到一个完整的函数，即一个**定义**：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We could then use our new function from another part of our code, perhaps like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从代码的另一个部分使用我们新的函数，可能如下所示：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we use a function, we say that we `shootLazers`, our program's execution
    branches to the code contained within that function. The function will run until
    it reaches the end or is told to `return`. Then, the code will continue running
    from the first line after the function call. We have already been using the functions
    that SFML provides. What is different here is that we will learn to write and
    call our own functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个函数时，我们说我们在“发射激光”，我们的程序执行分支到该函数内部包含的代码。函数将运行，直到它到达末尾或被指示“返回”。然后，代码将从函数调用后的第一行继续运行。我们已经在使用
    SFML 提供的函数。这里的不同之处在于，我们将学习编写和调用我们自己的函数。
- en: 'Here is another example of a function, complete with the code to make the function
    return to the code that called it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个函数的示例，包括使函数返回到调用它的代码的代码：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The call so that we can use the preceding function may look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式调用该函数：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Obviously, we don't need to write functions to add two variables together, but
    this example helps us look into the workings of functions. First, we pass in the
    values `2` and `4`. In the function signature, the value `2` is assigned to `int
    a`, and the value `4` is assigned to `int b`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要编写函数来将两个变量相加，但这个例子帮助我们了解函数的工作原理。首先，我们传递值 `2` 和 `4`。在函数签名中，值 `2` 被分配给
    `int a`，值 `4` 被分配给 `int b`。
- en: Within the function body, the `a` and `b` variables are added together and used
    to initialize the new variable, `int answer`. The `return answer;` line does just
    that. It returns the value stored in `answer` to the calling code, causing `myAnswer`
    to be initialized with the value `6`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，变量 `a` 和 `b` 被相加，并用于初始化新变量 `int answer`。`return answer;` 这一行正是这样做的。它将存储在
    `answer` 中的值返回给调用代码，导致 `myAnswer` 被初始化为值 `6`。
- en: Notice that each of the function signatures in the preceding examples vary a
    little. The reason for this is that the C++ function signature is quite flexible,
    allowing us to build exactly the functions we require.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面示例中的每个函数签名都有所不同。这是因为 C++ 函数签名非常灵活，允许我们构建我们需要的精确函数。
- en: Exactly how the function signature defines how the function must be called and
    if/how the function must return a value deserves further discussion. Let's give
    each part of that signature a name so that we can break it into parts and learn
    about them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名如何定义函数必须如何调用以及函数必须如何返回值，这值得进一步讨论。让我们给这个签名的每一部分起个名字，这样我们就可以将其分解成部分并了解它们。
- en: 'Here is a function signature with its parts described by their formal/technical
    term:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个带有其各部分通过其正式/技术术语描述的函数签名：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are a few examples that we can use for each of those parts:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们可以用于这些部分的示例：
- en: '`void`,  `bool`, `float`, `int`, and so on, or any C++ type or expression'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`，`bool`，`float`，`int` 等等，或者任何 C++ 类型或表达式'
- en: '`shootLazers`, `addAToB`, and so on'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shootLazers`，`addAToB` 等等'
- en: '`(int number, bool hitDetected)`, `(int x, int y)`, `(float a, float b)`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int number, bool hitDetected)`, `(int x, int y)`, `(float a, float b)`'
- en: Now, let's look at each part in turn, starting with the return type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一查看每个部分，从返回类型开始。
- en: Function return types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数返回类型
- en: 'The return type, as its name suggests, is the type of the value that will be
    returned from the function to the calling code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型，正如其名称所暗示的，是函数将返回给调用代码的值的类型：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our slightly dull but useful `addAtoB` example that we looked at previously,
    the return type in the signature is `int`. The `addAToB` function sends back and
    returns  a value that will fit in an `int` variable to the code that called it.
    The return type can be any C++ type we have seen so far or one of the ones we
    haven't seen yet.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看过的稍微有点无聊但很有用的 `addAtoB` 示例中，签名中的返回类型是 `int`。`addAToB` 函数将返回一个值，这个值将适合放入一个
    `int` 变量中，返回给调用它的代码。返回类型可以是到目前为止我们看到的任何 C++ 类型，或者是我们还没有看到的类型之一。
- en: 'A function does not have to return a value at all, however. In this case, the
    signature must use the `void` keyword as the return type. When the `void` keyword
    is used, the function body must not attempt to return a value as this will cause
    an error. It can, however, use the `return` keyword without a value. Here are
    some combinations of the return type and use of the `return` keyword that are
    valid:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数根本不需要返回值。在这种情况下，签名必须使用 `void` 关键字作为返回类型。当使用 `void` 关键字时，函数体不得尝试返回值，因为这将导致错误。然而，它可以不带有值使用
    `return` 关键字。以下是一些有效的返回类型和 `return` 关键字使用的组合：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another possibility is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性如下：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code is yet more examples of possible functions. Be sure to read
    the comments as well as the code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是更多可能的函数示例。务必阅读注释以及代码：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The last function example in the preceding code, which is for `detectCollision`,
    is a glimpse into the near future of our C++ code and demonstrates that we can
    also pass in user-defined types known as objects into functions so that we can
    perform calculations on them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中的最后一个函数示例，即`detectCollision`，是对我们C++代码未来近期的预览，并展示了我们也可以将用户定义的类型，即对象，传递给函数，以便在它们上进行计算。
- en: 'We could call each of the functions, in turn, like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依次调用每个函数，如下所示：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Don't worry about the odd-looking syntax regarding the `detectCollision` function;
    we will see real code like this soon. Simply, we are using the return value (`true`
    or `false`) as the expression directly in an `if` statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心关于`detectCollision`函数看起来奇怪的语法；我们很快就会看到这样的真实代码。简单来说，我们正在使用返回值（`true`或`false`）作为`if`语句中的表达式。
- en: Function names
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数名称
- en: 'The function name that we use when we design our own function can be almost
    anything at all. But it is best to use words, usually verbs, that clearly explain
    what the function will do. For example, take a look at the following function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计自己的函数时，我们使用的函数名称几乎可以是任何东西。但最好使用单词，通常是动词，清楚地说明函数将做什么。例如，看看以下函数：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding function is perfectly legal and will work, but the following
    function names are much clearer:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是完全合法的，并且会正常工作，但以下函数名称更清晰：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using clear and descriptive function names such as in the preceding three examples
    is good practice, but, as we saw from the `functionaroonieboonie` function, this
    is not a rule that the compiler enforces. Next, we will take a closer look at
    how we share some values with a function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像前面三个例子中那样的清晰和描述性的函数名称是一个好的做法，但正如我们从`functionaroonieboonie`函数中看到的那样，这不是编译器强制执行的规定。接下来，我们将更仔细地看看我们如何与函数共享一些值。
- en: Function parameters
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'We know that a function can return a result to the calling code. But what if
    we need to share some data values from the calling code with the function? **Parameters**
    allow us to share values with the function. We have already seen examples of parameters
    while looking at return types. We will look at the same example but a little more
    closely:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道一个函数可以返回结果给调用代码。但如果我们需要从调用代码中共享一些数据值给函数呢？**参数**允许我们与函数共享值。在我们查看返回类型时，我们已经看到了参数的例子。我们将查看相同的例子，但更仔细一些：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the parameters are `int a` and `int b`. Notice that, in the first line
    of the function body, we use `a + b` as if they are already declared and initialized
    variables. Well, that's because they are. The parameters in the function signature
    is their declaration, and the code that calls the function initializes them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数是`int a`和`int b`。注意，在函数主体的第一行，我们使用`a + b`就像它们已经是声明并初始化的变量一样。嗯，那是因为它们确实是。函数签名中的参数是它们的声明，调用函数的代码初始化它们。
- en: Important jargon note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要术语说明
- en: 'Note that we are referring to the variables in the function signature brackets
    `(int a, int b)` as parameters. When we pass values into the function from the
    calling code, these values are called arguments. When the arguments arrive, they
    are used by the parameters to initialize real, usable variables, like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里指的是函数签名括号中的变量`(int a, int b)`，我们称之为参数。当我们从调用代码向函数传递值时，这些值被称为参数。当参数到达时，它们被参数用来初始化真实、可用的变量，例如：
- en: '`int returnedAnswer = addAToB(10,5);`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`int returnedAnswer = addAToB(10,5);`'
- en: Also, as we have partly seen in previous examples, we don't have to just use
    `int` in our parameters. We can use any C++ type. We can also use as many parameters
    as is necessary to solve our problem, but it is good practice to keep the parameter
    list as short and therefore as manageable as possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在前面的例子中部分看到的那样，我们不必在我们的参数中只使用`int`。我们可以使用任何C++类型。我们也可以使用尽可能多的参数来解决我们的问题，但保持参数列表尽可能短，因此尽可能易于管理是一个好的做法。
- en: As we will see in future chapters, we have left a few of the cooler uses of
    functions out of this introductory tutorial so that we can learn about related
    C++ concepts before we take the topic of functions further.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在未来的章节中看到的那样，我们在这个入门教程中省略了一些函数的酷用，这样我们就可以在学习函数之前先了解相关的C++概念。
- en: The function body
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数主体
- en: 'The body is the part we have been kind of avoiding and has comments such as
    the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是我们一直避免的部分，其中包含如下注释：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Actually, we already know exactly what to do here! Any C++ code we have learned
    about so far will work in the body of a function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这里已经知道该做什么了！到目前为止我们所学的任何C++代码都可以在函数体中使用。
- en: Function prototypes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数原型
- en: So far, we have seen how to code a function and we have seen how to call one
    as well. There is one more thing we need to do, however, to make them work. All
    functions must have a **prototype**. A prototype is what makes the compiler aware
    of our function, and without a prototype the entire game will fail to compile.
    Fortunately, prototypes are straightforward.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何编写函数以及如何调用函数。然而，我们还需要做一件事才能使它们正常工作。所有函数都必须有一个**原型**。原型是让编译器知道我们的函数，没有原型整个游戏将无法编译。幸运的是，原型很简单。
- en: 'We can simply repeat the function''s signature, followed by a semicolon. The
    caveat is that the prototype must appear *before* any attempt to call or define
    the function. So, the absolute most simple example of a fully usable function
    in action is as follows. Look carefully at the comments and the location in the
    code that the different parts of the function appear in:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地重复函数的签名，然后跟一个分号。需要注意的是，原型必须在尝试调用或定义函数之前出现。因此，一个完全可用的函数的最简单示例如下。仔细查看注释和代码中函数不同部分出现的位置：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'What the previous code demonstrates is the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码展示的是以下内容：
- en: The prototype is before the `main` function.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型位于`main`函数之前。
- en: The call to use the function is as we might expect, inside the `main` function.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数的调用正如我们所预期的那样，在`main`函数内部。
- en: The definition is after/outside the `main` function.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义位于`main`函数之后/外部。
- en: Important note
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that we can omit the function prototype and go straight to the definition
    when the definition occurs before the function is used. As our code becomes longer
    and spread across multiple files, however, this will almost never happen. We will
    use separate prototypes and definitions all the time.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当函数的定义出现在使用函数之前时，我们可以省略函数原型并直接进入定义。然而，随着我们的代码变得越来越长，并分散到多个文件中，这种情况几乎不会发生。我们将会一直使用单独的原型和定义。
- en: Let's see how we can keep our functions organized.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何保持函数的有序性。
- en: Organizing functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织函数
- en: It's well worth pointing out that if we have multiple functions, especially
    if they are fairly long, our `.cpp` file will quickly become unwieldy. This defeats
    part of the objective that functions are intended for. The solution that we will
    see in the next project is that we can add all our function prototypes to our
    very own header file (`.hpp` or `.h`). Then, we can code all our functions in
    another `.cpp` file and simply add another `#include...` directive in our main
    `.cpp` file. This way, we can use any number of functions without adding any of
    their code (prototype or definition) to our main code file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，如果我们有多个函数，尤其是如果它们相当长，我们的`.cpp`文件将很快变得难以管理。这违背了函数旨在实现的部分目标。在下一个项目中，我们将看到解决方案，即我们可以将所有函数原型添加到我们自己的头文件（`.hpp`或`.h`）中。然后，我们可以在另一个`.cpp`文件中编写所有函数，并在我们的主`.cpp`文件中简单地添加另一个`#include...`指令。这样，我们可以使用任意数量的函数，而无需将它们的代码（原型或定义）添加到主代码文件中。
- en: Function gotcha!
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数陷阱！
- en: Another point that we should discuss about functions is **scope**. If we declare
    a variable in a function, either directly or in one of the parameters, that variable
    is not usable/visible outside of that function. Furthermore, any variables declared
    inside other functions cannot be seen/used inside the function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该讨论的关于函数的另一个点是**作用域**。如果我们在一个函数中声明一个变量，无论是直接声明还是在参数中声明，那么这个变量在该函数外部不可用/不可见。此外，在函数内部声明的任何变量在函数内部也看不见/不可用。
- en: The way that we should share values between function code and calling code is
    through the parameters/arguments and the return value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在函数代码和调用代码之间通过参数/参数和返回值来共享值。
- en: When a variable is not available because it is from another function, it is
    said to be out of scope. When it is available and usable, it is said to be in
    scope.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量不可用，因为它来自另一个函数时，我们说它超出了作用域。当它可用且可使用时，我们说它在作用域内。
- en: Important note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Variables declared within any block in C++ are only in scope within that block!
    This includes loops and `if` blocks as well. A variable that's declared at the
    top of `main` is in scope anywhere in `main`, a variable that's declared in the
    game loop is only in scope within the game loop, and so on. A variable that's
    declared within a function or other block is called a **local** variable. The
    more code we write, the more this will make sense. Every time we come across an
    issue in our code regarding scope, I will discuss it to make things clear. There
    will be one such issue coming up in the next section. There are also some more
    C++ staples that blow this issue wide open. They are called **references** and
    **pointers**, and we will learn about them in [*Chapter 9*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200),
    *C++ References, Sprite Sheets, and Vertex Arrays* and[*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214),
    *Pointers, the Standard Template Library, and Texture Management* respectively.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，任何块内声明的变量仅在該块的作用域内有效！这包括循环和`if`块。在`main`函数顶部声明的变量在`main`函数的任何地方都有作用域，在游戏循环中声明的变量仅在游戏循环中有作用域，依此类推。在函数或其他块内声明的变量称为**局部变量**。我们编写的代码越多，这一点就越有意义。每次我们在代码中遇到关于作用域的问题时，我都会讨论它，以便让大家明白。下一节将出现这样一个问题。还有一些其他的C++基本概念会使这个问题更加突出。它们被称为**引用**和**指针**，我们将在[*第9章*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200)，“C++引用、精灵图集和顶点数组”和[*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)，“指针、标准模板库和纹理管理”中分别学习它们。
- en: More on functions
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于函数的内容
- en: There is even more we could learn about functions, but we know enough about
    them already to implement the next part of our game. And don't worry if all the
    technical terms such as parameters, signatures, and definitions have not completely
    sunk in yet. These concepts will become clearer when we start to use them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以学习更多关于函数的知识，但我们已经足够了解它们，可以实施游戏下一部分的功能。而且，如果所有像参数、签名和定义这样的技术术语还没有完全理解，请不要担心。当我们开始使用这些概念时，它们会变得更加清晰。
- en: An absolute final word on functions – for now
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于函数的绝对最终话——现在
- en: 'It has probably not escaped your attention that we have been calling functions,
    especially the SFML functions, by appending the name of an object and a period
    before the function name, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你没有注意到，我们一直在通过在函数名之前添加对象名称和一个点来调用函数，特别是SFML函数，如下所示：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And yet, our entire discussion of functions saw us calling functions without
    any objects. We can write functions as part of a class or simply as a standalone
    function. When we write a function as part of a class, we need an object of that
    class to call the function, but when we have a standalone function, we don't.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们关于函数的整个讨论都是关于调用没有对象的函数。我们可以将函数作为类的一部分编写，或者简单地作为一个独立的函数编写。当我们将函数作为类的一部分编写时，我们需要该类的对象来调用该函数，但是当我们有一个独立的函数时，我们不需要。
- en: We will write a standalone function in a minute and we will write classes with
    functions starting from [*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154),
    *Object-Oriented Programming – Starting the Pong Game*. Everything we know so
    far about functions is relevant in both cases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内编写一个独立的函数，并从[*第6章*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)，“面向对象编程
    - 开始Pong游戏”开始编写带有函数的类。到目前为止，我们所了解到的关于函数的一切在两种情况下都是相关的。
- en: Now, we can get back to coding the branches in the Timber!!! game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到编写Timber!!!游戏中的分支代码。
- en: Growing the branches
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支的生长
- en: Next, as I have been promising for the last 20 pages, we will use all the new
    C++ techniques we've learned about to draw and move some branches on our tree.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我在过去20页中承诺的那样，我们将使用我们学到的所有新的C++技术来绘制和移动我们树上的一些分支。
- en: 'Add the following code outside of the `main` function. Just to be absolutely
    clear, I mean *before* the code for `int main()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数外部添加以下代码。为了绝对清楚，我的意思是*在*`int main()`代码之前：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We just achieved quite a few things with that new code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用新代码实现了相当多的事情：
- en: First, we wrote a function prototype for a function called `updateBranches`.
    We can see that it does not return a value (`void`) and that it takes an `int`
    argument called `seed`. We will write the function definition soon, and we will
    then see exactly what it does.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为名为`updateBranches`的函数编写了一个函数原型。我们可以看到它不返回值（`void`），并且接受一个名为`seed`的`int`参数。我们很快将编写函数定义，然后我们将看到它确切地做了什么。
- en: Next, we declare an `int` constant called `NUM_BRANCHES` and initialize it to
    `6`. There will be six moving branches on the tree, and we will soon see how `NUM_BRANCHES`
    is useful to us.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this, we declare an array of `Sprite` objects called `branches` that
    can hold six `Sprite` instances.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After that, we declare a new enumeration called `side` with three possible
    values: `LEFT`, `RIGHT`, and `NONE`. This will be used to describe the position
    of individual branches, as well as the player, in a few places throughout our
    code.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the preceding code, we initialize an array of `side` types with
    a size of `NUM_BRANCHES` (6). To be clear about what this achieves, we will have
    an array called `branchPositions` with six values in it. Each of these values
    is of the `side` type and can be either `LEFT`, `RIGHT`, or `NONE`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of course, what you really want to know is why the constant, two arrays, and
    the enumeration were declared *outside* of the `main` function. By declaring them
    above `main`, they now have `main` function and the `updateBranches` function.
    Note that it is good practice to make all the variables as local to where they
    are actually used as possible. It might seem useful to make everything global,
    but this leads to hard-to-read and error-prone code.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Preparing the branches
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will prepare our six `Sprite` objects and load them into the `branches`
    array. Add the following highlighted code just before our game loop:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare an SFML `Texture` object and load the `branch.png` graphic
    into it.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create a `for` loop that sets `i` to zero and increments `i` by one
    on each pass through the loop until `i` is no longer less than `NUM_BRANCHES`.
    This is exactly right because `NUM_BRANCHES` is 6 and the `branches` array has
    positions 0 through 5.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `for` loop, we set the `Texture` for each `Sprite` in the `branches`
    array with `setTexture` and then hide it off-screen with `setPosition`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the origin (the point that is used to locate the sprite when
    it is drawn) with `setOrigin`, to the center of the sprite. Soon, we will be rotating
    these sprites. Having the origin in the center means they will spin nicely around,
    without moving the sprite out of position.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have prepared all the branches, we can write some code to update
    them all each frame.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Updating the branch sprites each frame
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code, we will set the position of all the sprites in the `branches`
    array, based upon their position in the array and the value of `side` in the corresponding
    `branchPositions` array. Add the following highlighted code and try to understand
    it first before we go through it in detail:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The code we just added is one big `for` loop that sets `i` to zero and increments
    `i` by one each time through the loop and keeps going until `i` is no longer less
    than 6.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop, a new `float` variable called `height` is set to `i *
    150`. This means that the first branch will have a height of 0, the second a height
    of 150, and the sixth a height of 750.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a structure of `if` and `else` blocks. Take a look at the structure
    with the code stripped out:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first `if` statement uses the `branchPositions` array to see whether the
    current branch should be on the left. If it is, it sets the corresponding `Sprite`
    from the `branches` array to a position on the screen, appropriate for the left
    (610 pixels) and whatever the current `height` is. It then flips the Sprite by
    180 degrees because the `branch.png` graphic "hangs" to the right by default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Note that `else if` only executes if the branch is not on the left. It uses
    the same method to see if it is on the right. If it is, then the branch is drawn
    on the right (1,330 pixels). Then, the sprite rotation is set to zero degrees,
    just in case it had previously been at 180 degrees. If the x coordinate seems
    a little bit strange, just remember that we set the origin for the branch sprites
    to their center.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The final `else` statement correctly assumes that the current `branchPosition`
    must be `NONE` and hides the branch off-screen at 3,000 pixels.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our branches are in position and ready to be drawn.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the branches
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will use another `for` loop to step through the entire `branches`
    array from 0 to 5 and draw each branch sprite. Add the following highlighted code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Of course, we still haven't written the function that moves all the branches.
    Once we have written that function, we will also need to work out when and how
    to call it. Let's solve the first problem and write the function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Moving the branches
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already added the function prototype, above the `main` function. Now,
    we can code the actual definition of the function that will move all the branches
    down by one position each time it is called. We will code this function in two
    parts so that we can easily examine what is happening.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the first part of the `updateBranches` function *after* the closing curly
    brace of the `main` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this first part of the function, we simply move all the branches down one
    position, one at a time, starting with the sixth branch. This is achieved by making
    the `for` loop count from 5 through to 0\. Note that `branchPositions[j] = branchPositions[j
    - 1];` makes the actual move.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to note with this previous code is that after we have moved
    the branch in position 4 to position 5, then the branch in position 3 to position
    4, and so on, we will need to add a new branch at position 0, which is the top
    of the tree.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can spawn a new branch at the top of the tree. Add the following highlighted
    code, and then we will talk about it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the final part of the `updateBranches` function, we use the integer `seed`
    variable that gets passed in with the function call. We do this to guarantee that
    the random number seed is always different. We will see how we arrived at this
    value in the next chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Next, we generate a random number between zero and four and store the result
    in the `int` variable called `r`. Now, we `switch`, using `r` as the expression.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statements mean that if `r` is equal to zero, then we add a new branch
    to the left-hand side, at the top of the tree. If `r` is equal to 1, then the
    branch goes to the right. If `r` is anything else, (2, 3, or 4), then `default`
    ensures no branch will be added at the top. This balance of left, right, and none
    makes the tree seem realistic and the game work quite well. You could easily change
    the code to make the branches more frequent or less so.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Even after all this code for our branches, we still can't see a single one of
    them in the game. This is because we have more work to do before we can call the
    `updateBranches` function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see a branch now, you can add some temporary code and call the
    function five times with a unique seed each time, just before the game loop:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can now see the branches in place. But if the branches are to actually
    move, we will need to call `updateBranches` on a regular basis:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_04_01.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to remove the temporary code before moving on.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can turn our attention to the player as well, as calling the `updateBranches`
    function for real. We will do so in the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although not quite the longest, this was probably the chapter where we've covered
    the most C++ so far. We looked at the different types of loops we can use, such
    as `for` and `while` loops. We then studied arrays that we can use them to handle
    large amounts of variables and objects without breaking a sweat. We also learned
    about enumerations and `switch`. Probably the biggest concept in this chapter
    was functions, which allow us to organize and abstract our game's code. We will
    be looking more deeply at functions in a few more places in this book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a fully "working" tree, we can finish the game off, which we
    will do in the next and final chapter for this project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) You mentioned there were a few more types of C++ loops. Where can I find
    out about them?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Yes, take a look at this tutorial and explanation for the `do while` loops:
    [http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm](http://www.tutorialspoint.com/cplusplus/cpp_do_while_loop.htm).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can I assume I am now an expert on arrays?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Like many of the topics in this book, there is always more to learn. You
    know enough about arrays to proceed, but if you''re hungry for more, take a look
    at this fuller arrays tutorial: [http://www.cplusplus.com/doc/tutorial/arrays/](http://www.cplusplus.com/doc/tutorial/arrays/).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can I assume that I am an expert on functions?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Like many of the topics in this book, there is always more to learn. You
    know enough about functions to proceed, but if want to know even more, take a
    look at this tutorial: [http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: A) 与本书中的许多主题一样，总有更多东西可以学习。你对函数的了解已经足够继续前进，但如果你还想了解更多，请查看这个教程：[http://www.cplusplus.com/doc/tutorial/functions/](http://www.cplusplus.com/doc/tutorial/functions/).
