- en: Shader Editing and Optimization Tips
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器编辑和优化技巧
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Shaders (and the Materials they are built from in UE4) are responsible for
    all we see in the game. Some are very simple and require no user input whatsoever
    (such as most UI work), but eventually, any team making a modern day 3D game will
    likely need some custom solutions, if not a huge number, beyond what comes packaged
    with the basic game and templates. Knowing how to create and modify them, how
    to use (and re-use) them efficiently at runtime, and some of the powerful capabilities
    they provide, is major importance. Thankfully, UE4 makes some of this much easier
    than other platforms with their Material Editor, saving time and resources for
    teams, but of course this comes at the risk of improper use, which can be devastating
    for performance. Throughout this chapter are tips to prevent that, while getting
    the most out of the system and tools. And keep in mind, our goal here is not to
    become a specialized expert in every topic but to gain a holistic mastery of the
    major systems of UE4 and the confidence to guide a team or project to its best
    effectiveness. Material and shader mastery can (and does!) fill its own books
    entirely, but after this chapter, you should have the confidence to give grounded
    answers on the capabilities and limitations of what can be done with materials
    in UE4.  Our main topics will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器（以及它们在UE4中构建的材质）负责游戏中我们看到的所有内容。有些非常简单，根本不需要用户输入（例如大多数UI工作），但最终，任何制作现代3D游戏的团队都可能需要一些定制解决方案，如果不是大量的话，超出了基本游戏和模板所包含的内容。了解如何创建和修改它们，如何在运行时高效地使用（和重用）它们，以及它们提供的一些强大功能，是非常重要的。幸运的是，UE4通过其材质编辑器使这些操作比其他平台更容易，为团队节省了时间和资源，但当然这也带来了不当使用的风险，这可能会对性能造成灾难性的影响。在本章中，我们将提供一些防止这种情况发生的技巧，同时最大限度地利用系统和工具。记住，我们的目标不是成为每个主题的专家，而是要全面掌握UE4的主要系统，并拥有引导团队或项目达到最佳效果的信心的能力。材质和着色器的精通可以（并且确实！）填满整本书，但在这章之后，你应该有信心对UE4中材质的能力和限制给出有根据的回答。我们主要讨论的主题包括：
- en: Basics of creating and editing materials
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和编辑材质的基础
- en: Editing material networks and editor-time performance tips
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑材质网络和编辑时性能技巧
- en: Runtime tips for optimizing shaders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化着色器的运行时技巧
- en: Adapting shaders across various platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种平台上适配着色器
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will use the project from the following GitHub link. While the
    lessons can be applied to any project, specific examples will be given using assets
    directly from the game project, so of course syncing it is recommended:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用以下GitHub链接中的项目。虽然这些课程可以应用于任何项目，但将给出使用游戏项目直接资产的具体示例，因此当然建议同步：
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-8)'
- en: 'Engine version used: 4.19.2.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的引擎版本：4.19.2。
- en: Knowing and building materials
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解和构建材质
- en: 'It is assumed most readers are familiar with the concept of shaders: specific
    rendering code sent at runtime to tell the hardware how we want it to draw a given
    item to the screen. There are numerous places a novice can begin learning about
    them, but the assumption here is the reader has at least basic knowledge of how
    shaders work: compilation, upload to a GPU or software renderer, and execution
    there. As this is not a graphics primer, we''ll skip ahead now to UE4''s ubiquitous
    method of generating and porting shaders across platforms: Materials.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设大多数读者都熟悉着色器的概念：在运行时发送到硬件的特定渲染代码，告诉硬件如何将给定项目绘制到屏幕上。新手可以从许多地方开始学习它们，但这里的假设是读者至少对着色器的工作原理有基本了解：编译、上传到GPU或软件渲染器，并在那里执行。由于这不是图形入门教程，我们将跳过这部分，直接进入UE4生成和跨平台传输着色器的通用方法：材质。
- en: Overview of materials, material instance creation, and use
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料概述、材质实例创建和使用
- en: 'There''s no perfect place to start when it comes to materials. However, the
    obvious one not everyone even knows is there are engine materials. If you open
    the editor and go to the content browser, you''ll see in the bottom-right a View
    Options drop-down menu. Selecting Show Engine Content will make a new folder show
    up in the sources browser on the left, and selecting this folder, then adding
    a filter of Material and Material Instance, as here, from the Filters drop-down
    menu will show you a huge list of existing built-in materials:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在材料方面，没有一个完美的起点。然而，一个明显但并非每个人都知道的是，存在引擎材料。如果你打开编辑器并转到内容浏览器，你会在右下角看到一个视图选项的下拉菜单。选择显示引擎内容将在左侧的源浏览器中显示一个新文件夹，选择此文件夹，然后从过滤器下拉菜单中添加一个材料和材料实例的过滤器，就像这里一样，将显示一个现有的内置材料的大量列表：
- en: '![](img/db7f30e4-c71d-4ad2-aef5-638b30411292.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db7f30e4-c71d-4ad2-aef5-638b30411292.png)'
- en: 'Selecting the Daylight Ambient Cubemap as a quick example will open the material
    editor and look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以日光环境立方体贴图作为快速示例，将打开材料编辑器并看起来像这样：
- en: '![](img/b668d045-e4d7-4d5d-9743-00ec10039595.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b668d045-e4d7-4d5d-9743-00ec10039595.png)'
- en: 'For those new to editing materials, you can see it looks a lot like the blueprint
    editor and other node-based editing in UE4, which helps give a sense of familiarity
    across the different editor windows offered. Briefly describing what is shown
    here, the top-left has a preview (always just mapped to a sphere in the middle)
    of the material''s output. The bottom-left is the details of whatever node is
    selected. The center, of course, is the main editing pane. At the bottom is a
    summary of the shader''s complexity (more on this later!), and to the right is
    a list of nodes you can drop in (the same as if you right-click in the main pane).
    Browsing through the engine materials, you''ll see many are simply used by the
    editor itself. You''ll also notice (given the filter) several material instances.
    What''s the difference? And what''s different about a dynamic material instance?
    Let''s do a quick list here and continue to some more specific examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚开始编辑材料的人来说，你可以看到它看起来非常像蓝图编辑器和UE4中的其他基于节点的编辑，这有助于在不同编辑器窗口之间提供熟悉感。简要描述这里显示的内容，左上角是材料的预览（始终映射到中间的球体上）。左下角是所选节点的详细信息。当然，中心是主要的编辑面板。底部是着色器复杂性的摘要（稍后会有更多介绍），右侧是可以放入的节点列表（与在主面板上右键单击相同）。浏览引擎材料时，你会看到许多是由编辑器本身使用的。你也会注意到（考虑到过滤器），有几个材料实例。它们有什么区别？动态材料实例有什么不同？让我们在这里快速列出一些，并继续一些更具体的例子：
- en: A material is the most basic type, typically a parent class to material instances,
    when used, and consists of the basic flow of what the material (and compiled shader)
    are going to do
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料是最基本类型，通常是材料实例的父类，当使用时，它由材料（和编译的着色器）将要执行的基本流程组成
- en: By adding parameter nodes (more on this soon too), material instances can be
    inherited from a parent master material and given individual properties, so the
    whole material doesn't have to be remade to change, say, an input texture
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加参数节点（关于这一点很快也会有更多介绍），材料实例可以从父级主材料继承并赋予个别属性，因此整个材料不需要重做以更改，例如，输入纹理
- en: Dynamic material instances are material instances created at runtime that can
    take real-time parameters and change them in places like blueprints of an actor
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态材料实例是在运行时创建的材料实例，可以接受实时参数并在如演员蓝图等地方更改它们
- en: We'll go through some examples of each, creating our own as we go, and viewing
    others already built in the content of our project to date. But it's important
    to consider the usage of a material before you begin work on it. Is this a material
    that will be used in a very specific way with no need to derive children? Then
    it can probably just remain and be directly referenced as a material. Is the intention
    to have several variants of one core set of shader logic? Then you'll likely want
    a base material with a set of material instance children of course. Do you want
    something that takes parameters (think like a function being passed arguments
    in C++) at runtime with different outcomes based on that? You'll want to make
    a material, a material instance (at least one) thereof, and then at runtime, create
    a dynamic material instance (the easiest way is usually in the blueprint constructor
    of the object), and pass that its parameters either at startup or throughout that
    object's life. So let's take these one at a time in the next section, see what's
    involved in each of those cases, and get in the habit of building your materials
    right the first time to fit their use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Working on material networks and performance tips at editor time
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can easily begin a material from scratch (and it's highly recommended
    to just take some time playing with what can be done if you're unfamiliar), let's
    begin with an existing material and go through what it does, then begin changing
    it to something more useful in our test map.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To give a quick example of how we can change a material instance and apply it
    to the world, let's start with Content/InfinityBladeIceLands/Environments/Misc/Exo_Deco01/Materials,
    and we'll use the M_Exo_Crate_Open material as our starting point. Feel free to
    select it and open it in the material editor now.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a demonstration rolling, we''ll quickly do a few things to this base
    material. Drag from the Emissive Color pin and filter for time or the like to
    get the TimeWithSpeedVariable node placed here. Drag from its speed to the left
    and add a Constant. We''ll make sure that constant defaults to 0.0, thus not changing
    the base behavior everywhere else this crate material is used (in the frozen cove
    level). Lastly, right-click on that constant node, select Convert to Parameter,
    and name it EmissiveSpeed, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8997beff-61bb-418f-babd-d1101db2b637.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: For those paying close attention, you'll notice the Mobile texture samplers
    at the bottom is currently 2/8\. As soon as you save the material, its current
    graph gets applied (both to the material asset, as well as any instances in the
    level), and you'll see it jump from 2 to 6/8! Granted, tripling our texture sampling
    at runtime isn't great, but on mobile platforms that magic 8 number can be a very
    significant limit (more on that later in the chapter). But remember: *save to
    apply changes fully!*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that''s all done, back in the content browser, right-click on the crate
    material, and at the top is the option to Create Material Instance. We''ll use
    that to activate this emissive color in the instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成后，回到内容浏览器中，右键单击箱子材料，在顶部是创建材料实例的选项。我们将使用它来激活实例中的发射色：
- en: '![](img/37926a04-457c-44ff-83d6-8fb747a96fd3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37926a04-457c-44ff-83d6-8fb747a96fd3.png)'
- en: 'Just like in base materials, it''s important to always have whatever stats
    you need clicked to on at the top of these editors as you can immediately see
    an overview of the complexity of the material: base and vertex instructions and
    texture samplers. Small changes can make *huge* differences to these numbers,
    and getting artists and anyone working with materials familiar with what reasonable
    numbers are for your platform is critical to do early and always enforce!'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在基本材料中一样，始终在编辑器的顶部点击你需要的任何统计信息，这样你就可以立即看到材料的复杂性概述：基本和顶点指令以及纹理采样器。小的更改可以对这些数字产生*巨大*的影响，并且让艺术家以及任何与材料工作的人熟悉你平台上的合理数字是早期和始终执行的关键！
- en: 'Notice that while editing a material instance, the logic of the shader is gone.
    You can''t modify it in an instance, but you can modify parameters (that''s sort
    of the whole point of them!). In the top-right, check the box to allow editing
    of the EmissiveSpeed, and we''ll set it to 1.0\. Now, keep in mind this texture
    and its corresponding normal map were made for a specific model, not these cubes,
    but we''re again demonstrating concepts here, not making ready-to-ship art. We
    can now drag this (the instance''s icon from the content browser) on to one of
    the cubes in the level and play it. In the screenshot here, I lowered the direction
    light''s intensity to 0.6 or so, and brought the color of the sky light to a dark
    gray, but you don''t have to do these things. It just makes the lighting-independent
    nature of this pulsing emissive more obvious:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在编辑材料实例时，着色器的逻辑消失了。你无法在实例中修改它，但你可以修改参数（这几乎是它们的主要目的！）。在右上角，勾选允许编辑EmissiveSpeed的框，并将其设置为1.0。现在，请记住，这个纹理及其相应的法线贴图是为特定模型制作的，而不是这些立方体，但我们在这里演示的是概念，而不是制作即将发货的艺术品。我们现在可以将这个（内容浏览器中的实例图标）拖放到关卡中的一个立方体上并播放它。在这个屏幕截图中，我将方向光的强度降低到大约0.6，并将天空光的颜色调整为深灰色，但你不必做这些。这只是为了使这种脉冲发射的光照独立性质更加明显：
- en: '![](img/2b984e88-c338-48b9-b9f9-6b043f149648.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b984e88-c338-48b9-b9f9-6b043f149648.png)'
- en: 'So while it''s not perfect (we''ll improve it in just a moment!) you can see
    now a trick that a lot of games use to highlight items that the player should
    pick up in a game. They often have a pulsing shine to them that makes them stand
    out from the static backgrounds near them so the player won''t miss those valuable
    pick-ups. To test its pulsing, you can click Simulate from the Play button pull-down
    in the editor, though again for those of you playing along closely in the GitHub
    project, you''ll notice this exposes a check of mine on the player controller
    being the right type. So, any time a serious bug like that is found, you check
    in a fix ASAP. But let''s view that box now (either by playing the level normally,
    or syncing commit ce0da7c, or making the following fix locally):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以虽然它还不完美（我们稍后会改进它！）但你现在可以看到许多游戏用来突出玩家在游戏中应该捡起的项目的小技巧。它们通常有一个闪烁的光芒，使它们从附近的静态背景中脱颖而出，这样玩家就不会错过这些有价值的物品。要测试其脉冲，你可以从编辑器的播放按钮下拉菜单中选择模拟，尽管对于那些在GitHub项目中密切参与的人来说，你会注意到这暴露了我对玩家控制器类型的检查。所以，每当发现严重的错误时，你应立即检查并修复。但现在让我们查看那个框（无论是通过正常播放关卡，还是同步提交ce0da7c，或者本地进行以下修复）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And you can now see the results of a few quick changes to the material. Let''s
    improve it a bit quickly, and then move on. First we''ll make the pulsing follow
    a sine output rather than linear, and we''ll put a cap on its magnitude, defaulted
    to 0.5:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到对材料进行一些快速更改的结果。让我们快速改进一下，然后继续。首先，我们将使脉冲跟随正弦输出而不是线性输出，并对其幅度进行限制，默认设置为0.5：
- en: '![](img/0920a37c-1e3d-47fe-8427-c62a6248e7e5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0920a37c-1e3d-47fe-8427-c62a6248e7e5.png)'
- en: Now if you go to the material instance. As the MaxEmissive is also a parameter
    now, you can see it and set it to something else (say 0.25 to make it all a bit
    more subtle) and look at our result.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你转到材料实例。由于MaxEmissive现在也是一个参数，你可以看到它并将其设置为其他值（比如0.25，使其更加微妙），然后查看我们的结果。
- en: 'To make a dynamic material instance, we need to edit the blueprint of the Physics
    Box object in the test level, select any of them, and then in its details pane,
    pick Edit Blueprint and open the editor. Here we can add logic such as this, but
    note: this will change the logic for *all* of the boxes in the level now, and
    will even overwrite (as we put it in slot 0) the unmodified material instance
    on the box we were working on before. Add this and check out the result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fab396e1-4547-4cad-8ef6-98e4a692354c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Now we have a really fast pulsing material on all our boxes. If you wanted it
    on just a select few, it's possible to do this by referencing it in the level
    blueprint or by making individual box types instead of just the one they all are
    instances of, but now, hopefully, the value of creating a dynamic instance with
    parameters that can be set at runtime by blueprint events is evident. You could
    even change the material back to the default cube material upon being hit. The
    flexibility here is very powerful! Just keep in mind there are some specific precomputed
    possibilities that are lost if you replace a material dynamically at runtime,
    but for most games and projects, real-time lighting and effects are the prominent
    feature on anything you would give a dynamic material instance to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget also that static meshes (and other meshes) can have many materials:
    just look around at some of the pieces in the map Frozen Cove! All will be applied
    when rendering the actor. The first material is typically the one used for setting
    the Physical Material and the most basic/fundamental rendering of the object,
    but if you pick a static mesh object (including the 1M_Cube of this test level),
    you can see its materials are just an array with no hard limit (only practical
    ones for performance and manageability).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Materials at runtime and various platforms
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that editing materials is familiar and we briefly noted how one seemingly
    small change drastically increased one of the stats of a material, it's time to
    get a bit more in-depth here and understand the tools available for runtime analysis.
    There are myriad tools for analyzing the graphical performance of your scene,
    several built into UE4, and others that are free that you can explore. NVIDIA
    makes a great set of tools, a lifesaver for Android developers, which can be found
    in the additional reading section. For now, we'll focus on what we can do inside
    Unreal and the editor first and foremost as our main tool and early testing spot.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Runtime tools and techniques to quickly iterate shaders
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most immediately useful tools in your arsenal for shader performance
    is the Shader Complexity viewmode. In any viewport window in the editor, this
    can be found by clicking the lighting drop-down menu (next to the perspective
    drop-down menu in the top-left corner of the viewport. In the screenshots, these
    are typically Lit and Perspective respectively). In there, under Optimization
    Viewmodes is Shader Complexity (*Alt+8* being the shortcut on PC, *Alt+4* to get
    back to lit). However, in our test level there''s not much to look at, so let''s
    quickly go to the frozen cove map, which has a lot more of interest. At runtime,
    on any platform with the console enabled (*~* key on PC, 4-finger tap on most
    mobile devices), you can access this also via the show ShaderComplexity command,
    and as that''s most interesting here, let''s take a look at what we get at the
    start of frozen cove:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具库中，对于着色器性能来说，最直接有用的工具之一就是着色器复杂度视图模式。在任何编辑器中的视口窗口中，你可以通过点击灯光下拉菜单（位于视口左上角视角下拉菜单旁边）来找到它。在屏幕截图上，这些通常分别是“光照”和“视角”。在那里，在优化视图模式下是着色器复杂度（在PC上，快捷键是*Alt+8*，要回到光照模式，按*Alt+4*）。然而，在我们的测试级别中，没有什么可看的，所以让我们快速转到冻结海湾地图，那里有更多有趣的东西。在运行时，在启用了控制台的所有平台上（PC上的*~*键，大多数移动设备上的四指轻触），你也可以通过显示ShaderComplexity命令来访问它，由于这里最有趣，让我们看看在冻结海湾开始时我们得到了什么：
- en: '![](img/a4f54bd0-8e5b-4adf-bf7a-8a12753ce418.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4f54bd0-8e5b-4adf-bf7a-8a12753ce418.png)'
- en: Yikes! As is obvious from the color scale at the bottom, there's something serious
    going on there in the middle, and of course, it's obvious it's the blowing snow/clouds
    that drift through the center of the map. What you'll often find on most platforms
    is your most hated foe from a performance standpoint is overdraw. Most developers
    are at least familiar with the term, but this is where the GPU is forced to draw
    then re-draw the same pixel on the screen a number of times. Translucence tends
    to be the biggest cause of overdraw, as is exactly the case here. We have a ton
    of giant particles, all with alpha translucence, on top of each other from a rendering
    standpoint (our camera's perspective). Thus to blend them all, those pixels where
    they overlap are redrawn a huge number of times, making those bright white spots
    of shader work. On a decent PC this is all fine and good as the framerate in even
    a non-optimized build is still 50+ fps for this level, but on other platforms
    (especially mobile devices), this will quickly become a nightmare scenario, discussed
    further in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！从底部的颜色刻度可以看出，中间似乎有些严重的问题，当然，很明显是吹拂的雪花/云朵穿过地图的中心。你通常会在大多数平台上发现，从性能角度来看，你最讨厌的敌人是过度绘制。大多数开发者至少对这个词很熟悉，但这就是GPU被迫在屏幕上多次绘制和重绘相同像素的情况。半透明通常是最主要的过度绘制原因，这里也是一样。从渲染的角度来看，我们有一大堆巨大的粒子，所有这些粒子都具有alpha半透明，它们堆叠在一起（从我们的摄像机视角来看）。因此，为了将它们全部混合，那些重叠的像素被重新绘制了无数次，形成了那些明亮的白色着色器工作区域。在性能良好的PC上，这都没问题，即使是未优化的构建，这个级别的帧率也能达到50+
    fps，但在其他平台（尤其是移动设备）上，这很快就会变成一个噩梦场景，将在下一节中进一步讨论。
- en: 'In the meantime, since we don''t have a dedicated chapter in this book on optimization,
    hopefully an overview of helpful tools and some links to further reading will
    suffice. First, get to know your stat ... command-line cheats. These can give
    you huge amounts of real-time data in-game, and being familiar with a number of
    them is always recommended. That said, the ones I recommend most highly are stat
    CPU, stat GPU (where you can easily see the cost of translucence), stat Game, and
    stat FPS, the latter of which should probably be turned on by default in almost
    every non-release build.  Also of note, stat Memory is a huge help too, but for
    memory consumption, not directly performance. Figuring out where your game is
    bound of course is the key to knowing where to optimize to improve your framerate.
    Again, this is probably fairly common knowledge among most developers; but this
    simply means: is your main thread, render thread, or GPU cost the highest each
    frame. You''re only as fast as the slowest member of that group, and the Profiler
    in the Session Frontend window was discussed very early on. It is a good tool
    for getting very detailed information about the first two (main/game thread and
    render thread) to see whether you are using up too much CPU. The `stat GPU` command
    is the fastest way to check whether that is your bottleneck, but for detailed
    information such as in the profiler, you can use stat startfile and stat stopfile to
    generate detailed information and also open it in the frontend window. On other
    platforms or for a different perspective, again, see NVIDIA''s tools (mentioned
    earlier) or explore the many options each platform typically supplies to its developers.
    For a little bit more detail on UE4''s options, a couple of links have been added
    to the *Further reading *section. Of note at this point, you can, even while simulating
    or running a level, begin editing materials (and remember to save them to propagate
    changes!) and see the results directly and immediately.  So let''s now explore
    a couple of options here with these blending particles as examples of this.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，由于我们在这本书中没有专门关于优化的章节，希望一个有用的工具概述和一些进一步阅读的链接就足够了。首先，了解你的stat ... 命令行快捷方式。这些可以在游戏中提供大量的实时数据，并且熟悉其中的一些总是被推荐。话虽如此，我最推荐的是stat
    CPU、stat GPU（在这里你可以轻松看到透明度的成本）、stat Game和stat FPS，后者在几乎每个非发布版本中可能默认开启。另外值得注意的是，stat
    Memory也非常有帮助，但它是针对内存消耗，而不是直接性能。当然，找出你的游戏在哪里受限是了解如何优化以提高帧率的钥匙。再次强调，这可能是大多数开发者中相当普遍的知识；但这仅仅意味着：你的主线程、渲染线程或GPU在每一帧中成本最高。你的速度取决于这个群体中最慢的那个成员，Session
    Frontend窗口中的Profiler在早期就被讨论过了。这是一个获取非常详细信息的良好工具，关于前两个（主/游戏线程和渲染线程）以查看你是否使用了过多的CPU。检查`stat
    GPU`命令是检查这是否是你的瓶颈的最快方式，但为了获取如Profiler中的详细信息，你可以使用stat startfile和stat stopfile来生成详细的信息，并在前端窗口中打开它。在其他平台或从不同角度，再次，请参阅NVIDIA的工具（前面提到过）或探索每个平台通常提供给开发者的许多选项。关于UE4选项的更多细节，*进一步阅读*部分添加了一些链接。值得注意的是，即使在进行模拟或运行关卡时，你也可以开始编辑材质（并记得保存它们以传播更改！）并直接立即看到结果。那么现在让我们探索一些选项，以这些混合粒子作为示例。
- en: Know Your Platform and How to Adapt Shaders!
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解你的平台以及如何调整着色器！
- en: 'Knowing what platform you are developing for is obviously key to any performance
    optimization, especially in the graphics and shader department. For example, let''s
    say we''re aiming to include mid-performance Android phones and tablets as a platform.
    The fastest way to test what things may look like there is to go to the main editor
    menu''s settings drop-down menu, then Preview Rendering Level, Mobile / HTML5,
    and pick Android Preview. At this point, you''ll probably see this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你正在为哪个平台开发显然是任何性能优化的关键，尤其是在图形和着色器部门。例如，假设我们旨在将中等性能的Android手机和平板电脑作为一个平台。测试在那里事物可能看起来如何的最快方法是转到主编辑菜单的设置下拉菜单，然后预览渲染级别，选择移动/HTML5，并选择Android预览。在这个时候，你可能看到这个：
- en: '![](img/f2a4f86d-568a-4858-b80e-dcf4fe16d5fa.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2a4f86d-568a-4858-b80e-dcf4fe16d5fa.png)'
- en: We're now having to rebuild something like 8,000+ shaders for this new platform,
    but as may have been noted, this happened the first time opening this level on
    PC as well. It simply has to be done once, then smaller changes will cause smaller
    shader recompilations, but initially, this can be several minutes of serious CPU
    utilization as it builds all of those shaders. Just know that it won't keep happening
    in this level once they're cached for this preview mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须为这个新平台重建大约8,000多个着色器，但正如可能已经注意到的，这第一次在PC上打开这个级别时也发生了。这必须只做一次，然后较小的更改将导致较小的着色器重新编译，但最初，这可能会占用几分钟的严重CPU利用率，因为它正在构建所有这些着色器。只需知道，一旦它们为这种预览模式缓存，在这个级别中就不会再发生这种情况。
- en: 'Once that''s done, let''s play again and show shader complexity again now that
    we''re in OpenGL ES2 emulation in our viewport while playing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，让我们再次开始并再次展示着色器复杂性，现在我们在视图中进行OpenGL ES2模拟时：
- en: '![](img/30eb2379-b665-4835-9236-696e963da694.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30eb2379-b665-4835-9236-696e963da694.png)'
- en: Yikes! Now that overdraw is getting serious. So what can we do?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！现在过度绘制变得严重了。我们该怎么办？
- en: 'Well, the most obvious approach, as these are just a cosmetic feature (and
    other than a bit of visibility, are not there to affect gameplay), we simply tell
    the particle emitters not to run at certain quality levels. This section is not
    on particle FX (but there is one coming later!) so we''ll just briefly test this
    theory to prove our ES2 killing overdraw is coming from them specifically. Searching
    the level for emitters, eventually P_Snow_BlowingLarge_particulates stands out
    and is in fact the culprit. Opening it up, we can click on the emitter with the
    large swirling cloud particles and set its Detail Mode to Medium, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，最明显的方法是，这些只是外观上的功能（除了稍微影响可见性外，并不旨在影响游戏玩法），我们简单地告诉粒子发射器不要在特定质量级别上运行。这一节不是关于粒子特效（但稍后会有一个），所以我们只是简要测试这个理论，以证明我们的ES2过度绘制问题确实来自它们。在级别中搜索发射器，最终P_Snow_BlowingLarge_particulates脱颖而出，实际上就是罪魁祸首。打开它，我们可以点击带有大型旋转云粒子的发射器，将其详细模式设置为中等，如图所示：
- en: '![](img/025f6265-cc15-4eb0-8314-62212057e2c0.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/025f6265-cc15-4eb0-8314-62212057e2c0.png)'
- en: 'But, of course, nothing changes in our preview until we change the available
    performance levels there, too. Here, we''ll want to modify the scalability settings
    we''re using to preview this in-editor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，在我们的预览中，除非我们也更改可用的性能级别，否则没有任何变化。在这里，我们将想要修改我们用来在编辑器中预览的可扩展性设置：
- en: '![](img/91146e15-3a01-4e64-b97c-26d142fa9388.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91146e15-3a01-4e64-b97c-26d142fa9388.png)'
- en: 'So, as shown here, we''re going to set our current Effects level to Low, and
    voila, no more particles causing our biggest burning overdraw performance hit:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如图所示，我们将把当前的特效级别设置为低，哇，不再有粒子导致我们最大的过度绘制性能打击：
- en: '![](img/76bd8db6-aa25-4b0d-82f9-e8550f5fc539.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76bd8db6-aa25-4b0d-82f9-e8550f5fc539.png)'
- en: Don't worry about the lighting rebuild warning here in-game, as you can't build
    precomputed lighting in the editor under ES2 emulation (which you conveniently
    can see is on in the bottom-right corner), and it's also saying the vertex fog
    this level uses won't work at all in this mode. Good information, but *always* be
    sure to test whenever possible on the actual devices themselves. The emulation
    is a great way to quickly iterate a few ideas, but until you actually test these
    changes on a proper device with its library and OS updated to whatever level is
    appropriate, and it's using its own drivers, you can't be sure your results will
    match anything like the best emulation you could hope for here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中不用担心光照重建警告，因为在ES2模拟下，你无法在编辑器中构建预计算的光照（你方便地可以看到它在右下角是开启的），它还指出这个级别使用的顶点雾在这个模式下根本无法工作。这是有用的信息，但*始终*在可能的情况下确保在实际设备上进行测试。模拟是快速迭代几个想法的好方法，但直到你实际上在一个适当的设备上测试这些更改，并且它的库和操作系统更新到适当的水平，并且它使用自己的驱动程序，你才能确信你的结果会与这里可能希望得到的最佳模拟相匹配。
- en: 'While there are still plenty of things to worry about if we were to use this
    level on anything but higher-range Android devices (using ES3+ or other rendering),
    the biggest offender was just removed. But you may be asking, "*isn''t this chapter
    about modifying materials to suit your* needs?" Yes, it certainly is. Let''s find
    the material used in these particles. Tracing it from the emitters properties,
    it''s a smoke-like material instance whose parent is a translucent material. A
    typical adjustment from high-end rendering to ES2 OpenGL or lower-end rendering
    is to turn those translucent materials into masked, and rather than sending a
    graded alpha in to the translucency channel, you just send a 1-bit mask, like
    here, in the grass material near the start point in the map:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果我们不在高端Android设备（使用ES3+或其他渲染）上使用这个关卡，还有很多事情要担心，但最大的问题已经被移除了。但你可能会问，“*这一章不是关于修改材质以适应你的需求吗？*”是的，当然是的。让我们找到这些粒子中使用的材质。从发射器的属性中追踪，它是一个烟雾状的材质实例，其父级是不透明材质。从高端渲染到ES2
    OpenGL或低端渲染的典型调整是将那些不透明材质转换为遮罩，而不是向透明度通道发送渐变alpha，你只需发送一个1位的遮罩，就像这里在地图起点附近的草地材质中一样：
- en: '![](img/d38d9cc0-9622-462f-a637-7303ad5731fa.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d38d9cc0-9622-462f-a637-7303ad5731fa.png)'
- en: 'Note the alpha channel of the input texture going to the mask input of the
    shader (also interesting is the wind node which is used to shift the grass around
    at runtime, feel free to experiment with it, too).  Now, we have some pros and
    cons to this of course.  Pro: there''s no overdraw where you see through the texture,
    because the mask tells the renderer to never draw the pixel in the first place! 
    Con: you get hard edges where the mask falls, not smooth, subtle fading edges. 
    We''ve all seen this in games before, but take a look here at the grass in our
    preview window:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输入纹理的alpha通道连接到着色器的遮罩输入（风节点也很有趣，它在运行时用于移动草地，也请随意实验）。现在，当然，我们对此有一些优点和缺点。优点：在可以看到纹理的地方没有过度绘制，因为遮罩告诉渲染器一开始就不要绘制像素！缺点：遮罩处会有硬边，而不是平滑、微妙的渐变边缘。我们之前在游戏中都见过这种情况，但请看看预览窗口中的草地：
- en: '![](img/09205f73-ea87-4bc1-bd42-0cf922a26337.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09205f73-ea87-4bc1-bd42-0cf922a26337.png)'
- en: 'This works OK for things such as plants, or literally holes in surfaces, but
    would look amateurish at best for something like a puff of a snowy cloud like
    the effect here. So what can be done with materials to address this? Let''s get
    acquainted with by far the most helpful little node for this purpose, the quality
    switch. Here is the translucent material as it shipped with the level:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于植物或表面上的实际孔洞等东西来说效果不错，但对于像这里这样的雪云效果来说，最多看起来像业余水平。那么，我们可以通过材质做些什么来解决这个问题呢？让我们先熟悉一下到目前为止最有用的节点，即质量开关。以下是关卡附带的不透明材质：
- en: '![](img/dd36b8fe-2212-4599-b1e4-86fa146ffe44.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd36b8fe-2212-4599-b1e4-86fa146ffe44.png)'
- en: 'And here''s how we can insert the quality node to set low-quality FX to not
    do this alpha blending business on those devices:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何插入质量节点，将低质量FX设置为在这些设备上不执行这种alpha混合操作：
- en: '![](img/a6b99887-f958-4266-bd6c-02c8c39408db.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6b99887-f958-4266-bd6c-02c8c39408db.png)'
- en: 'If we now set the particle system back to >= Low detail mode (so it always
    tries to emit), but keep our editor''s scalability setting for effects to Low,
    the particles will also stop drawing and will not be a drag on our GPU performance
    anymore. This can be shown real time by playing the level before saving the change
    (or simply wiring the alpha of DIFF directly back into the A channel of the multiply
    node). With it wired up with the quality switch, save the material, and poof:
    the snowy cloud wisps are gone.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将粒子系统设置回 >= 低细节模式（使其始终尝试发射），但保持我们的编辑器效果缩放设置为低，粒子也将停止绘制，不再对我们的GPU性能造成拖累。这可以通过在保存更改之前播放关卡来实时展示（或者简单地将DIFF的alpha直接连接到乘法节点的A通道）。通过将其连接到质量开关，保存材质，然后：雪云的飘渺消失。
- en: 'So, one last point here. That''s all fine and good in the editor, but how do
    these things get set per platform, or even per device? Config (.ini) files. Keep
    in mind that in the Config folder of the project, you can have a subfolder for
    each relevant platform (so Config/Android, Config/Windows, Config/iOS, and so
    on), and for each Default... .ini in the base folder, you can create a platform-specific
    one in its folder (so, for example, DefaultEngine.ini is overridden on Android
    devices by `Config/Android/AndroidEngine.ini`). Config files are always applied
    from most specific to least specific, so if a property is in `AndroidEngine.ini`,
    the game''s `Config/DefaultEngine.ini`, *and* the engine''s `Config/BaseEngine.ini`,
    the `AndroidEngine.ini` propery will be the last one applied, and the one used
    at runtime. That said, if you''re working with a significant number of devices,
    you''ll likely want to add these properties at the game''s `Config/DefaultDeviceProfiles.ini`
    level. Here''s a quick rundown of what can be done there:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里还有一个最后要点。在编辑器中，这一切都很好，但这些设置是如何针对每个平台，甚至每个设备来设置的？配置（.ini）文件。记住，在项目的Config文件夹中，你可以为每个相关平台创建一个子文件夹（例如Config/Android、Config/Windows、Config/iOS等），并且对于基础文件夹中的每个Default...
    .ini，你可以在其文件夹中创建一个特定平台的配置文件（例如，DefaultEngine.ini在Android设备上被`Config/Android/AndroidEngine.ini`覆盖）。配置文件总是从最具体到最不具体地应用，所以如果某个属性在`AndroidEngine.ini`、游戏的`Config/DefaultEngine.ini`以及引擎的`Config/BaseEngine.ini`中，那么`AndroidEngine.ini`中的属性将是最后应用的，并在运行时使用。话虽如此，如果你正在处理大量设备，你可能会想在游戏的`Config/DefaultDeviceProfiles.ini`级别添加这些属性。以下是在那里可以做的事情的简要概述：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we define a special named device and its type (Android).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个特殊命名的设备和其类型（Android）。
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This chunk tells the engine how to figure out whether the device it''s started
    on is running that device type (by searching for the GPU type):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容告诉引擎如何确定它启动的设备是否正在运行该设备类型（通过搜索GPU类型）：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have a couple of default values for an Android device (all of them
    unless overridden more specifically after):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们为Android设备提供了一些默认值（除非有更具体的覆盖）：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a profile for high-performance Android properties to use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于高性能Android属性的配置文件：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And lastly, we simply set the specific Adreno4xx_High type to the Android_High
    type, but we could at that point set any properties we wanted to different levels
    as well. For our material, in the profiles we wanted the snowy clouds not to show
    up, so we''d simply set the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将特定的Adreno4xx_High类型设置为Android_High类型，但在此点我们也可以将任何我们想要的属性设置为不同的级别。对于我们的材质，在配置文件中我们希望雪云不要显示，所以我们只需设置以下内容：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In a more general fashion, you can set (Platform)Scalability.ini's sg.EffectsQuality
    to 0, as is shown in great detail in the scalability reference link from Epic
    in the *Further reading* section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以更通用的方式，你可以将(Platform)Scalability.ini的sg.EffectsQuality设置为0，这在Epic在*进一步阅读*部分的扩展链接中有详细说明。
- en: 'One warning: at the end of the GitHub project for this chapter, .uasset file
    types were added to Git''s LFS system because of some very large assets. Jumping
    back to earlier projects will turn any later changed .uasset pointers back into
    .uasset data objects and confuse LFS, which may require you to fix your local
    branch by doing a hard reset to before this LFS change (commit c24d2db), then
    doing a hard reset to the changelist or branch forward that you wanted to work
    in if it refuses to let you discard .uasset changes because it says it can''t
    parse the pointer (thinking it should be an LFS pointer, not a binary .uasset).
    All maintained branches going forward (Chapter-9, master, and the new In-Progress)
    will be set to have their .uassets tracked properly. It''s only an issue when
    jumping back, but hopefully these tips can get past it for any who do.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：在本章GitHub项目的末尾，由于一些非常大的资源，.uasset文件类型被添加到Git的LFS系统中。跳回早期项目将任何后续更改的.uasset指针转换回.uasset数据对象，并可能使LFS困惑，这可能需要你通过执行硬重置到LFS更改之前（提交c24d2db）来修复你的本地分支，然后如果你无法丢弃.uasset更改因为它说它无法解析指针（认为它应该是一个LFS指针，而不是二进制.uasset），那么你可以执行硬重置到你想工作的更改列表或分支。所有未来的维护分支（第9章、master和新的In-Progress）都将设置为正确跟踪它们的.uassets。这仅当跳回时才是一个问题，但希望这些提示可以帮助任何遇到这个问题的人。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For those already familiar with UE4's material system, hopefully this was a
    good review and came with some new information or pointers along the way. For
    those who were previously inexperienced, you should now have a solid foundation
    to build upon for driving a team and project forward and making the right decisions
    with the most commonly used powerful tools that Unreal makes available. There
    is always more to learn, but having a level of competence across areas such as
    this is mandatory for being able to take a project to a higher level and demonstrate
    to a team the skills and knowledge needed to manage such a complex and powerful
    world that UE4's materials offer every project. Finally, as promised, for those
    familiar with writing HLSL or GLSL directly, and wondering what this looks like
    for UE4, take a look in the Engine's Shaders/Private folder at things such as
    VolumetricFog.usf. For those who want to get started down this path or who are
    new to Unreal's way of compiling shaders themselves, another great link is in
    the *Further reading* section for just that pursuit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经熟悉UE4材质系统的用户，希望这能是一个良好的复习，并且在过程中获得了一些新的信息或指导。对于那些之前没有经验的用户，现在你们应该有了坚实的基础，可以在此基础上推动团队和项目向前发展，并使用UE4提供的最常用的强大工具做出正确的决策。总有更多东西要学习，但在这种领域达到一定水平是能够将项目提升到更高层次并展示给团队管理这样一个复杂且强大的世界（UE4的材质为每个项目提供）所需技能和知识所必需的。最后，正如承诺的那样，对于那些熟悉直接编写HLSL或GLSL的用户，并且想知道UE4中这看起来是什么样子，请查看引擎的Shaders/Private文件夹中的内容，例如VolumetricFog.usf。对于那些想要开始这条道路或对Unreal自己编译着色器的方式新手的用户，*进一步阅读*部分中还有一个很好的链接。
- en: Questions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a material and a material instance?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 材质和材质实例之间的区别是什么？
- en: A material instance is only meaningful if adding a very specific node type to
    a material. What is that type?
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 材料实例只有在向材质添加一个非常具体的节点类型时才有意义。这是什么类型？
- en: Simulation from the play drop-down menu can be helpful. What things did it reveal
    in this chapter?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从播放下拉菜单中模拟可以很有帮助。它在本章中揭示了哪些内容？
- en: What is the purpose of a dynamic material instance, and where/when can they
    be made?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态材质实例的目的是什么，它们可以在哪里/什么时候创建？
- en: What is the key tool for finding GPU-killing shaders in an area of a map?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图区域中寻找导致GPU性能下降的着色器的关键工具是什么？
- en: Which command-line options are most helpful for profiling any and all performance
    problems?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些命令行选项对于分析任何和所有性能问题最有帮助？
- en: What node is your best friend when trying to tune materials across various platforms?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当尝试在各种平台上调整材质时，哪个节点是你的好朋友？
- en: How can per-platform settings across almost all significant performance factors
    be set?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置几乎所有重要性能因素的平台特定设置？
- en: Further reading
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'NVIDIA PerfKit (Android and PC):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA PerfKit（Android和PC）：
- en: '[https://developer.nvidia.com/nvidia-perfkit](https://developer.nvidia.com/nvidia-perfkit)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.nvidia.com/nvidia-perfkit](https://developer.nvidia.com/nvidia-perfkit)'
- en: 'UE4 CPU profiling:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 CPU性能分析：
- en: '[https://docs.unrealengine.com/en-us/Engine/Performance/CPU](https://docs.unrealengine.com/en-us/Engine/Performance/CPU)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/Performance/CPU](https://docs.unrealengine.com/en-us/Engine/Performance/CPU)'
- en: 'UE4 GPU profiling:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 GPU性能分析：
- en: '[https://docs.unrealengine.com/en-US/Engine/Performance/GPU](https://docs.unrealengine.com/en-US/Engine/Performance/GPU)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Performance/GPU](https://docs.unrealengine.com/en-US/Engine/Performance/GPU)'
- en: 'Unreal scalability reference:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal可扩展性参考：
- en: '[https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference](https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference](https://docs.unrealengine.com/en-us/Engine/Performance/Scalability/ScalabilityReference)'
- en: 'Unreal Shader development (.usf, including HLSL/GLSL cross-compiling explained):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal着色器开发 (.usf，包括HLSL/GLSL交叉编译解释）：
- en: '[https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment](https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment](https://docs.unrealengine.com/en-us/Programming/Rendering/ShaderDevelopment)'
