["```cpp\nstatic const glm::vec3 CubeMapDirections[6] = { \n  { 1.f, 0.f, 0.f },  // 0 = Positive X \n  { -1.f, 0.f, 0.f }, // 1 = Negative X \n  { 0.f, 1.f, 0.f },  // 2 = Positive Y \n  { 0.f, -1.f, 0.f }, // 3 = Negative Y \n  { 0.f, 0.f, 1.f },  // 4 = Positive Z \n  { 0.f, 0.f, -1.f }  // 5 = Negative Z \n}; \n\n```", "```cpp\nstatic const int ShadowMeshIndices = 36; \nstatic const GLuint CubeIndices[ShadowMeshIndices] = { \n  0, 4, 7, 7, 3, 0,  // Front \n  0, 1, 5, 5, 4, 0,  // Left \n  3, 7, 6, 6, 2, 3,  // Right \n  1, 2, 6, 6, 5, 1,  // Back \n  7, 4, 5, 5, 6, 7,  // Up \n  1, 0, 3, 3, 2, 1   // Down \n}; \n\n```", "```cpp\nstatic const glm::vec3 CubeMapUpDirections[6] = { \n  { 0.f, -1.f, 0.f },  // 0 = Positive X \n  { 0.f, -1.f, 0.f }, // 1 = Negative X \n  { 0.f, 0.f, -1.f },  // 2 = Positive Y \n  { 0.f, 0.f, -1.f }, // 3 = Negative Y \n  { 0.f, -1.f, 0.f },  // 4 = Positive Z \n  { 0.f, -1.f, 0.f }  // 5 = Negative Z \n}; \n\n```", "```cpp\nstruct ShadowCasterPrototype { \n  ... \n  glm::vec3 m_vertices[ShadowMeshVertices]; \n  GLuint m_VAO; \n  GLuint m_VBO; \n  GLuint m_indexVBO; \n}; \n\n```", "```cpp\nShadowCasterPrototype() : m_VAO(0), m_VBO(0), m_indexVBO(0) {} \n~ShadowCasterPrototype() { \n  if (m_VBO) { glDeleteBuffers(1, &m_VBO); } \n  if (m_indexVBO) { glDeleteBuffers(1, &m_indexVBO); } \n  if (m_VAO) { glDeleteVertexArrays(1, &m_VAO); } \n} \n\n```", "```cpp\nvoid UploadVertices() { \n  if (!m_VAO) { glGenVertexArrays(1, &m_VAO); } \n  glBindVertexArray(m_VAO); \n  if (!m_VBO) { glGenBuffers(1, &m_VBO); } \n  if (!m_indexVBO) { glGenBuffers(1, &m_indexVBO); } \n\n  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); \n  glBufferData(GL_ARRAY_BUFFER, \n    ShadowMeshVertices * sizeof(m_vertices[0]), m_vertices, \n    GL_STATIC_DRAW); \n  // Position vertex attribute. \n  glEnableVertexAttribArray(0); \n  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, \n    sizeof(glm::vec3), 0); \n\n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); \n  glBufferData(GL_ELEMENT_ARRAY_BUFFER, \n    ShadowMeshIndices * sizeof(CubeIndices[0]), CubeIndices, \n    GL_STATIC_DRAW); \n  glBindBuffer(GL_ARRAY_BUFFER, 0); \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); \n\n  glBindVertexArray(0); \n} \n\n```", "```cpp\nvoid Draw() { \n  glBindVertexArray(m_VAO); \n  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indexVBO); \n  glDrawElements(GL_TRIANGLES, ShadowMeshIndices, \n    GL_UNSIGNED_INT, 0); // 0 = offset. \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); \n  glBindBuffer(GL_ARRAY_BUFFER, 0); \n  glBindVertexArray(0); \n} \n\n```", "```cpp\nbool operator == (const ShadowCasterPrototype& l_rhs) const { \n  for (unsigned short i = 0; i < ShadowMeshVertices; ++i) { \n    if (m_vertices[i] != l_rhs.m_vertices[i]) { return false; } \n  } \n  return true; \n} \n\n```", "```cpp\nusing ShadowCasterPrototypes = std::unordered_map<std::string, \n  std::unique_ptr<ShadowCasterPrototype>>; \n\n```", "```cpp\nstruct ShadowCaster { \n  ShadowCaster() : m_prototype(nullptr) { } \n  ShadowCasterPrototype* m_prototype; \n  GL_Transform m_transform; \n}; \n\n```", "```cpp\nusing ShadowCasters = std::vector<std::unique_ptr<ShadowCaster>>; \n\n```", "```cpp\nglm::mat4 GL_Transform::GetModelMatrix() { \n  glm::mat4 matrix_pos = glm::translate(m_position); \n  glm::mat4 matrix_scale = glm::scale(m_scale); \n  // Represent each stored rotation as a different matrix, \n  // because we store angles. \n  //                Directional vector  x, y, z \n  glm::mat4 matrix_rotX = \n    glm::rotate(m_rotation.x, glm::vec3(1, 0, 0)); \n  glm::mat4 matrix_rotY = \n    glm::rotate(m_rotation.y, glm::vec3(0, 1, 0)); \n  glm::mat4 matrix_rotZ = \n    glm::rotate(m_rotation.z, glm::vec3(0, 0, 1)); \n  // Create a rotation matrix. Multiply in reverse order it \n  // needs to be applied. \n  glm::mat4 matrix_rotation = matrix_rotZ*matrix_rotY*matrix_rotX; \n  // Apply transforms in reverse order they need to be applied in. \n  return matrix_pos * matrix_rotation * matrix_scale; \n} \n\n```", "```cpp\nGL_Camera::GL_Camera(const glm::vec3& l_pos, float l_fieldOfView, \n  float l_aspectRatio, float l_frustumNear, float l_frustumFar) \n  :m_position(l_pos),m_fov(l_fieldOfView),m_aspect(l_aspectRatio), \n  m_frustumNear(l_frustumNear), m_frustumFar(l_frustumFar) \n{ \n  RecalculatePerspective(); \n  m_forwardDir = glm::vec3(0.f, 0.f, 1.f); \n  m_upDir = glm::vec3(0.f, 1.f, 0.f); \n} \n\n```", "```cpp\nglm::mat4 GL_Camera::GetViewMatrix() { \n  return glm::lookAt(m_position, m_position + m_forwardDir, \n    m_upDir); \n} \nglm::mat4& GL_Camera::GetProjectionMatrix() { \n  return m_perspectiveMatrix; \n} \n\nvoid GL_Camera::RecalculatePerspective() { \n  m_perspectiveMatrix = glm::perspective(glm::radians(m_fov), \n    m_aspect, m_frustumNear, m_frustumFar); \n} \n\n```", "```cpp\nclass CubeTexture { \npublic: \n  CubeTexture(); \n  ~CubeTexture(); \n\n  void RenderingBind(); \n  void RenderingUnbind(); \n  void SamplingBind(unsigned int l_unit); \n  void SamplingUnbind(unsigned int l_unit); \n\n  GLuint GetTextureHandle()const; \n\n  void RenderToFace(unsigned int l_face); \n  void Clear(); \n\n  static const unsigned int TextureWidth = 1024; \n  static const unsigned int TextureHeight = 1024; \nprivate: \n  void Create(); \n  void CreateBuffers(); \n  void CreateFaces(); \n  GLuint m_textureID; // Texture handle. \n  GLuint m_fbo; // Frame-buffer handle. \n  GLuint m_rbo; // Render-buffer handle. \n}; \n\n```", "```cpp\nCubeTexture::CubeTexture() : m_textureID(0), m_fbo(0), m_rbo(0) \n  { Create(); } \nCubeTexture::~CubeTexture() { \n  if (m_fbo) { glDeleteFramebuffers(1, &m_fbo); } \n  if (m_rbo) { glDeleteRenderbuffers(1, &m_rbo); } \n  if (m_textureID) { glDeleteTextures(1, &m_textureID); } \n} \n\n```", "```cpp\nvoid CubeTexture::Create() { \n  if (m_textureID) { return; } \n  glGenTextures(1, &m_textureID); \n  CreateFaces(); \n  glTexParameteri(GL_TEXTURE_CUBE_MAP, \n    GL_TEXTURE_MAG_FILTER, GL_NEAREST); \n  glTexParameteri(GL_TEXTURE_CUBE_MAP, \n    GL_TEXTURE_MIN_FILTER, GL_NEAREST); \n  glTexParameteri(GL_TEXTURE_CUBE_MAP, \n    GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); \n  glTexParameteri(GL_TEXTURE_CUBE_MAP, \n    GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); \n  glTexParameteri(GL_TEXTURE_CUBE_MAP, \n    GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); \n\n  CreateBuffers(); \n  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); \n} \n\n```", "```cpp\nvoid CubeTexture::CreateFaces() { \n  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); \n  for (auto face = 0; face < 6; ++face) { \n    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, 0,GL_RGBA, \n      TextureWidth, TextureHeight, 0, GL_RGBA, \n      GL_UNSIGNED_BYTE, nullptr); \n  } \n} \n\n```", "```cpp\nvoid CubeTexture::Clear() { \n  glClearColor(1.f, 1.f, 1.f, 1.f); \n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n} \n\n```", "```cpp\nvoid CubeTexture::SamplingBind(unsigned int l_unit) { \n  assert(l_unit >= 0 && l_unit <= 31); \n  glActiveTexture(GL_TEXTURE0 + l_unit); \n  glEnable(GL_TEXTURE_CUBE_MAP); \n  glBindTexture(GL_TEXTURE_CUBE_MAP, m_textureID); \n} \nvoid CubeTexture::SamplingUnbind(unsigned int l_unit) { \n  assert(l_unit >= 0 && l_unit <= 31); \n  glActiveTexture(GL_TEXTURE0 + l_unit); \n  glBindTexture(GL_TEXTURE_CUBE_MAP, 0); \n  glDisable(GL_TEXTURE_CUBE_MAP); \n} \n\n```", "```cpp\nvoid CubeTexture::CreateBuffers() { \n  glGenFramebuffers(1, &m_fbo); \n  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); \n  glGenRenderbuffers(1, &m_rbo); \n  glBindRenderbuffer(GL_RENDERBUFFER, m_rbo); \n\n  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, \n    TextureWidth, TextureHeight); \n  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, \n    GL_RENDERBUFFER, m_rbo); \n  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); \n  if (status != GL_FRAMEBUFFER_COMPLETE) { ... } // Print status. \n  glBindFramebuffer(GL_FRAMEBUFFER, 0); \n} \n\n```", "```cpp\nvoid CubeTexture::RenderingBind() { \n  glBindFramebuffer(GL_FRAMEBUFFER, m_fbo); \n} \nvoid CubeTexture::RenderingUnbind() { \n  glBindFramebuffer(GL_FRAMEBUFFER, 0); // Render to screen. \n} \n\n```", "```cpp\nvoid CubeTexture::RenderToFace(unsigned int l_face) { \n  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, \n    GL_TEXTURE_CUBE_MAP_POSITIVE_X + l_face, m_textureID, 0); \n  Clear(); \n} \n\n```", "```cpp\nclass LightManager { \npublic: \n  ... \n  const std::string& AddCasterPrototype(const std::string& l_name, \n    std::unique_ptr<ShadowCasterPrototype> l_caster); \n  ShadowCaster* AddShadowCaster(const std::string& l_prototypeName); \n  ShadowCasterPrototype* GetPrototype(const std::string& l_name); \n  ... \nprivate: \n  ... \n  void DrawShadowMap(GLuint l_shadowShader, LightBase& l_light, \n    unsigned int l_texture); \n  ... \n  ShadowCasterPrototypes m_casterPrototypes; \n  ShadowCasters m_shadowCasters; \n  GL_Camera m_perspectiveCamera; \n  std::unique_ptr<CubeTexture> m_cubeTextures[LightsPerPass]; \n  ... \n}; \n\n```", "```cpp\nLightManager::LightManager(...) : ..., \n  m_perspectiveCamera({0.f, 0.f, 0.f}, 90.f, \n    CubeTexture::TextureWidth / CubeTexture::TextureHeight, \n    1.f, 200.f) \n{ \n  ... \n  for (auto i = 0; i < LightsPerPass; ++i) { \n    m_cubeTextures[i] = std::make_unique<CubeTexture>(); \n  } \n} \n\n```", "```cpp\nconst std::string& LightManager::AddCasterPrototype( \n  const std::string& l_name, \n  std::unique_ptr<ShadowCasterPrototype> l_caster) \n{ \n  auto itr = m_casterPrototypes.find(l_name); \n  if (itr != m_casterPrototypes.end()) { \n    l_caster.release(); return l_name; \n  } \n  for (auto& prototype : m_casterPrototypes) { \n    if (*prototype.second == *l_caster) { \n      l_caster.release(); return prototype.first; \n    } \n  } \n  m_window->GetRenderWindow()->setActive(true); \n  l_caster->UploadVertices(); \n  m_casterPrototypes.emplace(l_name, std::move(l_caster)); \n  return l_name; \n} \n\n```", "```cpp\nShadowCaster* LightManager::AddShadowCaster( \n  const std::string& l_prototypeName) \n{ \n  auto prototype = GetPrototype(l_prototypeName); \n  if (!prototype) { return nullptr; } \n  m_shadowCasters.emplace_back(); \n  auto& caster = m_shadowCasters.back(); \n  caster = std::make_unique<ShadowCaster>(); \n  caster->m_prototype = prototype; \n  return caster.get(); \n} \n\n```", "```cpp\nShadowCasterPrototype* LightManager::GetPrototype( \n  const std::string& l_name) \n{ \n  auto itr = m_casterPrototypes.find(l_name); \n  if (itr == m_casterPrototypes.end()) { return nullptr; } \n  return itr->second.get(); \n} \n\n```", "```cpp\nvoid LightManager::DrawShadowMap(GLuint l_shadowShader, \n  LightBase& l_light, unsigned int l_texture) \n{ \n  ... \n} \n\n```", "```cpp\nglEnable(GL_DEPTH_TEST); \nglEnable(GL_CULL_FACE); \nglCullFace(GL_FRONT); \n\n```", "```cpp\nglUseProgram(l_shadowShader); \nauto u_model = glGetUniformLocation(l_shadowShader, \"m_model\"); \nauto u_view = glGetUniformLocation(l_shadowShader, \"m_view\"); \nauto u_proj = glGetUniformLocation(l_shadowShader, \"m_proj\"); \nauto u_lightPos = glGetUniformLocation(l_shadowShader,\"lightPos\"); \nauto u_frustumFar = glGetUniformLocation(l_shadowShader, \n  \"frustumFar\"); \n\n```", "```cpp\nauto& texture = m_cubeTextures[l_texture]; \nauto l_pos = l_light.m_lightPos; \nm_perspectiveCamera.SetPosition({ l_pos.x, l_pos.z, l_pos.y }); \nglViewport( \n  0, 0, CubeTexture::TextureWidth, CubeTexture::TextureHeight); \ntexture->RenderingBind(); \nglUniform3f(u_lightPos, l_pos.x, l_pos.z, l_pos.y); \n\n```", "```cpp\nfor (auto face = 0; face < 6; ++face) { \n  texture->RenderToFace(face); \n  m_perspectiveCamera.SetForwardDir(CubeMapDirections[face]); \n  m_perspectiveCamera.SetUpDir(CubeMapUpDirections[face]); \n  m_perspectiveCamera.SetFrustumFar(l_light.m_radius); \n  m_perspectiveCamera.RecalculatePerspective(); \n  auto viewMat = m_perspectiveCamera.GetViewMatrix(); \n  auto& projMat = m_perspectiveCamera.GetProjectionMatrix(); \n  glUniformMatrix4fv(u_view, 1, GL_FALSE, &viewMat[0][0]); \n  glUniformMatrix4fv(u_proj, 1, GL_FALSE, &projMat[0][0]); \n  glUniform1f(u_frustumFar, m_perspectiveCamera.GetFrustumFar()); \n  for (auto& caster : m_shadowCasters) { \n    auto modelMat = caster->m_transform.GetModelMatrix(); \n    glUniformMatrix4fv(u_model, 1, GL_FALSE, &modelMat[0][0]); \n    caster->m_prototype->Draw(); \n  } \n} \n\n```", "```cpp\ntexture->RenderingUnbind(); \nglViewport( \n  0, 0, m_window->GetWindowSize().x, m_window->GetWindowSize().y); \nglDisable(GL_DEPTH_TEST); \nglDisable(GL_CULL_FACE); \nglCullFace(GL_BACK); \n\n```", "```cpp\nin vec3 position; \nuniform mat4 m_model; \nuniform mat4 m_view; \nuniform mat4 m_proj; \nuniform vec3 lightPos; \nuniform float frustumFar; \nout float distance; \n\nvoid main() { \n  vec4 worldCoords = m_model * vec4(position, 1.0); \n  float d = length(worldCoords.xyz - lightPos); \n  d /= frustumFar; \n  gl_Position = m_proj * m_view * worldCoords; \n  distance = d; \n} \n\n```", "```cpp\nin float distance; \n\nvoid main() { \n  gl_FragColor = vec4(distance, distance, distance, 1.0); \n} \n\n```", "```cpp\nclass GenericFBO { \npublic: \n  GenericFBO(const sf::Vector2u& l_size); \n  ~GenericFBO(); \n\n  void Create(); \n\n  void RenderingBind(GLuint l_texture); \n  void RenderingUnbind(); \nprivate: \n  sf::Vector2u m_size; \n  GLuint m_FBO; \n  GLuint m_RBO; \n}; \n\n```", "```cpp\nGenericFBO::GenericFBO(const sf::Vector2u& l_size) : \n  m_size(l_size), m_FBO(0), m_RBO(0) {} \n\nGenericFBO::~GenericFBO() { \n  if (m_FBO) { glDeleteFramebuffers(1, &m_FBO); } \n  if (m_RBO) { glDeleteRenderbuffers(1, &m_RBO); } \n} \n\n```", "```cpp\nvoid GenericFBO::Create() { \n  if (!m_FBO) { glCreateFramebuffers(1, &m_FBO); } \n  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); \n  if (!m_RBO) { glCreateRenderbuffers(1, &m_RBO); } \n  glBindRenderbuffer(GL_RENDERBUFFER, m_RBO); \n\n  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, \n    m_size.x, m_size.y); \n  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, \n    GL_RENDERBUFFER, m_RBO); \n  auto status = glCheckFramebufferStatus(GL_FRAMEBUFFER); \n  if (status != GL_FRAMEBUFFER_COMPLETE) { ... } // Print status. \n  glBindFramebuffer(GL_FRAMEBUFFER, 0); \n  glBindRenderbuffer(GL_RENDERBUFFER, 0); \n} \n\n```", "```cpp\nvoid GenericFBO::RenderingBind(GLuint l_texture) { \n  glBindFramebuffer(GL_FRAMEBUFFER, m_FBO); \n  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, \n    GL_TEXTURE_2D, l_texture, 0); \n} \n\nvoid GenericFBO::RenderingUnbind() { \n  glBindFramebuffer(GL_FRAMEBUFFER, 0); \n} \n\n```", "```cpp\nstruct BasicVertex { \n  glm::vec3 m_pos; \n  glm::vec2 m_tex; \n}; \n\n```", "```cpp\nclass BasicQuadPrimitive { \npublic: \n  BasicQuadPrimitive(); \n  ~BasicQuadPrimitive(); \n\n  void Create(); \n  void Bind(); \n  void Render(); \n  void Unbind(); \nprivate: \n  GLuint m_VAO; \n  GLuint m_VBO; \n  GLuint m_indices; \n}; \n\n```", "```cpp\nBasicQuadPrimitive::BasicQuadPrimitive() : m_VAO(0), \n  m_VBO(0), m_indices(0) {} \n\nBasicQuadPrimitive::~BasicQuadPrimitive() { \n  if (m_VAO) { glDeleteVertexArrays(1, &m_VAO); } \n  if (m_VBO) { glDeleteBuffers(1, &m_VBO); } \n  if (m_indices) { glDeleteBuffers(1, &m_indices); } \n} \n\n```", "```cpp\nvoid BasicQuadPrimitive::Create() { \n  glGenVertexArrays(1, &m_VAO); \n  glBindVertexArray(m_VAO); \n  glGenBuffers(1, &m_VBO); \n  glGenBuffers(1, &m_indices); \n\n  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); \n\n  BasicVertex vertices[4] = { \n    //    x    y    z        u    v \n    { { -1.f, 1.f, 0.f }, { 0.f, 1.f } }, // Top-left. \n    { { 1.f, 1.f, 0.f }, { 1.f, 1.f } },  // Top-right. \n    { { 1.f, -1.f, 0.f }, { 1.f, 0.f } }, // Bottom-right. \n    { { -1.f, -1.f, 0.f }, { 0.f, 0.f } } // Bottom-left. \n  }; \n\n  auto stride = sizeof(vertices[0]); \n  auto texCoordOffset = sizeof(vertices[0].m_pos); \n  glBufferData(GL_ARRAY_BUFFER, 4 * sizeof(vertices[0]), \n    &vertices[0], GL_STATIC_DRAW); \n  glEnableVertexAttribArray(0); \n  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, 0); \n  glEnableVertexAttribArray(1); \n  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, \n    (void*)texCoordOffset); \n\n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); \n  unsigned int indices[6] = { 0, 1, 2, 2, 3, 0 }; // CW! \n  glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), \n    &indices[0], GL_STATIC_DRAW); \n  Unbind(); \n} \n\n```", "```cpp\nvoid BasicQuadPrimitive::Bind() { \n  if (!m_VAO) { return; } \n  glBindVertexArray(m_VAO); \n  glBindBuffer(GL_ARRAY_BUFFER, m_VBO); \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_indices); \n} \n\nvoid BasicQuadPrimitive::Unbind() { \n  if (!m_VAO) { return; } \n  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); \n  glBindBuffer(GL_ARRAY_BUFFER, 0); \n  glBindVertexArray(0); \n} \n\n```", "```cpp\nvoid BasicQuadPrimitive::Render() { \n  glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); \n} \n\n```", "```cpp\nusing MaterialHandles = std::unordered_map< \n  MaterialMapType, unsigned int>; \nusing MaterialUniformNames = std::unordered_map< \n  MaterialMapType, std::string>; \n\n```", "```cpp\nclass LightManager { \n  ... \nprivate: \n  void GenerateMaterials(); \n  void Bind2DTextures(GLuint l_program, int l_pass); \n  void Unbind2DTextures(); \n  void SubmitLightUniforms(GLuint l_program, \n    unsigned int l_lightID, const LightBase& l_light); \n  ... \n  MaterialHandles m_materialHandles; \n  MaterialUniformNames m_materialNames; \n  //sf::VertexArray m_fullScreenQuad; \n  GenericFBO m_rendererFBO; \n  BasicQuadPrimitive m_fullScreenQuad; \n  ... \n}; \n\n```", "```cpp\nLightManager::LightManager(...) : ..., \n  m_rendererFBO(l_window->GetWindowSize()), ... \n{ \n  m_window->GetRenderWindow()->setActive(true); \n  GenerateMaterials(); \n  m_materialNames[MaterialMapType::Diffuse] = \"DiffuseMap\"; \n  m_materialNames[MaterialMapType::Normal] = \"NormalMap\"; \n  m_materialNames[MaterialMapType::Specular] = \"SpecularMap\"; \n  m_materialNames[MaterialMapType::Height] = \"HeightMap\"; \n  m_window->GetRenderWindow()->setActive(true); \n  m_rendererFBO.Create(); \n  m_window->GetRenderWindow()->setActive(true); \n  m_fullScreenQuad.Create(); \n  ... \n} \n\n```", "```cpp\nvoid LightManager::GenerateMaterials() { \n  auto windowSize = m_window->GetWindowSize(); \n  for (auto i = 0; i < \n    static_cast<int>(MaterialMapType::COUNT); ++i) \n  { \n    auto type = static_cast<MaterialMapType>(i); \n    auto pair = m_materialMaps.emplace(type, \n      std::move(std::make_unique<sf::RenderTexture>())); \n    auto& texture = pair.first->second; \n    texture->create(windowSize.x, windowSize.y); \n    m_materialHandles[type] = texture-> \n      getTexture().getNativeHandle(); \n  } \n} \n\n```", "```cpp\nvoid LightManager::Bind2DTextures(GLuint l_program, int l_pass) { \n  auto finishedTexture = m_window->GetRenderer()-> \n    GetFinishedTexture()->getTexture().getNativeHandle(); \n  auto lastPassHandle = (l_pass == 0 ? \n    m_materialHandles[MaterialMapType::Diffuse] : \n    finishedTexture); \n  m_window->GetRenderWindow()->setActive(true); \n  glActiveTexture(GL_TEXTURE0); \n  glBindTexture(GL_TEXTURE_2D, lastPassHandle); \n  glUniform1i(glGetUniformLocation(l_program, \"LastPass\"), 0); \n\n  for (int i = 0;i<static_cast<int>(MaterialMapType::COUNT);++i) { \n    auto type = static_cast<MaterialMapType>(i); \n    glActiveTexture(GL_TEXTURE1 + i); \n    glBindTexture(GL_TEXTURE_2D, m_materialMaps[type]-> \n      getTexture().getNativeHandle()); \n    auto uniform = glGetUniformLocation(l_program, \n      m_materialNames[type].c_str()); \n    glUniform1i(uniform, i + 1); \n  } \n} \n\n```", "```cpp\nvoid LightManager::Unbind2DTextures() { \n  for (int i = 0; i <= \n    static_cast<int>(MaterialMapType::COUNT); ++i) \n  { \n    glActiveTexture(GL_TEXTURE0 + i); \n    glBindTexture(GL_TEXTURE_2D, 0); \n  } \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  ... \n} \n\n```", "```cpp\n... // Inside the RenderScene() method. \nauto renderer = m_window->GetRenderer(); \nauto passes = static_cast<int>( \n  std::ceil(static_cast<float>(m_lights.size()) / LightsPerPass)); \nauto& beginning = m_lights.begin(); \nauto LightPassShaderHandle = renderer-> \n  GetShader(\"LightPass\")->getNativeHandle(); \nauto ShadowPassShaderHandle = renderer-> \n  GetShader(\"ShadowPass\")->getNativeHandle(); \nauto CurrentShaderHandle = (renderer->GetCurrentShader() ?  \n  renderer->GetCurrentShader()->getNativeHandle() : 0); \n\nauto window = m_window->GetRenderWindow(); \n\n```", "```cpp\n... // Inside the RenderScene() method. \nfor (int pass = 0; pass < passes; ++pass) { \n  auto& first = beginning + (pass * LightsPerPass); \n  auto LightCount = 0; \n  ... \n} \n\n```", "```cpp\n... // Inside the pass loop. \nfor (int lightID = 0; lightID < LightsPerPass; ++lightID) { \n  // Drawing shadow maps. \n  auto& light = first + lightID; \n  if (light == m_lights.end()) { break; } \n  window->setActive(true); \n  DrawShadowMap(ShadowPassShaderHandle, *light, lightID); \n  ++LightCount; \n} \n\n```", "```cpp\n... // Inside the pass loop. \nglUseProgram(LightPassShaderHandle); \nBind2DTextures(LightPassShaderHandle, pass); \nglUniform3f(glGetUniformLocation(LightPassShaderHandle, \n    \"AmbientLight\"), \n  m_ambientLight.m_lightColor.x, \n  m_ambientLight.m_lightColor.y, \n  m_ambientLight.m_lightColor.z); \nglUniform1i(glGetUniformLocation(LightPassShaderHandle, \n  \"LightCount\"), LightCount); \nglUniform1i(glGetUniformLocation(LightPassShaderHandle, \n  \"PassNumber\"), pass); \n\n```", "```cpp\n... // Inside the pass loop. \nauto BaseCubeMapUnit = static_cast<int>(MaterialMapType::COUNT)+1; \nfor (int lightID = 0; lightID < LightCount; ++lightID) { \n  auto& light = first + lightID; // Verified by previous loop. \n  SubmitLightUniforms(LightPassShaderHandle, lightID, *light); \n  // Bind the CUBE texture of the light. \n  m_cubeTextures[lightID]->SamplingBind(BaseCubeMapUnit +lightID); \n  auto ShadowMapName = \"ShadowMap[\"+std::to_string(lightID)+\"]\"; \n  glUniform1i(glGetUniformLocation(LightPassShaderHandle, \n    ShadowMapName.c_str()), BaseCubeMapUnit + lightID); \n} \n\n```", "```cpp\n... // Inside the pass loop. \nm_rendererFBO.RenderingBind(renderer->GetCurrentTexture()-> \n  getTexture().getNativeHandle()); \nm_fullScreenQuad.Bind(); \nm_fullScreenQuad.Render(); // This is where the magic happens! \nm_fullScreenQuad.Unbind(); \nm_rendererFBO.RenderingUnbind(); \nUnbind2DTextures(); \n\n```", "```cpp\n... // Inside the pass loop. \nfor (int lightID = 0; lightID < LightCount; ++lightID) { \n  m_cubeTextures[lightID]->SamplingUnbind( \n    BaseCubeMapUnit + lightID); \n} \n\n```", "```cpp\n... // Inside the pass loop. \nrenderer->SwapTextures(); \n\n```", "```cpp\n... // Right after the pass loop, inside RenderScene(). \nglUseProgram(CurrentShaderHandle); \nwindow->resetGLStates(); \nauto currentView = window->getView(); \nwindow->setView(window->getDefaultView()); \nrenderer->DrawBufferTexture(); \nwindow->setView(currentView); \n\n```", "```cpp\nvoid LightManager::SubmitLightUniforms(GLuint l_program, \n  unsigned int l_lightID, const LightBase& l_light) \n{ \n  auto window = m_window->GetRenderWindow(); \n  auto id = \"Lights[\" + std::to_string(l_lightID) + \"].\"; \n\n  sf::Vector2i screenPos = window->mapCoordsToPixel( \n    { l_light.m_lightPos.x, l_light.m_lightPos.y }, \n    window->getView()); \n  float y = static_cast<float>( \n    static_cast<int>(window->getSize().y) - screenPos.y); \n\n  glUniform3f(glGetUniformLocation(l_program, \n      (id + \"position\").c_str()), \n    screenPos.x, y, l_light.m_lightPos.z); \n  glUniform3f(glGetUniformLocation(l_program, \n      (id + \"color\").c_str()), \n    l_light.m_lightColor.x, \n    l_light.m_lightColor.y, \n    l_light.m_lightColor.z); \n  glUniform1f(glGetUniformLocation(l_program, \n    (id + \"radius\").c_str()), l_light.m_radius); \n  glUniform1f(glGetUniformLocation(l_program, \n    (id + \"falloff\").c_str()), l_light.m_falloff); \n  glUniform1f(glGetUniformLocation(l_program, \n      (id + \"specularExponent\").c_str()), \n    l_light.m_specularExponent); \n  glUniform1f(glGetUniformLocation(l_program, \n      (id + \"specularStrength\").c_str()), \n    l_light.m_specularStrength); \n} \n\n```", "```cpp\nin vec3 position; \nin vec2 texCoordIn; \nout vec2 texCoords; \nvoid main() \n{ \n  texCoords = texCoordIn; \n  gl_Position = vec4(position, 1.0); \n} \n\n```", "```cpp\nconst int MaxLights = 4; \nconst float LightHeightOffset = 16.0; \nin vec2 texCoords; \nuniform sampler2D LastPass; \nuniform sampler2D DiffuseMap; \nuniform sampler2D NormalMap; \nuniform sampler2D SpecularMap; \nuniform sampler2D HeightMap; \nuniform samplerCube ShadowMap[MaxLights]; \nuniform vec3 AmbientLight; \nuniform int LightCount; \nuniform int PassNumber; \n\n```", "```cpp\nvoid main() \n{ \n  vec4 pixel = texture2D(LastPass, texCoords); \n  vec4 diffusepixel = texture2D(DiffuseMap, texCoords); \n  vec4 normalpixel = texture2D(NormalMap, texCoords); \n  vec4 specularpixel = texture2D(SpecularMap, texCoords); \n  float pixelheight = texture2D(HeightMap, texCoords).r * 255.0; \n  vec3 PixelCoordinates = \n    vec3(gl_FragCoord.x, gl_FragCoord.y, pixelheight); \n  vec4 finalPixel = pixel; \n  ... \n  if(PassNumber == 0) { finalPixel *= vec4(AmbientLight, 1.0); } \n  for(int i = 0; i < LightCount; ++i){ \n    ... \n    float ShadowValue = CalculateShadow( \n      PixelCoordinates, Lights[i].position, i); \n    finalPixel += (diffusepixel * \n                  (vec4(Lights[i].color, 1.0) * attenuation) + \n                  vec4(specularReflection, 1.0)) \n      * normalDot * ShadowValue; \n  } \n  gl_FragColor = finalPixel; \n} \n\n```", "```cpp\nfloat CalculateShadow(vec3 fragment, vec3 light, int lightID) { \n  light.z += LightHeightOffset; \n  vec3 difference = fragment - light; \n  float currentDepth = length(difference); \n  difference.y *= -1.0; \n  float nearestDepth = texture(ShadowMap[lightID], \n    difference.xzy).r; \n  return (currentDepth > nearestDepth * Lights[lightID].radius \n    ? nearestDepth : 1.0); \n} \n\n```", "```cpp\nclass C_ShadowCaster : public C_Base { \npublic: \n  C_ShadowCaster() : C_Base(Component::ShadowCaster), \n    m_shadowCaster(nullptr) {} \n\n  void SetShadowCaster(ShadowCaster* l_caster) { \n    m_shadowCaster = l_caster; \n  } \n  void UpdateCaster(const glm::vec3& l_pos) { \n    m_shadowCaster->m_transform.SetPosition(l_pos); \n  } \n\n  void ReadIn(std::stringstream& l_stream) { \n    m_shadowPrimitive = std::make_unique<ShadowCasterPrototype>(); \n    for (auto i = 0; i < ShadowMeshVertices; ++i) { \n      l_stream >> m_shadowPrimitive->m_vertices[i].x >> \n      m_shadowPrimitive->m_vertices[i].y >> \n      m_shadowPrimitive->m_vertices[i].z; \n    } \n  } \n\n  std::unique_ptr<ShadowCasterPrototype> m_shadowPrimitive; \nprivate: \n  ShadowCaster* m_shadowCaster; \n}; \n\n```", "```cpp\nName Player \nAttributes 511 \n|Component|ID|Individual attributes| \n... \nComponent 8 -0.5 0.0 0.5 -0.5 0.0 -0.5 0.5 0.0 -0.5 ... \n\n```", "```cpp\nS_Shadow::S_Shadow(SystemManager* l_systemMgr) \n  : S_Base(System::Shadow, l_systemMgr), \n  m_lightManager(nullptr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::ShadowCaster); \n  m_requiredComponents.push_back(req); \n  req.Clear(); \n} \n\n```", "```cpp\nvoid S_Shadow::Update(float l_dT) { \n  if (!m_lightManager) { return; } \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for (auto &entity : m_entities) { \n    auto position = entities->GetComponent<C_Position>( \n      entity, Component::Position); \n    auto caster = entities->GetComponent<C_ShadowCaster>( \n      entity, Component::ShadowCaster); \n    float height = static_cast<float>( \n      (position->GetElevation() * Sheet::Tile_Size) - \n        Sheet::Tile_Size); \n    caster->UpdateCaster({ \n      position->GetPosition().x, \n      height, \n      position->GetPosition().y - 8.f }); \n  } \n} \n\n```", "```cpp\nvoid S_Shadow::OnEntityAdd(const EntityId& l_entity) { \n  auto component = m_systemManager->GetEntityManager()-> \n   GetComponent<C_ShadowCaster>(l_entity,Component::ShadowCaster); \n  if (!component) { return; } \n  std::string entityType; \n  if (!m_systemManager->GetEntityManager()-> \n    GetEntityType(l_entity, entityType)) \n  { \n    ... // Error \n    return; \n  } \n\n  auto name = m_lightManager->AddCasterPrototype(\"Entity_\" + \n    entityType, std::move(component->m_shadowPrimitive)); \n  auto caster = m_lightManager->AddShadowCaster(name); \n  if (!caster) { return; } // Error \n  component->SetShadowCaster(caster); \n  caster->m_transform.SetScale({ 16.f, 16.f, 16.f }); \n} \n\n```", "```cpp\nvoid Game::SetUpECS() { \n  ... \n  m_entityManager->AddComponentType<C_ShadowCaster> \n    (Component::ShadowCaster); \n  ... \n  m_systemManager->AddSystem<S_Shadow>(System::Shadow); \n  ... \n  m_systemManager->GetSystem<S_Shadow>(System::Shadow)-> \n    SetLightManager(m_lightManager.get()); \n} \n\n```"]