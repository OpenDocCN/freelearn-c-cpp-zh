- en: 'Integrating C++ and the Unreal Editor: Part II'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new editor module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new toolbar buttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new menu entries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new editor window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Asset type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom context menu entries for Assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new console commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting types with custom Details panels
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In game development, in addition to creating games, you'll often need to create
    tools for other developers to use that have been customized to fit the project
    that you're working on. In fact, this is often one of the more common entry-level
    game developer positions in the AAA game industry. In this chapter, we will learn
    how to implement custom editor windows and custom detail panels to inspect types
    that have been created by users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new editor module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipes all interact with editor mode-specific code and engine
    modules. As a result, it is considered good practice to create a new module that
    will only be loaded when the engine is running in editor mode, so that we can
    place all our editor-only code inside it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your project''s `.uproject` file in a text editor such as Notepad or Notepad++.
    You can find the file inside your project folder, and it should look similar to
    what''s shown in the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4051c5c-b769-4866-98f4-39af0c8018de.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Add the bold section of text in the following snippet to the file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note the comma after the first module before the second set of curly braces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Source` folder, create a new folder using the same name as you specified
    in your `uproject` file (in this instance, `"Chapter_10Editor"`):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc3ee6b5-e94d-4330-a120-4b2f707d6edc.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Open up the `Chapter_10Editor.Target.cs` file and update it to the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside this new folder, create a blank `.txt` file and rename it to `Chapter_10Editor.Build.cs`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f0a6cba-aeb7-420e-9d08-cec2aed2029e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Insert the following into the file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still inside of the `Chapter10_Editor` folder, create a new file called `Chapter_10Editor.h` and
    add the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, create a new source file called `Chapter_10Editor.cpp`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, close Visual Studio if you have it open. Then, right-click on the `.uproject` file
    and select Generate Visual Studio Project files:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71edf948-dcce-4da8-a1a3-e8069a117f83.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'You should see a small window launch, display a progress bar, and then close:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/766c4e4b-557f-4785-8c01-ae82430cadc7.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'You can now launch Visual Studio, verify that your new module is visible in
    the IDE, and compile your project successfully:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/770bd61f-d16a-49f2-9c81-f2f1d3be25d3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: The module is now ready for the next set of recipes.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code changes made in this editor module won't support hot-reloading in the same
    way that code in runtime modules does. If you get a compilation error that mentions
    changes to generated header files, simply close the editor and rebuild it from
    within your IDE instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal projects use the `.uproject` file format to specify a number of different
    pieces of information about the project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This information is used to inform the Header and Build tools about the modules
    that comprise this project, and is used for code generation and `makefile` creation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The file uses JSON-style formatting.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'These include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The engine version that the project should be opened in
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of modules that are used in the project
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of module declarations
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these module declarations contain the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The name of the module.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of module—is it an editor module (only runs in editor builds, has access
    to editor-only classes) or a runtime module (runs in both editor and Shipping
    builds)?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loading phase of the module—modules can be loaded at different points during
    program startup. This value specifies the point at which the module should be
    loaded, for example, if there are dependencies in other modules that should be
    loaded first.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of dependencies for the module. These are essential modules that contain
    exported functions or classes that the module relies on.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a new module to the `uproject file`. The module's name is `Chapter_10Editor` (Conventionally, `Editor` should
    be appended to the main game module for an editor module).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This module is marked as an editor module, and is set to load after the baseline
    engine so that it can use the classes that have been declared in Engine code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Our module's dependencies are left at the default values for now.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: With the `uproject` file altered to contain our new module, we need a build
    script for it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Build scripts are written in C#, and take the name `<ModuleName>.Build.cs`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: C#, unlike C++, doesn't use a separate header file and implementation – it's
    all there in the one `.cs` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: We want to access the classes that have been declared in the `UnrealBuildTool` module,
    so we include a `using` statement to indicate that we want to access that namespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We create a `public` class with the same name as our module, which inherits
    from `ModuleRules`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Inside our constructor, we add a number of modules to the dependencies of this
    module. There are both private dependencies and public dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: According to the code of the `ModuleRules` class, public dependencies are modules
    that your module's public header files depend on. Private dependencies are modules
    that the private code depends on. Anything used in both public headers and private
    code should go into the `PublicDependencyModuleNames` array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that our `PublicDependencyModuleNames` array contains our main game
    module. This is because some recipes in this chapter will extend the editor to
    better support the classes that are defined within our main game module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've told the build system that we have a new module to build through
    the project file, and we've specified how to build the module with the build script,
    we need to create the C++ class that is our actual module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We create a header file that includes the Engine header, the `ModuleManager` header,
    and the `UnrealEd` header.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We include `ModuleManager` because it defines `IModuleInterface`, the class
    that our module will inherit from.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: We also include `UnrealEd` because we're writing an editor module that will
    need to access the editor functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The class we declare inherits from `IModuleInterface`, and takes its name from
    the usual prefix, `F`, followed by the module name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `.cpp` file, we include our module's header, and then use the `IMPLEMENT_GAME_MODULE` macro.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`IMPLEMENT_GAME_MODULE` declares an exported C function, `InitializeModule()`,
    which returns an instance of our new module class.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: This means that Unreal can simply call `InitializeModule()` on any library that
    exports it to retrieve a reference to the actual module implementation without
    needing to know what class it is.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Having added our new module, we now need to rebuild our Visual Studio solution,
    so we close Visual Studio and then regenerate the project files using the context
    menu.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: With the project rebuilt, the new module will be visible in Visual Studio, and
    we can add code to it as usual.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Creating new toolbar buttons
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created a custom tool or window for display within the editor, you
    probably need some way to let the user make it appear. The easiest way to do this
    is to create a toolbar customization that adds a new toolbar button, and have
    it display your window when clicked. Create a new engine module by following the
    previous recipe, as we'll need it to initialize our toolbar customization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of the `Chapter_10Editor` folder, create a new header file, `CookbookCommands.h`,
    and insert the following class declaration:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the new class by placing the following in the `.cpp` file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will need to update our module class (`Chapter_10Editor.h`) to the
    following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Be sure to `#include` the header file for your command class as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement `StartupModule` and `ShutdownModule`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Regenerate your project piles if needed, compile your project from Visual Studio
    and start the editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that there''s a new button on the toolbar in the main level editor,
    which can be clicked on to open a new window:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f9e599c-aee8-4438-a084-5350a219f1ea.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal's editor UI is based on the concept of commands. Commands are a design
    pattern that allows looser coupling between the UI and the actions that it needs
    to perform.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To create a class that contains a set of commands, it is necessary to inherit
    from `TCommands`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`TCommands` is a template class that leverages the **Curiously Recurring Template
    Pattern** (**CRTP**). The CRTP is used commonly throughout Slate UI code as a
    means of creating compile-time polymorphism.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initializer list for `FCookbookCommands` constructor, we invoke the
    parent class constructor, passing in a number of parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the name of the command set, and is a simple `FName`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is a tooltip/human readable string, and, as such, uses `FText` so
    that it can support localization if necessary.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's a parent group of commands, the third parameter contains the name
    of the group. Otherwise, it contains `NAME_None`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final parameter for the constructor is the Slate Style set that contains
    any command icons that the command set will be using.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RegisterCommands()` function allows TCommands-derived classes to create
    any command objects that they require. The resulting `FUICommandInfo` instances
    that are returned from that function are stored inside the `Commands` class as
    members so that UI elements or functions can be bound to the commands.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This is why we have the member variable `TSharedPtr<FUICommandInfo> MyButton`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation for the class, we simply need to create our commands in `RegisterCommands`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `UI_COMMAND` macro that was used to create an instance of `FUICommandInfo` expects
    a localization namespace to be defined, even if it is just an empty default namespace.
    As a result, we need to enclose our `UI_COMMAND` calls with `#defines` to set
    a valid value for `LOCTEXT_NAMESPACE`, even if we don't intend to use localization.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual `UI_COMMAND` macro takes a number of parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the variable to store the `FUICommandInfo` in
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is a human-readable name for the command
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is a description for the command
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is `EUserInterfaceActionType`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enumeration essentially specifies what sort of button is being created.
    It supports `Button`, `ToggleButton`, `RadioButton`, and `Check` as valid types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Buttons are simple generic buttons. A toggle button stores on and off states.
    The radio button is similar to a toggle, but is grouped with other radio buttons,
    and only one can be enabled at a time. Lastly, the checkbox displays a read-only
    checkbox that's adjacent to the button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The last parameter for `UI_COMMAND` is the input chord, or the combination of
    keys that are required to activate the command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is primarily useful for defining key combinations for hotkeys
    linked to the command in question, rather than buttons. As a result, we use an
    empty `InputGesture`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: So, we now have a set of commands, but we haven't told the engine we want to add
    the set to the commands that show on the toolbar. We also haven't set up what
    actually happens when the button is clicked. To do this, we need to perform some
    initialization when our module begins, so we place some code into the `StartupModule`/`ShutdownModule` functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Inside `StartupModule`, we call the static `Register` function on the commands
    class that we defined earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We then create a shared pointer to a list of commands using the `MakeShareable` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In the command list, we use `MapAction` to create a mapping, or association,
    between the `UICommandInfo` object, which we set as a member of the `FCookbookCommands`,
    and the actual function we want to execute when the command is invoked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that we don't explicitly set anything regarding what could be used
    to invoke the command here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To perform this mapping, we call the `MapAction` function. The first parameter
    to `MapAction` is a `FUICommandInfo` object, which we can retrieve from `FCookbookCommands` by
    using its static `Get()` method to retrieve the instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`FCookbookCommands` is implemented as a singleton – a class with a single instance
    that exists throughout the application. You''ll see the pattern in most places
    – there''s a static `Get()` method available in the engine.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter of the `MapAction` function is a delegate bound to the
    function to be invoked when the command is executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Because `Chapter_10EditorModule` is a raw C++ class rather than a `UObject`,
    and we want to invoke a member function rather than a `static` function, we use `CreateRaw` to
    create a new delegate that's bound to a raw C++ member function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateRaw` expects a pointer to the object instance, and a function reference
    to the function to invoke on that pointer.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter for `MapAction` is a delegate to call to test if the action
    can be executed. Because we want the command to be executable all the time, we
    can use a simple predefined delegate that always returns `true`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With an association created between our command and the action it should call,
    we now need to actually tell the extension system that we want to add new commands
    to the toolbar.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We can do this via the `FExtender` class, which can be used to extend menus,
    context menus, or toolbars.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We initially create an instance of `FExtender` as a shared pointer so that our
    extensions are uninitialized when the module is shut down.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: We then call `AddToolBarExtension` on our new extender, storing the results
    in a shared pointer so that we can remove it on module uninitialization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: First argument of `AddToolBarExtension` is the name of the extension point where
    we want to add our extension.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: To find where we want to place our extension, we first need to turn on the display
    of extension points within the editor UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open Editor Preferences in the Edit menu within the editor:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/733efb6c-4df7-4663-b51c-2629dabb48c2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Open General | Miscellaneous and select Display UIExtension Points:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7875429-2beb-4350-8952-b13d6b5f419d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Restart the editor, and you should see green text overlaid on the Editor UI,
    as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cd351fc-a334-42c3-8155-24fa0772578c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Green text overlaying the Editor UI
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The green text indicates `UIExtensionPoint`, and the text's value is the string
    we should provide to the `AddToolBarExtension` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We're going to add our extension to the Compile extension point in this recipe,
    but of course, you could use any other extension point you wish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that adding a toolbar extension to a menu extension point
    will fail silently, and vice versa.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter to `AddToolBarExtension` is a location anchor relative
    to the extension point that's specified. We've selected `FExtensionHook::Before`,
    so our icon will be displayed before the compile point.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The next parameter is our command list that contains mapped actions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last parameter is a delegate that is responsible for actually adding
    UI controls to the toolbar at the extension point and the anchor that we specified
    earlier.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The delegate is bound to a function that has the form void (`*func`) (`FToolBarBuilder` and `builder`).
    In this instance, it is a function called `AddToolbarExtension`, which is defined
    in our module class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: When the function is invoked, calling commands on the `builder` that adds UI
    elements will apply those elements to the location in the UI we specified.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to load the level editor module within this function so that
    we can add our extender to the main toolbar within the level editor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we can use `ModuleManager` to load a module and return a reference
    to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: With that reference in hand, we can get the Toolbar Extensibility Manager for
    the module, and tell it to add our Extender.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: While this may seem cumbersome at first, the intention is to allow you to apply
    the same toolbar extension to multiple toolbars in different modules, if you would
    like to create a consistent UI layout between different editor windows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The counterpart to initializing our extension, of course, is removing it when
    our module is unloaded. To do that, we remove our extension from the extender,
    then null the shared pointers for both Extender and extension, thus reclaiming
    their memory allocation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The `AddToolBarExtension` function within the editor module is the one that
    is responsible for actually adding UI elements to the toolbar that can invoke
    our commands.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: It does this by calling functions on the `FToolBarBuilder` instance that's passed
    in as a function parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: First, we retrieve an appropriate icon for our new toolbar button using the `FSlateIcon` constructor.
    Then, with the icon loaded, we invoke `AddToolBarButton` on the `builder` instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`AddToolbarButton` has a number of parameters. The first parameter is the command
    to bind to – you''ll notice it''s the same `MyButton` member that we accessed
    earlier when binding the action to the command. The second parameter is an override
    for the extension hook we specified earlier, but we don''t want to override that,
    so we can use `NAME_None`. The third parameter is a label override for the new
    button that we create. Parameter four is a tooltip for the new button. The second
    to last parameter is the button''s icon, and the last parameter is a name that''s
    used to refer to this button element for highlighting support if you wish to use
    the in-editor tutorial framework.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating new menu entries
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflow for creating new menu entries is almost identical to that for creating
    new toolbar buttons, so this recipe will build on the previous one and show you
    how to add the command created therein to a menu rather than a toolbar.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new function inside of the `FChapter_10EditorModule` class, which
    is in `Chapter10_Editor.h`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the implementation file (`Chapter_10Editor.cpp`), find the following code
    within the `StartupModule` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replace the preceding code with the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile your code and launch the editor.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that you now have a menu entry under the Window menu that displays the Cookbook window
    when clicked. If you followed the preceding recipe, you''ll also see the green
    text listing the UI extension points, including the one we used in this recipe
    (LevelEditor):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23b9b8b0-5d3a-40ba-9ba8-cc176d0f1b58.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll note that `ToolbarExtender` is of type `FExtender` rather than `FToolbarExtender` or `FMenuExtender`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: By using a generic `FExtender` class rather than a specific subclass, the framework
    allows you to create a series of command-function mappings that can be used on
    either menus or toolbars. The delegate that actually adds the UI controls (in
    this instance, `AddMenuExtension`) can link those controls to a subset of commands
    from your `FExtender`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This way, you don't need to have different `TCommands` classes for different
    types of extensions, and you can place the commands into a single central class
    regardless of where those commands are invoked from the UI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the only changes that are required are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Swapping calls to `AddToolBarExtension` with `AddMenuExtension`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function that can be bound to `FMenuExtensionDelegate` rather than `FToolbarExtensionDelegate`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the extender to a Menu Extensibility Manager rather than a Toolbar Extensibility
    Manager
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new editor window
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom editor windows are useful when you have a new tool with user-configurable
    settings, or want to display some information to people using your customized
    editor. Ensure that you have have an editor module by following the recipe earlier
    in this chapter before you start. Read through either the *Creating new menu entries* or *Creating
    new toolbar buttons* recipes so that you can create a button within the editor
    that will launch our new window.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside your command''s bound function (in our case, the `MyButton_Clicked` function
    in the `FChapter_10EditorModule` class that''s found in `Chapter_10Editor.h`),
    add the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we removed the `;` at the end of the line stating `.SupportsMinimize(false)`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Compile your code and launch the editor.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you activate the command you created, either by selecting the custom menu
    option or the toolbar option that you added, you should see that the window has
    been displayed with some centered text in the middle:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e289ce2-a243-402b-9d35-319f0b8f2801.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your new editor window won't display itself, and so, at the start of this recipe,
    it is mentioned that you should have implemented a custom menu or toolbar button
    or a console command that we can use to trigger the display of our new window.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: All of Slate's widgets are usually interacted with in the form of `TSharedRef<
    >` or `TSharedPtr< >`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The `SNew()` function returns a `TSharedRef` that's been templated on the requested
    widget class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, Slate widgets have a number of functions that they
    implement, which all return the object that the function was invoked on. This
    allows for method chaining to be used to configure the object at creation time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This is what allows for the Slate syntax of `<Widget>.Property(Value).Property(Value)`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The properties that are set on the widget in this recipe are the window title,
    the window size, and whether the window can be maximized and minimized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Once all the requisite properties on a widget have been set, the bracket operators
    (`[]`) can be used to specify the content to be placed inside the widget, for
    example, a picture or label inside a button.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`SWindow` is a top-level widget with only one slot for child widgets, so we
    don''t need to add a slot for it ourselves. We place content into that slot by
    creating it inside the pair of brackets.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The content we create is `SVerticalBox`, which is a widget that can have an
    arbitrary number of slots for child widgets that are displayed in a vertical list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: For each widget we want to place into the vertical list, we need to create a **slot**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is to use the overloaded `+` operator and the `SVerticalBox::Slot()` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`Slot()` returns a widget like any other, so we can set properties on it like
    we did on our `SWindow`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This recipe centers the Slot's content on both horizontal and vertical axes
    using `HAlign` and `VAlign`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: A `Slot` has a single child widget, and it's created inside the `[]` operators,
    just like they are for `SWindow`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Slot` content, we create a text block with some custom text.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Our new `SWindow` now has its child widgets added, but it isn't being displayed
    yet because it hasn't been added to the window hierarchy.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The main frame module is used to check if we have a top-level editor window,
    and if it exists, our new window is added as a child.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If there's no top-level window to be added as a child to, then we use the Slate
    Application singleton to add our window without a parent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to see the hierarchy of the window we've created, you can
    use the Slate Widget Reflector, which can be accessed via Window | Developer Tools | Widget
    Reflector.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select Pick Painted Widget and hover your cursor over the text in the
    center of our custom window, you will be able to see the SWindow with our custom
    widgets added to its hierarchy:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0de07d76-1193-4fc5-ab7c-ed947a065605.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 11](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml), *Working with UE4
    APIs*, is all about UI, and will show you how to add additional elements to your
    new custom window'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Asset type
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your project, you might need to create a new custom Asset class,
    for example, an Asset to store conversation data in an RPG. To properly integrate
    these with Content Browser, you'll need to create a new Asset type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new C++ class based on `UObject` called `MyCustomAsset`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4eb0573-b97d-4470-90e8-3627adcf9c0d.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Open up the script and update the code of the `.h` file to the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create a class based on `UFactory`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e3e7c79e-3eeb-4cc4-a1e2-cd8e5371e942.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Give the script a name of `CustomAssetFactory` and press the Create Class button.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script in Visual Studio and update the `CustomAssetFactory.h` file
    to the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, switch over to the `CustomAssetFactory.cpp` file and implement the class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile your code and open the editor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click in Content Browser, from the Content folder and, under the Miscellaneous tab
    of the Create Advanced Asset section, you should see your new class and be able
    to create instances of your new custom type:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df0751b0-3259-47e3-b851-07fd9e1401ba.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first class is the actual object that can exist in the game at runtime.
    It's your texture, data file, or curve data – whatever you require.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this recipe, the simplest example is an asset that has an `FString` property
    to contain a name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The property is marked as `UPROPERTY` so that it remains in memory, and additionally
    marked as `EditAnywhere` so that it is editable on both the default object and
    on instances of it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The second class is `Factory`. Unreal uses the `Factory` design pattern to create
    instances of assets.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This means that there is a generic base `Factory` that uses virtual methods
    to declare the interface of object creation, and then `Factory` subclasses are
    responsible for creating the actual object in question.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is that the user-created subclass can potentially
    instantiate one of its own subclasses if required; it hides the implementation
    details regarding deciding which object to create away from the object requesting
    the creation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: With `UFactory` as our base class, we include the appropriate header.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The constructor is overridden, because there are a number of properties that
    we want to set for our new factory after the default constructor has run.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`bCreateNew` signifies that the factory is currently able to create a new instance
    of the object in question from scratch.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '`bEditAfterNew` indicates that we would like to edit the newly created object
    immediately after creation.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The `SupportedClass` variable is an instance of `UClass` containing reflection
    information about the type of object the factory will create.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The most significant function of our `UFactory` subclass is the actual factory
    method – `FactoryCreateNew`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '`FactoryCreateNew` is responsible for determining the type of object that should
    be created, and using `NewObject` to construct an instance of that type. It passes
    a number of parameters through to the `NewObject` call.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`InClass` is the class of object that will be constructed. `InParent` is the
    object that should be containing the new object that will be created. If this
    isn''t specified, the object is assumed to go into the transient package, which
    means that it won''t be automatically saved. `Name` is the name of the object
    to be created. `Flags` is a bitmask of creation flags that control things such
    as making the object visible outside of the package it is contained in.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Within `FactoryCreateNew`, decisions can be made regarding which subclass should
    be instantiated. Other initialization can also be performed; for example, if there
    are sub-objects that require manual instantiation or initialization, they can
    be added here.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'An example from the engine code for this function is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, there's a second call to `NewObject` to populate the `CameraInterpGroup` member
    of the `NewCamAnim` instance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Editing class properties in different places in the editor* recipe earlier
    in this chapter gives more context to the `EditAnywhere` property specifier
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom context menu entries for Assets
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Asset types commonly have special functions you wish to be able to perform
    on them. For example, converting images into sprites is an option you wouldn't
    want to add to any other Asset type. You can create custom context menu entries
    for specific Asset types to make those functions accessible to users.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the `Chapter_10Editor` folder, create two new files called `MyCustomAssetActions.h` and `MyCustomAssetActions.cpp`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to your project file and update your Visual Studio project. Once finished,
    open up the project in Visual Studio.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MyCustomAssetActions.h` and use the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open `MyCustomAssetActions.cpp` and add the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open up the `Chapter_10Editor.h` file and add the following property to the
    class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Don't forget to add the `#include` for `IAssetTypeActions.h`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Within your editor module (`Chapter_10Editor.cpp`), add the following code
    to the `StartupModule()` function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code inside the module''s `ShutdownModule()` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your project and launch the editor.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of your custom Asset inside the Content Browser by right-clicking
    and selecting Miscellaneous | My Custom Asset.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on your new asset to see our custom command in the context menu:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae13de6c-8e5e-4f38-8a0e-06ad7da16286.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Select the CustomAssetAction command to display a new blank editor window.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The base class for all asset type-specific context menu commands is `FAssetTypeActions_Base`,
    so we need to inherit from that class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`FAssetTypeActions_Base` is an abstract class that defines a number of virtual
    functions that allow us to extend the context menu. The interface that contains
    the original information for these virtual functions can be found in `IAssetTypeActions.h`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We also declare a function that we bind to our custom context menu entry.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )` is the
    function that''s called by the engine code to see if our `AssetTypeActions` class
    contains any actions that can be applied to the selected objects.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder&
    MenuBuilder)` is called if the `HasActions` function returns `true`. It calls
    functions on `MenuBuilder` to create the menu options for the actions that we
    provide.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetName()` returns the name of this class.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetSupportedClass()` returns an instance of `UClass` that
    our actions class supports.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetTypeColor()` returns the color associated with this
    class and actions.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetCategories()` returns a category that''s appropriate
    for the asset. This is used to change the category under which the actions show
    up in the context menu.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Our overridden implementation of `HasActions` simply returns `true` under all
    circumstances, and relies on filtering based on the results of `GetSupportedClass`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Inside the implementation of `GetActions`, we can call some functions on the `MenuBuilder` object
    that we are given as a function parameter. The `MenuBuilder` is passed as a reference,
    so any changes that are made by our function will persist after it returns.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`AddMenuEntry` has a number of parameters. The first parameter is the name
    of the action itself. This is the name that will be visible within the context
    menu. The name is an `FText` so that it can be localized should you wish. For
    the sake of simplicity, we construct `FText` from a string literal and don''t
    concern ourselves with multiple language support.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is also `FText`, which we construct by calling `FText::FromString`.
    This parameter is the text that's displayed in a tooltip if the user hovers over
    our command for more than a small period of time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The next parameter is `FSlateIcon` for the command, which is constructed from
    the `LevelEditor.ViewOptions` icon within the editor style set.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The last parameter to this function is an `FUIAction` instance. The `FUIAction` is
    a wrapper around a delegate binding, so we use `FExecuteAction::CreateRaw` to
    bind the command to the `MyCustomAsset_Clicked` function on this very instance
    of `FMyCustomAssetActions`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: This means that when the menu entry is clicked, our `MyCustomAssetContext_Clicked` function
    will be run.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of `GetName` returns the name of our Asset type. This string
    will be used on the thumbnail for our Asset if we don't set one ourselves, apart
    from being used in the title of the menu section that our custom Assets will be
    placed in.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: As you'd expect, the implementation of `GetSupportedClass` returns `UMyCustomAsset::StaticClass()`,
    as this is the Asset type we want our actions to operate on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`GetTypeColor()` returns the color that will be used for color coding in Content
    Browser – the color is used in the bar at the bottom of the asset thumbnail. I''ve
    used Emerald here, but any arbitrary color will work.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The real workhorse of this recipe is the `MyCustomAssetContext_Clicked()` function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that this function does is create a new instance of `SWindow`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`SWindow` is the Slate Window – a class from the Slate UI framework.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Slate Widgets are created using the `SNew` function, which returns an instance
    of the widget requested.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses the `builder` design pattern, which means that all of the functions
    that are **chained** after `SNew`, return a reference to the object that was being
    operated on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we create our new `SWindow`, then set the window title, its
    client size or area, and whether it can be maximized or minimized.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: With our new Window ready, we need to get a reference to the root window for
    the editor so that we can add our window to the hierarchy and get it displayed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We do this using the `IMainFrameModule` class. It's a module, so we use the Module
    Manager to load it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadModuleChecked` will assert if we can''t load the module, so we don''t
    need to check it.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: If the module was loaded, we check that we have a valid parent window. If that
    window is valid, then we use `FSlateApplication::AddWindowAsNativeChild` to add
    our window as a child of the top-level parent window.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: If we don't have a top-level parent, the function uses `AddWindow` to add the
    new window without parenting it to another window within the hierarchy.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have a class that will display custom actions on our custom Asset
    type, but what we actually need to do is tell the engine that it should ask our
    class to handle custom actions for the type. To do that, we need to register our
    class with the Asset Tools module.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The best way to do this is to register our class when our editor module is loaded,
    and unregister it when it is shut down.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we place our code into the `StartupModule` and `ShutdownModule` functions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Inside `StartupModule`, we load the Asset Tools module using Module Manager.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: With the module loaded, we create a new shared pointer that references an instance
    of our custom Asset actions class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do then is call `AssetModule.RegisterAssetTypeActions` and pass
    in an instance of our actions class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We then need to store a reference to that `Actions` instance so that we can
    unregister it later.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this recipe uses an array of all the created asset actions
    in case we want to add custom actions for other classes as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Within `ShutdownModule`, we again retrieve an instance of the Asset Tools module.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Using a range-based for loop, we iterate over the array of `Actions` instances
    that we populated earlier and call `UnregisterAssetTypeActions`, passing in our `Actions` class
    so it can be unregistered.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: With our class registered, the editor has been instructed to ask our registered
    class if it can handle assets that are right-clicked on.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: If the asset is of the Custom Asset class, then its `StaticClass` will match
    the one returned by `GetSupportedClass`. The editor will then call `GetActions`,
    and display the menu with the alterations made by our implementation of that function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: When the `CustomAssetAction` button is clicked, our custom `MyCustomAssetContext_Clicked` function
    will be called via the delegate that we created.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Creating new console commands
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During development, console commands can be very helpful by allowing a developer
    or tester to easily bypass content or disable the mechanics that are irrelevant
    to the current test being run. The most common way to implement this is via console
    commands, which can invoke functions during runtime. The console can be accessed
    using the tilde key (`~`) or the equivalent in the upper-left area of the alphanumeric
    zone of your keyboard:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc5a434d-25b5-4071-8ef7-bbbad9ac670c.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't already followed the *Creating a new editor module* recipe, do
    so, as this recipe will need a place to initialize and register the console command.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your editor module''s header file (`Chapter_10Editor.h`) and add the following
    code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code within the implementation of `StartupModule`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside `ShutdownModule`, add the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the following function in the editor module (`Chapter_10Editor.h`):'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile your code and launch the editor.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level, and then hit the tilde key to bring up the console.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `DisplayTestCommandWindow` and hit *Enter*:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/639eb05b-4ada-4f76-96ed-3e94259015d3.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'You should see our tutorial window open up:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f08671c4-aad4-4102-85ab-e0906f8a10ca.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Console commands are usually provided by a module. The best way to get the module
    to create the command when it is loaded is to place the code in the `StartupModule` method.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`IConsoleManager` is the module that contains the console functionality for
    the engine.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: As it is a sub-module of the core module, we don't need to add any additional
    information to the build scripts to link in additional modules.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: To call functions within the console manager, we need to get a reference to
    the current instance of `IConsoleManager` that is being used by the engine. To
    do so, we invoke the static `Get` function, which returns a reference to the module
    in a similar way to a singleton.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '`RegisterConsoleCommand` is the function that we can use to add a new console
    command and make it available in the console:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The parameters for the function are as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The actual console command that will be typed by users. It should not
    include spaces.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Help`: The tooltip that appears when users are looking at the command in the
    console. If your console command takes arguments, this is a good place to display
    usage information to users.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Command`: This is the actual function delegate that will be executed when
    the user types in the command.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flags`: These flags control the visibility of the command in a shipping build,
    and are also used for console variables. `ECVF_Default` specifies the default
    behavior wherein the command is visible, and has no restrictions on availability
    in a release build.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create an instance of the appropriate delegate, we use the `CreateRaw` static
    function on the `FConsoleCommand` delegate type. This lets us bind a raw C++ function
    to the delegate. The extra argument that is supplied after the function reference,
    the `FString``"Test Command Window"`, is a compile-time defined parameter that
    is passed to the delegate so that the end user doesn't have to specify the window
    name.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The second console command, `DisplayUserSpecifiedWindow`, is one that demonstrates
    the use of arguments with console commands.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference with this console command, aside from the different name
    for users to invoke it, is the use of `FConsoleCommandWithArgsDelegate` and the `CreateLambda` function
    on it in particular.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: This function allows us to bind an anonymous function to a delegate. It's particularly
    handy when you want to wrap or adapt a function so that its signature matches
    that of a particular delegate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: In our particular use case, the type of `FConsoleCommandWithArgsDelegate` specifies
    that the function should take a `const TArray` of `FStrings`. Our `DisplayWindow` function
    takes a single `FString` to specify the window title, so we need to somehow concatenate
    all the arguments of the console command into a single `FString` to use as our
    window title.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The lambda function allows us to do that before passing the `FString` onto the
    actual `DisplayWindow` function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the function, `[&](const TArray<FString>& Args)`, specifies
    that this lambda or anonymous function wants to capture the context of the declaring
    function by reference by including the ampersand in the capture options, `[&]`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the same as a normal function declaration, specifying that
    our lambda takes in `const Tarray`, which contains an FString as a parameter called `Args`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Within the lambda body, we create a new `FString` and concatenate the strings
    that make up our arguments together, adding a space between them to separate them
    so that we don't get a title without spaces.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: It uses a range-based `for` loop for brevity to loop over them all and perform
    the concatenation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Once they're all concatenated, we use the `this` pointer (captured by the `&` operator
    we mentioned earlier) to invoke `DisplayWindow` with our new title.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: For our module to remove the console command when it is unloaded, we need to
    maintain a reference to the console command object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we create a member variable in the module of type `IConsoleCommand*`,
    called `DisplayTestCommand`. When we execute the `RegisterConsoleCommand` function,
    it returns a pointer to the console command object that we can use as a handle
    later.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to enable or disable console commands at runtime based on gameplay
    or other factors.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Within `ShutdownModule`, we check to see if `DisplayTestCommand` refers to a
    valid console command object. If it does, we get a reference to the `IConsoleManager` object
    and call `UnregisterConsoleCommand`, passing in the pointer that we stored earlier
    in our call to `RegisterConsoleCommand`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The call to `UnregisterConsoleCommand` deletes the `IConsoleCommand` instance
    via the passed-in pointer, so we don't need to `deallocate` the memory ourselves
    – we just reset `DisplayTestCommand` to `nullptr` so that we can be sure that
    the old pointer doesn't dangle.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The `DisplayWindow` function takes in the window title as an `FString` parameter.
    This allows us to either use a console command that takes arguments to specify
    the title, or a console command that uses payload parameters to hard-code the
    title for other commands.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The function itself uses a function called `SNew()` to allocate and create an `SWindow` object.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`SWindow` is a Slate Window, a top-level window that uses the Slate UI framework.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses the `Builder` design pattern to allow for easy configuration of the
    new window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The `Title`, `ClientSize`, `SupportsMaximize`, and `SupportsMinimize` functions
    that are used here are all member functions of `SWindow`, and they return a reference
    to an `SWindow` (usually, the same object that the method was invoked on, but
    sometimes, a new object is constructed with the new configuration).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The fact that all these member methods return a reference to the configured
    object allows us to chain these method invocations together to create the desired
    object in the right configuration.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The functions used in `DisplayWindow` create a new top-level Window that has
    a title based on the function parameter. It is 800 x 400 pixels wide, and cannot
    be maximized or minimized.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: With our new Window created, we retrieve a reference to the main application
    frame module. If the top-level window for the editor exists and is valid, we add
    our new window instance as a child of that top-level window.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we retrieve a reference to the Slate interface and call `AddWindowAsNativeChild` to
    insert our window in the hierarchy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: If there isn't a valid top-level window, we don't need to add our new window
    as a child of anything, so we can simply call `AddWindow` and pass in our new
    window instance.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling
    Events and Delegates*, to learn more about delegates. It explains payload variables
    in greater detail.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Slate, refer to [Chapter 11](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml),
    *Working with UE4 APIs*.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the Blueprint system, we can use instances of our `MyCustomAsset` class
    as variables, provided we mark that class as a `BlueprintType` in its `UCLASS` macro.
    However, by default, our new asset is simply treated as a `UObject`, and we can''t
    access any of its members:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71c51dd0-1db5-4ab5-9c9e-45a433e1f2fd.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: 'For some types of assets, we might wish to enable in-line editing of literal
    values in the same way that classes such as `FVector` support the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2f07c2a-77ee-4333-aec6-47facbe0b76f.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: To enable this, we need to use a **Graph Pin** visualizer. This recipe will
    show you how to enable in-line editing of an arbitrary type using a custom widget
    defined by you.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will update the `MyCustomAsset` class to be editable in Blueprints
    and reflect what we''ll be doing in this recipe. Go to `MyCustomAsset.h` and update
    it to the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the `Chapter_10Editor` folder, create a new file called `MyCustomAssetPinFactory.h` .
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the header, add the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create another header file called `SGraphPinCustomAsset.h`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement `SGraphPinCustomAsset` by creating the `.cpp` file:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Regenerate your Visual Studio project.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `#include "MyCustomAssetPinFactory.h"` to the `Chapter_10Editor.h` module
    implementation file.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member to the editor module class (`FChapter_10EditorModule`):'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open `Chapter_10Editor.cpp` and then add the following to `StartupModule()`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also add the following code to `ShutdownModule()`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Compile your code and launch the editor.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Function inside of the Level Blueprint by clicking on the plus
    symbol beside Functions within the My Blueprint panel:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9415a2e-d1eb-406e-b064-ae473029c34d.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: 'Add an input parameter:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9209b56-9fbb-400f-b97a-42fa2ba9a246.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: 'Set its type to `MyCustomAsset` (Object Reference):'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5d2f5e2-1f18-45ea-b6bd-31ee1db119c9.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: 'In the Level Blueprint''s Event Graph, place an instance of your new function
    and verify that the input pin now has a custom visualizer in the form of a color
    picker:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/779d7694-622f-4cd8-94ec-acdf6fffbc5c.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: Newly added color picker visualizer
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing how objects appear as literal values on Blueprint pins is done using
    the `FGraphPanelPinFactory` class.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'This class defines a single virtual function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function of `CreatePin`, as the name implies, is to create a new visual
    representation of the graph pin.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: It receives a `UEdGraphPin` instance. `UEdGraphPin` contains information about
    the object that the pin represents so that our factory class can make an informed
    decision regarding which visual representation we should be displaying.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Within our implementation of the function, we check that the pin's type is our
    custom class.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: We do this by looking at the `PinSubCategoryObject` property, which contains
    a `UClass`, and comparing it to the `UClass` associated with our custom asset
    class.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: If the pin's type meets our conditions, we return a new shared pointer to a
    Slate Widget, which is the visual representation of our object.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: If the pin is of the wrong type, we return a null pointer to indicate a failed
    state.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The next class, `SGraphPinCustomAsset`, is the Slate Widget class, which is
    a visual representation of our object as a literal.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: It inherits from `SGraphPin`, the base class for all graph pins.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The `SGraphPinCustomAsset` class has a `Construct` function, which is called
    when the widget is created.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: It also implements some functions from the parent class: `GetPinColor()` and `GetDefaultValueWidget()`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The last function that is defined is `ColorPicked`, a handler for when a user
    selects a color in our custom pin.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of our custom class, we initialize our custom pin by calling
    the default implementation of `Construct`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The role of `GetDefaultValueWidget` is to actually create the widget that is
    the custom representation of our class, and return it to the engine code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, it creates a new `SColorPicker` instance – we want the
    user to be able to select a color and store the hex-based representation of that
    color inside the `FString` property in our custom class.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: This `SColorPicker` instance has a property called `OnColorCommitted` – this
    is a slate event that can be assigned to a function on an object instance.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Before returning our new `SColorPicker`, we link `OnColorCommitted` to the `ColorPicked` function
    on this current object so that it will be called if the user selects a new color.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorPicked` function receives the selected color as an input parameter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Because this widget is used when there's no object connected to the pin we are
    associated with, we can't simply set the property on the associated object to
    the desired color string.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a new instance of our custom asset class, and we do that by
    using the `NewObject` template function.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: This function behaves similarly to the `SpawnActor` function we discussed in
    other chapters, and initializes a new instance of the specified class before returning
    a pointer to it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: With a new instance in hand, we can set its `ColorName` property. `FLinearColors` can
    be converted into `FColor` objects, which define a `ToHex()` function that returns
    an `FString` with the hexadecimal representation of the color that was selected
    on the new widget.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to actually place our new object instance into the graph so
    that it will be referenced when the graph is executed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we need to access the graph pin object that we represent, and
    use the `GetSchema` function. This function returns the Schema for the graph that
    owns the node that contains our pin.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The Schema contains the actual values that correspond to graph pins, and is
    a key element during graph evaluation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have access to the Schema, we can set the default value for the
    pin that our widget represents. This value will be used during graph evaluation
    if the pin isn't connected to another pin, and acts like a default value that's
    provided during a function definition in C++.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: As with all the extensions we've made in this chapter, there has to be some
    sort of initialization or registration to tell the engine to defer to our custom
    implementation before using its default inbuilt representation.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to add a new member to our editor module to store our `PinFactory` class
    instance.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: During `StartupModule`, we create a new shared pointer that references an instance
    of our `PinFactory` class.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: We store it inside the editor module's member so that it can be unregistered
    later. Then, we call `FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)` to
    tell the engine to use our `PinFactory` to create the visual representation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: During `ShutdownModule`, we unregister the pin factory using `UnregisterVisualPinFactory`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we delete our old `PinFactory` instance by calling `Reset()` on the
    shared pointer that contains it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting types with custom Details panels
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `UObject`-derived UAssets open in the generic property editor.
    It looks as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cd21451-0090-40c5-b897-5525655f98ee.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
- en: However, at times, you may wish for custom widgets so that you can edit the
    properties on your class. To facilitate this, Unreal supports **Details Customization**,
    which is the focus of this recipe.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the `Chapter_10Editor` folder, create two new files called `MyCustomAssetDetailsCustomization.h` and `MyCustomAssetDetailsCustomization.cpp`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to your project file and update your Visual Studio project. Once finished,
    open up the project in Visual Studio.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `#pragma` and `#includes` to the header (`MyCustomAssetDetailsCustomization.h`):'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define our customization class, as follows:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Below that, define the following additional class:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the implementation file, add the following includes at the top of the file:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Afterwards, create an implementation for `CustomizeDetails`:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, create a definition for `ColorPicked`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Beneath all of the scripts in `MyCustomAssetDetailsCustomization.cpp`, add
    the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our editor module source file (`Chapter_10Editor.cpp`), add the following
    to your `#includes` in the `Chapter_10Editor.cpp` file:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following to the implementation of `StartupModule`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following to `ShutdownModule`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compile your code and launch the editor. Create a new instance of `MyCustomAsset` via
    the Content Browser.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on it to verify that the default editor that comes up now shows
    your custom layout:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/27a2b2cf-7c4b-45ba-a188-6e3894e6c8e3.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Details Customization is performed through the `IDetailCustomization` interface,
    which developers can inherit when defining a class that customizes the way assets
    of a certain class are displayed.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'The main function that `IDetailCustomization` uses to allow for this process
    to occur is as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Within our implementation of this function, we use methods on `DetailBuilder` that
    are passed in as parameters to get an array of all selected objects. The loop
    then scans those to ensure that at least one selected object is of the correct
    type.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the representation of a class is done by calling methods on the `DetailBuilder` object.
    We create a new category for our details view by using the `EditCategory` function.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `EditCategory` function is the name of the category
    we are going to manipulate.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is optional, and contains a potentially localized display
    name for the category.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is the priority of the category. A higher priority means
    it is displayed further up the list.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '`EditCategory` returns a reference to the category itself as `CategoryBuilder`,
    allowing us to chain additional method calls onto an invocation of `EditCategory`.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we call `AddCustomRow()` on `CategoryBuilder`, which adds a new
    key-value pair to be displayed in the category.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Using the Slate syntax, we then specify that the row will contain a Vertical
    Box with a single center-aligned slot.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Inside the slot, we create a color picker control and bind its `OnColorCommitted` delegate
    to our local `ColorPicked` event handler.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this requires us to define and implement `ColourPicked`. It has
    the following signature:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Inside the implementation of `ColorPicked`, we check to see if one of our selected
    assets was of the correct type, because, if at least one selected asset was correct,
    then `MyAsset` will be populated with a valid value.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ColorPicked`的实现中，我们检查是否我们选择的资产中有一个是正确的类型，因为如果至少有一个选定的资产是正确的，那么`MyAsset`将被填充为一个有效的值。
- en: Assuming we have a valid asset, we set the `ColorName` property to the hex string
    value corresponding to the color that was selected by the user.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个有效的资产，我们将`ColorName`属性设置为用户所选颜色的十六进制字符串值。
