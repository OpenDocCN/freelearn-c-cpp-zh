- en: 'Integrating C++ and the Unreal Editor: Part II'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 C++ 和 Unreal 编辑器：第二部分
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a new editor module
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器模块
- en: Creating new toolbar buttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的工具栏按钮
- en: Creating new menu entries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的菜单条目
- en: Creating a new editor window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器窗口
- en: Creating a new Asset type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的资产类型
- en: Creating custom context menu entries for Assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资产创建自定义上下文菜单条目
- en: Creating new console commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的控制台命令
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Blueprint 创建一个新的图形引脚可视化器
- en: Inspecting types with custom Details panels
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义 Details 面板检查类型
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In game development, in addition to creating games, you'll often need to create
    tools for other developers to use that have been customized to fit the project
    that you're working on. In fact, this is often one of the more common entry-level
    game developer positions in the AAA game industry. In this chapter, we will learn
    how to implement custom editor windows and custom detail panels to inspect types
    that have been created by users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，除了创建游戏，你通常还需要为其他开发者创建工具，这些工具已经根据你正在工作的项目进行了定制。实际上，这通常是 AAA 游戏行业中初级游戏开发者职位中较为常见的一种。在本章中，我们将学习如何实现自定义编辑器窗口和自定义详细面板来检查用户创建的类型。
- en: Creating a new editor module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器模块
- en: The following recipes all interact with editor mode-specific code and engine
    modules. As a result, it is considered good practice to create a new module that
    will only be loaded when the engine is running in editor mode, so that we can
    place all our editor-only code inside it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱都与编辑器模式特定的代码和引擎模块交互。因此，创建一个仅在引擎以编辑器模式运行时才会加载的新模块被认为是一种良好的实践，这样我们就可以将所有仅用于编辑器的代码放在其中。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open your project''s `.uproject` file in a text editor such as Notepad or Notepad++.
    You can find the file inside your project folder, and it should look similar to
    what''s shown in the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器（如记事本或 Notepad++）中打开你的项目 `.uproject` 文件。你可以在项目文件夹中找到该文件，它应该看起来与以下截图类似：
- en: '![](img/b4051c5c-b769-4866-98f4-39af0c8018de.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4051c5c-b769-4866-98f4-39af0c8018de.png)'
- en: 'Add the bold section of text in the following snippet to the file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段中的粗体部分添加到文件中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note the comma after the first module before the second set of curly braces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第二组花括号之前第一个模块后面的逗号。
- en: 'In your `Source` folder, create a new folder using the same name as you specified
    in your `uproject` file (in this instance, `"Chapter_10Editor"`):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Source` 文件夹中，创建一个与你在 `uproject` 文件中指定的相同名称的新文件夹（在本例中为 `"Chapter_10Editor"`）：
- en: '![](img/fc3ee6b5-e94d-4330-a120-4b2f707d6edc.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc3ee6b5-e94d-4330-a120-4b2f707d6edc.png)'
- en: 'Open up the `Chapter_10Editor.Target.cs` file and update it to the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter_10Editor.Target.cs` 文件并将其更新为以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside this new folder, create a blank `.txt` file and rename it to `Chapter_10Editor.Build.cs`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件夹中，创建一个空的 `.txt` 文件并将其重命名为 `Chapter_10Editor.Build.cs`：
- en: '![](img/1f0a6cba-aeb7-420e-9d08-cec2aed2029e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f0a6cba-aeb7-420e-9d08-cec2aed2029e.png)'
- en: 'Insert the following into the file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容插入到文件中：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still inside of the `Chapter10_Editor` folder, create a new file called `Chapter_10Editor.h` and
    add the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `Chapter10_Editor` 文件夹中，创建一个名为 `Chapter_10Editor.h` 的新文件并添加以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, create a new source file called `Chapter_10Editor.cpp`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为 `Chapter_10Editor.cpp` 的新源文件。
- en: 'Add the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, close Visual Studio if you have it open. Then, right-click on the `.uproject` file
    and select Generate Visual Studio Project files:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果你打开了 Visual Studio，请关闭它。然后，右键单击 `.uproject` 文件并选择“生成 Visual Studio 项目文件”：
- en: '![](img/71edf948-dcce-4da8-a1a3-e8069a117f83.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71edf948-dcce-4da8-a1a3-e8069a117f83.png)'
- en: 'You should see a small window launch, display a progress bar, and then close:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到一个小的窗口启动，显示进度条，然后关闭：
- en: '![](img/766c4e4b-557f-4785-8c01-ae82430cadc7.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/766c4e4b-557f-4785-8c01-ae82430cadc7.jpg)'
- en: 'You can now launch Visual Studio, verify that your new module is visible in
    the IDE, and compile your project successfully:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以启动 Visual Studio，验证你的新模块是否在 IDE 中可见，并成功编译你的项目：
- en: '![](img/770bd61f-d16a-49f2-9c81-f2f1d3be25d3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/770bd61f-d16a-49f2-9c81-f2f1d3be25d3.png)'
- en: The module is now ready for the next set of recipes.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块现在已准备好进行下一组食谱。
- en: Code changes made in this editor module won't support hot-reloading in the same
    way that code in runtime modules does. If you get a compilation error that mentions
    changes to generated header files, simply close the editor and rebuild it from
    within your IDE instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此编辑器模块中进行的代码更改不会像运行时模块中的代码那样支持热重载。如果你遇到提及生成头文件更改的编译错误，只需关闭编辑器，并在你的IDE中重新构建它即可。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unreal projects use the `.uproject` file format to specify a number of different
    pieces of information about the project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal项目使用`.uproject`文件格式来指定有关项目的一些不同信息。
- en: This information is used to inform the Header and Build tools about the modules
    that comprise this project, and is used for code generation and `makefile` creation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息用于通知头文件和构建工具关于构成此项目的模块，并用于代码生成和`makefile`创建。
- en: The file uses JSON-style formatting.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用JSON风格的格式。
- en: 'These include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括以下内容：
- en: The engine version that the project should be opened in
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目应该在其中打开的引擎版本
- en: A list of modules that are used in the project
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目中使用的模块列表
- en: A list of module declarations
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块声明的列表
- en: 'Each of these module declarations contain the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块声明中的每一个都包含以下内容：
- en: The name of the module.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称。
- en: The type of module—is it an editor module (only runs in editor builds, has access
    to editor-only classes) or a runtime module (runs in both editor and Shipping
    builds)?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的类型——这是一个编辑器模块（仅在编辑器构建中运行，可以访问仅限编辑器的类）还是一个运行时模块（在编辑器和发布构建中运行）？
- en: The loading phase of the module—modules can be loaded at different points during
    program startup. This value specifies the point at which the module should be
    loaded, for example, if there are dependencies in other modules that should be
    loaded first.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的加载阶段——模块可以在程序启动的不同阶段加载。此值指定模块应该加载的点，例如，如果有其他模块中的依赖项应该先加载。
- en: A list of dependencies for the module. These are essential modules that contain
    exported functions or classes that the module relies on.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的依赖项列表。这些是包含导出函数或类的必要模块，这些函数或类是模块所依赖的。
- en: We added a new module to the `uproject file`. The module's name is `Chapter_10Editor` (Conventionally, `Editor` should
    be appended to the main game module for an editor module).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`uproject`文件中添加了一个新模块。该模块的名称是`Chapter_10Editor`（传统上，`Editor`应该附加到主游戏模块的编辑器模块上）。
- en: This module is marked as an editor module, and is set to load after the baseline
    engine so that it can use the classes that have been declared in Engine code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块被标记为编辑器模块，并设置为在基线引擎之后加载，以便它可以使用在引擎代码中声明的类。
- en: Our module's dependencies are left at the default values for now.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块的依赖项目前保留为默认值。
- en: With the `uproject` file altered to contain our new module, we need a build
    script for it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将`uproject`文件修改为包含我们的新模块后，我们需要为其编写一个构建脚本。
- en: Build scripts are written in C#, and take the name `<ModuleName>.Build.cs`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本是用C#编写的，名称为`<ModuleName>.Build.cs`。
- en: C#, unlike C++, doesn't use a separate header file and implementation – it's
    all there in the one `.cs` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++不同，C#不使用单独的头文件和实现文件——所有内容都在一个`.cs`文件中。
- en: We want to access the classes that have been declared in the `UnrealBuildTool` module,
    so we include a `using` statement to indicate that we want to access that namespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要访问在`UnrealBuildTool`模块中声明的类，因此我们包含一个`using`语句来指示我们想要访问该命名空间。
- en: We create a `public` class with the same name as our module, which inherits
    from `ModuleRules`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个与我们的模块同名且继承自`ModuleRules`的`public`类。
- en: Inside our constructor, we add a number of modules to the dependencies of this
    module. There are both private dependencies and public dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们向此模块的依赖项中添加了多个模块。这些既有私有依赖项，也有公共依赖项。
- en: According to the code of the `ModuleRules` class, public dependencies are modules
    that your module's public header files depend on. Private dependencies are modules
    that the private code depends on. Anything used in both public headers and private
    code should go into the `PublicDependencyModuleNames` array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`ModuleRules`类的代码，公共依赖项是模块的公共头文件所依赖的模块。私有依赖项是私有代码所依赖的模块。任何在公共头文件和私有代码中使用的都应该放入`PublicDependencyModuleNames`数组中。
- en: You'll note that our `PublicDependencyModuleNames` array contains our main game
    module. This is because some recipes in this chapter will extend the editor to
    better support the classes that are defined within our main game module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的`PublicDependencyModuleNames`数组包含我们的主要游戏模块。这是因为本章的一些食谱将扩展编辑器以更好地支持定义在我们主要游戏模块内的类。
- en: Now that we've told the build system that we have a new module to build through
    the project file, and we've specified how to build the module with the build script,
    we need to create the C++ class that is our actual module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经通过项目文件告诉构建系统我们有一个新的模块需要构建，并且我们已经指定了如何使用构建脚本来构建该模块，我们需要创建一个C++类，即我们的实际模块。
- en: We create a header file that includes the Engine header, the `ModuleManager` header,
    and the `UnrealEd` header.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个头文件，其中包含引擎头文件、`ModuleManager`头文件和`UnrealEd`头文件。
- en: We include `ModuleManager` because it defines `IModuleInterface`, the class
    that our module will inherit from.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`ModuleManager`因为它定义了`IModuleInterface`，这是我们模块将继承的类。
- en: We also include `UnrealEd` because we're writing an editor module that will
    need to access the editor functionality.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含`UnrealEd`，因为我们正在编写一个需要访问编辑器功能的编辑器模块。
- en: The class we declare inherits from `IModuleInterface`, and takes its name from
    the usual prefix, `F`, followed by the module name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的类继承自`IModuleInterface`，并且其名称由通常的前缀`F`加上模块名称组成。
- en: Inside the `.cpp` file, we include our module's header, and then use the `IMPLEMENT_GAME_MODULE` macro.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，我们包含我们的模块头文件，然后使用`IMPLEMENT_GAME_MODULE`宏。
- en: '`IMPLEMENT_GAME_MODULE` declares an exported C function, `InitializeModule()`,
    which returns an instance of our new module class.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMPLEMENT_GAME_MODULE`声明了一个导出的C函数`InitializeModule()`，它返回我们新模块类的一个实例。'
- en: This means that Unreal can simply call `InitializeModule()` on any library that
    exports it to retrieve a reference to the actual module implementation without
    needing to know what class it is.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Unreal可以简单地调用任何导出它的库上的`InitializeModule()`来获取实际模块实现的引用，而无需知道它是什么类。
- en: Having added our new module, we now need to rebuild our Visual Studio solution,
    so we close Visual Studio and then regenerate the project files using the context
    menu.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了我们的新模块后，我们现在需要重新构建我们的Visual Studio解决方案，因此我们关闭Visual Studio，然后使用上下文菜单重新生成项目文件。
- en: With the project rebuilt, the new module will be visible in Visual Studio, and
    we can add code to it as usual.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建项目后，新的模块将在Visual Studio中可见，我们可以像往常一样向其中添加代码。
- en: Creating new toolbar buttons
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的工具栏按钮
- en: If you have created a custom tool or window for display within the editor, you
    probably need some way to let the user make it appear. The easiest way to do this
    is to create a toolbar customization that adds a new toolbar button, and have
    it display your window when clicked. Create a new engine module by following the
    previous recipe, as we'll need it to initialize our toolbar customization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为编辑器内显示的自定义工具或窗口创建了，你可能需要某种方式让用户使其出现。最简单的方法是创建一个工具栏自定义，添加一个新的工具栏按钮，并在点击时显示你的窗口。按照之前的食谱创建一个新的引擎模块，因为我们还需要它来初始化我们的工具栏自定义。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Inside of the `Chapter_10Editor` folder, create a new header file, `CookbookCommands.h`,
    and insert the following class declaration:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter_10Editor`文件夹内，创建一个新的头文件，名为`CookbookCommands.h`，并插入以下类声明：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the new class by placing the following in the `.cpp` file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`.cpp`文件中放置以下内容来实现新类：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will need to update our module class (`Chapter_10Editor.h`) to the
    following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的模块类（`Chapter_10Editor.h`）到以下内容：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Be sure to `#include` the header file for your command class as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保也包含你的命令类的头文件。
- en: 'We now need to implement `StartupModule` and `ShutdownModule`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要实现`StartupModule`和`ShutdownModule`：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Regenerate your project piles if needed, compile your project from Visual Studio
    and start the editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，重新生成你的项目文件，从Visual Studio编译你的项目并启动编辑器。
- en: 'Verify that there''s a new button on the toolbar in the main level editor,
    which can be clicked on to open a new window:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认主级别编辑器工具栏中有一个新的按钮，可以点击以打开一个新窗口：
- en: '![](img/6f9e599c-aee8-4438-a084-5350a219f1ea.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f9e599c-aee8-4438-a084-5350a219f1ea.png)'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unreal's editor UI is based on the concept of commands. Commands are a design
    pattern that allows looser coupling between the UI and the actions that it needs
    to perform.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal的编辑器UI基于命令的概念。命令是一种设计模式，它允许UI与其需要执行的操作之间有更松散的耦合。
- en: To create a class that contains a set of commands, it is necessary to inherit
    from `TCommands`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含一组命令的类，必须从 `TCommands` 继承。
- en: '`TCommands` is a template class that leverages the **Curiously Recurring Template
    Pattern** (**CRTP**). The CRTP is used commonly throughout Slate UI code as a
    means of creating compile-time polymorphism.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCommands` 是一个模板类，它利用了**奇特重复模板模式**（**CRTP**）。CRTP 在 Slate UI 代码中广泛使用，作为创建编译时多态的手段。'
- en: 'In the initializer list for `FCookbookCommands` constructor, we invoke the
    parent class constructor, passing in a number of parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FCookbookCommands` 构造函数的初始化列表中，我们调用父类构造函数，传递一系列参数：
- en: The first parameter is the name of the command set, and is a simple `FName`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是命令集的名称，它是一个简单的 `FName`。
- en: The second parameter is a tooltip/human readable string, and, as such, uses `FText` so
    that it can support localization if necessary.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是工具提示/人类可读字符串，因此使用 `FText` 以便在必要时支持本地化。
- en: If there's a parent group of commands, the third parameter contains the name
    of the group. Otherwise, it contains `NAME_None`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在命令的父组，第三个参数包含组的名称。否则，它包含 `NAME_None`。
- en: The final parameter for the constructor is the Slate Style set that contains
    any command icons that the command set will be using.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的最后一个参数是包含命令集将使用的任何命令图标的 Slate 风格集。
- en: The `RegisterCommands()` function allows TCommands-derived classes to create
    any command objects that they require. The resulting `FUICommandInfo` instances
    that are returned from that function are stored inside the `Commands` class as
    members so that UI elements or functions can be bound to the commands.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterCommands()` 函数允许 `TCommands` 派生类创建它们所需的任何命令对象。从该函数返回的 `FUICommandInfo`
    实例作为 `Commands` 类的成员存储，以便 UI 元素或函数可以绑定到命令。'
- en: This is why we have the member variable `TSharedPtr<FUICommandInfo> MyButton`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们有成员变量 `TSharedPtr<FUICommandInfo> MyButton`。
- en: In the implementation for the class, we simply need to create our commands in `RegisterCommands`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的实现中，我们只需在 `RegisterCommands` 中创建我们的命令。
- en: The `UI_COMMAND` macro that was used to create an instance of `FUICommandInfo` expects
    a localization namespace to be defined, even if it is just an empty default namespace.
    As a result, we need to enclose our `UI_COMMAND` calls with `#defines` to set
    a valid value for `LOCTEXT_NAMESPACE`, even if we don't intend to use localization.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建 `FUICommandInfo` 实例的 `UI_COMMAND` 宏期望定义一个本地化命名空间，即使它只是一个空的默认命名空间。因此，我们需要用
    `#defines` 将我们的 `UI_COMMAND` 调用括起来，以设置 `LOCTEXT_NAMESPACE` 的有效值，即使我们不想使用本地化。
- en: 'The actual `UI_COMMAND` macro takes a number of parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 `UI_COMMAND` 宏接受多个参数：
- en: The first parameter is the variable to store the `FUICommandInfo` in
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是存储 `FUICommandInfo` 的变量
- en: The second parameter is a human-readable name for the command
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是命令的人类可读名称
- en: The third parameter is a description for the command
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是命令的描述
- en: The fourth parameter is `EUserInterfaceActionType`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是 `EUserInterfaceActionType`
- en: This enumeration essentially specifies what sort of button is being created.
    It supports `Button`, `ToggleButton`, `RadioButton`, and `Check` as valid types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此枚举基本上指定了正在创建哪种类型的按钮。它支持 `Button`、`ToggleButton`、`RadioButton` 和 `Check` 作为有效类型。
- en: Buttons are simple generic buttons. A toggle button stores on and off states.
    The radio button is similar to a toggle, but is grouped with other radio buttons,
    and only one can be enabled at a time. Lastly, the checkbox displays a read-only
    checkbox that's adjacent to the button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是简单的通用按钮。切换按钮存储开/关状态。单选按钮类似于切换，但与其他单选按钮分组，并且一次只能启用一个。最后，复选框显示与按钮相邻的只读复选框。
- en: The last parameter for `UI_COMMAND` is the input chord, or the combination of
    keys that are required to activate the command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`UI_COMMAND` 的最后一个参数是输入和弦，或激活命令所需的键的组合。'
- en: This parameter is primarily useful for defining key combinations for hotkeys
    linked to the command in question, rather than buttons. As a result, we use an
    empty `InputGesture`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数主要用于定义与命令相关联的热键的关键组合，而不是按钮。因此，我们使用空的 `InputGesture`。
- en: So, we now have a set of commands, but we haven't told the engine we want to add
    the set to the commands that show on the toolbar. We also haven't set up what
    actually happens when the button is clicked. To do this, we need to perform some
    initialization when our module begins, so we place some code into the `StartupModule`/`ShutdownModule` functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一组命令，但我们还没有告诉引擎我们想要将这组命令添加到显示在工具栏上的命令中。我们也没有设置按钮点击时实际发生的事情。为此，我们需要在我们的模块开始时执行一些初始化，所以我们将在`StartupModule`/`ShutdownModule`函数中放置一些代码。
- en: Inside `StartupModule`, we call the static `Register` function on the commands
    class that we defined earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartupModule`内部，我们调用我们之前定义的命令类上的静态`Register`函数。
- en: We then create a shared pointer to a list of commands using the `MakeShareable` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`MakeShareable`函数创建一个命令列表的共享指针。
- en: In the command list, we use `MapAction` to create a mapping, or association,
    between the `UICommandInfo` object, which we set as a member of the `FCookbookCommands`,
    and the actual function we want to execute when the command is invoked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令列表中，我们使用`MapAction`创建一个映射，或关联，将`UICommandInfo`对象（我们将其设置为`FCookbookCommands`的一个成员）与我们要在命令调用时执行的函数关联起来。
- en: You'll note that we don't explicitly set anything regarding what could be used
    to invoke the command here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在这里没有明确设置任何有关可以用来调用命令的内容。
- en: To perform this mapping, we call the `MapAction` function. The first parameter
    to `MapAction` is a `FUICommandInfo` object, which we can retrieve from `FCookbookCommands` by
    using its static `Get()` method to retrieve the instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此映射，我们调用`MapAction`函数。`MapAction`的第一个参数是一个`FUICommandInfo`对象，我们可以通过使用其静态`Get()`方法从`FCookbookCommands`检索实例来获取它。
- en: '`FCookbookCommands` is implemented as a singleton – a class with a single instance
    that exists throughout the application. You''ll see the pattern in most places
    – there''s a static `Get()` method available in the engine.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`FCookbookCommands`实现为一个单例——一个在整个应用程序中存在单个实例的类。你会在大多数地方看到这个模式——在引擎中有一个可用的静态`Get()`方法。'
- en: The second parameter of the `MapAction` function is a delegate bound to the
    function to be invoked when the command is executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapAction`函数的第二个参数是一个委托，当命令执行时，它绑定到要调用的函数。'
- en: Because `Chapter_10EditorModule` is a raw C++ class rather than a `UObject`,
    and we want to invoke a member function rather than a `static` function, we use `CreateRaw` to
    create a new delegate that's bound to a raw C++ member function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Chapter_10EditorModule`是一个原始的C++类而不是`UObject`，并且我们想要调用成员函数而不是`static`函数，所以我们使用`CreateRaw`创建一个新的委托，该委托绑定到一个原始C++成员函数。
- en: '`CreateRaw` expects a pointer to the object instance, and a function reference
    to the function to invoke on that pointer.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateRaw`期望一个指向对象实例的指针和一个指向要在此指针上调用的函数的函数引用。'
- en: The third parameter for `MapAction` is a delegate to call to test if the action
    can be executed. Because we want the command to be executable all the time, we
    can use a simple predefined delegate that always returns `true`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapAction`的第三个参数是一个委托，用于测试动作是否可以执行。因为我们希望命令始终可执行，我们可以使用一个简单的预定义委托，该委托始终返回`true`。'
- en: With an association created between our command and the action it should call,
    we now need to actually tell the extension system that we want to add new commands
    to the toolbar.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的命令与其应调用的动作之间创建关联后，我们现在需要实际上告诉扩展系统我们想要将新命令添加到工具栏。
- en: We can do this via the `FExtender` class, which can be used to extend menus,
    context menus, or toolbars.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`FExtender`类来实现这一点，该类可以用来扩展菜单、上下文菜单或工具栏。
- en: We initially create an instance of `FExtender` as a shared pointer so that our
    extensions are uninitialized when the module is shut down.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建一个`FExtender`实例作为共享指针，这样当模块关闭时，我们的扩展未初始化。
- en: We then call `AddToolBarExtension` on our new extender, storing the results
    in a shared pointer so that we can remove it on module uninitialization.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的新扩展器上调用`AddToolBarExtension`，并将结果存储在共享指针中，这样我们就可以在模块卸载时将其删除。
- en: First argument of `AddToolBarExtension` is the name of the extension point where
    we want to add our extension.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToolBarExtension`的第一个参数是我们想要添加扩展的扩展点名称。'
- en: To find where we want to place our extension, we first need to turn on the display
    of extension points within the editor UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到我们想要放置扩展的位置，我们首先需要打开编辑器UI中扩展点的显示。
- en: 'To do so, open Editor Preferences in the Edit menu within the editor:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请在编辑器中的“编辑”菜单中打开“编辑器首选项”：
- en: '![](img/733efb6c-4df7-4663-b51c-2629dabb48c2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/733efb6c-4df7-4663-b51c-2629dabb48c2.png)'
- en: 'Open General | Miscellaneous and select Display UIExtension Points:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“通用”|“杂项”并选择显示UI扩展点：
- en: '![](img/a7875429-2beb-4350-8952-b13d6b5f419d.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a7875429-2beb-4350-8952-b13d6b5f419d.png)'
- en: 'Restart the editor, and you should see green text overlaid on the Editor UI,
    as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动编辑器，你应该会在编辑器UI上看到覆盖的绿色文本，如下面的截图所示：
- en: '![](img/9cd351fc-a334-42c3-8155-24fa0772578c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9cd351fc-a334-42c3-8155-24fa0772578c.png)'
- en: Green text overlaying the Editor UI
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖编辑器UI的绿色文本
- en: The green text indicates `UIExtensionPoint`, and the text's value is the string
    we should provide to the `AddToolBarExtension` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色文本表示`UIExtensionPoint`，文本的值是我们应该提供给`AddToolBarExtension`函数的字符串。
- en: We're going to add our extension to the Compile extension point in this recipe,
    but of course, you could use any other extension point you wish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将把我们的扩展添加到`Compile`扩展点，但当然，你也可以使用你想要的任何其他扩展点。
- en: It's important to note that adding a toolbar extension to a menu extension point
    will fail silently, and vice versa.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，将工具栏扩展添加到菜单扩展点将静默失败，反之亦然。
- en: The second parameter to `AddToolBarExtension` is a location anchor relative
    to the extension point that's specified. We've selected `FExtensionHook::Before`,
    so our icon will be displayed before the compile point.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToolBarExtension`的第二个参数是相对于指定扩展点的位置锚点。我们选择了`FExtensionHook::Before`，因此我们的图标将在编译点之前显示。'
- en: The next parameter is our command list that contains mapped actions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是我们包含映射操作的命令列表。
- en: Finally, the last parameter is a delegate that is responsible for actually adding
    UI controls to the toolbar at the extension point and the anchor that we specified
    earlier.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个参数是一个委托，它负责实际上在扩展点和之前指定的锚点处添加UI控件。
- en: The delegate is bound to a function that has the form void (`*func`) (`FToolBarBuilder` and `builder`).
    In this instance, it is a function called `AddToolbarExtension`, which is defined
    in our module class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 委托绑定到一个具有形式void (`*func`) (`FToolBarBuilder`和`builder`)的函数。在这个例子中，它是一个在模块类中定义的名为`AddToolbarExtension`的函数。
- en: When the function is invoked, calling commands on the `builder` that adds UI
    elements will apply those elements to the location in the UI we specified.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，在`builder`上调用添加UI元素的命令将把那些元素应用到我们在UI中指定的位置。
- en: Lastly, we need to load the level editor module within this function so that
    we can add our extender to the main toolbar within the level editor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在这个函数中加载关卡编辑器模块，这样我们就可以将我们的扩展器添加到关卡编辑器中的主工具栏。
- en: As usual, we can use `ModuleManager` to load a module and return a reference
    to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，我们可以使用`ModuleManager`来加载一个模块并返回它的引用。
- en: With that reference in hand, we can get the Toolbar Extensibility Manager for
    the module, and tell it to add our Extender.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个引用后，我们可以获取模块的工具栏可扩展性管理器，并告诉它添加我们的扩展器。
- en: While this may seem cumbersome at first, the intention is to allow you to apply
    the same toolbar extension to multiple toolbars in different modules, if you would
    like to create a consistent UI layout between different editor windows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始这可能看起来有些繁琐，但目的是允许你将相同的工具栏扩展应用到不同模块的多个工具栏上，如果你想在不同的编辑器窗口之间创建一致的UI布局的话。
- en: The counterpart to initializing our extension, of course, is removing it when
    our module is unloaded. To do that, we remove our extension from the extender,
    then null the shared pointers for both Extender and extension, thus reclaiming
    their memory allocation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，初始化我们的扩展的对应操作是在我们的模块卸载时移除它。为此，我们从扩展器中移除我们的扩展，然后使扩展器和扩展的共享指针都为空，从而回收它们的内存分配。
- en: The `AddToolBarExtension` function within the editor module is the one that
    is responsible for actually adding UI elements to the toolbar that can invoke
    our commands.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器模块中的`AddToolBarExtension`函数是负责实际上将UI元素添加到工具栏以调用我们的命令的那个函数。
- en: It does this by calling functions on the `FToolBarBuilder` instance that's passed
    in as a function parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过调用作为函数参数传入的`FToolBarBuilder`实例上的函数来实现这一点。
- en: First, we retrieve an appropriate icon for our new toolbar button using the `FSlateIcon` constructor.
    Then, with the icon loaded, we invoke `AddToolBarButton` on the `builder` instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`FSlateIcon`构造函数检索我们新工具栏按钮的适当图标。然后，在图标加载后，我们在`builder`实例上调用`AddToolBarButton`。
- en: '`AddToolbarButton` has a number of parameters. The first parameter is the command
    to bind to – you''ll notice it''s the same `MyButton` member that we accessed
    earlier when binding the action to the command. The second parameter is an override
    for the extension hook we specified earlier, but we don''t want to override that,
    so we can use `NAME_None`. The third parameter is a label override for the new
    button that we create. Parameter four is a tooltip for the new button. The second
    to last parameter is the button''s icon, and the last parameter is a name that''s
    used to refer to this button element for highlighting support if you wish to use
    the in-editor tutorial framework.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToolbarButton`有几个参数。第一个参数是要绑定的命令——你会注意到它与我们之前绑定操作到命令时访问的相同的`MyButton`成员。第二个参数是之前指定的扩展钩子的覆盖，但我们不想覆盖它，所以我们可以使用`NAME_None`。第三个参数是我们创建的新按钮的标签覆盖。第四个参数是新按钮的提示信息。倒数第二个参数是按钮的图标，最后一个参数是用于引用此按钮元素以便进行高亮显示的名称，如果你希望使用编辑器中的教程框架。'
- en: Creating new menu entries
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的菜单项
- en: The workflow for creating new menu entries is almost identical to that for creating
    new toolbar buttons, so this recipe will build on the previous one and show you
    how to add the command created therein to a menu rather than a toolbar.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新菜单项的工作流程几乎与创建新工具栏按钮的工作流程相同，因此这个配方将基于上一个配方，并展示如何将其中创建的命令添加到菜单而不是工具栏中。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new function inside of the `FChapter_10EditorModule` class, which
    is in `Chapter10_Editor.h`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter10_Editor.h`中的`FChapter_10EditorModule`类内部创建一个新函数：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the implementation file (`Chapter_10Editor.cpp`), find the following code
    within the `StartupModule` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件（`Chapter_10Editor.cpp`）中，在`StartupModule`函数内找到以下代码：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replace the preceding code with the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下代码：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile your code and launch the editor.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Verify that you now have a menu entry under the Window menu that displays the Cookbook window
    when clicked. If you followed the preceding recipe, you''ll also see the green
    text listing the UI extension points, including the one we used in this recipe
    (LevelEditor):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你现在在“窗口”菜单下有一个菜单项，当点击时会显示“Cookbook”窗口。如果你遵循了前面的配方，你还会看到列出UI扩展点的绿色文本，包括我们在这个配方中使用的（LevelEditor）：
- en: '![](img/23b9b8b0-5d3a-40ba-9ba8-cc176d0f1b58.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23b9b8b0-5d3a-40ba-9ba8-cc176d0f1b58.png)'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You'll note that `ToolbarExtender` is of type `FExtender` rather than `FToolbarExtender` or `FMenuExtender`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`ToolbarExtender`是`FExtender`类型，而不是`FToolbarExtender`或`FMenuExtender`。
- en: By using a generic `FExtender` class rather than a specific subclass, the framework
    allows you to create a series of command-function mappings that can be used on
    either menus or toolbars. The delegate that actually adds the UI controls (in
    this instance, `AddMenuExtension`) can link those controls to a subset of commands
    from your `FExtender`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用通用的`FExtender`类而不是特定的子类，框架允许你创建一系列命令-函数映射，这些映射可以在菜单或工具栏上使用。实际添加UI控件（在这个例子中，`AddMenuExtension`）的委托可以将这些控件链接到`FExtender`中的命令子集。
- en: This way, you don't need to have different `TCommands` classes for different
    types of extensions, and you can place the commands into a single central class
    regardless of where those commands are invoked from the UI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你不需要为不同类型的扩展有不同的`TCommands`类，你可以将命令放入一个单一的中心类中，无论这些命令是从UI的哪个地方调用的。
- en: 'As a result, the only changes that are required are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所需更改如下：
- en: Swapping calls to `AddToolBarExtension` with `AddMenuExtension`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对`AddToolBarExtension`的调用与`AddMenuExtension`交换
- en: Creating a function that can be bound to `FMenuExtensionDelegate` rather than `FToolbarExtensionDelegate`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以绑定到`FMenuExtensionDelegate`而不是`FToolbarExtensionDelegate`的函数
- en: Adding the extender to a Menu Extensibility Manager rather than a Toolbar Extensibility
    Manager
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将扩展器添加到菜单扩展管理器而不是工具栏扩展管理器
- en: Creating a new editor window
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的编辑器窗口
- en: Custom editor windows are useful when you have a new tool with user-configurable
    settings, or want to display some information to people using your customized
    editor. Ensure that you have have an editor module by following the recipe earlier
    in this chapter before you start. Read through either the *Creating new menu entries* or *Creating
    new toolbar buttons* recipes so that you can create a button within the editor
    that will launch our new window.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个带有用户可配置设置的全新工具，或者想要向使用你自定义编辑器的人显示一些信息时，自定义编辑窗口非常有用。在开始之前，请确保你已经按照本章前面的食谱实现了编辑器模块。阅读“创建新的菜单条目”或“创建新的工具栏按钮”的食谱，以便你可以在编辑器中创建一个按钮，该按钮将启动我们的新窗口。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Inside your command''s bound function (in our case, the `MyButton_Clicked` function
    in the `FChapter_10EditorModule` class that''s found in `Chapter_10Editor.h`),
    add the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的命令的绑定函数（在我们的例子中，是 `FChapter_10EditorModule` 类中的 `MyButton_Clicked` 函数，该类位于
    `Chapter_10Editor.h` 文件中）内部，添加以下代码：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we removed the `;` at the end of the line stating `.SupportsMinimize(false)`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在声明 `.SupportsMinimize(false)` 的行末去掉了分号。
- en: Compile your code and launch the editor.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'When you activate the command you created, either by selecting the custom menu
    option or the toolbar option that you added, you should see that the window has
    been displayed with some centered text in the middle:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你激活你创建的命令时，无论是通过选择自定义菜单选项还是添加的工具栏选项，你应该看到窗口已经显示，中间有一些居中的文本：
- en: '![](img/4e289ce2-a243-402b-9d35-319f0b8f2801.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e289ce2-a243-402b-9d35-319f0b8f2801.png)'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Your new editor window won't display itself, and so, at the start of this recipe,
    it is mentioned that you should have implemented a custom menu or toolbar button
    or a console command that we can use to trigger the display of our new window.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你新创建的编辑器窗口不会自动显示，因此，在本食谱的开始部分提到，你应该已经实现了一个自定义菜单或工具栏按钮或控制台命令，我们可以使用它来触发新窗口的显示。
- en: All of Slate's widgets are usually interacted with in the form of `TSharedRef<
    >` or `TSharedPtr< >`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Slate 的所有 widget 通常都以 `TSharedRef< >` 或 `TSharedPtr< >` 的形式进行交互。
- en: The `SNew()` function returns a `TSharedRef` that's been templated on the requested
    widget class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SNew()` 函数返回一个模板化请求的 widget 类的 `TSharedRef`。'
- en: As we mentioned previously, Slate widgets have a number of functions that they
    implement, which all return the object that the function was invoked on. This
    allows for method chaining to be used to configure the object at creation time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Slate widget 实现了许多函数，这些函数都返回函数被调用的对象。这允许在创建时使用方法链来配置对象。
- en: This is what allows for the Slate syntax of `<Widget>.Property(Value).Property(Value)`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用 `<Widget>.Property(Value).Property(Value)` 的 Slate 语法。
- en: The properties that are set on the widget in this recipe are the window title,
    the window size, and whether the window can be maximized and minimized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中设置的 widget 属性包括窗口标题、窗口大小以及窗口是否可以最大化或最小化。
- en: Once all the requisite properties on a widget have been set, the bracket operators
    (`[]`) can be used to specify the content to be placed inside the widget, for
    example, a picture or label inside a button.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 widget 上设置了所有必要的属性，就可以使用括号运算符（`[]`）来指定要放置在 widget 中的内容，例如，按钮内的图片或标签。
- en: '`SWindow` is a top-level widget with only one slot for child widgets, so we
    don''t need to add a slot for it ourselves. We place content into that slot by
    creating it inside the pair of brackets.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWindow` 是一个顶级 widget，它只为子 widget 有一个槽位，因此我们不需要自己为它添加槽位。我们通过在括号内创建它来将内容放入该槽位。'
- en: The content we create is `SVerticalBox`, which is a widget that can have an
    arbitrary number of slots for child widgets that are displayed in a vertical list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的内容是 `SVerticalBox`，这是一个可以拥有任意数量的槽位以在垂直列表中显示子 widget 的 widget。
- en: For each widget we want to place into the vertical list, we need to create a **slot**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要放置到垂直列表中的每个 widget，我们需要创建一个**槽位**。
- en: The easiest way to do this is to use the overloaded `+` operator and the `SVerticalBox::Slot()` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用重载的 `+` 运算符和 `SVerticalBox::Slot()` 函数。
- en: '`Slot()` returns a widget like any other, so we can set properties on it like
    we did on our `SWindow`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slot()` 返回一个与任何其他 widget 一样的 widget，因此我们可以像在 `SWindow` 上做的那样设置它的属性。'
- en: This recipe centers the Slot's content on both horizontal and vertical axes
    using `HAlign` and `VAlign`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱使用 `HAlign` 和 `VAlign` 在水平和垂直轴上居中 Slot 的内容。
- en: A `Slot` has a single child widget, and it's created inside the `[]` operators,
    just like they are for `SWindow`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Slot`有一个单独的小部件子代，它是在`[]`运算符内部创建的，就像它们对`SWindow`一样。'
- en: Inside the `Slot` content, we create a text block with some custom text.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Slot`内容内部，我们创建了一个包含一些自定义文本的文本块。
- en: Our new `SWindow` now has its child widgets added, but it isn't being displayed
    yet because it hasn't been added to the window hierarchy.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`SWindow`现在已经添加了子小部件，但它还没有被显示，因为它还没有被添加到窗口层次结构中。
- en: The main frame module is used to check if we have a top-level editor window,
    and if it exists, our new window is added as a child.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 主框架模块用于检查我们是否有顶级编辑器窗口，如果有，我们的新窗口就被添加为子窗口。
- en: If there's no top-level window to be added as a child to, then we use the Slate
    Application singleton to add our window without a parent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有顶级窗口可以添加为子窗口，那么我们就使用Slate应用程序单例来添加我们的窗口，而不需要父窗口。
- en: If you would like to see the hierarchy of the window we've created, you can
    use the Slate Widget Reflector, which can be accessed via Window | Developer Tools | Widget
    Reflector.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看我们创建的窗口的层次结构，你可以使用Slate Widget Reflector，它可以通过Window | Developer Tools
    | Widget Reflector访问。
- en: 'If you select Pick Painted Widget and hover your cursor over the text in the
    center of our custom window, you will be able to see the SWindow with our custom
    widgets added to its hierarchy:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择“选择已绘制的小部件”，并将光标悬停在自定义窗口中央的文本上，你将能够看到带有我们添加到其层次结构中的自定义小部件的`SWindow`：
- en: '![](img/0de07d76-1193-4fc5-ab7c-ed947a065605.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0de07d76-1193-4fc5-ab7c-ed947a065605.png)'
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 11](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml), *Working with UE4
    APIs*, is all about UI, and will show you how to add additional elements to your
    new custom window'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml)，*使用UE4 API*，全部关于UI，将向你展示如何向你的新自定义窗口添加额外的元素'
- en: Creating a new Asset type
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的资产类型
- en: At some point in your project, you might need to create a new custom Asset class,
    for example, an Asset to store conversation data in an RPG. To properly integrate
    these with Content Browser, you'll need to create a new Asset type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中的某个时候，你可能需要创建一个新的自定义资产类，例如，一个用于在RPG中存储对话数据的资产。为了正确地将这些与内容浏览器集成，你需要创建一个新的资产类型。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new C++ class based on `UObject` called `MyCustomAsset`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`UObject`的新C++类，命名为`MyCustomAsset`：
- en: '![](img/d4eb0573-b97d-4470-90e8-3627adcf9c0d.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4eb0573-b97d-4470-90e8-3627adcf9c0d.png)'
- en: 'Open up the script and update the code of the `.h` file to the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开脚本并更新`.h`文件的代码如下：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create a class based on `UFactory`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，基于`UFactory`创建一个类：
- en: '![](img/e3e7c79e-3eeb-4cc4-a1e2-cd8e5371e942.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3e7c79e-3eeb-4cc4-a1e2-cd8e5371e942.png)'
- en: Give the script a name of `CustomAssetFactory` and press the Create Class button.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给脚本命名为`CustomAssetFactory`并按下“创建类”按钮。
- en: 'Open the script in Visual Studio and update the `CustomAssetFactory.h` file
    to the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开脚本并更新`CustomAssetFactory.h`文件如下：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, switch over to the `CustomAssetFactory.cpp` file and implement the class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，切换到`CustomAssetFactory.cpp`文件并实现该类：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile your code and open the editor.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并打开编辑器。
- en: 'Right-click in Content Browser, from the Content folder and, under the Miscellaneous tab
    of the Create Advanced Asset section, you should see your new class and be able
    to create instances of your new custom type:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击，从内容文件夹中，在创建高级资产部分的Miscellaneous选项卡下，你应该能看到你的新类并能够创建你新自定义类型的实例：
- en: '![](img/df0751b0-3259-47e3-b851-07fd9e1401ba.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df0751b0-3259-47e3-b851-07fd9e1401ba.png)'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first class is the actual object that can exist in the game at runtime.
    It's your texture, data file, or curve data – whatever you require.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类是实际可以在游戏运行时存在的对象。它是你的纹理、数据文件或曲线数据——无论你需要什么。
- en: For the purpose of this recipe, the simplest example is an asset that has an `FString` property
    to contain a name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，最简单的例子是一个具有`FString`属性以包含名称的资产。
- en: The property is marked as `UPROPERTY` so that it remains in memory, and additionally
    marked as `EditAnywhere` so that it is editable on both the default object and
    on instances of it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 属性被标记为`UPROPERTY`，以便它保留在内存中，并且还标记为`EditAnywhere`，以便它可以在默认对象及其实例上编辑。
- en: The second class is `Factory`. Unreal uses the `Factory` design pattern to create
    instances of assets.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类是`Factory`。Unreal使用`Factory`设计模式来创建资产实例。
- en: This means that there is a generic base `Factory` that uses virtual methods
    to declare the interface of object creation, and then `Factory` subclasses are
    responsible for creating the actual object in question.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有一个通用的基类`Factory`，它使用虚拟方法来声明对象创建的接口，然后`Factory`子类负责创建实际的对象。
- en: The advantage of this approach is that the user-created subclass can potentially
    instantiate one of its own subclasses if required; it hides the implementation
    details regarding deciding which object to create away from the object requesting
    the creation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，如果需要，用户创建的子类可以实例化其自己的子类之一；它将决定创建哪个对象的实现细节隐藏在请求创建的对象之外。
- en: With `UFactory` as our base class, we include the appropriate header.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以`UFactory`作为我们的基类，我们包含适当的头文件。
- en: The constructor is overridden, because there are a number of properties that
    we want to set for our new factory after the default constructor has run.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数被重写，因为有一些属性在我们运行默认构造函数之后想要设置给我们的新工厂。
- en: '`bCreateNew` signifies that the factory is currently able to create a new instance
    of the object in question from scratch.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`bCreateNew`表示工厂目前能够从头开始创建所讨论对象的全新实例。'
- en: '`bEditAfterNew` indicates that we would like to edit the newly created object
    immediately after creation.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`bEditAfterNew`表示我们希望在创建后立即编辑新创建的对象。'
- en: The `SupportedClass` variable is an instance of `UClass` containing reflection
    information about the type of object the factory will create.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`SupportedClass`变量是包含工厂将要创建的对象类型的反射信息的`UClass`实例。'
- en: The most significant function of our `UFactory` subclass is the actual factory
    method – `FactoryCreateNew`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`UFactory`子类最重要的功能是实际的工厂方法——`FactoryCreateNew`。
- en: '`FactoryCreateNew` is responsible for determining the type of object that should
    be created, and using `NewObject` to construct an instance of that type. It passes
    a number of parameters through to the `NewObject` call.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryCreateNew`负责确定应该创建的对象类型，并使用`NewObject`来构造该类型的一个实例。它通过一系列参数传递给`NewObject`调用。'
- en: '`InClass` is the class of object that will be constructed. `InParent` is the
    object that should be containing the new object that will be created. If this
    isn''t specified, the object is assumed to go into the transient package, which
    means that it won''t be automatically saved. `Name` is the name of the object
    to be created. `Flags` is a bitmask of creation flags that control things such
    as making the object visible outside of the package it is contained in.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`InClass`是将要构造的对象的类。`InParent`是应该包含将要创建的新对象的那个对象。如果没有指定，该对象将被假定为进入临时包，这意味着它不会被自动保存。`Name`是要创建的对象的名称。`Flags`是一个创建标志的位掩码，它控制着诸如使对象在其包含的包外可见等事情。'
- en: Within `FactoryCreateNew`, decisions can be made regarding which subclass should
    be instantiated. Other initialization can also be performed; for example, if there
    are sub-objects that require manual instantiation or initialization, they can
    be added here.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FactoryCreateNew`中，可以做出关于应该实例化哪个子类的决定。也可以执行其他初始化；例如，如果有需要手动实例化或初始化的子对象，它们可以在这里添加。
- en: 'An example from the engine code for this function is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的引擎代码示例如下：
- en: '[PRE16]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, there's a second call to `NewObject` to populate the `CameraInterpGroup` member
    of the `NewCamAnim` instance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有一个对`NewObject`的第二次调用，用于填充`NewCamAnim`实例的`CameraInterpGroup`成员。
- en: See also
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Editing class properties in different places in the editor* recipe earlier
    in this chapter gives more context to the `EditAnywhere` property specifier
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面提到的*在编辑器中不同位置编辑类属性*的配方为`EditAnywhere`属性指定符提供了更多上下文。
- en: Creating custom context menu entries for Assets
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为资产创建自定义上下文菜单条目
- en: Custom Asset types commonly have special functions you wish to be able to perform
    on them. For example, converting images into sprites is an option you wouldn't
    want to add to any other Asset type. You can create custom context menu entries
    for specific Asset types to make those functions accessible to users.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资产类型通常有您希望能够在它们上执行的特殊功能。例如，将图像转换为精灵是一个您不希望添加到任何其他资产类型的选项。您可以为特定的资产类型创建自定义上下文菜单条目，使用户能够访问这些功能。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: From the `Chapter_10Editor` folder, create two new files called `MyCustomAssetActions.h` and `MyCustomAssetActions.cpp`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Chapter_10Editor`文件夹中，创建两个新的文件，分别命名为`MyCustomAssetActions.h`和`MyCustomAssetActions.cpp`。
- en: Return to your project file and update your Visual Studio project. Once finished,
    open up the project in Visual Studio.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的项目文件并更新你的Visual Studio项目。完成后，在Visual Studio中打开项目。
- en: 'Open `MyCustomAssetActions.h` and use the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MyCustomAssetActions.h`并使用以下代码：
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open `MyCustomAssetActions.cpp` and add the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MyCustomAssetActions.cpp`并添加以下代码：
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open up the `Chapter_10Editor.h` file and add the following property to the
    class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter_10Editor.h`文件并将以下属性添加到类中：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Don't forget to add the `#include` for `IAssetTypeActions.h`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加`#include`对`IAssetTypeActions.h`。
- en: 'Within your editor module (`Chapter_10Editor.cpp`), add the following code
    to the `StartupModule()` function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器模块（`Chapter_10Editor.cpp`）中，将以下代码添加到`StartupModule()`函数中：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code inside the module''s `ShutdownModule()` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的`ShutdownModule()`函数内部添加以下代码：
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your project and launch the editor.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目并启动编辑器。
- en: Create an instance of your custom Asset inside the Content Browser by right-clicking
    and selecting Miscellaneous | My Custom Asset.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在内容浏览器中右键单击并选择Miscellaneous | My Custom Asset在内容浏览器中创建你的自定义资产实例。
- en: 'Right-click on your new asset to see our custom command in the context menu:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你的新资产以在上下文菜单中看到我们的自定义命令：
- en: '![](img/ae13de6c-8e5e-4f38-8a0e-06ad7da16286.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae13de6c-8e5e-4f38-8a0e-06ad7da16286.png)'
- en: Select the CustomAssetAction command to display a new blank editor window.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择CustomAssetAction命令以显示一个新的空白编辑器窗口。
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The base class for all asset type-specific context menu commands is `FAssetTypeActions_Base`,
    so we need to inherit from that class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有资产类型特定上下文菜单命令的基类是`FAssetTypeActions_Base`，因此我们需要从该类继承。
- en: '`FAssetTypeActions_Base` is an abstract class that defines a number of virtual
    functions that allow us to extend the context menu. The interface that contains
    the original information for these virtual functions can be found in `IAssetTypeActions.h`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`FAssetTypeActions_Base`是一个抽象类，它定义了多个虚拟函数，允许我们扩展上下文菜单。包含这些虚拟函数原始信息的接口可以在`IAssetTypeActions.h`中找到。'
- en: We also declare a function that we bind to our custom context menu entry.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个我们绑定到自定义上下文菜单条目的函数。
- en: '`IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )` is the
    function that''s called by the engine code to see if our `AssetTypeActions` class
    contains any actions that can be applied to the selected objects.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )`是引擎代码调用的函数，用于查看我们的`AssetTypeActions`类是否包含可以应用于所选对象的任何动作。'
- en: '`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder&
    MenuBuilder)` is called if the `HasActions` function returns `true`. It calls
    functions on `MenuBuilder` to create the menu options for the actions that we
    provide.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder&
    MenuBuilder)`在`HasActions`函数返回`true`时被调用。它调用`MenuBuilder`上的函数来创建我们提供的动作的菜单选项。'
- en: '`IAssetTypeActions::GetName()` returns the name of this class.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetName()`返回此类的名称。'
- en: '`IAssetTypeActions::GetSupportedClass()` returns an instance of `UClass` that
    our actions class supports.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetSupportedClass()`返回我们的动作类所支持的`UClass`实例。'
- en: '`IAssetTypeActions::GetTypeColor()` returns the color associated with this
    class and actions.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetTypeColor()`返回与此类和动作关联的颜色。'
- en: '`IAssetTypeActions::GetCategories()` returns a category that''s appropriate
    for the asset. This is used to change the category under which the actions show
    up in the context menu.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAssetTypeActions::GetCategories()`返回一个适合资产的类别。这用于更改动作在上下文菜单中显示的类别。'
- en: Our overridden implementation of `HasActions` simply returns `true` under all
    circumstances, and relies on filtering based on the results of `GetSupportedClass`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`HasActions`的重写实现简单地在所有情况下返回`true`，并依赖于基于`GetSupportedClass`的结果进行过滤。
- en: Inside the implementation of `GetActions`, we can call some functions on the `MenuBuilder` object
    that we are given as a function parameter. The `MenuBuilder` is passed as a reference,
    so any changes that are made by our function will persist after it returns.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetActions`的实现内部，我们可以调用作为函数参数给出的`MenuBuilder`对象上的某些函数。`MenuBuilder`是通过引用传递的，因此我们函数所做的任何更改在它返回后都将持续存在。
- en: '`AddMenuEntry` has a number of parameters. The first parameter is the name
    of the action itself. This is the name that will be visible within the context
    menu. The name is an `FText` so that it can be localized should you wish. For
    the sake of simplicity, we construct `FText` from a string literal and don''t
    concern ourselves with multiple language support.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMenuEntry` 函数有多个参数。第一个参数是动作本身的名称。这个名称将在上下文菜单中可见。名称是一个 `FText`，以便在需要时进行本地化。为了简化，我们从一个字符串字面量构造
    `FText`，并且不考虑多语言支持。'
- en: The second parameter is also `FText`, which we construct by calling `FText::FromString`.
    This parameter is the text that's displayed in a tooltip if the user hovers over
    our command for more than a small period of time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数也是 `FText`，我们通过调用 `FText::FromString` 来构造这个参数。这个参数是当用户将鼠标悬停在命令上超过一小段时间时显示在工具提示中的文本。
- en: The next parameter is `FSlateIcon` for the command, which is constructed from
    the `LevelEditor.ViewOptions` icon within the editor style set.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是命令的 `FSlateIcon`，它由编辑器样式集中的 `LevelEditor.ViewOptions` 图标构造。
- en: The last parameter to this function is an `FUIAction` instance. The `FUIAction` is
    a wrapper around a delegate binding, so we use `FExecuteAction::CreateRaw` to
    bind the command to the `MyCustomAsset_Clicked` function on this very instance
    of `FMyCustomAssetActions`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的最后一个参数是一个 `FUIAction` 实例。`FUIAction` 是一个封装了委托绑定的包装器，因此我们使用 `FExecuteAction::CreateRaw`
    将命令绑定到 `FMyCustomAssetActions` 的这个实例上的 `MyCustomAsset_Clicked` 函数。
- en: This means that when the menu entry is clicked, our `MyCustomAssetContext_Clicked` function
    will be run.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当菜单项被点击时，我们的 `MyCustomAssetContext_Clicked` 函数将被执行。
- en: Our implementation of `GetName` returns the name of our Asset type. This string
    will be used on the thumbnail for our Asset if we don't set one ourselves, apart
    from being used in the title of the menu section that our custom Assets will be
    placed in.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `GetName` 的实现返回我们的资产类型的名称。如果我们没有设置一个，这个字符串将被用于我们的资产缩略图，除了在菜单部分的标题中使用外，我们的自定义资产将被放置在这个菜单部分。
- en: As you'd expect, the implementation of `GetSupportedClass` returns `UMyCustomAsset::StaticClass()`,
    as this is the Asset type we want our actions to operate on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`GetSupportedClass` 的实现返回 `UMyCustomAsset::StaticClass()`，因为我们希望我们的操作作用于这种资产类型。
- en: '`GetTypeColor()` returns the color that will be used for color coding in Content
    Browser – the color is used in the bar at the bottom of the asset thumbnail. I''ve
    used Emerald here, but any arbitrary color will work.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTypeColor()` 返回在内容浏览器中用于颜色编码的颜色——这个颜色用于资产缩略图底部的条形。我在这里使用了翡翠色，但任何任意颜色都可以工作。'
- en: The real workhorse of this recipe is the `MyCustomAssetContext_Clicked()` function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的实际工作马是 `MyCustomAssetContext_Clicked()` 函数。
- en: The first thing that this function does is create a new instance of `SWindow`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先做的事情是创建一个 `SWindow` 的新实例。
- en: '`SWindow` is the Slate Window – a class from the Slate UI framework.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWindow` 是 Slate 窗口——来自 Slate UI 框架的一个类。'
- en: Slate Widgets are created using the `SNew` function, which returns an instance
    of the widget requested.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Slate 小部件是通过 `SNew` 函数创建的，它返回请求的部件实例。
- en: Slate uses the `builder` design pattern, which means that all of the functions
    that are **chained** after `SNew`, return a reference to the object that was being
    operated on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Slate 使用 `builder` 设计模式，这意味着所有在 `SNew` 之后 **链式** 调用的函数都返回正在操作的对象的引用。
- en: In this function, we create our new `SWindow`, then set the window title, its
    client size or area, and whether it can be maximized or minimized.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们创建新的 `SWindow`，然后设置窗口标题、其客户端大小或区域，以及它是否可以被最大化或最小化。
- en: With our new Window ready, we need to get a reference to the root window for
    the editor so that we can add our window to the hierarchy and get it displayed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新窗口准备好后，我们需要获取编辑器的根窗口的引用，以便我们可以将我们的窗口添加到层次结构中并显示它。
- en: We do this using the `IMainFrameModule` class. It's a module, so we use the Module
    Manager to load it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `IMainFrameModule` 类来完成这项工作。它是一个模块，因此我们使用模块管理器来加载它。
- en: '`LoadModuleChecked` will assert if we can''t load the module, so we don''t
    need to check it.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadModuleChecked` 如果我们无法加载模块，将断言，因此我们不需要检查它。'
- en: If the module was loaded, we check that we have a valid parent window. If that
    window is valid, then we use `FSlateApplication::AddWindowAsNativeChild` to add
    our window as a child of the top-level parent window.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块已加载，我们检查是否有有效的父窗口。如果该窗口有效，则使用 `FSlateApplication::AddWindowAsNativeChild`
    将我们的窗口添加为顶级父窗口的子窗口。
- en: If we don't have a top-level parent, the function uses `AddWindow` to add the
    new window without parenting it to another window within the hierarchy.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有顶级父级，函数将使用`AddWindow`来添加新窗口，而不会将其作为另一个窗口的子窗口添加到层次结构中。
- en: So, now we have a class that will display custom actions on our custom Asset
    type, but what we actually need to do is tell the engine that it should ask our
    class to handle custom actions for the type. To do that, we need to register our
    class with the Asset Tools module.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个类，它将在我们的自定义资产类型上显示自定义操作，但我们实际上需要做的是告诉引擎它应该询问我们的类来处理该类型的自定义操作。为了做到这一点，我们需要将我们的类与资产工具模块注册。
- en: The best way to do this is to register our class when our editor module is loaded,
    and unregister it when it is shut down.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的最好方法是，在我们加载编辑器模块时注册我们的类，并在关闭时注销它。
- en: As a result, we place our code into the `StartupModule` and `ShutdownModule` functions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将我们的代码放入`StartupModule`和`ShutdownModule`函数中。
- en: Inside `StartupModule`, we load the Asset Tools module using Module Manager.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartupModule`内部，我们使用模块管理器加载资产工具模块。
- en: With the module loaded, we create a new shared pointer that references an instance
    of our custom Asset actions class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块加载后，我们创建一个新的共享指针，它引用我们的自定义资产操作类的一个实例。
- en: All we need to do then is call `AssetModule.RegisterAssetTypeActions` and pass
    in an instance of our actions class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是调用`AssetModule.RegisterAssetTypeActions`并传入我们的操作类的一个实例。
- en: We then need to store a reference to that `Actions` instance so that we can
    unregister it later.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要存储对那个`Actions`实例的引用，以便我们可以在以后注销它。
- en: The sample code for this recipe uses an array of all the created asset actions
    in case we want to add custom actions for other classes as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例代码使用所有创建的资产操作的数组，以防我们还想为其他类添加自定义操作。
- en: Within `ShutdownModule`, we again retrieve an instance of the Asset Tools module.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`中，我们再次检索资产工具模块的一个实例。
- en: Using a range-based for loop, we iterate over the array of `Actions` instances
    that we populated earlier and call `UnregisterAssetTypeActions`, passing in our `Actions` class
    so it can be unregistered.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于范围的for循环，我们遍历我们之前填充的`Actions`实例数组，并调用`UnregisterAssetTypeActions`，传入我们的`Actions`类以便它可以被注销。
- en: With our class registered, the editor has been instructed to ask our registered
    class if it can handle assets that are right-clicked on.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类注册后，编辑器已被指示询问我们的注册类是否可以处理右键单击的资产。
- en: If the asset is of the Custom Asset class, then its `StaticClass` will match
    the one returned by `GetSupportedClass`. The editor will then call `GetActions`,
    and display the menu with the alterations made by our implementation of that function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资产是自定义资产类，那么它的`StaticClass`将与`GetSupportedClass`返回的相匹配。然后编辑器将调用`GetActions`，并显示我们对该函数实现所做的更改的菜单。
- en: When the `CustomAssetAction` button is clicked, our custom `MyCustomAssetContext_Clicked` function
    will be called via the delegate that we created.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`CustomAssetAction`按钮时，我们的自定义`MyCustomAssetContext_Clicked`函数将通过我们创建的委托被调用。
- en: Creating new console commands
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的控制台命令
- en: 'During development, console commands can be very helpful by allowing a developer
    or tester to easily bypass content or disable the mechanics that are irrelevant
    to the current test being run. The most common way to implement this is via console
    commands, which can invoke functions during runtime. The console can be accessed
    using the tilde key (`~`) or the equivalent in the upper-left area of the alphanumeric
    zone of your keyboard:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，控制台命令可以通过允许开发人员或测试人员轻松绕过内容或禁用与当前正在运行的测试无关的机制而非常有帮助。实现这种功能最常见的方式是通过控制台命令，它们可以在运行时调用函数。您可以使用波浪键（`~`）或键盘数字区左上角的对等键访问控制台：
- en: '![](img/fc5a434d-25b5-4071-8ef7-bbbad9ac670c.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc5a434d-25b5-4071-8ef7-bbbad9ac670c.jpg)'
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already followed the *Creating a new editor module* recipe, do
    so, as this recipe will need a place to initialize and register the console command.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有遵循*创建新的编辑器模块*配方，请这样做，因为这个配方需要一个初始化和注册控制台命令的地方。
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open your editor module''s header file (`Chapter_10Editor.h`) and add the following
    code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的编辑器模块的头文件（`Chapter_10Editor.h`）并添加以下代码：
- en: '[PRE22]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code within the implementation of `StartupModule`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StartupModule`的实现中添加以下代码：
- en: '[PRE23]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside `ShutdownModule`, add the following code:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`内部添加以下代码：
- en: '[PRE24]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the following function in the editor module (`Chapter_10Editor.h`):'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器模块（`Chapter_10Editor.h`）中实现以下函数：
- en: '[PRE25]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile your code and launch the editor.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: Play the level, and then hit the tilde key to bring up the console.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩完关卡后，按波浪键打开控制台。
- en: 'Type `DisplayTestCommandWindow` and hit *Enter*:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `DisplayTestCommandWindow` 并按 *Enter*：
- en: '![](img/639eb05b-4ada-4f76-96ed-3e94259015d3.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/639eb05b-4ada-4f76-96ed-3e94259015d3.png)'
- en: 'You should see our tutorial window open up:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到我们的教程窗口打开：
- en: '![](img/f08671c4-aad4-4102-85ab-e0906f8a10ca.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f08671c4-aad4-4102-85ab-e0906f8a10ca.jpg)'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Console commands are usually provided by a module. The best way to get the module
    to create the command when it is loaded is to place the code in the `StartupModule` method.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台命令通常由一个模块提供。要使模块在加载时创建命令，最好的方法是将代码放在 `StartupModule` 方法中。
- en: '`IConsoleManager` is the module that contains the console functionality for
    the engine.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`IConsoleManager` 是包含引擎控制台功能的模块。'
- en: As it is a sub-module of the core module, we don't need to add any additional
    information to the build scripts to link in additional modules.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个核心模块的子模块，我们不需要在构建脚本中添加任何额外的信息来链接额外的模块。
- en: To call functions within the console manager, we need to get a reference to
    the current instance of `IConsoleManager` that is being used by the engine. To
    do so, we invoke the static `Get` function, which returns a reference to the module
    in a similar way to a singleton.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制台管理器中调用函数，我们需要获取引擎正在使用的 `IConsoleManager` 当前实例的引用。为此，我们调用静态 `Get` 函数，它以类似单例的方式返回模块的引用。
- en: '`RegisterConsoleCommand` is the function that we can use to add a new console
    command and make it available in the console:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterConsoleCommand` 是我们可以用来添加新的控制台命令并使其在控制台中可用的函数：'
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The parameters for the function are as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数如下：
- en: '`Name`: The actual console command that will be typed by users. It should not
    include spaces.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：用户将输入的实际控制台命令。它不应包含空格。'
- en: '`Help`: The tooltip that appears when users are looking at the command in the
    console. If your console command takes arguments, this is a good place to display
    usage information to users.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Help`：当用户在控制台中查看命令时出现的工具提示。如果你的控制台命令接受参数，这是一个向用户显示使用信息的好地方。'
- en: '`Command`: This is the actual function delegate that will be executed when
    the user types in the command.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`：这是当用户输入命令时将被实际执行的函数委托。'
- en: '`Flags`: These flags control the visibility of the command in a shipping build,
    and are also used for console variables. `ECVF_Default` specifies the default
    behavior wherein the command is visible, and has no restrictions on availability
    in a release build.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flags`：这些标志控制了在发布构建中命令的可见性，也用于控制台变量。`ECVF_Default` 指定了默认行为，其中命令是可见的，并且在发布构建中没有可用性的限制。'
- en: To create an instance of the appropriate delegate, we use the `CreateRaw` static
    function on the `FConsoleCommand` delegate type. This lets us bind a raw C++ function
    to the delegate. The extra argument that is supplied after the function reference,
    the `FString``"Test Command Window"`, is a compile-time defined parameter that
    is passed to the delegate so that the end user doesn't have to specify the window
    name.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建适当委托的实例，我们使用 `FConsoleCommand` 委托类型的 `CreateRaw` 静态函数。这使我们能够将原始 C++ 函数绑定到委托。在函数引用之后提供的额外参数，`FString`
    `"Test Command Window"`，是一个编译时定义的参数，传递给委托，这样最终用户就不需要指定窗口名称。
- en: The second console command, `DisplayUserSpecifiedWindow`, is one that demonstrates
    the use of arguments with console commands.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个控制台命令，`DisplayUserSpecifiedWindow`，展示了如何使用控制台命令的参数。
- en: The primary difference with this console command, aside from the different name
    for users to invoke it, is the use of `FConsoleCommandWithArgsDelegate` and the `CreateLambda` function
    on it in particular.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与此控制台命令的主要区别，除了用户调用它的名称不同之外，还在于特别使用了 `FConsoleCommandWithArgsDelegate` 和其上的
    `CreateLambda` 函数。
- en: This function allows us to bind an anonymous function to a delegate. It's particularly
    handy when you want to wrap or adapt a function so that its signature matches
    that of a particular delegate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许我们将匿名函数绑定到委托。当你想要包装或适配一个函数，使其签名与特定委托匹配时，这特别有用。
- en: In our particular use case, the type of `FConsoleCommandWithArgsDelegate` specifies
    that the function should take a `const TArray` of `FStrings`. Our `DisplayWindow` function
    takes a single `FString` to specify the window title, so we need to somehow concatenate
    all the arguments of the console command into a single `FString` to use as our
    window title.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定用例中，`FConsoleCommandWithArgsDelegate` 的类型指定了该函数应接受一个 `const TArray` 的
    `FStrings`。我们的 `DisplayWindow` 函数接受一个 `FString` 参数来指定窗口标题，因此我们需要以某种方式将控制台命令的所有参数连接成一个单一的
    `FString`，用作我们的窗口标题。
- en: The lambda function allows us to do that before passing the `FString` onto the
    actual `DisplayWindow` function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数允许我们在将 `FString` 传递给实际的 `DisplayWindow` 函数之前完成这一操作。
- en: The first line of the function, `[&](const TArray<FString>& Args)`, specifies
    that this lambda or anonymous function wants to capture the context of the declaring
    function by reference by including the ampersand in the capture options, `[&]`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一行 `[&](const TArray<FString>& Args)` 指定这个 lambda 或匿名函数想要通过引用捕获声明函数的上下文，通过在捕获选项中包含
    ampersand 实现，`[&]`。
- en: The second part is the same as a normal function declaration, specifying that
    our lambda takes in `const Tarray`, which contains an FString as a parameter called `Args`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分与正常函数声明相同，指定我们的 lambda 接受一个 `const Tarray`，它包含一个名为 `Args` 的 `FString` 参数。
- en: Within the lambda body, we create a new `FString` and concatenate the strings
    that make up our arguments together, adding a space between them to separate them
    so that we don't get a title without spaces.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 lambda 体内部，我们创建一个新的 `FString` 并将构成我们参数的字符串连接在一起，在它们之间添加一个空格以分隔它们，这样我们就不得到没有空格的标题。
- en: It uses a range-based `for` loop for brevity to loop over them all and perform
    the concatenation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用基于范围的 `for` 循环来简化代码，以便遍历所有项并执行连接操作。
- en: Once they're all concatenated, we use the `this` pointer (captured by the `&` operator
    we mentioned earlier) to invoke `DisplayWindow` with our new title.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们全部连接起来，我们使用 `this` 指针（由我们之前提到的 `&` 运算符捕获）调用 `DisplayWindow` 并使用我们的新标题。
- en: For our module to remove the console command when it is unloaded, we need to
    maintain a reference to the console command object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的模块在卸载时移除控制台命令，我们需要保持对控制台命令对象的引用。
- en: To achieve this, we create a member variable in the module of type `IConsoleCommand*`,
    called `DisplayTestCommand`. When we execute the `RegisterConsoleCommand` function,
    it returns a pointer to the console command object that we can use as a handle
    later.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们在模块中创建了一个成员变量，类型为 `IConsoleCommand*`，名为 `DisplayTestCommand`。当我们执行
    `RegisterConsoleCommand` 函数时，它返回一个指向控制台命令对象的指针，我们可以将其用作后续的句柄。
- en: This allows us to enable or disable console commands at runtime based on gameplay
    or other factors.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在运行时根据游戏玩法或其他因素启用或禁用控制台命令。
- en: Within `ShutdownModule`, we check to see if `DisplayTestCommand` refers to a
    valid console command object. If it does, we get a reference to the `IConsoleManager` object
    and call `UnregisterConsoleCommand`, passing in the pointer that we stored earlier
    in our call to `RegisterConsoleCommand`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ShutdownModule` 中，我们检查 `DisplayTestCommand` 是否指向一个有效的控制台命令对象。如果是，我们就获取 `IConsoleManager`
    对象的引用并调用 `UnregisterConsoleCommand`，传入我们在调用 `RegisterConsoleCommand` 时之前存储的指针。
- en: The call to `UnregisterConsoleCommand` deletes the `IConsoleCommand` instance
    via the passed-in pointer, so we don't need to `deallocate` the memory ourselves
    – we just reset `DisplayTestCommand` to `nullptr` so that we can be sure that
    the old pointer doesn't dangle.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnregisterConsoleCommand` 的调用通过传入的指针删除 `IConsoleCommand` 实例，因此我们不需要自己 `deallocate`
    内存 - 我们只需将 `DisplayTestCommand` 重置为 `nullptr`，这样我们就可以确保旧的指针不会悬空。'
- en: The `DisplayWindow` function takes in the window title as an `FString` parameter.
    This allows us to either use a console command that takes arguments to specify
    the title, or a console command that uses payload parameters to hard-code the
    title for other commands.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayWindow` 函数接受一个 `FString` 参数作为窗口标题。这允许我们使用接受参数来指定标题的控制台命令，或者使用有效载荷参数来为其他命令硬编码标题的控制台命令。'
- en: The function itself uses a function called `SNew()` to allocate and create an `SWindow` object.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数本身使用一个名为 `SNew()` 的函数来分配和创建一个 `SWindow` 对象。
- en: '`SWindow` is a Slate Window, a top-level window that uses the Slate UI framework.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWindow` 是一个 Slate 窗口，一个使用 Slate UI 框架的最高级窗口。'
- en: Slate uses the `Builder` design pattern to allow for easy configuration of the
    new window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Slate 使用 `Builder` 设计模式来允许轻松配置新窗口。
- en: The `Title`, `ClientSize`, `SupportsMaximize`, and `SupportsMinimize` functions
    that are used here are all member functions of `SWindow`, and they return a reference
    to an `SWindow` (usually, the same object that the method was invoked on, but
    sometimes, a new object is constructed with the new configuration).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`Title`、`ClientSize`、`SupportsMaximize`和`SupportsMinimize`函数都是`SWindow`的成员函数，并返回一个`SWindow`的引用（通常，是方法被调用的同一个对象，但有时会使用新的配置构造一个新对象）。
- en: The fact that all these member methods return a reference to the configured
    object allows us to chain these method invocations together to create the desired
    object in the right configuration.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，所有这些成员方法都返回配置对象的引用，这使得我们可以将这些方法调用串联起来，以正确的配置创建所需的对象。
- en: The functions used in `DisplayWindow` create a new top-level Window that has
    a title based on the function parameter. It is 800 x 400 pixels wide, and cannot
    be maximized or minimized.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DisplayWindow`中使用的函数创建了一个具有基于函数参数标题的新顶级窗口。它宽800 x 400像素，不能最大化或最小化。
- en: With our new Window created, we retrieve a reference to the main application
    frame module. If the top-level window for the editor exists and is valid, we add
    our new window instance as a child of that top-level window.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的新窗口后，我们检索主应用程序框架模块的引用。如果编辑器的顶级窗口存在且有效，我们将我们的新窗口实例添加为该顶级窗口的子窗口。
- en: To do this, we retrieve a reference to the Slate interface and call `AddWindowAsNativeChild` to
    insert our window in the hierarchy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们检索Slate接口的引用并调用`AddWindowAsNativeChild`将我们的窗口插入到层次结构中。
- en: If there isn't a valid top-level window, we don't need to add our new window
    as a child of anything, so we can simply call `AddWindow` and pass in our new
    window instance.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有有效的顶级窗口，我们不需要将我们的新窗口作为任何内容的子窗口添加，因此我们可以简单地调用`AddWindow`并传入我们的新窗口实例。
- en: See also
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling
    Events and Delegates*, to learn more about delegates. It explains payload variables
    in greater detail.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第5章[处理事件和委托](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，了解更多关于委托的信息。它更详细地解释了有效载荷变量。
- en: For more information on Slate, refer to [Chapter 11](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml),
    *Working with UE4 APIs*.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Slate的信息，请参考第11章[使用UE4 API工作](a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml)。
- en: Creating a new graph pin visualizer for Blueprint
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为蓝图创建新的图形引脚可视化器
- en: 'Within the Blueprint system, we can use instances of our `MyCustomAsset` class
    as variables, provided we mark that class as a `BlueprintType` in its `UCLASS` macro.
    However, by default, our new asset is simply treated as a `UObject`, and we can''t
    access any of its members:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图系统中，我们可以将我们的`MyCustomAsset`类的实例用作变量，前提是我们将其标记为`BlueprintType`，在它的`UCLASS`宏中。然而，默认情况下，我们的新资产被简单地视为`UObject`，我们无法访问其任何成员：
- en: '![](img/71c51dd0-1db5-4ab5-9c9e-45a433e1f2fd.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71c51dd0-1db5-4ab5-9c9e-45a433e1f2fd.jpg)'
- en: 'For some types of assets, we might wish to enable in-line editing of literal
    values in the same way that classes such as `FVector` support the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的资产，我们可能希望启用与`FVector`等类支持的类似方式的内联编辑字面值：
- en: '![](img/d2f07c2a-77ee-4333-aec6-47facbe0b76f.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2f07c2a-77ee-4333-aec6-47facbe0b76f.jpg)'
- en: To enable this, we need to use a **Graph Pin** visualizer. This recipe will
    show you how to enable in-line editing of an arbitrary type using a custom widget
    defined by you.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，我们需要使用一个**图形引脚**可视化器。这个菜谱将向您展示如何使用您定义的自定义小部件启用任意类型的内联编辑。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we will update the `MyCustomAsset` class to be editable in Blueprints
    and reflect what we''ll be doing in this recipe. Go to `MyCustomAsset.h` and update
    it to the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将更新`MyCustomAsset`类，使其在蓝图编辑器中可编辑，并反映我们将在这个菜谱中执行的操作。前往`MyCustomAsset.h`并更新为以下代码：
- en: '[PRE27]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the `Chapter_10Editor` folder, create a new file called `MyCustomAssetPinFactory.h` .
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Chapter_10Editor`文件夹中，创建一个名为`MyCustomAssetPinFactory.h`的新文件。
- en: 'Inside the header, add the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件内部，添加以下代码：
- en: '[PRE28]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create another header file called `SGraphPinCustomAsset.h`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`SGraphPinCustomAsset.h`的头部文件：
- en: '[PRE29]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement `SGraphPinCustomAsset` by creating the `.cpp` file:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`.cpp`文件实现`SGraphPinCustomAsset`：
- en: '[PRE30]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Regenerate your Visual Studio project.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新生成您的Visual Studio项目。
- en: Add `#include "MyCustomAssetPinFactory.h"` to the `Chapter_10Editor.h` module
    implementation file.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`#include "MyCustomAssetPinFactory.h"`添加到`Chapter_10Editor.h`模块实现文件中。
- en: 'Add the following member to the editor module class (`FChapter_10EditorModule`):'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员添加到编辑模块类（`FChapter_10EditorModule`）中：
- en: '[PRE31]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open `Chapter_10Editor.cpp` and then add the following to `StartupModule()`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter_10Editor.cpp`，然后在`StartupModule()`中添加以下代码：
- en: '[PRE32]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also add the following code to `ShutdownModule()`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在`ShutdownModule()`中添加以下代码：
- en: '[PRE33]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Compile your code and launch the editor.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Create a new Function inside of the Level Blueprint by clicking on the plus
    symbol beside Functions within the My Blueprint panel:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“我的蓝图”面板中点击“函数”旁边的加号符号，在层级蓝图内创建一个新的`Function`：
- en: '![](img/c9415a2e-d1eb-406e-b064-ae473029c34d.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9415a2e-d1eb-406e-b064-ae473029c34d.png)'
- en: 'Add an input parameter:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个输入参数：
- en: '![](img/d9209b56-9fbb-400f-b97a-42fa2ba9a246.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9209b56-9fbb-400f-b97a-42fa2ba9a246.png)'
- en: 'Set its type to `MyCustomAsset` (Object Reference):'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类型设置为`MyCustomAsset`（对象引用）：
- en: '![](img/f5d2f5e2-1f18-45ea-b6bd-31ee1db119c9.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5d2f5e2-1f18-45ea-b6bd-31ee1db119c9.png)'
- en: 'In the Level Blueprint''s Event Graph, place an instance of your new function
    and verify that the input pin now has a custom visualizer in the form of a color
    picker:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级蓝图的事件图中放置你新函数的一个实例，并验证输入引脚现在是否有一个以颜色选择器形式的自定义可视化器：
- en: '![](img/779d7694-622f-4cd8-94ec-acdf6fffbc5c.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/779d7694-622f-4cd8-94ec-acdf6fffbc5c.png)'
- en: Newly added color picker visualizer
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的颜色选择器可视化器
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Customizing how objects appear as literal values on Blueprint pins is done using
    the `FGraphPanelPinFactory` class.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FGraphPanelPinFactory`类来定制对象在蓝图引脚上作为字面值出现的方式。
- en: 'This class defines a single virtual function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了一个单独的虚函数：
- en: '[PRE34]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function of `CreatePin`, as the name implies, is to create a new visual
    representation of the graph pin.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`CreatePin`函数的功能是创建图引脚的新视觉表示。
- en: It receives a `UEdGraphPin` instance. `UEdGraphPin` contains information about
    the object that the pin represents so that our factory class can make an informed
    decision regarding which visual representation we should be displaying.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个`UEdGraphPin`实例。`UEdGraphPin`包含关于引脚所表示的对象的信息，以便我们的工厂类可以做出明智的决定，关于我们应该显示哪种视觉表示。
- en: Within our implementation of the function, we check that the pin's type is our
    custom class.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数实现中，我们检查引脚的类型是否是我们自定义类。
- en: We do this by looking at the `PinSubCategoryObject` property, which contains
    a `UClass`, and comparing it to the `UClass` associated with our custom asset
    class.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看`PinSubCategoryObject`属性，它包含一个`UClass`，并将其与我们的自定义资产类关联的`UClass`进行比较来做这件事。
- en: If the pin's type meets our conditions, we return a new shared pointer to a
    Slate Widget, which is the visual representation of our object.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引脚的类型符合我们的条件，我们返回一个新的共享指针到Slate Widget，这是我们对象的视觉表示。
- en: If the pin is of the wrong type, we return a null pointer to indicate a failed
    state.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引脚类型不正确，我们返回一个空指针以指示失败状态。
- en: The next class, `SGraphPinCustomAsset`, is the Slate Widget class, which is
    a visual representation of our object as a literal.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类`SGraphPinCustomAsset`是Slate Widget类，它是我们对象作为字面值的视觉表示。
- en: It inherits from `SGraphPin`, the base class for all graph pins.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 它继承自`SGraphPin`，这是所有图引脚的基类。
- en: The `SGraphPinCustomAsset` class has a `Construct` function, which is called
    when the widget is created.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`SGraphPinCustomAsset`类有一个`Construct`函数，当创建小部件时被调用。'
- en: It also implements some functions from the parent class: `GetPinColor()` and `GetDefaultValueWidget()`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 它还实现了父类的一些函数：`GetPinColor()`和`GetDefaultValueWidget()`。
- en: The last function that is defined is `ColorPicked`, a handler for when a user
    selects a color in our custom pin.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个定义的函数是`ColorPicked`，它是当用户在我们的自定义引脚中选择颜色时的处理程序。
- en: In the implementation of our custom class, we initialize our custom pin by calling
    the default implementation of `Construct`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自定义类的实现中，我们通过调用`Construct`的默认实现来初始化我们的自定义引脚。
- en: The role of `GetDefaultValueWidget` is to actually create the widget that is
    the custom representation of our class, and return it to the engine code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDefaultValueWidget`的作用实际上是创建我们类的自定义表示的控件，并将其返回给引擎代码。'
- en: In our implementation, it creates a new `SColorPicker` instance – we want the
    user to be able to select a color and store the hex-based representation of that
    color inside the `FString` property in our custom class.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，它创建了一个新的`SColorPicker`实例——我们希望用户能够选择一种颜色，并将该颜色的十六进制表示存储在我们自定义类的`FString`属性中。
- en: This `SColorPicker` instance has a property called `OnColorCommitted` – this
    is a slate event that can be assigned to a function on an object instance.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SColorPicker`实例有一个名为`OnColorCommitted`的属性——这是一个可以分配给对象实例上函数的slate事件。
- en: Before returning our new `SColorPicker`, we link `OnColorCommitted` to the `ColorPicked` function
    on this current object so that it will be called if the user selects a new color.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回我们的新`SColorPicker`之前，我们将`OnColorCommitted`链接到当前对象上的`ColorPicked`函数，以便如果用户选择新的颜色，它将被调用。
- en: The `ColorPicked` function receives the selected color as an input parameter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorPicked`函数接收所选颜色作为输入参数。'
- en: Because this widget is used when there's no object connected to the pin we are
    associated with, we can't simply set the property on the associated object to
    the desired color string.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当没有对象连接到我们关联的引脚时使用此小部件，所以我们不能简单地将关联对象的属性设置为所需的颜色字符串。
- en: We need to create a new instance of our custom asset class, and we do that by
    using the `NewObject` template function.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建我们自定义资产类的新实例，这是通过使用`NewObject`模板函数来实现的。
- en: This function behaves similarly to the `SpawnActor` function we discussed in
    other chapters, and initializes a new instance of the specified class before returning
    a pointer to it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的行为类似于我们在其他章节中讨论的`SpawnActor`函数，并在返回指针之前初始化指定类的新实例。
- en: With a new instance in hand, we can set its `ColorName` property. `FLinearColors` can
    be converted into `FColor` objects, which define a `ToHex()` function that returns
    an `FString` with the hexadecimal representation of the color that was selected
    on the new widget.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有新实例后，我们可以设置其`ColorName`属性。`FLinearColors`可以转换为`FColor`对象，这些对象定义了一个`ToHex()`函数，该函数返回一个包含所选颜色的十六进制表示的`FString`。
- en: Finally, we need to actually place our new object instance into the graph so
    that it will be referenced when the graph is executed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的新对象实例实际放置在图中，以便在图执行时被引用。
- en: To achieve this, we need to access the graph pin object that we represent, and
    use the `GetSchema` function. This function returns the Schema for the graph that
    owns the node that contains our pin.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要访问我们代表的图引脚对象，并使用`GetSchema`函数。此函数返回拥有包含我们的引脚的节点的图的Schema。
- en: The Schema contains the actual values that correspond to graph pins, and is
    a key element during graph evaluation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 模式包含与图引脚对应的实际值，并且在图评估期间是一个关键元素。
- en: Now that we have access to the Schema, we can set the default value for the
    pin that our widget represents. This value will be used during graph evaluation
    if the pin isn't connected to another pin, and acts like a default value that's
    provided during a function definition in C++.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问模式，我们可以设置我们的小部件所代表的引脚的默认值。如果引脚未连接到另一个引脚，则此值将在图评估期间使用，并像在C++函数定义期间提供的默认值一样起作用。
- en: As with all the extensions we've made in this chapter, there has to be some
    sort of initialization or registration to tell the engine to defer to our custom
    implementation before using its default inbuilt representation.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章中做出的所有扩展一样，必须有一些初始化或注册，告诉引擎在使用其默认内置表示之前先使用我们的自定义实现。
- en: To do this, we need to add a new member to our editor module to store our `PinFactory` class
    instance.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要向我们的编辑器模块添加一个新成员来存储我们的`PinFactory`类实例。
- en: During `StartupModule`, we create a new shared pointer that references an instance
    of our `PinFactory` class.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartupModule`期间，我们创建一个新的共享指针，它引用我们的`PinFactory`类的一个实例。
- en: We store it inside the editor module's member so that it can be unregistered
    later. Then, we call `FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)` to
    tell the engine to use our `PinFactory` to create the visual representation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其存储在编辑器模块的成员中，以便以后可以注销。然后，我们调用`FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)`来告诉引擎使用我们的`PinFactory`来创建视觉表示。
- en: During `ShutdownModule`, we unregister the pin factory using `UnregisterVisualPinFactory`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShutdownModule`期间，我们使用`UnregisterVisualPinFactory`注销引脚工厂。
- en: Finally, we delete our old `PinFactory` instance by calling `Reset()` on the
    shared pointer that contains it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在包含它的共享指针上调用`Reset()`来删除我们的旧的`PinFactory`实例。
- en: Inspecting types with custom Details panels
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义详细面板检查类型
- en: 'By default, `UObject`-derived UAssets open in the generic property editor.
    It looks as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，由`UObject`派生的UAssets将在通用属性编辑器中打开。它看起来如下：
- en: '![](img/1cd21451-0090-40c5-b897-5525655f98ee.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cd21451-0090-40c5-b897-5525655f98ee.png)'
- en: However, at times, you may wish for custom widgets so that you can edit the
    properties on your class. To facilitate this, Unreal supports **Details Customization**,
    which is the focus of this recipe.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能希望有自定义小部件，以便你可以编辑你类上的属性。为此，Unreal支持**详细定制**，这是本菜谱的重点。
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: From the `Chapter_10Editor` folder, create two new files called `MyCustomAssetDetailsCustomization.h` and `MyCustomAssetDetailsCustomization.cpp`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Chapter_10Editor` 文件夹中，创建两个名为 `MyCustomAssetDetailsCustomization.h` 和 `MyCustomAssetDetailsCustomization.cpp`
    的新文件。
- en: Return to your project file and update your Visual Studio project. Once finished,
    open up the project in Visual Studio.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的项目文件并更新您的 Visual Studio 项目。完成后，在 Visual Studio 中打开项目。
- en: 'Add the following `#pragma` and `#includes` to the header (`MyCustomAssetDetailsCustomization.h`):'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `#pragma` 和 `#includes` 添加到头文件 (`MyCustomAssetDetailsCustomization.h`)：
- en: '[PRE35]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define our customization class, as follows:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义我们的自定义类：
- en: '[PRE36]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Below that, define the following additional class:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面，定义以下附加类：
- en: '[PRE37]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the implementation file, add the following includes at the top of the file:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中，在文件顶部添加以下包含：
- en: '[PRE38]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Afterwards, create an implementation for `CustomizeDetails`:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为 `CustomizeDetails` 创建一个实现：
- en: '[PRE39]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, create a definition for `ColorPicked`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为 `ColorPicked` 创建一个定义：
- en: '[PRE40]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Beneath all of the scripts in `MyCustomAssetDetailsCustomization.cpp`, add
    the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyCustomAssetDetailsCustomization.cpp` 中的所有脚本下方，添加以下代码：
- en: '[PRE41]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our editor module source file (`Chapter_10Editor.cpp`), add the following
    to your `#includes` in the `Chapter_10Editor.cpp` file:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的编辑器模块源文件 (`Chapter_10Editor.cpp`) 中，将以下内容添加到 `Chapter_10Editor.cpp` 文件中的
    `#includes`：
- en: '[PRE42]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following to the implementation of `StartupModule`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `StartupModule` 的实现中：
- en: '[PRE43]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following to `ShutdownModule`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `ShutdownModule`：
- en: '[PRE44]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compile your code and launch the editor. Create a new instance of `MyCustomAsset` via
    the Content Browser.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码并启动编辑器。通过内容浏览器创建 `MyCustomAsset` 的新实例。
- en: 'Double-click on it to verify that the default editor that comes up now shows
    your custom layout:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击它以验证现在出现的默认编辑器是否显示您的自定义布局：
- en: '![](img/27a2b2cf-7c4b-45ba-a188-6e3894e6c8e3.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27a2b2cf-7c4b-45ba-a188-6e3894e6c8e3.png)'
- en: How it works...
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Details Customization is performed through the `IDetailCustomization` interface,
    which developers can inherit when defining a class that customizes the way assets
    of a certain class are displayed.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `IDetailCustomization` 接口执行细节自定义，开发人员可以在定义自定义显示特定类资产方式的类时继承它。
- en: 'The main function that `IDetailCustomization` uses to allow for this process
    to occur is as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDetailCustomization` 主要使用以下功能来允许此过程发生：'
- en: '[PRE45]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Within our implementation of this function, we use methods on `DetailBuilder` that
    are passed in as parameters to get an array of all selected objects. The loop
    then scans those to ensure that at least one selected object is of the correct
    type.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们此函数的实现中，我们使用 `DetailBuilder` 上作为参数传递的方法来获取所有选中对象的数组。然后循环扫描这些对象以确保至少有一个选中对象是正确的类型。
- en: Customizing the representation of a class is done by calling methods on the `DetailBuilder` object.
    We create a new category for our details view by using the `EditCategory` function.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `DetailBuilder` 对象上调用方法来自定义类的表示。我们使用 `EditCategory` 函数创建一个新类别以用于我们的细节视图。
- en: The first parameter of the `EditCategory` function is the name of the category
    we are going to manipulate.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditCategory` 函数的第一个参数是我们将要操作的类别名称。'
- en: The second parameter is optional, and contains a potentially localized display
    name for the category.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，包含一个可能本地化的类别显示名称。
- en: The third parameter is the priority of the category. A higher priority means
    it is displayed further up the list.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是类别的优先级。优先级越高，它显示在列表中的位置越靠前。
- en: '`EditCategory` returns a reference to the category itself as `CategoryBuilder`,
    allowing us to chain additional method calls onto an invocation of `EditCategory`.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditCategory` 返回对类别的引用作为 `CategoryBuilder`，允许我们将额外的方法调用链接到 `EditCategory`
    的调用上。'
- en: As a result, we call `AddCustomRow()` on `CategoryBuilder`, which adds a new
    key-value pair to be displayed in the category.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `CategoryBuilder` 上调用 `AddCustomRow()`，这将在类别中添加一个新键值对以显示。
- en: Using the Slate syntax, we then specify that the row will contain a Vertical
    Box with a single center-aligned slot.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Slate 语法，我们指定该行将包含一个包含单个居中对齐槽的垂直框。
- en: Inside the slot, we create a color picker control and bind its `OnColorCommitted` delegate
    to our local `ColorPicked` event handler.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在槽内，我们创建一个颜色选择控件并将其 `OnColorCommitted` 代理绑定到我们本地的 `ColorPicked` 事件处理器。
- en: 'Of course, this requires us to define and implement `ColourPicked`. It has
    the following signature:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这需要我们定义和实现 `ColourPicked`。它具有以下签名：
- en: '[PRE46]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Inside the implementation of `ColorPicked`, we check to see if one of our selected
    assets was of the correct type, because, if at least one selected asset was correct,
    then `MyAsset` will be populated with a valid value.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ColorPicked`的实现中，我们检查是否我们选择的资产中有一个是正确的类型，因为如果至少有一个选定的资产是正确的，那么`MyAsset`将被填充为一个有效的值。
- en: Assuming we have a valid asset, we set the `ColorName` property to the hex string
    value corresponding to the color that was selected by the user.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个有效的资产，我们将`ColorName`属性设置为用户所选颜色的十六进制字符串值。
