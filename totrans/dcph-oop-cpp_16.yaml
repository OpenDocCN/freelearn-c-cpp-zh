- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Using the Observer Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to solve recurring types of
    coding problems by utilizing common design patterns. Design patterns will also
    enhance code maintenance and provide avenues for potential code reuse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们的探索之旅，旨在扩展您的 C++ 编程知识库，超越面向对象的概念，目标是让您能够通过利用常见的设计模式来解决重复出现的编程问题。设计模式还将增强代码维护性，并为潜在的代码重用提供途径。
- en: The goal of the fourth section of the book, beginning with this chapter, is
    to demonstrate and explain popular design patterns and idioms and learn how to
    implement them effectively in C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，本书的第四部分的目标是展示和解释流行的设计模式和惯用法，并学习如何在 C++ 中有效地实现它们。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Understanding the advantage of utilizing design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解利用设计模式的优势
- en: Understanding the Observer pattern and how it contributes to OOP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解观察者模式及其对面向对象编程的贡献
- en: Understanding how to implement the Observer pattern in C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在 C++ 中实现观察者模式
- en: By the end of this chapter, you will understand the utility of employing design
    patterns in your code, as well as understand the popular **Observer pattern**.
    We will see an example implementation of this pattern in C++. Utilizing common
    design patterns will help you become a more beneficial and valuable programmer
    by enabling you to embrace more sophisticated programming techniques.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将理解在代码中采用设计模式的价值，以及理解流行的**观察者模式**。我们将通过 C++ 中的示例实现来展示这个模式。利用常见的设计模式将帮助您成为一个更有益和有价值的程序员，使您能够掌握更复杂的编程技术。
- en: Let’s increase our programming skillset by examining various design patterns,
    starting in this chapter with the Observer pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究各种设计模式来提高我们的编程技能集，从本章的观察者模式开始。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter16` in a file named `Chp16-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16)。每个完整程序示例都可以在
    GitHub 仓库中找到，位于相应章节标题（子目录）下的文件中，文件名对应章节编号，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述
    GitHub 目录下的 `Chapter16` 子目录中找到一个名为 `Chp16-Ex1.cpp` 的文件。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3A8ZWoy](https://bit.ly/3A8ZWoy).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址观看：[https://bit.ly/3A8ZWoy](https://bit.ly/3A8ZWoy)。
- en: Utilizing design patterns
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用设计模式
- en: '**Design patterns** represent a grouping of well-tested programming solutions
    for recurring types of programming conundrums. Design patterns represent the high-level
    concept of a design issue and how a generalized collaboration between classes
    can provide a solution that can be implemented in a variety of ways.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**代表了一组经过良好测试的编程解决方案，用于解决重复出现的编程难题。设计模式代表了设计问题的概念层面，以及类之间如何进行通用协作以提供多种实现方式的解决方案。'
- en: There are many well-identified design patterns that have been recognized and
    described in the past 25+ years of software development. We will look at some
    popular patterns in the remaining chapters of this book to give you a feel of
    how we can incorporate popular software design solutions into our coding arsenal
    of techniques.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去 25+ 年的软件开发中，已经识别和描述了许多公认的设计模式。我们将在本书的剩余章节中探讨一些流行的模式，以让您了解如何将流行的软件设计解决方案融入我们的技术编码库中。
- en: Why might we choose to utilize a design pattern? To start, once we have identified
    a type of programming problem, we can make use of a *tried and true* solution
    that other programmers have tested comprehensively. Additionally, once we employ
    a design pattern, other programmers immersing themselves in our code (for maintenance
    or future enhancements) will have a basic understanding of the techniques we have
    chosen, as core design patterns have become an industry standard.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么可能选择使用设计模式？首先，一旦我们确定了一种编程问题类型，我们可以使用其他程序员已经全面测试过的*经过验证的*解决方案。此外，一旦我们采用设计模式，其他沉浸在我们的代码中（用于维护或未来的增强）的程序员将对我们选择的技术有一个基本理解，因为核心设计模式已成为行业标准。
- en: Some of the earliest design patterns came about nearly 50 years ago, with the
    advent of the **Model-View-Controller** paradigm, later simplified at times to
    **Subject-View**. For example, Subject-View is a rudimentary pattern in which
    an object of interest (the **Subject**) will be loosely coupled with its method
    of display (its **View**). The Subject and its View communicate with a one-to-one
    association. Sometimes Subjects can have multiple Views, in which case the Subject
    is associated with many View objects. If one View changes, a state update can
    be sent to the Subject, who can then send necessary messages to the other Views
    so that they, too, can be updated to reflect how the new state may have modified
    their particular View.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最早的设计模式几乎在50年前出现，随着**模型-视图-控制器**（Model-View-Controller，简称MVC）范式的出现，后来有时简化为**主题-视图**。例如，主题-视图是一个基本的模式，其中感兴趣的物体（即**主题**）将与它的显示方法（即它的**视图**）松散耦合。主题和它的视图通过一对一的关联进行通信。有时主题可以有多个视图，在这种情况下，主题与多个视图对象相关联。如果一个视图发生变化，可以发送一个状态更新到主题，然后主题可以发送必要的消息到其他视图，以便它们也能更新以反映新的状态可能对其特定视图的修改。
- en: The original **Model-View-Controller** (**MVC**) pattern, emanating from early
    OOP languages such as Smalltalk, has a similar premise, except that a Controller
    object delegates events between the Model (that is, the Subject) and its View
    (or Views). These preliminary paradigms influenced early design patterns; the
    elements of Subject-View or MVC can be seen conceptually as a rudimentary basis
    for core design patterns today.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 来自早期面向对象语言（如Smalltalk）的原始**模型-视图-控制器**（MVC）模式有一个类似的假设，只不过是一个控制器对象在模型（即主题）和它的视图（或视图）之间委派事件。这些初步范式影响了早期的设计模式；主题-视图或MVC的元素可以从概念上被视为今天核心设计模式的基本基础。
- en: Many of the design patterns we will review in the remainder of this book will
    be adaptations of patterns originally described by the *Gang of Four* (Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides) in *Design Patterns, Elements
    of Reusable Object-Oriented Software*. We will apply and adapt these patterns
    to solve problems stemming from applications we have introduced in earlier chapters
    of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将回顾的许多设计模式将是*四人帮*（Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides）在《设计模式：可复用面向对象软件元素》中最初描述的模式的改编。我们将应用和改编这些模式来解决本书早期章节中介绍的应用程序产生的问题。
- en: Let’s begin our pursuit of understanding and utilizing popular design patterns
    by investigating a pattern in action. We will start with a behavioral pattern
    known as the **Observer pattern**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调查一个实际应用中的模式来开始我们对理解和利用流行设计模式的追求。我们将从一个被称为**观察者模式**的行为模式开始。
- en: Understanding the Observer pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: In the **Observer pattern**, an object of interest will maintain a list of observers
    who are interested in state updates of the main object. The observers will maintain
    a link to their object of interest. We will refer to the main object of interest
    as the **Subject**. The list of interested objects is known collectively as the
    **Observers**. The Subject will inform any Observer of relevant state changes.
    The Observers, once notified of any state changes of the Subject, will take any
    appropriate next action themselves (usually through a virtual function invoked
    on each Observer by the Subject).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在**观察者模式**中，一个感兴趣的物体将维护一个观察者的列表，这些观察者对主要物体的状态更新感兴趣。观察者将维护对其感兴趣物体的链接。我们将把感兴趣的物体称为**主题**。感兴趣物体的列表统称为**观察者**。主题将通知任何观察者相关的状态变化。一旦观察者被通知主题的任何状态变化，它们将自行采取任何适当的后续行动（通常是通过主题在每个观察者上调用虚拟函数来实现）。
- en: Already, we can imagine how an Observer pattern may be implemented using associations.
    In fact, the Observer represents a one-to-many association. The Subject, for example,
    may use an STL `list` (or `vector`) to collect a set of Observers. Each Observer
    will contain an association to the Subject. We can imagine an important operation
    on the Subject, corresponding to a state change in the Subject, issuing an update
    to its list of Observers to *notify* them of the state change. The `Notify()`
    method is, in fact, invoked when a Subject’s state changes and uniformly applies
    polymorphic Observer `Update()` methods on each of the Subject’s list of Observers.
    Before we get swept up in implementation, let’s consider the key components comprising
    the Observer pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 已经，我们可以想象如何使用关联来实现观察者模式。事实上，观察者代表了一对多关联。例如，主题可能使用STL `list`（或`vector`）来收集一组观察者。每个观察者都将包含对主题的关联。我们可以想象一个对主题的重要操作，对应于主题的状态变化，向其观察者列表发出更新，以*通知*它们状态变化。实际上，当主题的状态发生变化时，`Notify()`方法会被调用，并在主题的每个观察者列表上统一应用多态的观察者`Update()`方法。在我们陷入实现之前，让我们考虑构成观察者模式的关键组件。
- en: 'The Observer pattern will include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将包括以下内容：
- en: A Subject, or object of interest. The Subject will maintain a list of Observer
    objects (a many-sided association).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题，或感兴趣的物体。主题将维护一个观察者对象列表（多边关联）。
- en: A Subject will provide an interface to `Register()` or `Remove()` an Observer.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题将提供一个接口来`Register()`或`Remove()`观察者。
- en: A Subject will include a `Notify()` interface, which will update its Observers
    when the Subject’s state has changed. The Subject will `Notify()` Observers by
    calling a polymorphic `Update()` method on each Observer in its collection.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题将包括一个`Notify()`接口，当主题的状态发生变化时，将更新其观察者。主题将通过在其集合中的每个观察者上调用多态的`Update()`方法来`Notify()`观察者。
- en: An Observer class will be modeled as an abstract class (or interface).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者类将被建模为一个抽象类（或接口）。
- en: An Observer interface will provide an abstract, polymorphic `Update()` method
    to be called when its associated Subject has changed its state.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者接口将提供一个抽象的多态`Update()`方法，当其关联的主题改变其状态时将被调用。
- en: An association between each Observer to its Subject will be maintained in a
    concrete class, derived from Observer. Doing so will alleviate awkward casting
    (compared to maintaining the Subject link in the abstract Observer class).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个观察者与其主题之间的关联将在一个从观察者派生的具体类中维护。这样做将减轻尴尬的类型转换（与在抽象观察者类中维护主题链接相比）。
- en: Both classes will be able to maintain their current state.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个类都将能够维护它们当前的状态。
- en: The aforementioned `Subject` and `Observer` classes are specified generically
    so that they may be combined with a variety of concrete classes (mostly through
    inheritance) that desire to use the Observer pattern. A generic Subject and Observer
    provide a great opportunity for reuse. With a design pattern, many core elements
    of a pattern can often be set up more generically to allow for greater reuse of
    the code itself, not only the reuse in the concept of the solution (pattern).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`Subject`和`Observer`类被指定为通用类型，以便它们可以与各种具体的类（主要通过继承）结合使用，这些类希望使用观察者模式。通用的主题和观察者提供了很好的重用机会。在设计模式中，模式的核心元素通常可以更通用地设置，以便允许代码本身的重用，而不仅仅是解决方案（模式）概念的重用。
- en: Let’s move forward to see a sample implementation of the Observer pattern.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看观察者模式的示例实现。
- en: Implementing the Observer pattern
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: To implement the Observer pattern, we will first need to define our `Subject`
    and `Observer` classes. We will then need to derive concrete classes from these
    classes to incorporate our application specifics and to put our pattern in motion.
    Let’s get started!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现观察者模式，我们首先需要定义我们的`Subject`和`Observer`类。然后，我们需要从这些类派生出具体的类，以包含我们的应用程序特定内容，并使模式生效。让我们开始吧！
- en: Creating an Observer, Subject, and domain-specific derived classes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建观察者、主题和特定领域的派生类
- en: In our example, we will create `Subject` and `Observer` classes to establish
    the framework for *registering* an `Observer` with a `Subject` and for the `Subject`
    to `Notify()` its set of observers of a state change it may have. We will then
    derive from these base classes descendent classes we are accustomed to seeing
    – `Course` and `Student`, where `Course` will be our concrete `Subject` and `Student`
    will become our concrete `Observer`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建 `Subject` 和 `Observer` 类来建立将 `Observer` 注册到 `Subject` 的框架，以及 `Subject`
    通知其观察者可能的状态变化的机制。然后，我们将从这些基类派生出我们习惯看到的派生类 - `Course` 和 `Student`，其中 `Course` 将是我们的具体
    `Subject`，而 `Student` 将成为我们的具体 `Observer`。
- en: The application we will model will involve a course registration system and
    the concept of a waitlist. As we have seen before in *Question 2* of [*Chapter
    10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association, Aggregation,
    and Composition*, we will model a `Student` having an association to many `Course`
    instances, and a `Course` having an association to many `Student` instances. The
    Observer pattern will come into play when we model our waitlist.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要模拟的应用将涉及课程注册系统和等待名单的概念。正如我们在 *第10章* 的 *问题2* 中所看到的，*实现关联、聚合和组合*，我们将模拟一个 `Student`
    与多个 `Course` 实例的关联，以及一个 `Course` 与多个 `Student` 实例的关联。当我们模拟等待名单时，观察者模式将发挥作用。
- en: Our `Course` class will be derived from `Subject`. The list of observers that
    our `Course` will inherit will represent the `Student` instances on this `Course`’s
    waitlist. The `Course` will also have a list of `Student` instances, representing
    students who have been successfully enrolled in the course at hand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Course` 类将派生自 `Subject`。我们将继承的观察者列表将代表此 `Course` 的等待名单上的 `Student` 实例。`Course`
    还将有一个 `Student` 实例列表，代表成功注册了当前课程的 `Student`。
- en: Our `Student` class will be derived from both `Person` and `Observer`. The `Student`
    will include a list of `Course` instances in which that `Student` is currently
    enrolled. The `Student` will also have a data member, `waitListedCourse`, which
    will correspond to an association to a `Course` that the `Student` is waiting
    to add. This *waitlisted* `Course` represents the `Subject` from which we will
    receive notifications. A notification will correspond to a state change indicating
    that the `Course` now has room for a `Student` to add the `Course`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Student` 类将派生自 `Person` 和 `Observer`。`Student` 将包括一个 `Course` 实例列表，其中包含该
    `Student` 当前注册的课程。`Student` 还将有一个数据成员 `waitListedCourse`，它对应于一个 `Student` 正在等待添加的
    `Course` 的关联。这个 *等待名单* 的 `Course` 代表我们将从中接收通知的 `Subject`。一个通知将对应于一个状态变化，表明 `Course`
    现在有空间让一个 `Student` 添加该 `Course`。
- en: It is from `Observer` that `Student` will inherit the polymorphic operation
    `Update()`, which will correspond to the `Student` being notified that a spot
    is now open in the `Course`. Here, in `Student::Update()`, we will include the
    mechanics to add a student’s `waitListedCourse` (provided the course is open and
    has available seats). If the addition is successful, we will release the `Student`
    from the course’s waitlist (the list of observers inherited by `Course` from `Subject`).
    Naturally, the `Student` will be added to the current student list in the `Course`
    and the `Course` will appear in that student’s current course list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student` 将从 `Observer` 继承多态操作 `Update()`，这对应于 `Student` 被通知 `Course` 中现在有空位。在这里，在
    `Student::Update()` 中，我们将包括添加学生的 `waitListedCourse`（前提是课程开放且有可用座位）的机制。如果添加成功，我们将从课程的等待名单（`Course`
    从 `Subject` 继承的观察者列表）中释放 `Student`。自然地，`Student` 将被添加到 `Course` 的当前学生名单中，并且该 `Course`
    将出现在该学生的当前课程列表中。'
- en: Specifying the Observer and the Subject
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定观察者和主题
- en: 'Let’s break down our example into components, starting with the pair of classes
    to specify our `Observer` and `Subject`. This complete program can be found in
    our GitHub:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的示例分解成组件，从指定我们的 `Observer` 和 `Subject` 的类对开始。完整的程序可以在我们的 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous class definition, we introduce our abstract `Observer` class.
    Here, we include an `observerState` and protected constructors to initialize this
    state. We include a protected `SetState()` method to update this state from the
    scope of a derived class. We also include a public `GetState()` method. The addition
    of `GetState()` will facilitate implementation within our `Subject`’s `Notify()`
    method by allowing us to easily check whether the state of our `Observer` has
    changed. Though state information has historically been added to derived classes
    of both `Observer` and `Subject`, we will instead generalize state information
    in these base classes. This will allow our derived classes to remain more pattern-independent
    and instead focused on the essence of the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们引入了我们的抽象`Observer`类。在这里，我们包括一个`observerState`和受保护的构造函数来初始化这个状态。我们包括一个受保护的`SetState()`方法，从派生类的范围更新这个状态。我们还包括一个公共的`GetState()`方法。`GetState()`的添加将有助于在`Subject`的`Notify()`方法中的实现，因为它允许我们轻松地检查我们的`Observer`的状态是否已更改。尽管状态信息传统上被添加到`Observer`和`Subject`的派生类中，但我们将在这两个基类中泛化状态信息。这将允许我们的派生类保持更独立于模式，并专注于应用程序的本质。
- en: Notice that our destructor is virtual, and we introduce an abstract method `virtual
    void Update() = 0;` to specify the interface our `Subject` will invoke on its
    list of observers to delegate updates to these `Observer` instances.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的析构函数是虚的，我们引入了一个抽象方法`virtual void Update() = 0;`来指定`Subject`将在其观察者列表上调用该接口，以将这些更新委托给这些`Observer`实例。
- en: 'Now, let’s take a look at our `Subject` base class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`Subject`基类：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned `Subject` class definition, we see that our `Subject`
    includes an STL `list` to collect its `Observer` instances. It also includes the
    `subjectState` and a counter to reflect the number of observers. Also, we include
    a data member to keep track of an uncorrupted iterator. We’ll see this will be
    handy once we erase an element (`list::erase()` is an operation that will invalidate
    a current iterator).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Subject`类定义中，我们看到我们的`Subject`包括一个STL `list`来收集其`Observer`实例。它还包括`subjectState`和一个计数器，以反映观察者的数量。此外，我们还包括一个数据成员来跟踪一个未损坏的迭代器。我们将看到这将在我们删除一个元素时很有用（`list::erase()`是一个将使当前迭代器无效的操作）。
- en: Our `Subject` class will also have protected constructors and a `SetState()`
    method, which initializes or sets the `Subject`’s state. Though this class is
    not technically abstract (it does not contain a pure virtual function), its constructors
    are protected to simulate an abstract class; this class is only intended to be
    constructed as a subobject within a derived class instance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Subject`类也将拥有受保护的构造函数和一个`SetState()`方法，该方法用于初始化或设置`Subject`的状态。尽管这个类在技术上不是抽象的（它不包含纯虚函数），但其构造函数是受保护的，以模拟抽象类；这个类仅打算在派生类实例内部作为子对象进行构造。
- en: In the public interface, we have some access functions to get the current state
    or number of observers. We also have a virtual destructor, and virtual functions
    for `Register()`, `Release()`, and `Notify()`. We will provide implementations
    for the latter three methods at this base class level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共接口中，我们有一些访问函数来获取当前状态或观察者的数量。我们还有一个虚析构函数，以及`Register()`、`Release()`和`Notify()`的虚函数。我们将在基类级别提供后三个方法的实现。
- en: 'Let’s next take a look at the default implementations of `Register()`, `Release()`,
    and `Notify()` in our `Subject` base class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Subject`基类中`Register()`、`Release()`和`Notify()`的默认实现：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned `Subject` member functions, let’s begin by examining the
    `void Subject::Register(Observer *)` method. Here, we simply add the `Observer
    *` specified as a parameter to our STL `list` of observers (and increase the counter
    for the number of observers).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Subject`成员函数中，让我们首先检查`void Subject::Register(Observer *)`方法。在这里，我们只是将作为参数指定的`Observer
    *`添加到我们的STL观察者`list`中（并增加观察者数量的计数器）。
- en: Next, let’s consider the inverse of `Register()` by reviewing `void Subject::Release(Observer
    *)`. Here, we iterate through our list of observers until we find the one we are
    seeking. We then call `list::erase()` on that current item, set our `found` flag
    to `true` (to leave the loop), and decrement the number of observers. Also, notice
    that we save the return value of `list::erase()`, which is an updated (and valid)
    iterator to the list of observers. The iterator `iter` in the loop has been invalidated
    with our call to `list::erase()`. We save this revised iterator in a data member
    `newIter` so that we can access it shortly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑`Register()`的逆操作，通过审查`void Subject::Release(Observer *)`。在这里，我们遍历观察者列表，直到找到我们正在寻找的观察者。然后我们在当前项上调用`list::erase()`，将我们的`found`标志设置为`true`（以退出循环），并减少观察者的数量。注意，我们还保存了`list::erase()`的返回值，这是一个更新（且有效）的观察者列表迭代器。循环中的迭代器`iter`在我们的`list::erase()`调用后已失效。我们将这个修订的迭代器保存在数据成员`newIter`中，以便我们稍后可以访问它。
- en: Finally, let’s take a look at the `Notify()` method in `Subject`. This method
    will be called once there is a state change in the `Subject`. The goal will be
    to `Update()` all observers on the `Subject`’s observer list. To do just that,
    we look through our list. One by one, we grab an `Observer` with the list iterator
    `iter`. We call `Update()` on the current `Observer` with `(*iter)->Update();`.
    We can tell whether the update has been a success for a given `Observer` by checking
    the observer’s state using `if ((*iter)->GetState() == State::Success)`. With
    a state of *Success*, we know the observer’s actions will have caused the `Release()`
    function we just reviewed to be called on itself. Because the `list::erase()`
    used in `Release()` has invalidated the iterator, we now get the correct and revised
    iterator using `iter = newIter;`. Finally, outside of the loop, we call `Update()`
    on the last item in the list of observers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`Subject`中的`Notify()`方法。当`Subject`中发生状态变化时，此方法将被调用。目标是更新`Subject`的观察者列表中的所有观察者。为了做到这一点，我们遍历我们的列表。一个接一个地，我们使用列表迭代器`iter`获取一个`Observer`。我们通过`(*iter)->Update();`在当前`Observer`上调用`Update()`。我们可以通过使用`if
    ((*iter)->GetState() == State::Success)`检查观察者的状态来判断给定的`Observer`的更新是否成功。当状态为*Success*时，我们知道观察者的操作将导致我们刚刚审查的`Release()`函数被调用。因为`Release()`中使用的`list::erase()`已使迭代器无效，所以我们现在使用`iter
    = newIter;`获取正确和修订的迭代器。最后，在循环外部，我们在观察者列表的最后一个项目上调用`Update()`。
- en: Deriving concrete classes from Subject and Observer
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Subject和Observer派生具体类
- en: 'Let’s continue moving forward with this example by taking a look at our concrete
    classes derived from `Subject` or `Observer`. Let’s start with `Course`, derived
    from `Subject`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看从`Subject`或`Observer`派生的具体类来继续这个例子。让我们从`Subject`派生的`Course`开始：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our aforementioned `Course` class, we include data members for the course
    title and number as well as for the total number of students currently enrolled.
    We also have our list of students currently enrolled, indicated by `Student *students[MAXNUMBERSTUDENTS];`.
    Additionally, keep in mind that we inherit the STL `list` of observers from our
    `Subject` base class. This list of `Observer` instances will represent the `Student`
    instances comprising our waitlist (of students) for the `Course`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前提到的`Course`类中，我们包括课程标题和编号的数据成员，以及当前注册的学生总数。我们还有当前注册的学生列表，表示为`Student *students[MAXNUMBERSTUDENTS];`。此外，请记住，我们从`Subject`基类继承了STL
    `list`观察者。这个`Observer`实例的列表将代表我们的`Course`（学生）等待列表。
- en: The `Course` class additionally includes a constructor, a virtual destructor,
    and simple access functions. Note that the virtual destructor has more work to
    do than shown – if a `Course` destructs, we must remember to first remove (but
    not delete) `Student` instances from the `Course`. Our `bool Course::AddStudent(Student
    *)` interface will allow us to add a `Student` to a `Course`. Of course, we should
    ensure that the `Student` has not already added the `Course` in the body of this
    method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Course`类还包括一个构造函数、一个虚析构函数和简单的访问函数。请注意，虚析构函数要做的工作比显示的更多——如果`Course`被销毁，我们必须记住首先从`Course`中移除（但不删除）`Student`实例。我们的`bool
    Course::AddStudent(Student *)`接口将允许我们将`Student`添加到`Course`中。当然，我们应该确保`Student`没有在这个方法的主体中添加`Course`。'
- en: Our `void Course::Open();` method will be invoked on a `Course` to indicate
    that the course is now available to add students. Here, we will first set the
    state to `Course::OpenForEnrollment` (clearly indicating *Open for Enrollment*
    with the enumerated type) and then call `Notify()`. Our `Notify()` method in base
    class `Subject` loops through each `Observer`, calling polymorphic `Update()`
    on each observer. Each `Observer` is a `Student`; `Student::Update()` will allow
    each `Student` on the waitlist to try to add the `Course`, which now is open to
    receive students. With a successful addition to the course’s current student list,
    a `Student` will then request `Release()` of its position on the waitlist (as
    an `Observer`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `void Course::Open();` 方法将在 `Course` 对象上被调用，以指示该课程现在可以添加学生。在这里，我们首先将状态设置为
    `Course::OpenForEnrollment`（通过枚举类型明确表示 *Open for Enrollment*），然后调用 `Notify()`。我们的基类
    `Subject` 中的 `Notify()` 方法会遍历每个 `Observer`，对每个观察者调用多态的 `Update()` 方法。每个 `Observer`
    是一个 `Student`；`Student::Update()` 将允许等待名单上的每个 `Student` 尝试添加 `Course`，现在该课程对学生开放。一旦成功添加到课程的当前学生名单中，`Student`
    将请求其在等待名单上的位置 `Release()`（作为一个 `Observer`）。
- en: 'Next, let’s take a look at our class definition for `Student`, our concrete
    class derived from both `Person` and `Observer`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下我们的 `Student` 类定义，这是我们从 `Person` 和 `Observer` 派生出来的具体类：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Briefly reviewing the aforementioned class definition for `Student`, we can
    see that this class is derived from both `Person` and `Observer` using multiple
    inheritance. Let’s assume our `Person` class is as we have used in the past many
    times.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾一下之前提到的 `Student` 类定义，我们可以看到这个类通过多继承同时从 `Person` 和 `Observer` 派生出来。让我们假设我们的
    `Person` 类与我们过去多次使用的是一样的。
- en: In addition to the usual components of our `Student` class, we add the data
    member `Course *waitListedCourse;`, which will model the association to our `Subject`.
    This data member will model the idea of a `Course` that we would very much like
    to add, yet currently cannot, that is, a *waitlisted* course. Here, we are implementing
    the concept of a single waitlisted course, but we could easily expand the example
    to include a list supporting multiple waitlisted courses. Notice that this link
    (data member) is declared in the form of the derived type, `Course`, not the base
    type, `Subject`. This is typical in the Observer pattern and will help us avoid
    dreaded down-casting as we override our `Update()` method in `Student`. It is
    through this link that we will conduct our interaction with our `Subject` and
    the means by which we will receive updates from our `Subject` as it changes states.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们 `Student` 类的常规组件外，我们添加了数据成员 `Course *waitListedCourse;`，它将模拟与我们的 `Subject`
    的关联。这个数据成员将模拟我们非常希望添加，但目前无法添加的 `Course` 的概念，即一个 *等待名单* 的课程。在这里，我们正在实现单个等待名单课程的概念，但我们可以轻松地扩展示例以包括支持多个等待名单课程的列表。请注意，这个链接（数据成员）是以派生类型
    `Course` 的形式声明的，而不是基类型 `Subject`。这在观察者模式中很典型，并且将帮助我们避免在 `Student` 中重写 `Update()`
    方法时的讨厌的向下转型。正是通过这个链接，我们将与我们的 `Subject` 进行交互，以及我们接收来自 `Subject` 更新状态的方式。
- en: We also notice that we have `virtual void Update() override;` prototyped in
    `Student`. This method will allow us to override the pure virtual `Update()` method
    specified by `Observer`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，我们在 `Student` 中声明了 `virtual void Update() override;`。这个方法将允许我们重写由 `Observer`
    指定的纯虚 `Update()` 方法。
- en: 'Next, let’s review a selection of the various new member functions for `Student`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下 `Student` 的各种新成员函数：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s review the previously listed member functions. Since we are accustomed
    to most of the necessary components and mechanics in the `Student` class, we will
    focus on the newly added `Student` methods, starting with an alternate constructor.
    In this constructor, let us assume that we set most of the data members as usual.The
    key additional lines of code here are `waitListedCourse = c;` to set our waitlist
    entry to the desired `Course` (`Subject`), as well as `c->Register(this);`, where
    we add the `Student` (`Observer`) to the `Subject`’s list (the formal waitlist
    for the course).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前列出的成员函数。由于我们已经习惯了 `Student` 类中的大多数必要组件和机制，我们将重点关注新添加的 `Student` 方法，从备用构造函数开始。在这个构造函数中，让我们假设我们像往常一样设置了大多数数据成员。这里的关键代码行是
    `waitListedCourse = c;`，将我们的等待名单条目设置为所需的 `Course`（`Subject`），以及 `c->Register(this);`，其中我们将
    `Student`（`Observer`）添加到 `Subject` 的列表（课程的正式等待名单）中。
- en: Next, in our `bool Student::AddCourse(Course *)` method, we first check that
    we haven’t exceeded our maximum allowed courses. If not, we go through the mechanics
    to add the association to link a `Student` and `Course` in both directions. That
    is, `courses[currentNumCourses++] = c;` to have the student’s current course list
    contain an association to the new `Course`, as well as `c->AddStudent(this);`
    to ask the current `Course` to add the `Student` (namely, `this`) to its enrolled
    student list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `bool Student::AddCourse(Course *)` 方法中，我们首先检查我们是否没有超过允许的最大课程数。如果没有，我们就进行添加关联的机制，以便在两个方向上链接一个
    `Student` 和 `Course`。也就是说，`courses[currentNumCourses++] = c;` 使得学生的当前课程列表包含对新
    `Course` 的关联，以及 `c->AddStudent(this);` 请求当前 `Course` 将 `Student`（即 `this`）添加到其注册学生名单中。
- en: 'Let’s continue by reviewing the remainder of the new member functions for `Student`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续回顾 `Student` 的新成员函数的其余部分：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Continuing with the remainder of our previously mentioned `Student` member functions,
    next, in our polymorphic `void Student::Update()` method, we conduct the desired
    adding of a waitlisted course. Recall, `Notify()` will be called when there is
    a state change on our `Subject` (`Course`). One such state change may be when
    a `Course` is *Open for Enrollment*, or perhaps a state of *New Space Available*
    now exists following a `Student` dropping the `Course`. `Notify()` then calls
    `Update()` on each `Observer`. Our `Update()` has been overridden in `Student`
    to get the state of the `Course` (`Subject`). If the state indicates the `Course`
    is now *Open for Enrollment* or has a *New Space Available*, we try `AddCourse(waitListedCourse);`.
    If this is a success, we set the state of the `Student` (`Observer`) to `StudentState::AddSuccess`
    (*Add Success*) to indicate that we have been successful in our `Update()`, which
    means we’ve added the `Course`. Next, since we have added the desired course to
    our current course list, we can now remove ourselves from the `Course`’s waitlist.
    That is, we will want to remove ourselves (`Student`) as an `Observer` from the
    `Subject` (the `Course`’s waitlist) using `waitListedCourse->Release(this);`.
    Now that we have added our desired waitlisted course, we can also remove our link
    to the `Subject` using `waitListedCourse = nullptr;`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前提到的 `Student` 成员函数的其余部分，接下来，在我们的多态 `void Student::Update()` 方法中，我们执行所需的添加等待名单中的课程。回想一下，当我们的
    `Subject`（课程）发生状态变化时，将调用 `Notify()`。一种这样的状态变化可能是当 `Course` 对注册开放，或者当 `Student`
    放弃 `Course` 后，现在存在一个 *New Space Available*（新空间可用）的状态。`Notify()` 然后对每个 `Observer`
    调用 `Update()`。我们的 `Update()` 在 `Student` 中被重写以获取 `Course`（主题）的状态。如果状态表明课程现在对注册开放或有一个
    *New Space Available*，我们尝试 `AddCourse(waitListedCourse);`。如果成功，我们将 `Student`（观察者）的状态设置为
    `StudentState::AddSuccess`（添加成功）以指示我们在 `Update()` 中成功，这意味着我们已添加了课程。接下来，由于我们已经将期望的课程添加到我们的当前课程列表中，我们现在可以自己从
    `Course` 的等待名单中移除。也就是说，我们将使用 `waitListedCourse->Release(this);` 将自己（学生）作为 `Observer`
    从 `Subject`（课程的等待名单）中移除。现在我们已经添加了我们的期望等待名单课程，我们也可以使用 `waitListedCourse = nullptr;`
    移除我们与 `Subject` 的链接。
- en: Lastly, our aforementioned `Student` code includes a method to print the currently
    enrolled courses of the `Student` with `void Student::PrintCourses();`. This method
    is pretty straightforward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们之前提到的 `Student` 代码包括一个方法来打印 `Student` 当前注册的课程，即 `void Student::PrintCourses();`。这个方法相当直接。
- en: Bringing the pattern components together
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Let us now bring all of our various components together by taking a look at
    our `main()` function to see how our Observer pattern is orchestrated:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过查看我们的 `main()` 函数来查看我们的观察者模式是如何编排的：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reviewing our aforementioned `main()` function, we first instantiate three `Course`
    instances. We next instantiate five `Student` instances, utilizing a constructor
    that allows us to provide an initial `Course` that each `Student` would like to
    add when course registration commences. Note that these `Students` (`Observers`)
    will be added to the waitlist for their desired courses (`Subject`). Here, a `Subject`
    (`Course`) will have a list of `Observer`s (`Student`s) who wish to add the course
    when registration opens.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前提到的 `main()` 函数，我们首先创建了三个 `Course` 实例。接下来，我们创建了五个 `Student` 实例，使用一个构造函数，允许我们在课程注册开始时为每个
    `Student` 提供一个他们想要添加的初始 `Course`。请注意，这些 `Students`（观察者）将被添加到他们期望课程的等待名单（主题）中。在这里，一个
    `Subject`（课程）将有一个 `Observer`（学生）列表，这些学生希望在注册开放时添加该课程。
- en: Next, we see that a `Course` that many `Student` instances desire becomes *Open
    for Enrollment* for registration with `c1->Open();`. `Course::Open()` sets the
    state of the `Subject` to `CourseState::OpenForEnrollment`, easily indicating
    the course is *Open for Enrollment*, and then calls `Notify()`. As we know, `Subject::Notify()`
    will call `Update()` on the `Subject`’s list of observers. It is here that an
    initial waitlisted `Course` instance will be added to a student’s schedule and
    be subsequently removed as an `Observer` from the `Subject`’s waitlist.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到许多`Student`实例渴望的`Course`变为*开放注册*，可以通过`c1->Open();`进行注册。`Course::Open()`将`Subject`的状态设置为`CourseState::OpenForEnrollment`，这很容易表明课程是*开放注册*的，然后调用`Notify()`。正如我们所知，`Subject::Notify()`将在`Subject`的观察者列表上调用`Update()`。正是在这里，一个初始的等待注册的`Course`实例将被添加到学生的日程表中，并随后作为`Observer`从`Subject`的等待列表中移除。
- en: Now that registration is open, each `Student` will try to add more courses in
    the usual manner using `bool Student::AddCourse(Course *)`, such as with `s1.AddCourse(c2);`.
    Should a `Course` be full, the `Student` will be added to the `Course`’s waitlist
    (modeled as the inherited `Subject`’s list of observers, which are in fact, derived
    `Student` types). Recall, `Course` inherits from `Subject`, which keeps a list
    of students interested in adding a particular course (the waitlist of observers).
    When the `Course` state changes to *New Space Available*, students on the waitlist
    (via data member `observers`) will be notified, and the `Update()` method on each
    `Student` will subsequently call `AddCourse()` for that `Student`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注册已经开放，每个`Student`将尝试使用`bool Student::AddCourse(Course *)`以通常的方式添加更多课程，例如`s1.AddCourse(c2);`。如果一个`Course`已满，`Student`将被添加到`Course`的等待列表中（作为继承自`Subject`的观察者列表，实际上是由派生自`Student`类型的观察者组成）。回想一下，`Course`继承自`Subject`，它保留了一个对添加特定课程感兴趣的学生列表（观察者的等待列表）。当`Course`状态变为*新空间可用*时，等待列表中的学生（通过数据成员`observers`）将被通知，并且每个`Student`上的`Update()`方法将随后调用该`Student`的`AddCourse()`方法。
- en: Once we have added various courses, we will then see each `Course` print its
    roster of students, such as `c2->PrintStudents()`. Likewise, we will then see
    each `Student` print the respective courses in which they are enrolled, such as
    with `s5.PrintCourses();`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了各种课程，我们就会看到每个`Course`打印其学生名单，例如`c2->PrintStudents()`。同样，我们也会看到每个`Student`打印他们所注册的课程，例如使用`s5.PrintCourses()`。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have now seen an implementation of the Observer pattern. We have folded the
    more generic `Subject` and `Observer` classes into the framework of classes we
    are accustomed to seeing, namely `Course`, `Person`, and `Student`. Let us now
    briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了观察者模式的实现。我们将更通用的`Subject`和`Observer`类折叠到我们习惯看到的类框架中，即`Course`、`Person`和`Student`。现在，让我们简要回顾一下与模式相关的学习内容，然后再进入下一章。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have begun our pursuit to become better C++ programmers
    by expanding our repertoire beyond OOP concepts to include the utilization of
    design patterns. Our primary goal is to enable you to solve recurring types of
    coding problems using *tried and true* solutions by applying common design patterns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始追求成为更好的 C++ 程序员，通过将我们的知识库从面向对象的概念扩展到包括设计模式的应用。我们的主要目标是让您能够通过应用常见的模式，使用**经过验证和可靠的**解决方案来解决重复出现的编程问题。
- en: We have first understood the purpose of design patterns and the advantage of
    employing them in our code. We have then specifically understood the premise behind
    the Observer pattern and how it contributes to OOP. Finally, we have taken a look
    at how we may implement the Observer pattern in C++.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先理解了设计模式的目的以及在我们代码中采用它们的优势。然后，我们具体理解了观察者模式背后的前提以及它是如何贡献于面向对象的。最后，我们查看了一下如何在
    C++ 中实现观察者模式。
- en: Utilizing common design patterns, such as the Observer pattern, will help you
    more easily solve recurring types of programming problems in a manner understood
    by other programmers. A key tenant in OOP is to strive for the reuse of components
    whenever possible. By utilizing design patterns, you will be contributing to reusable
    solutions with more sophisticated programming techniques.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 利用常见的模式，如观察者模式，将帮助您更轻松地以其他程序员能理解的方式解决重复出现的编程问题。面向对象的一个关键原则是尽可能追求组件的重用。通过利用设计模式，您将为具有更复杂编程技术的可重用解决方案做出贡献。
- en: We are now ready to continue forward with our next design pattern in [*Chapter
    17*](B19087_17.xhtml#_idTextAnchor743), *Implementing the Factory Pattern*. Adding
    more patterns to our collection of skills makes us more versatile and valued programmers.
    Let’s continue forward!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好继续前进，进入我们的下一个设计模式[*第17章*](B19087_17.xhtml#_idTextAnchor743)，*实现工厂模式*。将更多模式添加到我们的技能集合中，使我们成为更灵活、更有价值的程序员。让我们继续前进！
- en: Questions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the online code for the example in this chapter as a starting point and
    the solution from a previous exercise (*Question 3*, *Chapter 10*, *Implementing
    Association, Aggregation, and Composition*):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以本章示例的在线代码作为起点，以及之前练习的解决方案（*问题3*，*第10章*，*实现关联、聚合和组合*）：
- en: Implement (or modify your previous) `Student::DropCourse()`. When a `Student`
    drops a `Course`, this event will cause the `Course` state to become state `2`,
    *New Space Available*. With the state change, `Notify()` will then be called on
    the `Course` (`Subject`), which will then `Update()` the list of observers (students
    on the waitlist). `Update()` will indirectly allow waitlisted `Student` instances,
    if any, to now add the `Course`.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现（或修改你之前的）`Student::DropCourse()`。当`Student`取消选课时，这个事件将导致`Course`状态变为状态`2`，*新空间可用*。随着状态的变化，`Notify()`将被调用在`Course`（主题）上，然后它将`Update()`观察者列表（等待名单上的学生）。`Update()`将间接允许等待名单上的`Student`实例（如果有），现在可以添加该课程。
- en: Lastly, in `DropCourse()`, remember to remove the dropped course from the student’s
    current course list.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`DropCourse()`中，记得从学生的当前课程列表中移除已取消的课程。
- en: What other examples can you imagine that might easily incorporate the Observer
    pattern?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象出哪些其他例子可以轻松地融入观察者模式？
