- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to solve recurring types of
    coding problems by utilizing common design patterns. Design patterns will also
    enhance code maintenance and provide avenues for potential code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the fourth section of the book, beginning with this chapter, is
    to demonstrate and explain popular design patterns and idioms and learn how to
    implement them effectively in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the advantage of utilizing design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Observer pattern and how it contributes to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to implement the Observer pattern in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the utility of employing design
    patterns in your code, as well as understand the popular **Observer pattern**.
    We will see an example implementation of this pattern in C++. Utilizing common
    design patterns will help you become a more beneficial and valuable programmer
    by enabling you to embrace more sophisticated programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our programming skillset by examining various design patterns,
    starting in this chapter with the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter16` in a file named `Chp16-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3A8ZWoy](https://bit.ly/3A8ZWoy).'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Design patterns** represent a grouping of well-tested programming solutions
    for recurring types of programming conundrums. Design patterns represent the high-level
    concept of a design issue and how a generalized collaboration between classes
    can provide a solution that can be implemented in a variety of ways.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many well-identified design patterns that have been recognized and
    described in the past 25+ years of software development. We will look at some
    popular patterns in the remaining chapters of this book to give you a feel of
    how we can incorporate popular software design solutions into our coding arsenal
    of techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Why might we choose to utilize a design pattern? To start, once we have identified
    a type of programming problem, we can make use of a *tried and true* solution
    that other programmers have tested comprehensively. Additionally, once we employ
    a design pattern, other programmers immersing themselves in our code (for maintenance
    or future enhancements) will have a basic understanding of the techniques we have
    chosen, as core design patterns have become an industry standard.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the earliest design patterns came about nearly 50 years ago, with the
    advent of the **Model-View-Controller** paradigm, later simplified at times to
    **Subject-View**. For example, Subject-View is a rudimentary pattern in which
    an object of interest (the **Subject**) will be loosely coupled with its method
    of display (its **View**). The Subject and its View communicate with a one-to-one
    association. Sometimes Subjects can have multiple Views, in which case the Subject
    is associated with many View objects. If one View changes, a state update can
    be sent to the Subject, who can then send necessary messages to the other Views
    so that they, too, can be updated to reflect how the new state may have modified
    their particular View.
  prefs: []
  type: TYPE_NORMAL
- en: The original **Model-View-Controller** (**MVC**) pattern, emanating from early
    OOP languages such as Smalltalk, has a similar premise, except that a Controller
    object delegates events between the Model (that is, the Subject) and its View
    (or Views). These preliminary paradigms influenced early design patterns; the
    elements of Subject-View or MVC can be seen conceptually as a rudimentary basis
    for core design patterns today.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the design patterns we will review in the remainder of this book will
    be adaptations of patterns originally described by the *Gang of Four* (Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides) in *Design Patterns, Elements
    of Reusable Object-Oriented Software*. We will apply and adapt these patterns
    to solve problems stemming from applications we have introduced in earlier chapters
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin our pursuit of understanding and utilizing popular design patterns
    by investigating a pattern in action. We will start with a behavioral pattern
    known as the **Observer pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the **Observer pattern**, an object of interest will maintain a list of observers
    who are interested in state updates of the main object. The observers will maintain
    a link to their object of interest. We will refer to the main object of interest
    as the **Subject**. The list of interested objects is known collectively as the
    **Observers**. The Subject will inform any Observer of relevant state changes.
    The Observers, once notified of any state changes of the Subject, will take any
    appropriate next action themselves (usually through a virtual function invoked
    on each Observer by the Subject).
  prefs: []
  type: TYPE_NORMAL
- en: Already, we can imagine how an Observer pattern may be implemented using associations.
    In fact, the Observer represents a one-to-many association. The Subject, for example,
    may use an STL `list` (or `vector`) to collect a set of Observers. Each Observer
    will contain an association to the Subject. We can imagine an important operation
    on the Subject, corresponding to a state change in the Subject, issuing an update
    to its list of Observers to *notify* them of the state change. The `Notify()`
    method is, in fact, invoked when a Subject’s state changes and uniformly applies
    polymorphic Observer `Update()` methods on each of the Subject’s list of Observers.
    Before we get swept up in implementation, let’s consider the key components comprising
    the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Observer pattern will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Subject, or object of interest. The Subject will maintain a list of Observer
    objects (a many-sided association).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Subject will provide an interface to `Register()` or `Remove()` an Observer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Subject will include a `Notify()` interface, which will update its Observers
    when the Subject’s state has changed. The Subject will `Notify()` Observers by
    calling a polymorphic `Update()` method on each Observer in its collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Observer class will be modeled as an abstract class (or interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Observer interface will provide an abstract, polymorphic `Update()` method
    to be called when its associated Subject has changed its state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An association between each Observer to its Subject will be maintained in a
    concrete class, derived from Observer. Doing so will alleviate awkward casting
    (compared to maintaining the Subject link in the abstract Observer class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both classes will be able to maintain their current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned `Subject` and `Observer` classes are specified generically
    so that they may be combined with a variety of concrete classes (mostly through
    inheritance) that desire to use the Observer pattern. A generic Subject and Observer
    provide a great opportunity for reuse. With a design pattern, many core elements
    of a pattern can often be set up more generically to allow for greater reuse of
    the code itself, not only the reuse in the concept of the solution (pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to see a sample implementation of the Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the Observer pattern, we will first need to define our `Subject`
    and `Observer` classes. We will then need to derive concrete classes from these
    classes to incorporate our application specifics and to put our pattern in motion.
    Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Observer, Subject, and domain-specific derived classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we will create `Subject` and `Observer` classes to establish
    the framework for *registering* an `Observer` with a `Subject` and for the `Subject`
    to `Notify()` its set of observers of a state change it may have. We will then
    derive from these base classes descendent classes we are accustomed to seeing
    – `Course` and `Student`, where `Course` will be our concrete `Subject` and `Student`
    will become our concrete `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: The application we will model will involve a course registration system and
    the concept of a waitlist. As we have seen before in *Question 2* of [*Chapter
    10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association, Aggregation,
    and Composition*, we will model a `Student` having an association to many `Course`
    instances, and a `Course` having an association to many `Student` instances. The
    Observer pattern will come into play when we model our waitlist.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Course` class will be derived from `Subject`. The list of observers that
    our `Course` will inherit will represent the `Student` instances on this `Course`’s
    waitlist. The `Course` will also have a list of `Student` instances, representing
    students who have been successfully enrolled in the course at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Student` class will be derived from both `Person` and `Observer`. The `Student`
    will include a list of `Course` instances in which that `Student` is currently
    enrolled. The `Student` will also have a data member, `waitListedCourse`, which
    will correspond to an association to a `Course` that the `Student` is waiting
    to add. This *waitlisted* `Course` represents the `Subject` from which we will
    receive notifications. A notification will correspond to a state change indicating
    that the `Course` now has room for a `Student` to add the `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: It is from `Observer` that `Student` will inherit the polymorphic operation
    `Update()`, which will correspond to the `Student` being notified that a spot
    is now open in the `Course`. Here, in `Student::Update()`, we will include the
    mechanics to add a student’s `waitListedCourse` (provided the course is open and
    has available seats). If the addition is successful, we will release the `Student`
    from the course’s waitlist (the list of observers inherited by `Course` from `Subject`).
    Naturally, the `Student` will be added to the current student list in the `Course`
    and the `Course` will appear in that student’s current course list.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Observer and the Subject
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s break down our example into components, starting with the pair of classes
    to specify our `Observer` and `Subject`. This complete program can be found in
    our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we introduce our abstract `Observer` class.
    Here, we include an `observerState` and protected constructors to initialize this
    state. We include a protected `SetState()` method to update this state from the
    scope of a derived class. We also include a public `GetState()` method. The addition
    of `GetState()` will facilitate implementation within our `Subject`’s `Notify()`
    method by allowing us to easily check whether the state of our `Observer` has
    changed. Though state information has historically been added to derived classes
    of both `Observer` and `Subject`, we will instead generalize state information
    in these base classes. This will allow our derived classes to remain more pattern-independent
    and instead focused on the essence of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our destructor is virtual, and we introduce an abstract method `virtual
    void Update() = 0;` to specify the interface our `Subject` will invoke on its
    list of observers to delegate updates to these `Observer` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our `Subject` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `Subject` class definition, we see that our `Subject`
    includes an STL `list` to collect its `Observer` instances. It also includes the
    `subjectState` and a counter to reflect the number of observers. Also, we include
    a data member to keep track of an uncorrupted iterator. We’ll see this will be
    handy once we erase an element (`list::erase()` is an operation that will invalidate
    a current iterator).
  prefs: []
  type: TYPE_NORMAL
- en: Our `Subject` class will also have protected constructors and a `SetState()`
    method, which initializes or sets the `Subject`’s state. Though this class is
    not technically abstract (it does not contain a pure virtual function), its constructors
    are protected to simulate an abstract class; this class is only intended to be
    constructed as a subobject within a derived class instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the public interface, we have some access functions to get the current state
    or number of observers. We also have a virtual destructor, and virtual functions
    for `Register()`, `Release()`, and `Notify()`. We will provide implementations
    for the latter three methods at this base class level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s next take a look at the default implementations of `Register()`, `Release()`,
    and `Notify()` in our `Subject` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `Subject` member functions, let’s begin by examining the
    `void Subject::Register(Observer *)` method. Here, we simply add the `Observer
    *` specified as a parameter to our STL `list` of observers (and increase the counter
    for the number of observers).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s consider the inverse of `Register()` by reviewing `void Subject::Release(Observer
    *)`. Here, we iterate through our list of observers until we find the one we are
    seeking. We then call `list::erase()` on that current item, set our `found` flag
    to `true` (to leave the loop), and decrement the number of observers. Also, notice
    that we save the return value of `list::erase()`, which is an updated (and valid)
    iterator to the list of observers. The iterator `iter` in the loop has been invalidated
    with our call to `list::erase()`. We save this revised iterator in a data member
    `newIter` so that we can access it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s take a look at the `Notify()` method in `Subject`. This method
    will be called once there is a state change in the `Subject`. The goal will be
    to `Update()` all observers on the `Subject`’s observer list. To do just that,
    we look through our list. One by one, we grab an `Observer` with the list iterator
    `iter`. We call `Update()` on the current `Observer` with `(*iter)->Update();`.
    We can tell whether the update has been a success for a given `Observer` by checking
    the observer’s state using `if ((*iter)->GetState() == State::Success)`. With
    a state of *Success*, we know the observer’s actions will have caused the `Release()`
    function we just reviewed to be called on itself. Because the `list::erase()`
    used in `Release()` has invalidated the iterator, we now get the correct and revised
    iterator using `iter = newIter;`. Finally, outside of the loop, we call `Update()`
    on the last item in the list of observers.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving concrete classes from Subject and Observer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s continue moving forward with this example by taking a look at our concrete
    classes derived from `Subject` or `Observer`. Let’s start with `Course`, derived
    from `Subject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned `Course` class, we include data members for the course
    title and number as well as for the total number of students currently enrolled.
    We also have our list of students currently enrolled, indicated by `Student *students[MAXNUMBERSTUDENTS];`.
    Additionally, keep in mind that we inherit the STL `list` of observers from our
    `Subject` base class. This list of `Observer` instances will represent the `Student`
    instances comprising our waitlist (of students) for the `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Course` class additionally includes a constructor, a virtual destructor,
    and simple access functions. Note that the virtual destructor has more work to
    do than shown – if a `Course` destructs, we must remember to first remove (but
    not delete) `Student` instances from the `Course`. Our `bool Course::AddStudent(Student
    *)` interface will allow us to add a `Student` to a `Course`. Of course, we should
    ensure that the `Student` has not already added the `Course` in the body of this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Our `void Course::Open();` method will be invoked on a `Course` to indicate
    that the course is now available to add students. Here, we will first set the
    state to `Course::OpenForEnrollment` (clearly indicating *Open for Enrollment*
    with the enumerated type) and then call `Notify()`. Our `Notify()` method in base
    class `Subject` loops through each `Observer`, calling polymorphic `Update()`
    on each observer. Each `Observer` is a `Student`; `Student::Update()` will allow
    each `Student` on the waitlist to try to add the `Course`, which now is open to
    receive students. With a successful addition to the course’s current student list,
    a `Student` will then request `Release()` of its position on the waitlist (as
    an `Observer`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at our class definition for `Student`, our concrete
    class derived from both `Person` and `Observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Briefly reviewing the aforementioned class definition for `Student`, we can
    see that this class is derived from both `Person` and `Observer` using multiple
    inheritance. Let’s assume our `Person` class is as we have used in the past many
    times.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the usual components of our `Student` class, we add the data
    member `Course *waitListedCourse;`, which will model the association to our `Subject`.
    This data member will model the idea of a `Course` that we would very much like
    to add, yet currently cannot, that is, a *waitlisted* course. Here, we are implementing
    the concept of a single waitlisted course, but we could easily expand the example
    to include a list supporting multiple waitlisted courses. Notice that this link
    (data member) is declared in the form of the derived type, `Course`, not the base
    type, `Subject`. This is typical in the Observer pattern and will help us avoid
    dreaded down-casting as we override our `Update()` method in `Student`. It is
    through this link that we will conduct our interaction with our `Subject` and
    the means by which we will receive updates from our `Subject` as it changes states.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that we have `virtual void Update() override;` prototyped in
    `Student`. This method will allow us to override the pure virtual `Update()` method
    specified by `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s review a selection of the various new member functions for `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s review the previously listed member functions. Since we are accustomed
    to most of the necessary components and mechanics in the `Student` class, we will
    focus on the newly added `Student` methods, starting with an alternate constructor.
    In this constructor, let us assume that we set most of the data members as usual.The
    key additional lines of code here are `waitListedCourse = c;` to set our waitlist
    entry to the desired `Course` (`Subject`), as well as `c->Register(this);`, where
    we add the `Student` (`Observer`) to the `Subject`’s list (the formal waitlist
    for the course).
  prefs: []
  type: TYPE_NORMAL
- en: Next, in our `bool Student::AddCourse(Course *)` method, we first check that
    we haven’t exceeded our maximum allowed courses. If not, we go through the mechanics
    to add the association to link a `Student` and `Course` in both directions. That
    is, `courses[currentNumCourses++] = c;` to have the student’s current course list
    contain an association to the new `Course`, as well as `c->AddStudent(this);`
    to ask the current `Course` to add the `Student` (namely, `this`) to its enrolled
    student list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue by reviewing the remainder of the new member functions for `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with the remainder of our previously mentioned `Student` member functions,
    next, in our polymorphic `void Student::Update()` method, we conduct the desired
    adding of a waitlisted course. Recall, `Notify()` will be called when there is
    a state change on our `Subject` (`Course`). One such state change may be when
    a `Course` is *Open for Enrollment*, or perhaps a state of *New Space Available*
    now exists following a `Student` dropping the `Course`. `Notify()` then calls
    `Update()` on each `Observer`. Our `Update()` has been overridden in `Student`
    to get the state of the `Course` (`Subject`). If the state indicates the `Course`
    is now *Open for Enrollment* or has a *New Space Available*, we try `AddCourse(waitListedCourse);`.
    If this is a success, we set the state of the `Student` (`Observer`) to `StudentState::AddSuccess`
    (*Add Success*) to indicate that we have been successful in our `Update()`, which
    means we’ve added the `Course`. Next, since we have added the desired course to
    our current course list, we can now remove ourselves from the `Course`’s waitlist.
    That is, we will want to remove ourselves (`Student`) as an `Observer` from the
    `Subject` (the `Course`’s waitlist) using `waitListedCourse->Release(this);`.
    Now that we have added our desired waitlisted course, we can also remove our link
    to the `Subject` using `waitListedCourse = nullptr;`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, our aforementioned `Student` code includes a method to print the currently
    enrolled courses of the `Student` with `void Student::PrintCourses();`. This method
    is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now bring all of our various components together by taking a look at
    our `main()` function to see how our Observer pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our aforementioned `main()` function, we first instantiate three `Course`
    instances. We next instantiate five `Student` instances, utilizing a constructor
    that allows us to provide an initial `Course` that each `Student` would like to
    add when course registration commences. Note that these `Students` (`Observers`)
    will be added to the waitlist for their desired courses (`Subject`). Here, a `Subject`
    (`Course`) will have a list of `Observer`s (`Student`s) who wish to add the course
    when registration opens.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see that a `Course` that many `Student` instances desire becomes *Open
    for Enrollment* for registration with `c1->Open();`. `Course::Open()` sets the
    state of the `Subject` to `CourseState::OpenForEnrollment`, easily indicating
    the course is *Open for Enrollment*, and then calls `Notify()`. As we know, `Subject::Notify()`
    will call `Update()` on the `Subject`’s list of observers. It is here that an
    initial waitlisted `Course` instance will be added to a student’s schedule and
    be subsequently removed as an `Observer` from the `Subject`’s waitlist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that registration is open, each `Student` will try to add more courses in
    the usual manner using `bool Student::AddCourse(Course *)`, such as with `s1.AddCourse(c2);`.
    Should a `Course` be full, the `Student` will be added to the `Course`’s waitlist
    (modeled as the inherited `Subject`’s list of observers, which are in fact, derived
    `Student` types). Recall, `Course` inherits from `Subject`, which keeps a list
    of students interested in adding a particular course (the waitlist of observers).
    When the `Course` state changes to *New Space Available*, students on the waitlist
    (via data member `observers`) will be notified, and the `Update()` method on each
    `Student` will subsequently call `AddCourse()` for that `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added various courses, we will then see each `Course` print its
    roster of students, such as `c2->PrintStudents()`. Likewise, we will then see
    each `Student` print the respective courses in which they are enrolled, such as
    with `s5.PrintCourses();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen an implementation of the Observer pattern. We have folded the
    more generic `Subject` and `Observer` classes into the framework of classes we
    are accustomed to seeing, namely `Course`, `Person`, and `Student`. Let us now
    briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun our pursuit to become better C++ programmers
    by expanding our repertoire beyond OOP concepts to include the utilization of
    design patterns. Our primary goal is to enable you to solve recurring types of
    coding problems using *tried and true* solutions by applying common design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We have first understood the purpose of design patterns and the advantage of
    employing them in our code. We have then specifically understood the premise behind
    the Observer pattern and how it contributes to OOP. Finally, we have taken a look
    at how we may implement the Observer pattern in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing common design patterns, such as the Observer pattern, will help you
    more easily solve recurring types of programming problems in a manner understood
    by other programmers. A key tenant in OOP is to strive for the reuse of components
    whenever possible. By utilizing design patterns, you will be contributing to reusable
    solutions with more sophisticated programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with our next design pattern in [*Chapter
    17*](B19087_17.xhtml#_idTextAnchor743), *Implementing the Factory Pattern*. Adding
    more patterns to our collection of skills makes us more versatile and valued programmers.
    Let’s continue forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the online code for the example in this chapter as a starting point and
    the solution from a previous exercise (*Question 3*, *Chapter 10*, *Implementing
    Association, Aggregation, and Composition*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement (or modify your previous) `Student::DropCourse()`. When a `Student`
    drops a `Course`, this event will cause the `Course` state to become state `2`,
    *New Space Available*. With the state change, `Notify()` will then be called on
    the `Course` (`Subject`), which will then `Update()` the list of observers (students
    on the waitlist). `Update()` will indirectly allow waitlisted `Student` instances,
    if any, to now add the `Course`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, in `DropCourse()`, remember to remove the dropped course from the student’s
    current course list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might easily incorporate the Observer
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
