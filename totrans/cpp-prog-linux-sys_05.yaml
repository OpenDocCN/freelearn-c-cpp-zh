- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Errors with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on error handling in C++. As a programmer, you will
    inevitably encounter situations where you need to determine the best approach
    to propagate program errors. Whether you use error codes or exceptions, we will
    delve into them to gain a better understanding of how to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine how to handle errors reported by POSIX APIs
    using C++. We will begin by covering the `errno` thread-local variable and the
    `strerror` function. After that, we will introduce `std::error_code` and `std::error_condition`
    and demonstrate how they help to wrap POSIX errors that come from POSIX APIs.
    We will also investigate custom error categories, which allow us to compare errors
    produced by various sources and develop platform-independent error-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, we will learn about exceptions in C++ and how to convert `std::error_code`
    into a `std::system_error` exception. We will also explore some best practices
    for working with exceptions, such as throwing exceptions by value and catching
    them by reference. Additionally, we will become acquainted with object slicing,
    a side effect that can occur when we catch exceptions by value rather than by
    reference. Finally, we will delve into the RAII technique in C++, which eliminates
    the need for a `finally` construct in the language.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a thorough understanding of the various
    ways to handle errors in C++, and you will be familiar with several techniques
    for creating error-resistant code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors from POSIX APIs with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From error codes to exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, it’s time to begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux Mint 21 Cinnamon edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC 12.2 with compiler flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-``std=c++20`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please make sure your environment is at least that recent. For all the examples,
    you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors from POSIX APIs with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In POSIX-compliant systems, such as Unix and Linux, error handling is based
    on the use of error codes and error messages to communicate errors between functions
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when a function encounters an error, it returns a non-zero error
    code and sets the `errno` global variable to a specific error value that indicates
    the nature of the error. The application can then use the `errno` variable to
    determine the cause of the error and take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to error codes, POSIX-compliant functions often provide error messages
    that describe the nature of the error in more detail. These error messages are
    typically accessed using the `strerror` function, which takes an error code as
    input and returns a pointer to a sequence of characters terminated with a null
    character containing the corresponding error message.
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX error-handling style requires developers to check for errors after
    each system call or function call that may fail and to handle errors in a consistent
    and meaningful way. This can include logging error messages, retrying failed operations,
    or terminating the program in the event of a critical error.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the following example where we demonstrate how to use the `errno`
    variable and the `strerror()` function to handle errors from POSIX functions in
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example uses the `open()` and `close()` POSIX functions, which try to open
    and close a file from the filesystem of our Linux test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we attempt to open a file for reading called `no-such-file.txt`
    using the `open()` function; see marker `{1}`. In case of success, `open()` returns
    a non-negative integer, which corresponds to the file descriptor ID of the successfully
    opened file. If `open()` returns `-1`, we know an error occurred, so we print
    the error message using `strerror(errno)` and return the value of `errno` where
    the corresponding error code is written.
  prefs: []
  type: TYPE_NORMAL
- en: If `open()` succeeds, we do something with the file and then close it using
    the `close()` function. If `close()` returns `-1`, we print the error message
    again using `strerror(errno)` and return the value of `errno`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a common error-handling technique for POSIX functions. In case of an
    error, they return `-1` and set the `errno` variable with the corresponding error
    code. The `errno` variable is a *thread-local* modifiable variable of the `int`
    type. This means that it is safe for you to use it in a multithreaded environment.
    Each thread will have its own copy, and POSIX methods invoked by this thread will
    use this instance to report errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print a meaningful message in the case of an error, we use the
    `strerror()` function, which accepts an integer and tries to match its value to
    a well-known list of descriptions of system-specific error codes. The `open()`
    function can report several errors and set different values to `errno` depending
    on the type of the occurred error. Let’s see the output of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `open()` method has failed to open the file because it doesn’t
    exist. In this case, it sets `errno` to a value of `2`, which corresponds to the
    `ENOENT` value specified in the documentation of the function. It is a good practice
    to explicitly set `errno` to `0` before you do a system call to ensure that after
    the call, you can read its real response.
  prefs: []
  type: TYPE_NORMAL
- en: Using std::error_code and std::error_condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ Standard Library provides several classes for handling errors from low-level
    APIs such as the POSIX interface. These classes are `std::error_code` for handling
    system-specific errors and `std::error_condition`, which deals with portable error
    codes. Let us explore both styles in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: std::error_code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s rework our previous example in such a way that we provide a function
    for the creation of a directory with a specific directory path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rather than the client of our new function, `CreateDirectory`, using the `errno`
    variable directly to determine whether the operation was successful, we will make
    use of a utility class provided by the Standard Library – `std::error_code`. `std::error_code`
    is used to store and transmit error codes as they were generated by libraries
    or system calls. It is a kind of wrapper class for which there are predefined
    categories of errors to work with. The errors returned by the POSIX functions
    are mostly standard and, as such, are predefined in the Standard Library. Therefore,
    it is straightforward to create a `std::error_code` instance from the `errno`
    value and specify that this value corresponds to `std::generic_category()`, as
    done in marker `{1}` in the preceding example. The `errno` value is de facto casted
    to a constant of the `std::errc` enumerator.
  prefs: []
  type: TYPE_NORMAL
- en: The created `std::error_code` object has two methods that can give you details
    about the underlying error. The `std::error_code::message()` method returns a
    meaningful string that can be used for logging purposes. The `std::error_code::value()`method,
    in our example, returns the value initially stored in the `errno` variable. But
    probably the most notable operation that the user can use from the `std::error_code`
    object is the predefined `operator bool()` of the class. In the case of an error
    stored in the object, it returns `true`; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding example, the caller of the `CreateCategory()`
    method checks whether an error occurred, and if so, it gets the message stored
    for this error; see marker `{2}`. Here, you can find the output of the program
    run on our test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As is visible from the program’s output, the first `CreateDirectory()` invocation
    succeeds but the second one fails; see marker `{3}`. This is because the implementation
    of `CreateDirectory()` first checks whether such a directory already exists and
    if not, it creates it for us. But if the directory exists, the `mkdir()` system
    call returns `–1` and sets `errno` to `EEXIST`.
  prefs: []
  type: TYPE_NORMAL
- en: Something important about the `std::error_code` class is that it is platform
    specific. This means that the error values stored in it strongly depend on the
    underlying OS. In the case of a POSIX-like system, which Linux is, the error value
    we have is `EEXIST`. But this is not necessarily true for other OSs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if we design our code to be as platform agnostic as possible, we
    need to avoid comparations such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But we also need a way to ensure that a directory that already exists doesn’t
    break our program logic. Yes, from a POSIX standpoint this is an error, but in
    our specific business logic, this is not a problem for the program execution to
    continue.
  prefs: []
  type: TYPE_NORMAL
- en: std::error_condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The right approach to address this problem is with the help of another Standard
    Library class – `std::error_condition`. As the name suggests, its main purpose
    is to provide conditional program logic. Let’s slightly rework the `CreateDirectory()`
    method from the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the difference from the previous example is how we construct
    the `error_code` object. In the reworked code, we first create an object of the
    `std::errc` type and initialize it with the value of POSIX `errno`; see marker
    `{1}`. The `std::errc` class is a scoped enumerator class. It defines *portable
    error conditions* that correspond to the specific POSIX error codes. This implies
    that instead of relying on a platform-specific macro that corresponds to a particular
    POSIX error code, such as `EEXIST`, we switch to an error that will have the same
    error condition regardless of the platform it comes from.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the predefined portable error conditions of the `std::errc` scoped
    enumerator, which correspond to their equivalent POSIX error codes, here: [https://en.cppreference.com/w/cpp/error/errc](https://en.cppreference.com/w/cpp/error/errc).'
  prefs: []
  type: TYPE_NORMAL
- en: Once we create an instance of `std::errc`, we pass it to the factory method
    for the creation of error codes – `std::make_error_code()` (see marker `{2}`)
    – which generates for us a `std::error_code` of a generic category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how the `main()` method is changed in order to be platform independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We still have two invocations of the `CreateDirectory()` method, and the second
    one still returns an `error_code`. But the main difference comes from how we compare
    the `ecode` object; see marker `{3}`. Instead of comparing it with an integer
    value of the error POSIX code, we compare it against an object that holds a portable
    error condition – `std::errc::file_exists`. It has the same semantics, saying
    that the file already exists, but it is platform independent. In the next section,
    we will see how useful this could be.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom error categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every software developer should strive as much as possible to write portable
    code. Writing portable code provides reusability, which can significantly reduce
    development costs. Of course, this is not always possible. There are use cases
    where the code you write is dedicated to a specific system. But for all the rest,
    abstracting your code from the underlying system allows you to easily migrate
    it to other systems without carrying out huge refactoring to make it work. This
    is safer and cheaper.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to our previous example, where we tried to abstract the error
    code received from a POSIX system call. It should be comparable against a portable
    error condition such as `std::errc::file_exists`. We will extend this with the
    following use case. Imagine that we have a custom library that also works with
    files. Let’s call it `MyFileLibrary`. But this library doesn’t support the POSIX
    error codes. It provides a different *category* of custom error codes that semantically
    correspond to some of the POSIX codes but with different error values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library supports the following errors with their corresponding error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our library can return the `FileAlreadyExists` enumerated constant,
    just like the `mkdir()` system call does, but with a different error value – `1000`.
    So, the main logic that consumes both `MyFileLibrary` and `mkdir()` should be
    able to handle these errors in the same way, because they are semantically equal.
    Let’s see how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we created the error code returned by the POSIX API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `std::generic_category`, which is a derived class from the base category
    class – `std::error_category`. It is predefined for us in the Standard Library
    in such a way that it *knows* POSIX error codes. This is effectively the place
    where the translation between the real error code returned by the API and `std::error_condition`
    is done. So, in order to expose the same capability for `MyFileLibrary`, we need
    to define a new `std::error_category` derived class. We will name it `MyFileLibraryCategory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::error_category` base class has several *virtual* methods that, if
    overridden in the derived class, allow custom behavior. In our example, we have
    overridden the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name()` method, which is used to report which category this error belongs
    to; see marker `{1}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `message()` method, which is used to report a message string that corresponds
    to a specific error value; see marker `{2}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equivalent()` method, which is used to make a comparison between the custom
    error code generated by our library and the predefined `std::error_condition`
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equivalent()` method gets the custom error code, casts it to a value of
    `MyFileLibraryError`, and, for each specific case, decides what `condition` it
    matches; see marker `{3}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, since we have our new, shiny custom error category – `MyFileLibraryCategory`
    – let’s see how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first step we need to take is to instantiate an object of our custom category;
    see marker `{1}`. Then, we create an `error_code` instance, which we initialize
    with the `FileAlreadyExists` error value and specify that it is from the `MyFileLibraryCategory`
    category; see marker `{2}`. Since we have a valid instance of an error code –
    `file_exists` – we are ready to compare it against the platform-independent `std::errc::file_exists`
    error condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the comparation between an error generated from `MyFileLibrary`
    and the generic `std::errc::file_exists` is now possible with the help of the
    custom error category we defined – `MyFileLibraryCategory`. The corresponding
    error message is displayed (see marker `{3}`) and the category as well (see marker
    `{4}`).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can find the full description with all virtual methods that the `std::error_category`
    base class exposes: [https://en.cppreference.com/w/cpp/error/error_category](https://en.cppreference.com/w/cpp/error/error_category).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the usage of error codes and error conditions,
    let’s see how we can use the powerful mechanism of C++ exceptions and propagate
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: From error codes to exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is an important aspect of programming, especially when dealing
    with errors that can disrupt the normal flow of a program. While there are several
    ways to handle errors in a code base, exceptions provide a powerful mechanism
    for handling errors in a way that separates error flow from normal program flow.
  prefs: []
  type: TYPE_NORMAL
- en: When working with error codes, it can be challenging to ensure that all error
    cases are properly handled and that the code remains maintainable. By wrapping
    error codes in exceptions, we can create a more pragmatic approach to error handling
    that makes it easier to reason about code and catch errors in a more centralized
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to say which approach is better when dealing with error handling in
    a code base, and the decision to use exceptions should be based on pragmatic considerations.
    While exceptions can provide significant benefits in terms of code organization
    and maintainability, they may come with a performance penalty that may not be
    acceptable in certain systems.
  prefs: []
  type: TYPE_NORMAL
- en: At their core, exceptions are a way to segregate the normal program flow from
    the error flow. Unlike error codes, which can be ignored, exceptions cannot be
    easily overlooked, making them a more reliable way to ensure that errors are handled
    in a consistent and centralized manner.
  prefs: []
  type: TYPE_NORMAL
- en: While exceptions may not be the right choice for every code base, they offer
    a powerful way to handle errors that can make code easier to maintain and reason
    about. By understanding how to correctly use exceptions, programmers can make
    informed decisions about how to handle errors in their code. Let’s get deeper
    into this.
  prefs: []
  type: TYPE_NORMAL
- en: std::system_error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we created a program that properly handles errors
    reported by the POSIX system call – `mkdir()`. Now, let’s see how we can improve
    the error handling in this program using exceptions instead of error codes. Here
    is the revisited `CreateDirectory()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `CreateDirectory()` method, we make a system call using the `mkdir()`
    API, which, in the case of failure, returns a non-zero result and stores a POSIX
    error code in the `errno` variable. Nothing new so far. Just as in our previous
    example, we create an `std::error_code` from the value of `errno` (see marker
    `{2}`) to report it to the caller of our `CreateDirectory()` method. But instead
    of returning the error directly as a result of the function, we prefer to use
    an exception for this and make our function `{1}`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we already have an error code object created, we will use it to create
    an exception from it. In order to do so, we will use a predefined exception class
    from the Standard Library that is explicitly defined to wrap `std::error_code`
    objects – `std::system_error`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::system_error` is a derived type from the `std::exception` interface class
    from the C++ Standard Library. It is used by various library functions, which
    typically interface with OS facilities and can report errors either by generating
    `std::error_code` or `std::error_condition`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Inheritance diagram of std::system_error exception](img/Figure_5.1_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Inheritance diagram of std::system_error exception
  prefs: []
  type: TYPE_NORMAL
- en: In our example, in order to create an `std::system_error` object, we have to
    pass to its constructor the instance of `std::error_code ecode`, which we already
    created; see marker `{3}`.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other exception derived from the base exception class from the Standard
    Library – `std::exception` – `std::system_error` has the `what()` method. It aims
    to report a meaningful string explaining details about the error behind the exception.
    More specifically, it calls under the hood the `message()` method of the `std::error_code`
    object it wraps and returns its result.
  prefs: []
  type: TYPE_NORMAL
- en: Since we already have a new, shiny exception object created, we now need to
    *throw* it back to the caller of our API. This is done with the `throw` keyword;
    see marker `{4}`. An important note is that we throw the exception object by *value*;
    we don’t throw a reference or a pointer to it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, wherever possible, throw your exceptions by value.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of exceptions over error codes is that they *can’t
    be omitted* by the caller. When a function returns an error code, it is up to
    the function’s caller to decide whether to check the return value or not. There
    are some cases where the return value is not checked by mistake, and this leads
    to bugs in the program. When using exceptions as an error-handling mechanism,
    there is no such possibility. Once an exception is thrown, it propagates up the
    call stack until it is either caught by the appropriate program exception-handling
    logic or reaches the top of the function stack. If the exception is not caught
    anywhere during its propagation path, known also as *stack unwinding*, then it
    terminates the program by invoking the `std::terminate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following `std::system_error` reference page: [https://en.cppreference.com/w/cpp/error/system_error](https://en.cppreference.com/w/cpp/error/system_error).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get back to our example and see how the `main()` method should be
    reworked in order to handle the exception thrown from the `CreateDirectory()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unlike error codes, which, once returned by a function, need to be assigned
    and checked, the exceptions need to be caught and appropriate actions should be
    taken. Catching exceptions in C++ is done with the help of the try-catch construction
    in the language. In the preceding example, you can see that we invoke the `CreateDirectory()`
    method twice because the second invocation will generate an error, which will
    be propagated up the stack as an exception. This exception will be caught by the
    `catch` clause in marker `{5}`. As you can see, the `catch` clause expects a parameter
    that specifies what should be caught; see marker `{5}`. Its syntax is similar
    to the function’s parameter list, where you can pass objects either by value or
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we catch the exception thrown by the `CreateDirectory()` method
    by *constant reference*. The reason why we don’t catch by value is to avoid unnecessary
    object copying and – more importantly – to avoid *object slicing*. We will get
    deeper into the specifics of the exception-catching techniques in C++ soon, but
    for now, let’s focus on our current example. Once we catch the exception, we can
    extract the `error_condition` object from it; see marker `{6}`. This is possible
    because the `system_error` class supports error codes and error conditions and
    enables us to fetch them. When we have `error_condition`, we can successfully
    check against the well-known `errc` codes whether this exception is a real problem
    for our program or it can be omitted; see marker `{7}`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, catch exceptions by reference (prefer constant) rather than
    by value to avoid potential object slicing and additional overhead due to object
    copying.
  prefs: []
  type: TYPE_NORMAL
- en: Our business program logic expects that errors reporting that a file already
    exists are normal and should not break program execution. Ultimately, it says
    that we try to create a directory that already exists, and that’s fine and we
    can continue. But if the error is something else that we don’t know what to do
    with, then we have to report that error and rethrow it to the upper methods in
    the call stack, which could better know what to do with such a kind of error.
    This is done with the `throw` clause in the language; see marker `{8}`. An important
    detail here is that in order to *rethrow an existing exception* rather than throwing
    a new one, you have to just use `throw;` with *no arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Use the `throw;` clause with no arguments to rethrow an existing exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if the error is what we expect, such as `std::errc::file_exists`,
    then we can safely continue the program execution without the need to rethrow
    this exception. You can find the output of the program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the exception is thrown by the `CreateDirectory()` method and
    it is caught by the `catch` clause in the `main()` method. In this example, we
    saw that using exceptions instead of error codes clearly segregates the normal
    program execution path from the error path and makes it easier to rethrow errors
    that we can’t properly deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Throw by value, catch by reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, we can literally throw every object. You could successfully do this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement throws an integer object with a value of `42`. But just
    because you can do something, it doesn’t mean it’s a good idea to do so. The goal
    of the exception is to bring context to the error that occurred. Throwing the
    value of `42` doesn’t provide much context, right? What does `42` mean for the
    recipient of your exception? Not much!
  prefs: []
  type: TYPE_NORMAL
- en: This statement is fully confirmed by the C++ Core Guidelines project developed
    by some of the key members of the C++ Standards Committee. The C++ Core Guidelines
    are a really useful guide for every C++ developer no matter what level of expertise
    you have. It gathers recommendations and best practices about different features
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to get familiar with the C++ Core Guidelines, which you can find at
    [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines).
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ Core Guidelines say that we have to make sure that we throw meaningful
    exceptions. If you don’t have a standard defined exception that works for your
    case, you can throw a user-defined type that derives from some of the standard
    exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ Core Guidelines also suggest throwing our exceptions by value and catching
    them by reference. Of course, even better if we catch by constant reference. Throwing
    by value ensures that the lifetime of the thrown object will be managed by the
    runtime of your system. Otherwise, if you throw a pointer to an object that you
    have allocated on the heap whose responsibility will be to delete this object
    when it is no longer needed, it is quite possible you will end up with leaked
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through an example. We will define a method – `Throw()` – which throws
    by value a `std::system_error` exception with an error code – `bad_file_descriptor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be invoked by the `main()` method in which we will catch the
    thrown exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, we have defined two `try-catch` blocks
    – one inner and one outer. The reason behind this is that exceptions thrown in
    the `catch` branch can’t be caught by another `catch` branch in the same try-catch
    block. They are propagated out and, therefore, in order to catch them, we need
    an outer try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: In marker `{1}`, we invoke the `Throw()` method, which throws an exception.
    But in marker `{2}`, we catch the thrown exception. Actually, we don’t catch `std::system_error`
    directly but we catch its parent class – `std::runtime_error`. Also, you can see
    that we catch this exception by value with `runtime_error e`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only action we take once we catch the `runtime_error` exception is to throw
    it away from the inner try-catch block with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Always be careful when you rethrow an existing exception. The upper statement
    *doesn’t rethrow* the exception caught in the `catch` clause but it throws a new
    instance of the `runtime_error` exception, which is a copy of the caught exception,
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new exception is thrown, it is caught by the outer `catch` clause in
    marker `{4}`. As you can see, following the recommendation from the C++ Core Guidelines,
    we catch a constant reference instead of a value to the Standard Library’s base
    exception class – `std::exception` – which is also a base class for `std::runtime_error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `catch` clause, we try to downcast it back to its original type – `std::system_error`
    – and print the message from its `std::error_condition`. Let’s see the output
    from the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: But surprisingly, we don’t get the expected result. The downcast has failed,
    and when it fails, it generates a standard exception – `std::bad_cast` – which
    is thrown away from the outer `catch` clause. But this exception is not guarded
    by another try-catch block, and therefore, it propagates out of the `main()` method,
    which is de facto the top of the function stack of the program. As we explained
    earlier, if an exception is not caught during its propagation upwind in the function
    stack, then the `std::terminate` function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: But why did the cast fail when we tried to downcast to `std::system_error`?
    The reason is that the `Throw()` method throws `std::system_error` and everything
    should work fine. Well, it should, but it doesn’t really. Let’s get deeper into
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Throw()` method really throws an instance of `std::system_error` by *value*.
    But the inner `catch` clause catches a *base class exception* also *by value*
    and throws a *copy* of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This leads to a problem because the object we rethrow is no longer an instance
    of `std::system_error`. It has been sliced to its base class – `std::runtime_error`.
    All the information that has been part of the *original* `std::system_error` object
    is no longer part of the newly created *copy* of the `std::runtime_error` – `e`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the downcast to `std::system_error` doesn’t succeed and our program
    terminates.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, we can say that these kinds of errors can be successfully prevented
    by following the rules of throwing exceptions by value, catching them by reference,
    and rethrowing the existing exceptions rather than their copy wherever this is
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: try/catch … finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably noticed that in the C++ language, we have the `try-catch` block,
    but we don’t have the `finally` construct. If you have experience in languages
    such as C# or Java, you will be used to releasing the resource that you have acquired
    using the `finally` clause. But this works only for exceptional cases where the
    `try` clause is preceding the usage of `finally`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we do it in C++ without `finally`? Let’s revisit our initial example
    for opening and closing a file using the `open()` and `close()` POSIX functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we already discussed earlier in the chapter, opening a file using the `open()`
    POSIX method returns the ID of the file descriptor if the function successfully
    opens the file; otherwise, as with many of the POSIX functions, it returns `-1`;
    see marker `{1}`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your file opened, it is your responsibility to ensure that *finally*,
    when you finish with it, it will be closed. Therefore, we invoke the `close()`
    method at the end of the `main()` method to ensure that the file will be closed
    (see marker `{3}`) just before we leave `main()`. But how can you be sure that
    some abnormal situation won’t occur, and an exception won’t be thrown before you
    close your file? Actually, the only case in which you can be sure that this won’t
    happen is if exceptions are not supported in your system. But in our test Linux
    environment, this is not the case. Even worse, when working in real code bases,
    it’s hard to be sure that some of the methods you invoke during your normal business
    logic execution won’t throw.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine what happens if your program throws before you close your file; see
    marker `{2}`. Effectively, you will *leak* a resource. As a rule of thumb, we
    should never leak resources, no matter whether this will lead to a problem or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we protect ourselves from leaking resources without having the
    `finally` clause in the language? Let’s have a look into one of the most typical
    C++ programming techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have reworked our `main()` method in such a way that we just create a file
    (see marker `{2}`) and pass its filename (see marker `{1}`) to a new object of
    the `file_guard` type (see marker `{3}`), which we will look at it just in a moment.
    The `file_guard` object is responsible for opening and closing a file with a specific
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The class gets in its constructor the file path and the mode in which the file
    should be opened; see marker `{5}`. In the initializer list of the constructor,
    the POSIX `open()` method is invoked. The result, which is the file descriptor
    ID, is assigned to the `_fd` member of the class. If `open()` fails, an exception
    is thrown away from the `file_guard` constructor. We should not care about closing
    the file in this case because we didn’t open it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In the destructor of the class, we have the reversed operation; see marker `{9}`.
    If the file descriptor is different from `-1`, which means that the file has been
    successfully opened before that, we close it.
  prefs: []
  type: TYPE_NORMAL
- en: This C++ programming technique is called **Resource Acquisition Is Initialization**,
    or just **RAII**. It is a resource management technique that acquires the resource
    during the construction of the RAII object and releases it during the destruction
    of that object. Unlike in languages such as Java and C# that use automatic garbage
    collection and whose resource release timing is not entirely clear to the user,
    C++ objects have a precisely defined storage duration and lifetime. Thus, we can
    rely on this characteristic and utilize RAII objects to manage our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our `main()` method, if the file is opened (see marker `{3}`)
    and something goes wrong before it has been explicitly closed (see marker `{4}`),
    we will be sure that it will be automatically closed once the `file_guard` object
    goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is widely used no matter whether exceptions are available in
    the system or not. You can wrap your resources using RAII and be assured that
    they will be automatically released whenever you leave the scope where the RAII
    object lives.
  prefs: []
  type: TYPE_NORMAL
- en: In our `file_guard` example, we have removed the copy constructor and the copy
    assignment operator and left the move constructor and move operator only, claiming
    that this RAII object is not copyable.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ is often questioned about not having the `finally` construct. However,
    the inventor of C++, Bjarne Stroustrup, has explained that RAII is a better substitute:
    [https://www.stroustrup.com/bs_faq2.xhtml#finally](https://www.stroustrup.com/bs_faq2.xhtml#finally).'
  prefs: []
  type: TYPE_NORMAL
- en: Stroustrup argues that in practical code bases, there are many more resource
    acquisitions and releases, and using RAII instead of `finally` results in less
    code. Additionally, it is less susceptible to errors since the RAII wrapper only
    needs to be coded once, and there is no need to remember to release the resource
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library has many examples of RAII objects, such as `std::unique_ptr`,
    `std::lock_guard`, and `std::fstreams`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered various techniques for error handling when working
    with POSIX APIs in C++. We discussed the use of `errno`, a thread-local variable,
    and the `strerror` function. We also explored how `std::error_code` and `std::error_condition`
    can wrap POSIX errors and how custom error categories enable us to compare errors
    generated by different sources and develop platform-independent error-handling
    code. Furthermore, we delved into exceptions in C++ and how to convert `std::error_code`
    into an exception of the `std::system_error` type.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined best practices for working with exceptions, such as throwing
    them by value and catching them by reference, to avoid issues such as object slicing.
    Finally, we learned about the RAII technique in C++, which eliminates the need
    for a `finally` construct in the language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the topic of concurrency with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Advanced Techniques for System Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn about expert-level C++20 features, which will further
    improve both your OS and C++ development expertise. The examples, though still
    practical, become more complex and require some preliminary understanding of the
    subject of system programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20833_06.xhtml#_idTextAnchor086)*, Concurrent System Programming
    with C++*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20833_07.xhtml#_idTextAnchor101)*, Proceeding with Inter-Process
    Communication*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20833_08.xhtml#_idTextAnchor116)*, Using Clocks, Timers, and
    Signals in Linux*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20833_09.xhtml#_idTextAnchor129)*, Understanding the C++ Memory
    Model*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B20833_10.xhtml#_idTextAnchor147)*, Using Coroutines in C++
    for System Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
