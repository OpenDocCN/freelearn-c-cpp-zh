- en: Getting to Grips with Socket APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握套接字 API
- en: In this chapter, we will begin to really start working with network programming.
    We will introduce the concept of sockets, and explain a bit of the history behind
    them. We will cover the important differences between the socket APIs provided
    by Windows and Unix-like operating systems, and we will review the common functions
    that are used in socket programming. This chapter ends with a concrete example
    of turning a simple console program into a networked program you can access through
    your web browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将真正开始学习网络编程。我们将介绍套接字的概念，并简要解释其背后的历史。我们将讨论 Windows 和类 Unix 操作系统提供的套接字
    API 之间的重要差异，并回顾在套接字编程中常用的函数。本章以将一个简单的控制台程序转换为可以通过网页浏览器访问的网络程序的具体示例结束。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What are sockets?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是套接字？
- en: Which header files are used with socket programming?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字编程使用哪些头文件？
- en: How to compile a socket program on Windows, Linux, and macOS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Windows、Linux 和 macOS 上编译套接字程序
- en: Connection-oriented and connectionless sockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向连接和无连接套接字
- en: TCP and UDP protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 和 UDP 协议
- en: Common socket functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见套接字函数
- en: Building a simple console program into a web server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单的控制台程序构建成网络服务器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs in this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler On Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler On Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler On macOS*, for compiler setup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例程序可以使用任何现代 C 编译器编译。我们推荐在 Windows 上使用 MinGW，在 Linux 和 macOS 上使用 GCC。有关编译器设置，请参阅[附录
    B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在 Windows 上设置您的 C 编译器*，[附录 C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在
    Linux 上设置您的 C 编译器*，以及[附录 D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在 macOS
    上设置您的 C 编译器*。
- en: 'The code for this book can be found here: [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的代码可以在以下位置找到：[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，你可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter is standalone, and each example runs on
    Windows, Linux, and macOS. When compiling for Windows, keep in mind that most
    of the example programs require linking with the Winsock library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都是独立的，每个示例都可以在 Windows、Linux 和 macOS 上运行。当为 Windows 编译时，请记住大多数示例程序都需要与
    Winsock 库链接。
- en: This is accomplished by passing the `-lws2_32` option to `gcc`. We provide the
    exact commands needed to compile each example as they are introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过向 `gcc` 传递 `-lws2_32` 选项来实现。我们提供了编译每个示例所需的精确命令，当介绍示例时。
- en: What are sockets?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是套接字？
- en: A socket is one endpoint of a communication link between systems. Your application
    sends and receives all of its network data through a socket.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是系统间通信链路的一个端点。你的应用程序通过套接字发送和接收所有的网络数据。
- en: There are a few different socket **application programming interfaces** (**APIs**).
    The first were Berkeley sockets, which were released in 1983 with 4.3BSD Unix.
    The Berkeley socket API was widely successful and quickly evolved into a de facto
    standard. From there, it was adopted as a POSIX standard with little modification.
    The terms Berkeley sockets, BSD sockets, Unix sockets, and **Portable Operating
    System Interface** (**POSIX**) sockets are often used interchangeably.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种不同的套接字**应用程序编程接口**（**API**）。第一种是伯克利套接字，它在 1983 年与 4.3BSD Unix 一起发布。伯克利套接字
    API 获得了巨大的成功，并迅速演变成一个事实上的标准。从那时起，它经过少量修改后就被采纳为 POSIX 标准。术语伯克利套接字、BSD 套接字、Unix
    套接字和**可移植操作系统接口**（**POSIX**）套接字通常可以互换使用。
- en: If you're using Linux or macOS, then your operating system provides a proper
    implementation of Berkeley sockets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Linux 或 macOS，那么你的操作系统提供了适当的伯克利套接字实现。
- en: Windows' socket API is called **Winsock**. It was created to be largely compatible
    with Berkeley sockets. In this book, we strive to create cross-platform code that
    is valid for both Berkeley sockets and Winsock.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 的套接字 API 被称为 **Winsock**。它是为了与伯克利套接字高度兼容而创建的。在这本书中，我们努力创建跨平台的代码，使其对伯克利套接字和
    Winsock 都有效。
- en: Historically, sockets were used for **inter-process communication** (**IPC**)
    as well as various network protocols. In this book, we use sockets only for communication
    with TCP and UDP.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，套接字被用于**进程间通信**（IPC）以及各种网络协议。在这本书中，我们只使用套接字与 TCP 和 UDP 进行通信。
- en: Before we can start using sockets, we need to do a bit of setup. Let's dive
    right in!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用套接字之前，我们需要做一些设置。让我们直接进入正题！
- en: Socket setup
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字设置
- en: Before we can use the socket API, we need to include the socket API header files.
    These files vary depending on whether we are using Berkeley sockets or Winsock.
    Additionally, Winsock requires initialization before use. It also requires that
    a cleanup function is called when we are finished. These initialization and cleanup
    steps are not used with Berkeley sockets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用套接字 API 之前，我们需要包含套接字 API 头文件。这些文件取决于我们是否使用伯克利套接字或 Winsock。此外，Winsock
    在使用之前需要初始化。它还要求在完成时调用清理函数。这些初始化和清理步骤在伯克利套接字中不使用。
- en: We will use the C preprocessor to run the proper code on Windows compared to
    Berkeley socket systems. By using the preprocessor statement, `#if defined(_WIN32)`,
    we can include code in our program that will only be compiled on Windows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 C 预处理器来在 Windows 上运行适当的代码，与伯克利套接字系统相比。通过使用预处理器语句 `#if defined(_WIN32)`，我们可以在程序中包含仅在
    Windows 上编译的代码。
- en: 'Here is a complete program that includes the needed socket API headers for
    each platform and properly initializes Winsock on Windows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完整的程序，它包括每个平台所需的套接字 API 头文件，并在 Windows 上正确初始化 Winsock：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first part includes `winsock.h` and `ws2tcpip.h` on Windows. `_WIN32_WINNT`
    must be defined for the Winsock headers to provide all the functions we need.
    We also include the `#pragma comment(lib,"ws2_32.lib")` pragma statement. This
    tells the Microsoft Visual C compiler to link your program against the Winsock
    library, `ws2_32.lib`. If you're using MinGW as your compiler, then `#pragma` is
    ignored. In this case, you need to tell the compiler to link in `ws2_32.lib` on
    the command line using the `-lws2_32` option.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包括 Windows 上的 `winsock.h` 和 `ws2tcpip.h`。为了 Winsock 头文件提供我们需要的所有功能，必须定义
    `_WIN32_WINNT`。我们还包含了 `#pragma comment(lib,"ws2_32.lib")` 预编译语句。这告诉 Microsoft
    Visual C 编译器将你的程序链接到 Winsock 库，即 `ws2_32.lib`。如果你使用 MinGW 作为编译器，则 `#pragma` 被忽略。在这种情况下，你需要通过命令行使用
    `-lws2_32` 选项告诉编译器链接 `ws2_32.lib`。
- en: If the program is not compiled on Windows, then the section after `#else` will
    compile. This section includes the various Berkeley socket API headers and other
    headers we need on these platforms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序不是在 Windows 上编译的，那么 `#else` 之后的部分将被编译。这部分包括各种伯克利套接字 API 头文件以及在这些平台上我们需要的其他头文件。
- en: In the `main()` function, we call `WSAStartup()` on Windows to initialize Winsock.
    The `MAKEWORD` macro allows us to request Winsock version 2.2\. If our program
    is unable to initialize Winsock, it prints an error message and aborts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们在 Windows 上调用 `WSAStartup()` 来初始化 Winsock。`MAKEWORD` 宏允许我们请求
    Winsock 版本 2.2。如果我们的程序无法初始化 Winsock，它将打印错误消息并终止。
- en: When using Berkeley sockets, no special initialization is needed, and the socket
    API is always ready to use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用伯克利套接字时，不需要特殊初始化，套接字 API 总是准备就绪，可以立即使用。
- en: Before our program finishes, `WSACleanup()` is called if we're compiling for
    Winsock on Windows. This function allows the Windows operating system to do additional
    cleanup.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序结束之前，如果我们在 Windows 上编译 Winsock，则需要调用 `WSACleanup()`。此函数允许 Windows 操作系统进行额外的清理。
- en: 'Compiling and running this program on Linux or macOS is done with the following
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 或 macOS 上编译和运行此程序可以使用以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compiling on Windows using MinGW can be done with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上使用 MinGW 编译可以通过以下命令完成：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the `-lws2_32` flag is needed with MinGW to tell the compiler to
    link in the Winsock library, `ws2_32.lib`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 MinGW 需要使用 `-lws2_32` 标志来告诉编译器链接 Winsock 库，即 `ws2_32.lib`。
- en: Now that we've done the necessary setup to begin using the socket APIs, let's
    take a closer look at what we will be using these sockets for.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了开始使用套接字 API 所必需的设置，让我们更详细地看看我们将使用这些套接字做什么。
- en: Two types of sockets
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两种类型的套接字
- en: Sockets come in two basic types—**connection-oriented** and **connectionless**.
    These terms refer to types of protocols. Beginners sometimes get confused with
    the term **connectionless**. Of course, two systems communicating over a network
    are in some sense connected. Keep in mind that these terms are used with special
    meanings, which we will cover shortly, and should not imply that some protocols
    manage to send data without a connection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字有两种基本类型——**面向连接**和**无连接**。这些术语指的是协议的类型。初学者有时会混淆**无连接**这个术语。当然，通过网络进行通信的两个系统在某种程度上是连接的。请记住，这些术语具有特殊含义，我们将在稍后讨论，不应暗示某些协议能够不通过连接发送数据。
- en: The two protocols that are used today are **Transmission Control Protocol** (**TCP**)
    and **User Datagram Protocol** (**UDP**). TCP is a connection-oriented protocol,
    and UDP is a connectionless protocol.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 今天使用的两种协议是**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。TCP是一种面向连接的协议，而UDP是一种无连接的协议。
- en: The socket APIs also support other less-common or outdated protocols, which
    we do not cover in this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字API还支持其他不太常见或过时的协议，这些内容我们在这本书中不予涉及。
- en: In a connectionless protocol, such as UDP, each data packet is addressed individually.
    From the protocol's perspective, each data packet is completely independent and
    unrelated to any packets coming before or after it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在无连接协议（如UDP）中，每个数据包都是单独寻址的。从协议的角度来看，每个数据包是完全独立且与之前或之后到达的任何数据包无关的。
- en: A good analogy for UDP is **postcards**. When you send a postcard, there is
    no guarantee that it will arrive. There is also no way to know if it did arrive.
    If you send many postcards at once, there is no way to predict what order they
    will arrive in. It is entirely possible that the first postcard you send gets
    delayed and arrives weeks after the last postcard was sent.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UDP的一个好的类比是**明信片**。当你发送明信片时，没有保证它会到达。也无法知道它是否真的到达了。如果你一次性发送很多明信片，也无法预测它们将按什么顺序到达。完全有可能你发送的第一张明信片被延误，并在最后一张明信片发送数周后才到达。
- en: With UDP, these same caveats apply. UDP makes no guarantee that a packet will
    arrive. UDP doesn't generally provide a method to know if a packet did not arrive,
    and UDP does not guarantee that the packets will arrive in the same order they
    were sent. As you can see, UDP is no more reliable than postcards. In fact, you
    may consider it less reliable, because with UDP, it is possible that a single
    packet may arrive twice!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP时，这些相同的注意事项同样适用。UDP不保证数据包会到达。UDP通常不提供一种方法来知道数据包是否未到达，并且UDP也不保证数据包会按照发送的顺序到达。正如你所见，UDP的可靠性并不比明信片高。事实上，你可能会认为它更不可靠，因为在使用UDP的情况下，单个数据包可能会重复到达两次！
- en: If you need reliable communication, you may be tempted to develop a scheme where
    you number each packet that's sent. For the first packet sent, you number it one,
    the second packet sent is numbered two, and so on. You could also request that
    the receiver send an acknowledgment for each packet. When the receiver gets packet
    one, it sends a return message, **packet one received**. In this way, the receiver
    can be sure that received packets are in the proper order. If the same packet
    arrives twice, the receiver can just ignore the redundant copy. If a packet isn't
    received at all, the sender knows from the missing acknowledgment and can resend
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要可靠的通信，你可能倾向于开发一种方案，其中为发送的每个数据包编号。对于第一个发送的数据包，编号为一，第二个发送的数据包编号为二，依此类推。你也可以要求接收方为每个数据包发送确认。当接收方收到第一个数据包时，它会发送一个回执消息，“**数据包一已接收**”。这样，接收方可以确信接收到的数据包是按正确顺序的。如果相同的包两次到达，接收方可以简单地忽略重复的副本。如果某个数据包根本未收到，发送方可以从缺失的确认中知道，并重新发送它。
- en: This scheme is essentially what connection-oriented protocols, such as TCP,
    do. TCP guarantees that data arrives in the same order it is sent. It prevents
    duplicate data from arriving twice, and it retries sending missing data. It also
    provides additional features such as notifications when a connection is terminated
    and algorithms to mitigate network congestion. Furthermore, TCP implements these
    features with an efficiency that is not achievable by piggybacking a custom reliability
    scheme on top of UDP.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案本质上就是面向连接的协议，如TCP所做的那样。TCP保证数据按照发送的顺序到达。它防止重复数据两次到达，并重新发送丢失的数据。它还提供了诸如连接终止时的通知和缓解网络拥塞的算法等附加功能。此外，TCP以UDP之上叠加自定义可靠性方案无法达到的效率实现了这些功能。
- en: For these reasons, TCP is used by many protocols. HTTP (for severing web pages),
    FTP (for transferring files), SSH (for remote administration), and SMTP (for delivering
    email) all use TCP. We will cover HTTP, SSH, and SMTP in the coming chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，许多协议都使用 TCP。HTTP（用于提供网页服务）、FTP（用于文件传输）、SSH（用于远程管理）和 SMTP（用于发送电子邮件）都使用
    TCP。我们将在接下来的章节中介绍 HTTP、SSH 和 SMTP。
- en: UDP is used by DNS (for resolving domain names). It is suitable for this purpose
    because an entire request and response can fit in a single packet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 被用于 DNS（用于解析域名）。它适合这个目的，因为整个请求和响应可以适合一个单独的数据包。
- en: UDP is also commonly used in real-time applications, such as audio streaming,
    video streaming, and multiplayer video games. In real-time applications, there
    is often no reason to retry sending dropped packets, so TCP's guarantees are unnecessary.
    For example, if you are streaming live video and a few packets get dropped, the
    video simply resumes when the next packet arrives. There is no reason to resend
    (or even detect) the dropped packet, as the video has already progressed past
    that point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 也常用于实时应用，如音频流、视频流和多玩家视频游戏。在实时应用中，通常没有必要重发丢失的数据包，因此 TCP 的保证是不必要的。例如，如果你正在流式传输实时视频，并且一些数据包丢失，视频将在下一个数据包到达时简单地继续。没有必要重发（甚至检测）丢失的数据包，因为视频已经超过了那个点。
- en: UDP also has the advantage in cases where you want to send a message without
    expecting a response from the other end. This makes it useful when using IP broadcast
    or multicast. TCP, on the other hand, requires bidirectional communication to
    provide its guarantees, and TCP does not work with IP multicast or broadcast.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你想要发送消息而不期望从另一端得到响应的情况下，UDP 也有优势。这使得它在使用 IP 广播或多播时非常有用。另一方面，TCP 需要双向通信来提供其保证，TCP
    也不与 IP 多播或广播一起工作。
- en: If the guarantees that TCP provides are not needed, then UDP can achieve greater
    efficiency. This is because TCP adds some additional overhead by numbering packets.
    TCP must also delay packets that arrive out of order, which can cause unnecessary
    delays in real-time applications. If you do need the guarantees provided by TCP,
    however, it is almost always preferable to use TCP instead of trying to add those
    mechanisms to UDP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要 TCP 提供的保证，那么 UDP 可以实现更高的效率。这是因为 TCP 通过对数据包编号增加了额外的开销。TCP 还必须延迟顺序错误的到达的数据包，这可能导致实时应用中不必要的延迟。然而，如果你确实需要
    TCP 提供的保证，那么几乎总是更倾向于使用 TCP 而不是尝试将那些机制添加到 UDP 中。
- en: Now that we have an idea of the communication models we use sockets for, let's
    look at the actual functions that are used in socket programming.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们使用套接字进行通信的模型，让我们看看实际在套接字编程中使用的函数。
- en: Socket functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字函数
- en: 'The socket APIs provide many functions for use in network programming. Here
    are the common socket functions that we use in this book:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字 API 为网络编程提供了许多函数。以下是我们在本书中使用的常见套接字函数：
- en: '`socket()` creates and initializes a new socket.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket()` 函数用于创建和初始化一个新的套接字。'
- en: '`bind()` associates a socket with a particular local IP address and port number.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind()` 函数将套接字与特定的本地 IP 地址和端口号关联。'
- en: '`listen()` is used on the server to cause a TCP socket to listen for new connections.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listen()` 函数用于服务器上，使 TCP 套接字监听新的连接。'
- en: '`connect()` is used on the client to set the remote address and port. In the
    case of TCP, it also establishes a connection.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()` 函数用于客户端设置远程地址和端口。在 TCP 的情况下，它也建立了连接。'
- en: '`accept()` is used on the server to create a new socket for an incoming TCP
    connection.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept()` 函数用于服务器上创建一个新的套接字以处理传入的 TCP 连接。'
- en: '`send()` and `recv()` are used to send and receive data with a socket.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send()` 和 `recv()` 用于通过套接字发送和接收数据。'
- en: '`sendto()` and `recvfrom()` are used to send and receive data from sockets
    without a bound remote address.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendto()` 和 `recvfrom()` 用于在没有绑定远程地址的套接字上发送和接收数据。'
- en: '`close()` (Berkeley sockets) and `closesocket()` (Winsock sockets) are used
    to close a socket. In the case of TCP, this also terminates the connection.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`（伯克利套接字）和 `closesocket()`（Winsock 套接字）用于关闭套接字。在 TCP 的情况下，这也终止了连接。'
- en: '`shutdown()` is used to close one side of a TCP connection. It is useful to
    ensure an orderly connection teardown.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()` 函数用于关闭 TCP 连接的一侧。它有助于确保有序地断开连接。'
- en: '`select()` is used to wait for an event on one or more sockets.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select()` 函数用于在一个或多个套接字上等待事件。'
- en: '`getnameinfo()` and `getaddrinfo()` provide a protocol-independent manner of
    working with hostnames and addresses.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getnameinfo()` 和 `getaddrinfo()` 提供了一种与主机名和地址无关的协议方式。'
- en: '`setsockopt()` is used to change some socket options.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setsockopt()`用于更改一些套接字选项。'
- en: '`fcntl()` (Berkeley sockets) and `ioctlsocket()` (Winsock sockets) are also
    used to get and set some socket options.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fcntl()`（伯克利套接字）和`ioctlsocket()`（Winsock套接字）也用于获取和设置一些套接字选项。'
- en: You may see some Berkeley socket networking programs using `read()` and `write()`.
    These functions don't port to Winsock, so we prefer `send()` and `recv()` here.
    Some other common functions that are used with Berkeley sockets are `poll()` and
    `dup()`. We will avoid these in order to keep our programs portable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些使用`read()`和`write()`的伯克利套接字网络程序。这些函数不能移植到Winsock，所以我们在这里更喜欢使用`send()`和`recv()`。与伯克利套接字一起使用的其他一些常见函数是`poll()`和`dup()`。我们将避免使用这些函数，以保持我们的程序可移植。
- en: Other differences between Berkeley sockets and Winsock sockets are addressed
    later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将讨论伯克利套接字和Winsock套接字的其它差异。
- en: Now that we have an idea of the functions involved, let's consider program design
    and flow next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了涉及的函数，接下来让我们考虑程序设计和流程。
- en: Anatomy of a socket program
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字程序的结构
- en: As we mentioned in [Chapter 1](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml), *An
    Introduction to Networks and Protocols*, network programming is usually done using
    a client-server paradigm. In this paradigm, a server listens for new connections
    at a published address. The client, knowing the server's address, is the one to
    establish the connection initially. Once the connection is established, the client
    and the server can both send and receive data. This can continue until either
    the client or the server terminates the connection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml)，“网络和协议简介”中提到的，网络编程通常使用客户端-服务器范式。在这个范式中，服务器在一个已发布的地址上监听新的连接。客户端知道服务器的地址，是建立初始连接的一方。一旦建立连接，客户端和服务器都可以发送和接收数据。这可以持续到客户端或服务器终止连接。
- en: A traditional client-server model usually implies different behaviors for the
    client and server. The way web browsing works, for example, is that the server
    resides at a known address, waiting for connections. A client (web browser) establishes
    a connection and sends a request that includes which web page or resource it wants
    to download. The server then checks that it knows what to do with this request
    and responds appropriately (by sending the web page).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的客户端-服务器模型通常意味着客户端和服务器有不同的行为。例如，网页浏览的方式是服务器位于一个已知地址，等待连接。客户端（网页浏览器）建立连接并发送一个请求，包括它想要下载的网页或资源。然后服务器检查它是否知道如何处理这个请求，并相应地做出回应（通过发送网页）。
- en: An alternative paradigm is the peer-to-peer model. For example, this model is
    used by the BitTorrent protocol. In the peer-to-peer model, each peer has essentially
    the same responsibilities. While a web server is optimized to send requested data
    from the server to the client, a peer-to-peer protocol is balanced in that data
    is exchanged somewhat evenly between peers. However, even in the peer-to-peer
    model, the underlying sockets that are using TCP or UDP aren't created equal.
    That is, for each peer-to-peer connection, one peer was listening and the other
    connecting. BitTorrent works by having a central server (called a **tracker**)
    that stores a list of peer IP addresses. Each of the peers on that list has agreed
    to behave like a server and listen for new connections. When a new peer wants
    to join the swarm, it requests a list of peers from the central server, and then
    tries to establish a connection to peers on that list while simultaneously listening
    for new connections from other peers. In summary, a peer-to-peer protocol doesn't
    so much replace the client-server model; it is just expected that each peer be
    a client and a server both.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种范式是对等模型。例如，这个模型被BitTorrent协议使用。在对等模型中，每个对等方本质上都有相同的职责。虽然Web服务器被优化为从服务器向客户端发送请求的数据，但对等协议在数据在对等方之间交换上是平衡的。然而，即使在对等模型中，使用TCP或UDP的底层套接字也不尽相同。也就是说，对于每个对等连接，一个对等方在监听，另一个在连接。BitTorrent通过有一个中央服务器（称为**追踪器**）来工作，该服务器存储了一个对等IP地址列表。列表上的每个对等方都同意表现得像服务器并监听新的连接。当一个新对等方想要加入群体时，它会从中央服务器请求一个对等方列表，然后尝试与列表上的对等方建立连接，同时监听来自其他对等方的新连接。总之，对等协议并不是要完全取代客户端-服务器模型；它只是预期每个对等方既是客户端也是服务器。
- en: Another common protocol that pushes the boundary of the client-server paradigm
    is FTP. The FTP server listens for connections until the FTP client connects.
    After the initial connection, the FTP client issues commands to the server. If
    the FTP client requests a file from the server, the server will attempt to establish
    a new connection to the FTP client to transfer the file over. So, for this reason,
    the FTP client first establishes a connection as a TCP client, but later accepts
    connections like a TCP server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个推动客户端-服务器范式边界的常见协议是FTP。FTP服务器监听连接，直到FTP客户端连接。在初始连接之后，FTP客户端向服务器发送命令。如果FTP客户端从服务器请求文件，服务器将尝试与FTP客户端建立新的连接以传输文件。因此，出于这个原因，FTP客户端首先以TCP客户端的身份建立连接，但后来像TCP服务器一样接受连接。
- en: Network programs can usually be described as one of four types—a TCP server,
    a TCP client, a UDP server, or a UDP client. Some protocols call for a program
    to implement two, or even all four types, but it is useful for us to consider
    each of the four types separately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 网络程序通常可以描述为四种类型之一——TCP服务器、TCP客户端、UDP服务器或UDP客户端。某些协议要求程序实现两种，甚至所有四种类型，但对我们来说，分别考虑这四种类型是有用的。
- en: TCP program flow
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP程序流程
- en: A TCP client program must first know the TCP server's address. This is often
    input by a user. In the case of a web browser, the server address is either input
    directly by the user into the address bar, or is known from the user clicking
    on a link. The TCP client takes this address (for example, `http://example.com`)
    and uses the `getaddrinfo()` function to resolve it into a `struct addrinfo` structure.
    The client then creates a socket using a call to `socket()`. The client then establishes
    the new TCP connection by calling `connect()`. At this point, the client can freely
    exchange data using `send()` and `recv()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TCP客户端程序必须首先知道TCP服务器的地址。这通常由用户输入。在网页浏览器的例子中，服务器地址要么是用户直接在地址栏中输入，要么是用户点击链接时已知的。TCP客户端获取这个地址（例如，`http://example.com`），并使用`getaddrinfo()`函数将其解析为`struct
    addrinfo`结构。然后客户端通过调用`socket()`创建套接字。客户端随后通过调用`connect()`建立新的TCP连接。此时，客户端可以使用`send()`和`recv()`自由交换数据。
- en: A TCP server listens for connections at a particular port number on a particular
    interface. The program must first initialize a `struct addrinfo` structure with
    the proper listening IP address and port number. The `getaddrinfo()` function
    is helpful so that you can do this in an IPv4/IPv6 independent way. The server
    then creates the socket with a call to `socket()`. The socket must be bound to
    the listening IP address and port. This is accomplished with a call to `bind()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器在特定接口的特定端口号上监听连接。程序必须首先使用适当的监听IP地址和端口号初始化`struct addrinfo`结构。`getaddrinfo()`函数有助于以IPv4/IPv6独立的方式进行此操作。然后服务器通过调用`socket()`创建套接字。套接字必须绑定到监听IP地址和端口号。这是通过调用`bind()`实现的。
- en: The server program then calls `listen()`, which puts the socket in a state where
    it listens for new connections. The server can then call `accept()`, which will
    wait until a client establishes a connection to the server. When the new connection
    has been established, `accept()` returns a new socket. This new socket can be
    used to exchange data with the client using `send()` and `recv()`. Meanwhile,
    the first socket remains listening for new connections, and repeated calls to
    `accept()` allow the server to handle multiple clients.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器程序随后调用`listen()`，这将套接字置于监听新连接的状态。然后服务器可以调用`accept()`，这将等待直到客户端与服务器建立连接。当新的连接建立后，`accept()`返回一个新的套接字。这个新的套接字可以用来通过`send()`和`recv()`与客户端交换数据。同时，第一个套接字仍然在监听新的连接，重复调用`accept()`允许服务器处理多个客户端。
- en: 'Graphically, the program flow of a TCP client and server looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，TCP客户端和服务器程序流程如下：
- en: '![](img/59a85ccf-c015-4f95-b3c6-349a92f8d1a0.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59a85ccf-c015-4f95-b3c6-349a92f8d1a0.png)'
- en: The program flow given here should serve as a good example of how basic client-server
    TCP programs interact. That said, considerable variation on this basic program
    flow is possible. There is also no rule about which side calls `send()` or `recv()`
    first, or how many times. Both sides could call `send()` as soon as the connection
    is established.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的程序流程应该作为基本客户端-服务器TCP程序交互的良好示例。话虽如此，在这个基本程序流程上可能会有相当大的变化。关于哪一方首先调用`send()`或`recv()`，或调用多少次，也没有规则。双方可以在连接建立后立即调用`send()`。
- en: Also, note that the TCP client could call `bind()` before `connect()` if it
    is particular about which network interface is being used to connect with. This
    is sometimes important on servers that have multiple network interfaces. It's
    often not important for general purpose software.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，如果TCP客户端对要使用的网络接口有特定要求，它可以在`connect()`之前调用`bind()`。这在具有多个网络接口的服务器上有时很重要。对于通用软件通常并不重要。
- en: Many other variations of TCP operation are possible too, and we will look at
    some in [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth
    Overview of TCP Connections*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TCP操作的其他许多变体也是可能的，我们将在[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，“TCP连接的深入概述”中探讨一些。
- en: UDP program flow
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP程序流程
- en: A UDP client must know the address of the remote UDP peer in order to send the
    first packet. The UDP client uses the `getaddrinfo()` function to resolve the
    address into a `struct addrinfo` structure. Once this is done, the client creates
    a socket of the proper type. The client can then call `sendto()` on the socket
    to send the first packet. The client can continue to call `sendto()` and `recvfrom()`
    on the socket to send and receive additional packets. Note that the client must
    send the first packet with `sendto()`. The UDP client cannot receive data first,
    as the remote peer would have no way of knowing where to send data without it
    first receiving data from the client. This is different from TCP, where a connection
    is first established with a handshake. In TCP, either the client or server can
    send the first application data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个UDP客户端必须知道远程UDP对等方的地址，才能发送第一个数据包。UDP客户端使用`getaddrinfo()`函数将地址解析为`struct addrinfo`结构。一旦完成，客户端将创建适当类型的套接字。然后，客户端可以在套接字上调用`sendto()`来发送第一个数据包。客户端可以继续在套接字上调用`sendto()`和`recvfrom()`来发送和接收额外的数据包。请注意，客户端必须使用`sendto()`发送第一个数据包。UDP客户端不能先接收数据，因为远程对等方在没有先从客户端接收数据的情况下，将无法知道数据应该发送到哪里。这与TCP不同，TCP首先通过握手建立连接。在TCP中，客户端或服务器都可以先发送第一个应用数据。
- en: A UDP server listens for connections from a UDP client. This server should initialize `struct
    addrinfo` structure with the proper listening IP address and port number. The
    `getaddrinfo()` function can be used to do this in a protocol-independent way.
    The server then creates a new socket with `socket()` and binds it to the listening
    IP address and port number using `bind()`. At this point, the server can call
    `recvfrom()`, which causes it to block until it receives data from a UDP client.
    After the first data is received, the server can reply with `sendto()` or listen
    for more data (from the first client or any new client) with `recvfrom()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个UDP服务器监听来自UDP客户端的连接。这个服务器应该使用正确的监听IP地址和端口号初始化`struct addrinfo`结构。可以使用`getaddrinfo()`函数以协议无关的方式完成此操作。然后，服务器使用`socket()`创建一个新的套接字，并使用`bind()`将其绑定到监听的IP地址和端口号。此时，服务器可以调用`recvfrom()`，这将使其阻塞，直到从UDP客户端接收数据。接收第一个数据后，服务器可以使用`sendto()`进行回复，或者使用`recvfrom()`监听更多数据（来自第一个客户端或任何新的客户端）。
- en: 'Graphically, the program flow of a UDP client and server looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，UDP客户端和服务器程序流程如下：
- en: '![](img/1201c9b4-5159-47e2-a5a0-b2c4fb3b7e20.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1201c9b4-5159-47e2-a5a0-b2c4fb3b7e20.png)'
- en: We cover some variations of this example program flow in [Chapter 4](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml),
    *Establishing UDP Connections*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml)，“建立UDP连接”中讨论了此示例程序流程的一些变体。
- en: We're almost ready to begin implementing our first networked program, but before
    we begin, we should take care of some cross-platform concerns. Let's work on this
    now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好开始实现我们的第一个网络程序了，但在开始之前，我们应该注意一些跨平台的问题。现在让我们来处理这个问题。
- en: Berkeley sockets versus Winsock sockets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伯克利套接字与Winsock套接字
- en: As we stated earlier, Winsock sockets were modeled on Berkeley sockets. Therefore,
    there are many similarities between them. However, there are also many differences
    we need to be aware of.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Winsock套接字是基于伯克利套接字设计的。因此，它们之间有许多相似之处。然而，也有许多我们需要注意的差异。
- en: In this book, we will try to create each program so that it can run on both
    Windows and Unix-based operating systems. This is made much easier by defining
    a few C macros to help us with this.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将尝试创建每个程序，使其能够在Windows和基于Unix的操作系统中运行。通过定义一些C宏来帮助我们，这使得这个过程变得容易得多。
- en: Header files
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件
- en: As we mentioned earlier, the needed header files differ between implementations.
    We've already seen how these header file discrepancies can be easily overcome
    with a preprocessor statement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，所需的头文件在不同的实现之间有所不同。我们已经看到如何使用预处理语句轻松克服这些头文件差异。
- en: Socket data type
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字数据类型
- en: In UNIX, a socket descriptor is represented by a standard file descriptor. This
    means you can use any of the standard UNIX file I/O functions on sockets. This
    isn't true on Windows, so we simply avoid these functions to maintain portability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX中，套接字描述符由标准文件描述符表示。这意味着你可以对套接字使用任何标准的UNIX文件I/O函数。在Windows上并非如此，所以我们简单地避免这些函数以保持可移植性。
- en: 'Additionally, in UNIX, all file descriptors (and therefore socket descriptors)
    are small, non-negative integers. In Windows, a socket handle can be anything.
    Furthermore, in UNIX, the `socket()` function returns an `int`, whereas in Windows
    it returns a `SOCKET`. `SOCKET` is a `typedef` for an `unsigned int` in the Winsock
    headers. As a workaround, I find it useful to either `typedef int SOCKET` or `#define
    SOCKET int` on non-Windows platforms. That way, you can store a socket descriptor
    as a `SOCKET` type on all platforms:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在UNIX中，所有文件描述符（因此也是套接字描述符）都是小的、非负整数。在Windows中，套接字句柄可以是任何东西。此外，在UNIX中，`socket()`函数返回一个`int`，而在Windows中返回一个`SOCKET`。`SOCKET`是Winsock头文件中`unsigned
    int`的`typedef`。作为一个解决方案，我发现将`typedef int SOCKET`或`#define SOCKET int`在非Windows平台上是有用的。这样，你可以在所有平台上将套接字描述符存储为`SOCKET`类型：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Invalid sockets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无效套接字
- en: 'On Windows, `socket()` returns `INVALID_SOCKET` if it fails. On Unix, `socket()`
    returns a negative number on failure. This is particularly problematic as the
    Windows `SOCKET` type is unsigned. I find it useful to define a macro to indicate
    if a socket descriptor is valid or not:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，如果`socket()`失败，则返回`INVALID_SOCKET`。在Unix上，如果`socket()`失败，则返回一个负数。这尤其成问题，因为Windows的`SOCKET`类型是无符号的。我发现定义一个宏来指示套接字描述符是否有效是有用的：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Closing sockets
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭套接字
- en: 'All sockets on Unix systems are also standard file descriptors. For this reason,
    sockets on Unix systems can be closed using the standard `close()` function. On
    Windows, a special close function is used instead—`closesocket()`. It''s useful
    to abstract out this difference with a macro:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中，所有套接字也都是标准文件描述符。因此，Unix系统上的套接字可以使用标准的`close()`函数关闭。在Windows上，则使用特殊的关闭函数——`closesocket()`。使用宏抽象出这种差异是有用的：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Error handling
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'When a socket function, such as `socket()`, `bind()`, `accept()`, and so on,
    has an error on a Unix platform, the error number gets stored in the thread-global
    `errno` variable. On Windows, the error number can be retrieved by calling `WSAGetLastError()`
    instead. Again, we can abstract out this difference using a macro:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字函数，如`socket()`、`bind()`、`accept()`等，在Unix平台上出现错误时，错误号会被存储在线程全局的`errno`变量中。在Windows上，可以通过调用`WSAGetLastError()`来检索错误号。同样，我们可以使用宏来抽象出这种差异：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to obtaining an error code, it is often useful to retrieve a text
    description of the error condition. Please refer to [Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml), *Socket
    Programming Tips and Pitfalls*, for a technique for this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取错误代码外，检索错误条件的文本描述通常也很有用。请参阅[第13章](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml)，*套接字编程技巧与陷阱*，了解如何进行此操作。
- en: With these helper macros out of the way, let's dive into our first real socket
    program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些辅助宏处理完毕后，让我们深入到我们的第一个真正的套接字程序。
- en: Our first program
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个程序
- en: Now that we have a basic idea of socket APIs and the structure of networked
    programs, we are ready to begin our first program. By building an actual real-world
    program, we will learn the useful details of how socket programming actually works.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对套接字API和网络程序的结构有了基本了解，我们准备开始我们的第一个程序。通过构建一个实际的真实世界程序，我们将学习套接字编程实际工作的有用细节。
- en: As an example task, we are going to build a web server that tells you what time
    it is right now. This could be a useful resource for anybody with a smartphone
    or web browser that needs to know what time it is right now. They can simply navigate
    to our web page and find out. This is a good first example because it does something
    useful but still trivial enough that it won't distract from what we are trying
    to learn—network programming.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例任务，我们将构建一个可以告诉你现在是什么时间的Web服务器。这对于任何需要知道现在时间的智能手机或网页浏览器的用户来说可能是一个有用的资源。他们只需导航到我们的网页，就可以找到答案。这是一个很好的入门示例，因为它做了一些有用的事情，但仍然足够简单，不会分散我们对网络编程的学习。
- en: A motivating example
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个激励性的例子
- en: Before we begin the networked program, it is useful to solve our problem with
    a simple console program first. In general, it is a good idea to work out your
    program's functionality locally before adding in networked features.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写联网程序之前，先解决我们的简单控制台程序问题是有用的。一般来说，在添加联网功能之前，在本地解决程序的功能是一个好主意。
- en: 'The local, console version of our time-telling program is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间显示程序的本地、控制台版本如下：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can compile and run it like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样编译和运行它：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program works by getting the time with the built-in C `time()` function.
    It then converts it into a string with the `ctime()` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过使用内置的C `time()`函数获取时间，然后使用`ctime()`函数将其转换为字符串。
- en: Making it networked
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其联网
- en: Now that we've worked out our program's functionality, we can begin on the networked
    version of the same program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了程序的功能，我们可以开始编写相同程序的联网版本。
- en: 'To begin with, we include the needed headers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含所需的头文件：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we discussed earlier, this detects if the compiler is running on Windows
    or not and includes the proper headers for the platform it is running on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，这检测编译器是否在Windows上运行，并为它运行的平台包含适当的头文件。
- en: 'We also define some macros, which abstract out some of the difference between
    the Berkeley socket and Winsock APIs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一些宏，这些宏抽象出了伯克利套接字和Winsock API之间的一些差异：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need a couple of standard C headers, hopefully for obvious reasons:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要几个标准C头文件，希望原因很明显：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are ready to begin the `main()` function. The first thing the `main()`
    function will do is initialize Winsock if we are compiling on Windows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始编写`main()`函数。如果我们在Windows上编译，`main()`函数首先会初始化Winsock：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We must now figure out the local address that our web server should bind to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须确定我们的Web服务器应该绑定的本地地址：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use `getaddrinfo()` to fill in a `struct addrinfo` structure with the needed
    information. `getaddrinfo()` takes a `hints` parameter, which tells it what we're
    looking for. In this case, we've zeroed out `hints` using `memset()` first. Then,
    we set `ai_family = AF_INET`. `AF_INET` specifies that we are looking for an IPv4
    address. We could use `AF_INET6` to make our web server listen on an IPv6 address
    instead (more on this later).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getaddrinfo()`将所需信息填充到`struct addrinfo`结构中。`getaddrinfo()`函数接受一个`hints`参数，它告诉它我们在寻找什么。在这种情况下，我们首先使用`memset()`将`hints`清零。然后，我们设置`ai_family
    = AF_INET`。`AF_INET`指定我们正在寻找一个IPv4地址。我们可以使用`AF_INET6`来使我们的Web服务器监听IPv6地址（关于这一点稍后讨论）。
- en: Next, we set `ai_socktype = SOCK_STREAM`. This indicates that we're going to
    be using TCP. `SOCK_DGRAM` would be used if we were doing a UDP server instead.
    Finally, `ai_flags = AI_PASSIVE` is set. This is telling `getaddrinfo()` that
    we want it to bind to the wildcard address. That is, we are asking `getaddrinfo()`
    to set up the address, so we listen on any available network interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置`ai_socktype = SOCK_STREAM`。这表示我们将使用TCP。如果我们正在做UDP服务器，将使用`SOCK_DGRAM`。最后，`ai_flags
    = AI_PASSIVE`被设置。这告诉`getaddrinfo()`我们希望它绑定到通配符地址。也就是说，我们要求`getaddrinfo()`设置地址，以便我们可以在任何可用的网络接口上监听。
- en: Once `hints` is set up properly, we declare a pointer to a `struct addrinfo`
    structure, which holds the return information from `getaddrinfo()`. We then call
    the `getaddrinfo()` function. The `getaddrinfo()` function has many uses, but
    for our purpose, it generates an address that's suitable for `bind()`. To make
    it generate this, we must pass in the first parameter as `NULL` and have the `AI_PASSIVE`
    flag set in `hints.ai_flags`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确设置了`hints`，我们就声明一个指向`struct addrinfo`结构的指针，该结构保存了`getaddrinfo()`函数的返回信息。然后我们调用`getaddrinfo()`函数。`getaddrinfo()`函数有很多用途，但就我们的目的而言，它生成一个适合`bind()`的地址。为了使其生成这个地址，我们必须将第一个参数传递为`NULL`，并在`hints.ai_flags`中设置`AI_PASSIVE`标志。
- en: The second parameter to `getaddrinfo()` is the port we listen for connections
    on. A standard HTTP server would use port `80`. However, only privileged users
    on Unix-like operating systems can bind to ports `0` through `1023`. The choice
    of port number here is arbitrary, but we use `8080` to avoid issues. If you are
    running with superuser privileges, feel free to change the port number to `80`
    if you like. Keep in mind that only one program can bind to a particular port
    at a time. If you try to use a port that is already in use, then the call to `bind()` fails.
    In this case, just change the port number to something else and try again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 的第二个参数是我们监听连接的端口。标准的 HTTP 服务器会使用端口 `80`。然而，只有 Unix-like 操作系统上的特权用户才能绑定端口
    `0` 到 `1023`。这里端口号的选择是任意的，但我们使用 `8080` 来避免问题。如果您以超级用户权限运行，如果您喜欢，可以随意将端口号更改为 `80`。请记住，一次只能有一个程序绑定到特定的端口。如果您尝试使用已被占用的端口，则
    `bind()` 调用将失败。在这种情况下，只需将端口号更改为其他值并再次尝试即可。'
- en: It is common to see programs that don't use `getaddrinfo()` here. Instead, they
    fill in a `struct addrinfo` structure directly. The advantage to using `getaddrinfo()`
    is that it is protocol-independent. Using `getaddrinfo()` makes it very easy to
    convert our program from IPv4 to IPv6\. In fact, we only need to change `AF_INET`
    to `AF_INET6`, and our program will work on IPv6\. If we filled in the `struct
    addrinfo` structure directly, we would need to make many tedious changes to convert
    our program into IPv6.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的情况是程序在这里不使用 `getaddrinfo()`。相反，它们直接填充 `struct addrinfo` 结构。使用 `getaddrinfo()`
    的优点是它是协议无关的。使用 `getaddrinfo()` 使得将我们的程序从 IPv4 转换为 IPv6 变得非常容易。实际上，我们只需要将 `AF_INET`
    更改为 `AF_INET6`，我们的程序就可以在 IPv6 上运行。如果我们直接填充 `struct addrinfo` 结构，我们需要对程序进行许多繁琐的更改才能将其转换为
    IPv6。
- en: 'Now that we''ve figured out our local address info, we can create the socket:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了我们的本地地址信息，我们就可以创建套接字：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we define `socket_listen` as a `SOCKET` type. Recall that `SOCKET` is
    a Winsock type on Windows, and that we have a macro defining it as `int` on other
    platforms. We call the `socket()` function to generate the actual socket. `socket()`
    takes three parameters: the socket family, the socket type, and the socket protocol.
    The reason we used `getaddrinfo()` before calling `socket()` is that we can now
    pass in parts of `bind_address` as the arguments to `socket()`. Again, this makes
    it very easy to change our program''s protocol without needing a major rewrite.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `socket_listen` 定义为 `SOCKET` 类型。回想一下，`SOCKET` 是 Windows 上的 Winsock 类型，而在其他平台上，我们使用宏将其定义为
    `int`。我们调用 `socket()` 函数来生成实际的套接字。`socket()` 函数接受三个参数：套接字族、套接字类型和套接字协议。我们在调用 `socket()`
    之前使用 `getaddrinfo()` 的原因是我们现在可以将 `bind_address` 的部分作为 `socket()` 的参数传递。再次强调，这使得在不进行重大重写的情况下更改我们程序的协议变得非常容易。
- en: It is common to see programs written so that they call `socket()` first. The
    problem with this is that it makes the program more complicated as the socket
    family, type, and protocol must be entered multiple times. Structuring our program
    as we have here is better.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的情况是程序首先调用 `socket()`。这种做法的问题在于，它使得程序变得更加复杂，因为必须多次输入套接字族、类型和协议。像我们这里这样组织程序会更好。
- en: 'We should check that the call to `socket()` was successful:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查 `socket()` 的调用是否成功：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can check that `socket_listen` is valid using the `ISVALIDSOCKET()` macro
    we defined earlier. If the socket is not valid, we print an error message. Our
    `GETSOCKETERRNO()` macro is used to retrieve the error number in a cross-platform
    way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们之前定义的 `ISVALIDSOCKET()` 宏来检查 `socket_listen` 是否有效。如果套接字无效，我们打印一条错误信息。我们的
    `GETSOCKETERRNO()` 宏用于以跨平台的方式检索错误号。
- en: 'After the socket has been created successfully, we can call `bind()` to associate
    it with our address from `getaddrinfo()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字成功创建之后，我们可以调用 `bind()` 来将其与 `getaddrinfo()` 中的地址关联：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`bind()` returns `0` on success and non-zero on failure. If it fails, we print
    the error number much like we did for the error handling on `socket()`. `bind()` fails
    if the port we are binding to is already in use. In that case, either close the
    program using that port or change your program to use a different port.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 在成功时返回 `0`，在失败时返回非零值。如果它失败了，我们会像处理 `socket()` 上的错误一样打印错误号。如果我们要绑定的端口已被占用，`bind()`
    将失败。在这种情况下，要么关闭使用该端口的程序，要么更改您的程序以使用不同的端口。'
- en: After we have bound to `bind_address`, we can call the `freeaddrinfo()` function
    to release the address memory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将地址绑定到 `bind_address` 之后，我们可以调用 `freeaddrinfo()` 函数来释放地址内存。
- en: 'Once the socket has been created and bound to a local address, we can cause
    it to start listening for connections with the `listen()` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并绑定到本地地址的套接字，我们可以使用`listen()`函数让它开始监听连接：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second argument to `listen()`, which is `10` in this case, tells `listen()`
    how many connections it is allowed to queue up. If many clients are connecting
    to our server all at once, and we aren't dealing with them fast enough, then the
    operating system begins to queue up these incoming connections. If `10` connections
    become queued up, then the operating system will reject new connections until
    we remove one from the existing queue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()`的第二个参数，在这个例子中是`10`，告诉`listen()`它可以允许多少个连接排队。如果许多客户端同时连接到我们的服务器，而我们处理它们不够快，那么操作系统开始排队这些传入的连接。如果`10`个连接排队，那么操作系统将拒绝新的连接，直到我们从现有队列中移除一个。'
- en: Error handling for `listen()` is done the same way as we did for `bind()` and
    `socket()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()`的错误处理方式与我们对`bind()`和`socket()`的处理方式相同。'
- en: 'After the socket has begun listening for connections, we can accept any incoming
    connection with the `accept()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字开始监听连接后，我们可以使用`accept()`函数接受任何传入的连接：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`accept()` has a few functions. First, when it''s called, it will block your
    program until a new connection is made. In other words, your program will sleep
    until a connection is made to the listening socket. When the new connection is
    made, `accept()` will create a new socket for it. Your original socket continues
    to listen for new connections, but the new socket returned by `accept()` can be
    used to send and receive data over the newly established connection. `accept()` also
    fills in address info of the client that connected.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()`有几个功能。首先，当它被调用时，它将阻塞你的程序，直到建立新的连接。换句话说，你的程序将休眠，直到连接到监听套接字。当建立新的连接时，`accept()`将为它创建一个新的套接字。你的原始套接字继续监听新的连接，但`accept()`返回的新套接字可以用来通过新建立的连接发送和接收数据。`accept()`还填充了连接客户端的地址信息。'
- en: Before calling `accept()`, we must declare a new `struct sockaddr_storage` variable
    to store the address info for the connecting client. The `struct sockaddr_storage`
    type is guaranteed to be large enough to hold the largest supported address on
    your system. We must also tell `accept()` the size of the address buffer we're
    passing in. When `accept()` returns, it will have filled in `client_address` with
    the connected client's address and `client_len` with the length of that address.
    `client_len` differs, depending on whether the connection is using IPv4 or IPv6.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`accept()`之前，我们必须声明一个新的`struct sockaddr_storage`变量来存储连接客户端的地址信息。`struct sockaddr_storage`类型保证足够大，可以容纳系统上支持的最大地址。我们还必须告诉`accept()`我们传递的地址缓冲区的大小。当`accept()`返回时，它将用连接客户端的地址填充`client_address`，并用该地址的长度填充`client_len`。`client_len`的值取决于连接是使用IPv4还是IPv6。
- en: We store the return value of `accept()` in `socket_client`. We check for errors
    by detecting if `client_socket` is a valid socket. This is done in exactly the
    same way as we did for `socket()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`accept()`的返回值存储在`socket_client`中。我们通过检测`client_socket`是否是一个有效的套接字来检查错误。这与我们对`socket()`的处理方式完全相同。
- en: 'At this point, a TCP connection has been established to a remote client. We
    can print the client''s address to the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，已经与远程客户端建立了一个TCP连接。我们可以将客户端的地址打印到控制台：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This step is completely optional, but it is good practice to log network connections
    somewhere.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步完全是可选的，但将网络连接记录在某个地方是一个好的实践。
- en: '`getnameinfo()` takes the client''s address and address length. The address
    length is needed because `getnameinfo()` can work with both IPv4 and IPv6 addresses.
    We then pass in an output buffer and buffer length. This is the buffer that `getnameinfo()` writes
    its hostname output to. The next two arguments specify a second buffer and its
    length. `getnameinfo()` outputs the service name to this buffer. We don''t care
    about that, so we''ve passed in `0` for those two parameters. Finally, we pass
    in the `NI_NUMERICHOST` flag, which specifies that we want to see the hostname
    as an IP address.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`getnameinfo()`接受客户端的地址和地址长度。地址长度是必需的，因为`getnameinfo()`可以与IPv4和IPv6地址一起工作。然后我们传递一个输出缓冲区和缓冲区长度。这是`getnameinfo()`将主机名输出写入的缓冲区。接下来的两个参数指定第二个缓冲区和其长度。`getnameinfo()`将服务名输出到这个缓冲区。我们对此不感兴趣，所以为这两个参数传递了`0`。最后，我们传递了`NI_NUMERICHOST`标志，指定我们希望以IP地址的形式看到主机名。'
- en: 'As we are programming a web server, we expect the client (for example, a web
    browser) to send us an HTTP request. We read this request using the `recv()` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个 Web 服务器，我们期望客户端（例如，一个 Web 浏览器）发送给我们一个 HTTP 请求。我们使用 `recv()` 函数读取这个请求：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We define a request buffer, so that we can store the browser's HTTP request.
    In this case, we allocate 1,024 bytes to it, which should be enough for this application.
    `recv()` is then called with the client's socket, the request buffer, and the
    request buffer size. `recv()` returns the number of bytes that are received. If
    nothing has been received yet, `recv()` blocks until it has something. If the
    connection is terminated by the client, `recv()` returns `0` or `-1`, depending
    on the circumstance. We are ignoring that case here for simplicity, but you should
    always check that `recv() > 0` in production. The last parameter to `recv()` is
    for flags. Since we are not doing anything special, we simply pass in `0`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个请求缓冲区，以便我们可以存储浏览器的 HTTP 请求。在这种情况下，我们分配了 1,024 字节给它，这对于这个应用程序来说应该足够了。然后使用客户端套接字、请求缓冲区和请求缓冲区大小调用
    `recv()`。`recv()` 返回接收到的字节数。如果还没有收到任何内容，`recv()` 将阻塞，直到有内容。如果连接被客户端终止，`recv()`
    返回 `0` 或 `-1`，具体取决于情况。在这里我们忽略这种情况以简化问题，但在生产环境中你应该始终检查 `recv() > 0`。`recv()` 的最后一个参数是标志。由于我们不做任何特殊的事情，我们简单地传递
    `0`。
- en: The request received from our client should follow the proper HTTP protocol.
    We will go into detail about HTTP in [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml), *Building
    a Simple Web Client*, and [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml), *Building
    a Simple Web Server*, where we will work on web clients and servers. A real web
    server would need to parse the request and look at which resource the web browser
    is requesting. Our web server only has one function—to tell us what time it is.
    So, for now, we just ignore the request altogether.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的客户请求应遵循正确的 HTTP 协议。我们将在[第 6 章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的
    Web 客户端*，和[第 7 章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)，*构建简单的 Web 服务器*中详细介绍
    HTTP，在那里我们将处理 Web 客户端和服务器。一个真正的 Web 服务器需要解析请求并查看浏览器请求的是哪个资源。我们的 Web 服务器只有一个功能——告诉我们现在是什么时间。所以，现在我们只是完全忽略这个请求。
- en: 'If you want to print the browser''s request to the console, you can do it like
    this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将浏览器的请求打印到控制台，你可以这样做：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we use the `printf()` format string, `"%.*s"`. This tells `printf()`
    that we want to print a specific number of characters—`bytes_received`. It is
    a common mistake to try printing data that's received from `recv()` directly as
    a C string. There is no guarantee that the data received from `recv()` is null
    terminated! If you try to print it with `printf(request)` or `printf("%s", request)`,
    you will likely receive a segmentation fault error (or at best it will print some
    garbage).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的是 `printf()` 格式字符串，`"%.*s"`。这告诉 `printf()` 我们想要打印特定数量的字符——`bytes_received`。尝试直接将
    `recv()` 接收到的数据作为 C 字符串打印是一个常见的错误。从 `recv()` 接收到的数据没有保证是空终止的！如果你尝试用 `printf(request)`
    或 `printf("%s", request)` 打印它，你很可能会收到一个段错误错误（或者最多打印一些垃圾）。
- en: 'Now that the web browser has sent its request, we can send our response back:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Web 浏览器已经发送了它的请求，我们可以发送我们的响应回：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To begin with, we set `char *response` to a standard HTTP response header and
    the beginning of our message (`Local time is:`). We will discuss HTTP in detail
    in [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml), *Building a Simple
    Web Client*, and [Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml), *Building
    a Simple Web Server*. For now, know that this response tells the browser three
    things—your request is OK; the server will close the connection when all the data
    is sent and the data you receive will be plain text.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `char *response` 设置为一个标准的 HTTP 响应头和我们的消息的开始（`Local time is:`）。我们将在[第
    6 章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的 Web 客户端*，和[第 7 章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)，*构建简单的
    Web 服务器*中详细讨论 HTTP。现在，知道这个响应告诉浏览器三件事——你的请求是有效的；服务器将在所有数据发送完毕后关闭连接，你接收到的数据将是纯文本。
- en: The HTTP response header ends with a blank line. HTTP requires line endings
    to take the form of a carriage return character, followed by a newline character.
    So, a blank line in our response is `\r\n`. The part of the string that comes
    after the blank line, `Local time is:`, is treated by the browsers as plain text.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应头以一个空白行结束。HTTP 要求行结束以回车字符后跟换行字符的形式出现。所以，我们响应中的空白行是 `\r\n`。空白行之后的字符串部分，`Local
    time is:`，被浏览器视为纯文本。
- en: We send the data to the client using the `send()` function. This function takes
    the client's socket, a pointer to the data to be sent, and the length of the data
    to send. The last parameter to `send()` is flags. We don't need to do anything
    special, so we pass in `0`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`send()`函数将数据发送到客户端。这个函数接受客户端的套接字、要发送的数据的指针以及要发送的数据长度。`send()`的最后一个参数是标志。我们不需要做任何特殊的事情，所以我们传入`0`。
- en: '`send()` returns the number of bytes sent. You should generally check that
    the number of bytes sent was as expected, and you should attempt to send the rest
    if it''s not. We are ignoring that detail here for simplicity. (Also, we are only
    attempting to send a few bytes; if `send()` can''t handle that, then something
    is probably very broken, and resending won''t help.)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`返回发送的字节数。你应该通常检查发送的字节数是否符合预期，如果不一致，你应该尝试发送剩余的数据。这里为了简单起见，我们忽略这个细节。（此外，我们只尝试发送几个字节；如果`send()`无法处理，那么可能非常严重的问题，重新发送也不会有帮助。）'
- en: 'After the HTTP header and the beginning of our message is sent, we can send
    the actual time. We get the local time the same way we did in `time_console.c`,
    and we send it using `send()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送HTTP头和我们的消息的开始之后，我们可以发送实际的时间。我们以与`time_console.c`中相同的方式获取本地时间，并使用`send()`发送它：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We must then close the client connection to indicate to the browser that we''ve
    sent all of our data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须关闭客户端连接，以向浏览器表明我们已经发送了所有数据：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we don't close the connection, the browser will just wait for more data until
    it times out.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关闭连接，浏览器将等待更多数据，直到超时。
- en: 'At this point, we could call `accept()` on `socket_listen` to accept additional
    connections. That is exactly what a real server would do. However, as this is
    just a quick example program, we will instead close the listening socket too and
    terminate the program:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以调用`socket_listen`上的`accept()`来接受额外的连接。这正是真实服务器会做的事情。然而，由于这是一个快速示例程序，我们将关闭监听套接字并终止程序：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's the complete program. After you compile and run it, you can navigate
    a web browser to it, and it'll display the current time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完整的程序。编译并运行它后，你可以使用网页浏览器导航到它，它将显示当前时间。
- en: 'On Linux and macOS, you can compile and run the program like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，你可以这样编译和运行程序：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On Windows, you can compile and run with MinGW using these commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以使用MinGW编译和运行，以下是一些命令：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you run the program, it waits for a connection. You can open a web browser
    and navigate to `http://127.0.0.1:8080` to load the web page. Recall that `127.0.0.1`
    is the IPv4 loopback address, which connects to the same machine it's running
    on. The `:8080` part of the URL specifies the port number to connect to. If it
    were left out, your browser would default to port `80`, which is the standard
    for HTTP connections.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它会等待连接。你可以打开一个网页浏览器，导航到`http://127.0.0.1:8080`来加载网页。记住`127.0.0.1`是IPv4回环地址，它连接到运行程序的同台机器。URL中的`:8080`部分指定了要连接的端口号。如果省略了这部分，你的浏览器将默认连接到端口`80`，这是HTTP连接的标准。
- en: 'Here is what you should see if you compile and run the program, and then connect
    a web browser to it on the same computer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行程序，然后在同一台计算机上使用网页浏览器连接到它，你应该看到以下内容：
- en: '![](img/cf0b6dc6-dc76-4a82-8491-12db5c626b05.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf0b6dc6-dc76-4a82-8491-12db5c626b05.png)'
- en: 'Here is the web browser connected to our `time_server` program on port `8080`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是连接到我们`time_server`程序端口`8080`的网页浏览器：
- en: '![](img/c6ec89d7-cddd-42a2-aa9a-ea7962479d89.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6ec89d7-cddd-42a2-aa9a-ea7962479d89.png)'
- en: Working with IPv6
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IPv6
- en: Please recall the `hints.ai_family = AF_INET` part of `time_server.c` near the
    beginning of the `main()` function. If this line is changed to `hints.ai_family
    = AF_INET6`, then your web server listens for IPv6 connections instead of IPv4
    connections. This modified file is included in the GitHub repository as `time_server_ipv6.c`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆一下在`main()`函数开头附近的`time_server.c`中的`hints.ai_family = AF_INET`部分。如果这一行改为`hints.ai_family
    = AF_INET6`，那么你的网络服务器将监听IPv6连接而不是IPv4连接。这个修改后的文件包含在GitHub仓库中，文件名为`time_server_ipv6.c`。
- en: In this case, you should navigate your web browser to `http://[::1]:8080` to
    see the web page. `::1` is the IPv6 loopback address, which tells the web browser
    to connect to the same machine it's running on. In order to use IPv6 addresses
    in URLs, you need to put them in square brackets, `[]`. `:8080` specifies the
    port number in the same way that we did for the IPv4 example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该使用你的网络浏览器导航到`http://[::1]:8080`以查看网页。`::1`是IPv6回环地址，它告诉网络浏览器连接到运行它的同一台机器。为了在URL中使用IPv6地址，你需要将它们放在方括号`[]`中。`:8080`指定端口号，这与我们为IPv4示例所做的方式相同。
- en: 'Here is what you should see when compiling, running, and connecting a web browser
    to our `time_server_ipv6` program:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编译、运行并将网络浏览器连接到我们的`time_server_ipv6`程序时应看到的内容：
- en: '![](img/ef16537f-a6b5-4b88-835e-5bc2c971b4c9.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef16537f-a6b5-4b88-835e-5bc2c971b4c9.png)'
- en: 'Here is the web browser that''s connected to our server using an IPv6 socket:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用IPv6套接字连接到我们服务器的网络浏览器：
- en: '![](img/3d9c9073-759e-46eb-9958-f8aedca7e8af.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d9c9073-759e-46eb-9958-f8aedca7e8af.png)'
- en: See `time_server_ipv6.c` for the complete program.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`time_server_ipv6.c`以获取完整的程序。
- en: Supporting both IPv4 and IPv6
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持IPv4和IPv6
- en: It is also possible for the listening IPv6 socket to accept IPv4 connections
    with a dual-stack socket. Not all operating systems support dual-stack sockets.
    With Linux in particular, support varies between distros. If your operating system
    does support dual-stack sockets, then I highly recommend implementing your server
    programs using this feature. It allows your programs to communicate with both
    IPv4 and IPv6 peers while requiring no extra work on your part.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 监听的IPv6套接字也可以接受使用双栈套接字的IPv4连接。并非所有操作系统都支持双栈套接字。特别是Linux，不同发行版之间的支持情况各不相同。如果你的操作系统支持双栈套接字，那么我强烈建议使用此功能实现你的服务器程序。这允许你的程序与IPv4和IPv6对等方通信，而无需你进行额外的工作。
- en: 'We can modify `time_server_ipv6.c` to use dual-stack sockets with only a minor
    addition. After the call to `socket()` and before the call to `bind()`, we must
    clear the `IPV6_V6ONLY` flag on the socket. This is done with the `setsockopt()`
    function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改`time_server_ipv6.c`以使用双栈套接字，只需进行微小的添加。在调用`socket()`之后和调用`bind()`之前，我们必须清除套接字上的`IPV6_V6ONLY`标志。这是通过`setsockopt()`函数完成的：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We first declare `option` as an integer and set it to `0`. `IPV6_V6ONLY` is
    enabled by default, so we clear it by setting it to `0`. `setsockopt()` is called
    on the listening socket. We pass in `IPPROTO_IPV6` to tell it what part of the
    socket we're operating on, and we pass in `IPV6_V6ONLY` to tell it which flag
    we are setting. We then pass in a pointer to our option and its length. `setsockopt()` returns `0`
    on success.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`option`声明为整数并将其设置为`0`。`IPV6_V6ONLY`默认启用，所以我们通过将其设置为`0`来清除它。在监听套接字上调用`setsockopt()`。我们传入`IPPROTO_IPV6`来告诉它我们在操作套接字的哪个部分，并传入`IPV6_V6ONLY`来告诉它我们正在设置哪个标志。然后我们传入一个指向我们的选项的指针及其长度。`setsockopt()`在成功时返回`0`。
- en: 'Windows Vista and later supports dual-stack sockets. However, many Windows
    headers are missing the definitions for `IPV6_V6ONLY`. For this reason, it might
    make sense to include the following code snippet at the top of the file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Vista及以后的版本支持双栈套接字。然而，许多Windows头文件缺少`IPV6_V6ONLY`的定义。因此，在文件顶部包含以下代码片段可能是有意义的：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Keep in mind that the socket needs to be initially created as an IPv6 socket.
    This is accomplished with the `hints.ai_family = AF_INET6` line in our code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，套接字最初需要被创建为IPv6套接字。这可以通过我们代码中的`hints.ai_family = AF_INET6`行来完成。
- en: When an IPv4 peer connects to our dual-stack server, the connection is remapped
    to an IPv6 connection. This happens automatically and is taken care of by the
    operating system. When your program sees the client IP address, it will still
    be presented as a special IPv6 address. These are represented by IPv6 addresses
    where the first 96 bits consist of the prefix—`0:0:0:0:0:ffff`. The last 32 bits
    of the address are used to store the IPv4 address. For example, if a client connects
    with the IPv4 address `192.168.2.107`, then your dual-stack server sees it as
    the IPv6 address `::ffff.192.168.2.107`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个IPv4对等方连接到我们的双栈服务器时，连接会被重映射到IPv6连接。这会自动发生，并由操作系统处理。当你的程序看到客户端IP地址时，它仍然会以一个特殊的IPv6地址呈现。这些地址由IPv6地址表示，其中前96位是前缀——`0:0:0:0:0:ffff`。地址的最后32位用于存储IPv4地址。例如，如果一个客户端使用IPv4地址`192.168.2.107`连接，那么你的双栈服务器会将其视为IPv6地址`::ffff.192.168.2.107`。
- en: 'Here is what it looks like to compile, run, and connect to `time_server_dual`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是编译、运行并连接到`time_server_dual`时的样子：
- en: '![](img/44af723e-9cb7-4d02-93a4-12321236041e.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44af723e-9cb7-4d02-93a4-12321236041e.png)'
- en: 'Here is a web browser connected to our `time_server_dual` program using the
    loopback IPv4 address:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过回环 IPv4 地址连接到我们的 `time_server_dual` 程序的网页浏览器：
- en: '![](img/7069a80b-93ed-4cc4-a145-4a1ca6f8f9ff.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7069a80b-93ed-4cc4-a145-4a1ca6f8f9ff.png)'
- en: Notice that the browser is navigating to the IPv4 address `127.0.0.1`, but we
    can see on the console that the server sees the connection as coming from the
    IPv6 address `::ffff:127.0.0.1`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到浏览器正在导航到 IPv4 地址 `127.0.0.1`，但我们可以在控制台上看到服务器将连接视为来自 IPv6 地址 `::ffff:127.0.0.1`。
- en: See `time_server_dual.c` for the complete dual-stack socket server.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `time_server_dual.c` 以获取完整的双栈套接字服务器。
- en: Networking with inetd
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 inetd 进行网络
- en: On Unix-like systems, such as Linux or macOS, a service called *inetd* can be
    used to turn console-only applications into networked ones. You can configure
    *inetd* (with `/etc/inetd.conf`) with your program's location, port number, protocol
    (TCP or UDP), and the user you want it to run as. *inetd* will then listen for
    connections on your desired port. After an incoming connection is accepted by
    *inetd*, it will start your program and redirect all socket input/output through
    `stdin` and `stdout`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上，例如 Linux 或 macOS，可以使用名为 *inetd* 的服务将仅控制台应用程序转换为网络应用程序。您可以使用程序的位置、端口号、协议（TCP
    或 UDP）以及您希望其运行的用户的配置 *inetd*（使用 `/etc/inetd.conf`）。然后 *inetd* 将在您指定的端口上监听连接。一旦
    *inetd* 接受传入连接，它将启动您的程序并将所有套接字输入/输出通过 `stdin` 和 `stdout` 重定向。
- en: Using *inetd*, we could have `time_console.c` behave like `time_server.c` with
    very minimal changes. We would only need to add in an extra `printf()` function with
    the HTTP response header, read from `stdin`, and configure *inetd*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *inetd*，我们可以将 `time_console.c` 的行为修改得像 `time_server.c`，只需进行非常小的改动。我们只需要添加一个额外的
    `printf()` 函数用于 HTTP 响应头，从 `stdin` 读取，并配置 *inetd*。
- en: You may be able to use *inetd* on Windows through Cygwin or the Windows Subsystem
    for Linux.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以通过 Cygwin 或 Windows Subsystem for Linux 在 Windows 上使用 *inetd*。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the basics of using sockets for network programming.
    Although there are many differences between Berkeley sockets (used on Unix-like
    operating systems) and Winsock sockets (used on Windows), we mitigated those differences
    with preprocessor statements. In this way, it was possible to write one program
    that compiles cleanly on Windows, Linux, and macOS.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用套接字进行网络编程的基础。尽管伯克利套接字（用于类 Unix 操作系统）和 Winsock 套接字（用于 Windows）之间存在许多差异，但我们通过预处理语句来缓解这些差异。这样，我们就可以编写一个可以在
    Windows、Linux 和 macOS 上干净编译的程序。
- en: We covered how the UDP protocol is connectionless and what that means. We learned
    that TCP, being a connection-oriented protocol, gives some reliability guarantees,
    such as automatically detecting and resending lost packets. We also saw that UDP
    is often used for simple protocols (for example, DNS) and for real-time streaming
    applications. TCP is used for most other protocols.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 UDP 协议是无连接的，以及这意味着什么。我们了解到，作为面向连接的协议，TCP 提供了一些可靠性保证，例如自动检测和重发丢失的数据包。我们还看到
    UDP 常用于简单的协议（例如 DNS）和实时流媒体应用程序。TCP 用于大多数其他协议。
- en: After that, we worked through a real example by converting a console application
    into a web server. We learned how to write the program using the `getaddrinfo()`
    function, and why that matters for making the program IPv4/IPv6-agnostic. We used
    `bind()`, `listen()`, and `accept()` on the server to wait for an incoming connection
    from the web browser. Data was then read from the client using `recv()`, and a
    reply was sent using `send()`. Finally, we terminated the connection with `close()`
    (`closesocket()` on Windows).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过将控制台应用程序转换为网络服务器来处理了一个真实示例。我们学习了如何使用 `getaddrinfo()` 函数编写程序，以及为什么这对于使程序
    IPv4/IPv6 无关很重要。我们在服务器上使用 `bind()`、`listen()` 和 `accept()` 等待来自网络浏览器的传入连接。然后使用
    `recv()` 从客户端读取数据，并使用 `send()` 发送回复。最后，我们使用 `close()`（在 Windows 上为 `closesocket()`）终止连接。
- en: When we built the web server, `time_server.c`, we covered much ground. It's
    OK if you didn't understand all of it. We will revisit many of these functions
    again throughout [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An
    In-Depth Overview of TCP Connections*, and the rest of this book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建网络服务器 `time_server.c` 时，我们覆盖了很多内容。如果你没有完全理解也没有关系。我们将在第 3 章 [An In-Depth
    Overview of TCP Connections](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml) 和本书的其余部分重新访问许多这些函数。
- en: In the next chapter, [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*, we will consider programming for TCP
    connections in more depth.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*，我们将更深入地探讨TCP连接的编程。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge on this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你对本章知识的掌握：
- en: What is a socket?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是套接字？
- en: What is a connectionless protocol? What is a connection-oriented protocol?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是无连接协议？什么是面向连接的协议？
- en: Is UDP a connectionless or connection-oriented protocol?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UDP是无连接协议还是面向连接的协议？
- en: Is TCP a connectionless or connection-oriented protocol?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP是无连接协议还是面向连接的协议？
- en: What types of applications generally benefit from using the UDP protocol?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的应用通常从使用UDP协议中获益？
- en: What types of applications generally benefit from using the TCP protocol?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的应用通常从使用TCP协议中获益？
- en: Does TCP guarantee that data will be transmitted successfully?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP是否保证数据能够成功传输？
- en: What are some of the main differences between Berkeley sockets and Winsock sockets?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些是伯克利套接字和Winsock套接字之间的一些主要区别？
- en: What does the `bind()` function do?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bind()`函数的作用是什么？'
- en: What does the `accept()` function do?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accept()`函数的作用是什么？'
- en: In a TCP connection, does the client or the server send application data first?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TCP连接中，是客户端还是服务器首先发送应用数据？
- en: Answers are in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml), *Answers
    to Questions*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题答案*中。
