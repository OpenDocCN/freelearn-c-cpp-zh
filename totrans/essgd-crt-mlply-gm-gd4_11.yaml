- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Data Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data
    Requests*, where we will use the tools that we saw in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260),
    *Debugging and Profiling the Network*, and finally implement improvements to the
    network code that we wrote in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online* *Adventure Prototype*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand a bit more about bandwidth and throughput
    by analyzing the current state of our game. We saw, in the *Using the network
    profiler* section of [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, that we have some improvements to make, especially
    regarding the MultiplayerSynchronizers and the `QuestDatabase` data transmission.
    So, here, we will see how we can decrease the number of requests and how we can
    compress and decompress data to reduce the bandwidth and throughput and make our
    game available to more people in a more reliable and optimal way.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand that there are many ways to
    optimize a game and most of the optimizations will depend on the specific demands
    of the game itself. As you progress, you will develop a keen sense and understanding
    of how to assess potential areas of improvement and the kind of data you are looking
    for, as well as some general techniques to address bottlenecks in your network
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding network resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreasing the requests count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data compression with `ENetConnection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, *Part 3*, *Optimizing the Online Experience*, is based
    on the final version of the project made in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure Prototype*, so it’s fundamental to have read, practiced,
    and implemented the concepts presented there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the files necessary to get started with this chapter through the
    following link. These files have the implementations we’ve made in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260),
    *Debugging and Profiling* *the Network*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also necessary that you have read and understood the concepts and tools
    presented in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and
    Profiling the Network*, so that we can move forward under the assumption that
    you already know what they are and how to use them properly. In particular, you
    will need to understand how the Debugger’s Network Profiler and Monitors tools
    work. So, if you aren’t sure how to use these tools, please take some time to
    go back and read [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260)*, Debugging
    and Profiling the Network,* so you can master these and other debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding network resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already mentioned the importance of bandwidth and throughput; in [*Chapter
    1*](B18527_01.xhtml#_idTextAnchor018), *Setting up a Server*, we even had a brief
    introduction to and a visual representation of the topic in *Figure 1**.3* and
    *Figure 1**.4*. Now it’s time to wrap our heads around these concepts, which are
    fundamental to network usage optimization and will be our major resources to measure
    the improvements we made toward our optimization goals.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, the less bandwidth and the lower the throughput of our network
    code, the better. Of course, we need to keep in mind that all optimizations should
    maintain the game experience, so we are in a very delicate position. Different
    from other processing, memory, and graphics optimizations, our work can’t create
    “beautiful accidents,” such as a processing optimization that can lead to a cool
    mechanic. No, our job as network engineers is to replicate the already established
    mechanics and effects to all peers in a network. Let’s understand how we do that.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about bandwidth, it might be surprising to hear that most games
    don’t actually need to have huge infrastructures available. For instance, a video
    conference takes way more bandwidth than a complex first-person shooter or a war
    simulator with tons of physics simulation because it works with processed data
    in the form of rendered images that must be passed around and re-created in each
    of the participants’ instances of the conference. In the case of games, most of
    the necessary resources to create the simulations are already available on the
    user’s machine, so most of our job is to communicate through messages what the
    computer should load to sync the client’s and server’s game instances. It’s well
    established that players need a bandwidth of about 5 Mbps to play most modern
    online multiplayer games, including huge franchises such as Call of Duty, League
    of Legends, and Fortnite.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 1*, *Handshaking and Networking*, of this book, we saw that games work
    mostly with unreliable data, meaning that most of the time, we only need to know
    the latest data regarding an object in the game in order to sync it. This decreases
    the network usage a lot and allows us to focus on the specific types of data necessary
    to replicate the server’s game world in clients’ game worlds.
  prefs: []
  type: TYPE_NORMAL
- en: The major concern in online multiplayer games is the consistency with which
    we can keep on the data transmission stream – ultimately, whether we can maintain
    the throughput of our network consistently. This can be affected by latency and
    other external aspects, so all we can do is design a communication architecture
    that takes into account how latency can affect our throughput. Of course, we will
    also try to keep the bandwidth to a minimum so that if a household has many devices
    connected to the same network, our game has room to keep the data flowing.
  prefs: []
  type: TYPE_NORMAL
- en: So, keep in mind that bandwidth and throughput are our major resources and we
    will be looking at them to find areas that we can improve in our game.
  prefs: []
  type: TYPE_NORMAL
- en: You might still be trying to work out the difference between bandwidth and throughput.
    So, let’s briefly assess them both. We were introduced to these concepts in [*Chapter
    1*](B18527_01.xhtml#_idTextAnchor018), *Setting up a Server*, so if you don’t
    quite remember what they are, take a brief moment to read the *What is the UDP
    protocol?* section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use bandwidth to understand how much of the network our game
    needs to perform correctly, meaning how much data we expect to transmit through
    the network taking into account all the measurements we observed using the network
    profiler. This means that if we have 1,000 MultiplayerSynchronizers syncing 5
    KB of data per second at any given point of our game, we will need a network with
    a 5 Mbps velocity. Note that this might not be consistent transmission of 5 Mbps
    throughout the whole game session, but it’s a recommendation based on our measurements
    that the game might require a network that can manage up to 5 Mbps to play smoothly.
    In summary, bandwidth is the amount of space available in a connection for data
    transmission, not the transmission itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the actual thing we are looking to optimize is the **throughput**, which
    points to how many packets and the size of these packets we are actually transmitting
    through the network. The throughput is our actual data flow. You can think about
    it using an analogy where bandwidth is a pipe and throughput is the water. We
    can’t stream more water than a pipe can support; instead, we can stream water
    up to the available pipe size. In the same way, the amount of throughput we can
    have is based on the available bandwidth capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an illustration of a good and bad throughput-bandwidth relationship
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship](img/Figure_11.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship
  prefs: []
  type: TYPE_NORMAL
- en: Note that with good throughput, the data sent and received is consistent and
    doesn’t exceed the bandwidth, whereas with bad throughput, the data packets are
    inconsistent in size and frequency, and some are even lost in the middle of the
    transmission. When packets don’t reach their destination, we call it **packet
    loss**, and this can cause lots of headaches and complaints from players.
  prefs: []
  type: TYPE_NORMAL
- en: With packet loss, the client doesn’t know how to handle their game instance
    properly. Where should the second player’s spaceship be? Did it stop shooting?
    Is it shooting at an `Asteroid` node or are there no more `Asteroid` nodes to
    shoot? Is the `Asteroid` node they were shooting at there yet? We are going to
    see, in [*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Implementing Lag Compensation*,
    how to handle these situations, but ideally, we should avoid them by paying attention
    to the throughput.
  prefs: []
  type: TYPE_NORMAL
- en: With all that said, network engineers are left in a very delicate position when
    the resources available for optimization don’t leave space for new mechanics to
    emerge. We take the already implemented mechanics and try to fit them all into
    the available resources, usually squeezing them to keep up with any potential
    changes that may require more of these resources, for instance, a new mechanic
    that requires more bandwidth. So, we can’t experiment a lot when optimizing the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s talk about how we can initiate our optimizations
    by decreasing the number of requests that our game makes. We are going to assess
    the problems presented in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, such as in `Weapon2D` massive RPC count and unnecessary
    syncs of the `Asteroid` node’s `MultiplayerSynchronizer` node.
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing the requests count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, we saw that there was a disproportional and unnecessary
    number of requests being made to the `Weapon2D` node’s `fire()` RPC method, and
    we even came up with what could be a solution for this issue. We also saw that
    we can decrease the `Asteroid` node’s sync problem by only updating it once a
    given player requests a synchronization using the `World` node’s `sync_world()`
    RPC method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to implement these optimization methods and improve
    the overall performance of our network. Let’s start with the `Weapon2D` node issue.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the weapon fire count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we may need to make changes in the core code of a feature in order
    to improve its network performance, even when its local performance stays the
    same, or may even drop. When talking about optimization, we are always trying
    to balance things out and figure out how to use the available resources in a way
    that allows more players to enjoy a better experience. Network resources are particularly
    a priority in most online multiplayer games since it’s through a good network
    that players will be able to get the most out of their shared experiences. So,
    let’s make some changes to how `Player2D` node fires `Weapon2D` node. Let’s open
    the `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.tscn` scene
    first and carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `timeout` signal of `Timer` node to `Weapon2D` node and create
    a callback method named `_on_timer_timeout()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s
    _on_timer_timeout() callback](img/Figure_11.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout()
    callback
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.gd` script
    and, in the `_on_timer_timeout()` callback, call the `fire()` method so `Weapon2D`
    node fires on every `Timer` node’s tic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, let’s create an RPC method that can be called by any peer and should
    also be called locally. We will use this method to change `Weapon2D`’s firing
    state, so it should receive a Boolean variable as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this method, we will check the `firing` state, and if it’s `true`, we
    will call the `fire()` method as well; otherwise, we will tell `Timer` to stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we can remove the RPC annotation on the `fire()` method and the
    `if timer.is_stopped()` statement, since now `Timer` itself tells when `Weapon2D`
    fires. The `fire()` method should look like this after that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, `Weapon2D` will fire based on the timeout signal from `Timer`. With
    the new RPC method, we can change the firing state, starting or stopping the creation
    of new *bullets*. The `Weapon2D` script should look like this at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to know when `Weapon2D`’s firing state changes, and to do that,
    we will need to make some changes to `Player2D`. So, open `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    and implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the whole `_process()` callback code. Then, override the `_unhandled_input()`
    callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `_unhandled_input()` callback, we are going to check whether the
    `"shoot"` action was pressed or released. If pressed, we set the `weapon` firing
    state to `true`, and if released, it’s set to `false` (remember, we should do
    that using the `rpc()` method so the player shoots on all network peer instances):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a line to the `setup_multiplayer()` method to also toggle
    the `_unhandled_input()` process based on whether the instance of the spaceship
    is the current player or a remote player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, `Player2D` will toggle `Weapon2D`’s firing state based on whether
    the `"shoot"` action was pressed or released, instead of calling it every frame
    while `"shoot"` was pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make an assessment of this improvement. Turn on the network profiler
    and let’s see how this goes. Remember that depending on the duration of the profiling
    section, we may get different results, so this isn’t as accurate as a unit test;
    but still, it will give us a good sense of any potential improvements we’ve made.
    In the following figure, we have `Player2D` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting
    thePlayer2D node instance’s incoming RPCs](img/Figure_11.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D
    node instance’s incoming RPCs
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, I destroyed all 30 asteroids in a play session
    of around 20.0 seconds, with a total of six RPC calls from `Player2D` instance.
    If you compare this to *Figure 10**.13*, where we had 693 calls for a session
    with about the same duration, this is more than 115x fewer calls. I think we did
    a good job here.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, we learned how to optimize data requests in our game to
    improve network performance. We focused on how to decrease the number of requests
    being made in the game by optimizing the firing of `Weapon2D` node. We also saw
    how to create an RPC method that can change `Weapon2D`’s firing state, and how
    to toggle the firing state based on the `"shoot"` action being pressed or released
    instead of triggering the firing on every frame in the `_process()` callback.
    Finally, we saw how to use the network profiler to assess the impact of these
    optimizations on the game’s performance. In the next section, we will work on
    decreasing the requests of Asteroid’s `MultiplayerSynchronizer`.
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing Asteroid’s syncing count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another issue we saw in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, was regarding the way `Asteroid` node’s `MultiplayerSynchronizers`
    sync their position to players. Since they don’t move throughout the play session,
    there’s no need to keep updating their position and other properties on a regular
    basis. Instead, we only need to sync them once when the player asks `World` node
    to sync.
  prefs: []
  type: TYPE_NORMAL
- en: So, open the `res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.tscn`
    scene and make the necessary changes to improve this aspect of our network engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we just need to set the `MultiplayerSynchronizer` node’s **Visibility
    Update Mode** property to **None**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update
    Mode property set to None](img/Figure_11.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update
    Mode property set to None
  prefs: []
  type: TYPE_NORMAL
- en: With that, we just have to do the syncing manually now. The `MultiplayerSynchronizer`
    node has a method called `update_visibility()`, which receives an argument where
    we can pass the ID of the peer we want to sync with; if we pass `0`, it updates
    all peers instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method takes into account the filters we set in the *Syncing
    the asteroids* section of [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating
    an Online Adventure Prototype*, using the `set_visibility_for()` method, meaning
    only the peers added using this method will be synced. So, in our case, if we
    don’t add the peer to the filtering using the `set_visibility_for()` method, this
    peer won’t be synced, even if we use the `update_visibility()` method, passing
    the correct peer ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to manually sync the `Asteroid` node’s properties will be in
    the `World` class, so open the `res://09.prototyping-space-adventure/Levels/World.gd`
    script . Then, inside the `sync_world()` method, let’s add another group call
    to the `"Sync"` group, but this time to the `update_visibility` method, and pass
    `player_id` as an argument. The whole `sync_world()` method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With that, all `Asteroid` nodes should only sync once to every player, decreasing
    the total network resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s profile this change as well to see its impact on the overall network
    consumption. The following figure showcases the sync count of some asteroids’
    MultiplayerSynchronizers:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the\
    \ Asteroid \uFEFFnodes’ MultiplayerSynchronizer \uFEFFnodes’ sync counts](img/Figure_11.05_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid
    nodes’ MultiplayerSynchronizer nodes’ sync counts
  prefs: []
  type: TYPE_NORMAL
- en: Compare this to *Figure 10**.13*, where we had hundreds and hundreds of updates,
    and for every frame, the update count would increase. After what we’ve done, they
    only increase once a player enters a session and only to that specific player.
    Pretty good job, right?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to optimize data requests by decreasing the `asteroid`
    nodes’ `MultiplayerSynchronizer` nodes’ syncs. To do that, we disabled the automatic
    synchronization by setting `MultiplayerSynchronizer` node’s `MultiplayerSynchronizer.update_visibility()`
    method once the player joins the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will see how we can compress data to optimize the
    packet’s size. Until now, we’ve only dealt with how many packets we send or receive,
    but the size of these packets is very important to handle as well. Let’s understand
    what we have available to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing data with the ENetConnection class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Godot Engine’s high-level network API includes the `ENetConnection` class.
    This class is available after a connection between peers, such as the server and
    client, is established. Using `ENetConnection`, we can tweak the peer’s connections,
    allowing us to tell, for instance, the compression method. We can access the `ENetConnection`
    instance after the peers have successfully connected. For that, we can use the
    `ENetMultiplayerPeer.host` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five available compression methods to use in the `ENetConnection`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CompressionMode` enumerator’s `COMPRESS_NONE` option. This is what the documentation
    says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*This uses the most bandwidth but has the upside of requiring the fewest CPU
    resources. This option may also be used to make network debugging using tools
    like* *Wireshark easier.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ENet’s built-in `CompressionMode` enumerator’s `COMPRESS_RANGE_CODER` option.
    This is what the documentation says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[This is] ENet’s built-in range encoding. Works well on small packets, but
    is not the most efficient algorithm on packets larger than* *4 KB.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CompressionMode` enumerator’s `COMPRESS_FASTLZ` option. This is what the documentation
    says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*This option uses less CPU resources compared to COMPRESS_ZLIB, at the expense
    of using* *more bandwidth.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CompressionMode` enumerator’s `COMPRESS_ZLIB` option. This is what the documentation
    says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*This option uses less bandwidth compared to COMPRESS_FASTLZ , at the expense
    of using more* *CPU resources.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CompressionMode` enumerator’s `COMPRESS_ZSTD` option. This is what the documentation
    says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Note that this algorithm is not very efficient on packets smaller than 4 KB.
    Therefore, it’s recommended to use other compression algorithms in* *most cases.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can find more about `ENetConnection` and `CompressionMode` in the Godot
    docs through the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode](https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to work on the size of the data we are transmitting through the network.
    In the following steps, we will implement compression to decrease our game’s packet
    size and optimize the transmission of data through the network. Note that, as
    always, there’s a trade-off between the bandwidth and CPU resources. Our game
    currently doesn’t have any issues regarding CPU usage. So, at this point, we can
    focus on optimizing the network resources. For that, we can use the `COMPRESS_ZLIB`
    compression mode. To do that, let’s open the `res://09.prototyping-space-adventure/Authentication.gd`
    script and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right before we set `multiplayer_peer` to the peer in the `_ready()` callback,
    we are going to change the `ENetConnection` compression mode. For that, we access
    the `host` property and use the `compress()` method, passing `EnetConnection.COMPRESS_ZLIB`
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to do this here because the compression mode needs to be set before
    the connection is established, which happens after we set the `multiplayer.multiplayer_peer`
    property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to do the same thing in the `res://09.prototyping-spaceadventure/LoggingScreen.gd`
    script so that this connection also matches the server’s connection compression.
    Again, before setting `multiplayer.multiplayer_peer`, we set ENetConnection’s
    compression to `COMPRESS_ZLIB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we are able to change the compression mode used in our game’s network
    connection as soon as the players join the game’s world. For now, this won’t make
    a huge impact. As we saw in the previous quotes from the documentation, most of
    the compression algorithms aim at having data packets be either below 4 KB or
    above 4 KB. Our game’s packets currently haven’t even reached the Kilobytes yet,
    so…this may not have a big, if any, impact at this point, to be honest.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to measure how much bandwidth we are using and get at least a glance
    at any possible improvements, we can use the Debugger’s `EnetConnection` instances’
    sent and received data. For that, we can use the `ENetConnection.pop_statistic()`
    method to create two relevant monitors using the `Performance` singleton to add
    our custom monitors. Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `World` class script, create a method called `get_received_data()`.
    This method needs to return an integer or floating point so we can use it to create
    a monitor. In this case, it will return the received data statistic from the current
    `ENetConnection`. For that, we can use the `pop_statistic()` method, passing `ENetConnection.HOST_TOTAL_RECEIVED_DATA`
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we are going to create another method called `get_sent_data()` and do
    the same thing, but passing `ENetConnection.HOST_TOTAL_SENT_DATA` as an argument
    this time around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `_ready()` callback, where we check to see whether this instance
    is the server or not, right above where we create the `Asteroid` instances, we
    are going to add the respective `callable` to the `Performance` singleton using
    the `Performance.add_custom_monitor()` method, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are able to monitor the differences between each compression mode and
    see the one that better fits our game. In the following figure, we compare the
    usage of the `COMPRESS_ZLIB` and `COMPRESS_NONE` compression modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – A comparison between the monitors of the data sent and received
    using the COMPRESS_ZLIB and COMPRESS_NONE compression modes](img/Figure_11.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – A comparison between the monitors of the data sent and received
    using the COMPRESS_ZLIB and COMPRESS_NONE compression modes
  prefs: []
  type: TYPE_NORMAL
- en: Note that with the `COMPRESS_ZLIB` compression, we had a peak of 12,509 bytes
    on the received data, while we had a peak of 48,802 bytes in the data sent. Meanwhile,
    using `COMPRESS_NONE`, we peaked at 14,470 bytes in the received data and 80,234
    bytes on the sent data – even with very small data packets, we have massive gains,
    especially on the server’s data sent metrics, so we also did a good job there!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to optimize data requests in our game to improve
    network performance. We focused on decreasing the number of requests being made
    in the game by optimizing the firing of the weapon. We saw how to create an RPC
    method that can change the weapon’s firing state and how to toggle the firing
    state based on the “shoot” action being pressed or released instead of triggering
    the firing on every frame in the `_process()` callback. Finally, we saw how to
    use the network profiler to assess the impact of these optimizations on the game’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we tackled the issue of `Asteroid` node’s MultiplayerSynchronizers’
    syncs. We disabled the automatic synchronization by setting the `MultiplayerSynchronizer`
    to `MultiplayerSynchronizer.update_visibility()` method once the player joins
    the game. This decreased the `Asteroid`node’s sync count and decreased the total
    network resource usage. We also saw how to measure the effectiveness of these
    optimizations using the debugger’s network profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the Godot Engine’s high-level network API’s `ENetConnection`
    class, which offers compression methods to optimize the packet size. We saw how
    to use the `ENetConnection.pop_statistic()` method to create custom monitors using
    the `Performance` singleton to track ENetConnection’s sent and received data.
    We compared the usage of the `COMPRESS_ZLIB` and `COMPRESS_NONE` compression modes
    and found that even with very small data packets, we have massive gains, especially
    on the server’s data sent metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to get even deeper into optimization. We are
    going to use interpolation and prediction to decrease the `MultiplayerSynchronizer`
    syncing count of the player’s spaceship while trying to keep the movement consistent
    throughout the game network instances. See you there!
  prefs: []
  type: TYPE_NORMAL
