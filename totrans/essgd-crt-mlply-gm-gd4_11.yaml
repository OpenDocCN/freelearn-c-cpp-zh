- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Optimizing Data Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据请求
- en: Welcome to [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data
    Requests*, where we will use the tools that we saw in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260),
    *Debugging and Profiling the Network*, and finally implement improvements to the
    network code that we wrote in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online* *Adventure Prototype*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第11章*](B18527_11.xhtml#_idTextAnchor276)，*优化数据请求*，我们将使用在[*第10章*](B18527_10.xhtml#_idTextAnchor260)中看到的工具，*调试和性能分析网络*，并最终改进我们在[*第9章*](B18527_09.xhtml#_idTextAnchor188)中编写的网络代码，*创建在线*
    *冒险原型*。
- en: In this chapter, we will understand a bit more about bandwidth and throughput
    by analyzing the current state of our game. We saw, in the *Using the network
    profiler* section of [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, that we have some improvements to make, especially
    regarding the MultiplayerSynchronizers and the `QuestDatabase` data transmission.
    So, here, we will see how we can decrease the number of requests and how we can
    compress and decompress data to reduce the bandwidth and throughput and make our
    game available to more people in a more reliable and optimal way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过分析我们游戏当前的状态，对带宽和吞吐量有更深入的了解。在[*第10章*](B18527_10.xhtml#_idTextAnchor260)中，*调试和性能分析网络*的*使用网络分析器*部分，我们看到了一些需要改进的地方，特别是在MultiplayerSynchronizers和`QuestDatabase`数据传输方面。因此，在这里，我们将看到如何减少请求数量，以及如何压缩和解压缩数据以减少带宽和吞吐量，使我们的游戏以更可靠和更优化的方式对更多人开放。
- en: By the end of this chapter, you will understand that there are many ways to
    optimize a game and most of the optimizations will depend on the specific demands
    of the game itself. As you progress, you will develop a keen sense and understanding
    of how to assess potential areas of improvement and the kind of data you are looking
    for, as well as some general techniques to address bottlenecks in your network
    code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解到优化游戏有许多方法，而大多数优化将取决于游戏本身的具体需求。随着你的进步，你将培养出敏锐的判断力和对如何评估潜在改进区域以及你正在寻找的数据类型的理解，以及一些解决网络代码瓶颈的一般技术。
- en: 'So, this chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将涵盖以下主题：
- en: Understanding network resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络资源
- en: Decreasing the requests count
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少请求数量
- en: Data compression with `ENetConnection`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ENetConnection`进行数据压缩
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As mentioned in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, *Part 3*, *Optimizing the Online Experience*, is based
    on the final version of the project made in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure Prototype*, so it’s fundamental to have read, practiced,
    and implemented the concepts presented there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第10章*](B18527_10.xhtml#_idTextAnchor260)中所述，*调试和性能分析网络*，*第3部分*，*优化在线体验*，是基于[*第9章*](B18527_09.xhtml#_idTextAnchor188)中制作的项目最终版本，*创建在线冒险原型*，因此，阅读、实践和实施那里提出的概念是基本要求。
- en: 'You can get the files necessary to get started with this chapter through the
    following link. These files have the implementations we’ve made in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260),
    *Debugging and Profiling* *the Network*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接获取开始本章所需的文件。这些文件包含了我们在[*第10章*](B18527_10.xhtml#_idTextAnchor260)中实现的*调试和性能分析网络*：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests)'
- en: It’s also necessary that you have read and understood the concepts and tools
    presented in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and
    Profiling the Network*, so that we can move forward under the assumption that
    you already know what they are and how to use them properly. In particular, you
    will need to understand how the Debugger’s Network Profiler and Monitors tools
    work. So, if you aren’t sure how to use these tools, please take some time to
    go back and read [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260)*, Debugging
    and Profiling the Network,* so you can master these and other debugging tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你也需要阅读并理解[*第十章*](B18527_10.xhtml#_idTextAnchor260) *调试和性能分析网络*中介绍的概念和工具，这样我们才能在假设你已经知道它们是什么以及如何正确使用它们的前提下继续前进。特别是，你需要理解调试器的网络性能分析器和监视工具是如何工作的。所以，如果你不确定如何使用这些工具，请花些时间回顾[*第十章*](B18527_10.xhtml#_idTextAnchor260)
    *调试和性能分析网络*，以便掌握这些和其他调试工具。
- en: Understanding network resources
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络资源
- en: We’ve already mentioned the importance of bandwidth and throughput; in [*Chapter
    1*](B18527_01.xhtml#_idTextAnchor018), *Setting up a Server*, we even had a brief
    introduction to and a visual representation of the topic in *Figure 1**.3* and
    *Figure 1**.4*. Now it’s time to wrap our heads around these concepts, which are
    fundamental to network usage optimization and will be our major resources to measure
    the improvements we made toward our optimization goals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了带宽和吞吐量的重要性；在[*第一章*](B18527_01.xhtml#_idTextAnchor018) *设置服务器*中，我们甚至对*图1.3*和*图1.4*这一主题进行了简短的介绍和视觉表示。现在是我们深入理解这些概念的时候了，这些概念是网络使用优化的基础，也将是我们衡量我们向优化目标所取得的进步的主要资源。
- en: As a general rule, the less bandwidth and the lower the throughput of our network
    code, the better. Of course, we need to keep in mind that all optimizations should
    maintain the game experience, so we are in a very delicate position. Different
    from other processing, memory, and graphics optimizations, our work can’t create
    “beautiful accidents,” such as a processing optimization that can lead to a cool
    mechanic. No, our job as network engineers is to replicate the already established
    mechanics and effects to all peers in a network. Let’s understand how we do that.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们的网络代码带宽越低、吞吐量越低，效果越好。当然，我们需要记住，所有的优化都应该保持游戏体验，所以我们处于一个非常微妙的地位。与其他处理、内存和图形优化不同，我们的工作不能创造“美丽的意外”，比如一个可能导致酷炫机制的优化。不，我们作为网络工程师的职责是复制已经建立好的机制和效果到网络中的所有节点。让我们了解我们是如何做到这一点的。
- en: When talking about bandwidth, it might be surprising to hear that most games
    don’t actually need to have huge infrastructures available. For instance, a video
    conference takes way more bandwidth than a complex first-person shooter or a war
    simulator with tons of physics simulation because it works with processed data
    in the form of rendered images that must be passed around and re-created in each
    of the participants’ instances of the conference. In the case of games, most of
    the necessary resources to create the simulations are already available on the
    user’s machine, so most of our job is to communicate through messages what the
    computer should load to sync the client’s and server’s game instances. It’s well
    established that players need a bandwidth of about 5 Mbps to play most modern
    online multiplayer games, including huge franchises such as Call of Duty, League
    of Legends, and Fortnite.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到带宽时，可能会让人惊讶的是，大多数游戏实际上并不需要拥有巨大的基础设施。例如，一个视频会议需要的带宽比一个复杂的单人第一人称射击游戏或拥有大量物理模拟的战争模拟器要多得多，因为它需要处理以渲染图像形式存在的数据，这些数据必须在每个参与者的会议实例中传递和重新创建。在游戏的情况下，创建模拟所需的大部分必要资源已经存在于用户的机器上，因此我们的大部分工作是通过消息来沟通计算机应该加载什么，以同步客户端和服务器上的游戏实例。众所周知，玩家需要大约5
    Mbps的带宽才能玩大多数现代在线多人游戏，包括像使命召唤、英雄联盟和堡垒之夜这样的大型游戏系列。
- en: In *Part 1*, *Handshaking and Networking*, of this book, we saw that games work
    mostly with unreliable data, meaning that most of the time, we only need to know
    the latest data regarding an object in the game in order to sync it. This decreases
    the network usage a lot and allows us to focus on the specific types of data necessary
    to replicate the server’s game world in clients’ game worlds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*第一部分* *握手和网络*中，我们了解到游戏主要使用不可靠的数据，这意味着大多数时候，我们只需要知道游戏中某个对象的最新数据以便同步它。这大大减少了网络使用量，并允许我们专注于复制服务器游戏世界到客户端游戏世界所需的具体数据类型。
- en: The major concern in online multiplayer games is the consistency with which
    we can keep on the data transmission stream – ultimately, whether we can maintain
    the throughput of our network consistently. This can be affected by latency and
    other external aspects, so all we can do is design a communication architecture
    that takes into account how latency can affect our throughput. Of course, we will
    also try to keep the bandwidth to a minimum so that if a household has many devices
    connected to the same network, our game has room to keep the data flowing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线多人游戏中，我们主要关心的是我们保持数据传输流的一致性 – 最终，我们能否持续保持网络的吞吐量。这可能会受到延迟和其他外部因素的影响，所以我们能做的就是设计一个考虑延迟如何影响我们吞吐量的通信架构。当然，我们也会尽量将带宽保持在最低，以便如果同一网络连接了多个设备，我们的游戏仍有空间保持数据流动。
- en: So, keep in mind that bandwidth and throughput are our major resources and we
    will be looking at them to find areas that we can improve in our game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请记住带宽和吞吐量是我们主要的资源，我们将查看它们以找到我们可以改进游戏的地方。
- en: You might still be trying to work out the difference between bandwidth and throughput.
    So, let’s briefly assess them both. We were introduced to these concepts in [*Chapter
    1*](B18527_01.xhtml#_idTextAnchor018), *Setting up a Server*, so if you don’t
    quite remember what they are, take a brief moment to read the *What is the UDP
    protocol?* section of the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还在试图弄清楚带宽和吞吐量之间的区别。那么，让我们简要地评估一下这两个概念。我们在[*第一章*](B18527_01.xhtml#_idTextAnchor018)，“设置服务器”，中介绍了这些概念，所以如果你不太记得它们是什么，请花一点时间阅读该章节的“什么是
    UDP 协议？”部分。
- en: We are going to use bandwidth to understand how much of the network our game
    needs to perform correctly, meaning how much data we expect to transmit through
    the network taking into account all the measurements we observed using the network
    profiler. This means that if we have 1,000 MultiplayerSynchronizers syncing 5
    KB of data per second at any given point of our game, we will need a network with
    a 5 Mbps velocity. Note that this might not be consistent transmission of 5 Mbps
    throughout the whole game session, but it’s a recommendation based on our measurements
    that the game might require a network that can manage up to 5 Mbps to play smoothly.
    In summary, bandwidth is the amount of space available in a connection for data
    transmission, not the transmission itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带宽来了解我们的游戏需要多少网络才能正确运行，这意味着我们预计将通过网络传输多少数据，考虑到我们使用网络分析器观察到的所有测量值。这意味着如果我们有
    1,000 个 MultiplayerSynchronizers 在游戏的任何一点同步 5 KB 的数据每秒，我们需要一个 5 Mbps 速度的网络。请注意，这并不意味着整个游戏会持续以
    5 Mbps 的速度传输，但这是基于我们的测量结果，建议游戏可能需要一个能够管理高达 5 Mbps 的网络才能流畅运行。总之，带宽是连接中可用于数据传输的空间量，而不是传输本身。
- en: Now, the actual thing we are looking to optimize is the **throughput**, which
    points to how many packets and the size of these packets we are actually transmitting
    through the network. The throughput is our actual data flow. You can think about
    it using an analogy where bandwidth is a pipe and throughput is the water. We
    can’t stream more water than a pipe can support; instead, we can stream water
    up to the available pipe size. In the same way, the amount of throughput we can
    have is based on the available bandwidth capacity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们真正想要优化的是**吞吐量**，这指的是我们实际上通过网络传输的包的数量和这些包的大小。吞吐量是我们的实际数据流。你可以用类比来考虑它，其中带宽是管道，吞吐量是水。我们不能传输比管道能支持的更多的水；相反，我们可以传输直到可用管道大小的水。同样，我们可以有的吞吐量量是基于可用的带宽容量。
- en: 'You can see an illustration of a good and bad throughput-bandwidth relationship
    in the following figure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图中看到良好与不良吞吐量-带宽关系的示意图：
- en: '![Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship](img/Figure_11.01_B18527.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 良好与不良吞吐量-带宽关系的示意图](img/Figure_11.01_B18527.jpg)'
- en: Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 良好与不良吞吐量-带宽关系的示意图
- en: Note that with good throughput, the data sent and received is consistent and
    doesn’t exceed the bandwidth, whereas with bad throughput, the data packets are
    inconsistent in size and frequency, and some are even lost in the middle of the
    transmission. When packets don’t reach their destination, we call it **packet
    loss**, and this can cause lots of headaches and complaints from players.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，良好的吞吐量下，发送和接收的数据是一致的，不会超过带宽，而糟糕的吞吐量下，数据包的大小和频率不一致，有些甚至在传输过程中丢失。当数据包没有到达目的地时，我们称之为**丢包**，这可能会给玩家带来很多麻烦和投诉。
- en: With packet loss, the client doesn’t know how to handle their game instance
    properly. Where should the second player’s spaceship be? Did it stop shooting?
    Is it shooting at an `Asteroid` node or are there no more `Asteroid` nodes to
    shoot? Is the `Asteroid` node they were shooting at there yet? We are going to
    see, in [*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Implementing Lag Compensation*,
    how to handle these situations, but ideally, we should avoid them by paying attention
    to the throughput.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在丢包的情况下，客户端不知道如何正确处理他们的游戏实例。第二位玩家的飞船应该在哪个位置？它停止射击了吗？它是在射击`Asteroid`节点，还是没有更多的`Asteroid`节点可以射击？他们射击的`Asteroid`节点还在那里吗？我们将在[*第12章*](B18527_12.xhtml#_idTextAnchor285)，*实现延迟补偿*中看到如何处理这些情况，但理想情况下，我们应该通过关注吞吐量来避免它们。
- en: With all that said, network engineers are left in a very delicate position when
    the resources available for optimization don’t leave space for new mechanics to
    emerge. We take the already implemented mechanics and try to fit them all into
    the available resources, usually squeezing them to keep up with any potential
    changes that may require more of these resources, for instance, a new mechanic
    that requires more bandwidth. So, we can’t experiment a lot when optimizing the
    network.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，当可用的优化资源不足以让新的机制出现时，网络工程师处于一个非常微妙的地位。我们采取已经实施的机制，并尝试将它们全部纳入可用的资源中，通常是通过挤压它们来跟上可能需要更多这些资源的任何潜在变化，例如，需要更多带宽的新机制。因此，我们在优化网络时不能进行太多的实验。
- en: In the next section, let’s talk about how we can initiate our optimizations
    by decreasing the number of requests that our game makes. We are going to assess
    the problems presented in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, such as in `Weapon2D` massive RPC count and unnecessary
    syncs of the `Asteroid` node’s `MultiplayerSynchronizer` node.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们讨论如何通过减少游戏发出的请求数量来启动我们的优化。我们将评估在[*第10章*](B18527_10.xhtml#_idTextAnchor260)，*调试和性能分析网络*中提出的问题，例如在`Weapon2D`中大量的RPC计数和`Asteroid`节点的`MultiplayerSynchronizer`节点的非必要同步。
- en: Decreasing the requests count
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少请求数量
- en: Previously, in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, we saw that there was a disproportional and unnecessary
    number of requests being made to the `Weapon2D` node’s `fire()` RPC method, and
    we even came up with what could be a solution for this issue. We also saw that
    we can decrease the `Asteroid` node’s sync problem by only updating it once a
    given player requests a synchronization using the `World` node’s `sync_world()`
    RPC method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18527_10.xhtml#_idTextAnchor260)，*调试和性能分析网络*中，我们看到了对`Weapon2D`节点的`fire()`
    RPC方法进行了不成比例和不必要的请求，我们甚至提出了可能解决这个问题的方案。我们还看到，我们可以通过仅使用`World`节点的`sync_world()`
    RPC方法在给定玩家请求同步时更新一次`Asteroid`节点来减少`Asteroid`节点的同步问题。
- en: In this section, we are going to implement these optimization methods and improve
    the overall performance of our network. Let’s start with the `Weapon2D` node issue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现这些优化方法，并提高我们网络的总体性能。让我们从`Weapon2D`节点问题开始。
- en: Reducing the weapon fire count
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少武器射击次数
- en: 'Sometimes we may need to make changes in the core code of a feature in order
    to improve its network performance, even when its local performance stays the
    same, or may even drop. When talking about optimization, we are always trying
    to balance things out and figure out how to use the available resources in a way
    that allows more players to enjoy a better experience. Network resources are particularly
    a priority in most online multiplayer games since it’s through a good network
    that players will be able to get the most out of their shared experiences. So,
    let’s make some changes to how `Player2D` node fires `Weapon2D` node. Let’s open
    the `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.tscn` scene
    first and carry out the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要修改一个功能的核心代码以改进其网络性能，即使其本地性能保持不变，甚至可能下降。当谈到优化时，我们总是试图平衡事物并找出如何以允许更多玩家享受更好体验的方式使用可用资源。网络资源在大多数在线多人游戏中尤其是一个优先事项，因为只有通过良好的网络，玩家才能充分利用他们的共享体验。所以，让我们改变
    `Player2D` 节点射击 `Weapon2D` 节点的方式。首先打开 `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.tscn`
    场景并执行以下步骤：
- en: 'Connect the `timeout` signal of `Timer` node to `Weapon2D` node and create
    a callback method named `_on_timer_timeout()`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Timer` 节点的 `timeout` 信号连接到 `Weapon2D` 节点，并创建一个名为 `_on_timer_timeout()` 的回调方法：
- en: '![Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s
    _on_timer_timeout() callback](img/Figure_11.02_B18527.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Timer 节点的超时信号连接到 Weapon2D 节点的 _on_timer_timeout() 回调](img/Figure_11.02_B18527.jpg)'
- en: Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout()
    callback
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Timer 节点的超时信号连接到 Weapon2D 节点的 _on_timer_timeout() 回调
- en: Open the `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.gd` script
    and, in the `_on_timer_timeout()` callback, call the `fire()` method so `Weapon2D`
    node fires on every `Timer` node’s tic.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.gd` 脚本，并在 `_on_timer_timeout()`
    回调中调用 `fire()` 方法，以便 `Weapon2D` 节点在每个 `Timer` 节点的 tic 上进行射击。
- en: 'Then, let’s create an RPC method that can be called by any peer and should
    also be called locally. We will use this method to change `Weapon2D`’s firing
    state, so it should receive a Boolean variable as an argument:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个可以被任何对等节点调用并且也应该在本地调用的 RPC 方法。我们将使用此方法来改变 `Weapon2D` 的射击状态，因此它应该接收一个布尔变量作为参数：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside this method, we will check the `firing` state, and if it’s `true`, we
    will call the `fire()` method as well; otherwise, we will tell `Timer` to stop:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将检查 `firing` 状态，如果是 `true`，我们将调用 `fire()` 方法；否则，我们将告诉 `Timer` 停止：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With that, we can remove the RPC annotation on the `fire()` method and the
    `if timer.is_stopped()` statement, since now `Timer` itself tells when `Weapon2D`
    fires. The `fire()` method should look like this after that:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们可以移除 `fire()` 方法和 `if timer.is_stopped()` 语句上的 RPC 注释，因为现在 `Timer` 本身就会告诉
    `Weapon2D` 何时射击。修改后的 `fire()` 方法应该如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With that, `Weapon2D` will fire based on the timeout signal from `Timer`. With
    the new RPC method, we can change the firing state, starting or stopping the creation
    of new *bullets*. The `Weapon2D` script should look like this at this point:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`Weapon2D` 将根据来自 `Timer` 的超时信号进行射击。使用新的 RPC 方法，我们可以改变射击状态，开始或停止创建新的 *子弹*。在这个阶段，`Weapon2D`
    脚本应该看起来像这样：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we need to know when `Weapon2D`’s firing state changes, and to do that,
    we will need to make some changes to `Player2D`. So, open `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    and implement the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要知道 `Weapon2D` 的射击状态何时改变，为此，我们需要对 `Player2D` 进行一些修改。所以，打开 `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    并执行以下步骤：
- en: 'Remove the whole `_process()` callback code. Then, override the `_unhandled_input()`
    callback:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除整个 `_process()` 回调代码。然后，重写 `_unhandled_input()` 回调：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the `_unhandled_input()` callback, we are going to check whether the
    `"shoot"` action was pressed or released. If pressed, we set the `weapon` firing
    state to `true`, and if released, it’s set to `false` (remember, we should do
    that using the `rpc()` method so the player shoots on all network peer instances):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_unhandled_input()` 回调内部，我们将检查是否按下了 `"shoot"` 动作或释放了它。如果按下，我们将 `weapon` 射击状态设置为
    `true`，如果释放，则设置为 `false`（记住，我们应该使用 `rpc()` 方法来做这件事，以便玩家在所有网络对等实例上射击）：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to add a line to the `setup_multiplayer()` method to also toggle
    the `_unhandled_input()` process based on whether the instance of the spaceship
    is the current player or a remote player:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`setup_multiplayer()`方法中添加一行代码，以便根据飞船实例是当前玩家还是远程玩家来切换`_unhandled_input()`过程：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, `Player2D` will toggle `Weapon2D`’s firing state based on whether
    the `"shoot"` action was pressed or released, instead of calling it every frame
    while `"shoot"` was pressed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Player2D`将根据“射击”动作是否被按下或释放来切换`Weapon2D`的发射状态，而不是在“射击”被按下时每帧调用它。
- en: 'Let’s make an assessment of this improvement. Turn on the network profiler
    and let’s see how this goes. Remember that depending on the duration of the profiling
    section, we may get different results, so this isn’t as accurate as a unit test;
    but still, it will give us a good sense of any potential improvements we’ve made.
    In the following figure, we have `Player2D` instance:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对这次改进进行评估。打开网络分析器，看看效果如何。记住，根据分析段的持续时间，我们可能会得到不同的结果，所以这并不像单元测试那样准确；但仍然，它将给我们一个关于我们已做的任何潜在改进的良好感觉。在下面的图中，我们有`Player2D`实例：
- en: '![Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting
    thePlayer2D node instance’s incoming RPCs](img/Figure_11.03_B18527.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 第1次会话调试器的网络分析器标签页突出显示`Player2D`节点实例的传入RPC](img/Figure_11.03_B18527.jpg)'
- en: Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D
    node instance’s incoming RPCs
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 第1次会话调试器的网络分析器标签页突出显示`Player2D`节点实例的传入RPC
- en: As you can see in the figure, I destroyed all 30 asteroids in a play session
    of around 20.0 seconds, with a total of six RPC calls from `Player2D` instance.
    If you compare this to *Figure 10**.13*, where we had 693 calls for a session
    with about the same duration, this is more than 115x fewer calls. I think we did
    a good job here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，我在大约20.0秒的游玩过程中摧毁了所有30颗小行星，总共进行了六个来自`Player2D`实例的RPC调用。如果你将这个结果与*图10.13*进行比较，在那里我们对于大约相同时长的会话进行了693次调用，这比之前的调用减少了超过115倍。我认为我们在这里做得很好。
- en: So, in this section, we learned how to optimize data requests in our game to
    improve network performance. We focused on how to decrease the number of requests
    being made in the game by optimizing the firing of `Weapon2D` node. We also saw
    how to create an RPC method that can change `Weapon2D`’s firing state, and how
    to toggle the firing state based on the `"shoot"` action being pressed or released
    instead of triggering the firing on every frame in the `_process()` callback.
    Finally, we saw how to use the network profiler to assess the impact of these
    optimizations on the game’s performance. In the next section, we will work on
    decreasing the requests of Asteroid’s `MultiplayerSynchronizer`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们学习了如何优化游戏中的数据请求以提高网络性能。我们关注了如何通过优化`Weapon2D`节点的触发来减少游戏中发出的请求的数量。我们还看到了如何创建一个可以改变`Weapon2D`发射状态的RPC方法，以及如何根据“射击”动作的按下或释放来切换发射状态，而不是在每帧的`_process()`回调中触发发射。最后，我们看到了如何使用网络分析器来评估这些优化对游戏性能的影响。在下一节中，我们将致力于减少小行星的`MultiplayerSynchronizer`请求。
- en: Decreasing Asteroid’s syncing count
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少小行星的同步计数
- en: Another issue we saw in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, was regarding the way `Asteroid` node’s `MultiplayerSynchronizers`
    sync their position to players. Since they don’t move throughout the play session,
    there’s no need to keep updating their position and other properties on a regular
    basis. Instead, we only need to sync them once when the player asks `World` node
    to sync.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18527_10.xhtml#_idTextAnchor260)中，我们看到了另一个问题，即关于`Asteroid`节点的`MultiplayerSynchronizers`如何将位置同步给玩家的问题。由于它们在整个游玩过程中不移动，因此没有必要定期更新它们的位置和其他属性。相反，我们只需要在玩家请求`World`节点同步时同步一次。
- en: So, open the `res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.tscn`
    scene and make the necessary changes to improve this aspect of our network engineering.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.tscn`场景，并对这一方面进行必要的修改以改进我们的网络工程。
- en: 'Here, we just need to set the `MultiplayerSynchronizer` node’s **Visibility
    Update Mode** property to **None**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要将`MultiplayerSynchronizer`节点的**可见性更新模式**属性设置为**None**：
- en: '![Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update
    Mode property set to None](img/Figure_11.04_B18527.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 小行星节点的`MultiplayerSynchronizer`节点可见性更新模式属性设置为None](img/Figure_11.04_B18527.jpg)'
- en: Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update
    Mode property set to None
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 小行星节点的 MultiplayerSynchronizer 节点的可见性更新模式属性设置为 None
- en: With that, we just have to do the syncing manually now. The `MultiplayerSynchronizer`
    node has a method called `update_visibility()`, which receives an argument where
    we can pass the ID of the peer we want to sync with; if we pass `0`, it updates
    all peers instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要手动进行同步。`MultiplayerSynchronizer` 节点有一个名为 `update_visibility()` 的方法，它接收一个参数，我们可以传递我们想要同步的同伴的
    ID；如果我们传递 `0`，则更新所有同伴。
- en: Note that this method takes into account the filters we set in the *Syncing
    the asteroids* section of [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating
    an Online Adventure Prototype*, using the `set_visibility_for()` method, meaning
    only the peers added using this method will be synced. So, in our case, if we
    don’t add the peer to the filtering using the `set_visibility_for()` method, this
    peer won’t be synced, even if we use the `update_visibility()` method, passing
    the correct peer ID.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法考虑了我们在 [*第 9 章*](B18527_09.xhtml#_idTextAnchor188) 的 *同步小行星* 部分中设置的过滤器，使用
    `set_visibility_for()` 方法，这意味着只有使用此方法添加的同伴才会被同步。因此，在我们的情况下，如果我们不使用 `set_visibility_for()`
    方法将同伴添加到过滤中，即使我们使用 `update_visibility()` 方法并传递正确的同伴 ID，该同伴也不会被同步。
- en: 'The best place to manually sync the `Asteroid` node’s properties will be in
    the `World` class, so open the `res://09.prototyping-space-adventure/Levels/World.gd`
    script . Then, inside the `sync_world()` method, let’s add another group call
    to the `"Sync"` group, but this time to the `update_visibility` method, and pass
    `player_id` as an argument. The whole `sync_world()` method should look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 手动同步 `Asteroid` 节点属性的最佳位置是在 `World` 类中，因此打开 `res://09.prototyping-space-adventure/Levels/World.gd`
    脚本。然后，在 `sync_world()` 方法内部，让我们向 `"Sync"` 组添加另一个分组调用，但这次是调用 `update_visibility`
    方法，并传递 `player_id` 作为参数。整个 `sync_world()` 方法应该看起来像这样：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that, all `Asteroid` nodes should only sync once to every player, decreasing
    the total network resource usage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，所有 `Asteroid` 节点应该只对每个玩家同步一次，从而减少总网络资源的使用。
- en: 'Let’s profile this change as well to see its impact on the overall network
    consumption. The following figure showcases the sync count of some asteroids’
    MultiplayerSynchronizers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将这个更改进行性能分析，以查看其对整体网络消耗的影响。以下图展示了某些小行星的 MultiplayerSynchronizers 的同步计数：
- en: "![Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the\
    \ Asteroid \uFEFFnodes’ MultiplayerSynchronizer \uFEFFnodes’ sync counts](img/Figure_11.05_B18527.jpg)"
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 第二次会话调试器的网络分析器突出显示小行星节点的 MultiplayerSynchronizer 节点的同步计数](img/Figure_11.05_B18527.jpg)'
- en: Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid
    nodes’ MultiplayerSynchronizer nodes’ sync counts
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 第二次会话调试器的网络分析器突出显示小行星节点的 MultiplayerSynchronizer 节点的同步计数
- en: Compare this to *Figure 10**.13*, where we had hundreds and hundreds of updates,
    and for every frame, the update count would increase. After what we’ve done, they
    only increase once a player enters a session and only to that specific player.
    Pretty good job, right?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 *图 10.13* 进行比较，在那里我们有成百上千的更新，并且对于每一帧，更新计数都会增加。在我们所做之后，它们只会在玩家进入会话时增加一次，并且只针对那个特定的玩家。做得不错，对吧？
- en: In this section, we saw how to optimize data requests by decreasing the `asteroid`
    nodes’ `MultiplayerSynchronizer` nodes’ syncs. To do that, we disabled the automatic
    synchronization by setting `MultiplayerSynchronizer` node’s `MultiplayerSynchronizer.update_visibility()`
    method once the player joins the game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何通过减少 `asteroid` 节点的 `MultiplayerSynchronizer` 节点的同步来优化数据请求。为此，我们在玩家加入游戏后禁用了自动同步，设置了
    `MultiplayerSynchronizer` 节点的 `MultiplayerSynchronizer.update_visibility()` 方法。
- en: In the upcoming section, we will see how we can compress data to optimize the
    packet’s size. Until now, we’ve only dealt with how many packets we send or receive,
    but the size of these packets is very important to handle as well. Let’s understand
    what we have available to do that.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解如何压缩数据以优化数据包的大小。到目前为止，我们只处理了发送或接收的数据包数量，但这些数据包的大小同样非常重要。让我们了解我们有哪些可用的方法来做到这一点。
- en: Compressing data with the ENetConnection class
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ENetConnection 类压缩数据
- en: The Godot Engine’s high-level network API includes the `ENetConnection` class.
    This class is available after a connection between peers, such as the server and
    client, is established. Using `ENetConnection`, we can tweak the peer’s connections,
    allowing us to tell, for instance, the compression method. We can access the `ENetConnection`
    instance after the peers have successfully connected. For that, we can use the
    `ENetMultiplayerPeer.host` property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎的高级网络 API 包含 `ENetConnection` 类。在服务器和客户端等对等体之间建立连接后，此类可用。使用 `ENetConnection`，我们可以调整对等体的连接，例如，指定压缩方法。在对等体成功连接后，我们可以访问
    `ENetConnection` 实例。为此，我们可以使用 `ENetMultiplayerPeer.host` 属性。
- en: 'There are five available compression methods to use in the `ENetConnection`
    class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ENetConnection` 类中可以使用五种压缩方法：
- en: '`CompressionMode` enumerator’s `COMPRESS_NONE` option. This is what the documentation
    says:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionMode` 枚举的 `COMPRESS_NONE` 选项。文档中的说明如下：'
- en: '*This uses the most bandwidth but has the upside of requiring the fewest CPU
    resources. This option may also be used to make network debugging using tools
    like* *Wireshark easier.*'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*这使用最多的带宽，但优点是需要的 CPU 资源最少。此选项还可以用于使用 Wireshark 等工具进行网络调试。*'
- en: 'ENet’s built-in `CompressionMode` enumerator’s `COMPRESS_RANGE_CODER` option.
    This is what the documentation says:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENet 内置的 `CompressionMode` 枚举的 `COMPRESS_RANGE_CODER` 选项。文档中的说明如下：
- en: '*[This is] ENet’s built-in range encoding. Works well on small packets, but
    is not the most efficient algorithm on packets larger than* *4 KB.*'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*[这是] ENet 内置的范围编码。在小数据包上表现良好，但大于 *4 KB* 的数据包上不是最有效的算法。*'
- en: '`CompressionMode` enumerator’s `COMPRESS_FASTLZ` option. This is what the documentation
    says:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionMode` 枚举的 `COMPRESS_FASTLZ` 选项。文档中的说明如下：'
- en: '*This option uses less CPU resources compared to COMPRESS_ZLIB, at the expense
    of using* *more bandwidth.*'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*此选项相比 COMPRESS_ZLIB 使用更少的 CPU 资源，但代价是使用更多的带宽。*'
- en: '`CompressionMode` enumerator’s `COMPRESS_ZLIB` option. This is what the documentation
    says:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionMode` 枚举的 `COMPRESS_ZLIB` 选项。文档中的说明如下：'
- en: '*This option uses less bandwidth compared to COMPRESS_FASTLZ , at the expense
    of using more* *CPU resources.*'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*此选项相比 COMPRESS_FASTLZ 使用更少的带宽，但代价是使用更多的 CPU 资源。*'
- en: '`CompressionMode` enumerator’s `COMPRESS_ZSTD` option. This is what the documentation
    says:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionMode` 枚举的 `COMPRESS_ZSTD` 选项。文档中的说明如下：'
- en: '*Note that this algorithm is not very efficient on packets smaller than 4 KB.
    Therefore, it’s recommended to use other compression algorithms in* *most cases.*'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*请注意，此算法在小于 4 KB 的小数据包上效率不高。因此，在大多数情况下，建议使用其他压缩算法。*'
- en: 'You can find more about `ENetConnection` and `CompressionMode` in the Godot
    docs through the following link:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接在 Godot 文档中找到更多关于 `ENetConnection` 和 `CompressionMode` 的信息：
- en: '[https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode](https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode](https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode)'
- en: 'It’s time to work on the size of the data we are transmitting through the network.
    In the following steps, we will implement compression to decrease our game’s packet
    size and optimize the transmission of data through the network. Note that, as
    always, there’s a trade-off between the bandwidth and CPU resources. Our game
    currently doesn’t have any issues regarding CPU usage. So, at this point, we can
    focus on optimizing the network resources. For that, we can use the `COMPRESS_ZLIB`
    compression mode. To do that, let’s open the `res://09.prototyping-space-adventure/Authentication.gd`
    script and complete the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候着手优化我们通过网络传输的数据的大小了。在以下步骤中，我们将实现压缩以减小游戏的包大小并优化网络数据传输。请注意，如往常一样，带宽和 CPU 资源之间存在权衡。我们的游戏目前没有关于
    CPU 使用的问题。因此，在这个阶段，我们可以专注于优化网络资源。为此，我们可以使用 `COMPRESS_ZLIB` 压缩模式。为此，让我们打开 `res://09.prototyping-space-adventure/Authentication.gd`
    脚本并完成以下步骤：
- en: 'Right before we set `multiplayer_peer` to the peer in the `_ready()` callback,
    we are going to change the `ENetConnection` compression mode. For that, we access
    the `host` property and use the `compress()` method, passing `EnetConnection.COMPRESS_ZLIB`
    as an argument:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 回调中将 `multiplayer_peer` 设置为对等体之前，我们将更改 `ENetConnection` 的压缩模式。为此，我们访问
    `host` 属性并使用 `compress()` 方法，将 `EnetConnection.COMPRESS_ZLIB` 作为参数传递：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to do this here because the compression mode needs to be set before
    the connection is established, which happens after we set the `multiplayer.multiplayer_peer`
    property.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在这里做这件事，因为压缩模式需要在建立连接之前设置，而连接是在我们设置`multiplayer.multiplayer_peer`属性之后建立的。
- en: 'We also need to do the same thing in the `res://09.prototyping-spaceadventure/LoggingScreen.gd`
    script so that this connection also matches the server’s connection compression.
    Again, before setting `multiplayer.multiplayer_peer`, we set ENetConnection’s
    compression to `COMPRESS_ZLIB`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`res://09.prototyping-spaceadventure/LoggingScreen.gd`脚本中做同样的事情，以便这个连接也匹配服务器的连接压缩。再次提醒，在设置`multiplayer.multiplayer_peer`之前，我们将ENetConnection的压缩设置为`COMPRESS_ZLIB`：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, we are able to change the compression mode used in our game’s network
    connection as soon as the players join the game’s world. For now, this won’t make
    a huge impact. As we saw in the previous quotes from the documentation, most of
    the compression algorithms aim at having data packets be either below 4 KB or
    above 4 KB. Our game’s packets currently haven’t even reached the Kilobytes yet,
    so…this may not have a big, if any, impact at this point, to be honest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们能够在玩家加入游戏世界时立即更改游戏网络连接中使用的压缩模式。目前，这不会产生很大的影响。正如我们在文档中的先前引用中看到的，大多数压缩算法的目标是使数据包的大小要么低于4
    KB，要么高于4 KB。我们游戏的包目前还没有达到千字节，所以……坦白说，这可能不会有太大的影响，如果有的话。
- en: 'If we want to measure how much bandwidth we are using and get at least a glance
    at any possible improvements, we can use the Debugger’s `EnetConnection` instances’
    sent and received data. For that, we can use the `ENetConnection.pop_statistic()`
    method to create two relevant monitors using the `Performance` singleton to add
    our custom monitors. Let’s do it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要测量我们正在使用的带宽量，并至少浏览一下任何可能的改进，我们可以使用调试器的`EnetConnection`实例的发送和接收数据。为此，我们可以使用`ENetConnection.pop_statistic()`方法，通过使用`Performance`单例来添加我们的自定义监视器，创建两个相关的监视器。让我们来做这件事：
- en: 'Still in the `World` class script, create a method called `get_received_data()`.
    This method needs to return an integer or floating point so we can use it to create
    a monitor. In this case, it will return the received data statistic from the current
    `ENetConnection`. For that, we can use the `pop_statistic()` method, passing `ENetConnection.HOST_TOTAL_RECEIVED_DATA`
    as an argument:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`World`类脚本中，创建一个名为`get_received_data()`的方法。这个方法需要返回一个整数或浮点数，这样我们就可以用它来创建一个监视器。在这种情况下，它将返回当前`ENetConnection`的接收数据统计信息。为此，我们可以使用`pop_statistic()`方法，传递`ENetConnection.HOST_TOTAL_RECEIVED_DATA`作为参数：
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we are going to create another method called `get_sent_data()` and do
    the same thing, but passing `ENetConnection.HOST_TOTAL_SENT_DATA` as an argument
    this time around:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建另一个名为`get_sent_data()`的方法，并做同样的事情，但这次传递`ENetConnection.HOST_TOTAL_SENT_DATA`作为参数：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, in the `_ready()` callback, where we check to see whether this instance
    is the server or not, right above where we create the `Asteroid` instances, we
    are going to add the respective `callable` to the `Performance` singleton using
    the `Performance.add_custom_monitor()` method, like so:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`_ready()`回调中，我们检查这个实例是否是服务器，就在创建`Asteroid`实例的上方，我们将使用`Performance.add_custom_monitor()`方法将相应的`callable`添加到`Performance`单例中，如下所示：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are able to monitor the differences between each compression mode and
    see the one that better fits our game. In the following figure, we compare the
    usage of the `COMPRESS_ZLIB` and `COMPRESS_NONE` compression modes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够监控不同压缩模式之间的差异，并看到哪个更适合我们的游戏。在下面的图中，我们比较了`COMPRESS_ZLIB`和`COMPRESS_NONE`压缩模式的用法：
- en: '![Figure 11.6 – A comparison between the monitors of the data sent and received
    using the COMPRESS_ZLIB and COMPRESS_NONE compression modes](img/Figure_11.06_B18527.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 使用COMPRESS_ZLIB和COMPRESS_NONE压缩模式发送和接收数据监视器的比较](img/Figure_11.06_B18527.jpg)'
- en: Figure 11.6 – A comparison between the monitors of the data sent and received
    using the COMPRESS_ZLIB and COMPRESS_NONE compression modes
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 使用COMPRESS_ZLIB和COMPRESS_NONE压缩模式发送和接收数据监视器的比较
- en: Note that with the `COMPRESS_ZLIB` compression, we had a peak of 12,509 bytes
    on the received data, while we had a peak of 48,802 bytes in the data sent. Meanwhile,
    using `COMPRESS_NONE`, we peaked at 14,470 bytes in the received data and 80,234
    bytes on the sent data – even with very small data packets, we have massive gains,
    especially on the server’s data sent metrics, so we also did a good job there!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`COMPRESS_ZLIB`压缩时，接收数据达到了峰值12,509字节，而发送数据达到了峰值48,802字节。同时，使用`COMPRESS_NONE`，接收数据峰值达到14,470字节，发送数据峰值达到80,234字节——即使是非常小的数据包，我们也取得了巨大的收益，尤其是在服务器的发送数据指标上，所以我们在这方面也做得很好！
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to optimize data requests in our game to improve
    network performance. We focused on decreasing the number of requests being made
    in the game by optimizing the firing of the weapon. We saw how to create an RPC
    method that can change the weapon’s firing state and how to toggle the firing
    state based on the “shoot” action being pressed or released instead of triggering
    the firing on every frame in the `_process()` callback. Finally, we saw how to
    use the network profiler to assess the impact of these optimizations on the game’s
    performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何优化游戏中的数据请求以提高网络性能。我们专注于通过优化武器的发射来减少游戏中发出的请求次数。我们看到了如何创建一个可以改变武器发射状态的RPC方法，以及如何根据“射击”动作的按下或释放来切换发射状态，而不是在`_process()`回调的每一帧上触发发射。最后，我们看到了如何使用网络分析器来评估这些优化对游戏性能的影响。
- en: After that, we tackled the issue of `Asteroid` node’s MultiplayerSynchronizers’
    syncs. We disabled the automatic synchronization by setting the `MultiplayerSynchronizer`
    to `MultiplayerSynchronizer.update_visibility()` method once the player joins
    the game. This decreased the `Asteroid`node’s sync count and decreased the total
    network resource usage. We also saw how to measure the effectiveness of these
    optimizations using the debugger’s network profiler.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们解决了`小行星`节点多玩家同步器同步的问题。当玩家加入游戏后，我们将`MultiplayerSynchronizer`设置为`MultiplayerSynchronizer.update_visibility()`方法来禁用自动同步。这减少了`小行星`节点的同步次数，并降低了总网络资源的使用量。我们还了解了如何使用调试器的网络分析器来衡量这些优化的有效性。
- en: Finally, we learned about the Godot Engine’s high-level network API’s `ENetConnection`
    class, which offers compression methods to optimize the packet size. We saw how
    to use the `ENetConnection.pop_statistic()` method to create custom monitors using
    the `Performance` singleton to track ENetConnection’s sent and received data.
    We compared the usage of the `COMPRESS_ZLIB` and `COMPRESS_NONE` compression modes
    and found that even with very small data packets, we have massive gains, especially
    on the server’s data sent metrics.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Godot引擎高级网络API的`ENetConnection`类，它提供了压缩方法以优化数据包大小。我们看到了如何使用`ENetConnection.pop_statistic()`方法通过使用`Performance`单例来创建自定义监控器，以跟踪ENetConnection的发送和接收数据。我们比较了`COMPRESS_ZLIB`和`COMPRESS_NONE`压缩模式的用法，并发现即使是非常小的数据包，我们也取得了巨大的收益，尤其是在服务器的发送数据指标上。
- en: In the next chapter, we are going to get even deeper into optimization. We are
    going to use interpolation and prediction to decrease the `MultiplayerSynchronizer`
    syncing count of the player’s spaceship while trying to keep the movement consistent
    throughout the game network instances. See you there!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨优化。我们将使用插值和预测来减少玩家飞船的`MultiplayerSynchronizer`同步次数，同时尝试在整个游戏网络实例中保持移动的一致性。那里见！
