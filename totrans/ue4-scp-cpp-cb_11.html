<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with UE4 APIs</h1>
                </header>
            
            <article>
                
<p>The <strong>application programming interface</strong> (<strong>API</strong>) is the way in which you, as the programmer, instruct the engine, and therefore the PC, what to do. Some of the interesting APIs that we'll explore in the recipes in this chapter are as follows:</p>
<ul>
<li>Core/Logging API – defining a custom log category</li>
<li>Core/Logging API – FMessageLog to write messages to the Message Log</li>
<li>Core/Math API – rotation using FRotator</li>
<li>Core/Math API – rotation using FQuat</li>
<li>Core/Math API – rotation using FRotationMatrix to have one object face another</li>
<li>Landscape API – landscape generation with Perlin noise</li>
<li>Foliage API – adding trees procedurally to your level</li>
<li>Landscape and Foliage APIs – map generation using Landscape and Foliage APIs</li>
<li>GameplayAbilities API – triggering an actor's gameplay abilities with game controls</li>
<li>GameplayAbilities API – implementing stats with AttributeSet</li>
<li>GameplayAbilities API – implementing buffs with GameplayEffect</li>
<li>GameplayTags API – attaching GameplayTags to an actor</li>
<li>GameplayTasks API – making things happen with GameplayTasks</li>
<li>HTTP API – downloading web pages using web requests</li>
<li>HTTP API – displaying downloaded progress</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>All of UE4's functionality is encapsulated in modules, including very basic and core functionality. Each module has an API for it. To use an API, there is a very important linkage step, where you must list all APIs that you will be using in your build in a<span> </span><kbd>ProjectName.Build.cs</kbd><span> </span>file, which is located in your<span> </span><span class="packt_screen">Solution Explorer</span><span> </span>window.</p>
<div class="packt_tip">Do not name any of your UE4 projects with the exact same name as one of the UE4 API names!</div>
<p>There are a variety of APIs inside the UE4 engine that expose functionality to various essential parts of it.<span> </span></p>
<p>The UE4 engine's base functionality, which is available in the editor, is quite broad. The functionality from C++ code is actually grouped into little sections called APIs. There is a separate API module for each important functionality in the UE4 codebase. This is done to keep the codebase highly organized and modular.</p>
<div class="packt_tip">Using different APIs may require special linkage in your <kbd>Build.cs</kbd> file! If you are getting build errors, be sure to check that the linkage with the correct APIs is there!</div>
<p>The complete API listing is located in the following documentation: <span class="URLPACKT"><a href="https://docs.unrealengine.com/latest/INT/API/">https://docs.unrealengine.com/latest/INT/API/</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core/Logging API – defining a custom log category</h1>
                </header>
            
            <article>
                
<p>UE4 itself defines several logging categories, including categories such as <kbd>LogActor</kbd>, which has any log messages to do with the <kbd>Actor</kbd> class, and <kbd>LogAnimation</kbd>, which logs messages about animations. In general, UE4 defines a separate logging category for each module. This allows developers to output their log messages to different logging streams. Each log stream's name is prefixed to the outputted message, as shown in the following example log messages from the engine:</p>
<pre>LogContentBrowser: Native class hierarchy updated for <br/> 'HierarchicalLODOutliner' in 0.0011 seconds. Added 1 classes and 2 <br/> folders. 
LogLoad: Full Startup: 8.88 seconds (BP compile: 0.07 seconds) 
LogStreaming:Warning: Failed to read file <br/> '../../../Engine/Content/Editor/Slate/Common/Selection_16x.png' <br/> error. 
LogExternalProfiler: Found external profiler: VSPerf </pre>
<p>These log messages <span>are samples </span>from the engine, each prefixed with their log category. Warning messages appear in yellow and have <span class="packt_screen">Warning</span> added to the front as well.</p>
<p>The example code you will find on the internet tends to use <kbd>LogTemp</kbd> for a UE4 project's own messages, as follows:</p>
<pre>UE_LOG( LogTemp, Warning, TEXT( "Message %d" ), 1 ); </pre>
<p>We can actually improve upon this formula by defining our own custom <kbd>LogCategory</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Have a UE4 project ready in which you'd like to define a custom log. Open a header file that will be included in almost all files using this log.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the main header file for your project; for example, if your project's name is <kbd>Chapter_11</kbd>, you'll open <kbd>Chapter_11.h</kbd>. Add the following line of code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/><br/><strong>DECLARE_LOG_CATEGORY_EXTERN(LogCh11, Log, All);</strong></pre>
<p style="padding-left: 60px">As defined in <kbd>AssertionMacros.h</kbd>, there are three arguments to this declaration, which are as follows:</p>
<ul>
<li style="padding-left: 30px"><kbd>CategoryName</kbd>: This is the log category name being defined (<kbd>LogCh11</kbd> here)</li>
<li style="padding-left: 30px"><kbd>DefaultVerbosity</kbd>: This is the default verbosity to use on log messages</li>
<li style="padding-left: 30px"><kbd>CompileTimeVerbosity</kbd>: This is the verbosity to bake into compiled code</li>
</ul>
<ol start="2">
<li>Inside the main <kbd>.cpp</kbd> file for your project (<kbd>Chapter_11.cpp</kbd> in our case), include the following line of code:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_11.h"<br/>#include "Modules/ModuleManager.h"<br/><br/>IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, Chapter_11, "Chapter_11" );<br/><br/><strong>DEFINE_LOG_CATEGORY(LogCh11);</strong></pre>
<ol start="3">
<li>Now, we can use this log category in our own scripts. As an example, open up your project's <kbd>GameModeBase</kbd> file (in this case, <kbd>Chapter_11GameModeBase.h</kbd>) and add the following function declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_11_API AChapter_11GameModeBase : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <br/>    <strong>void BeginPlay();</strong><br/>};</pre>
<ol start="4">
<li>Then, go to the implementation (<kbd>Chapter_11GameModeBase.cpp</kbd>) and use the following code as an example of the various display categories:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">#include "Chapter_11GameModeBase.h"<br/>#include "Chapter_11.h"<br/><br/>void AChapter_11GameModeBase::BeginPlay()<br/>{<br/><strong>    // Traditional Logging</strong><br/><strong>    UE_LOG(LogTemp, Warning, TEXT("Message %d"), 1);</strong><br/><br/><strong>    // Our custom log type</strong><br/><strong>    UE_LOG(LogCh11, Display, TEXT("A display message, log is working" ) ); // shows in gray </strong><br/><strong>    UE_LOG(LogCh11, Warning, TEXT("A warning message"));</strong><br/><strong>    UE_LOG(LogCh11, Error, TEXT("An error message "));</strong><br/>}</pre>
<ol start="5">
<li>Compile your scripts. Afterwards, open the <span class="packt_screen">World Settings</span> menu and set the <span class="packt_screen">GameMode Override</span> property to <kbd>Chapter_11GameModeBase</kbd> and then run the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5e64d7dd-1c39-4e0b-80fe-1556f7b9cf2b.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The location of the logged messages from the Output Log window</div>
<p>As you can see, we can see our custom log messages being displayed!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Logging works by outputting messages to the <span class="packt_screen">Output Log</span> (<span class="packt_screen">Window</span> | <span class="packt_screen">Developer Tools</span> | <span class="packt_screen">Output Log</span>) as well as a file. All information outputted to the <span class="packt_screen">Output Log</span> is also mirrored to a simple text file that is located in your project's <kbd>/Saved/Logs</kbd> folder. The extension of the log files is <kbd>.log</kbd>, with the most recent one being named <kbd>YourProjectName.log</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can enable or suppress log messages for a particular log channel from within the editor using the following console commands:</p>
<pre>Log LogName off // Stop LogName from displaying at the output 
Log LogName Log // Turn LogName's output on again </pre>
<p>If you'd like to edit the initial values of the output levels of some of the built-in log types, you can use a C++ class to create changes for the <kbd>engine.ini</kbd> config file. You can change the initial values in the <kbd>engine.ini</kbd> configuration file.</p>
<div class="packt_infobox">See <span class="URLPACKT"><a href="https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime">https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime</a></span> for more details.</div>
<p><kbd>UE_LOG</kbd> sends its output to <span class="packt_screen">Output Window</span>. If you'd like to use the more specialized <span class="packt_screen">Message Log</span> window in addition to this, you can use the <kbd>FMessageLog</kbd> object to write your output messages. <kbd>FMessageLog</kbd> writes to both the <span class="packt_screen">Message Log</span> and the <span class="packt_screen">Output Window</span>. See the next recipe for details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core/Logging API – FMessageLog to write messages to the Message Log</h1>
                </header>
            
            <article>
                
<p><kbd>FMessageLog</kbd> is an object that allows you to write output messages to the <span class="packt_screen">Message Log</span> (<span class="packt_screen">Window</span> | <span class="packt_screen">Developer Tools</span> | <span class="packt_screen">Message Log</span>) and <span class="packt_screen">Output Log</span> (<span class="packt_screen">Window</span> | <span class="packt_screen">Developer Tools</span> | <span class="packt_screen">Output Log</span>) simultaneously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Have your project ready and some information to log to <span class="packt_screen">Message Log</span>. Display the <span class="packt_screen">Message Log <span>(</span>Window<span> | </span>Developer Tools<span> | </span>Message Log<span>)</span></span> in your UE4 Editor. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add <kbd>#define</kbd> to your main header file (<kbd>ProjectName.h</kbd>), defining <kbd>LOCTEXT_NAMESPACE</kbd> as something unique to your codebase:</li>
</ol>
<pre style="padding-left: 60px">#define LOCTEXT_NAMESPACE "Chapter11Namespace"</pre>
<p style="padding-left: 60px">This <kbd>#define</kbd> is used by the <kbd>LOCTEXT()</kbd> macro, which we use to generate <kbd>FText</kbd> objects, but is not seen in output messages.</p>
<ol start="2">
<li>Declare your <kbd>FMessageLog</kbd> by constructing it somewhere very global. You can use <kbd>extern</kbd> in your <kbd>ProjectName.h</kbd> file. Consider the following piece of code as an example:</li>
</ol>
<pre style="padding-left: 60px">#define LOCTEXT_NAMESPACE "Chapter11Namespace"<br/><strong>#define FTEXT(x) LOCTEXT(x, x) </strong><br/><br/><strong>extern FName LoggerName;</strong><br/><br/><strong>void CreateLog(FName logName);</strong></pre>
<ol start="3">
<li>Then, create your <kbd>FMessageLog</kbd> by defining it in a <kbd>.cpp</kbd> file and registering it with <kbd>MessageLogModule</kbd>. Be sure to give your logger a clear and unique name on construction. It's the category of your log that will appear to the left of your log messages in <span class="packt_screen">Output Log</span>. For example, <kbd>ProjectName.cpp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_11.h"<br/>#include "Modules/ModuleManager.h"<br/>#include "MessageLog/Public/MessageLogModule.h"<br/>#include "MessageLog.h"<br/><br/>// ...<br/><br/>FName LoggerName("MessageLogChapter11");<br/><br/>void CreateLog(FName logName)<br/>{<br/>    FMessageLogModule&amp; MessageLogModule = FModuleManager::LoadModuleChecked&lt;FMessageLogModule&gt;("MessageLog");<br/>    FMessageLogInitializationOptions InitOptions;<br/>    InitOptions.bShowPages = true;<br/>    InitOptions.bShowFilters = true;<br/>    FText LogListingName = FTEXT("Chapter 11's Log Listing");<br/>    MessageLogModule.RegisterLogListing(logName, LogListingName, InitOptions);<br/>}</pre>
<ol start="4">
<li>Then, head back to somewhere in your code to actually create the log and use it. For example, we can add the following <kbd>GameModeBase</kbd> class's <kbd>BeginPlay</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">void AChapter_11GameModeBase::BeginPlay()<br/>{<br/>    // 11-01 - Core/Logging API - Defining a custom log<br/>    // category<br/>    // Traditional Logging<br/>    UE_LOG(LogTemp, Warning, TEXT("Message %d"), 1);<br/><br/>    // Our custom log type<br/>    UE_LOG(LogCh11, Display, TEXT("A display message, log is working" ) ); // shows in gray <br/>    UE_LOG(LogCh11, Warning, TEXT("A warning message"));<br/>    UE_LOG(LogCh11, Error, TEXT("An error message "));<br/><br/><strong>    // 11-02 - Core/Logging API - FMessageLog to write <br/>    // messages to the Message Log</strong><br/><strong>    CreateLog(LoggerName);</strong><br/><strong>    // Retrieve the Log by using the LoggerName. </strong><br/><strong>    FMessageLog logger(LoggerName);</strong><br/><strong>    logger.Warning(FTEXT("A warning message from gamemode"));</strong><br/>}</pre>
<div class="mce-root packt_tip"><span>The</span> <kbd>KEY</kbd> <span>to</span> <kbd>LOCTEXT</kbd> <span>(first argument) must be unique or you will get a previously hashed string back. If you'd like, you can include a</span> <kbd>#define</kbd> <span>that repeats the argument to</span> <kbd>LOCTEXT</kbd> <span>twice, as we did earlier:<br/>
<br/></span> <kbd>#define FTEXT(x) LOCTEXT(x, x)</kbd></div>
<ol start="5">
<li>Log your messages using the following code:</li>
</ol>
<pre style="padding-left: 60px">logger.Info( FTEXT( "Info to log" ) ); 
logger.Warning( FTEXT( "Warning text to log" ) ); 
logger.Error( FTEXT( "Error text to log" ) ); </pre>
<p style="padding-left: 60px">This code utilizes the <kbd>FTEXT()</kbd> macro we defined earlier. Ensure it is in your codebase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>This recipe displays a message to the Message Log. As we discussed previously, you can see logged information at the </span><span class="packt_screen">Message Log</span><span> (</span><span class="packt_screen">Window</span><span> | </span><span class="packt_screen">Developer Tools</span><span> | </span><span class="packt_screen">Message Log</span><span>) and </span><span class="packt_screen">Output Log</span><span> (</span><span class="packt_screen">Window</span><span> | </span><span class="packt_screen">Developer Tools</span><span> | </span><span class="packt_screen">Output Log</span><span>) .</span></p>
<div class="mce-root packt_tip"><span>Constructing your message log again after initialization retrieves a copy of the original message log. For example, at any place in the code, you can write the following code:<br/>
<br/></span> <kbd>FMessageLog( LoggerName ).Info(FTEXT( "An info message"));</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core/Math API – rotation using FRotator</h1>
                </header>
            
            <article>
                
<p>Rotation in UE4 has such a complete implementation that it can be hard to choose how to rotate your objects. There are three main methods: <kbd>FRotator</kbd>, <kbd>FQuat</kbd>, and <kbd>FRotationMatrix</kbd>. This recipe outlines the construction and use of the first of the three different methods for the rotation of objects—the <kbd>FRotator</kbd>. Using this, and the following two recipes, you can select a method to use to rotate your objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Open a UE4 project that has an object you can get a C++ interface with. For example, you can construct a C++ class Coin that derives from <kbd>Actor</kbd> to test out rotations. Override the <kbd>Coin::Tick()</kbd> method to apply your rotations from the C++ code. Alternatively, you can call these rotation functions in the <kbd>Tick</kbd> event from Blueprints.</p>
<p>In this example, we will rotate an object at a rate of one degree per second by making use of an Actor component. The actual rotation will be the accumulated time since the object was created. To get this value, we'll just call <kbd>GetWorld()-&gt;TimeSeconds</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>From the <span class="packt_screen">Modes</span> tab, under the <span class="packt_screen">Place</span> section and under <span class="packt_screen">Basic</span>, drag and drop a <span class="packt_screen">Cube</span> object into your scene.</li>
<li>From the <span class="packt_screen">Details</span> tab, go to the <span class="packt_screen">Transform</span> component and change the <span class="packt_screen">Mobility</span> property to <span class="packt_screen">Movable</span>.</li>
<li>Afterwards, click on the <span class="packt_screen">Add Component</span> button and select <span class="packt_screen">New C++ Component</span>.</li>
<li>From the menu that pops up, select <span class="packt_screen">Actor Component</span> and select <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7df035bd-fc84-445a-bc58-40af6b94ac73.png" style="width:42.33em;height:25.08em;"/></p>
<ol start="5">
<li>From there, give your component a name, for example, <kbd>RotateActorComponent</kbd>, and then press the <span class="packt_screen">Create Class</span> button.</li>
<li>Construct your <kbd>FRotator</kbd>. <kbd>FRotators</kbd> can be constructed using a stock pitch, yaw, and roll constructor, as shown in the following example:</li>
</ol>
<pre style="padding-left: 60px">FRotator( float InPitch, float InYaw, float InRoll ); </pre>
<ol start="7">
<li>Your <kbd>FRotator</kbd> will be constructed as follows:</li>
</ol>
<pre style="padding-left: 60px">FRotator rotator( 0, GetWorld()-&gt;TimeSeconds, 0 ); </pre>
<ol start="8">
<li>The standard orientation for an object in UE4 is with Forward facing down the <em>+X</em>-axis. Right is the <em>+Y</em>-axis, and Up is <em>+Z</em>.</li>
<li>Pitch is rotation about the <em>Y</em>-axis (across), yaw is rotation about the <em>Z</em>-axis (up), and roll is rotation about the <em>X</em>-axis. This is best understood in the following three points:</li>
</ol>
<ul>
<li style="padding-left: 30px"><strong>Pitch</strong>: If you think of an airplane in UE4 standard coordinates, the <em>Y</em>-axis goes along the wingspan (pitching tilts it forward and backward)</li>
<li class="CDPAlignLeft CDPAlign" style="padding-left: 30px"><strong>Yaw</strong>: The <em>Z</em>-axis goes straight up and down (yawing turns it left and right)</li>
<li style="padding-left: 30px"><strong>Roll</strong>: The <em>X</em>-axis goes straight along the fuselage of the plane (rolling does barrel rolls)</li>
</ul>
<div class="mce-root packt_tip"><span>You should note that in other conventions, the</span> <em>X</em>-<span>axis is pitch, the</span> <em>Y</em>-<span>axis is yaw, and the</span> <em>Z</em>-<span>axis is roll.</span></div>
<ol start="10">
<li>Apply your <kbd>FRotator</kbd> to your actor using the <kbd>SetActorRotation</kbd> member function, as follows:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void URotateActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)<br/>{<br/>    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br/><br/><strong>    FRotator rotator(0, GetWorld()-&gt;TimeSeconds, 0);</strong><br/><strong>    GetOwner()-&gt;SetActorRotation(rotator);</strong><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core/Math API – rotation using FQuat</h1>
                </header>
            
            <article>
                
<p>Quaternions sound intimidating, but they are extremely easy to use. You may want to review the theoretical math behind them by viewing the following videos:</p>
<ul>
<li><em>Fantastic Quaternions</em> by Numberphile: <a href="https://www.youtube.com/watch?v=3BR8tK-LuB0">https://www.youtube.com/watch?v=3BR8tK-LuB0</a></li>
<li><em>Understanding Quaternions</em> by Jim Van Verth: <a href="http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding">http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding</a></li>
</ul>
<p>However, we won't cover the math background here! In fact, you don't need to understand much about the math background of quaternions to use them effectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Have a project ready and an <kbd>Actor</kbd> with an override <kbd>::Tick()</kbd> function that we can enter the C++ code into.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To construct a quaternion, the best constructor to use is as follows:</li>
</ol>
<pre style="padding-left: 60px">FQuat( FVector Axis, float AngleRad ); </pre>
<div class="mce-root packt_tip"><span>Quaternions have quaternion addition, quaternion subtraction, multiplication by a scalar, and division by a scalar defined for them, among other functions. They are extremely useful to rotate things at arbitrary angles, and point objects at one another.</span></div>
<ol start="2">
<li>For example, if you wanted to use an FQuat inside of the <kbd>RotateActorComponent.cpp</kbd> file, it would look similar to this:</li>
</ol>
<pre style="padding-left: 60px">void URotateActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)<br/>{<br/>    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br/><br/>    // 11-04 - Rotation using FQuat<br/><strong>    FQuat quat = FQuat(FVector(0, 1, 0), GetWorld()-&gt;TimeSeconds * PI / 4.f);</strong><br/><strong>    GetOwner()-&gt;SetActorRotation(quat);</strong><br/><br/>}</pre>
<p>Upon compiling your code and returning to the game, you should notice the cube moving at a constant rate:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ddb86012-77dc-4859-ad2f-ea3689f90875.png" style="width:39.00em;height:18.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Quaternions are a bit strange, but using them is quite simple. If <em>v</em> is the axis around which to rotate, and <img src="assets/6edc4c6a-2cc5-4162-9d74-cd70b3b729b3.jpg" style="width:1.17em;height:1.67em;"/> is the magnitude of the angle of rotation, then we get the following equations for the components of a quaternion:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9dc711a-8f43-48f8-bc68-a56de59ad11f.jpg" style="width:8.08em;height:16.33em;"/></p>
<p>So, for example, rotation about <img src="assets/ac235d9d-5ef7-46a7-8ce4-0a18ed80d558.jpg" style="width:10.75em;height:2.83em;"/> by an angle of <img src="assets/69cf02ef-9e27-44a6-9a4b-efdc00908cd8.jpg" style="width:1.42em;height:3.33em;"/> will have the following quaternion components:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d3c4d321-4172-4dbe-9974-d6e0b6c8fe89.jpg" style="width:16.50em;height:3.42em;"/></p>
<p>Three of the four components of the quaternion (<em>x</em>, <em>y</em>, and <em>z</em>) define the axis around which to rotate (scaled by the sine of half the angle of rotation), while the fourth component (<em>w</em>) has only the cosine of half the angle to rotate with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Quaternions, being<span> </span><span>vectors</span><span> themselves, can be rotated. Simply extract the (</span><em>x</em><span>,</span> <em>y</em><span>,</span> <em>z</em><span>) components of the quaternion, normalize, and then rotate that vector. Construct a new quaternion from that new unit vector with the desired angle of rotation.</span></p>
<p>Multiplying quaternions together represents a series of rotations that happen subsequently. For example, a rotation of 45º about the <em>X</em>-axis, followed by a rotation of 45º about the <em>Y</em>-axis will be composed by the following:</p>
<pre>FQuat( FVector( 1, 0, 0 ), PI/4.f ) * 
FQuat( FVector( 0, 1, 0 ), PI/4.f ); </pre>
<p>This would give you a result that would look similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f4bbdb04-e68b-48f2-abea-f943c4029dfd.png" style="width:39.67em;height:18.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API – rotation using FRotationMatrix to have one object face another</h1>
                </header>
            
            <article>
                
<p><kbd>FRotationMatrix</kbd> offers matrix construction using a series of <kbd>::Make*</kbd> routines. They are easy to use and useful to get one object to face another. Say you have two objects, one of which is following the other. We want the rotation of the follower to always be facing what it is following. The construction methods of <kbd>FRotationMatrix</kbd> make this easy to do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Have two actors in a scene, one of which should face the other. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add a new <span class="packt_screen">C++ Actor Component</span> for the follower called <kbd>FollowActorComponent</kbd> (see the <em>Core/Math API – rotation using FRotator</em> recipe if you need help with this).</li>
<li>From the <kbd>FollowActorComponent.h</kbd> file, we need to have a reference to the object we want to follow, so add the following:</li>
</ol>
<pre style="padding-left: 60px">UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )<br/>class CHAPTER_11_API UFollowActorComponent : public UActorComponent<br/>{<br/>    GENERATED_BODY()<br/><br/>public: <br/>    // Sets default values for this component's properties<br/>    UFollowActorComponent();<br/><br/>protected:<br/>    // Called when the game starts<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;<br/><br/>    <strong>UPROPERTY(EditAnywhere)</strong><br/><strong>    AActor * target;</strong><br/>};</pre>
<ol start="3">
<li>Then, in the <kbd>FollowActorComponent.cpp</kbd> file, in the <kbd>TickComponent</kbd> function, look into the available constructors under the<span> </span><kbd>FRotationMatrix</kbd><span> </span>class. A bunch of constructors are available that will let you specify a rotation for an object (from stock position) by reorienting one or more of the<span> </span><em>X</em>-,<span> </span><em>Y</em>-, or<span> </span><em>Z</em><span>-</span>axes, named with the<span> </span><kbd>FRotationMatrix::Make*()</kbd><span> </span>pattern.</li>
<li>Assuming you have a default stock orientation for your actor (with Forward facing down the<span> </span><em>+X</em><span>-</span>axis, and up facing up the<span> </span><em>+Z</em><span>-</span>axis), find the vector from the follower to the object they want to follow, as shown in this piece of code:</li>
</ol>
<pre style="padding-left: 60px">// Called every frame<br/>void UFollowActorComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)<br/>{<br/>    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);<br/><br/><strong>    FVector toFollow = target-&gt;GetActorLocation() - GetOwner()-&gt;GetActorLocation();</strong><br/><br/><strong>    FMatrix rotationMatrix = FRotationMatrix::MakeFromXZ(toFollow, GetOwner()-&gt;GetActorUpVector());</strong><br/><br/><strong>    GetOwner()-&gt;SetActorRotation(rotationMatrix.Rotator());</strong><br/><br/>}</pre>
<ol start="5">
<li>Compile your script and assign the <span class="packt_screen">Target</span> property inside of the <span class="packt_screen">Follow Actor Component</span> from the <span class="packt_screen">Details</span> tab. This can be done using the eyedropper button to the right of the property or by using the drop-down list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/37b4eeb3-2998-4d99-b3cf-0d6e219be4d6.png"/></p>
<p>If all went well, you should see the actor rotate correctly to face the target:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c28f774e-1745-4d24-bcd7-8d7986021a0c.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Getting one object to look at another, with a desired up vector, can be done by calling the correct function, depending on your object's stock orientation. Usually, you want to reorient the <em>X</em>-axis (Forward), while specifying either the <em>Y</em>-axis (Right) or <em>Z</em>-axis (Up) vectors (<kbd>FRotationMatrix::MakeFromXY()</kbd>). For example, to make an actor look along a <kbd>lookAlong</kbd> vector, with its right side facing right, we'd construct and set <kbd>FRotationMatrix</kbd> for it, as follows:</p>
<pre>FRotationMatrix rotationMatrix = FRotationMatrix::MakeFromXY( <br/> lookAlong, right ); 
actor-&gt;SetActorRotation( rotationMatrix.Rotator() ); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GameplayAbilities API – triggering an actor's gameplay abilities with game controls</h1>
                </header>
            
            <article>
                
<p style="color: black">The <strong>GameplayAbilities</strong> API can be used to attach C++ functions to invoke on certain button pushes, triggering the game unit to exhibit its abilities during play in response to keystroke events. In this recipe, we will show you how to do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black">Enumerate and describe your game character's abilities. You will need to know what your character does in response to key events to code in this recipe.</p>
<p style="color: black">There are several objects that we need to use here; they are as follows:</p>
<ul>
<li>The <kbd>UGameplayAbility</kbd> class—this is needed to derive the C++ class instances of the <kbd>UGameplayAbility</kbd> class, with one derivative class for each ability:</li>
<li style="padding-left: 30px">Define what each ability does in <kbd>.h</kbd> and <kbd>.cpp</kbd> by overriding the available functions, such as <kbd>UGameplayAbility::ActivateAbility</kbd>, <kbd>UGameplayAbility::InputPressed</kbd>, <kbd>UGameplayAbility::CheckCost</kbd>, <kbd>UGameplayAbility::ApplyCost</kbd>, <kbd>UGameplayAbility::ApplyCooldown</kbd>, and so on</li>
<li><kbd>GameplayAbilitiesSet</kbd> is a <kbd>DataAsset</kbd> derivative object that contains a series of enum'd command values, and blueprints of the corresponding <kbd>UGameplayAbility</kbd> derivative classes that define the behavior for that particular input command. Each GameplayAbility is kicked off by a keystroke or mouse-click, which is set in <kbd>DefaultInput.ini</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p style="color: black">In the following code, we'll implement a <kbd>UGameplayAbility</kbd> derivative called <kbd>UGameplayAbility_Attack</kbd> for a <kbd>Warrior</kbd> class object. We'll attach this gameplay functionality to the input command string <kbd>Ability1</kbd>, which we'll activate on the left-mouse button-click:</p>
<ol>
<li>Open up your <kbd>.Build.cs</kbd> file (in our case, <kbd>Chapter_11.Build.cs</kbd>) and add the following dependencies:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_11 : ModuleRules<br/>{<br/>    public Chapter_11(ReadOnlyTargetRules Target) : <br/>    base(Target)<br/>    {<br/>        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/>    <br/>        PublicDependencyModuleNames.AddRange(new string[] {<br/>        "Core", "CoreUObject", "Engine", "InputCore" });<br/>        <strong>PublicDependencyModuleNames.AddRange(new string[] {  <br/>        "GameplayAbilities", "GameplayTags", "GameplayTasks" });</strong><br/><br/>        PrivateDependencyModuleNames.AddRange(new string[] { });<br/>    }<br/>}</pre>
<ol start="2">
<li>Compile your code.</li>
<li>From the Unreal Editor, go to <span class="packt_screen">Settings | Plugins</span>.</li>
</ol>
<ol start="4">
<li>From the menu that pops up, search for <kbd>GameplayAbilities</kbd> and check it. You'll get a message asking if you are sure. Click on the <span class="packt_screen">Yes</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb27ba3b-6389-4a08-9651-614f0d31f7dc.png" style="width:39.58em;height:16.50em;"/></p>
<ol start="5">
<li>Afterwards, click on the <span class="packt_screen">Restart Now</span> button. The classes should be added to your project correctly.</li>
<li>Now, access the <span class="packt_screen">Add C++ Class</span> wizard by selecting from the Content Browser <span class="packt_screen">Add New | New C++ Class...</span> and check the <span class="packt_screen">Show All Classes</span> option. From there, type in <kbd>gameplayability</kbd> and select the base <span class="packt_screen">GameplayAbility</span> class to base our new class on:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b731ae0b-66a3-40f4-a9d8-dae61e50aafb.png" style="width:39.83em;height:24.17em;"/></p>
<ol start="7">
<li>Give the new gameplay ability a name of <span><kbd>GameplayAbility_Attack</kbd> </span>and press <span class="packt_screen">Create Class</span>.</li>
<li>At the very least, you want to override the following:</li>
</ol>
<ul>
<li style="padding-left: 30px">The <kbd>UGameplayAbility_Attack::CanActivateAbility</kbd> member function to indicate when the actor is allowed to invoke the ability.</li>
<li style="padding-left: 30px">The <kbd>UGameplayAbility_Attack::CheckCost</kbd> function to indicate whether the player can afford to use an ability or not. This is extremely important because if this returns false, ability invocation should fail.</li>
<li style="padding-left: 30px">The <kbd>UGameplayAbility_Attack::ActivateAbility</kbd> member function to write the code that the <kbd>Warrior</kbd> is to execute when their <kbd>Attack</kbd> ability is activated.</li>
<li style="padding-left: 30px">The <kbd>UGameplayAbility_Attack::InputPressed</kbd> member function and to respond to the key input event assigned to the ability:</li>
</ul>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Abilities/GameplayAbility.h"<br/>#include "GameplayAbility_Attack.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_11_API UGameplayAbility_Attack : public UGameplayAbility<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>        /** Returns true if this ability can be activated<br/>        right now. Has no side effects */</strong><br/><strong>        virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const {</strong><br/><strong>        UE_LOG(LogTemp, Warning, TEXT("ability_attack <br/>        CanActivateAbility!"));</strong><br/><strong>        return true;</strong><br/><strong>    }</strong><br/><br/><strong>    /** Checks cost. returns true if we can pay for the<br/>    ability. False if not */</strong><br/><strong>    virtual bool CheckCost(const FGameplayAbilitySpecHandle Handle, <br/>    const FGameplayAbilityActorInfo* ActorInfo, OUT <br/>    FGameplayTagContainer* OptionalRelevantTags = nullptr) const {</strong><br/><strong>        UE_LOG(LogTemp, Warning, TEXT("ability_attack CheckCost!"));</strong><br/><strong>        return true;</strong><br/><strong>        //return Super::CheckCost( Handle, ActorInfo, <br/>        //OptionalRelevantTags );</strong><br/><strong>    }</strong><br/><br/><strong>    virtual void ActivateAbility(const FGameplayAbilitySpecHandle <br/>    Handle,</strong><br/><strong>        const FGameplayAbilityActorInfo* ActorInfo, const <br/>        FGameplayAbilityActivationInfo ActivationInfo,</strong><br/><strong>        const FGameplayEventData* TriggerEventData)</strong><br/><strong>    {</strong><br/><strong>        UE_LOG(LogTemp, Warning, TEXT("Activating <br/>        ugameplayability_attack().. swings weapon!"));</strong><br/><strong>        Super::ActivateAbility(Handle, ActorInfo, ActivationInfo,  <br/>        TriggerEventData);</strong><br/><strong>    }</strong><br/><br/><strong>    /** Input binding stub. */</strong><br/><strong>    virtual void InputPressed(const FGameplayAbilitySpecHandle <br/>    Handle, const FGameplayAbilityActorInfo* ActorInfo, const <br/>    FGameplayAbilityActivationInfo ActivationInfo) {</strong><br/><strong>        UE_LOG(LogTemp, Warning, TEXT("ability_attack <br/>        inputpressed!"));</strong><br/><strong>        Super::InputPressed(Handle, ActorInfo, ActivationInfo);</strong><br/><strong>    }</strong><br/>  <br/>};</pre>
<ol start="9">
<li>Derive a Blueprint class from your <kbd>UGameplayAbility_Attack</kbd> object inside the UE4 Editor.</li>
</ol>
<ol start="10">
<li>Inside the Editor, navigate to <span class="packt_screen">Content Browser</span> and create a <kbd>GameplayAbilitiesSet</kbd> object by doing the following:</li>
</ol>
<ul>
<li style="padding-left: 30px">Right-clicking on <span class="packt_screen">Content Browser</span> and selecting <span class="packt_screen">Miscellaneous</span> | <span class="packt_screen">Data Asset</span>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/777500fc-befc-4e6b-b1ca-8924737f7ecf.png"/></p>
<ul>
<li style="padding-left: 30px">In the dialog box that follows, select <kbd>GameplayAbilitySet</kbd> for the <span class="packt_screen"><span class="packt_screen">Data Asset</span></span> <span class="packt_screen">Class</span>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90023d90-6b67-4cc4-896a-ace1d96ee8c5.png" style="width:37.00em;height:31.33em;"/></p>
<div class="mce-root packt_tip"><span>In fact, the </span><kbd>GameplayAbilitySet</kbd><span> object is a </span><kbd>UDataAsset</kbd><span> derivative. It is located in </span><kbd>GameplayAbilitySet.h</kbd><span> and contains a single member function, </span><kbd>GameplayAbilitySet::GiveAbilities()</kbd><span>, which I strongly recommend you not to use for reasons listed in a later step.</span></div>
<ol start="11">
<li>Name your <kbd>GameplayAbilitySet</kbd> data asset something related to the <kbd>WarriorAbilitySet</kbd> object so that we know to put it into the <kbd>Warrior</kbd> class (for example, <kbd>WarriorAbilitySet</kbd>).</li>
<li>Double-click to open and edit the new <kbd>WarriorAbilitySet</kbd> Data Asset. Stack in a list of <kbd>GameplayAbility</kbd> class derivative Blueprints by clicking <span class="packt_screen">+</span> on the <kbd>TArray</kbd> object inside of it. Your <kbd>UGameplayAbility_Attack</kbd> object must appear in the dropdown:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/01c90d63-775f-4669-8d74-a9e01192e4f7.png"/></p>
<ol start="13">
<li>We now need to create a <kbd>Character</kbd> class-derived object so that we can contain this ability set. In this example, we will call this class <kbd>Warrior</kbd>.</li>
<li>Add a <kbd>UPROPERTY UGameplayAbilitySet* gameplayAbilitySet</kbd> member to your <kbd>Warrior</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Character.h"<br/><strong>#include "GameplayAbilitySet.h"</strong><br/><strong>#include "AbilitySystemInterface.h"</strong><br/>#include "Warrior.generated.h"<br/><br/><strong>#define FS(x,...) FString::Printf( TEXT( x ), __VA_ARGS__ )</strong><br/><br/>UCLASS()<br/>class CHAPTER_11_API AWarrior : public ACharacter<strong>, public IAbilitySystemInterface</strong><br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    // Sets default values for this character's properties<br/>    AWarrior();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>    // Called to bind functionality to input<br/>    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;<br/><br/><strong>    // Lists key triggers for various abilities for the <br/>    // player.</strong><br/><strong>    // Selects an instance of UGameplayAbilitySet (which is a      //    \<br/>    UDataAsset derivative</strong><br/><strong>    // that you construct in the Content Browser).</strong><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =<br/>    Stats)</strong><br/><strong>    UGameplayAbilitySet* gameplayAbilitySet;</strong><br/><br/><strong>    // The AbilitySystemComponent itself</strong><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =<br/>    Stats)</strong><br/><strong>    UAbilitySystemComponent* AbilitySystemComponent;</strong><br/><br/><strong>    // IAbilitySystemInterface implementation:</strong><br/><strong>    virtual UAbilitySystemComponent* GetAbilitySystemComponent() const { return AbilitySystemComponent; }</strong><br/><br/>};<br/><br/></pre>
<p style="padding-left: 60px">Ensure that your<span> </span><kbd>Actor</kbd><span> </span>class derivative also derives from the<span> </span><kbd>UAbilitySystemInterface</kbd><span> </span>interface. This is extremely important so that calls to<span> </span><kbd>(Cast&lt;IAbilitySystemInterface&gt;(yourActor))-&gt;GetAbilitySystemComponent()</kbd><span> </span>succeed.</p>
<ol start="15">
<li>Create a Blueprint of the <kbd>Warrior</kbd> class and set the <span class="packt_screen">Gameplay Ability Set</span> to the <span class="packt_screen">Warrior Ability Set</span> we created earlier, and set the <span class="packt_screen">Ability System Component</span> to the <span class="packt_screen">Ability System Component</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/16747445-09a2-4b0e-b317-85c07b104892.png" style="width:46.50em;height:48.00em;"/></p>
<div class="packt_tip">If you are unable to see the <span class="packt_screen">Ability System Component</span>, close and reopen the Blueprint.</div>
<ol start="16">
<li>Once finished, assign <kbd>MyWarrior</kbd> as the <span class="packt_screen">Default Pawn Class</span> of your Game Mode.</li>
<li>Compile, run, and select-in <kbd>WarriorAbilitySet</kbd> as it sits in <span class="packt_screen">Content Browser</span> (created in Steps 5 to 7) of the abilities of which this <kbd>Warrior</kbd> is capable.</li>
<li>Some time after the construction of your actor, call <kbd>gameplayAbilitySet-&gt;GiveAbilities( abilitySystemComponent );</kbd> or enter a loop, as shown in the following step where you invoke <kbd>abilitySystemComponent-&gt;GiveAbility()</kbd> for each ability listed in your <kbd>gameplayAbilitySet</kbd>.</li>
<li>Write an override for <kbd>AWarrior::SetupPlayerInputComponent( UInputComponent* Input )</kbd> to connect the input controller to the Warrior's <kbd>GameplayAbility</kbd> activations. After doing so, iterate over each <kbd>GameplayAbility</kbd> listed in your <kbd>GameplayAbilitySet</kbd>'s <span class="packt_screen">Abilities</span> group:</li>
</ol>
<pre style="color: black;padding-left: 60px">#include "AbilitySystemComponent.h"<br/><br/>// ...<br/><br/>// Called to bind functionality to input<br/>void AWarrior::SetupPlayerInputComponent(UInputComponent* Input)<br/>{<br/>    Super::SetupPlayerInputComponent(Input);<br/><br/>    // Connect the class's AbilitySystemComponent <br/>    // to the actor's input component <br/>    AbilitySystemComponent-&gt;BindToInputComponent(Input);<br/><br/>    // Go thru each BindInfo in the gameplayAbilitySet. <br/>    // Give &amp; try and activate each on the <br/>    // AbilitySystemComponent. <br/>    for (const FGameplayAbilityBindInfo&amp; BindInfo :<br/>        gameplayAbilitySet-&gt;Abilities)<br/>    {<br/><br/>        FGameplayAbilitySpec spec(<br/>            // Gets you an instance of the UClass <br/>            BindInfo.GameplayAbilityClass-&gt;<br/>            GetDefaultObject&lt;UGameplayAbility&gt;(),<br/>            1, (int32)BindInfo.Command);<br/><br/>        // STORE THE ABILITY HANDLE FOR LATER INVOKATION <br/>        // OF THE ABILITY <br/>        FGameplayAbilitySpecHandle abilityHandle =<br/>            AbilitySystemComponent-&gt;GiveAbility(spec);<br/><br/>        // The integer id that invokes the ability <br/>        // (ith value in enum listing) <br/>        int32 AbilityID = (int32)BindInfo.Command;<br/><br/>        // CONSTRUCT the inputBinds object, which will <br/>        // allow us to wire-up an input event to the <br/>        // InputPressed() / InputReleased() events of <br/>        // the GameplayAbility. <br/>        FGameplayAbilityInputBinds inputBinds(<br/>            // These are supposed to be unique strings that <br/>            // define what kicks off the ability for the actor        <br/>            // instance. <br/>            // Using strings of the format <br/>            // "ConfirmTargetting_Player0_AbilityClass" <br/>            FS("ConfirmTargetting_%s_%s", *GetName(),<br/>                *BindInfo.GameplayAbilityClass-&gt;GetName()),<br/>            FS("CancelTargetting_%s_%s", *GetName(),<br/>                *BindInfo.GameplayAbilityClass-&gt;GetName()),<br/>            "EGameplayAbilityInputBinds", // The name of the<br/>            // ENUM that has the abilities listing<br/>            // (GameplayAbilitySet.h). <br/>            AbilityID, AbilityID<br/>        );<br/>        // MUST BIND EACH ABILITY TO THE INPUTCOMPONENT,<br/>        // OTHERWISE THE ABILITY CANNOT "HEAR" INPUT EVENTS. <br/>        // Enables triggering of InputPressed() / <br/>        // InputReleased() events, which you can in-turn use <br/>        // to call <br/>        // TryActivateAbility() if you so choose. <br/>        AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(<br/>            Input, inputBinds<br/>        );<br/><br/>        // Test-kicks the ability to active state. <br/>        // You can try invoking this manually via your <br/>        // own hookups to keypresses in this Warrior class <br/>        // TryActivateAbility() calls ActivateAbility() if <br/>        // the ability is indeed invokable at this time <br/>        // according to rules internal to the Ability's class <br/>        // (such as cooldown is ready and cost is met) <br/>        AbilitySystemComponent-&gt;TryActivateAbility(<br/>            abilityHandle, 1);<br/>    }<br/>}<br/><br/><br/></pre>
<ol start="20">
<li>Compile your code and then play the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7cad0887-cbad-49f8-966b-83e6fc2d9f0d.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black">You must subclass and link in a set of <kbd>UGameplayAbility</kbd> objects to your actor's <kbd>UAbilitySystemComponent</kbd> object through a series of calls to <kbd>UAbilitySystemComponent::GiveAbility( spec )</kbd> with appropriately constructed <kbd>FGameplayAbilitySpec</kbd> objects. What this does is deck out your actor with this bunch of <kbd>GameplayAbilities</kbd>. The functionality of each <kbd>UGameplayAbility</kbd>, as well as its cost, cooldown, and activation, is all neatly contained within the <kbd>UGameplayAbility</kbd> class derivative that you will construct.</p>
<p><span>Do not use  the</span><span> </span><kbd>GameplayAbilitySet::GiveAbilities()</kbd><span> </span><span>member function because it doesn't give you access to the set of</span><span> </span><kbd>FGameplayAbilitySpecHandle</kbd><span> </span><span>objects that you actually need later </span><span>to</span><span> </span><span>bind and invoke the ability to an input component.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p style="color: black">You'll want to carefully code in a bunch of the other functions that are available in the <kbd>GameplayAbility.h</kbd> header file, including implementations for the following:</p>
<ul>
<li><kbd>SendGameplayEvent</kbd>: This is a function to notify GameplayAbility that some general gameplay event has happened.</li>
<li><kbd>CancelAbility</kbd>: This is a function to stop an ability's usage midway through, and to give the ability an interrupted state.</li>
<li>Keep in mind that there are a bunch of existing <kbd>UPROPERTY</kbd> specifiers near the bottom of the <kbd>UGameplayAbility</kbd> class declaration that either activate or cancel the ability upon addition or removal of certain <kbd>GameplayTags</kbd>. See the following <em>GameplayTags API – attaching GameplayTags to an actor</em> recipe for more details.</li>
<li>There are a bunch more! Explore the API and implement those functions you find to be useful in your code.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <kbd>GameplayAbilities</kbd> API is a rich and nicely interwoven series of objects and functions. Explore <kbd>GameplayEffects</kbd>, <kbd>GameplayTags</kbd>, and <kbd>GameplayTasks</kbd> and how they integrate with the <kbd>UGameplayAbility</kbd> class to fully explore the functionality the library has to offer. You can read more about the API here: <a href="https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html">https://api.unrealengine.com/INT/API/Plugins/GameplayAbilities/index.html</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GameplayAbilities API - Implementing stats with UAttributeSet</h1>
                </header>
            
            <article>
                
<p style="color: black">The <kbd>GameplayAbilities</kbd> API allows you to associate a set of attributes, that is, <kbd>UAttributeSet</kbd>, to an Actor. <kbd>UAttributeSet</kbd> describes properties appropriate for that Actor's in-game attributes, such as <kbd>Hp</kbd>, <kbd>Mana</kbd>, <kbd>Speed</kbd>, <kbd>Armor</kbd>, <kbd>AttackDamage</kbd>, and so on. You can either define a single game-wide set of attributes common to all Actors, or several different sets of attributes appropriate for the different classes of actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black"><kbd>AbilitySystemComponent</kbd> is the first thing you will need to add to your actors to equip them to use the <kbd>GameplayAbilities</kbd> API and <kbd>UAttributeSet</kbd> classes. To define your custom <kbd>UAttributeSet</kbd>, you will simply derive from the <kbd>UAttributeSet</kbd> base class and extend the base class with your own series of <kbd>UPROPERTY</kbd> members. After that, you must register your custom <kbd>AttributeSet</kbd> with your <kbd>Actor</kbd> class's <kbd>AbilitySystemComponent</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>If you have not done so already, complete Steps 1-4 of the <em>GameplayAbilities API – triggering an actor's gameplay abilities with game controls</em> recipe to link to the <kbd>GameplayAbilities</kbd> API in your <kbd>ProjectName.Build.cs</kbd> file and enable its functionality.</li>
<li>Create a new C++ class  by going to the <span class="packt_screen">Content Browser</span> and selecting <span class="packt_screen">Add New | Add C++ Class</span>. From the <span class="packt_screen">Add C++ Class</span> menu, check the <span class="packt_screen">Show All Classes</span> option. From there, type in <kbd>attr</kbd> and select <kbd>AttributeSet</kbd> as your parent class. From there, click the <span class="packt_screen">Next</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/98d22785-cb67-4d52-b392-4c4424e5a76e.png" style="width:51.17em;height:30.92em;"/></p>
<ol start="3">
<li>Give the class a <span class="packt_screen">Name</span> of <kbd>GameUnitAttributeSet</kbd> and click on <span class="packt_screen">Create Class</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df7f58db-1f4a-46d1-a5e5-3c5e43478d3d.png"/></p>
<p style="padding-left: 60px">Once created, deck the class out with a set of <kbd>UPROPERTY</kbd> specifiers that you want each Actor to have in their property set.</p>
<ol start="4">
<li>For example, you might want to declare your <kbd>UAttributeSet</kbd> derivate class similar to what's given in the following piece of code:</li>
</ol>
<pre style="color: black;padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "AttributeSet.h"<br/>#include "GameUnitAttributeSet.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS(<strong>Blueprintable, BlueprintType</strong>)<br/>class CHAPTER_11_API UGameUnitAttributeSet : public UAttributeSet<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)</strong><br/><strong>    float Hp;</strong><br/><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)</strong><br/><strong>    float Mana;</strong><br/><br/><strong>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes)</strong><br/><strong>    float Speed;</strong><br/><strong>};</strong><br/><br/></pre>
<div class="mce-root packt_tip"><span>If your code is networked, you might want to enable replication on each of the</span> <kbd>UPROPERTY</kbd> specifiers <span>with the replicated declaration in the</span> <kbd>UPROPERTY</kbd> <span>macro.</span></div>
<ol start="5">
<li>Connect <kbd>GameUnitAttributeSet</kbd> with your <kbd>AbilitySystemComponent</kbd> inside your <kbd>Actor</kbd> class. We can do this with the <kbd>Warrior</kbd> class we created previously by opening the <kbd>Warrior.h</kbd> file and adding the following function declaration:</li>
</ol>
<pre style="padding-left: 60px">virtual void PostInitializeComponents() override;</pre>
<ol start="6">
<li>Then, open <kbd>Warrior.cpp</kbd> and add the following <kbd>#include</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "GameUnitAttributeSet.h"</pre>
<ol start="7">
<li>Afterwards, implement that function:</li>
</ol>
<pre style="padding-left: 60px">void AWarrior::PostInitializeComponents()<br/>{<br/>    Super::PostInitializeComponents();<br/><br/>    if(AbilitySystemComponent)<br/>    {<br/>        AbilitySystemComponent-&gt;InitStats(UGameUnitAttributeSet::StaticClass(), NULL);<br/>    }<br/>}</pre>
<div class="packt_tip" style="padding-left: 60px">You can put this call somewhere in <kbd>PostInitializeComponents()</kbd>, or in code that is called later than that.</div>
<ol start="8">
<li>Once you have registered <kbd>UAttributeSet</kbd>, you can move on with the next recipe and apply <kbd>GameplayEffect</kbd> to some of the elements in the attribute set.</li>
</ol>
<ol start="9">
<li>Be sure your <kbd>Actor</kbd> class object implements <kbd>IAbilitySystemInterface</kbd> by deriving from it. This is extremely important as the <kbd>UAbilitySet</kbd> object will attempt a cast to <kbd>IAbilitySystemInterface</kbd> to call <kbd>GetAbilitySystemComponent()</kbd> on it at various places in the code.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black"><kbd>UAttributeSets</kbd> simply allow you to enumerate and define attributes of different actors. <kbd>GameplayEffects</kbd> will be your means to make changes to the attributes of a specific actor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p style="color: black">You can code in definitions of <kbd>GameplayEffects</kbd>, which will be things that act on the <kbd>AbilitySystemComponent</kbd>'s <kbd>AttributeSet</kbd> collections. You can also write <kbd>GameplayTasks</kbd> for generic functions that run at specific times or follow particular events, or even in response to a tag addition (<kbd>GameplayTagResponseTable.cpp</kbd>). You can define <kbd>GameplayTags</kbd> to modify <kbd>GameplayAbility</kbd> behavior, as well as select and match gameplay units during play.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GameplayAbilities API – implementing buffs with GameplayEffect</h1>
                </header>
            
            <article>
                
<p style="color: black">A buff is just an effect that introduces a temporary, permanent, or recurring change to a game unit's attributes from its <kbd>AttributeSet</kbd>. Buffs can either be good or bad, supplying either bonuses or penalties. For example, you might have a hex buff that slows a unit to half speed, an angel wing buff that increases unit speed by 2x, or a cherub buff that recovers <kbd>5 hp</kbd> every 5 seconds for 3 minutes. A <kbd>GameplayEffect</kbd> affects an individual gameplay attribute in the <kbd>UAttributeSet</kbd> that's attached to an <kbd>AbilitySystemComponent</kbd> of an Actor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black">Brainstorm your game units' effects that happen during the game. Be sure that you've created an <kbd>AttributeSet</kbd>, as shown in the previous recipe, with gameplay attributes that you'd like to affect. Select an effect to implement and follow the succeeding steps with your example.</p>
<div class="packt_tip"><span>You may want to turn </span><kbd>LogAbilitySystem</kbd><span> into a </span><kbd>VeryVerbose</kbd><span> setting by going to the </span><span class="packt_screen">Output Log</span><span> and typing </span><kbd>`</kbd><span>, and then </span><kbd>Log LogAbilitySystem All</kbd><span>. This will display much more information from <kbd>AbilitySystem</kbd> in the <span class="packt_screen">Output Log</span>, making it easier to see what's going on within the system.<br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p style="color: black">In the following steps, we'll construct a quick <kbd>GameplayEffect</kbd> that heals <kbd>50 hp</kbd> to the selected unit's <kbd>AttributeSet</kbd>:</p>
<ol>
<li>Open up the <kbd>Warrior.h</kbd> file we created previously. In there, add the following function definition:</li>
</ol>
<pre style="padding-left: 60px">void TestGameplayEffect();</pre>
<ol start="2">
<li>Afterwards, open up <kbd>Warrior.cpp</kbd> and add the following methods:</li>
</ol>
<pre style="padding-left: 60px">inline UGameplayEffect* ConstructGameplayEffect(FString name)<br/>{<br/>    return NewObject&lt;UGameplayEffect&gt;(GetTransientPackage(), FName(*name));<br/>}<br/><br/>inline FGameplayModifierInfo&amp; AddModifier(<br/>    UGameplayEffect* Effect, UProperty* Property,<br/>    EGameplayModOp::Type Op,<br/>    const FGameplayEffectModifierMagnitude&amp; Magnitude)<br/>{<br/>    int32 index = Effect-&gt;Modifiers.Num();<br/>    Effect-&gt;Modifiers.SetNum(index + 1);<br/>    FGameplayModifierInfo&amp; Info = Effect-&gt;Modifiers[index];<br/>    Info.ModifierMagnitude = Magnitude;<br/>    Info.ModifierOp = Op;<br/>    Info.Attribute.SetUProperty(Property);<br/>    return Info;<br/>}</pre>
<ol start="3">
<li>Then, add the following code to implement:</li>
</ol>
<pre style="padding-left: 60px">void AWarrior::TestGameplayEffect()<br/>{<br/>    // Construct &amp; retrieve UProperty to affect<br/>    UGameplayEffect* RecoverHP = ConstructGameplayEffect("RecoverHP");<br/><br/>    // Compile-time checked retrieval of Hp UPROPERTY()<br/>    // from our UGameUnitAttributeSet class (listed in<br/>    // UGameUnitAttributeSet.h)<br/>    UProperty* hpProperty = FindFieldChecked&lt;UProperty&gt;(<br/>        UGameUnitAttributeSet::StaticClass(),<br/>        GET_MEMBER_NAME_CHECKED(UGameUnitAttributeSet, Hp));<br/><br/>}</pre>
<ol start="4">
<li>Use the <kbd>AddModifier</kbd> function to change the <kbd>Hp</kbd> field of <kbd>GameUnitAttributeSet</kbd>, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">  // Command the addition of +5 HP to the hpProperty<br/>  AddModifier(RecoverHP, hpProperty, EGameplayModOp::Additive, FScalableFloat(50.f));</pre>
<ol start="5">
<li>Fill in the other properties of <kbd>GameplayEffect</kbd>, including fields such as <kbd>DurationPolicy</kbd> and <kbd>ChanceToApplyToTarget</kbd>, or any other fields that you'd like to modify, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">// .. for a fixed-duration of 10 seconds ..<br/>RecoverHP-&gt;DurationPolicy = EGameplayEffectDurationType::HasDuration;<br/>RecoverHP-&gt;DurationMagnitude = FScalableFloat(10.f);<br/><br/>// .. with 100% chance of success ..<br/>RecoverHP-&gt;ChanceToApplyToTarget = 1.f;<br/><br/>// .. with recurrency (Period) of 0.5 seconds<br/>RecoverHP-&gt;Period = 0.5f;</pre>
<ol start="6">
<li>Apply the effect to an <kbd>AbilitySystemComponent</kbd> of your choice. The underlying <kbd>UAttributeSet</kbd> will be affected and modified by your call, as shown in the following piece of code:</li>
</ol>
<pre style="color: black;padding-left: 60px">FActiveGameplayEffectHandle recoverHpEffectHandle =<br/>    AbilitySystemComponent-&gt;ApplyGameplayEffectToTarget(<br/>        RecoverHP, AbilitySystemComponent, 1.f);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black"><kbd>GameplayEffects</kbd> are simply little objects that effect changes to an actor's <kbd>AttributeSet</kbd>. <kbd>GameplayEffects</kbd> can occur once, or repeatedly, in intervals over a <kbd>Period</kbd>. You can program-in effects pretty quickly, and the <kbd>GameplayEffect</kbd> class creation is intended to be inline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p style="color: black">Once the <kbd>GameplayEffect</kbd> is active, you will receive an <kbd>FActiveGameplayEffectHandle</kbd>. You can use this handle to attach a function delegate to run when the effect is over using the <kbd>OnRemovedDelegate</kbd> member of the <kbd>FActiveGameplayEffectHandle</kbd>. For example, you might call the following code:</p>
<pre style="color: black">FOnActiveGameplayEffectRemoved* ep = AbilitySystemComponent-&gt;<br/>    OnGameplayEffectRemovedDelegate(recoverHpEffectHandle);<br/><br/>if (ep) <br/>{<br/>    ep-&gt;AddLambda([]() <br/>    {<br/>        UE_LOG(LogTemp, Warning, TEXT("Recover effect has been removed."), 1);<br/>    });<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GameplayTasks API – making things happen with GameplayTasks</h1>
                </header>
            
            <article>
                
<p style="color: black"><kbd>GameplayTasks</kbd> are used to wrap up some gameplay functionality in a reusable object. All you have to do to use them is derive from the <kbd>UGameplayTask</kbd> base class and override some of the member functions that you prefer to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black"><span>If you have not done so already, complete Steps 1-4 of the</span> <em>GameplayAbilities API – triggering an actor's gameplay abilities with game controls</em> <span>recipe to link to the </span><kbd>GameplayTasks</kbd><span> API in your </span><kbd>ProjectName.Build.cs</kbd><span> file and enable its functionality.</span></p>
<p style="color: black">Afterwards, go in the UE4 Editor and navigate to <span class="packt_screen">Class Viewer</span> by going to <span class="packt_screen">Window | Developer Tools | Class Viewer</span>. Under <span class="packt_screen">Filters</span>, uncheck the <span class="packt_screen">Actors Only</span> and <span class="packt_screen">Placeable Only</span> options.</p>
<p style="color: black">Ensure that the <kbd>GameplayTask</kbd> object type exists:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3294cedd-2012-4aee-b372-41fee61f3347.png" style="width:40.75em;height:37.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Click on <span class="packt_screen">File</span> | <span class="packt_screen">Add C++ Class...</span>. Choose to derive from <kbd>GameplayTask</kbd>. To do so, you must first tick <span class="packt_screen">Show All Classes</span>, and then type <kbd>gameplaytask</kbd> into the filter box. Click on <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bcf5cdab-33de-40f8-82db-fc30adcbe46e.png" style="width:48.00em;height:29.00em;"/></p>
<ol start="2">
<li>Name your C++ class (something like <kbd>GameplayTask_TaskName</kbd> is the convention), then add the class to your project. The example spawns a particle emitter and is called <kbd>GameplayTask_CreateParticles</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bbd3d5ad-3e83-46d0-abcb-5096ca481530.png"/></p>
<ol start="3">
<li>Once your <kbd>GameplayTask_CreateParticles.h</kbd> and <kbd>.cpp</kbd> pair are created, navigate to the <kbd>.h</kbd> file and update the class to the following:</li>
</ol>
<pre style="color: black;padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameplayTask.h"<br/><strong>#include "Particles/ParticleSystem.h"</strong><br/>#include "GameplayTask_CreateParticles.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_11_API UGameplayTask_CreateParticles : public UGameplayTask<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    virtual void Activate();</strong><br/><br/><strong>    // A static constructor for an instance of a <br/>    // UGameplayTask_CreateEmitter instance,</strong><br/><strong>    // including args of (what class of emitter, where to <br/>    // create it).</strong><br/><strong>    UFUNCTION(BlueprintCallable, Category = "GameplayTasks", meta = (AdvancedDisplay = "TaskOwner", DefaultToSelf = "TaskOwner", BlueprintInternalUseOnly = "TRUE"))</strong><br/><strong>        static UGameplayTask_CreateParticles* ConstructTask(</strong><br/><strong>            TScriptInterface&lt;IGameplayTaskOwnerInterface&gt; TaskOwner,</strong><br/><strong>            UParticleSystem* particleSystem,</strong><br/><strong>            FVector location);</strong><br/><br/><strong>    UParticleSystem* ParticleSystem;</strong><br/><strong>    FVector Location;</strong><br/><br/>};</pre>
<ol start="4">
<li>Then, implement the <kbd>GameplayTask_CreateParticles.cpp</kbd> file, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">#include "GameplayTask_CreateParticles.h"<br/><strong>#include "Kismet/GameplayStatics.h"</strong><br/><br/><strong>// Like a constructor.</strong><br/><strong>UGameplayTask_CreateParticles* UGameplayTask_CreateParticles::ConstructTask(</strong><br/><strong>    TScriptInterface&lt;IGameplayTaskOwnerInterface&gt; TaskOwner,</strong><br/><strong>    UParticleSystem* particleSystem,</strong><br/><strong>    FVector location)</strong><br/><strong>{</strong><br/><strong>    UGameplayTask_CreateParticles* task = <br/>    NewTask&lt;UGameplayTask_CreateParticles&gt;(TaskOwner);</strong><br/><strong>    // Fill fields</strong><br/><strong>    if (task)</strong><br/><strong>    {</strong><br/><strong>        task-&gt;ParticleSystem = particleSystem;</strong><br/><strong>        task-&gt;Location = location;</strong><br/><strong>    }</strong><br/><strong>    return task;</strong><br/><strong>}</strong><br/><br/><strong>void UGameplayTask_CreateParticles::Activate()</strong><br/><strong>{</strong><br/><strong>    Super::Activate();</strong><br/><br/><strong>    UGameplayStatics::SpawnEmitterAtLocation(GetWorld(),<br/>    ParticleSystem, Location);</strong><br/><strong>}</strong></pre>
<ol start="5">
<li>Open up your <kbd>Warrior.h</kbd> file and add the following interface to the class definition:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_11_API AWarrior : public ACharacter, public IAbilitySystemInterface<strong>, public IGameplayTaskOwnerInterface</strong><br/>{<br/>    GENERATED_BODY()</pre>
<ol start="6">
<li>Afterwards, add the following new properties to it:</li>
</ol>
<pre>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>    UGameplayTasksComponent* GameplayTasksComponent;<br/><br/>    // This is the particleSystem that we create with the<br/>    // GameplayTask_CreateParticles object.<br/>    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>    UParticleSystem* particleSystem;</pre>
<ol start="7">
<li>Below that, add the following function definitions for the <kbd>GameplayTaskOwnerInterface</kbd>:</li>
</ol>
<pre>    // &lt;GameplayTaskOwnerInterface&gt;<br/><br/>    virtual UGameplayTasksComponent* GetGameplayTasksComponent(const <br/>    UGameplayTask&amp; Task) const { return GameplayTasksComponent; }<br/><br/>    // This gets called both when task starts and when task gets <br/>    // resumed.<br/>    // Check Task.GetStatus() if you want to differentiate.<br/>    virtual void OnTaskActivated(UGameplayTask&amp; Task) { }<br/>    virtual void OnTaskDeactivated(UGameplayTask&amp; Task) { }<br/><br/>    virtual AActor* GetOwnerActor(const UGameplayTask* Task) const {<br/>        return Task-&gt;GetOwnerActor(); // This will give us the <br/>    // accurate answer for the Task..<br/>    }<br/>    // &lt;/End GameplayTaskOwnerInterface&gt;</pre>
<ol start="8">
<li>Afterwards, go to the <kbd>Warrior.cpp</kbd> file and update the class constructor to the following:</li>
</ol>
<pre style="padding-left: 60px">AWarrior::AWarrior()<br/>{<br/>    // Set this character to call Tick() every frame. You can <br/>    // turn this off to improve performance if you don't need <br/>    // it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/>    AbilitySystemComponent = CreateDefaultSubobject&lt;UAbilitySystemComponent&gt;<br/>    ("UAbilitySystemComponent");<br/>    GameplayTasksComponent = CreateDefaultSubobject&lt;UGameplayTasksComponent&gt;<br/>    ("UGameplayTasksComponent");<br/>}</pre>
<ol start="9">
<li>Save your scripts, return to the Unreal Editor, and compile your code. Once compiled, open your <kbd>Actor</kbd> class derivative (<kbd>MyWarrior</kbd>) and then scroll down to the <span class="packt_screen">Stats</span> section and set the <span class="packt_screen">Particle System</span> property to something you'd like to see, for instance, the <kbd>P_Fire</kbd> option if you included the sample content when you created your project:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e2540cdb-18c9-4567-9772-0bff4c83ab28.png" style="width:37.58em;height:38.58em;"/></p>
<ol start="10">
<li>Which is available in the <span class="packt_screen">Full Blueprint Editor</span> in the <span class="packt_screen">Components</span> drop-down of the <span class="packt_screen">Components</span> tab in the Blueprint editor. <span>Add </span><kbd>GameplayTasksComponent</kbd><span> to</span></li>
<li>Create and add an instance of your <kbd>GameplayTask</kbd> inside your <kbd>Actor</kbd> derivative (<kbd>MyWarrior</kbd>) instance using the following code:</li>
</ol>
<pre style="color: black">    UGameplayTask_CreateParticles* task =<br/>        UGameplayTask_CreateParticles::ConstructTask(this,<br/>        particleSystem, FVector(200.f, 0.f, 200.f));<br/>            <br/><br/>    if (GameplayTasksComponent &amp;&amp; task)<br/>    {<br/>        GameplayTasksComponent-&gt;AddTaskReadyForActivation(*task);<br/>    }</pre>
<p style="padding-left: 60px">This code runs anywhere in your <kbd>Actor</kbd> class derivative, any time after <kbd>GameplayTasksComponent</kbd> is initialized (any time after <kbd>PostInitializeComponents()</kbd>).</p>
<ol start="12">
<li>Compile your code. Set your level to use <kbd>MyWarrior</kbd> as the <span class="packt_screen">Default Pawn Type</span> and when the game starts, you should notice that the particle plays:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d976d754-77a1-43dd-9906-1e21151058ec.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black"><kbd>GameplayTasks</kbd> simply register with the <kbd>GameplayTasksComponent</kbd> situated inside an <kbd>Actor</kbd> class derivative of your choice. You can activate any number of <kbd>GameplayTasks</kbd> at any time during gameplay to trigger their effects.</p>
<p style="color: black"><kbd>GameplayTasks</kbd> can also kick off <kbd>GameplayEffects</kbd> to change attributes of <kbd>AbilitySystemsComponents</kbd> if you wish.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p style="color: black">You can derive <kbd>GameplayTasks</kbd> for any number of events in your game. What's more is that you can override a few more virtual functions to hook into additional functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP API – downloading webpages using web requests</h1>
                </header>
            
            <article>
                
<p style="color: black">When you're maintaining scoreboards or other such things that require regular HTTP request access to servers, you can use the HTTP API to perform such web request tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black">Have a server that you're allowed to request data via HTTP from. You can use a public server of any type to try out HTTP requests, if you'd like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Link to the <kbd>HTTP</kbd> API in your <kbd>ProjectName.Build.cs</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_11 : ModuleRules<br/>{<br/>    public Chapter_11(ReadOnlyTargetRules Target) : base(Target)<br/>    {<br/>        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/>    <br/>        PublicDependencyModuleNames.AddRange(new string[] {<br/>        "Core", "CoreUObject", "Engine", "InputCore" });<br/>        PublicDependencyModuleNames.AddRange(new string[] { <br/>        "GameplayAbilities", "GameplayTags", "GameplayTasks" });<br/><strong>        PublicDependencyModuleNames.AddRange(new string[] {<br/>        "HTTP" });</strong><br/><br/>        PrivateDependencyModuleNames.AddRange(new string[] { });<br/><br/>        // Uncomment if you are using Slate UI<br/>        // PrivateDependencyModuleNames.AddRange(new string[]<br/>        // { "Slate", "SlateCore" });<br/>        <br/>        // Uncomment if you are using online features<br/>        // PrivateDependencyModuleNames.Add("OnlineSubsystem");<br/><br/>        // To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true<br/>    }<br/>}</pre>
<ol start="2">
<li>In the file that you will send your web request from (in my case, I'll be using the <kbd>Chapter_11GameModeBase</kbd> class), include the new additions to the following code snippet:</li>
</ol>
<pre style="color: black;padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "Runtime/Online/HTTP/Public/HttpManager.h" </strong><br/><strong>#include "Runtime/Online/HTTP/Public/HttpModule.h" </strong><br/><strong>#include "Runtime/Online/HTTP/Public/HttpRetrySystem.h"</strong> <br/><strong>#include "Runtime/Online/HTTP/Public/Interfaces/IHttpResponse.h"</strong><br/><strong>using namespace FHttpRetrySystem;</strong><br/>#include "Chapter_11GameModeBase.generated.h"</pre>
<ol start="3">
<li>Construct an <kbd>IHttpRequest</kbd> object from <kbd>FHttpModule</kbd> using the following code:</li>
</ol>
<pre style="color: black">TSharedRef&lt;IHttpRequest&gt; <br/> http=FHttpModule::Get().CreateRequest();</pre>
<div class="mce-root packt_tip"><kbd>FHttpModule</kbd> <span>is a singleton object. One copy of it exists for the entire program that you are meant to use for all interactions with the</span> <kbd>FHttpModule</kbd> <span>class.</span></div>
<ol start="4">
<li>Attach your function to run to the <kbd>IHttpRequest</kbd> object's <kbd>FHttpRequestCompleteDelegate</kbd>, which has the following signature:</li>
</ol>
<pre style="color: black;padding-left: 60px">void HttpRequestComplete( FHttpRequestPtr request,<br/> FHttpResponsePtr response, bool success );</pre>
<ol start="5">
<li>The delegate is found inside of the <kbd>IHttpRequest</kbd> object as <kbd>http-&gt;OnProcessRequestComplete()</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">FHttpRequestCompleteDelegate&amp; delegate = http-<br/> &gt;OnProcessRequestComplete();</pre>
<p style="padding-left: 60px">There are a few ways to attach a callback function to the delegate. You can use the following methods:</p>
<ul>
<li style="padding-left: 30px">A lambda using <kbd>delegate.BindLambda()</kbd>:</li>
</ul>
<pre style="color: black;padding-left: 60px">delegate.BindLambda( 
  // Anonymous, inlined code function (aka lambda) 
  []( FHttpRequestPtr request, FHttpResponsePtr response, bool <br/>   success ) -&gt; void 
{ 
  UE_LOG( LogTemp, Warning, TEXT( "Http Response: %d, %s" ), 
  request-&gt;GetResponse()-&gt;GetResponseCode(), 
  *request-&gt;GetResponse()-&gt;GetContentAsString() ); 
}); </pre>
<ol start="6">
<li>Specify the URL of the site you'd like to hit:</li>
</ol>
<pre style="color: black;padding-left: 60px">http-&gt;SetURL( TEXT( "http://unrealengine.com" ) ); </pre>
<ol start="7">
<li>Process the request by calling <kbd>ProcessRequest</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">http-&gt;ProcessRequest();</pre>
<p>Then, when you run this code, you should notice the contents of the URL you pointed to being displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b5de988c-e6c7-4509-a9af-9ff2c3a41881.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">HTML content of unrealengine.com displayed</div>
<p>Of course, in this instance, it's a web page, but you can easily point this to a CSV file, text document, or anything to obtain information for your project!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black">The HTTP object is all you need to send off HTTP requests to a server and get HTTP responses. You can use the HTTP request/response for anything that you wish; for example, submitting scores to a high scores table or to retrieve text to display in-game from a server.</p>
<p style="color: black">They are decked out with a URL to visit and a function callback to run when the request is complete. Finally, they are sent off via <kbd>FManager</kbd>. When the web server responds, your callback is called and the results of your HTTP response can be shown.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are also other ways in which you can attach a callback function to the delegate:</p>
<ul>
<li>Using any UObject's member function:</li>
</ul>
<pre style="color: black;padding-left: 60px">delegate.BindUObject(this, &amp;AChapter_11GameModeBase::HttpRequestComplete);</pre>
<div class="mce-root packt_tip"><span>You cannot attach to</span><span> </span><kbd>UFunction</kbd><span> </span><span>directly here as the</span><span> </span><kbd>.BindUFunction()</kbd><span> </span><span>command requests arguments that are all</span><span> </span><kbd>UCLASS</kbd><span>,</span><span> </span><kbd>USTRUCT</kbd><span>, </span><span>or</span><span> </span><kbd>UENUM</kbd><span>.</span></div>
<ul>
<li>With any plain old C++ object's member function, using<span> </span><kbd>.BindRaw</kbd>:</li>
</ul>
<pre class="mce-root" style="padding-left: 60px"><span>PlainObject* plainObject = new PlainObject();<br/></span>delegate.BindRaw( plainObject, &amp;PlainObject::httpHandler );<br/> // plainObject cannot be DELETED Until httpHandler gets<br/> // called..</pre>
<div class="mce-root packt_tip"><span>You have to ensure that your</span><span> </span><kbd>plainObject</kbd><span> </span><span>refers to a valid object in memory at the time that the HTTP request completes. This means that you cannot use</span><span> </span><kbd>TAutoPtr</kbd><span> </span><span>on</span><span> </span><kbd>plainObject</kbd><span>, because that will deallocate</span><span> </span><kbd>plainObject</kbd><span> </span><span>at the end of the block in which it is declared, but that may be before the HTTP request completes.</span></div>
<ul>
<li>Using a global C-style static function:</li>
</ul>
<pre style="color: black;padding-left: 60px">// C-style function for handling the HTTP response: 
void httpHandler( FHttpRequestPtr request,  
FHttpResponsePtr response, bool success ) 
{ 
  Info( "static: Http req handled" ); 
} 
delegate.BindStatic( &amp;httpHandler ); </pre>
<p><span>When using a delegate callback with an object, be sure that the object instance that you're calling back on lives on at least until the point at which the</span><span> </span><kbd>HttpResponse</kbd><span> </span><span>arrives back from the server. Processing the</span><span> </span><kbd>HttpRequest</kbd><span> </span><span>takes real time to run. It is a web request after all—think of waiting for a web page to load.</span></p>
<p>You have to be sure that the object instance on which you're calling the callback function has not deallocated on you between the time of the initial call and the invocation of your<span> </span><kbd>HttpHandler</kbd><span> </span>function. The object must still be in memory when the callback returns after the HTTP request completes.</p>
<p>You cannot simply expect that the<span> </span><kbd>HttpResponse</kbd><span> </span>function happens immediately after you attach the callback function and call<span> </span><kbd>ProcessRequest()</kbd>! Using a reference counted<span> </span><kbd>UObject</kbd><span> </span>instance to attach the<span> </span><kbd>HttpHandler</kbd><span> </span>member function is a good idea to ensure that the object stays in memory until the HTTP request completes.</p>
<p>You can see an example of all seven possible ways it can be used inside of the <kbd>Chapter_11GameModeBase.cpp</kbd> file in the Example Code for this chapter.</p>
<p style="color: black">You can set additional HTTP request parameters via the following member functions:</p>
<ul>
<li><kbd>SetVerb()</kbd>, to change whether you are using the <kbd>GET</kbd> or <kbd>POST</kbd> method in your HTTP request</li>
<li><kbd>SetHeaders()</kbd>, to modify any general header settings you would like</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP API – displaying downloaded progress </h1>
                </header>
            
            <article>
                
<p style="color: black">The <kbd>IHttpRequest</kbd> object from the HTTP API will report HTTP download progress via a callback on a <kbd>FHttpRequestProgressDelegate</kbd>, which is accessible via <kbd>OnRequestProgress()</kbd>. The signature of the function we can attach to the <kbd>OnRequestProgress()</kbd> delegate is as follows:</p>
<pre style="color: black">HandleRequestProgress( FHttpRequestPtr request, int32 <br/> sentBytes, int32 receivedBytes )</pre>
<p style="color: black">The three parameters of the function you may write include the original <kbd>IHttpRequest</kbd> object, the bytes sent, and the bytes received so far. This function gets called back periodically until the <kbd>IHttpRequest</kbd> object completes, which is when the function you attach to <kbd>OnProcessRequestComplete()</kbd> when it gets called. You can use the values passed to your <kbd>HandleRequestProgress</kbd> function to find out your progress.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="color: black">You will need an internet connection to use this recipe. We will be requesting a file from a public server. You can use a public server or your own private server for your HTTP request, if you'd like.</p>
<p style="color: black">In this recipe, we will bind a callback function to just the <kbd>OnRequestProgress()</kbd> delegate to display the download progress of a file from a server. Have a project ready where we can write a piece of code that will perform <kbd>IHttpRequest,</kbd> and a nice interface on which to display percentage progress.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Link to the <kbd>HTTP</kbd> API in your <kbd>ProjectName.Build.cs</kbd> file.</li>
<li>Construct an <kbd>IHttpRequest</kbd> object using the following code:</li>
</ol>
<pre style="color: black;padding-left: 60px">TSharedRef&lt;IHttpRequest&gt; http = <br/> HttpModule::Get().CreateRequest();</pre>
<ol start="3">
<li>Provide a callback function to call when the request progresses, which updates our user:</li>
</ol>
<pre style="color: black;padding-left: 60px">http-&gt;OnRequestProgress().BindLambda(<br/>    [this](FHttpRequestPtr request, int32 sentBytes, int32<br/>    receivedBytes)<br/>    -&gt; void<br/>    {<br/>        int32 contentLen =<br/>        request-&gt;GetResponse()-&gt;GetContentLength();<br/>        float percentComplete = 100.f * receivedBytes /<br/>        contentLen;<br/><br/>        UE_LOG(LogTemp, Warning, TEXT("Progress sent=%d bytes /<br/>        received=%d/%d bytes [%.0f%%]"), sentBytes, receivedBytes,<br/>        contentLen, percentComplete);<br/><br/>    });</pre>
<ol start="4">
<li>Process your request with <kbd>http-&gt;ProcessRequest()</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p style="color: black">The <kbd>OnRequestProgress()</kbd> callback gets fired every so often with the bytes sent and bytes received HTTP progress. We will compute the total percentage of the download that is completed by calculating <kbd>(float)receivedBytes/totalLen</kbd>, where <kbd>totalLen</kbd> is the HTTP response's total length in bytes. Using the lambda function we attached to the <kbd>OnRequestProgress()</kbd> delegate callback, we can display the information through text.</p>
<div class="packt_infobox" style="color: black">With the code in the previous <em>How to do it...</em> section as a base, it would be possible to create a UMG widget for a progress bar and call the <kbd>.SetPercent()</kbd> member function to reflect the download's progress.</div>


            </article>

            
        </section>
    </body></html>