- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are a fundamental concept in programming; regardless of what topic
    we are discussing, we will end up talking about functions. Trying to cover everything
    about functions in a single chapter is not only hard but also not very rational.
    Being a fundamental element of the language, functions are encountered in every
    recipe in this book. This chapter, however, covers modern language features related
    to functions and callable objects, with a focus on lambda expressions, concepts
    from functional languages such as higher-order functions, and function templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defaulted and deleted functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas with standard algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic and template lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a function template with a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fold expressions to simplify variadic function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the higher-order functions `map` and `fold`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions into a higher-order function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniformly invoking anything callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start this chapter by learning about a feature that makes it easier
    for us to provide special class member functions or prevent any function (member
    or non-member) from being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Defaulted and deleted functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, classes have special members (constructors, a destructor, and assignment
    operators) that may be either implemented by default by the compiler or supplied
    by the developer. However, the rules for what can be default implemented are a
    bit complicated and can lead to problems. On the other hand, developers sometimes
    want to prevent objects from being copied, moved, or constructed in a particular
    way.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible by implementing different tricks using these special members.
    The C++11 standard has simplified many of these by allowing functions to be deleted
    or defaulted in the manner we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to be familiar with the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Special member functions (default constructor, destructor, copy constructor,
    move constructor, copy assignment operator, and move assignment operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The copyable concept (a class features a copy constructor and copy assignment
    operator, making it possible to create copies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The movable concept (a class features a move constructor and a move assignment
    operator, making it possible to move objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, let’s learn how to define default and deleted special functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following syntax to specify how functions should be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To default a function, use `=default` instead of the function body. Only special
    class member functions for which the compiler can provide default implementations
    can be defaulted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To delete a function, use `=delete` instead of the function body. Any function,
    including non-member functions, can be deleted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use defaulted and deleted functions to achieve various design goals, such as
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a class that is not copyable and implicitly not movable, declare
    the copy constructor and the copy assignment operator as deleted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement a class that is not copyable but is movable, declare the copy
    operations as deleted and explicitly implement the move operations (and provide
    any additional constructors that are needed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure a function is called only with objects of a specific type, and perhaps
    prevent type promotion, provide deleted overloads for the function (the following
    example with free functions can also be applied to any class member functions):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class has several special members that can be implemented, by default, by
    the compiler. These are the default constructor, copy constructor, move constructor,
    copy assignment, move assignment, and destructor (for a discussion on move semantics,
    refer to the *Implementing move semantics* recipe in *Chapter 9*, *Robustness
    and Performance*). If you don’t implement them, then the compiler does it so that,
    if needed, instances of a class can be created, moved, copied, and destructed.
    However, if you explicitly provide one or more of these special methods, then
    the compiler will not generate the others according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a user-defined constructor exists, the default constructor is not generated
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined virtual destructor exists, the default destructor is not generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined move constructor or move assignment operator exists, then
    the copy constructor and copy assignment operator are not generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy constructor, move constructor, copy assignment operator,
    move assignment operator, or destructor exists, then the move constructor and
    move assignment operator are not generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy constructor or destructor exists, then the copy assignment
    operator is generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy assignment operator or destructor exists, then the copy
    constructor is generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the last two rules in the preceding list are deprecated rules and
    may no longer be supported by your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, developers need to provide empty implementations of these special
    members or hide them in order to prevent the instances of the class from being
    constructed in a specific manner. A typical example is a class that is not supposed
    to be copyable. The classical pattern for this is to provide a default constructor
    and hide the copy constructor and copy assignment operators. While this works,
    the explicitly defined default constructor ensures the class is no longer considered
    trivial and, therefore, a **Plain Old Data** (**POD**) type. The modern alternative
    to this is using a deleted function, as shown in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler encounters `=default` in the definition of a function, it
    will provide the default implementation. The rules for special member functions
    mentioned earlier still apply. Functions can be declared `=default` outside the
    body of a class if and only if they are inlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The defaulted implementations have several benefits, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Can be more efficient than the explicit ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-defaulted implementations, even if they are empty, are considered non-trivial,
    and that affects the semantics of the type, which becomes non-trivial (and, therefore,
    non-POD).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps the user not write explicit default implementations. For instance, if
    a user-defined move constructor is present, then the copy constructor and the
    copy assignment operator are not provided by default by the compiler. However,
    you can still default explicitly and ask the compiler to provide them so that
    you don’t have to do it manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the compiler encounters `=delete` in the definition of a function, it
    will prevent the calling of the function. However, the function is still considered
    during overload resolution, and only if the deleted function is the best match
    does the compiler generate an error. For example, by giving the previously defined
    overloads for the `run()` function, only calls with long integers are possible.
    Calls with arguments of any other type (including `int`, for which an automatic
    type promotion to `long` exists) will determine a deleted overload to be considered
    the best match and, therefore, the compiler will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that previously declared functions cannot be deleted as the `=delete`
    definition must be the first declaration in a translation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rule of thumb (also known as the *Rule of Five*) for class special member
    functions is that if you explicitly define any copy constructor, move constructor,
    copy assignment operator, move assignment operator, or destructor, then you must
    either explicitly define or default all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The user-defined destructor, copy-constructor, and copy assignment operator
    are necessary because objects are constructed from copies in various situations
    (like passing parameters to functions). If they are not user-defined, they are
    provided by the compiler, but their default implementation may be wrong. If the
    class manages resources, then the default implementation does a shallow copy,
    meaning that it copies the value of the handle of the resource (such as a pointer
    to an object) and not the resource itself. In such cases, a user-defined implementation
    must do a deep copy that copies the resource, not the handle to it. The presence
    of the move constructor and move assignment operator are desirable in this case
    because they represent a performance improvement. Lacking these two is not an
    error but a missed optimization opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: Opposed to the Rule of Five on the one hand but complementing it on the other
    is the so-called *Rule of Zero*. This rule states that unless a class deals with
    ownership of resources, it should have no custom destructors, copy and move constructors,
    and, respectively, copy and move assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing classes, you should follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: A class that manages a resource should have the single responsibility of handling
    the ownership of that resource. Such a class must follow the Rule of Five and
    implement a custom destructor, copy/move constructors, and copy/move assignment
    operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that doesn’t manage resources should not have a custom destructor, copy/move
    constructors, and copy/move assignment operators (therefore following the Rule
    of Zero).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Uniformly invoking anything callable*, to learn how to use `std::invoke()`
    to invoke any callable object with the provided arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas with standard algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important modern features of C++ is lambda expressions, also
    referred to as lambda functions or simply lambdas. Lambda expressions enable us
    to define anonymous function objects that can capture variables in the scope and
    be invoked or passed as arguments to functions. They avoid having to define named
    functions or function objects. Lambdas are useful for many purposes, and in this
    recipe, we will learn how to use them with standard algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll discuss standard algorithms that take an argument that’s
    a function or predicate that’s applied to the elements it iterates through. You
    need to know what unary and binary functions are and what predicates and comparison
    functions are. You also need to be familiar with function objects because lambda
    expressions are syntactic sugar for function objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should prefer to use lambda expressions to pass callbacks to standard algorithms
    instead of functions or function objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define anonymous lambda expressions in the place of the call if you only need
    to use the lambda in a single place:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a named lambda, that is, one assigned to a variable (usually with the
    `auto` specifier for the type), if you need to call the lambda in multiple places:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use generic lambda expressions if you need lambdas that only differ in terms
    of their argument types (available since C++14):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The non-generic lambda expression shown in the second bullet takes a constant
    integer and returns `true` if it is greater than `0`, or `false` otherwise. The
    compiler defines an unnamed function object with the call operator, which has
    the signature of the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The way the unnamed function object is defined by the compiler depends on the
    way we define the lambda expression that can capture variables, use the `mutable`
    specifier or exception specifications, or have a trailing return type. The `__lambda_name__`
    function object shown earlier is actually a simplification of what the compiler
    generates because it also defines a default copy and move constructor, a default
    destructor, and a deleted assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: It must be well understood that the lambda expression is actually a class. In
    order to call it, the compiler needs to instantiate an object of the class. The
    object instantiated from a lambda expression is called a *lambda closure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we want to count the number of elements in a range
    that are greater than or equal to 5 and less than or equal to 10\. The lambda
    expression, in this case, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This lambda captures two variables, `minimum` and `maximum`, by copy (that
    is, value). The resulting unnamed function object created by the compiler looks
    very much like the one we defined earlier. With the default and deleted special
    members mentioned earlier, the class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The lambda expression can capture variables by copy (or value) or by reference,
    and different combinations of the two are possible. However, it is not possible
    to capture a variable multiple times and it is only possible to have `&` or `=`
    at the beginning of the capture list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression can access the following kinds of variables: variables
    captured from the enclosing scope, lambda parameters, variables declared locally
    within its body, class data members when the lambda is declared inside a class
    and the pointer is captured by the lambda, and any variable with static storage
    duration such as global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: A lambda can only capture variables from an enclosing function scope. It cannot
    capture variables with static storage duration (that is, variables declared in
    a namespace scope or with the `static` or `external` specifier).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows various combinations for lambda capture semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lambda** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[](){}` | Does not capture anything. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&](){}` | Captures everything by reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `[=](){}` | Captures everything by copy. Implicit capturing of the pointer
    `this` is deprecated in C++20. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&x](){}` | Captures only `x` by reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `[x](){}` | Captures only `x` by copy. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&x...](){}` | Captures pack extension `x` by reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `[x...](){}` | Captures pack extension `x` by copy. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, x](){}` | Captures everything by reference except for `x` that is captured
    by copy. |'
  prefs: []
  type: TYPE_TB
- en: '| `[=, &x](){}` | Captures everything by copy except for `x` that is captured
    by reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, this](){}` | Captures everything by reference except for the pointer
    `this`, which is captured by copy (`this` is always captured by copy). |'
  prefs: []
  type: TYPE_TB
- en: '| `[x, x](){}` | Error; `x` is captured twice. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, &x](){}` | Error; everything is captured by reference, and we cannot
    specify again to capture `x` by reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `[=, =x](){}` | Error; everything is captured by copy, and we cannot specify
    again to capture `x` by copy. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&this](){}` | Error; the pointer `this` is always captured by copy. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, =](){}` | Error; cannot capture everything both by copy and by reference.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[x=expr](){}` | `x` is a data member of the lambda’s closure initialized
    from the expression `expr`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[&x=expr](){}` | `x` is a reference data member of the lambda’s closure
    initialized from the expression `expr`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Examples of lambda captures with explanations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general form of a lambda expression, as of C++17, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All parts shown in this syntax are actually optional except for the capture
    list, which can, however, be empty, and the body, which can also be empty. The
    parameter list can actually be omitted if no parameters are needed. The return
    type does not need to be specified as the compiler can infer it from the type
    of the returned expression. The `mutable` specifier (which tells the compiler
    the lambda can actually modify variables captured by copy, which is not the same
    as capturing by value because the changes are only observed within the lambda),
    the `constexpr` specifier (which tells the compiler to generate a `constexpr`
    call operator), and the exception specifiers and attributes are all optional.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest possible lambda expression is `[]{}`, though it is often written
    as `[](){}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter two examples in the preceding table are forms of generalized lambda
    captures. These were introduced in C++14 to allow us to capture variables with
    move-only semantics, but they can also be used to define new arbitrary objects
    in the lambda. The following example shows how variables can be captured by `move`
    with generalized lambda captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambdas that are written in class methods and need to capture class data members
    can do so in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Capturing individual data members with the form `[x=expr]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Capturing the entire object with the form `[=]` (please note that the implicit
    capture of pointer `this` via `[=]` is deprecated in C++20):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Capturing the entire object by capturing the `this` pointer. This is necessary
    if you need to invoke other methods of the class. This can be captured either
    as `[this]` when the pointer is captured by value, or `[*this]` when the object
    itself is captured by value. This can make a big difference if the object may
    go out of scope after the capture occurs but before the lambda is invoked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this latter case, the correct capture should be `[*this]` so that the object
    is copied by value. In this case, invoking the lambda will print *42 john*, even
    though the temporary has gone out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++20 standard introduces several changes to capturing the pointer `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: It deprecates the implicit capturing of `this` when you use `[=]`. This will
    produce a deprecation warning to be issued by the compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It introduces explicit capturing of the `this` pointer by value when you want
    to capture everything with `[=, this]`. You can still only capture the pointer
    `this` with a `[this]` capture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are cases where lambda expressions only differ in terms of their arguments.
    In this case, the lambdas can be written in a generic way, just like templates,
    but using the `auto` specifier for the type parameters (no template syntax is
    involved). This is addressed in the next recipe, as noted in the upcoming *See
    also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Before C++23, attributes could be specified on a lambda expression between the
    optional exception specifier and the optional trailing return type. Such attributes
    would apply to the type, not the function call operator. However, attributes such
    as `[[nodiscard]]` or `[[noreturn]]` would only make sense on a function, not
    a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, as of C++23, this restriction has changed so that attributes can
    also be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: after the lambda introducer and its optional capture, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: after the template parameter list and its optional requires clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes declared in any of these parts of a lambda declaration apply
    to the function call operator and not the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[[deprecated]]` attribute applies to the type of the lambda and no warning
    is produced when compiling the snippet. In C++23, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, both the `[[nodiscard]]` and `[[deprecated]]` attributes
    apply to the function call operator of the lambda type. This results in two warnings
    being issued: one that a deprecated function is being used, and one that the return
    type is being ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using generic and template lambdas*, to learn how to use `auto` for lambda
    parameters and how to define template lambdas in C++20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a recursive lambda*, to understand the technique we can use to make
    a lambda call itself recursively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Providing metadata to the compiler with attributes*, to learn
    about available standard attributes and how to use them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic and template lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw how to write lambda expressions and use them
    with standard algorithms. In C++, lambdas are basically syntactic sugar for unnamed
    function objects, which are classes that implement the call operator. However,
    just like any other function, this can be implemented generically with templates.
    C++14 takes advantage of this and introduces generic lambdas that do not need
    to specify actual types for their parameters and use the `auto` specifier instead.
    Though not referred to by this name, generic lambdas are basically lambda templates.
    They are useful in cases where we want to use the same lambda but with different
    types of parameters. Moreover, the C++20 standard takes this a step further and
    supports explicitly defining template lambdas. This helps with some scenarios
    where generic lambdas are cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is recommended that you read the preceding recipe, *Using lambdas with standard
    algorithms*, before you continue with this one to familiarize yourself with the
    fundamentals of lambdas in C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since C++14, we can write generic lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `auto` specifier instead of actual types for lambda expression
    parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to use multiple lambdas that only differ by their parameter types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows a generic lambda used with the `std::accumulate()`
    algorithm, first with a vector of integers and then with a vector of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since C++20, we can write template lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: By using a template parameter list in angle brackets (such as `<template T>`)
    after the capture clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you want to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict the use of a generic lambda with only some types, such as a container,
    or types that satisfy a concept.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that two or more arguments of a generic lambda actually do have the
    same type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the type of a generic parameter so that, for example, we can create
    instances of it, invoke static methods, or use its iterator types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform perfect forwarding in a generic lambda.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows a template lambda that can be invoked only using
    an `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first example from the previous section, we defined a named lambda expression—that
    is, a lambda expression that has its closure assigned to a variable. This variable
    is then passed as an argument to the `std::accumulate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This general algorithm takes the beginning and the ending iterators, which define
    a range, an initial value to accumulate over, and a function that is supposed
    to accumulate each value in the range to the total. This function takes a first
    parameter representing the currently accumulated value and a second parameter
    representing the current value to accumulate to the total, and it returns the
    new accumulated value. Note that I did not use the term `add` because this can
    be used for more things than just adding. It can also be used for calculating
    a product, concatenating, or other operations that aggregate values together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two calls to `std::accumulate()` in this example are almost the same; only
    the types of the arguments are different:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first call, we pass iterators to a range of integers (from a `vector<int>`),
    0 for the initial sum, and a lambda that adds two integers and returns their sum.
    This produces a sum of all integers in the range; for this example, it is `22`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second call, we pass iterators to a range of strings (from a `vector<string>`),
    an empty string for the initial value, and a lambda that concatenates two strings
    by adding them together and returning the result. This produces a string that
    contains all the strings in the range put together one after another; for this
    example, the result is `hello world!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though generic lambdas can be defined anonymously in the place where they are
    called, it does not really make sense because the very purpose of a generic lambda
    (which is basically, as we mentioned earlier, a lambda expression template) is
    to be reused, as shown in the example from the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: When defining this lambda expression, when used with multiple calls to `std::accumulate()`,
    instead of specifying concrete types for the lambda parameters (such as `int`
    or `std::string`), we used the `auto` specifier and let the compiler deduce the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When encountering a lambda expression that has the `auto` specifier for a parameter
    type, the compiler generates an unnamed function object that has a call operator
    template. For the generic lambda expression in this example, the function object
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The call operator is a template with a type parameter for each parameter in
    the lambda that was specified with `auto`. The return type of the call operator
    is also `auto`, which means the compiler will deduce it from the type of the returned
    value. This operator template will be instantiated with the actual types that
    the compiler will identify in the context where the generic lambda is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++20 template lambdas are an improvement of the C++14 generic lambdas,
    making some scenarios easier. A typical one was shown in the second example of
    the previous section, where the use of lambda was restricted with arguments of
    the type `std::vector`. Another example is when you want to make sure that two
    parameters of the lambda have the same type. Prior to C++20, this was difficult
    to do, but with template lambdas, it is very easy, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another scenario for template lambdas is when you need to know the type of
    a parameter so that you can create instances of that type or invoke static members
    of it. With generic lambdas, the solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This solution requires the use of `std::decay_t` and `decltype`. `decltype`
    is a type specifier that yields the type of a specified expression and is primarily
    used in writing templates. On the other hand, `std::decay` is a utility from `<type_traits>`
    that performs the same type conversions as when passing function arguments by
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in C++20, the same lambda can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar situation occurs when we need to do perfect forwarding in a generic
    lambda, which requires the use of `decltype` to determine the types of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With template lambda, we can rewrite it in a simpler way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As seen in these examples, template lambdas are an improvement on generic lambdas,
    making it easier to handle the scenarios mentioned in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using lambdas with standard algorithms*, to explore the basics of lambda expressions
    and how you can utilize them with the standard algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Using auto whenever possible*, to understand how automatic type
    deduction works in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas are basically unnamed function objects, which means that it should be
    possible to call them recursively. Indeed, they can be called recursively; however,
    the mechanism for doing so is not obvious as it requires assigning the lambda
    to a function wrapper and capturing the wrapper by reference. Though it can be
    argued that a recursive lambda does not really make sense and that a function
    is probably a better design choice, in this recipe, we will look at how to write
    a recursive lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to write a recursive lambda, we will consider the well-known
    example of the Fibonacci function. This is usually implemented recursively in
    C++, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Having this implementation as a starting point, let’s see how we can rewrite
    it using a recursive lambda.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++11, in order to write a recursive lambda function, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the lambda in a function scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the lambda to an `std::function` wrapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the `std::function` object by reference in the lambda in order to call
    it recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++14, the above pattern can be simplified using a generic lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the lambda in a function scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the first argument with the `auto` placeholder; this is used to pass
    the lambda expression as an argument to itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the lambda expression by passing the lambda itself for the first argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C++23, this pattern can be further simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the lambda in a function scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the first argument `this const auto&& self`; this is to enable a new
    C++23 feature called *deducing this* or *explicit object parameter*. You can recursively
    call the lambda expression through the `self` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the lambda expression by calling it with the explicit arguments (if any)
    and let the compiler deduce the first one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of recursive lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive Fibonacci lambda expression in the scope of a function that is
    invoked from the scope where it is defined:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A recursive Fibonacci lambda expression returned by a function, which can be
    invoked from any scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A lambda expression as a member of a class that is invoked recursively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A recursive Fibonacci generic lambda expression—the C++14 alternative for the
    example from the first bullet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A recursive Fibonacci lambda expression, taking advantage of the C++23 feature
    called explicit object parameter (or deducing this), a further simplified alternative
    to the one above:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you need to consider when writing a recursive lambda in C++11
    is that a lambda expression is a function object and, in order to call it recursively
    from the lambda’s body, the lambda must capture its closure (that is, the instantiation
    of the lambda). In other words, the lambda must capture itself, and this has several
    implications:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the lambda must have a name; an unnamed lambda cannot be captured
    so that it can be called again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the lambda can only be defined in a function scope. The reason for
    this is that a lambda can only capture variables from a function scope; it cannot
    capture any variable that has a static storage duration. Objects defined in a
    namespace scope or with the static or external specifiers have static storage
    duration. If the lambda was defined in a namespace scope, its closure would have
    static storage duration and, therefore, the lambda would not capture it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third implication is that the type of the lambda closure cannot remain unspecified;
    that is, it cannot be declared with the `auto` specifier. It is not possible for
    a variable declared with the `auto` type specifier to appear in its own initializer.
    This is because the type of the variable is not known when the initializer is
    being processed. Therefore, you must specify the type of the lambda closure. The
    way we can do this is by using the general-purpose function wrapper `std::function`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, but not least, the lambda closure must be captured by reference. If we
    capture by copy (or value), then a copy of the function wrapper is made but the
    wrapper is uninitialized when the capturing is done. We end up with an object
    that we are not able to call. Even though the compiler will not complain about
    capturing by value, when the closure is invoked, an `std::bad_function_call` is
    thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first example from the *How to do it...* section, the recursive lambda
    is defined inside another function called `sample()`. The signature and the body
    of the lambda expression are the same as those of the regular recursive function
    `fib` `()`, which was defined in the introductory section. The lambda closure
    is assigned to a function wrapper called `lfib`, which is then captured by reference
    by the lambda and called recursively from its body. Since the closure is captured
    by reference, it will be initialized at the time it has to be called from the
    lambda’s body.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we defined a function that returns the closure of a lambda
    expression that, in turn, defines and invokes a recursive lambda with the argument
    it was in turn invoked with. This is a pattern that must be implemented when a
    recursive lambda needs to be returned from a function. This is necessary because
    the lambda closure must still be available at the time the recursive lambda is
    called. The `fib_create()` method returns a function wrapper that, when invoked,
    creates the recursive lambda that captures itself. The outer `f` lambda does not
    capture anything, especially by reference; therefore, we don’t have this issue
    with dangling references. However, when invoked, it creates a closure of the nested
    lambda, which is the actual lambda we are interested in calling, and returns the
    result of applying that recursive `lfib` lambda to its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a recursive lambda is simpler in C++14, as the fourth example from
    the *How to do it…* section shows. Instead of capturing the lambda’s closure,
    it is passed as an argument (typically, the first). For this purpose, a parameter
    is declared using the `auto` placeholder. Let’s revisit the implementation in
    order to discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A lambda expression is a function object with a function call operator. A generic
    lambda is a function object with a template function call operator. The compiler
    generates code similar to the following for the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The function call operator is a template function. Its first parameter has the
    type of the type template parameter. For this primary template, a full explicit
    specialization for the class type itself is provided. This makes it possible to
    invoke the lambda, passing itself as an argument, and therefore, avoiding the
    capturing of an `std::function` object, as it was necessary to do in C++11.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your compiler supports C++23, then it’s possible to simplify this even further
    with the help of the *explicit object parameter* feature (also known as *deducing
    this*). This feature was designed to enable the compiler to figure out from within
    a function whether the expression it’s invoked on is an lvalue or an rvalue, or
    if it is *cv-* or *ref-*qualified, and what the type of the expression is. This
    feature makes possible scenarios such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicating code with overloads-based *cv-* and *ref-*qualifiers (for
    instance, the same function with no qualifiers and with a `const` qualifier, which
    is the most usual case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the **curiously recurring template pattern** (**CRTP**) by using
    simple inheritance and, therefore, removing the recurrence from the pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying writing recursive lambdas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the example given in the *How to do it…* section, the compiler is able to
    deduce the type of the first argument, `self`, making it unnecessary to explicitly
    pass the lambda closure as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the C++23 example, we have defined a lambda expression using
    the trailing return type syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Without this, you would get a compiler error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With a small change in the function implementation, shown next, the trailing
    return type is no longer needed, and the deduce this feature works again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using generic and template lambdas*, to learn how to use `auto` for lambda
    parameters and how to define template lambdas in C++20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Static polymorphism with the curiously recurring template pattern*,
    to learn about what the CRTP is and how it works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic code is key to avoid writing repetitive code. In C++, this is achieved
    with the help of templates. Classes, functions, and variables can be templated.
    Although templates are often seen as complex and cumbersome, they enable the creation
    of general-purpose libraries, such as the standard library, and help us write
    less and better code.
  prefs: []
  type: TYPE_NORMAL
- en: Templates are first-class citizens of the C++ language and could take an entire
    book to cover in detail. In fact, multiple recipes in this book deal with various
    aspects of templates. In this recipe, we will discuss the basics of writing function
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following to create function templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a function template, precede the function declaration with the `template`
    keyword followed by the list of template parameters in angle brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To specialize a function template, leave the list of template parameters empty
    and replace the template parameters with actual types or values in the function
    signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To overload a function template, provide another definition, which can be either
    a template or a non-template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure a particular function template or specialization of a function template
    cannot be called (is deleted from the overload set), declare it as `deleted`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At least at first look, function templates are only slightly different from
    other functions. They are introduced with a template syntax and can be parameterized
    with types, values, or even other templates. However, since templates are only
    blueprints for creating actual code, a function template is basically a blueprint
    that defines a family of functions. Templates only exist in source code, until
    they are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler instantiates the templates based on their use. This process is
    called *template instantiation*. This is done by the compiler by substituting
    the template arguments. For instance, in the case of the `minimum<T>` function
    template shown previously, when we invoke this as `minimum<int>(1, 2)`, the compiler
    substitutes the `int` type for the `T` parameter. There are two forms of instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit instantiation** occurs when the compiler generates code from a template
    based on the templates used in the code. For instance, if the `minimum<T>` function
    is invoked with `int` and `double` values throughout your code, then two overloads
    (one with integer parameters and one with `double` parameters) are generated.
    This is the implicit instantiation, as shown in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explicit instantiation** occurs when you, as a user, request the compiler
    to generate code from a template even if that instantiation is not used in the
    code. An example of where this is useful is when creating library (binary) files,
    since uninstantiated templates (which are only blueprints) are not put into object
    files. The following shows an example of explicit instantiation of the `minimum<T>`
    function for the `char` type. Keep in mind that if an explicit instantiation is
    not defined in the same namespace as the template, the name must be fully qualified
    in the explicit instantiation definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As previously mentioned, templates can have different kinds of parameters.
    These are provided in angle brackets after the `template` keyword and can be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type template parameters**, where the parameter is a placeholder for a type.
    This is the case for all the examples seen in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-type template parameters**, where the parameter is a value of a structural
    type. The integer types, floating-point types (since C++20), pointer types, enumeration
    types, and lvalue reference types are all structural types. In the following example,
    `T` is a type template parameter and `S` is a non-type template parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In C++17, non-type template parameters can be declared using the `auto` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Template template parameters**, where the type of the parameter is another
    type. In the following example, the `trimin` function template has two template
    parameters, a type template parameter `T`, and a template template parameter `M`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although templates allow us to write one implementation for many types (or
    template parameters, more generally), it is often useful, or maybe necessary,
    to provide modified implementations for different types. This process of providing
    alternative implementations for some template parameters is called specialization.
    The template that is being specialized is called the *primary template*. There
    are two possible forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial specialization** is when you provide a different implementation only
    for some of the template parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full specialization** is when you provide a different implementation for
    the entire set of template parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function templates only support full specialization. Partial specialization
    is only possible for class templates. An example of a full specialization was
    provided in the *How to do it…* section when we specialized the `minimum<T>` function
    template for the `const char*` type. Instead of lexicographically comparing the
    two arguments of the function, we decided which is “smaller” based on their length.
    Keep in mind this was an example given only for the purpose of understanding specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function templates can be overloaded just like any other function. You should
    note that when multiple overloads are available, both template and non-template,
    the compiler will prefer a non-template overload. An example was provided earlier.
    Let’s see it again, with only the declarations of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The first call to the `minimum` function takes `std::string` arguments, and,
    therefore, the non-template overload will be invoked. The second call takes `std::wstring`
    arguments, and since the function template is the only matching overload, its
    `std::wstring` instantiation will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying the template arguments during the invocation of a function template
    is not always necessary. The following two calls are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many cases where the compiler can deduce the template arguments from
    the invocation of the function. In this example, since both function arguments
    are integers, it can figure out that the template argument should be the `int`
    type. Therefore, explicitly specifying this is not necessary. However, there are
    also situations in which the compiler cannot deduce the types. In these cases,
    you must provide them explicitly. An example is given next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The two arguments are an `int` and an `unsigned int`. Therefore, the compiler
    does not know whether the `T` type should be deduced as `int` or `unsigned int`.
    To solve this ambiguity, you must provide the template argument explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When deducing template arguments, the compiler performs a comparison between
    the template parameters and the arguments used to invoke the function. These must
    have a certain structure for the comparison to succeed and for the compiler to
    successfully deduce all the arguments. A detailed look at this process is, however,
    beyond the scope of this recipe. You can consult other resources, including my
    book *Template Metaprogramming with C++*, which discusses this in detail in *Chapter
    4*, both for function templates and class templates.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction, templates are a broad topic that cannot be
    covered in one recipe. We will learn more about templates throughout the book,
    including in the next two recipes, where we will discuss function templates with
    a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*, to learn
    how to write functions that take a variable number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Simplifying code with class template argument deduction*, to
    see how template argument deduction works for class templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a function template with a variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes useful to write functions with a variable number of arguments
    or classes with a variable number of members. Typical examples include functions
    such as `printf`, which takes a format and a variable number of arguments, or
    classes such as `tuple`. Before C++11, the former was possible only with the use
    of variadic macros (which enable writing only type-unsafe functions) and the latter
    was not possible at all. C++11 introduced variadic templates, which are templates
    with a variable number of arguments that make it possible to write both type-safe
    function templates with a variable number of arguments, and also class templates
    with a variable number of members. In this recipe, we will look at writing function
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions with a variable number of arguments are called *variadic functions*.
    Function templates with a variable number of arguments are called *variadic function
    templates*. Knowledge of C++ variadic macros (`va_start`, `va_end`, `va_arg`,
    `va_copy`, and `va_list`) is not necessary for learning how to write variadic
    function templates, but it represents a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: We have already used variadic templates in our previous recipes, but this one
    will provide detailed explanations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to write variadic function templates, you must perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an overload with a fixed number of arguments to end compile-time recursion
    if the semantics of the variadic function template require it (refer to `[1]`
    in the following code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a template parameter pack that is a template parameter that can hold
    any number of arguments, including zero; these arguments can be either types,
    non-types, or templates (refer to `[2]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a function parameter pack to hold any number of function arguments, including
    zero; the size of the template parameter pack and the corresponding function parameter
    pack is the same. This size can be determined with the `sizeof...` operator (refer
    to `[3]` and refer to the end of the *How it works...* section for information
    on this operator).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the parameter pack in order to replace it with the actual arguments being
    supplied (refer to `[4]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example, which illustrates all the preceding points, is a variadic
    function template that adds a variable number of arguments using `operator+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first glance, the preceding implementation looks like recursion because the
    function `add()` calls itself, and in a way it is, but it is a compile-time recursion
    that does not incur any sort of runtime recursion and overhead. The compiler actually
    generates several functions with a different number of arguments, based on the
    variadic function template’s usage, so only function overloading is involved and
    not any sort of recursion. However, implementation is done as if parameters would
    be processed in a recursive manner with an end condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we can identify the following key parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Typename... Ts` is a template parameter pack that indicates a variable number
    of template type arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ts... rest` is a function parameter pack that indicates a variable number
    of function arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest...` is an expansion of the function parameter pack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of the ellipsis is not syntactically relevant. `typename... Ts`,
    `typename ... Ts`, and `typename ...Ts` are all equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: In the `add(T head, Ts... rest)` parameter, `head` is the first element of the
    list of arguments, while `...rest` is a pack with the rest of the parameters in
    the list (this can be zero or more). In the body of the function, `rest...` is
    an expansion of the function parameter pack. This means the compiler replaces
    the parameter pack with its elements in their order. In the `add()` function,
    we basically add the first argument to the sum of the remaining arguments, which
    gives the impression of recursive processing. This recursion ends when there is
    a single argument left, in which case the first `add()` overload (with a single
    argument) is called and returns the value of its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation of the function template `add()` enables us to write code,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler encounters `add(1, 2, 3, 4, 5)`, it generates the following
    functions (notice that `arg1`, `arg2`, and so on are not the actual names the
    compiler generates), which shows that this process is actually only a sequence
    of calls to overloaded functions and not recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With GCC and Clang, you can use the `__PRETTY_FUNCTION__` macro to print the
    name and the signature of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding an `std::cout << __PRETTY_FUNCTION__ << std::endl`, when using GCC
    or Clang, at the beginning of the two functions we wrote, we get the following
    when running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With GCC:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Clang:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is a function template, it can be used with any type that supports
    `operator+`. The other example, `add("hello"s, " "s, "world"s, "!"s)`, produces
    the *hello world!* string. However, the `std::basic_string` type has different
    overloads for `operator+`, including one that can concatenate a string into a
    character, so we should be able to also write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that will generate compiler errors, as follows (note that I actually
    replaced `std::basic_string<char, std::char_traits<char>, std::allocator<char>
    >` with the string *hello world!* for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens is that the compiler generates the code shown here, where the
    return type is the same as the type of the first argument. However, the first
    argument is either an `std::string` or a `char` (again, `std::basic_string<char,
    std::char_traits<char>, std::allocator<char> >` was replaced with `string` for
    simplicity). In cases where `char` is the type of the first argument, the type
    of the return value `head+add` `(...)`, which is an `std::string`, does not match
    the function return type and does not have an implicit conversion to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by modifying the variadic function template so that it has
    `auto` for the return type instead of `T`. In this case, the return type is always
    inferred from the return expression, and in our example, it will be `std::string`
    in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be further added that a parameter pack can appear in a brace initialization
    and that its size can be determined using the `sizeof...` operator. Also, variadic
    function templates do not necessarily imply compile-time recursion, as we have
    shown in this recipe. All these are shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The template parameter pack `T` is expanded (with `T...`) into the type arguments
    of the `std::tuple` class template, and the function parameter pack `a` is expanded
    (with `a...`) into the values for the tuple members using brace initialization.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using fold expressions to simplify variadic function templates*, to learn
    how to write simpler and clearer code when creating function templates with a
    variable number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Creating raw user-defined literals*, to understand how to provide
    a custom interpretation of an input sequence so that it changes the normal behavior
    of the compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fold expressions to simplify variadic function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have already discussed folding several times; this is an
    operation that applies a binary function to a range of values to produce a single
    value. We saw this when we discussed variadic function templates and we will see
    it again with higher-order functions. It turns out there is a significant number
    of cases where the expansion of a parameter pack in variadic function templates
    is basically a folding operation. To simplify writing such variadic function templates,
    C++17 introduced fold expressions, which fold an expansion of a parameter pack
    over a binary operator. In this recipe, we will learn how to use fold expressions
    to simplify writing variadic function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The examples in this recipe are based on the variadic function template `add`
    `()`, which we wrote in the previous recipe, *Writing a function template with
    a variable number of arguments*. That implementation is a left-folding operation.
    For simplicity, we’ll present the function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how this particular implementation can be
    simplified, as well as other examples of using fold expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To fold a parameter pack over a binary operator, use one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Left folding with a unary form `(... op pack)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Left folding with a binary form `(init op ... op pack)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right folding with a unary form `(pack op ...)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right folding with a binary form `(pack op ... op init)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parentheses shown here are part of the fold expression and cannot be omitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the compiler encounters a fold expression, it expands it in one of the
    following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Expansion** |'
  prefs: []
  type: TYPE_TB
- en: '| `(... op pack)` | `((pack$1 op pack$2) op ...) op pack$n` |'
  prefs: []
  type: TYPE_TB
- en: '| `(init op ... op pack)` | `(((init op pack$1) op pack$2) op ...) op pack$n`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `(pack op ...)` | `pack$1 op (... op (pack$n-1 op pack$n))` |'
  prefs: []
  type: TYPE_TB
- en: '| `(pack op ... op init)` | `pack$1 op (... op (pack$n-1 op (pack$n op init)))`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: The possible forms of a fold expression'
  prefs: []
  type: TYPE_NORMAL
- en: When the binary form is used, the operator on both the left-hand and right-hand
    sides of the ellipses must be the same, and the initialization value must not
    contain an unexpanded parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following binary operators are supported with fold expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `+` | `-` | `*` | `/` | `%` | `^` | `&` | `&#124;` | `=` | `<` | `>` | `<<`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | `+=` | `-=` | `*=` | `/=` | `%=` | `^=` | `&=` | `&#124;=` | `<<=`
    | `>>=` | `==` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | `<=` | `>=` | `&&` | `&#124;&#124;` | `,` | `.*` | `->*.` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: The binary operator supported with fold expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the unary form, only operators such as `*`, `+`, `&`, `|`, `&&`,
    `||`, and `,` (comma) are allowed with an empty parameter pack. In this case,
    the value of the empty pack is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Empty pack value** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | `-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | `void()` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.4: Operators that can be used with an empty parameter pack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the function templates we implemented earlier (let’s consider
    the left-folding version), we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the `add(1, 2, 3, 4, 5)` call, it will produce the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth mentioning that due to the aggressive ways modern compilers do optimizations,
    this function can be inlined and, eventually, we may end up with an expression
    such as `auto sum = 1 + 2 + 3 + 4 + 5`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fold expressions work with all overloads for the supported binary operators,
    but do not work with arbitrary binary functions. It is possible to implement a
    workaround for that by providing a wrapper type that will hold a value and an
    overloaded operator for that wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `wrapper` is a simple class template that holds a constant
    reference to a value of type `T`. An overloaded `operator<` is provided for this
    class template; this overload does not return a Boolean to indicate that the first
    argument is less than the second, but actually an instance of the `wrapper` class
    type to hold the minimum value of the two arguments. The variadic function template
    `min` `()`, shown here, uses this overloaded `operator<` to fold the pack of arguments
    expanded to instances of the `wrapper` class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This `min()` function is expanded by the compiler to something that could look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see here is cascading calls to the binary `operator <` that return
    a `Wrapper<int>` value. Without this, an implementation of the `min()` function
    using fold expressions would not be possible. The following implementation does
    not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler would transform this, based on the call `min(3, 1, 2)`, to something
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The result is a function that returns a Boolean, and not the actual integer
    value, which is the minimum between the supplied arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing higher-order functions map and fold*, to learn about higher-order
    functions in functional programming and how to implement the widely used `map`
    and `fold` (or `reduce`) functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the higher-order functions map and fold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the preceding recipes in this book, we have used the general-purpose
    algorithms `std::transform()` and `std::accumulate()` in several examples, such
    as for implementing string utilities to create uppercase or lowercase copies of
    a string or for summing the values of a range.
  prefs: []
  type: TYPE_NORMAL
- en: These are basically implementations of the higher-order functions, `map` and
    `fold`. A higher-order function is a function that takes one or more other functions
    as arguments and applies them to a range (a list, vector, map, tree, and so on),
    thus producing either a new range or a value. In this recipe, we will learn how
    to implement the `map` and `fold` functions so that they work with C++ standard
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map` is a higher-order function that applies a function to the elements of
    a range and returns a new range in the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fold` is a higher-order function that applies a combining function to the
    elements of the range to produce a single result. Since the order of the processing
    can be important, there are usually two versions of this function. One is `fold_left`,
    which processes elements from left to right, while the other is `fold_right`,
    which combines the elements from right to left.'
  prefs: []
  type: TYPE_NORMAL
- en: Most descriptions of the function map indicate that it is applied to a list,
    but this is a general term that can indicate different sequential types, such
    as list, vector, and array, and also dictionaries (that is, maps), queues, and
    so on. For this reason, I prefer to use the term range when describing these higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the mapping operation could transform a range of strings into
    a range of integers representing the length of each string. The fold operation
    could then add these lengths to determine the combined length of all the strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the `map` function, you should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::transform` on containers that support iterating and assignment to
    the elements, such as `std::vector` or `std::list`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use other means such as explicit iteration and insertion for containers that
    do not support assignment to the elements, such as `std::map` and `std::queue`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the `fold` function, you should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::accumulate()` on containers that support iterating:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use other means to explicitly process containers that do not support iterating,
    such as `std::queue`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding examples, we implemented the `map` higher-order function in
    a functional way, without side effects. This means it preserves the original range
    and returns a new one. The arguments of the function are the function to apply
    and the range. In order to avoid confusion with the `std::map` container, we have
    called this function `mapf`. There are several overloads for `mapf`, as shown
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The first overload is for containers that support iterating and assignment to
    its elements; this includes `std::vector`, `std::list`, and `std::array`, but
    also C-like arrays. The function takes an `rvalue` reference to a function and
    a range for which `std::begin()` and `std::end()` are defined. The range is passed
    by value so that modifying the local copy does not affect the original range.
    The range is transformed by applying the given function to each element using
    the standard algorithm `std::transform()`; the transformed range is then returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second overload is specialized for `std::map`, which does not support direct
    assignment to its elements (`std::pair<T, U>`). Therefore, this overload creates
    a new map, then iterates through its elements using a range-based `for` loop,
    and inserts the result of applying the input function to each element of the original
    map into the new map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third overload is specialized for `std::queue`, which is a container that
    does not support iterating. It can be argued that a queue is not a typical structure
    to map over, but for the sake of demonstrating different possible implementations,
    we are considering it. In order to iterate over the elements of a queue, the queue
    must be altered—you need to pop elements from the front until the list is empty.
    This is what the third overload does—it processes each element of the input queue
    (passed by value) and pushes the result of applying the given function to the
    front element of the remaining queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have these overloads implemented, we can apply them to a lot of
    containers, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retain absolute values from a vector. In this example, the vector contains
    both negative and positive values. After applying the mapping, the result is a
    new vector with only positive values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Square the numerical values of a list. In this example, the list contains integral
    values. After applying the mapping, the result is a list containing the squares
    of the initial values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rounded amounts of floating points. For this example, we need to use `std::round()`;
    however, this has overloads for all floating-point types, which makes it impossible
    for the compiler to pick the right one. As a result, we either have to write a
    lambda that takes an argument of a specific floating-point type and returns the
    value of `std::round()` applied to that value, or create a function object template
    that wraps `std::round()` and enables its call operator only for floating-point
    types. This technique is used in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Uppercase the string keys of a map of words (where the key is the word and
    the value is the number of appearances in the text). Note that creating an uppercase
    copy of a string is itself a mapping operation. Therefore, in this example, we
    use `mapf` to apply `toupper()` to the elements of the string representing the
    key in order to produce an uppercase copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Normalize values from a queue of priorities; initially, the values are from
    1 to 100, but we want to normalize them into two values, 1=high and 2=normal.
    All the initial priorities that have a value up to 30 get high priority; the others
    get normal priority:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement `fold`, we actually have to consider the two possible types of
    folding—that is, from left to right and from right to left. Therefore, we have
    provided two functions called `fold_left` (for left folding) and `fold_right`
    (for right folding). The implementations shown in the previous section are very
    similar: they both take a function, range, and initial value and call `std::accumulate()`
    to fold the values of the range into a single value. However, `fold_left` uses
    direct iterators, whereas `fold_right` uses reverse iterators to traverse and
    process the range. The second overload is a specialization for the type `std::queue`,
    which does not have iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these implementations for folding, we can implement the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the values of a vector of integers. In this case, both left and right
    folding will produce the same result. In the following examples, we pass either
    a lambda that takes a sum and a number and returns a new sum or the function object
    `std::plus<>` from the standard library, which applies `operator+` to two operands
    of the same type (basically similar to the closure of the lambda):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concatenating strings from a vector into a single string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concatenating an array of characters into a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Counting the number of words in text based on their already computed appearances,
    available in a `map<string, int>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These functions can be pipelined—that is, they can call one function with the
    result of another. The following example maps a range of integers into a range
    of positive integers by applying the `std::abs()` function to its elements. The
    result is then mapped into another range of squares. These are then summed together
    by applying a left fold on the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, we could implement the `fold` function as a variadic function
    template, in the manner seen earlier. The function that performs the actual folding
    is provided as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compare this with the `add()` function template that we wrote in the
    *Writing a function template with a variable number of arguments* recipe, we can
    notice several differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a function, which is perfectly forwarded when calling
    `fold_left` recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end case is a function that requires two arguments because the function
    we use for folding is a binary one (taking two arguments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of the two functions we wrote is declared as `auto` because
    it must match the return type of the supplied binary function `f`, which is not
    known until we call `fold_left`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fold_left()` function can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the last call produces a compiler error because the variadic function
    template `fold_left()` requires at least two arguments to be passed in order to
    invoke the supplied binary function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Creating a library of string helpers*, to see how to create useful
    text utilities that are not directly available in the standard library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Composing functions into a higher-order function*, to learn the functional
    programming technique for creating a new function from one or more other functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions into a higher-order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we implemented two higher-order functions, `map` and
    `fold`, and saw various examples of using them. At the end of the recipe, we saw
    how they can be pipelined to produce a final value after several transformations
    of the original data. Pipelining is a form of composition, which means creating
    one new function from two or more given functions. In the mentioned example, we
    didn’t actually compose functions; we only called a function with the result produced
    by another, but in this recipe, we will learn how to actually compose functions
    together into a new function. For simplicity, we will only consider unary functions
    (functions that take only one argument).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you go forward, it is recommended that you read the previous recipe,
    *Implementing the higher-order functions map and fold*. It is not mandatory for
    understanding this recipe, but we will refer to the `map` and `fold` functions
    we implemented there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compose unary functions into a higher-order function, you should do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compose two functions, provide a function that takes two functions, `f`
    and `g`, as arguments and returns a new function (a lambda) that returns `f(g(x))`,
    where `x` is the argument of the composed function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compose a variable number of functions, provide a variadic template overload
    of the function described previously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composing two unary functions into a new one is relatively trivial. Create a
    template function, which we called `compose()` in the earlier examples, with two
    arguments—`f` and `g`—that represent functions, and return a function that takes
    one argument, `x`, and returns `f(g(x))`. It is important that the type of the
    value returned by the `g` function is the same as the type of the argument of
    the `f` function. The returned value of the compose function is a closure—that
    is, it’s an instantiation of a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it is useful to be able to combine more than just two functions.
    This can be achieved by writing a variadic template version of the `compose()`
    function. Variadic templates are explained in more detail in the *Writing a function
    template with a variable number of arguments* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variadic templates imply compile-time recursion by expanding the parameter
    pack. This implementation is very similar to the first version of `compose()`,
    except for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a variable number of functions as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned closure calls `compose()` recursively with the expanded parameter
    pack; recursion ends when only two functions are left, in which case the previously
    implemented overload is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the code looks like recursion is happening, this is not true recursion.
    It could be called compile-time recursion, but with every expansion, we get a
    call to another method with the same name but a different number of arguments,
    which does not represent recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these variadic template overloads implemented, we can rewrite
    the last example from the previous recipe, *Implementing the higher-order functions
    map and fold*. Refer to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Having an initial vector of integers, we map it to a new vector with only positive
    values by applying `std::abs()` to each element. The result is then mapped to
    a new vector by doubling the value of each element. Finally, the values in the
    resulting vector are folded together by adding them to the initial value, `0`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composition is usually represented by a dot (`.`) or asterisk (`*`), such as
    `f . g` or `f * g`. We can actually do something similar in C++ by overloading
    `operator*` (it would make little sense to try to overload the operator dot).
    Similar to the `compose()` function, `operator*` should work with any number of
    arguments; therefore, we will have two overloads, just like in the case of `compose()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first overload takes two arguments and calls `compose()` to return a new
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second overload is a variadic template function that, again, calls `operator*`
    by expanding the parameter pack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these considerations, we can implement `operator*` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now simplify the actual composition of functions by applying `operator*`
    instead of the more verbose call to `compose()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Although it may not be intuitive at first glance, the functions are applied
    in reverse order rather than the one shown in the text. For instance, in the first
    example, the absolute value of the argument is retained. Then, the result is doubled,
    and the result of that operation is then multiplied by itself. Finally, the result
    is converted to a string. For the supplied argument, `-3`, the final result is
    the string `"36"`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniformly invoking anything callable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers, especially those who implement libraries, sometimes need to invoke
    a callable object in a uniform manner. This can be a function, a pointer to a
    function, a pointer to a member function, or a function object. Examples of such
    cases include `std::bind`, `std::function`, `std::mem_fn`, and `std::thread::thread`.
    C++17 defines a standard function called `std::invoke()` that can invoke any callable
    object with the provided arguments. This is not intended to replace direct calls
    to functions or function objects, but it is useful in template metaprogramming
    for implementing various library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you should be familiar with how to define and use function
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify how `std::invoke()` can be used in different contexts, we will
    use the following function and class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll explore the possible use cases for the `std::invoke()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::invoke()` function is a variadic function template that takes the
    callable object as the first argument and a variable list of arguments that are
    passed to the call. `std::invoke()` can be used to call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Free functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Free functions through a pointer to function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Member functions through a pointer to member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Data members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Function objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lambda expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In practice, `std:invoke()` should be used in template metaprogramming to invoke
    a function with an arbitrary number of arguments. To exemplify such a case, we’ll
    present a possible implementation for our `std::apply()` function, and also a
    part of the standard library, as of C++17, that calls a function by unpacking
    the members of a tuple into the arguments of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we see how `std::invoke()` works, let’s have a quick look at how different
    callable objects can be invoked. Given a function, obviously, the ubiquitous way
    of invoking it is by directly passing it the necessary parameters. However, we
    can also invoke the function using function pointers. The trouble with function
    pointers is that defining the type of the pointer can be cumbersome. Using `auto`
    can simplify things (as shown in the following code), but in practice, you usually
    need to define the type of the pointer to function first, and then define an object
    and initialize it with the correct function address. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling through a function pointer becomes more cumbersome when you need to
    invoke a class function through an object that is an instance of the class. The
    syntax for defining the pointer to a member function and invoking it is not simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of how cumbersome this kind of call may look, the actual problem
    is writing library components (functions or classes) that are able to call any
    of these types of callable objects, in a uniform manner. This is what benefits,
    in practice, from a standard function, such as `std::invoke()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation details of `std::invoke()` are complex, but the way it works
    can be explained in simple terms. Supposing the call has the form `invoke(f, arg1,
    arg2, ..., argN)`, then consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `f` is a pointer to a member function of a `T` class, then the call is equivalent
    to either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(arg1.*f)(arg2, ..., argN)`, if `arg1` is an instance of `T`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(arg1.get().*f)(arg2, ..., argN)`, if `arg1` is a specialization of `reference_wrapper`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`((*arg1).*f)(arg2, ..., argN)`, if it is otherwise'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `f` is a pointer to a data member of a `T` class and there is a single argument—in
    other words, the call has the form `invoke(f, arg1)`—then the call is equivalent
    to either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg1.*f` if `arg1` is an instance class `T`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg1.get().*f` if `arg1` is a specialization of `reference_wrapper`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(*arg1).*f`, if it is otherwise'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `f` is a function object, then the call is equivalent to `f(arg1, arg2, ...,
    argN)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard library also provides a series of related type traits: `std::is_invocable`
    and `std::is_nothrow_invocable` on the one hand, and `std::is_invocable_r` and
    `std::is_nothrow_invocable_r` on the other hand. The first set determines whether
    a function can be invocable with the supplied arguments, while the second determines
    whether it can be invocable with the supplied arguments and produce a result that
    can be implicitly converted to a specified type. The *nothrow* versions of these
    type traits verify that the call can be done without any exception being thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: As of C++20, the `std::invoke` function is `constexpr`, which means it can be
    used to invoke callable objects at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: In C++23, a similar utility called `std::invoke_r` has been added. This has
    one additional template parameter (the first one), which is a type template parameter
    that represents the type of the return value (unless it is `void`) or a type to
    which the return value can be implicitly converted.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_03.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
