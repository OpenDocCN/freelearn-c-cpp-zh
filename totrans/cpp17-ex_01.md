# C++入门

本章介绍了C++中的**面向对象编程**（**OOP**）。我们首先查看一个简单的掷骰子程序。我们编写代码，编译、链接和执行程序。

然后我们继续构建一个简单的面向对象层次结构，包括`Person`基类及其两个子类`Student`和`Employee`。我们还探讨了指针和动态绑定。

最后，我们创建了两种简单的数据类型——栈和队列。栈是由一组从底到顶排序的值构成的，我们只对顶部值感兴趣。队列是一个传统的值队列，我们在后面添加值，在前面检查值。

本章我们将涵盖以下主题：

+   我们首先实现一个简单的游戏：掷骰子。其主要目的是介绍环境，并教你如何设置项目，以及如何编译、链接和执行程序。

+   然后我们通过编写以`Person`作为基类和`Student`、`Employee`作为子类的类层次结构来开始面向对象编程的探讨。这为继承、封装和动态绑定提供了介绍。

+   最后，我们为抽象数据类型栈和队列编写类。栈是一个结构，我们在顶部添加和移除值，而队列更像是一个传统的队列，我们在后面添加值，从前面移除。

# 掷骰子

作为介绍，我们首先编写一个掷骰子的程序。我们使用内置的随机数生成器生成一个介于1到6（包括1和6）之间的整数：

**Main.cpp**

[PRE0]

在前面的程序中，初始的`include`指令允许我们包含头文件，这些头文件主要包含标准库的声明。我们需要`CStdLib`头文件来使用随机数生成器，`CTime`头文件用当前时间初始化随机数生成器，以及`IOStream`头文件来写入结果。

标准库存储在一个名为`std`的`namespace`中。`namespace`可以被认为是一个包含代码的容器。我们通过`using namespace`指令来访问标准库。

每个C++程序恰好包含一个`main`函数。程序的执行总是从`main`函数开始。我们使用`srand`和`time`标准函数来初始化随机数生成器，并使用`rand`生成实际的随机值。百分号（`%`）是取模运算符，它将两个整数相除并给出除法的余数。这样，`dice`整数变量的值总是至少为1，最多为6。最后，我们使用`cout`输出`dice`变量的值，`cout`是标准库中用于写入文本和值的对象。

前四章的程序是用Visual Studio编写的，而剩余章节的程序是用Qt Creator编写的。

以下是如何创建项目、编写代码和执行应用程序的说明。当我们启动 Visual Studio 时，我们按照以下步骤创建我们的项目：

1.  首先，我们在文件菜单中选择“新建”和“项目”，如图所示：

![图片](img/3286a2c4-c1ce-451b-b518-300e356a4880.png)

1.  我们选择 Win32 控制台应用程序类型，并将项目命名为 `Dice`:

![图片](img/6f5ba715-fd89-4045-84ae-59809b91744f.png)

1.  在第一个对话框中，我们只需按下“下一步”按钮：

![图片](img/92382e5d-80ec-45b6-8d03-e65e27d2cf03.png)

1.  在第二个对话框中，我们选择“空项目”复选框，然后单击“完成”按钮。这样，就会创建一个没有文件的空项目：

![图片](img/919e66ae-8eb8-418f-bb40-ffac49c8446f.png)

1.  当我们创建了自己的项目后，我们需要添加一个文件：

![图片](img/e8f2e8ac-3736-4e11-92ea-3d10a8f1c712.png)

1.  我们选择一个 C++ 文件(.cpp)并命名为 `Main.cpp`:

![图片](img/dbf1c8f0-1c72-40c1-83ff-f3ccbccc114b.png)

1.  然后，我们在 `Main.cpp` 文件中输入代码：

![图片](img/c2c816f2-d507-42c2-bb96-0deea233f28b.png)

1.  最后，我们执行程序。最简单的方法是选择“开始调试”或“不调试启动”菜单选项。这样，程序将被编译、链接和执行：

![图片](img/d544cad4-596d-4de1-9746-81edd5feacee.png)

1.  执行的输出显示在命令窗口中：

![图片](img/d041451b-d5b6-443a-9e1a-d7a0a2e9cbbc.png)

# 理解类 - 汽车类

让我们继续看看一个简单的类，它处理汽车的速度和方向。在面向对象的语言中，类是一个非常核心的特性。在 C++ 中，其规范由两部分组成——其定义和实现。定义部分通常放在一个带有 `.h` 后缀的头文件中，而实现部分则放在一个带有 `.cpp` 后缀的文件中，例如 `Car.h` 和 `Car.cpp` 文件。然而，在 [第 3 章](6814bf19-e75b-4083-8447-892dd8416f49.xhtml) 中引入的模板类，即 [构建图书馆管理系统](6814bf19-e75b-4083-8447-892dd8416f49.xhtml)，只存储在一个文件中。

一个类由其成员组成，其中成员是一个字段或方法。**字段**保存特定类型的值。**方法**是一个数学抽象，可能需要输入值并返回一个值。方法输入值被称为参数。然而，在 C++ 中，可以定义没有参数和没有返回类型的函数。

对象是类的实例；我们可以创建一个类的多个对象。方法可以分为以下几类：

+   **构造函数**: 当对象被创建时调用构造函数

+   **检查员**: 检查员检查类的字段

+   **修饰符**: 修饰符修改字段的值

+   **析构函数**: 当对象被销毁时调用析构函数

理想情况下，类的成员方法不直接访问字段，因为这意味着如果字段发生变化，方法名称/类型也必须改变。相反，方法应该提供对类属性的访问。这些是类的概念元素，可能不映射到单个字段。类的每个成员都是`public`、`protected`或`private`：

+   一个`public`成员可以被程序的其他部分访问。

+   一个`protected`成员只能被其自身的成员或其子类的成员访问，这些将在下一节介绍。

+   一个`private`成员只能被其自身的成员访问。然而，这并不完全正确。一个类可以邀请其他类成为其友元，在这种情况下，它们被赋予了访问其`private`和`protected`成员的权限。我们将在下一章探讨友元。

以下`Car`类的定义有两个构造函数和一个析构函数。在这种情况下，它们总是与`Car`类的名称相同。析构函数前面有一个波浪号（`~`）。没有参数的构造函数被称为默认构造函数。

只要方法具有不同的参数列表，就可以有多个具有相同名称的方法，这称为**重载**。更具体地说，它被称为无上下文重载。还有上下文相关重载，在这种情况下，两个方法具有相同的名称和参数列表，但返回类型不同。然而，C++不支持上下文相关重载。

因此，一个类可以包含多个构造函数，只要它们的参数列表不同。然而，析构函数不允许有参数。因此，一个类只能包含一个析构函数：

**Car.h**

[PRE1]

`getSpeed`和`getDirection`方法都是检查器，返回汽车当前的速度和方向。返回值持有`int`类型，即整数的缩写。由于它们不改变类的字段，因此它们被标记为常量，使用`const`关键字。然而，构造函数或析构函数不能是常量：

[PRE2]

`accelerate`、`decelerate`、`turnLeft`和`turnRight`方法都是修改器，用于设置汽车当前的速度和方向。由于它们改变类的字段，因此不能标记为常量：

[PRE3]

`m_speed`和`m_direction`字段持有汽车当前的速度和方向。`-m`前缀表示它们是类的成员，而不是方法局部字段：

[PRE4]

在实现文件中，我们必须包含`Car.h`头文件。`#include`指令是预处理程序的一部分，它只是简单地将`Car.h`文件的内容包含到文件中。在前面的一节中，我们使用尖括号字符(`<`和`>`)包含了系统文件。在这种情况下，我们使用引号包含本地文件。系统包含文件（带有尖括号）包含语言的一部分系统代码，而本地包含文件（带有引号）包含我们自己的代码，作为项目的一部分。技术上，系统包含文件通常从文件系统中的特殊目录中包含，而本地包含文件通常在文件系统中本地包含：

**Car.cpp**

[PRE5]

默认构造函数初始化`speed`和`direction`并将它们设置为`0`。冒号(`:`)符号用于初始化字段。在两个斜杠(`//`)和行尾之间的文本被称为行注释，会被忽略：

[PRE6]

第二个构造函数初始化`speed`和`direction`为给定的参数值：

[PRE7]

在前面的构造函数中，可以使用赋值运算符(`=`)而不是类初始化符号，就像以下代码所示。然而，这被认为是不高效的，因为代码可以通过前面的初始化符号进行优化。注意，我们使用一个等号(`=`)进行赋值。对于两个值的比较，我们使用两个等号(`==`)，这是一种在[第2章](856debf4-f653-4211-928d-b3296fe56d99.xhtml)中引入的方法，*数据结构和算法*：

[PRE8]

在这个类中，析构函数不做任何事情；它只为了完整性而包含：

[PRE9]

`getSpeed`和`getDirection`方法只是简单地返回汽车当前的速度和方向：

[PRE10]

一个加号直接跟在等号后面被称为**复合赋值**，它会导致右边的值加到左边的值上。同样，一个减号直接跟在等号后面会导致右边的值从左边的值中减去。

在一个斜杠(`/`)直接跟在一个星号(`*`)之后，以及一个星号直接跟在一个斜杠之后之间的文本被称为**块注释**，会被忽略：

[PRE11]

现在是时候测试我们的类了。为此，我们需要包含`Car.h`文件，就像我们在`Car.cpp`文件中所做的那样。然而，我们还需要包含系统`IOStream`头文件。与前面的章节一样，系统头文件被括在箭头括号(`<`和`>`)中。我们还需要使用`namespace std`来使用其功能。

**Main.cpp**

[PRE12]

在C++中，一个函数可以是类的一部分，也可以是独立于类的。类的函数通常被称为方法。函数是一个数学抽象。它有输入值，这些值被称为参数，并返回一个值。然而，在C++中，一个函数允许没有参数，并且它可以返回特殊类型void，表示它不返回值。

如前节所述，程序的执行总是从名为`main`的函数开始，每个程序必须恰好有一个名为`main`的函数。与某些其他语言不同，没有必要将文件命名为`Main`。

然而，在这本书中，出于方便起见，每个包含`main`函数的文件都命名为`Main.cpp`。`void`关键字表示`main`不返回值。请注意，虽然构造函数和析构函数从不返回值，且不标记为`void`，但其他不返回值的函数和方法必须标记为`void`：

[PRE13]

我们创建了一个名为`redVolvo`的`Car`类对象。对象是类的实例；`redVolvo`是众多汽车之一：

[PRE14]

在编写信息时，我们使用`cout`对象（代表控制台输出），它通常写入一个文本窗口。由两个左尖括号(`<<`)组成的操作符被称为输出流操作符。`endl`指令使得下一个输出从下一行的开头开始：

[PRE15]

`blueFiat`对象是`Car`类的常量对象。这意味着它只能通过其中一个构造函数进行初始化，然后进行检查，但不能修改。更具体地说，只有常量方法可以在常量对象上调用，并且只有不修改对象字段的那些方法可以是常量：

[PRE16]

当我们执行代码时，输出显示在命令窗口中：

![](img/01041d1d-7233-4864-95f8-a124b9836463.png)

# 扩展`Car`类

在本节中，我们修改了`Car`类。在早期版本中，我们在构造函数中初始化了字段。初始化字段的一个替代方法是直接在类定义中初始化它们。然而，这个特性应该谨慎使用，因为它可能会导致不必要的初始化。如果调用`Car`类的第二个构造函数，字段会被初始化两次，这是无效的。

**Car.h**

[PRE17]

虽然`Car`类定义在`Car.h`文件中，但其方法定义在`Car.cpp`文件中。请注意，我们首先包含`Car.h`文件，以便方法的定义符合其在`Car.h`中的声明：

**Car.cpp**

[PRE18]

此外，前节中的`Car`类有一些局限性：

+   可以无限加速汽车，也可以减速汽车到负速度

+   可以将汽车转向，使其方向为负或超过360度

首先，我们将汽车的最高速度设置为`200`英里/小时。如果速度超过`200`英里/小时，我们将它设置为`200`英里/小时。我们使用`if`语句，它接受一个条件，如果条件为真，则执行以下语句。在这种情况下，语句`(m_speed = 200;)`被括号包围。这并不是必需的，因为它只包含一个语句。然而，如果有多个语句，则这是必需的。在这本书中，我们总是为了清晰起见使用括号，无论语句的数量多少。

**Car.cpp**

[PRE19]

如果速度变为负数，我们改变速度的符号使其变为正数。请注意，我们不能写`m_speed -= m_speed`。那样会将速度设置为零，因为它会从自身减去速度。

由于值是负数，当我们改变符号时，它变为正数。我们还通过旋转`180`度来改变汽车的方向。请注意，在这种情况下，我们也必须检查汽车是否超过速度限制。

此外，请注意，我们必须检查方向是否小于180度。如果是，我们加上`180`度；否则，我们减去`180`度以保持方向在`0`到`360`度的区间内。我们使用`if...else`语句来完成这个操作。如果`if`语句的条件不为真，则执行`else`关键字后的语句：

[PRE20]

当转向汽车时，我们使用取模（`%`）运算符。当除以`360`时，取模运算符给出除法的余数。例如，当`370`除以`360`时，余数是`10`：

[PRE21]

`main`函数创建了一个`Car`类的对象——`redVolvo`。我们首先写下它的速度和方向，然后加速并向左转，再次写下它的速度和加速度。最后，我们减速并向右转，最后一次写下它的速度和方向：

**Main.cpp**

[PRE22]

当我们执行代码时，输出将如下显示在命令窗口中：

![图片](img/c4ae7e52-8fdf-4251-80bd-1de8d8b555ee.png)

# 类层次结构——Person、Student和Employee类

让我们继续使用类层次结构，其中`Person`是基类，`Student`和`Employee`是其子类：

![图片](img/9bedb9c8-d793-4af2-9526-82118247b200.png)

正如人有一个名字一样，我们使用C++标准库中的`string`类来存储名字。`virtual`关键字标记了`print`方法受动态绑定的影响，我们将在本节稍后探讨这一点：

**Person.h**

[PRE23]

我们包含`String`头文件，这允许我们使用`string`类：

**Person.cpp**

[PRE24]

`Student`和`Employee`类是`Person`的子类，并且以`public`方式继承`Person`。有时术语扩展代替继承。继承可以是`public`、`protected`或`private`：

+   在`public`继承中，基类的所有成员在子类中都有相同的访问权限

+   在`protected`继承中，基类的所有`public`成员在子类中变为`protected`

+   在私有继承中，基类的所有 `public` 和 `protected` 成员在子类中变为私有。

`Student` 和 `Employee` 类具有文本字段 `m_university` 和 `m_company`：

**Student.h**

[PRE25]

文件 `Student.cpp` 定义了 `Student` 类的方法：

**Student.cpp**

[PRE26]

子类可以通过使用冒号表示法 (`:`) 来指定其 `name` 来调用基类的构造函数。`Student` 的构造函数使用参数 `name` 调用 `Person` 的构造函数：

[PRE27]

我们必须声明，我们通过使用双冒号表示法 (`::`) 在 `Person` 而不是 `Student` 中调用 `print`：

[PRE28]

`Employee` 类与 `Student` 类类似。然而，它持有字段 `c_company` 而不是 `m_university`。

**Employee.h**

[PRE29]

文件 `Employee.cpp` 定义了 `Employee` 类的方法。

**Employee.cpp**

[PRE30]

构造函数初始化人员的姓名和他们受雇的公司：

[PRE31]

最后，`main` 函数首先包含系统头文件 `String` 和 `IOStream`，它们包含有关字符串处理和输入输出流的声明。由于所有标准头文件都包含在标准命名空间中，我们可以通过使用 `using` 命令来访问系统声明。

**Main.cpp**

[PRE32]

我们定义了三个对象，`Monica`、`Demi` 和 `Charles`，并且对它们中的每一个都调用了 `print` 方法。在所有三种情况下，都调用了 `Person`、`Student` 和 `Employee` 类的 `print` 方法：

[PRE33]

星号 (`*`) 标记 `personPtr` 是指向 `Person` 对象的指针，而不是 `Person` 对象本身。指针持有对象的内存地址，而不是对象本身。然而，目前它并没有持有任何地址。我们很快就会将它分配给一个对象的地址：

[PRE34]

`&` 是一个操作符，它提供对象的地址，该地址被分配给指针 `personPtr`。我们依次将 `personPtr` 分配给 `Person`、`Student` 和 `Employee` 对象的地址，并在每种情况下调用 `print`。由于 `print` 在 `Person` 中被标记为虚拟的，因此调用当前指针指向的对象类的 `print`。由于 `print` 在基类 `Person` 中被标记为虚拟的，因此不需要在子类 `Student` 和 `Employee` 中将 `print` 标记为虚拟。在访问对象指针的成员时，我们使用箭头 (`->`) 操作符而不是点操作符。

当 `personPtr` 指向 `Person` 对象时，调用 `Person` 中的 `print`：

[PRE35]

当 `personPtr` 指向 `Student` 对象时，调用 `Student` 中的 `print`：

[PRE36]

当 `personPtr` 指向 `Employee` 对象时，调用 `Employee` 中的 `print`：

[PRE37]

这个过程称为动态绑定。如果我们省略 `Person` 中的虚拟标记，则会发生静态绑定，并且所有情况下都会调用 `Person` 中的 `print`。

面向对象编程的概念建立在封装、继承和动态绑定这三个基石之上。不支持这些特性的语言不能被称为面向对象的语言。

# 一个简单的数据类型——栈

栈是一种简单的数据类型，我们可以在顶部添加值，移除顶部的值，并且只能检查顶部值。在本节中，我们实现了一个整数栈。在下一章中，我们将探讨可以持有任意类型值的模板类。我们使用链表，这是一种结构，其中指针指向链表中的第一个单元格，每个单元格都持有指向链表中下一个单元格的指针。自然地，链表必须最终结束。我们使用`nullptr`来标记链表的结束，它是C++标准指向特殊空地址的指针。

首先，我们需要一个类来保存链表中的每个单元格。单元格包含一个整数值和指向列表中下一个单元格的指针，或者如果它是列表的最后一个单元格，则为`nullptr`。在下一节中，我们将探讨同时持有前一个和下一个单元格指针的单元格类。

**Cell.h**

[PRE38]

可以直接在类定义中实现方法；它们被称为内联方法。然而，这通常只用于短方法。一个经验法则是内联方法不应超过一行：

[PRE39]

每个单元格都持有一个值和链表中下一个单元格的地址：

[PRE40]

**Cell.h**

[PRE41]

一个单元格通过一个值和一个指向链表下一个单元格的指针来初始化。注意，如果单元格是链表中的最后一个单元格，则`m_next`的值为`nullptr`：

[PRE42]

在栈中，我们只对它的顶部值感兴趣。默认构造函数将栈初始化为空。压栈在栈顶添加一个值，顶部返回顶部值，弹出移除顶部值，大小返回栈中的值的数量，如果栈为空，则返回`true`。布尔类型是一种逻辑类型，可以持有`true`或`false`的值。

**Stack.h**

[PRE43]

`m_firstCellPtr`字段是指向包含栈值的链表第一个单元格的指针。当栈为空时，`m_firstCellPtr`将持有值`nullptr`。`m_size`字段持有栈的当前大小：

[PRE44]

包含了`CAssert`头文件，用于assert宏，该宏用于测试某些条件是否为真。宏是预处理器的组成部分，它执行某些文本替换。

**Stack.cpp**

[PRE45]

默认构造函数通过将指向第一个单元格的指针初始化为`nullptr`并将大小设置为零来将栈设置为空：

[PRE46]

当在栈顶压入新值时，我们使用新操作符动态分配单元格所需的内存。如果我们耗尽内存，则返回`nullptr`，这通过assert宏进行测试。如果`m_firstCellPtr`等于`nullptr`，则执行会因错误信息而终止。紧跟在等于号(`=`)后面的感叹号(`!`)构成了不等于操作符。两个加号(`++`)构成了增量操作符，意味着值增加一。

增量操作符实际上有两种版本——前缀(`++m_size`)和后缀(`m_size++`)。在前缀情况下，值首先增加然后返回，而在后缀情况下，值增加但返回原始值。然而，在这种情况下，我们使用哪个版本都无关紧要，因为我们只对结果感兴趣——即`m_size`的值增加一：

[PRE47]

当返回栈顶值时，我们必须首先检查栈是否为空，因为返回空栈的顶部值是不合逻辑的。如果栈为空，则执行会因错误信息而终止。单个感叹号(`!`)是逻辑非操作符。我们返回存储在链表第一个单元格中的顶部值：

[PRE48]

当弹出栈顶值时，我们也必须检查栈是否为空。我们将指向链表第一个单元格的指针设置为指向下一个单元格。然而，在那之前，我们必须存储第一个指针，`deleteCellPtr`，以便释放它所指向的单元格的内存。

我们使用`delete`操作符释放内存：

[PRE49]

与上面提到的增量操作符一样，两个减号(`--`)构成了`减量`操作符，它将值减一：

[PRE50]

`size`方法简单地返回`m_size`字段的值：

[PRE51]

如果指向第一个单元格指针的指针等于`nullptr`，则栈为空。非正式地说，如果它等于`nullptr`，则指针为空：

[PRE52]

我们通过压栈、查看顶部和弹出一些值来测试栈。

**Main.cpp**

[PRE53]

当打印布尔值时，`stream`操作符不会打印`true`或`false`，而是为`true`打印一个值，为`false`打印零。为了真正打印`true`或`false`，我们使用条件操作符。它接受三个值，由问号(`?`)和冒号(`:`)分隔。如果第一个值是`true`，则返回第二个值。如果第一个值是`false`，则返回第三个值：

[PRE54]

# 更高级的数据类型——队列

队列是一个传统队列的模型；我们在队列的尾部输入值，并在队列的前端检查和移除值。还可以决定它所持有的值的数量以及它是否为空。

与上一节中的栈类似，我们使用链表来实现队列。我们重用`Cell`类；然而，在队列的情况下，我们需要设置一个单元格的下一个链接。因此，我们将`next`重命名为`getNext`并添加了新的`setNext`方法：

**Cell.h**

[PRE55]

我们以类似于栈的方式使用链表实现队列。构造函数初始化一个空队列，`enter` 方法在队列的末尾插入一个值，`remove` 方法从队列的前端删除一个值，`size` 方法返回队列的当前大小，而 `empty` 方法如果队列为空则返回 `true`：

**Queue.h**

[PRE56]

在栈的情况下，我们只对它的顶部感兴趣，它存储在链表的开始处。在队列的情况下，我们既对前部也对后部感兴趣，这意味着我们需要访问链表的第一和最后一个单元格。因此，我们有两个指针，`m_firstCellPtr` 和 `m_lastCellPtr`，分别指向链表中的第一个和最后一个单元格：

[PRE57]

**Queue.cpp**

[PRE58]

当队列被创建时，它是空的；指针是空的，大小为零。由于链表中没有单元格，两个单元格指针都指向 `nullptr`：

[PRE59]

当在队列的末尾输入新值时，我们检查队列是否为空。如果它是空的，两个指针都设置为指向新单元格。如果不为空，最后一个单元格的下一个指针设置为指向新单元格，然后最后一个单元格指针设置为指向新单元格：

[PRE60]

第一种方法简单地返回链表中的第一个单元格的值：

[PRE61]

`remove` 方法将第一个单元格设置为指向第二个单元格。然而，首先我们必须存储它的地址，以便使用 C++ 标准的 `delete` 操作符来释放它的内存：

[PRE62]

我们通过输入和删除一些值来测试队列。我们输入的值为一、二、三，这些值按照顺序放入队列中。然后我们删除前两个值，并输入值四。此时队列中包含的值为三和四：

**Main.cpp**

[PRE63]

# 摘要

在本章中，我们探讨了面向对象编程的基础。我们首先创建了一个项目并执行了一个掷骰子的程序。我们还创建了一个类层次结构，包括基类 `Person` 和它的两个子类 `Student` 和 `Employee`。通过定义对象的指针，我们执行了动态绑定。

最后，我们创建了两种数据类型——栈和队列。栈是一种结构，我们只对顶部的值感兴趣。我们可以在顶部添加值，检查顶部值，并删除顶部值。队列是一种传统的队列，我们在后面输入值，同时在前面检查和删除值。

在下一章中，我们将继续创建数据类型，以及更高级的数据类型，如列表和集合。我们还将探讨 C++ 的更多高级特性。
