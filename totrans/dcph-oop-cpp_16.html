<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-264"><a id="_idTextAnchor711"/>16</h1>
<h1 id="_idParaDest-265"><a id="_idTextAnchor712"/>Using the Observer Pattern</h1>
<p><a id="_idTextAnchor713"/>This chapter will begin our quest to expand your C++ programming repertoire beyond OOP concepts, with the goal of enabling you to solve recurring types of coding problems by utilizing common design patterns. Design patterns will also enhance code maintenance and provide avenues for potential code reuse. </p>
<p>The goal of the fourth section of the book, beginning with this chapter, is to demonstrate and explain popular design patterns and idioms and learn how to implement them effectively in C++. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the advantage of utilizing design patterns</li>
<li>Understanding the Observer pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Observer pattern in C++</li>
</ul>
<p>By the end of this chapter, you will understand the utility of employing design patterns in your code, as well as understand the popular<strong class="bold"> Observer pattern</strong>. We will see an example implementation of this pattern in C++. Utilizing common design patterns will help you become a more beneficial and valuable programmer by enabling you to embrace more sophisticated programming techniques.</p>
<p>Let’s increase our programming skillset by examining various design patterns, starting in this chapter with the Observer pattern.</p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor714"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter16</strong> in a file named <strong class="source-inline">Chp16-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3A8ZWoy">https://bit.ly/3A8ZWoy</a>.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor715"/><a id="_idTextAnchor716"/><a id="_idTextAnchor717"/>Utilizing design patterns</h1>
<p><strong class="bold"><a id="_idTextAnchor718"/>Design patterns</strong> represent a grouping of well-tested programming<a id="_idIndexMarker1039"/> solutions for recurring types of programming<a id="_idIndexMarker1040"/> conundrums. Design patterns represent the high-level concept of a design issue and how a generalized collaboration between classes can provide a solution that can be implemented in a variety of ways.</p>
<p>There are many well-identified design patterns that have been recognized and described in the past 25+ years of software development. We will look at some popular patterns in the remaining chapters of this book to give you a feel of how we can incorporate popular software design solutions into our coding arsenal of techniques.</p>
<p>Why might we choose to utilize a design pattern? To start, once we have identified a type of programming problem, we can make use of a <em class="italic">tried and true</em> solution that other programmers have tested comprehensively. Additionally, once we employ a design pattern, other programmers immersing themselves in our code (for maintenance or future enhancements) will have a basic understanding of the techniques we have chosen, as core design patterns have become an industry standard. </p>
<p>Some of the earliest design patterns came about nearly 50 years ago, with the advent of the <strong class="bold">Model-View-Controller</strong> paradigm, later simplified at times to <strong class="bold">Subject-View</strong>. For example, Subject-View<a id="_idIndexMarker1041"/> is a rudimentary pattern in which an object of interest (the <strong class="bold">Subject</strong>) will be loosely coupled with its method of display (its <strong class="bold">View</strong>). The Subject and its View communicate with a one-to-one association. Sometimes Subjects can have multiple Views, in which case the Subject is associated with many View objects. If one View changes, a state update can be sent to the Subject, who can then send necessary messages to the other Views so that they, too, can be updated to reflect how the new state may have modified their particular View.</p>
<p>The original <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) pattern, emanating from early OOP<a id="_idIndexMarker1042"/> languages such as Smalltalk, has a similar premise, except that a Controller object delegates events between the Model (that is, the Subject) and its View (or Views). These preliminary paradigms influenced early design patterns; the elements of Subject-View or MVC can be seen conceptually as a rudimentary basis for core design patterns today.</p>
<p>Many of the design patterns we will review in the remainder of this book will be adaptations of patterns originally described by the <em class="italic">Gang of Four</em> (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) in <em class="italic">Design Patterns, Elements of Reusable Object-Oriented Software</em>. We will apply and adapt these patterns to solve problems stemming from applications we have introduced in earlier chapters of this book.</p>
<p>Let’s begin our pursuit<a id="_idIndexMarker1043"/> of understanding and utilizing popular design patterns by investigating a pattern in action. We will start with a behavioral pattern known as the <strong class="bold">Observer patt<a id="_idTextAnchor719"/>ern</strong>.</p>
<h1 id="_idParaDest-268"><a id="_idTextAnchor720"/>Understanding the Observer pattern</h1>
<p>In the <strong class="bold">Observer pattern</strong>, an object of interest will maintain<a id="_idIndexMarker1044"/> a list of observers who are interested in state updates of the main object. The observers will maintain a link to their object of interest. We<a id="_idIndexMarker1045"/> will refer to the main object of interest as the <strong class="bold">Subject</strong>. The list of interested objects is known collectively as the <strong class="bold">Observers</strong>. The Subject will inform any Observer<a id="_idIndexMarker1046"/> of relevant state changes. The Observers, once notified of any state changes of the Subject, will take any appropriate next action themselves (usually through a virtual function invoked on each Observer by the Subject).</p>
<p>Already, we can imagine how an Observer pattern may be implemented using associations. In fact, the Observer represents a one-to-many association. The Subject, for example, may use an STL <strong class="source-inline">list</strong> (or <strong class="source-inline">vector</strong>) to collect a set of Observers. Each Observer will contain an association to the Subject. We can imagine an important operation on the Subject, corresponding to a state change in the Subject, issuing an update to its list of Observers to <em class="italic">notify</em> them of the state change. The <strong class="source-inline">Notify()</strong> method is, in fact, invoked when a Subject’s state changes and uniformly applies polymorphic Observer <strong class="source-inline">Update()</strong> methods on each of the Subject’s list of Observers. Before we get swept up in implementation, let’s consider the key components comprising the Observer pa<a id="_idTextAnchor721"/>ttern. </p>
<p>The Observer pattern will include the following:</p>
<ul>
<li>A Subject, or object of interest. The Subject will maintain a list of Observer objects (a many-sided association).</li>
<li>A Subject will provide an interface to <strong class="source-inline">Register()</strong> or <strong class="source-inline">Remove()</strong> an Observer.</li>
<li>A Subject will include a <strong class="source-inline">Notify()</strong> interface, which will update its Observers when the Subject’s state has changed. The Subject will <strong class="source-inline">Notify()</strong> Observers by calling a polymorphic <strong class="source-inline">Update()</strong> method on each Observer in its collection.</li>
<li>An Observer class will be modeled as an abstract class (or interface).</li>
<li>An Observer interface will provide an abstract, polymorphic <strong class="source-inline">Update()</strong> method to be called when its associated Subject has changed its state.</li>
<li>An association between each Observer to its Subject will be maintained in a concrete class, derived from Observer. Doing so will alleviate awkward casting (compared to maintaining the Subject link in the abstract Observer class).</li>
<li>Both classes will be able to maintain their current state.</li>
</ul>
<p>The aforementioned <strong class="source-inline">Subject</strong> and <strong class="source-inline">Observer</strong> classes are specified <a id="_idIndexMarker1047"/>generically so that they may be combined with a variety of concrete classes (mostly through inheritance) that desire to use the Observer pattern. A generic Subject and Observer provide a great opportunity for reuse. With a design pattern, many core elements of a pattern can often be set up more generically to allow for greater reuse of the code itself, not only the reuse in the concept of the solution (pattern).</p>
<p>Let’s move forward to see a sample implementation of the Observer pattern.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor722"/>Implementing the Observer pattern</h1>
<p>To implement the Observer pattern, we will first<a id="_idIndexMarker1048"/> need to define our <strong class="source-inline">Subject</strong> and <strong class="source-inline">Observer</strong> classes. We will then need to derive concrete classes from these classes to incorporate our application specifics and to put our pattern in motion. Let’s get started!</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor723"/>Creating an Observer, Subject, and domain-specific derived classes</h2>
<p>In our example, we will<a id="_idIndexMarker1049"/> create <strong class="source-inline">Subject</strong> and <strong class="source-inline">Observer</strong> classes to<a id="_idIndexMarker1050"/> establish the<a id="_idIndexMarker1051"/> framework for <em class="italic">registering</em> an <strong class="source-inline">Observer</strong> with a <strong class="source-inline">Subject</strong> and for the <strong class="source-inline">Subject</strong> to <strong class="source-inline">Notify()</strong> its set of observers of a state change it may have. We will then derive from these base classes descendent classes we are accustomed to seeing – <strong class="source-inline">Course</strong> and <strong class="source-inline">Student</strong>, where <strong class="source-inline">Course</strong> will be our concrete <strong class="source-inline">Subject</strong> and <strong class="source-inline">Student</strong> will become our concrete <strong class="source-inline">Observer</strong>.</p>
<p>The application we will model will involve a course registration system and the concept of a waitlist. As we have seen before in <em class="italic">Q<a id="_idTextAnchor724"/>uestion 2</em> of <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, we will model a <strong class="source-inline">Student</strong> having an association to many <strong class="source-inline">Course</strong> instances, and a <strong class="source-inline">Course</strong> having an association to many <strong class="source-inline">Student</strong> instances. The Observer pattern will come into play when we model our waitlist. </p>
<p>Our <strong class="source-inline">Course</strong> class will be derived from <strong class="source-inline">Subject</strong>. The list of observers that our <strong class="source-inline">Course</strong> will inherit will represent the <strong class="source-inline">Student</strong> instances on this <strong class="source-inline">Course</strong>’s waitlist. The <strong class="source-inline">Course</strong> will also have a list of <strong class="source-inline">Student</strong> instances, representing students who have been successfully enrolled in the course at hand.</p>
<p>Our <strong class="source-inline">Student</strong> class will be derived from both <strong class="source-inline">Person</strong> and <strong class="source-inline">Observer</strong>. The <strong class="source-inline">Student</strong> will include a list of <strong class="source-inline">Course</strong> instances in which that <strong class="source-inline">Student</strong> is currently enrolled. The <strong class="source-inline">Student</strong> will also have a data member, <strong class="source-inline">waitListedCourse</strong>, which will correspond to an association to a <strong class="source-inline">Course</strong> that the <strong class="source-inline">Student</strong> is waiting to add. This <em class="italic">waitlisted</em> <strong class="source-inline">Course</strong> represents the <strong class="source-inline">Subject</strong> from which we will receive notifications. A notification will correspond to a state change indicating that the <strong class="source-inline">Course</strong> now has room for a <strong class="source-inline">Student</strong> to add the <strong class="source-inline">Course</strong>. </p>
<p>It is from <strong class="source-inline">Observer</strong> that <strong class="source-inline">Student</strong> will inherit the polymorphic operation <strong class="source-inline">Update()</strong>, which will correspond to the <strong class="source-inline">Student</strong> being notified that a spot is now open in the <strong class="source-inline">Course</strong>. Here, in <strong class="source-inline">Student::Update()</strong>, we will include the mechanics to add a student’s <strong class="source-inline">waitListedCourse</strong> (provided the course is open and has available seats). If the addition is successful, we will release the <strong class="source-inline">Student</strong> from the course’s waitlist (the list of observers inherited by <strong class="source-inline">Course</strong> from <strong class="source-inline">Subject</strong>). Naturally, the <strong class="source-inline">Student</strong> will be added to the current student list in the <strong class="source-inline">Course</strong> and the <strong class="source-inline">Course</strong> will appear in that student’s current <a id="_idTextAnchor725"/><a id="_idTextAnchor726"/>course list.</p>
<h3>Specifying the Observer and the Subject</h3>
<p>Let’s break down our example<a id="_idIndexMarker1052"/> into components, starting with the pair<a id="_idIndexMarker1053"/> of classes to specify our <strong class="source-inline">Observer</strong> and <strong class="source-inline">Subject</strong>. This complete program can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;list&gt;    // partial list of #includes
#include &lt;iterator&gt;
using std::cout;   // prefered to: using namespace std;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
using std::list;
constexpr int MAXCOURSES = 5, MAXSTUDENTS = 5;
// Simple enums for states; we could have also made a
// hierarchy of states, but let's keep it simple
enum State { Initial = 0, Success = 1, Failure = 2 };
// More specific states for readability in subsequent code
enum StudentState { AddSuccess = State::Success, 
                    AddFailure = State::Failure };
enum CourseState { OpenForEnrollment = State::Success,
                   NewSpaceAvailable = State::Success, 
                   Full = State::Failure };
class Subject;  // forward declarations
class Student;
<strong class="bold">class Observer</strong>  // Observer is an abstract clas<a id="_idTextAnchor727"/>s
{
private:
    // Represent a state as an int, to eliminate type
    // conversions between specific and basic states
    int observerState = State::Initial;  // in-class init.
protected:
    Observer() = default;
    Observer(int s): observerState(s) { }
    void SetState(int s) { observerState = s; }
public:
    int GetState() const { return observerState; }
    virtual ~Observer() = default;
    <strong class="bold">virtual void Update() = 0;</strong>
};</pre>
<p>In the previous class<a id="_idIndexMarker1054"/> definition, we introduce <a id="_idIndexMarker1055"/>our abstract <strong class="source-inline">Observer</strong> class. Here, we include an <strong class="source-inline">observerState</strong> and protected constructors to initialize this state. We include a protected <strong class="source-inline">SetState()</strong> method to update this state from the scope of a derived class. We also include a public <strong class="source-inline">GetState()</strong> method. The addition of <strong class="source-inline">GetState()</strong> will facilitate implementation within our <strong class="source-inline">Subject</strong>’s <strong class="source-inline">Notify()</strong> method by allowing us to easily check whether the state of our <strong class="source-inline">Observer</strong> has changed. Though state information has historically been added to derived classes of both <strong class="source-inline">Observer</strong> and <strong class="source-inline">Subject</strong>, we will instead generalize state information in these base classes. This will allow our derived classes to remain more pattern-independent and instead focused on the essence of the application.</p>
<p>Notice that our destructor<a id="_idIndexMarker1056"/> is virtual, and we introduce<a id="_idIndexMarker1057"/> an abstract method <strong class="source-inline">virtual void Update() = 0;</strong> to specify the interface our <strong class="source-inline">Subject</strong> will invoke on its list of observers to delegate updates to these <strong class="source-inline">O<a id="_idTextAnchor728"/>bserver</strong> instances.</p>
<p>Now, let’s take a look at our <a id="_idTextAnchor729"/><strong class="source-inline">Subject</strong> base class:</p>
<pre class="source-code">
<strong class="bold">class Subject</strong>   // Treated as an abstract class, due to
{               // protected constructors. However, there's 
private:        // no pure virtual function
    <strong class="bold">list&lt;class Observer *&gt; observers;</strong>
    int numObservers = 0;
    // Represent a state as an int, to eliminate
    // type conversions between specific and basic states
    int subjectState = State::Initial;
    list&lt;Observer *&gt;::iterator newIter;
protected:
    Subject() = default;
    Subject(int s): subjectState(s) { } // note in-class
                                        // init. above
    void SetState(int s) { subjectState = s; }
public:
    int GetState() const { return subjectState; }
    int GetNumObservers() const { return numObservers; }
    virtual ~Subject() = default;
    <strong class="bold">virtual void Register(Observer *);</strong>
    <strong class="bold">virtual void Release(Observer *);</strong>
    <strong class="bold">virtual void Notify();</strong>
};</pre>
<p>In the aforementioned <strong class="source-inline">Subject</strong> class<a id="_idIndexMarker1058"/> definition, we see that our <strong class="source-inline">Subject</strong> includes an STL <strong class="source-inline">list</strong> to collect<a id="_idIndexMarker1059"/> its <strong class="source-inline">Observer</strong> instances. It also includes the <strong class="source-inline">subjectState</strong> and a counter to reflect the number of observers. Also, we include a data member to keep track of an uncorrupted iterator. We’ll see this will be handy once we erase an element (<strong class="source-inline">list::erase()</strong> is an operation that will invalidate a current iterator). </p>
<p>Our <strong class="source-inline">Subject</strong> class will also have protected constructors and a <strong class="source-inline">SetState()</strong> method, which initializes or sets the <strong class="source-inline">Subject</strong>’s state. Though this class is not technically abstract (it does not contain a pure virtual function), its constructors are protected to simulate an abstract class; this class is only intended to be constructed as a subobject within a derived class instance. </p>
<p>In the public interface, we have some access functions to get the current state or number of observers. We also have a virtual destructor, and virtual functions for <strong class="source-inline">Register()</strong>, <strong class="source-inline">Release()</strong>, and <strong class="source-inline">Notify()</strong>. We will provide implementations for the latter three methods at this base class level.</p>
<p>Let’s next take a look at the default implementations of <strong class="source-inline">Register()</strong>, <strong class="source-inline">Release()</strong>, and <strong class="source-inline">Notify()</strong> in our <strong class="source-inline">Subject</strong> base class:</p>
<pre class="source-code">
<strong class="bold">void Subject::Register(Observer *ob)</strong>
{
    observers.push_back(ob); // Add an Observer to the list
    numObservers++;
}
<strong class="bold">void Subject::Release(Observer *ob)</strong> // Remove an Observer 
{                                   // from the list
    bool found = false;
    // loop until we find th<a id="_idTextAnchor730"/>e desired Observer
    // Note auto iter will be: list&lt;Observer *&gt;::iterator
    for (auto iter = observers.begin();
         iter != observers.end() &amp;&amp; !found; ++iter)
    {
        if (*iter == ob)// if we find observer that we seek
        {
            // erase() element, iterator is now corrupt.
            // Save returned (good) iterator; 
            // we'll need it later
            newIter = observers.erase(iter);
            found = true;  // exit loop after found
            numObservers--;
        }
    }
}
<strong class="bold">void Subject::Notify()</strong>
{   // Notify all Observers
    // Note auto iter will be: list&lt;Observer *&gt;::iterator
    for (auto iter = observers.begin(); 
         iter != observers.end(); ++iter)
    {
        (*iter)-&gt;Update(); // AddCourse, then Release   
        // Observer. State 'Success' is represented
        // generally for Observer (at this level we have 
        // no knowledge of how Subject and Observer have
        // been specialized). In our application, this
        // means a Student (observer) added a course,
        // got off waitlist (so waitlist had a Release),
        // so we update the iterator
        if ((*iter)-&gt;GetState() == State::Success)
            iter = newIter; // update the iterator since
    }                       // erase() invalidated this one
    if (!observers.empty())
    {   // Update last item on waitlist
        Observer *last = *newIter; 
        last-&gt;Update();
    }
}</pre>
<p>In the aforementioned <strong class="source-inline">Subject</strong> member functions, let’s begin<a id="_idIndexMarker1060"/> by examining<a id="_idIndexMarker1061"/> the <strong class="source-inline">void Subject::Register(Observer *)</strong> method. Here, we simply add the <strong class="source-inline">Observer *</strong> specified as a parameter to our STL <strong class="source-inline">list</strong> of observers (and increase the counter for the number of observers).</p>
<p>Next, let’s consider the inverse of <strong class="source-inline">Register()</strong> by reviewing <strong class="source-inline">void Subject::Release(Observer *)</strong>. Here, we iterate through our list of observers until we find the one we are seeking. We then call <strong class="source-inline">list::erase()</strong> on that current item, set our <strong class="source-inline">found</strong> flag to <strong class="source-inline">true</strong> (to leave the loop), and decrement the number of observers. Also, notice that we save the return value of <strong class="source-inline">list::erase()</strong>, which is an updated (and valid) iterator to the list of observers. The iterator <strong class="source-inline">iter</strong> in the loop has been invalidated with our call to <strong class="source-inline">list::erase()</strong>. We save this revised iterator in a data member <strong class="source-inline">newIter</strong> so that we can access it shortly.</p>
<p>Finally, let’s take a look at the <strong class="source-inline">Notify()</strong> method in <strong class="source-inline">Subject</strong>. This method <a id="_idIndexMarker1062"/>will be called once<a id="_idIndexMarker1063"/> there is a state change in the <strong class="source-inline">Subject</strong>. The goal will be to <strong class="source-inline">Update()</strong> all observers on the <strong class="source-inline">Subject</strong>’s observer list. To do just that, we look through our list. One by one, we grab an <strong class="source-inline">Observer</strong> with the list iterator <strong class="source-inline">iter</strong>. We call <strong class="source-inline">Update()</strong> on the current <strong class="source-inline">Observer</strong> with <strong class="source-inline">(*iter)-&gt;Update();</strong>. We can tell whether the update has been a success for a given <strong class="source-inline">Observer</strong> by checking the observer’s state using <strong class="source-inline">if ((*iter)-&gt;GetState() == State::Success)</strong>. With a state of <em class="italic">Success</em>, we know the observer’s actions will have caused the <strong class="source-inline">Release()</strong> function we just reviewed to be called on itself. Because the <strong class="source-inline">list::erase()</strong> used in <strong class="source-inline">Release()</strong> has invalidated the iterator, we now get the correct and revised iterator using <strong class="source-inline">iter = newIter;</strong>. Finally, outside of the loop, we call <strong class="source-inline">Update()</strong> on the last item in the list of observers.</p>
<h3>Deriving concrete classes from Subject and Observer </h3>
<p>Let’s continue moving forward<a id="_idIndexMarker1064"/> with this example by taking<a id="_idIndexMarker1065"/> a look at our concrete<a id="_idIndexMarker1066"/> classes derived<a id="_idIndexMarker1067"/> from <strong class="source-inline">Subject</strong> or <strong class="source-inline">Observer</strong>. Let’s start with <strong class="source-inline">Course</strong>, derived from <strong class="source-inline">Subject</strong>:</p>
<pre class="source-code">
<strong class="bold">class Course: public Subject  </strong>
{   <strong class="bold">// inherits Observer list; </strong>
<strong class="bold">    // Observer list represents Students on waitlist</strong>
private:
    string title;
    int number = 0;  // course num, total num students set
    int totalStudents = 0; // using in-class initialization
    Student *students[MAXSTUDENTS] = { }; // initialize to
                                          // nullptrs
public:                             
    Course(const string &amp;title, int num): number(num)
    {
        this-&gt;title = title;  // or rename parameter
        // Note: in-class init. is in-lieu of below:
        // for (int i = 0; i &lt; MAXSTUDENTS; i++)
            // students[i] = nullptr; 
    }
    // destructor body shown as place holder to add more
    // work that will be necessary
    ~Course() override 
    {     /* There's more work to add here! */    }
    int GetCourseNum() const { return number; }
    const string &amp;GetTitle() const { return title; }
    const AddStudent(Student *);
    <strong class="bold">void Open() </strong>
<strong class="bold">    {    SetState(CourseState::OpenForEnrollment); </strong>
<strong class="bold">         Notify(); </strong>
<strong class="bold">    }</strong> 
    void PrintStudents() const;
};
bool Course::AddStudent(Student *s)
{  // Should also check Student hasn't been added to Course
    if (totalStudents &lt; MAXSTUDENTS)  // course not full
    {
        students[totalStudents++] = s;
        return true;
    }
    else return false;
}
void Course::PrintStudents() const
{
    cout &lt;&lt; "Course: (" &lt;&lt; GetTitle() &lt;&lt; 
            ") has the following students: " &lt;&lt; endl;
    for (int i = 0; i &lt; MAXSTUDENTS &amp;&amp; 
                        students[i] != nullptr; i++)
    {
        cout &lt;&lt; "\t" &lt;&lt; students[i]-&gt;GetFirstName() &lt;&lt; " ";
        cout &lt;&lt; students[i]-&gt;GetLastName() &lt;&lt; endl;
    }
}</pre>
<p>In our aforementioned <strong class="source-inline">Course</strong> class, we include<a id="_idIndexMarker1068"/> data members for the course<a id="_idIndexMarker1069"/> title and number<a id="_idIndexMarker1070"/> as well as for the total number<a id="_idIndexMarker1071"/> of students currently enrolled. We also have our list of students currently enrolled, indicated by <strong class="source-inline">Student *students[MAXNUMBERSTUDENTS];</strong>. Additionally, keep in mind that we inherit the STL <strong class="source-inline">list</strong> of observers from our <strong class="source-inline">Subject</strong> base class. This list of <strong class="source-inline">Observer</strong> instances will represent the <strong class="source-inline">Student</strong> instances comprising our waitlist (of students) for the <strong class="source-inline">Course</strong>.</p>
<p>The <strong class="source-inline">Course</strong> class additionally includes a constructor, a virtual destructor, and simple access functions. Note that the virtual destructor has more work to do than shown – if a <strong class="source-inline">Course</strong> destructs, we must remember to first remove (but not delete) <strong class="source-inline">Student</strong> instances from the <strong class="source-inline">Course</strong>. Our <strong class="source-inline">bool Course::AddStudent(Student *)</strong> interface will allow us to add a <strong class="source-inline">Student</strong> to a <strong class="source-inline">Course</strong>. Of course, we should ensure that the <strong class="source-inline">Student</strong> has not already added the <strong class="source-inline">Course</strong> in the body of this method.</p>
<p>Our <strong class="source-inline">void Course::Open();</strong> method<a id="_idIndexMarker1072"/> will be invoked<a id="_idIndexMarker1073"/> on a <strong class="source-inline">Course</strong> to indicate<a id="_idIndexMarker1074"/> that the course is now available to add<a id="_idIndexMarker1075"/> students. Here, we will first set the state to <strong class="source-inline">Course::OpenForEnrollment</strong> (clearly indicating <em class="italic">Open for Enrollment</em> with the enumerated type) and then call <strong class="source-inline">Notify()</strong>. Our <strong class="source-inline">Notify()</strong> method in base class <strong class="source-inline">Subject</strong> loops through each <strong class="source-inline">Observer</strong>, calling polymorphic <strong class="source-inline">Update()</strong> on each observer. Each <strong class="source-inline">Observer</strong> is a <strong class="source-inline">Student</strong>; <strong class="source-inline">Student::Update()</strong> will allow each <strong class="source-inline">Student</strong> on the waitlist to try to add the <strong class="source-inline">Course</strong>, which now is open to receive students. With a successful addition to the course’s current student list, a <strong class="source-inline">Student</strong> will then request <strong class="source-inline">Release()</strong> of its position on the waitlist (as an <strong class="source-inline">Observer</strong>).</p>
<p>Next, let’s take a look at our class definition for <strong class="source-inline">Student</strong>, our concrete class derived from both <strong class="source-inline">Person</strong> and <strong class="source-inline">Observer</strong>:</p>
<pre class="source-code">
class Person { }; // Assume our typical Person class here
<strong class="bold">class Student: public Person, public Observer</strong>
{
private:
    float gpa = 0.0;     // in-class initialization
    const string studentId;
    int currentNumCourses = 0;
    Course *courses[MAXCOURSES] = { }; // set to nullptrs
    // Course we'd like to take - we're on the waitlist. 
    <strong class="bold">Course *waitListedCourse = nullptr;  </strong>// Our Subject
                                // (in specialized form)
    static int numStudents;
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, <strong class="bold">Course *</strong>);
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;);
    Student(const Student &amp;) = delete; // Copies disallowed
    ~Student() override;   // virtual destructor
    void EarnPhD();
    float GetGpa() const { return gpa; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void Print() const override;  // from Person
    void IsA() const override;  // from Person
    <strong class="bold">void Upd<a id="_idTextAnchor731"/>ate() override;</strong>     // from Observer
    virtual void Graduate(); // newly introduced virtual fn
    bool AddCourse(Course *);
    void PrintCourses() const;
    static int GetNumberStudents() { return numStudents; } 
};</pre>
<p>Briefly reviewing<a id="_idIndexMarker1076"/> the aforementioned class<a id="_idIndexMarker1077"/> definition for <strong class="source-inline">Student</strong>, we can see<a id="_idIndexMarker1078"/> that this class<a id="_idIndexMarker1079"/> is derived from both <strong class="source-inline">Person</strong> and <strong class="source-inline">Observer</strong> using multiple inheritance. Let’s assume our <strong class="source-inline">Person</strong> class is as we have used in the past many times. </p>
<p>In addition to the usual components of our <strong class="source-inline">Student</strong> class, we add the data member <strong class="source-inline">Course *waitListedCourse;</strong>, which will model the association to our <strong class="source-inline">Subject</strong>. This data member will model the idea of a <strong class="source-inline">Course</strong> that we would very much like to add, yet currently <a id="_idIndexMarker1080"/>cannot, that is, a <em class="italic">waitlisted</em> course. Here, we<a id="_idIndexMarker1081"/> are implementing the concept <a id="_idIndexMarker1082"/>of a single waitlisted<a id="_idIndexMarker1083"/> course, but we could easily expand the example to include a list supporting multiple waitlisted courses. Notice that this link (data member) is declared in the form of the derived type, <strong class="source-inline">Course</strong>, not the base type, <strong class="source-inline">Subject</strong>. This is typical in the Observer pattern and will help us avoid dreaded down-casting as we override our <strong class="source-inline">Update()</strong> method in <strong class="source-inline">Student</strong>. It is through this link that we will conduct our interaction with our <strong class="source-inline">Subject</strong> and the means by which we will receive updates from our <strong class="source-inline">Subject</strong> as it changes states.</p>
<p>We also notice that we have <strong class="source-inline">virtual void Update() override;</strong> prototyped in <strong class="source-inline">Student</strong>. This method will allow us to override the pure vir<a id="_idTextAnchor732"/>tual <strong class="source-inline">Update()</strong> method specified by <strong class="source-inline">Observer</strong>.</p>
<p>Next, let’s review a selection of the various new member functions for <strong class="source-inline">Student</strong>:</p>
<pre class="source-code">
// Assume most Student member functions are as we are
// accustomed to seeing. All are available online.
// Let's look at ONLY those that may differ:
// Note that the default constructor for Observer() will be
// invoked implicitly, thus it is not needed in init list
// below (it is shown in comment as a reminder it's called)
Student::Student(const string &amp;fn, const string &amp;ln, 
    char mi, const string &amp;t, float avg, const string &amp;id,
    <strong class="bold">Course *c</strong>): Person(fn, ln, mi, t), // <strong class="bold">Observer()</strong>,
    gpa(avg), studentId(id), currentNumCourses(0)
{ 
    // Below nullptr assignment is no longer needed with
    // above in-class initialization; otherwise, add here:
    // for (int i = 0; i &lt; MAXCOURSES; i++)
        // courses[i] = nullptr;
    <strong class="bold">waitListedCourse = c;</strong>  // set initial waitlisted Course
                           // (Subject)
    <strong class="bold">c-&gt;Register(this);</strong> // Add the Student (Observer) to 
                       // the Subject's list of Observers
    numStudents++;
}
bool Student::AddCourse(Course *c)
{ 
    // Should also check Student isn't already in Course
    if (currentNumCourses &lt; MAXCOURSES)
    {
        courses[currentNumCourses++] = c;  // set assoc.
        c-&gt;AddStudent(this);               // set back-link
        return true;
    }
    else  // if we can't add the course,
    {   // add Student (Observer) to the Course's Waitlist, 
        <strong class="bold">c-&gt;Register(this);</strong>  // stored in Subject base class
        <strong class="bold">waitListedCourse = c;</strong> // set Student (Observer) 
                              // link to Subject
        return false;
    }
}</pre>
<p>Let’s review the previously listed<a id="_idIndexMarker1084"/> member functions. Since we are<a id="_idIndexMarker1085"/> accustomed to most of the necessary<a id="_idIndexMarker1086"/> components and mechanics<a id="_idIndexMarker1087"/> in the <strong class="source-inline">Student</strong> class, we will focus on the newly added <strong class="source-inline">Student</strong> methods, starting with an alternate constructor. In this constructor, let us assume that we set most of the data members as usual.The key additional lines of code here are <strong class="source-inline">waitListedCourse = c;</strong> to set our waitlist entry to the desired <strong class="source-inline">Course</strong> (<strong class="source-inline">Subject</strong>), as well as <strong class="source-inline">c-&gt;Register(this);</strong>, where we add the <strong class="source-inline">Student</strong> (<strong class="source-inline">Observer</strong>) to the <strong class="source-inline">Subject</strong>’s list (the formal waitlist for the course).</p>
<p>Next, in our <strong class="source-inline">bool Student::AddCourse(Course *)</strong> method, we first check that we haven’t exceeded our maximum allowed courses. If not, we go through the mechanics to add the association to link a <strong class="source-inline">Student</strong> and <strong class="source-inline">Course</strong> in both directions. That is, <strong class="source-inline">courses[currentNumCourses++] = c;</strong> to have the student’s current course list contain an association to the new <strong class="source-inline">Course</strong>, as well as <strong class="source-inline">c-&gt;AddStudent(this);</strong> to ask the current <strong class="source-inline">Course</strong> to add the <strong class="source-inline">Student</strong> (namely, <strong class="source-inline">this</strong>) to its enrolled student list.</p>
<p>Let’s continue by reviewing the remainder of the new member functions for <strong class="source-inline">Student</strong>:</p>
<pre class="source-code">
<strong class="bold">void Student::Update()</strong>
{   // Course state changed to 'Open For Enrol<a id="_idTextAnchor733"/>lment', etc.
    // so we can now add it.
    if ((waitListedCourse-&gt;GetState() == 
         CourseState::OpenForEnrollment) ||
        (waitListedCourse-&gt;GetState() == 
         CourseState::NewSpaceAvailable))
    {
        if (AddCourse(waitListedCourse)) // success Adding 
        {
            cout &lt;&lt; GetFirstName() &lt;&lt; " " &lt;&lt; GetLastName();
            cout &lt;&lt; " removed from waitlist and added to ";
            cout &lt;&lt; waitListedCourse-&gt;GetTitle() &lt;&lt; endl;
            // Set observer's state to AddSuccess
            <strong class="bold">SetState(StudentState::AddSuccess);</strong> 
            // Remove Student from Course's waitlist
            <strong class="bold">waitListedCourse-&gt;Release(this);</strong> // Remove Obs.
                                            // from Subject
            <strong class="bold">waitListedCourse = nullptr;</strong> // Set Subject link 
        }                               // to null
    }
}
void Student::PrintCourses() const
{
    cout &lt;&lt; "Student: (" &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetLastName() &lt;&lt; ") enrolled in: " &lt;&lt; endl;
    for (int i = 0; i &lt; MAXCOURSES &amp;&amp; 
                    courses[i] != nullptr; i++)
        cout &lt;&lt; "\t" &lt;&lt; courses[i]-&gt;GetTitle() &lt;&lt; endl;
}</pre>
<p>Continuing<a id="_idIndexMarker1088"/> with the remainder<a id="_idIndexMarker1089"/> of our previously mentioned <strong class="source-inline">Student</strong> member<a id="_idIndexMarker1090"/> functions, next, in our<a id="_idIndexMarker1091"/> polymorphic <strong class="source-inline">void Student::Update()</strong> method, we conduct the desired adding of a waitlisted course. Recall, <strong class="source-inline">Notify()</strong> will be called when there is a state change on our <strong class="source-inline">Subject</strong> (<strong class="source-inline">Course</strong>). One such state change may be when a <strong class="source-inline">Course</strong> is <em class="italic">Open for Enrollment</em>, or perhaps a state of <em class="italic">New Space Available</em> now exists following a <strong class="source-inline">Student</strong> dropping the <strong class="source-inline">Course</strong>. <strong class="source-inline">Notify()</strong> then calls <strong class="source-inline">Update()</strong> on each <strong class="source-inline">Observer</strong>. Our <strong class="source-inline">Update()</strong> has been overridden in <strong class="source-inline">Student</strong> to get the state of the <strong class="source-inline">Course</strong> (<strong class="source-inline">Subject</strong>). If the state indicates the <strong class="source-inline">Course</strong> is now <em class="italic">Open for Enrollment</em> or has a <em class="italic">New Space Available</em>, we try <strong class="source-inline">AddCourse(waitListedCourse);</strong>. If this is a success, we set the state of the <strong class="source-inline">Student</strong> (<strong class="source-inline">Observer</strong>) to <strong class="source-inline">StudentState::AddSuccess</strong> (<em class="italic">Add Success</em>) to indicate that we have been successful in our <strong class="source-inline">Update()</strong>, which means we’ve added the <strong class="source-inline">Course</strong>. Next, since we have added the desired course to our current course list, we can now remove ourselves from the <strong class="source-inline">Course</strong>’s waitlist. That is, we will want to remove ourselves (<strong class="source-inline">Student</strong>) as an <strong class="source-inline">Observer</strong> from the <strong class="source-inline">Subject</strong> (the <strong class="source-inline">Course</strong>’s waitlist) using <strong class="source-inline">waitListedCourse-&gt;Release(this);</strong>. Now that we have added our desired waitlisted course, we can also remove our link to the <strong class="source-inline">Subject</strong> using <strong class="source-inline">waitListedCourse = nullptr;</strong>.</p>
<p>Lastly, our <a id="_idIndexMarker1092"/>aforementioned <strong class="source-inline">Student</strong> code includes<a id="_idIndexMarker1093"/> a method to print<a id="_idIndexMarker1094"/> the currently enrolled<a id="_idIndexMarker1095"/> courses of the <strong class="source-inline">Student</strong> with <strong class="source-inline">void Student::PrintCourses();</strong>. This method is pretty straightforward.</p>
<h3>Bringing the pattern components together</h3>
<p>Let us now bring all of our various<a id="_idIndexMarker1096"/> components together by taking a look at our <strong class="source-inline">main()</strong> function to see how our Observer pattern is orchestrated:</p>
<pre class="source-code">
int main()
{   // Instantiate several courses
    Course *c1 = new Course("C++", 230);  
    Course *c2 = new Course("Advanced C++", 430);
    Course *c3 = new Course("C++ Design Patterns", 550);
    // Instantiate Students, select a course to be on the 
    // waitlist for -- to be added when registration starts
    Student s1("Anne", "Chu", 'M',<a id="_idTextAnchor734"/> "Ms.", 3.9, "66CU", <strong class="bold">c1</strong>);
    Student s2("Joley", "Putt", 'I', "Ms.", 3.1, 
               "585UD", <strong class="bold">c1</strong>);
    Student s3("Geoff", "Curt", 'K', "Mr.", 3.1, 
               "667UD", <strong class="bold">c1</strong>);
    Student s4("Ling", "Mau", 'I', "Ms.", 3.1, "55TU", <strong class="bold">c1</strong>);
    Student s5("Jiang", "Wu", 'Q', "Dr.", 3.8, "88TU", <strong class="bold">c1</strong>);
    cout &lt;&lt; "Registration is Open" &lt;&lt; "\n";
    cout &lt;&lt; "Waitlist Students to be added to Courses"; 
    cout &lt;&lt; endl;
    // Sends a message to Students that Course is Open. 
    <strong class="bold">c1-&gt;Open();</strong> // Students on waitlist will automatically
    c2-&gt;Open(); // be Added (as room allows)
    c3-&gt;Open();
    // Now that registration is open, add more courses 
    cout &lt;&lt; "During open registration, Students now adding
             additional courses" &lt;&lt; endl;
    <strong class="bold">s1.AddCourse(c2);</strong>  // Try to add more courses
    s2.AddCourse(c2);  // If full, we'll be added to 
    s4.AddCourse(c2);  // a waitlist
    s5.AddCourse(c2);  
    s1.AddCourse(c3);  
    s3.AddCourse(c3);  
    s5.AddCourse(c3);
    cout &lt;&lt; "Registration complete\n" &lt;&lt; endl;
    c1-&gt;PrintStudents();   // print each Course's roster
    c2-&gt;PrintStudents();
    c3-&gt;PrintStudents();
    s1.PrintCourses();  // print each Student's course list
    s2.PrintCourses();
    s3.PrintCourses();
    s4.PrintCourses();
    s5.PrintCourses();
    return 0;
}</pre>
<p>Reviewing our aforementioned <strong class="source-inline">main()</strong> function, we first<a id="_idIndexMarker1097"/> instantiate three <strong class="source-inline">Course</strong> instances. We next instantiate five <strong class="source-inline">Student</strong> instances, utilizing a constructor that allows us to provide an initial <strong class="source-inline">Course</strong> that each <strong class="source-inline">Student</strong> would like to add when course registration commences. Note that these <strong class="source-inline">Students</strong> (<strong class="source-inline">Observers</strong>) will be added to the waitlist for their desired courses (<strong class="source-inline">Subject</strong>). Here, a <strong class="source-inline">Subject</strong> (<strong class="source-inline">Course</strong>) will have a list of <strong class="source-inline">Observer</strong>s (<strong class="source-inline">Student</strong>s) who wish to add the course when registration opens. </p>
<p>Next, we see that a <strong class="source-inline">Course</strong> that many <strong class="source-inline">Student</strong> instances desire becomes <em class="italic">Open for Enrollment</em> for registration with <strong class="source-inline">c1-&gt;Open();</strong>. <strong class="source-inline">Course::Open()</strong> sets the state of the <strong class="source-inline">Subject</strong> to <strong class="source-inline">CourseState::OpenForEnrollment</strong>, easily indicating the course is <em class="italic">Open for Enrollment</em>, and then calls <strong class="source-inline">Notify()</strong>. As we know, <strong class="source-inline">Subject::Notify()</strong> will call <strong class="source-inline">Update()</strong> on the <strong class="source-inline">Subject</strong>’s list of observers. It is here that an initial waitlisted <strong class="source-inline">Course</strong> instance will be added to a student’s schedule and be subsequently removed as an <strong class="source-inline">Observer</strong> from the <strong class="source-inline">Subject</strong>’s waitlist.</p>
<p>Now that registration is open, each <strong class="source-inline">Student</strong> will try to add more courses in the usual manner using <strong class="source-inline">bool Student::AddCourse(Course *)</strong>, such as with <strong class="source-inline">s1.AddCourse(c2);</strong>. Should a <strong class="source-inline">Course</strong> be full, the <strong class="source-inline">Student</strong> will be added to the <strong class="source-inline">Course</strong>’s waitlist (modeled as the inherited <strong class="source-inline">Subject</strong>’s list of observers, which are in fact, derived <strong class="source-inline">Student</strong> types). Recall, <strong class="source-inline">Course</strong> inherits from <strong class="source-inline">Subject</strong>, which keeps a list of students interested in adding a particular course (the waitlist of observers). When the <strong class="source-inline">Course</strong> state changes to <em class="italic">New Space Available</em>, students on the waitlist (via data member <strong class="source-inline">observers</strong>) will be notified, and the <strong class="source-inline">Update()</strong> method on each <strong class="source-inline">Student</strong> will subsequently call <strong class="source-inline">AddCourse()</strong> for that <strong class="source-inline">Student</strong>.</p>
<p>Once we have added<a id="_idIndexMarker1098"/> various courses, we will then see each <strong class="source-inline">Course</strong> print its roster of students, such as <strong class="source-inline">c2-&gt;PrintStudents()</strong>. Likewise, we will then see each <strong class="source-inline">Student</strong> print the respective courses i<a id="_idTextAnchor735"/><a id="_idTextAnchor736"/>n which they are enrolled, such as with <strong class="source-inline">s5.PrintCourses();</strong>.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Registration is Open </p>
<p class="source-code">Waitlist Students to be added to Courses</p>
<p class="source-code">Anne Chu removed from waitlist and added to C++</p>
<p class="source-code">Goeff Curt removed from waitlist and added to C++</p>
<p class="source-code">Jiang Wu removed from waitlist and added to C++</p>
<p class="source-code">Joley Putt removed from waitlist and added to C++</p>
<p class="source-code">Ling Mau removed from waitlist and added to C++</p>
<p class="source-code">During open registration, Students now adding more courses</p>
<p class="source-code">Registration complete</p>
<p class="source-code">Course: (C++) has the following students:</p>
<p class="source-code">        Anne Chu</p>
<p class="source-code">        Goeff Curt</p>
<p class="source-code">        Jiang Wu</p>
<p class="source-code">        Joley Putt</p>
<p class="source-code">        Ling Mau</p>
<p class="source-code">Course: (Advanced C++) has the following students:</p>
<p class="source-code">        Anne Chu</p>
<p class="source-code">        Joley Putt</p>
<p class="source-code">        Ling Mau</p>
<p class="source-code">        Jiang Wu</p>
<p class="source-code">Course: (C++ Design Patterns) has the following students:</p>
<p class="source-code">        Anne Chu</p>
<p class="source-code">        Goeff Curt</p>
<p class="source-code">        Jiang Wu</p>
<p class="source-code">Student: (Anne Chu) enrolled in:</p>
<p class="source-code">        C++</p>
<p class="source-code">        Advanced C++</p>
<p class="source-code">        C++ Design Patterns</p>
<p class="source-code">Student: (Joley Putt) enrolled in:</p>
<p class="source-code">        C++</p>
<p class="source-code">        Advanced C++</p>
<p class="source-code">Student: (Goeff Curt) enrolled in:</p>
<p class="source-code">        C++</p>
<p class="source-code">        C++ Design Patterns</p>
<p class="source-code">Student: (Ling Mau) enrolled in:</p>
<p class="source-code">        C++</p>
<p class="source-code">        Advanced C++</p>
<p class="source-code">Student: (Jiang Wu) enrolled in:</p>
<p class="source-code">        C++</p>
<p class="source-code">        Advanced C++</p>
<p class="source-code">        C++ Design Patterns</p>
<p>We have now seen an implementation<a id="_idIndexMarker1099"/> of the Observer pattern. We have folded the more generic <strong class="source-inline">Subject</strong> and <strong class="source-inline">Observer</strong> classes into the framework of classes we a<a id="_idTextAnchor737"/>re accustomed to seeing, namely <strong class="source-inline">Course</strong>, <strong class="source-inline">Person</strong>, and <strong class="source-inline">Student</strong>. Let us now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor738"/>Summary</h1>
<p>In this chapter, we have begun our pursuit to become better C++ programmers by expanding our repertoire beyond OOP concepts to include the utilization of design patterns. Our primary goal is to enable you to solve recurring types of coding problems using <em class="italic">tried and true</em> solutions by applying common design patterns.</p>
<p>We have first understood the purpose of design patterns and the advantage of employing them in our code. We have then specifically understood the premise behind the Observer pattern and how it contributes to OOP. Finally, we have taken a look at how we may implement the Observer pattern in C++. </p>
<p>Utilizing common design patterns, such as the Observer pattern, will help you more easily solve recurring types of programming problems in a manner understood by other programmers. A key tenant in OOP is to strive for the reuse of components whenever possible. By utilizing design patterns, you will be contributing to reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern in <a href="B19087_17.xhtml#_idTextAnchor743"><em class="italic">Chapter 17</em></a>, <em class="italic">Implementing the Factory Pattern</em>. Adding more patterns to our collection of skills makes us more versat<a id="_idTextAnchor739"/>ile and valued programmers. Let’s continue forward!</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor740"/>Questions</h1>
<ol>
<li>Using the online code for the example in this chapter as a starting point and the solution from a previous exercise (<em class="italic">Question 3</em>, <em class="italic">Chapter <a id="_idTextAnchor741"/>10</em>, <em class="italic">Implementing Association, Aggregation, and Composition</em>):<ol><li>Implement (or modify your previous) <strong class="source-inline">Student::DropCourse()</strong>. When a <strong class="source-inline">Student</strong> drops a <strong class="source-inline">Course</strong>, this event will cause the <strong class="source-inline">Course</strong> state to become state <strong class="source-inline">2</strong>, <em class="italic">New Space Available</em>. With the state change, <strong class="source-inline">Notify()</strong> will then be called on the <strong class="source-inline">Course</strong> (<strong class="source-inline">Subject</strong>), which will then <strong class="source-inline">Update()</strong> the list of observers (students on the waitlist). <strong class="source-inline">Update()</strong> will indirectly allow w<a id="_idTextAnchor742"/>aitlisted <strong class="source-inline">Student</strong> instances, if any, to now add the <strong class="source-inline">Course</strong>. </li><li>Lastly, in <strong class="source-inline">DropCourse()</strong>, remember to remove the dropped course from the student’s current course list.</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Observer pattern?</li>
</ol>
</div>
</div></body></html>