<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-264"><a id="_idTextAnchor711"/>16</h1>
<h1 id="_idParaDest-265"><a id="_idTextAnchor712"/>Using the Observer Pattern</h1>
<p><a id="_idTextAnchor713"/>This chapter will begin our quest to expand your C++ programming repertoire beyond OOP concepts, with the goal of enabling you to solve recurring types of coding problems by utilizing common design patterns. Design patterns will also enhance code maintenance and provide avenues for potential code reuse. </p>
<p>The goal of the fourth section of the book, beginning with this chapter, is to demonstrate and explain popular design patterns and idioms and learn how to implement them effectively in C++. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the advantage of utilizing design patterns</li>
<li>Understanding the Observer pattern and how it contributes to OOP</li>
<li>Understanding how to implement the Observer pattern in C++</li>
</ul>
<p>By the end of this chapter, you will understand the utility of employing design patterns in your code, as well as understand the popular<strong class="bold"> Observer pattern</strong>. We will see an example implementation of this pattern in C++. Utilizing common design patterns will help you become a more beneficial and valuable programmer by enabling you to embrace more sophisticated programming techniques.</p>
<p>Let’s increase our programming skillset by examining various design patterns, starting in this chapter with the Observer pattern.</p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor714"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter16</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter16</code> in a file named <code>Chp16-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3A8ZWoy">https://bit.ly/3A8ZWoy</a>.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor715"/><a id="_idTextAnchor716"/><a id="_idTextAnchor717"/>Utilizing design patterns</h1>
<p><strong class="bold"><a id="_idTextAnchor718"/>Design patterns</strong> represent a grouping of well-tested programming<a id="_idIndexMarker1039"/> solutions for recurring types of programming<a id="_idIndexMarker1040"/> conundrums. Design patterns represent the high-level concept of a design issue and how a generalized collaboration between classes can provide a solution that can be implemented in a variety of ways.</p>
<p>There are many well-identified design patterns that have been recognized and described in the past 25+ years of software development. We will look at some popular patterns in the remaining chapters of this book to give you a feel of how we can incorporate popular software design solutions into our coding arsenal of techniques.</p>
<p>Why might we choose to utilize a design pattern? To start, once we have identified a type of programming problem, we can make use of a <em class="italic">tried and true</em> solution that other programmers have tested comprehensively. Additionally, once we employ a design pattern, other programmers immersing themselves in our code (for maintenance or future enhancements) will have a basic understanding of the techniques we have chosen, as core design patterns have become an industry standard. </p>
<p>Some of the earliest design patterns came about nearly 50 years ago, with the advent of the <strong class="bold">Model-View-Controller</strong> paradigm, later simplified at times to <strong class="bold">Subject-View</strong>. For example, Subject-View<a id="_idIndexMarker1041"/> is a rudimentary pattern in which an object of interest (the <strong class="bold">Subject</strong>) will be loosely coupled with its method of display (its <strong class="bold">View</strong>). The Subject and its View communicate with a one-to-one association. Sometimes Subjects can have multiple Views, in which case the Subject is associated with many View objects. If one View changes, a state update can be sent to the Subject, who can then send necessary messages to the other Views so that they, too, can be updated to reflect how the new state may have modified their particular View.</p>
<p>The original <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) pattern, emanating from early OOP<a id="_idIndexMarker1042"/> languages such as Smalltalk, has a similar premise, except that a Controller object delegates events between the Model (that is, the Subject) and its View (or Views). These preliminary paradigms influenced early design patterns; the elements of Subject-View or MVC can be seen conceptually as a rudimentary basis for core design patterns today.</p>
<p>Many of the design patterns we will review in the remainder of this book will be adaptations of patterns originally described by the <em class="italic">Gang of Four</em> (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) in <em class="italic">Design Patterns, Elements of Reusable Object-Oriented Software</em>. We will apply and adapt these patterns to solve problems stemming from applications we have introduced in earlier chapters of this book.</p>
<p>Let’s begin our pursuit<a id="_idIndexMarker1043"/> of understanding and utilizing popular design patterns by investigating a pattern in action. We will start with a behavioral pattern known as the <strong class="bold">Observer patt<a id="_idTextAnchor719"/>ern</strong>.</p>
<h1 id="_idParaDest-268"><a id="_idTextAnchor720"/>Understanding the Observer pattern</h1>
<p>In the <strong class="bold">Observer pattern</strong>, an object of interest will maintain<a id="_idIndexMarker1044"/> a list of observers who are interested in state updates of the main object. The observers will maintain a link to their object of interest. We<a id="_idIndexMarker1045"/> will refer to the main object of interest as the <strong class="bold">Subject</strong>. The list of interested objects is known collectively as the <strong class="bold">Observers</strong>. The Subject will inform any Observer<a id="_idIndexMarker1046"/> of relevant state changes. The Observers, once notified of any state changes of the Subject, will take any appropriate next action themselves (usually through a virtual function invoked on each Observer by the Subject).</p>
<p>Already, we can imagine how an Observer pattern may be implemented using associations. In fact, the Observer represents a one-to-many association. The Subject, for example, may use an STL <code>list</code> (or <code>vector</code>) to collect a set of Observers. Each Observer will contain an association to the Subject. We can imagine an important operation on the Subject, corresponding to a state change in the Subject, issuing an update to its list of Observers to <em class="italic">notify</em> them of the state change. The <code>Notify()</code> method is, in fact, invoked when a Subject’s state changes and uniformly applies polymorphic Observer <code>Update()</code> methods on each of the Subject’s list of Observers. Before we get swept up in implementation, let’s consider the key components comprising the Observer pa<a id="_idTextAnchor721"/>ttern. </p>
<p>The Observer pattern will include the following:</p>
<ul>
<li>A Subject, or object of interest. The Subject will maintain a list of Observer objects (a many-sided association).</li>
<li>A Subject will provide an interface to <code>Register()</code> or <code>Remove()</code> an Observer.</li>
<li>A Subject will include a <code>Notify()</code> interface, which will update its Observers when the Subject’s state has changed. The Subject will <code>Notify()</code> Observers by calling a polymorphic <code>Update()</code> method on each Observer in its collection.</li>
<li>An Observer class will be modeled as an abstract class (or interface).</li>
<li>An Observer interface will provide an abstract, polymorphic <code>Update()</code> method to be called when its associated Subject has changed its state.</li>
<li>An association between each Observer to its Subject will be maintained in a concrete class, derived from Observer. Doing so will alleviate awkward casting (compared to maintaining the Subject link in the abstract Observer class).</li>
<li>Both classes will be able to maintain their current state.</li>
</ul>
<p>The aforementioned <code>Subject</code> and <code>Observer</code> classes are specified <a id="_idIndexMarker1047"/>generically so that they may be combined with a variety of concrete classes (mostly through inheritance) that desire to use the Observer pattern. A generic Subject and Observer provide a great opportunity for reuse. With a design pattern, many core elements of a pattern can often be set up more generically to allow for greater reuse of the code itself, not only the reuse in the concept of the solution (pattern).</p>
<p>Let’s move forward to see a sample implementation of the Observer pattern.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor722"/>Implementing the Observer pattern</h1>
<p>To implement the Observer pattern, we will first<a id="_idIndexMarker1048"/> need to define our <code>Subject</code> and <code>Observer</code> classes. We will then need to derive concrete classes from these classes to incorporate our application specifics and to put our pattern in motion. Let’s get started!</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor723"/>Creating an Observer, Subject, and domain-specific derived classes</h2>
<p>In our example, we will<a id="_idIndexMarker1049"/> create <code>Subject</code> and <code>Observer</code> classes to<a id="_idIndexMarker1050"/> establish the<a id="_idIndexMarker1051"/> framework for <em class="italic">registering</em> an <code>Observer</code> with a <code>Subject</code> and for the <code>Subject</code> to <code>Notify()</code> its set of observers of a state change it may have. We will then derive from these base classes descendent classes we are accustomed to seeing – <code>Course</code> and <code>Student</code>, where <code>Course</code> will be our concrete <code>Subject</code> and <code>Student</code> will become our concrete <code>Observer</code>.</p>
<p>The application we will model will involve a course registration system and the concept of a waitlist. As we have seen before in <em class="italic">Q<a id="_idTextAnchor724"/>uestion 2</em> of <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, we will model a <code>Student</code> having an association to many <code>Course</code> instances, and a <code>Course</code> having an association to many <code>Student</code> instances. The Observer pattern will come into play when we model our waitlist. </p>
<p>Our <code>Course</code> class will be derived from <code>Subject</code>. The list of observers that our <code>Course</code> will inherit will represent the <code>Student</code> instances on this <code>Course</code>’s waitlist. The <code>Course</code> will also have a list of <code>Student</code> instances, representing students who have been successfully enrolled in the course at hand.</p>
<p>Our <code>Student</code> class will be derived from both <code>Person</code> and <code>Observer</code>. The <code>Student</code> will include a list of <code>Course</code> instances in which that <code>Student</code> is currently enrolled. The <code>Student</code> will also have a data member, <code>waitListedCourse</code>, which will correspond to an association to a <code>Course</code> that the <code>Student</code> is waiting to add. This <em class="italic">waitlisted</em> <code>Course</code> represents the <code>Subject</code> from which we will receive notifications. A notification will correspond to a state change indicating that the <code>Course</code> now has room for a <code>Student</code> to add the <code>Course</code>. </p>
<p>It is from <code>Observer</code> that <code>Student</code> will inherit the polymorphic operation <code>Update()</code>, which will correspond to the <code>Student</code> being notified that a spot is now open in the <code>Course</code>. Here, in <code>Student::Update()</code>, we will include the mechanics to add a student’s <code>waitListedCourse</code> (provided the course is open and has available seats). If the addition is successful, we will release the <code>Student</code> from the course’s waitlist (the list of observers inherited by <code>Course</code> from <code>Subject</code>). Naturally, the <code>Student</code> will be added to the current student list in the <code>Course</code> and the <code>Course</code> will appear in that student’s current <a id="_idTextAnchor725"/><a id="_idTextAnchor726"/>course list.</p>
<h3>Specifying the Observer and the Subject</h3>
<p>Let’s break down our example<a id="_idIndexMarker1052"/> into components, starting with the pair<a id="_idIndexMarker1053"/> of classes to specify our <code>Observer</code> and <code>Subject</code>. This complete program can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter16/Chp16-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;list&gt;    // partial list of #includes
#include &lt;iterator&gt;
using std::cout;   // prefered to: using namespace std;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
using std::list;
constexpr int MAXCOURSES = 5, MAXSTUDENTS = 5;
// Simple enums for states; we could have also made a
// hierarchy of states, but let's keep it simple
enum State { Initial = 0, Success = 1, Failure = 2 };
// More specific states for readability in subsequent code
enum StudentState { AddSuccess = State::Success, 
                    AddFailure = State::Failure };
enum CourseState { OpenForEnrollment = State::Success,
                   NewSpaceAvailable = State::Success, 
                   Full = State::Failure };
class Subject;  // forward declarations
class Student;
<strong class="bold">class Observer</strong>  // Observer is an abstract clas<a id="_idTextAnchor727"/>s
{
private:
    // Represent a state as an int, to eliminate type
    // conversions between specific and basic states
    int observerState = State::Initial;  // in-class init.
protected:
    Observer() = default;
    Observer(int s): observerState(s) { }
    void SetState(int s) { observerState = s; }
public:
    int GetState() const { return observerState; }
    virtual ~Observer() = default;
    <strong class="bold">virtual void Update() = 0;</strong>
};</pre>
<p>In the previous class<a id="_idIndexMarker1054"/> definition, we introduce <a id="_idIndexMarker1055"/>our abstract <code>Observer</code> class. Here, we include an <code>observerState</code> and protected constructors to initialize this state. We include a protected <code>SetState()</code> method to update this state from the scope of a derived class. We also include a public <code>GetState()</code> method. The addition of <code>GetState()</code> will facilitate implementation within our <code>Subject</code>’s <code>Notify()</code> method by allowing us to easily check whether the state of our <code>Observer</code> has changed. Though state information has historically been added to derived classes of both <code>Observer</code> and <code>Subject</code>, we will instead generalize state information in these base classes. This will allow our derived classes to remain more pattern-independent and instead focused on the essence of the application.</p>
<p>Notice that our destructor<a id="_idIndexMarker1056"/> is virtual, and we introduce<a id="_idIndexMarker1057"/> an abstract method <code>virtual void Update() = 0;</code> to specify the interface our <code>Subject</code> will invoke on its list of observers to delegate updates to these <code>O<a id="_idTextAnchor728"/>bserver</code> instances.</p>
<p>Now, let’s take a look at our <a id="_idTextAnchor729"/><code>Subject</code> base class:</p>
<pre class="source-code">
<strong class="bold">class Subject</strong>   // Treated as an abstract class, due to
{               // protected constructors. However, there's 
private:        // no pure virtual function
    <strong class="bold">list&lt;class Observer *&gt; observers;</strong>
    int numObservers = 0;
    // Represent a state as an int, to eliminate
    // type conversions between specific and basic states
    int subjectState = State::Initial;
    list&lt;Observer *&gt;::iterator newIter;
protected:
    Subject() = default;
    Subject(int s): subjectState(s) { } // note in-class
                                        // init. above
    void SetState(int s) { subjectState = s; }
public:
    int GetState() const { return subjectState; }
    int GetNumObservers() const { return numObservers; }
    virtual ~Subject() = default;
    <strong class="bold">virtual void Register(Observer *);</strong>
    <strong class="bold">virtual void Release(Observer *);</strong>
    <strong class="bold">virtual void Notify();</strong>
};</pre>
<p>In the aforementioned <code>Subject</code> class<a id="_idIndexMarker1058"/> definition, we see that our <code>Subject</code> includes an STL <code>list</code> to collect<a id="_idIndexMarker1059"/> its <code>Observer</code> instances. It also includes the <code>subjectState</code> and a counter to reflect the number of observers. Also, we include a data member to keep track of an uncorrupted iterator. We’ll see this will be handy once we erase an element (<code>list::erase()</code> is an operation that will invalidate a current iterator). </p>
<p>Our <code>Subject</code> class will also have protected constructors and a <code>SetState()</code> method, which initializes or sets the <code>Subject</code>’s state. Though this class is not technically abstract (it does not contain a pure virtual function), its constructors are protected to simulate an abstract class; this class is only intended to be constructed as a subobject within a derived class instance. </p>
<p>In the public interface, we have some access functions to get the current state or number of observers. We also have a virtual destructor, and virtual functions for <code>Register()</code>, <code>Release()</code>, and <code>Notify()</code>. We will provide implementations for the latter three methods at this base class level.</p>
<p>Let’s next take a look at the default implementations of <code>Register()</code>, <code>Release()</code>, and <code>Notify()</code> in our <code>Subject</code> base class:</p>
<pre class="source-code">
<strong class="bold">void Subject::Register(Observer *ob)</strong>
{
    observers.push_back(ob); // Add an Observer to the list
    numObservers++;
}
<strong class="bold">void Subject::Release(Observer *ob)</strong> // Remove an Observer 
{                                   // from the list
    bool found = false;
    // loop until we find th<a id="_idTextAnchor730"/>e desired Observer
    // Note auto iter will be: list&lt;Observer *&gt;::iterator
    for (auto iter = observers.begin();
         iter != observers.end() &amp;&amp; !found; ++iter)
    {
        if (*iter == ob)// if we find observer that we seek
        {
            // erase() element, iterator is now corrupt.
            // Save returned (good) iterator; 
            // we'll need it later
            newIter = observers.erase(iter);
            found = true;  // exit loop after found
            numObservers--;
        }
    }
}
<strong class="bold">void Subject::Notify()</strong>
{   // Notify all Observers
    // Note auto iter will be: list&lt;Observer *&gt;::iterator
    for (auto iter = observers.begin(); 
         iter != observers.end(); ++iter)
    {
        (*iter)-&gt;Update(); // AddCourse, then Release   
        // Observer. State 'Success' is represented
        // generally for Observer (at this level we have 
        // no knowledge of how Subject and Observer have
        // been specialized). In our application, this
        // means a Student (observer) added a course,
        // got off waitlist (so waitlist had a Release),
        // so we update the iterator
        if ((*iter)-&gt;GetState() == State::Success)
            iter = newIter; // update the iterator since
    }                       // erase() invalidated this one
    if (!observers.empty())
    {   // Update last item on waitlist
        Observer *last = *newIter; 
        last-&gt;Update();
    }
}</pre>
<p>In the aforementioned <code>Subject</code> member functions, let’s begin<a id="_idIndexMarker1060"/> by examining<a id="_idIndexMarker1061"/> the <code>void Subject::Register(Observer *)</code> method. Here, we simply add the <code>Observer *</code> specified as a parameter to our STL <code>list</code> of observers (and increase the counter for the number of observers).</p>
<p>Next, let’s consider the inverse of <code>Register()</code> by reviewing <code>void Subject::Release(Observer *)</code>. Here, we iterate through our list of observers until we find the one we are seeking. We then call <code>list::erase()</code> on that current item, set our <code>found</code> flag to <code>true</code> (to leave the loop), and decrement the number of observers. Also, notice that we save the return value of <code>list::erase()</code>, which is an updated (and valid) iterator to the list of observers. The iterator <code>iter</code> in the loop has been invalidated with our call to <code>list::erase()</code>. We save this revised iterator in a data member <code>newIter</code> so that we can access it shortly.</p>
<p>Finally, let’s take a look at the <code>Notify()</code> method in <code>Subject</code>. This method <a id="_idIndexMarker1062"/>will be called once<a id="_idIndexMarker1063"/> there is a state change in the <code>Subject</code>. The goal will be to <code>Update()</code> all observers on the <code>Subject</code>’s observer list. To do just that, we look through our list. One by one, we grab an <code>Observer</code> with the list iterator <code>iter</code>. We call <code>Update()</code> on the current <code>Observer</code> with <code>(*iter)-&gt;Update();</code>. We can tell whether the update has been a success for a given <code>Observer</code> by checking the observer’s state using <code>if ((*iter)-&gt;GetState() == State::Success)</code>. With a state of <em class="italic">Success</em>, we know the observer’s actions will have caused the <code>Release()</code> function we just reviewed to be called on itself. Because the <code>list::erase()</code> used in <code>Release()</code> has invalidated the iterator, we now get the correct and revised iterator using <code>iter = newIter;</code>. Finally, outside of the loop, we call <code>Update()</code> on the last item in the list of observers.</p>
<h3>Deriving concrete classes from Subject and Observer </h3>
<p>Let’s continue moving forward<a id="_idIndexMarker1064"/> with this example by taking<a id="_idIndexMarker1065"/> a look at our concrete<a id="_idIndexMarker1066"/> classes derived<a id="_idIndexMarker1067"/> from <code>Subject</code> or <code>Observer</code>. Let’s start with <code>Course</code>, derived from <code>Subject</code>:</p>
<pre class="source-code">
<strong class="bold">class Course: public Subject  </strong>
{   <strong class="bold">// inherits Observer list; </strong>
<strong class="bold">    // Observer list represents Students on waitlist</strong>
private:
    string title;
    int number = 0;  // course num, total num students set
    int totalStudents = 0; // using in-class initialization
    Student *students[MAXSTUDENTS] = { }; // initialize to
                                          // nullptrs
public:                             
    Course(const string &amp;title, int num): number(num)
    {
        this-&gt;title = title;  // or rename parameter
        // Note: in-class init. is in-lieu of below:
        // for (int i = 0; i &lt; MAXSTUDENTS; i++)
            // students[i] = nullptr; 
    }
    // destructor body shown as place holder to add more
    // work that will be necessary
    ~Course() override 
    {     /* There's more work to add here! */    }
    int GetCourseNum() const { return number; }
    const string &amp;GetTitle() const { return title; }
    const AddStudent(Student *);
    <strong class="bold">void Open() </strong>
<strong class="bold">    {    SetState(CourseState::OpenForEnrollment); </strong>
<strong class="bold">         Notify(); </strong>
<strong class="bold">    }</strong> 
    void PrintStudents() const;
};
bool Course::AddStudent(Student *s)
{  // Should also check Student hasn't been added to Course
    if (totalStudents &lt; MAXSTUDENTS)  // course not full
    {
        students[totalStudents++] = s;
        return true;
    }
    else return false;
}
void Course::PrintStudents() const
{
    cout &lt;&lt; "Course: (" &lt;&lt; GetTitle() &lt;&lt; 
            ") has the following students: " &lt;&lt; endl;
    for (int i = 0; i &lt; MAXSTUDENTS &amp;&amp; 
                        students[i] != nullptr; i++)
    {
        cout &lt;&lt; "\t" &lt;&lt; students[i]-&gt;GetFirstName() &lt;&lt; " ";
        cout &lt;&lt; students[i]-&gt;GetLastName() &lt;&lt; endl;
    }
}</pre>
<p>In our aforementioned <code>Course</code> class, we include<a id="_idIndexMarker1068"/> data members for the course<a id="_idIndexMarker1069"/> title and number<a id="_idIndexMarker1070"/> as well as for the total number<a id="_idIndexMarker1071"/> of students currently enrolled. We also have our list of students currently enrolled, indicated by <code>Student *students[MAXNUMBERSTUDENTS];</code>. Additionally, keep in mind that we inherit the STL <code>list</code> of observers from our <code>Subject</code> base class. This list of <code>Observer</code> instances will represent the <code>Student</code> instances comprising our waitlist (of students) for the <code>Course</code>.</p>
<p>The <code>Course</code> class additionally includes a constructor, a virtual destructor, and simple access functions. Note that the virtual destructor has more work to do than shown – if a <code>Course</code> destructs, we must remember to first remove (but not delete) <code>Student</code> instances from the <code>Course</code>. Our <code>bool Course::AddStudent(Student *)</code> interface will allow us to add a <code>Student</code> to a <code>Course</code>. Of course, we should ensure that the <code>Student</code> has not already added the <code>Course</code> in the body of this method.</p>
<p>Our <code>void Course::Open();</code> method<a id="_idIndexMarker1072"/> will be invoked<a id="_idIndexMarker1073"/> on a <code>Course</code> to indicate<a id="_idIndexMarker1074"/> that the course is now available to add<a id="_idIndexMarker1075"/> students. Here, we will first set the state to <code>Course::OpenForEnrollment</code> (clearly indicating <em class="italic">Open for Enrollment</em> with the enumerated type) and then call <code>Notify()</code>. Our <code>Notify()</code> method in base class <code>Subject</code> loops through each <code>Observer</code>, calling polymorphic <code>Update()</code> on each observer. Each <code>Observer</code> is a <code>Student</code>; <code>Student::Update()</code> will allow each <code>Student</code> on the waitlist to try to add the <code>Course</code>, which now is open to receive students. With a successful addition to the course’s current student list, a <code>Student</code> will then request <code>Release()</code> of its position on the waitlist (as an <code>Observer</code>).</p>
<p>Next, let’s take a look at our class definition for <code>Student</code>, our concrete class derived from both <code>Person</code> and <code>Observer</code>:</p>
<pre class="source-code">
class Person { }; // Assume our typical Person class here
<strong class="bold">class Student: public Person, public Observer</strong>
{
private:
    float gpa = 0.0;     // in-class initialization
    const string studentId;
    int currentNumCourses = 0;
    Course *courses[MAXCOURSES] = { }; // set to nullptrs
    // Course we'd like to take - we're on the waitlist. 
    <strong class="bold">Course *waitListedCourse = nullptr;  </strong>// Our Subject
                                // (in specialized form)
    static int numStudents;
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, <strong class="bold">Course *</strong>);
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;);
    Student(const Student &amp;) = delete; // Copies disallowed
    ~Student() override;   // virtual destructor
    void EarnPhD();
    float GetGpa() const { return gpa; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void Print() const override;  // from Person
    void IsA() const override;  // from Person
    <strong class="bold">void Upd<a id="_idTextAnchor731"/>ate() override;</strong>     // from Observer
    virtual void Graduate(); // newly introduced virtual fn
    bool AddCourse(Course *);
    void PrintCourses() const;
    static int GetNumberStudents() { return numStudents; } 
};</pre>
<p>Briefly reviewing<a id="_idIndexMarker1076"/> the aforementioned class<a id="_idIndexMarker1077"/> definition for <code>Student</code>, we can see<a id="_idIndexMarker1078"/> that this class<a id="_idIndexMarker1079"/> is derived from both <code>Person</code> and <code>Observer</code> using multiple inheritance. Let’s assume our <code>Person</code> class is as we have used in the past many times. </p>
<p>In addition to the usual components of our <code>Student</code> class, we add the data member <code>Course *waitListedCourse;</code>, which will model the association to our <code>Subject</code>. This data member will model the idea of a <code>Course</code> that we would very much like to add, yet currently <a id="_idIndexMarker1080"/>cannot, that is, a <em class="italic">waitlisted</em> course. Here, we<a id="_idIndexMarker1081"/> are implementing the concept <a id="_idIndexMarker1082"/>of a single waitlisted<a id="_idIndexMarker1083"/> course, but we could easily expand the example to include a list supporting multiple waitlisted courses. Notice that this link (data member) is declared in the form of the derived type, <code>Course</code>, not the base type, <code>Subject</code>. This is typical in the Observer pattern and will help us avoid dreaded down-casting as we override our <code>Update()</code> method in <code>Student</code>. It is through this link that we will conduct our interaction with our <code>Subject</code> and the means by which we will receive updates from our <code>Subject</code> as it changes states.</p>
<p>We also notice that we have <code>virtual void Update() override;</code> prototyped in <code>Student</code>. This method will allow us to override the pure vir<a id="_idTextAnchor732"/>tual <code>Update()</code> method specified by <code>Observer</code>.</p>
<p>Next, let’s review a selection of the various new member functions for <code>Student</code>:</p>
<pre class="source-code">
// Assume most Student member functions are as we are
// accustomed to seeing. All are available online.
// Let's look at ONLY those that may differ:
// Note that the default constructor for Observer() will be
// invoked implicitly, thus it is not needed in init list
// below (it is shown in comment as a reminder it's called)
Student::Student(const string &amp;fn, const string &amp;ln, 
    char mi, const string &amp;t, float avg, const string &amp;id,
    <strong class="bold">Course *c</strong>): Person(fn, ln, mi, t), // <strong class="bold">Observer()</strong>,
    gpa(avg), studentId(id), currentNumCourses(0)
{ 
    // Below nullptr assignment is no longer needed with
    // above in-class initialization; otherwise, add here:
    // for (int i = 0; i &lt; MAXCOURSES; i++)
        // courses[i] = nullptr;
    <strong class="bold">waitListedCourse = c;</strong>  // set initial waitlisted Course
                           // (Subject)
    <strong class="bold">c-&gt;Register(this);</strong> // Add the Student (Observer) to 
                       // the Subject's list of Observers
    numStudents++;
}
bool Student::AddCourse(Course *c)
{ 
    // Should also check Student isn't already in Course
    if (currentNumCourses &lt; MAXCOURSES)
    {
        courses[currentNumCourses++] = c;  // set assoc.
        c-&gt;AddStudent(this);               // set back-link
        return true;
    }
    else  // if we can't add the course,
    {   // add Student (Observer) to the Course's Waitlist, 
        <strong class="bold">c-&gt;Register(this);</strong>  // stored in Subject base class
        <strong class="bold">waitListedCourse = c;</strong> // set Student (Observer) 
                              // link to Subject
        return false;
    }
}</pre>
<p>Let’s review the previously listed<a id="_idIndexMarker1084"/> member functions. Since we are<a id="_idIndexMarker1085"/> accustomed to most of the necessary<a id="_idIndexMarker1086"/> components and mechanics<a id="_idIndexMarker1087"/> in the <code>Student</code> class, we will focus on the newly added <code>Student</code> methods, starting with an alternate constructor. In this constructor, let us assume that we set most of the data members as usual.The key additional lines of code here are <code>waitListedCourse = c;</code> to set our waitlist entry to the desired <code>Course</code> (<code>Subject</code>), as well as <code>c-&gt;Register(this);</code>, where we add the <code>Student</code> (<code>Observer</code>) to the <code>Subject</code>’s list (the formal waitlist for the course).</p>
<p>Next, in our <code>bool Student::AddCourse(Course *)</code> method, we first check that we haven’t exceeded our maximum allowed courses. If not, we go through the mechanics to add the association to link a <code>Student</code> and <code>Course</code> in both directions. That is, <code>courses[currentNumCourses++] = c;</code> to have the student’s current course list contain an association to the new <code>Course</code>, as well as <code>c-&gt;AddStudent(this);</code> to ask the current <code>Course</code> to add the <code>Student</code> (namely, <code>this</code>) to its enrolled student list.</p>
<p>Let’s continue by reviewing the remainder of the new member functions for <code>Student</code>:</p>
<pre class="source-code">
<strong class="bold">void Student::Update()</strong>
{   // Course state changed to 'Open For Enrol<a id="_idTextAnchor733"/>lment', etc.
    // so we can now add it.
    if ((waitListedCourse-&gt;GetState() == 
         CourseState::OpenForEnrollment) ||
        (waitListedCourse-&gt;GetState() == 
         CourseState::NewSpaceAvailable))
    {
        if (AddCourse(waitListedCourse)) // success Adding 
        {
            cout &lt;&lt; GetFirstName() &lt;&lt; " " &lt;&lt; GetLastName();
            cout &lt;&lt; " removed from waitlist and added to ";
            cout &lt;&lt; waitListedCourse-&gt;GetTitle() &lt;&lt; endl;
            // Set observer's state to AddSuccess
            <strong class="bold">SetState(StudentState::AddSuccess);</strong> 
            // Remove Student from Course's waitlist
            <strong class="bold">waitListedCourse-&gt;Release(this);</strong> // Remove Obs.
                                            // from Subject
            <strong class="bold">waitListedCourse = nullptr;</strong> // Set Subject link 
        }                               // to null
    }
}
void Student::PrintCourses() const
{
    cout &lt;&lt; "Student: (" &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetLastName() &lt;&lt; ") enrolled in: " &lt;&lt; endl;
    for (int i = 0; i &lt; MAXCOURSES &amp;&amp; 
                    courses[i] != nullptr; i++)
        cout &lt;&lt; "\t" &lt;&lt; courses[i]-&gt;GetTitle() &lt;&lt; endl;
}</pre>
<p>Continuing<a id="_idIndexMarker1088"/> with the remainder<a id="_idIndexMarker1089"/> of our previously mentioned <code>Student</code> member<a id="_idIndexMarker1090"/> functions, next, in our<a id="_idIndexMarker1091"/> polymorphic <code>void Student::Update()</code> method, we conduct the desired adding of a waitlisted course. Recall, <code>Notify()</code> will be called when there is a state change on our <code>Subject</code> (<code>Course</code>). One such state change may be when a <code>Course</code> is <em class="italic">Open for Enrollment</em>, or perhaps a state of <em class="italic">New Space Available</em> now exists following a <code>Student</code> dropping the <code>Course</code>. <code>Notify()</code> then calls <code>Update()</code> on each <code>Observer</code>. Our <code>Update()</code> has been overridden in <code>Student</code> to get the state of the <code>Course</code> (<code>Subject</code>). If the state indicates the <code>Course</code> is now <em class="italic">Open for Enrollment</em> or has a <em class="italic">New Space Available</em>, we try <code>AddCourse(waitListedCourse);</code>. If this is a success, we set the state of the <code>Student</code> (<code>Observer</code>) to <code>StudentState::AddSuccess</code> (<em class="italic">Add Success</em>) to indicate that we have been successful in our <code>Update()</code>, which means we’ve added the <code>Course</code>. Next, since we have added the desired course to our current course list, we can now remove ourselves from the <code>Course</code>’s waitlist. That is, we will want to remove ourselves (<code>Student</code>) as an <code>Observer</code> from the <code>Subject</code> (the <code>Course</code>’s waitlist) using <code>waitListedCourse-&gt;Release(this);</code>. Now that we have added our desired waitlisted course, we can also remove our link to the <code>Subject</code> using <code>waitListedCourse = nullptr;</code>.</p>
<p>Lastly, our <a id="_idIndexMarker1092"/>aforementioned <code>Student</code> code includes<a id="_idIndexMarker1093"/> a method to print<a id="_idIndexMarker1094"/> the currently enrolled<a id="_idIndexMarker1095"/> courses of the <code>Student</code> with <code>void Student::PrintCourses();</code>. This method is pretty straightforward.</p>
<h3>Bringing the pattern components together</h3>
<p>Let us now bring all of our various<a id="_idIndexMarker1096"/> components together by taking a look at our <code>main()</code> function to see how our Observer pattern is orchestrated:</p>
<pre class="source-code">
int main()
{   // Instantiate several courses
    Course *c1 = new Course("C++", 230);  
    Course *c2 = new Course("Advanced C++", 430);
    Course *c3 = new Course("C++ Design Patterns", 550);
    // Instantiate Students, select a course to be on the 
    // waitlist for -- to be added when registration starts
    Student s1("Anne", "Chu", 'M',<a id="_idTextAnchor734"/> "Ms.", 3.9, "66CU", <strong class="bold">c1</strong>);
    Student s2("Joley", "Putt", 'I', "Ms.", 3.1, 
               "585UD", <strong class="bold">c1</strong>);
    Student s3("Geoff", "Curt", 'K', "Mr.", 3.1, 
               "667UD", <strong class="bold">c1</strong>);
    Student s4("Ling", "Mau", 'I', "Ms.", 3.1, "55TU", <strong class="bold">c1</strong>);
    Student s5("Jiang", "Wu", 'Q', "Dr.", 3.8, "88TU", <strong class="bold">c1</strong>);
    cout &lt;&lt; "Registration is Open" &lt;&lt; "\n";
    cout &lt;&lt; "Waitlist Students to be added to Courses"; 
    cout &lt;&lt; endl;
    // Sends a message to Students that Course is Open. 
    <strong class="bold">c1-&gt;Open();</strong> // Students on waitlist will automatically
    c2-&gt;Open(); // be Added (as room allows)
    c3-&gt;Open();
    // Now that registration is open, add more courses 
    cout &lt;&lt; "During open registration, Students now adding
             additional courses" &lt;&lt; endl;
    <strong class="bold">s1.AddCourse(c2);</strong>  // Try to add more courses
    s2.AddCourse(c2);  // If full, we'll be added to 
    s4.AddCourse(c2);  // a waitlist
    s5.AddCourse(c2);  
    s1.AddCourse(c3);  
    s3.AddCourse(c3);  
    s5.AddCourse(c3);
    cout &lt;&lt; "Registration complete\n" &lt;&lt; endl;
    c1-&gt;PrintStudents();   // print each Course's roster
    c2-&gt;PrintStudents();
    c3-&gt;PrintStudents();
    s1.PrintCourses();  // print each Student's course list
    s2.PrintCourses();
    s3.PrintCourses();
    s4.PrintCourses();
    s5.PrintCourses();
    return 0;
}</pre>
<p>Reviewing our aforementioned <code>main()</code> function, we first<a id="_idIndexMarker1097"/> instantiate three <code>Course</code> instances. We next instantiate five <code>Student</code> instances, utilizing a constructor that allows us to provide an initial <code>Course</code> that each <code>Student</code> would like to add when course registration commences. Note that these <code>Students</code> (<code>Observers</code>) will be added to the waitlist for their desired courses (<code>Subject</code>). Here, a <code>Subject</code> (<code>Course</code>) will have a list of <code>Observer</code>s (<code>Student</code>s) who wish to add the course when registration opens. </p>
<p>Next, we see that a <code>Course</code> that many <code>Student</code> instances desire becomes <em class="italic">Open for Enrollment</em> for registration with <code>c1-&gt;Open();</code>. <code>Course::Open()</code> sets the state of the <code>Subject</code> to <code>CourseState::OpenForEnrollment</code>, easily indicating the course is <em class="italic">Open for Enrollment</em>, and then calls <code>Notify()</code>. As we know, <code>Subject::Notify()</code> will call <code>Update()</code> on the <code>Subject</code>’s list of observers. It is here that an initial waitlisted <code>Course</code> instance will be added to a student’s schedule and be subsequently removed as an <code>Observer</code> from the <code>Subject</code>’s waitlist.</p>
<p>Now that registration is open, each <code>Student</code> will try to add more courses in the usual manner using <code>bool Student::AddCourse(Course *)</code>, such as with <code>s1.AddCourse(c2);</code>. Should a <code>Course</code> be full, the <code>Student</code> will be added to the <code>Course</code>’s waitlist (modeled as the inherited <code>Subject</code>’s list of observers, which are in fact, derived <code>Student</code> types). Recall, <code>Course</code> inherits from <code>Subject</code>, which keeps a list of students interested in adding a particular course (the waitlist of observers). When the <code>Course</code> state changes to <em class="italic">New Space Available</em>, students on the waitlist (via data member <code>observers</code>) will be notified, and the <code>Update()</code> method on each <code>Student</code> will subsequently call <code>AddCourse()</code> for that <code>Student</code>.</p>
<p>Once we have added<a id="_idIndexMarker1098"/> various courses, we will then see each <code>Course</code> print its roster of students, such as <code>c2-&gt;PrintStudents()</code>. Likewise, we will then see each <code>Student</code> print the respective courses i<a id="_idTextAnchor735"/><a id="_idTextAnchor736"/>n which they are enrolled, such as with <code>s5.PrintCourses();</code>.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>Registration is Open 
Waitlist Students to be added to Courses
Anne Chu removed from waitlist and added to C++
Goeff Curt removed from waitlist and added to C++
Jiang Wu removed from waitlist and added to C++
Joley Putt removed from waitlist and added to C++
Ling Mau removed from waitlist and added to C++
During open registration, Students now adding more courses
Registration complete
Course: (C++) has the following students:
        Anne Chu
        Goeff Curt
        Jiang Wu
        Joley Putt
        Ling Mau
Course: (Advanced C++) has the following students:
        Anne Chu
        Joley Putt
        Ling Mau
        Jiang Wu
Course: (C++ Design Patterns) has the following students:
        Anne Chu
        Goeff Curt
        Jiang Wu
Student: (Anne Chu) enrolled in:
        C++
        Advanced C++
        C++ Design Patterns
Student: (Joley Putt) enrolled in:
        C++
        Advanced C++
Student: (Goeff Curt) enrolled in:
        C++
        C++ Design Patterns
Student: (Ling Mau) enrolled in:
        C++
        Advanced C++
Student: (Jiang Wu) enrolled in:
        C++
        Advanced C++
        C++ Design Patterns</pre>
<p>We have now seen an implementation<a id="_idIndexMarker1099"/> of the Observer pattern. We have folded the more generic <code>Subject</code> and <code>Observer</code> classes into the framework of classes we a<a id="_idTextAnchor737"/>re accustomed to seeing, namely <code>Course</code>, <code>Person</code>, and <code>Student</code>. Let us now briefly recap what we have learned relating to patterns before moving forward to our next chapter.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor738"/>Summary</h1>
<p>In this chapter, we have begun our pursuit to become better C++ programmers by expanding our repertoire beyond OOP concepts to include the utilization of design patterns. Our primary goal is to enable you to solve recurring types of coding problems using <em class="italic">tried and true</em> solutions by applying common design patterns.</p>
<p>We have first understood the purpose of design patterns and the advantage of employing them in our code. We have then specifically understood the premise behind the Observer pattern and how it contributes to OOP. Finally, we have taken a look at how we may implement the Observer pattern in C++. </p>
<p>Utilizing common design patterns, such as the Observer pattern, will help you more easily solve recurring types of programming problems in a manner understood by other programmers. A key tenant in OOP is to strive for the reuse of components whenever possible. By utilizing design patterns, you will be contributing to reusable solutions with more sophisticated programming techniques.</p>
<p>We are now ready to continue forward with our next design pattern in <a href="B19087_17.xhtml#_idTextAnchor743"><em class="italic">Chapter 17</em></a>, <em class="italic">Implementing the Factory Pattern</em>. Adding more patterns to our collection of skills makes us more versat<a id="_idTextAnchor739"/>ile and valued programmers. Let’s continue forward!</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor740"/>Questions</h1>
<ol>
<li>Using the online code for the example in this chapter as a starting point and the solution from a previous exercise (<em class="italic">Question 3</em>, <em class="italic">Chapter <a id="_idTextAnchor741"/>10</em>, <em class="italic">Implementing Association, Aggregation, and Composition</em>):<ol><li>Implement (or modify your previous) <code>Student::DropCourse()</code>. When a <code>Student</code> drops a <code>Course</code>, this event will cause the <code>Course</code> state to become state <code>2</code>, <em class="italic">New Space Available</em>. With the state change, <code>Notify()</code> will then be called on the <code>Course</code> (<code>Subject</code>), which will then <code>Update()</code> the list of observers (students on the waitlist). <code>Update()</code> will indirectly allow w<a id="_idTextAnchor742"/>aitlisted <code>Student</code> instances, if any, to now add the <code>Course</code>. </li><li>Lastly, in <code>DropCourse()</code>, remember to remove the dropped course from the student’s current course list.</li></ol></li>
<li>What other examples can you imagine that might easily incorporate the Observer pattern?</li>
</ol>
</div>
</div></body></html>