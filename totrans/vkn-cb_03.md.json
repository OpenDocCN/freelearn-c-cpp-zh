["```cpp\nVkCommandPoolCreateInfo command_pool_create_info = { \n  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, \n  nullptr, \n  parameters, \n  queue_family \n};\n\n```", "```cpp\nVkResult result = vkCreateCommandPool( logical_device, &command_pool_create_info, nullptr, &command_pool ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create command pool.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkCommandBufferAllocateInfo command_buffer_allocate_info = { \n  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, \n  nullptr, \n  command_pool, \n  level, \n  count \n};\n\n```", "```cpp\ncommand_buffers.resize( count ); \n\nVkResult result = vkAllocateCommandBuffers( logical_device, &command_buffer_allocate_info, &command_buffers[0] ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not allocate command buffers.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkCommandBufferBeginInfo command_buffer_begin_info = { \n  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, \n  nullptr, \n  usage, \n  secondary_command_buffer_info \n};\n\n```", "```cpp\nVkResult result = vkBeginCommandBuffer( command_buffer, &command_buffer_begin_info ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not begin command buffer recording operation.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkResult result = vkEndCommandBuffer( command_buffer ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during command buffer recording.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkResult result = vkResetCommandBuffer( command_buffer, release_resources ? VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT : 0 ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during command buffer reset.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkResult result = vkResetCommandPool( logical_device, command_pool, release_resources ? VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT : 0 ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during command pool reset.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkSemaphoreCreateInfo semaphore_create_info = { \n  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, \n  nullptr, \n  0 \n};\n\n```", "```cpp\nVkResult result = vkCreateSemaphore( logical_device, &semaphore_create_info, nullptr, &semaphore ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a semaphore.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkFenceCreateInfo fence_create_info = { \n  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, \n  nullptr, \n  signaled ? VK_FENCE_CREATE_SIGNALED_BIT : 0 \n};\n\n```", "```cpp\nVkResult result = vkCreateFence( logical_device, &fence_create_info, nullptr, &fence ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a fence.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( fences.size() > 0 ) { \n  VkResult result = vkWaitForFences( logical_device, static_cast<uint32_t>(fences.size()), &fences[0], wait_for_all, timeout ); \n  if( VK_SUCCESS != result ) { \n    std::cout << \"Waiting on fence failed.\" << std::endl; \n    return false; \n  } \n  return true; \n} \nreturn false;\n\n```", "```cpp\nif( fences.size() > 0 ) { \n  VkResult result = vkResetFences( logical_device, static_cast<uint32_t>(fences.size()), &fences[0] ); \n  if( VK_SUCCESS != result ) { \n    std::cout << \"Error occurred when tried to reset fences.\" << std::endl; \n    return false; \n  } \n  return VK_SUCCESS == result; \n} \nreturn false;\n\n```", "```cpp\nstruct WaitSemaphoreInfo { \n  VkSemaphore           Semaphore; \n  VkPipelineStageFlags  WaitingStage; \n};\n\n```", "```cpp\nstd::vector<VkSemaphore>          wait_semaphore_handles; \nstd::vector<VkPipelineStageFlags> wait_semaphore_stages; \n\nfor( auto & wait_semaphore_info : wait_semaphore_infos ) { \n  wait_semaphore_handles.emplace_back( wait_semaphore_info.Semaphore ); \n  wait_semaphore_stages.emplace_back( wait_semaphore_info.WaitingStage ); \n}\n\n```", "```cpp\nVkSubmitInfo submit_info = { \n  VK_STRUCTURE_TYPE_SUBMIT_INFO, \n  nullptr, \n  static_cast<uint32_t>(wait_semaphore_infos.size()), \n  wait_semaphore_handles.size() > 0 ? &wait_semaphore_handles[0] : nullptr, \n  wait_semaphore_stages.size() > 0 ? &wait_semaphore_stages[0] : nullptr, \n  static_cast<uint32_t>(command_buffers.size()), \n  command_buffers.size() > 0 ? &command_buffers[0] : nullptr, \n  static_cast<uint32_t>(signal_semaphores.size()), \n  signal_semaphores.size() > 0 ? &signal_semaphores[0] : nullptr \n};\n\n```", "```cpp\nVkResult result = vkQueueSubmit( queue, 1, &submit_info, fence ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Error occurred during command buffer submission.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstruct WaitSemaphoreInfo { \n  VkSemaphore           Semaphore; \n  VkPipelineStageFlags  WaitingStage; \n};\n\n```", "```cpp\nstd::vector<VkSemaphore> first_signal_semaphores; \nfor( auto & semaphore_info : synchronizing_semaphores ) { \n  first_signal_semaphores.emplace_back( semaphore_info.Semaphore ); \n} \nif( !SubmitCommandBuffersToQueue( first_queue, first_wait_semaphore_infos, first_command_buffers, first_signal_semaphores, VK_NULL_HANDLE ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !SubmitCommandBuffersToQueue( second_queue, synchronizing_semaphores, second_command_buffers, second_signal_semaphores, second_fence ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( !SubmitCommandBuffersToQueue( queue, wait_semaphore_infos, command_buffers, signal_semaphores, fence ) ) { \n  return false; \n}\n\n```", "```cpp\nreturn WaitForFences( logical_device, { fence }, VK_FALSE, timeout );\n\n```", "```cpp\nVkResult result = vkQueueWaitIdle( queue ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Waiting for all operations submitted to queue failed.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkResult result = vkDeviceWaitIdle( logical_device ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Waiting on a device failed.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( VK_NULL_HANDLE != fence ) { \n  vkDestroyFence( logical_device, fence, nullptr ); \n  fence = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != semaphore ) { \n  vkDestroySemaphore( logical_device, semaphore, nullptr ); \n  semaphore = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( command_buffers.size() > 0 ) { \n  vkFreeCommandBuffers( logical_device, command_pool, static_cast<uint32_t>(command_buffers.size()), &command_buffers[0] ); \n  command_buffers.clear(); \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != command_pool ) { \n  vkDestroyCommandPool( logical_device, command_pool, nullptr ); \n  command_pool = VK_NULL_HANDLE; \n}\n\n```"]