["```cpp\n    import std;\n    int main()\n    {\n       std::println(\"Hello, world!\");\n    } \n    std.core module from Visual C++, which contains most of the functionality of the standard library, including the streams library:\n    ```", "```cpp\n    import std.core;\n    int main()\n    {\n      std::cout << \"Hello, World!\\n\";\n    } \n    ```", "```cpp\n    // --- geometry.ixx/.cppm ---\n    export module geometry;\n    #ifdef __cpp_lib_modules\n    import std;\n    #else\n    import std.core;\n    #endif\n    export template <class T,\n       typename = typename std::enable_if_t<std::is_arithmetic_v<T>, T>>\n    struct point\n    {\n       T x;\n       T y;\n    };\n    export using int_point = point<int>;\n    export constexpr int_point int_point_zero{ 0,0 };\n    export template <class T>\n    double distance(point<T> const& p1, point<T> const& p2)\n    {\n       return std::sqrt((p2.x - p1.x) * (p2.x - p1.x) +\n                        (p2.y - p1.y) * (p2.y - p1.y));\n    }\n    namespace geometry_literals\n    {\n       export int_point operator \"\"_ip(const char* ptr, std::size_t size)\n       {\n          int x = 0, y = 0;\n          if(ptr)\n          {\n             while (*ptr != ',' && *ptr != ' ')\n                x = x * 10 + (*ptr++ - '0');\n             while (*ptr == ',' || *ptr == ' ') ptr++;\n             while (*ptr != 0)\n                y = y * 10 + (*ptr++ - '0');\n          }\n          return { x, y };\n       }\n    }\n    // --- main.cpp ---\n    #ifdef __cpp_lib_modules\n    import std;\n    #else\n    import std.core;\n    #endif\n    import geometry;\n    int main()\n    {\n       int_point p{ 3, 4 };\n       std::cout << distance(int_point_zero, p) << '\\n';\n       {\n          using namespace geometry_literals;\n          std::cout << distance(\"0,0\"_ip, \"30,40\"_ip) << '\\n';\n       }\n    } \n    ```", "```cpp\n    // --- geometry.h ---\n    #pragma once\n    #include <cmath>\n    template <class T,\n       typename = typename std::enable_if_t<std::is_arithmetic_v<T>, T>>\n    struct point\n    {\n       T x;\n       T y;\n    };\n    using int_point = point<int>;\n    constexpr int_point int_point_zero{ 0,0 };\n    template <class T>\n    double distance(point<T> const& p1, point<T> const& p2)\n    {\n       return std::sqrt((p2.x – p1.x) * (p2.x – p1.x) +\n                        (p2.y – p1.y) * (p2.y – p1.y));\n    }\n    namespace geometry_literals\n    {\n       int_point operator \"\"_ip(const char* ptr, std::size_t)\n       {\n          int x = 0, y = 0;\n          if(ptr)\n          {\n    while (*ptr != ',' && *ptr != ' ')\n                x = x * 10 + (*ptr++ - '0');\n             while (*ptr == ',' || *ptr == ' ') ptr++;\n             while (*ptr != 0)\n                y = y * 10 + (*ptr++ - '0');\n          }\n          return { x, y };\n       }\n    }\n    // --- main.cpp ---\n    #ifdef __cpp_lib_modules\n    import std;\n    #else\n    import std.core;\n    #endif\n    import \"geometry.h\";\n    int main()\n    {\n       int_point p{ 3, 4 };\n       std::cout << distance(int_point_zero, p) << '\\n';\n       {\n          using namespace geometry_literals;\n          std::cout << distance(\"0,0\"_ip, \"30,40\"_ip) << '\\n';\n       }\n    } \n    ```", "```cpp\n#include <iostream>\nint main()\n{\n   std::cout << \"Hello, world!\\n\";\n} \n```", "```cpp\nimport std;\nint main()\n{\n   std::println(\"Hello, world!\");\n} \n```", "```cpp\n    // --- geometry-core.ixx/.cppm ---\n    export module geometry:core;\n    import std;\n    export template <class T,\n       typename = typename std::enable_if_t<std::is_arithmetic_v<T>, T>>\n    struct point\n    {\n       T x;\n       T y;\n    };\n    export using int_point = point<int>;\n    export constexpr int_point int_point_zero{ 0,0 };\n    export template <class T>\n    double distance(point<T> const& p1, point<T> const& p2)\n    {\n       return std::sqrt((p2.x - p1.x) * (p2.x - p1.x) +\n                        (p2.y - p1.y) * (p2.y - p1.y));\n    }\n    // --- geometry-literals.ixx/.cppm ---\n    export module geometry:literals;\n    import :core;\n    namespace geometry_literals\n    {\n       export int_point operator \"\"_ip(const char* ptr, std::size_t)\n       {\n          int x = 0, y = 0;\n          if(ptr)\n          {\n    while (*ptr != ',' && *ptr != ' ')\n                x = x * 10 + (*ptr++ - '0');\n             while (*ptr == ',' || *ptr == ' ') ptr++;\n             while (*ptr != 0)\n                y = y * 10 + (*ptr++ - '0');\n          }\n          return { x, y };\n       }\n    } \n    ```", "```cpp\n    // --- geometry.ixx/.cppm ---\n    export module geometry;\n    export import :core;\n    export import :literals; \n    ```", "```cpp\n    // --- main.cpp ---\n    import std;\n    import geometry;\n    int main()\n    {\n       int_point p{ 3, 4 };\n       std::cout << distance(int_point_zero, p) << '\\n';\n       {\n          using namespace geometry_literals;\n          std::cout << distance(\"0,0\"_ip, \"30,40\"_ip) << '\\n';\n       }\n    } \n    ```", "```cpp\n    // --- geometry-details.cpp --\n    module geometry:details;\n    import std;\n    std::pair<int, int> split(const char* ptr)\n    {\n      int x = 0, y = 0;\n      if(ptr)\n      {\n    while (*ptr != ',' && *ptr != ' ')\n          x = x * 10 + (*ptr++ - '0');\n        while (*ptr == ',' || *ptr == ' ') ptr++;\n        while (*ptr != 0)\n          y = y * 10 + (*ptr++ - '0');\n      }\n      return { x, y };\n    }\n    // --- geometry-literals.ixx/.cppm ---\n    export module geometry:literals;\n    import :core;\n    import :details;\n    namespace geometry_literals\n    {\n      export int_point operator \"\"_ip(const char* ptr, std::size_t)\n      {\n        auto [x, y] = split(ptr);\n        return {x, y};\n      }\n    } \n    ```", "```cpp\n// --- geometry-literals.ixx/.cppm ---\nexport module geometry:literals;\n// import the core partition\nimport :core;\n// --- geometry.ixx/.cppm ---\nexport module geometry;\n// import the core partition and then export it\nexport import :core;\n// import the literals partition and then export it\nexport import :literals; \n```", "```cpp\n// --- geometry-core.ixx ---\nexport module geometry.core;\nimport std;\nexport template <class T,\n   typename = typename std::enable_if_t<std::is_arithmetic_v<T>, T>>\nstruct point\n{\n   T x;\n   T y;\n};\nexport using int_point = point<int>;\nexport constexpr int_point int_point_zero{ 0,0 };\nexport template <class T>\ndouble distance(point<T> const& p1, point<T> const& p2)\n{\n   return std::sqrt(\n      (p2.x - p1.x) * (p2.x - p1.x) +\n      (p2.y - p1.y) * (p2.y - p1.y));\n}\n// --- geometry-literals.ixx ---\nexport module geometry.literals;\nimport geometry.core;\nnamespace geometry_literals\n{\n   export int_point operator \"\"_ip(const char* ptr, std::size_t)\n   {\n      int x = 0, y = 0;\n      if(ptr)\n      {\nwhile (*ptr != ',' && *ptr != ' ')\n            x = x * 10 + (*ptr++ - '0');\n         while (*ptr == ',' || *ptr == ' ') ptr++;\n         while (*ptr != 0)\n            y = y * 10 + (*ptr++ - '0');\n      }\n      return { x, y };\n   }\n}\n// --- geometry.ixx ---\nexport module geometry;\nexport import geometry.core;\nexport import geometry.literals; \n```", "```cpp\nimport std;\nimport geometry.core;\nimport geometry.literals;\nint main()\n{\n   int_point p{ 3, 4 };\n   std::cout << distance(int_point_zero, p) << '\\n';\n   {\n      using namespace geometry_literals;\n      std::cout << distance(\"0,0\"_ip, \"30,40\"_ip) << '\\n';\n   }\n} \n```", "```cpp\ntemplate <typename T>,\n          typename = typename std::enable_if_t<std::is_arithmetic_v<T>, T>>\nstruct NumericalValue\n{\n  T value;\n};\ntemplate <typename T>\nNumericalValue<T> wrap(T value) { return { value }; }\ntemplate <typename T>\nT unwrap(NumericalValue<T> t) { return t.value; }\nauto nv = wrap(42);\nstd::cout << nv.value << '\\n';   // prints 42\nauto v = unwrap(nv);\nstd::cout << v << '\\n';          // prints 42\nusing namespace std::string_literals;\nauto ns = wrap(\"42\"s);           // error \n```", "```cpp\n    template <class T>\n    concept Numerical = std::is_arithmetic_v<T>; \n    ```", "```cpp\n    template <class T>\n    concept Numerical = std::integral<T> || std::floating_point<T>; \n    ```", "```cpp\n    template <Numerical T>\n    struct NumericalValue\n    {\n      T value;\n    };\n    template <Numerical T>\n    NumericalValue<T> wrap(T value) { return { value }; }\n    template <Numerical T>\n    T unwrap(NumericalValue<T> t) { return t.value; } \n    ```", "```cpp\n    auto nv = wrap(42);\n    std::cout << nv.value << '\\n';   // prints 42\n    auto v = unwrap(nv);\n    std::cout << v << '\\n';          // prints 42\n    using namespace std::string_literals;\n    auto ns = wrap(\"42\"s);           // error \n    ```", "```cpp\ntemplate <class T>\nconcept Real = std::is_floating_point_v<T>;\ntemplate<Real T>\nconstexpr T pi = T(3.1415926535897932385L);\nstd::cout << pi<double> << '\\n';\nstd::cout << pi<int>    << '\\n'; // error \n```", "```cpp\ntemplate <class T>\nconcept Integral = std::is_integral_v<T>;\ntemplate <class T>\nconcept Real = std::is_floating_point_v<T>; \n```", "```cpp\ntemplate <class T>\nconcept Numerical = Integral<T> || Real<T>; \n```", "```cpp\nstruct IComparableToInt\n{\n  virtual bool CompareTo(int const o) = 0;\n};\nstruct IConvertibleToInt\n{\n  virtual int ConvertTo() = 0;\n}; \n```", "```cpp\ntemplate <typename T>\nstruct SmartNumericalValue : public IComparableToint, IConvertibleToInt\n{\n  T value;\n  SmartNumericalValue(T v) :value(v) {}\n  bool CompareTo(int const o) override\n { return static_cast<int>(value) == o; }\n  int ConvertTo() override\n { return static_cast<int>(value); }\n};\ntemplate <typename T>\nstruct DullNumericalValue : public IConvertibleToInt\n{\n  T value;\n  DullNumericalValue(T v) :value(v) {}\n  int ConvertTo() override\n { return static_cast<int>(value); }\n}; \n```", "```cpp\ntemplate <class T>\nconcept IntComparable = std::is_base_of_v<IComparableToInt, T>;\ntemplate <class T>\nconcept IntConvertible = std::is_base_of_v<IConvertibleToInt, T>;\ntemplate <class T>\nconcept IntComparableAndConvertible = IntComparable<T> && IntConvertible<T>;\ntemplate <IntComparableAndConvertible T>\nvoid print(T o)\n{\n  std::cout << o.value << '\\n';\n}\nint main()\n{\n   auto snv = SmartNumericalValue<double>{ 42.0 };\n   print(snv);                      // prints 42\nauto dnv = DullNumericalValue<short>{ 42 };\n   print(dnv);                      // error\n} \n```", "```cpp\n    template <typename T>\n    concept Addable = requires (T a, T b) {a + b;};\n    template <Addable T>\n    T add(T a, T b)\n    {\n      return a + b;\n    }\n    add(1, 2);        // OK, integers\n    add(\"1\"s, \"2\"s);  // OK, std::string user-defined literals\n    NumericalValue<int> a{1};\n    NumericalValue<int> b{2};\n    add(a, b); // error: no matching function for call to 'add'\n    // 'NumericalValue<int>' does not satisfy 'Addable' \n    ```", "```cpp\n    template <typename T>\n    concept Wrapable = requires(T x) { wrap(x); };\n    template <Wrapable T>\n    void do_wrap(T x)\n    {\n      [[maybe_unused]] auto v = wrap(x);\n    }\n    do_wrap(42);    // OK, can wrap an int\n    do_wrap(42.0);  // OK, can wrap a double\n    do_wrap(\"42\"s); // error, cannot wrap a std::string \n    ```", "```cpp\n    template <typename T>\n    concept Container = requires(T x)\n    {\n      typename T::value_type;\n      typename T::iterator;\n      begin(x);\n      end(x);\n    };\n    template <Container T>\n    void pass_container(T const & c)\n    {\n      for(auto const & x : c)\n        std::cout << x << '\\n';\n    }\n    std::vector<int> v { 1, 2, 3};\n    std::array<int, 3> a {1, 2, 3};\n    int arr[] {1,2,3};\n    pass_container(v);   // OK\n    pass_container(a);   // OK\n    pass_container(arr); // error: 'int [3]' does not satisfy\n    // 'Container' \n    ```", "```cpp\n    template <typename T>\n    concept NumericalWrapable =\n    requires(T x)\n    {\n      {wrap(x)} -> std::same_as<NumericalValue<T>>;\n    };\n    template <NumericalWrapable T>\n    void do_wrap_numerical(T x)\n    {\n      [[maybe_unused]] auto v = wrap(x);\n    }\n    template <typename T>\n    class any_wrapper\n    {\n    public:\n      T value;\n    };\n    any_wrapper<std::string> wrap(std::string s)\n    {\n      return any_wrapper<std::string>{s};\n    }\n    // OK, wrap(int) returns NumericalValue<int>\n    do_wrap_numerical(42);\n    // error, wrap(string) returns any_wrapper<string>\n    do_wrap_numerical(\"42\"s); \n    ```", "```cpp\n    template <typename T> requires Addable<T>\n    T add(T a, T b)\n    {\n      return a + b;\n    } \n    ```", "```cpp\n    template <typename T>\n    T add(T a, T b) requires Addable<T>\n    {\n      return a + b;\n    } \n    ```", "```cpp\n    template <typename T>\n    T add(T a, T b) requires requires (T a, T b) {a + b;}\n    {\n      return a + b;\n    } \n    ```", "```cpp\n    auto sum(auto a, auto b)\n    {\n       return a + b;\n    }\n    auto a = sum(40, 2);    // 42\n    auto b = sum(42.0, 2);  // 44.0 \n    ```", "```cpp\n    auto sum(std::integral auto a, std::integral auto b)\n    {\n       return a + b;\n    }\n    auto a = sum(40, 2);    // 42\n    auto b = sum(42.0, 2);  // error \n    ```", "```cpp\n    auto sum(std::integral auto ... args)\n    {\n       return (args + ...);\n    }\n    auto a = sum(10, 30, 2);   // 42 \n    ```", "```cpp\n    int main()\n    {\n       auto lsum = [](std::integral auto a, std::integral auto b)\n       {\n          return a + b;\n       };\n       auto a = lsum(40, 2);    // 42\n    auto b = lsum(42.0, 2);  // error\n    } \n    ```", "```cpp\n    auto sum(auto a, auto b)\n    {\n       return a + b;\n    }\n    template <>\n    auto sum(char const* a, char const* b)\n    {\n       return std::string(a) + std::string(b);\n    }\n    auto a = sum(40, 2);       // 42\n    auto b = sum(\"40\", \"2\");   // \"402\" \n    ```", "```cpp\nauto sum(auto a, auto b)\n{\n   return a + b;\n}\ntemplate <typename T, typename U>\nauto sum(T a, U b)\n{\n   return a + b;\n} \n```", "```cpp\nauto sum(std::integral auto a, std::integral auto b)\n{\n   return a + b;\n} \n```", "```cpp\ntemplate <typename T>\nT sum(T a, T b);\ntemplate<>\nint sum(int a, int b)\n{\n   return a + b;\n} \n```", "```cpp\ntemplate <>\nauto sum(char const* a, char const* b)\n{\n   return std::string(a) + std::string(b);\n} \n```", "```cpp\nbool is_prime(int const number)\n{\n  if (number != 2)\n  {\n    if (number < 2 || number % 2 == 0) return false;\n    auto root = std::sqrt(number);\n    for (int i = 3; i <= root; i += 2)\n      if (number % i == 0) return false;\n  }\n  return true;\n} \n```", "```cpp\nnamespace rv = std::ranges::views;\nnamespace rg = std::ranges; \n```", "```cpp\n    for (auto i : rv::iota(1, 10))\n      std::cout << i << ' '; \n    ```", "```cpp\n    // prints 2 3 5 7 11 13 ... 79 83 89 97\n    for (auto i : rv::iota(1, 100) | rv::filter(is_prime))\n      std::cout << i << ' ';\n    // prints 2 3 5 13\n    std::vector<int> nums{ 1, 1, 2, 3, 5, 8, 13, 21 };\n    for (auto i : nums | rv::filter(is_prime))\n      std::cout << i << ' '; \n    ```", "```cpp\n    // prints 3 4 6 8 12 14 ... 80 84 90 98\n    for (auto i : rv::iota(1, 100) |\n                  rv::filter(is_prime) |\n                  rv::transform([](int const n) {return n + 1; }))\n      std::cout << i << ' '; \n    ```", "```cpp\n    // prints 2 3 5 7 11 13 17 19 23 29\n    for (auto i : rv::iota(1, 100) |\n                  rv::filter(is_prime) |\n                  rv::take(10))\n      std::cout << i << ' '; \n    ```", "```cpp\n    // prints 97 89 83 79 73 71 67 61 59 53\n    for (auto i : rv::iota(1, 100) |\n                  rv::reverse |\n                  rv::filter(is_prime) |\n                  rv::take(10))\n      std::cout << i << ' ';\n    // prints 53 59 61 67 71 73 79 83 89 97\n    for (auto i : rv::iota(1, 100) |\n                  rv::reverse |\n                  rv::filter(is_prime) |\n                  rv::take(10) |\n                  rv::reverse)\n      std::cout << i << ' '; \n    ```", "```cpp\n    // prints 31 37 41 43 47\n    for (auto i : rv::iota(1, 100) |\n                  rv::filter(is_prime) |\n                  rv::drop(10) |\n                  rv::reverse |\n                  rv::drop(10) |\n                  rv::reverse)\n      std::cout << i << ' '; \n    ```", "```cpp\n    std::vector<int> v{ 5, 2, 7, 1, 4, 2, 9, 5 };\n    auto m = rg::max(v); // 5 \n    ```", "```cpp\n    rg::sort(v); // 1 2 2 4 5 5 7 9 \n    ```", "```cpp\n    rg::copy(v, std::ostream_iterator<int>(std::cout, \" \")); \n    ```", "```cpp\n    rg::reverse(v); \n    ```", "```cpp\n    auto primes = rg::count_if(v, is_prime); \n    ```", "```cpp\nstd::vector<int> nums{ 1, 1, 2, 3, 5, 8, 13, 21 };\nauto v = nums | rv::filter(is_prime) | rv::take(3) | rv::reverse;\nfor (auto i : v) std::cout << i << ' '; // prints 5 3 2 \nfor statement. The views are said to be lazy. The pipe operator (|) is overloaded to simplify the composition of views.\n```", "```cpp\nauto v = rv::reverse(rv::take(rv::filter(nums, is_prime), 3)); \n```", "```cpp\n#include \"range/v3/view.hpp\"\n#include \"range/v3/algorithm/sort.hpp\"\n#include \"range/v3/algorithm/copy.hpp\"\n#include \"range/v3/algorithm/reverse.hpp\"\n#include \"range/v3/algorithm/count_if.hpp\"\n#include \"range/v3/algorithm/max.hpp\"\nnamespace rv = ranges::views;\nnamespace rg = ranges; \n```", "```cpp\nnamespace rv = std::ranges::views;\nnamespace rg = std::ranges; \n```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto primes = numbers | rv::filter(is_prime);\n    rg::copy(primes, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    2 3 5 13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto letters = numbers | \n                   rv::transform([](int i) { \n                      return static_cast<char>('A' + i); });\n    rg::copy(letters, std::ostream_iterator<char>{ std::cout, \" \" }); \n    ```", "```cpp\n    B B C D F I N \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto some_numbers = numbers | rv::take(3);\n    rg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 1 2 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto some_numbers = numbers | \n                        rv::take_while([](int i) { \n                           return i < 3; });});\n    rg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 1 2 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto some_numbers = numbers | rv::drop(3);\n    rg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    3 5 8 13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto some_numbers = numbers | \n                        rv::drop_while([](int i) { \n                           return i < 3; });\n    rg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    3 5 8 13 \n    ```", "```cpp\n    std::vector<std::vector<int>> numbers{ {1, 1}, {2, 3}, {5, 8}, {13} };\n    auto joined_numbers = numbers | rv::join;\n    rg::copy(joined_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 1 2 3 5 8 13 \n    ```", "```cpp\n    std::string text{ \"Hello, world!\" };\n    auto words = text | rv::split(' ');\n    for (auto const word : words)\n    {\n       std::cout << std::quoted(std::string_view(word)) << ' ';\n    } \n    ```", "```cpp\n    \"Hello,\" \"world!\" \n    ```", "```cpp\n    std::string text{ \"Hello, world!\" };\n    auto words = text | rv::lazy_split(' ');\n    for (auto const word : words)\n    {\n       std::cout << \n          std::quoted(std::ranges::to<std::string>(word)) << ' ';\n    } \n    ```", "```cpp\n    \"Hello,\" \"world!\" \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto reversed_numbers = numbers | rv::reverse;\n    rg::copy(reversed_numbers, \n             std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    13 8 5 3 2 1 1 \n    ```", "```cpp\n    std::vector<std::tuple<int, std::string_view>> numbers{\n       {1, \"one\"},\n       {1, \"one\"},\n       {2, \"two\"},\n       {3, \"three\"},\n       {5, \"five\"},\n       {8, \"eight\"},\n       {13, \"thirteen\"} };\n    auto some_numbers = numbers | rv::elements<0>;\n    rg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 1 2 3 5 8 13 \n    ```", "```cpp\n    auto some_names = numbers | rv::elements<1>;\n    rg::copy(some_names, \n             std::ostream_iterator<std::string_view>{ std::cout, \" \" }); \n    ```", "```cpp\n    one one two three five eight thirteen \n    ```", "```cpp\nstd::vector<std::pair<int, std::string_view>> numbers{\n   {1, \"one\"},\n   {1, \"one\"},\n   {2, \"two\"},\n   {3, \"three\"},\n   {5, \"five\"},\n   {8, \"eight\"},\n   {13, \"thirteen\"} };\nauto some_numbers = numbers | rv::keys;\nrg::copy(some_numbers, std::ostream_iterator<int>{ std::cout, \" \" }); \n```", "```cpp\n1 1 2 3 5 8 13 \n```", "```cpp\nauto some_names = numbers | rv::values;\nrg::copy(some_names, \n         std::ostream_iterator<std::string_view>{ std::cout, \" \" }); \n```", "```cpp\none one two three five eight thirteen \n```", "```cpp\n    std::vector<std::string> words{ \"one\", \"two\", \"three\", \n                                    \"four\", \"five\" };\n    auto enumerated_words = words | rv::enumerate;\n    for (auto const [index, word] : enumerated_words)\n    {\n       std::println(\"{} : {}\", index, word);\n    } \n    ```", "```cpp\n    0 : one\n    1 : two\n    2 : three\n    3 : four\n    4 : five \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    std::vector<std::string> words{ \"one\", \"two\", \"three\", \n                                    \"four\", \"five\" };\n    auto zipped = rv::zip(numbers, words);\n    for (auto const [number, word] : zipped)\n    {\n       std::println(\"{} : {}\", number, word);\n    } \n    ```", "```cpp\n    1 : one\n    1 : two\n    2 : three\n    3 : four\n    5 : five \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    std::vector<std::string> words{ \"one\", \"two\", \"three\", \n                                    \"four\", \"five\" };\n    auto zipped = rv::zip_transform(\n       [](int number, std::string word) {\n          return std::to_string(number) + \" : \" + word;\n       },\n       numbers, \n       words);\n    std::ranges::for_each(zipped, \n                          [](auto e) {std::println(\"{}\", e); }); \n    ```", "```cpp\n    1 : one\n    1 : two\n    2 : three\n    3 : four\n    5 : five \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto adjacent_numbers = numbers | rv::adjacent<3>;\n    std::ranges::for_each(\n       adjacent_numbers, \n       [](auto t) {\n          auto [a, b, c] = t;\n          std::println(\"{},{},{}\", a, b, c); \n       }); \n    ```", "```cpp\n    1,1,2\n    1,2,3\n    2,3,5\n    3,5,8\n    5,8,13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto adjacent_numbers = \n       numbers | \n       rv::adjacent_transform<3>(\n          [](int a, int b, int c) {return a * b * c; });\n    std::ranges::for_each(adjacent_numbers, \n                          [](auto e) {std::print(\"{} \", e); }); \n    ```", "```cpp\n    2 6 30 120 520 \n    ```", "```cpp\n    std::vector<std::vector<int>> numbers{ {1, 1, 2}, {3, 5, 8}, \n                                           {13} };\n    auto joined_numbers = numbers | rv::join_with(0);\n    rg::copy(joined_numbers, \n             std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 1 2 0 3 5 8 0 13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto slide_numbers = numbers | rv::slide(3);\n    std::ranges::for_each(\n       slide_numbers,\n       [](auto r) {\n          rg::copy(r, std::ostream_iterator<int>{ std::cout, \" \" });\n          std::println(\"\");\n       }); \n    ```", "```cpp\n    1 1 2\n    1 2 3\n    2 3 5\n    3 5 8\n    5 8 13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto chunk_numbers = numbers | rv::chunk(3);\n    std::ranges::for_each(\n       chunk_numbers,\n       [](auto r) {\n          rg::copy(r, std::ostream_iterator<int>{ std::cout, \" \" });\n          std::println(\"\");\n       }); \n    ```", "```cpp\n    1 1 2\n    3 5 8\n    13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto chunk_numbers = \n       numbers | \n       rv::chunk_by([](int a, int b) {return a * b % 2 == 1; });\n    std::ranges::for_each(\n       chunk_numbers,\n       [](auto r) {\n          rg::copy(r, std::ostream_iterator<int>{ std::cout, \" \" });\n          std::println(\"\");\n       }); \n    ```", "```cpp\n    1 1\n    2\n    3 5\n    8\n    13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    auto stride_numbers = numbers | rv::stride(3);\n    rg::copy(stride_numbers, \n             std::ostream_iterator<int>{ std::cout, \" \" }); \n    ```", "```cpp\n    1 3 13 \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 2 };\n    std::vector<std::string> words{ \"one\", \"two\", \"three\" };\n    auto product = rv::cartesian_product(numbers, words);\n    rg::for_each(\n       product,\n       [](auto t) {\n          auto [number, word] = t;\n          std::println(\"{} : {}\", number, word);\n       }); \n    ```", "```cpp\n    1 : one\n    1 : two\n    1 : three\n    2 : one\n    2 : two\n    2 : three \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    std::vector<int> primes = numbers | \n                              std::views::filter(is_prime) | \n                              std::ranges::to<std::vector>();\n    std::ranges::copy(primes, \n                      std::ostream_iterator<int>(std::cout, \" \"));\n    std::println(\"\");\n    std::string text{ \"server=demo123;db=optimus\" };\n    auto parts = text | \n                 std::views::lazy_split(';') | \n                 std::ranges::to<std::vector<std::string>>();\n    std::ranges::copy(parts, \n                      std::ostream_iterator<std::string>(std::cout, \" \"));\n    std::println(\"\"); \n    ```", "```cpp\n    std::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\n    std::vector<std::string> words{\"one\", \"two\", \"three\", \"four\"};\n    auto zipped = std::views::zip(numbers, words) | \n                  std::ranges::to<\n                     std::unordered_multimap<int, std::string>>();\n    for (auto const [number, word] : zipped)\n    {\n       std::println(\"{} = {}\", number, word);\n    } \n    ```", "```cpp\n    std::string text{ \"server=demo123;db=optimus\" };\n    std::string text2 = text | \n                        std::views::stride(3) | \n                        std::ranges::to<std::string>();\n    std::println(\"{}\", text2); \n    ```", "```cpp\nstd::vector<int> numbers{ 1, 1, 2, 3, 5, 8, 13 };\nstd::list<int> list = numbers | std::ranges::to<std::list>(); \nstd::list and not std::list<int>. However, there are scenarios where this is not possible, and you will get compiler errors unless you explicitly provide the full type. Such an example is shown next:\n```", "```cpp\nstd::map<int, std::string> m{ {1, \"one\"}, {2, \"two\"}, {3, \"three\"} };\nstd::vector<std::pair<int, std::string>> words = \n   m | rg::to<std::vector<std::pair<int, std::string>>>(); \n```", "```cpp\nstd::vector<int> v {1, 1, 2, 3, 5, 8};\nauto r = v | std::ranges::to<std::vector>;   // error \n```", "```cpp\nauto r = v | std::ranges::to<std::vector>();  // OK \n```", "```cpp\n    template<rg::input_range R, typename P>\n        requires rg::view<R>\n    class trim_view :\n        public rg::view_interface<trim_view<R, P>>\n    {\n    }; \n    ```", "```cpp\n    private:\n      R base_ {};\n      P pred_;\n      mutable rg::iterator_t<R> begin_ {std::begin(base_)};\n      mutable rg::iterator_t<R> end_   {std::end(base_)};\n      mutable bool evaluated_ = false;\n      void ensure_evaluated() const\n     {\n        if(!evaluated_)\n        {\n          while(begin_ != std::end(base_) && pred_(*begin_))\n          {begin_ = std::next(begin_);}\n          while(end_ != begin_ && pred_(*std::prev(end_)))\n          {end_ = std::prev(end_);}\n          evaluated_ = true;\n        }\n      } \n    ```", "```cpp\n    public:\n      trim_view() = default;\n      constexpr trim_view(R base, P pred)\n        : base_(std::move(base))\n        , pred_(std::move(pred))\n        , begin_(std::begin(base_))\n        , end_(std::end(base_))\n      {} \n    ```", "```cpp\n     constexpr R base() const &       {return base_;}\n      constexpr R base() &&            {return std::move(base_);}\n      constexpr P const & pred() const { return pred_; } \n    ```", "```cpp\n     constexpr auto begin() const\n     { ensure_evaluated(); return begin_; }\n      constexpr auto end() const\n     { ensure_evaluated(); return end_ ; } \n    ```", "```cpp\n     constexpr auto size() requires rg::sized_range<R>\n     { return std::distance(begin_, end_); }\n      constexpr auto size() const requires rg::sized_range<const R>\n     { return std::distance(begin_, end_); } \n    ```", "```cpp\ntemplate<rg::input_range R, typename P> requires rg::view<R>\nclass trim_view : public rg::view_interface<trim_view<R, P>>\n{\nprivate:\n  R base_ {};\n  P pred_;\n  mutable rg::iterator_t<R> begin_ {std::begin(base_)};\n  mutable rg::iterator_t<R> end_   {std::end(base_)};\n  mutable bool evaluated_ = false;\nprivate:\n  void ensure_evaluated() const\n {\n    if(!evaluated_)\n    {\n      while(begin_ != std::end(base_) && pred_(*begin_))\n      {begin_ = std::next(begin_);}\n      while(end_ != begin_ && pred_(*std::prev(end_)))\n      {end_ = std::prev(end_);}\n      evaluated_ = true;\n    }\n  }\npublic:\n  trim_view() = default;\n  constexpr trim_view(R base, P pred)\n    : base_(std::move(base))\n    , pred_(std::move(pred))\n    , begin_(std::begin(base_))\n    , end_(std::end(base_))\n  {}\n  constexpr R base() const &       {return base_;}\n  constexpr R base() &&            {return std::move(base_);}\n  constexpr P const & pred() const { return pred_; }\n  constexpr auto begin() const\n { ensure_evaluated(); return begin_; }\n  constexpr auto end() const\n { ensure_evaluated(); return end_ ; }\n  constexpr auto size() requires rg::sized_range<R>\n { return std::distance(begin_, end_); }\n  constexpr auto size() const requires rg::sized_range<const R>\n { return std::distance(begin_, end_); }\n}; \n```", "```cpp\n    template<class R, typename P>\n    trim_view(R&& base, P pred)\n      -> trim_view<rg::views::all_t<R>, P>; \n    ```", "```cpp\n    namespace details\n    {\n      template <typename P>\n      struct trim_view_range_adaptor_closure\n      {\n        P pred_;\n        constexpr trim_view_range_adaptor_closure(P pred)\n          : pred_(pred)\n        {}\n        template <rg::viewable_range R>\n        constexpr auto operator()(R && r) const\n     {\n          return trim_view(std::forward<R>(r), pred_);\n        }\n      };\n      struct trim_view_range_adaptor\n      {\n        template<rg::viewable_range R, typename P>\n     constexpr auto operator () (R && r, P pred)\n     {\n          return trim_view( std::forward<R>(r), pred ) ;\n        }\n        template <typename P>\n        constexpr auto operator () (P pred)\n     {\n          return trim_view_range_adaptor_closure(pred);\n        }\n      };\n    } \n    ```", "```cpp\n    namespace details\n    {\n      template <rg::viewable_range R, typename P>\n      constexpr auto operator | (\n        R&& r,\n        trim_view_range_adaptor_closure<P> const & a)\n      {\n        return a(std::forward<R>(r)) ;\n      }\n    } \n    ```", "```cpp\n    namespace views\n    {\n      inline static details::trim_view_range_adaptor trim;\n    } \n    ```", "```cpp\nauto is_odd = [](int const n){return n%2 == 1;};\nstd::vector<int> n { 1,1,2,3,5,6,4,7,7,9 };\nauto v = trim_view(n, is_odd);\nrg::copy(v, std::ostream_iterator<int>(std::cout, \" \"));\n// prints 2 3 5 6 4\nfor(auto i : rv::reverse(trim_view(n, is_odd)))\n  std::cout << i << ' ';\n// prints 4 6 5 3 2 \n```", "```cpp\nauto v = n | views::trim(is_odd);\nrg::copy(v, std::ostream_iterator<int>(std::cout, \" \"));\nfor(auto i : n | views::trim(is_odd) | rv::reverse)\n  std::cout << i << ' '; \n```", "```cpp\n    std::vector<int> v(5);\n    std::ranges::fill(v, 42);\n    // v = {42, 42, 42, 42, 42} \n    ```", "```cpp\n    std::vector<int> v(10);\n    std::ranges::fill_n(v.begin(), 5, 42);\n    // v = {42, 42, 42, 42, 42, 0, 0, 0, 0, 0} \n    ```", "```cpp\n    std::vector<int> v(5);\n    auto i = 1;\n    std::ranges::generate_n(v.begin(), v.size(), \n                            [&i] { return I * i++; });\n    // v = {1, 4, 9, 16, 25} \n    ```", "```cpp\n    std::vector<int> v(5);\n    std::ranges::iota(v, 1);\n    // v = {1, 2, 3, 4, 5} \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto it = std::ranges::find(v, 3);\n    if (it != v.cend()) std::cout << *it << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto it = std::ranges::find_if(v, [](int const n) { return n > 10; });\n    if (it != v.cend()) std::cout << *it << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    std::vector<int> p{ 5, 7, 11 };\n    auto it = std::ranges::find_first_of(v, p);\n    if (it != v.cend())\n       std::cout << \"found \" << *it\n       << \" at index \" << std::ranges::distance(v.cbegin(), it)\n       << '\\n'; \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    std::ranges::sort(v);\n    // v = {1, 1, 2, 3, 5, 8, 13}\n    std::ranges::sort(v, std::ranges::greater());\n    // v = {13, 8, 5, 3, 2, 1 ,1} \n    ```", "```cpp\n    std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n    auto sorted = std::ranges::is_sorted(v);\n    sorted = std::ranges::is_sorted(v, std::ranges::greater()); \n    ```", "```cpp\n    std::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\n    auto it = std::ranges::is_sorted_until(v);\n    auto length = std::ranges::distance(v.cbegin(), it);\n    // length = 2 \n    ```", "```cpp\ntemplate <ranges::input_range R, class T, class Proj = std::identity>\nrequires std::indirect_binary_predicate<\n    ranges::equal_to,\n    std::projected<ranges::iterator_t<R>, Proj>,\n    const T*>\nconstexpr ranges::borrowed_iterator_t<R>\n    find( R&& r, const T& value, Proj proj = {} ); \nstd::ranges::find() algorithm, also presented in the previous section, invoked with a beginning and ending iterator:\n```", "```cpp\nstd::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\nauto it = std::ranges::find(v.begin(), v.end(), 3);\nif (it != v.cend()) std::cout << *it << '\\n'; \n```", "```cpp\nstd::vector<int> v{ 3, 13, 5, 8, 1, 2, 1 };\nauto range =\n   v |\n   std::views::filter([](int const n) {return n % 2 == 1; }) |\n   std::views::transform([](int const n) {return n * n; }) |\n   std::views::take(4);\nstd::ranges::for_each(range, \n                      [](int const n) {std::cout << n << ' '; });\nstd::cout << '\\n';\nauto it = std::ranges::find_if(range, \n                               [](int const n) {return n > 10; });\nif (it != range.end())\n   std::cout << *it << '\\n'; \n```", "```cpp\nstruct Product\n{\n   int         id;\n   std::string name;\n   double      price;\n};\nstd::vector<Product> products\n{\n   {1, \"pen\", 15.50},\n   {2, \"pencil\", 9.99},\n   {3, \"rubber\", 5.0},\n   {4, \"ruler\", 5.50},\n   {5, \"notebook\", 12.50}\n}; \n```", "```cpp\nauto pos = std::find_if(\n   products.begin(), products.end(),\n   [](Product const& p) { return p.price == 12.5; });\nif (pos != products.end())\n   std::cout << pos->name << '\\n'; \n```", "```cpp\nauto it = std::ranges::find(products, 12.50, &Product::price);\nif (it != products.end())\n   std::cout << it->name << '\\n'; \n```", "```cpp\nstd::ranges::sort(products, std::ranges::less(), &Product::name);\nstd::ranges::for_each(products, [](Product const& p) {\n      std::cout << std::format(\"{} = {}\\n\", p.name, p.price); }); \n```", "```cpp\ntask<int> get_answer()\n{\n  co_return 42;\n}\ntask<> print_answer()\n{\n  auto t = co_await get_answer();\n  std::cout << \"the answer is \" << t << '\\n';\n}\ntemplate <typename T>\nvoid execute(T&& t)\n{\n  while (!t.is_ready()) t.resume();\n};\nint main()\n{\n  auto t = get_answer();\n  execute(t);\n  std::cout << \"the answer is \" << t.value() << '\\n';\n  execute(print_answer());\n} \n```", "```cpp\n    namespace details\n    {\n      struct promise_base\n      {\n        auto initial_suspend() noexcept\n     { return std::suspend_always{}; }\n        auto final_suspend() noexcept\n     { return std::suspend_always{}; }\n        void unhandled_exception()\n     { std::terminate(); }\n       };\n    } \n    ```", "```cpp\n    template <typename T>\n    struct task;\n    namespace details\n    {\n      template <typename T>\n      struct promise final : public promise_base\n      {\n        task<T> get_return_object() noexcept;\n        template<typename V,\n                 typename = std::enable_if_t<\n                    std::is_convertible_v<V&&, T>>>\n        void return_value(V&& value)\n        noexcept(std::is_nothrow_constructible_v<T, V&&>)\n        {\n          value_ = value;\n        }\n        T get_value() const noexcept { return value_; }\n      private:\n        T value_;\n      };\n    } \n    ```", "```cpp\n    namespace details\n    {\n      template <>\n      struct promise<void> final : public promise_base\n      {\n        task<void> get_return_object() noexcept;\n        void return_void() noexcept {}\n      };\n    } \n    ```", "```cpp\n    namespace details\n    {\n      template <typename T>\n      struct promise<T&> final : public promise_base\n      {    \n        task<T&> get_return_object() noexcept;\n        void return_value(T& value) noexcept\n     {\n          value_ = std::addressof(value);\n        }\n        T& get_value() const noexcept { return *value_; }\n      private:\n        T* value_ = nullptr;\n      };\n    } \n    ```", "```cpp\n    template <typename T = void>\n    struct task\n    {\n      using promise_type = details::promise<T>;\n      // task_awaiter\n    // members\n    private:\n      std::coroutine_handle<promise_type> handle_ = nullptr;\n    }; \n    ```", "```cpp\n    struct task_awaiter\n    {\n      task_awaiter(std::coroutine_handle<promise_type> coroutine)\n      noexcept\n        : handle_(coroutine)\n      {}\n      bool await_ready() const noexcept\n     {\n         return !handle_ || handle_.done();\n      }\n      void await_suspend(\n        std::coroutine_handle<> continuation) noexcept\n     {\n        handle_.resume();\n      }\n      decltype(auto) await_resume()\n     {\n        if (!handle_)\n          throw std::runtime_error{ \"broken promise\" };\n        return handle_.promise().get_value();\n      }\n      friend struct task<T>;\n    private:\n      std::coroutine_handle<promise_type> handle_;\n    }; \n    ```", "```cpp\n    explicit task(std::coroutine_handle<promise_type> handle)\n      : handle_(handle)\n    {\n    }\n    ~task()\n    {\n      if (handle_) handle_.destroy();\n    }\n    task(task&& t) noexcept : handle_(t.handle_)\n    {\n      t.handle_ = nullptr;\n    }\n    task& operator=(task&& other) noexcept\n    {\n      if (std::addressof(other) != this)\n      {\n        if (handle_) handle_.destroy();\n        handle_ = other.handle_;\n        other.handle_ = nullptr;\n      }\n      return *this;\n    }\n    task(task const &) = delete;\n    task& operator=(task const &) = delete;\n    T value() const noexcept\n    { return handle_.promise().get_value(); }\n    void resume() noexcept\n    { handle_.resume(); }\n    bool is_ready() const noexcept\n    { return !handle_ || handle_.done(); }\n    auto operator co_await() const& noexcept\n    {\n      return task_awaiter{ handle_ };\n    } \n    ```", "```cpp\n    namespace details\n    {\n       template <typename T>\n       task<T> promise<T>::get_return_object() noexcept\n       {\n          return task<T>{\n            std::coroutine_handle<promise<T>>::from_promise(*this)};\n       }\n       task<void> promise<void>::get_return_object() noexcept\n       {\n          return task<void>{\n            std::coroutine_handle<promise<void>>::from_promise(*this)};\n       }\n       template <typename T>\n       task<T&> promise<T&>::get_return_object() noexcept\n       {\n          return task<T&>{\n            std::coroutine_handle<promise<T&>>::from_promise(\n            *this)};\n       }\n    } \n    ```", "```cpp\nstruct suspend_always\n{\n  constexpr bool await_ready() noexcept { return false; }\n  constexpr void await_suspend(coroutine_handle<>) noexcept {}\n  constexpr void await_resume() noexcept {}\n};\nstruct suspend_never\n{\n  constexpr bool await_ready() noexcept { return true; }\n  constexpr void await_suspend(coroutine_handle<>) noexcept {}\n  constexpr void await_resume() noexcept {}\n}; \n```", "```cpp\ntask<> print_answer()\n{\n  auto t = co_await get_answer();\n  std::cout << \"the answer is \" << t << '\\n';\n} \n```", "```cpp\ntask<> print_answer()\n{\n  __frame* context;\n  task<>::task_awaiter t = operator co_await(get_answer());\n  if(!t.await_ready())\n  {\n    coroutine_handle<> resume_co =\n      coroutine_handle<>::from_address(context);\n    y.await_suspend(resume_co);\n    __suspend_resume_point_1:\n  }\n  auto value = t.await_resume();\n  std::cout << \"the answer is \" << value << '\\n';\n} \n```", "```cpp\nwhile (!t.is_ready()) t.resume(); \n```", "```cpp\n#include <iostream>\n#include <coro/task.hpp>\n#include <coro/sync_wait.hpp>\ncoro::task<int> get_answer()\n{\n  co_return 42;\n}\ncoro::task<> print_answer()\n{\n  auto t = co_await get_answer();\n  std::cout << \"the answer is \" << t << '\\n';\n}\ncoro::task<> demo()\n{\n  auto t = co_await get_answer();\n  std::cout << \"the answer is \" << t << '\\n';\n  co_await print_answer();\n}\nint main()\n{\n   coro::sync_wait(demo());\n} \n```", "```cpp\ngenerator<int> iota(int start = 0, int step = 1) noexcept\n{\n  auto value = start;\n  for (int i = 0;; ++i)\n  {\n    co_yield value;\n    value += step;\n  }\n}\ngenerator<std::optional<int>> iota_n(\n  int start = 0, int step = 1,\n  int n = std::numeric_limits<int>::max()) noexcept\n{\n  auto value = start;\n  for (int i = 0; i < n; ++i)\n  {\n    co_yield value;\n    value += step;\n  }\n}\ngenerator<int> fibonacci() noexcept\n{\n  int a = 0, b = 1;\n  while (true)\n  {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\nint main()\n{\n  for (auto i : iota())\n  {\n    std::cout << i << ' ';\n    if (i >= 10) break;\n  }\n  for (auto i : iota_n(0, 1, 10))\n  {\n    if (!i.has_value()) break;\n    std::cout << i.value() << ' ';\n  }\n  int c = 1;\n  for (auto i : fibonacci())\n  {\n    std::cout << i << ' ';\n    if (++c > 10) break;\n  }\n} \n```", "```cpp\n    template <typename T>\n    struct generator\n    {\n      // struct promise_type\n    // struct iterator\n    // member functions\n    // iterators\n    private:\n       std::coroutine_handle<promise_type> handle_ = nullptr;\n    }; \n    ```", "```cpp\n    struct promise_type\n    {\n      T const*             value_;\n      std::exception_ptr   eptr_;\n      auto get_return_object()\n     { return generator{ *this }; }\n      auto initial_suspend() noexcept\n     { return std::suspend_always{}; }\n      auto final_suspend() noexcept\n     { return std::suspend_always{}; }\n      void unhandled_exception() noexcept\n     {\n         eptr_ = std::current_exception();\n      }\n      void rethrow_if_exception()\n     {\n         if (eptr_)\n         {\n            std::rethrow_exception(eptr_);\n         }\n      }\n      auto yield_value(T const& v)\n     {\n         value_ = std::addressof(v);\n         return std::suspend_always{};\n      }\n      void return_void() {}\n      template <typename U>\n      U&& await_transform(U&& v)\n     {\n         return std::forward<U>(v);\n      }\n    }; \n    ```", "```cpp\n    struct iterator\n    {\n      using iterator_category = std::input_iterator_tag;\n      using difference_type   = ptrdiff_t;\n      using value_type        = T;\n      using reference         = T const&;\n      using pointer           = T const*;\n      std::coroutine_handle<promise_type> handle_ = nullptr;\n      iterator() = default;\n      iterator(nullptr_t) : handle_(nullptr) {}\n      iterator(std::coroutine_handle<promise_type> arg)\n        : handle_(arg)\n      {}\n      iterator& operator++()\n      {\n         handle_.resume();\n         if (handle_.done())\n         {\n            std::exchange(handle_, {}).promise()\n                                      .rethrow_if_exception();\n         }\n         return *this;\n      }\n      void operator++(int)\n      {\n         ++*this;\n      }\n      bool operator==(iterator const& _Right) const\n      {\n         return handle_ == _Right.handle_;\n      }\n      bool operator!=(iterator const& _Right) const\n      {\n         return !(*this == _Right);\n      }\n      reference operator*() const\n      {\n         return *handle_.promise().value_;\n      }\n      pointer operator->() const\n      {\n         return std::addressof(handle_.promise().value_);\n      }\n    }; \n    ```", "```cpp\n    explicit generator(promise_type& p)\n      : handle_(\n          std::coroutine_handle<promise_type>::from_promise(p))\n    {}\n    generator() = default;\n    generator(generator const&) = delete;\n    generator& operator=(generator const&) = delete;\n    generator(generator&& other) : handle_(other.handle_)\n    {\n      other.handle_ = nullptr;\n    }\n    generator& operator=(generator&& other)\n    {\n      if (this != std::addressof(other))\n      {\n         handle_ = other.handle_;\n         other.handle_ = nullptr;\n      }\n      return *this;\n    }\n    ~generator()\n    {\n      if (handle_)\n      {\n         handle_.destroy();\n      }\n    } \n    ```", "```cpp\n    iterator begin()\n    {\n      if (handle_)\n      {\n         handle_.resume();\n         if (handle_.done())\n         {\n            handle_.promise().rethrow_if_exception();\n            return { nullptr };\n         }\n      }\n      return { handle_ };\n    }\n    iterator end()\n    {\n      return { nullptr };\n    } \n    ```", "```cpp\ngenerator<int> get_values() noexcept\n{\n  co_yield 1;\n  co_yield 2;\n  co_yield 3;\n}\nint main()\n{\n  for (auto i : get_values())\n  {\n    std::cout << i << ' ';\n  }\n} \n```", "```cpp\nstd::generator<int> iota(int start = 0, int step = 1) noexcept\n{\n  auto value = start;\n  for (int i = 0;; ++i)\n  {\n    co_yield value;\n    value += step;\n  }\n}\nint main()\n{\n  for (auto i : iota())\n  {\n    std::cout << i << ' ';\n    if (i >= 10) break;\n  }\n} \n```", "```cpp\ntemplate<class Ref, class V = void, class Allocator = void>\nclass generator\n : public ranges::view_interface<generator<Ref, V, Allocator>>; \n```", "```cpp\nstd::generator<int> get_values() noexcept\n{\n  co_yield 1;\n  co_yield 2;\n  co_yield 3;\n} \n```", "```cpp\nstd::generator<int> fibonacci() noexcept\n{\n  int a = 0, b = 1;\n  while (true)\n  {\n    co_yield b;\n    auto tmp = a;\n    a = b;\n    b += tmp;\n  }\n}\nint main()\n{\n  int c = 1;\n  for (auto i : fibonacci())\n  {\n    std::cout << i << ' ';\n    if (++c > 10) break;\n  }\n} \n```"]