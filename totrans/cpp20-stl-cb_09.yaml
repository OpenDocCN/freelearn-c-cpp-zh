- en: '*Chapter 9*: Concurrency and Parallelism'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：并发与并行'
- en: Concurrency and parallelism refer to the ability to run code in separate *threads
    of execution*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行是指能够在独立的*执行线程*中运行代码的能力。
- en: More specifically, *concurrency* is the ability to run threads in the background,
    and *parallelism* is the ability to run threads simultaneously in separate cores
    of a processor. The run-time library, along with the host operating system, will
    choose between concurrent and parallel execution models for a given thread on
    a given hardware environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，*并发*是指能够在后台运行线程的能力，而*并行*是指能够在处理器的不同核心上同时运行线程的能力。运行时库以及宿主操作系统将为给定硬件环境中的给定线程选择并发或并行执行模型。
- en: In a modern multi-tasking operating system, the `main()` function already represents
    a thread of execution. When a new thread is started, it's said to be *spawned*
    by an existing thread. A group of threads may be called a *swarm*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代多任务操作系统中，`main()`函数已经代表了一个执行线程。当启动一个新线程时，它被称为由现有线程*孵化*的。一组线程可能被称为*蜂群*。
- en: In the C++ standard library, the `std::thread` class provides the basic unit
    of threaded execution. Other classes build upon `thread` to provide *locks*, *mutexes*,
    and other concurrency patterns. Depending on system architecture, execution threads
    may run concurrently on one processor, or in parallel on separate cores.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++标准库中，`std::thread`类提供了线程执行的基本单元。其他类基于`thread`提供*锁*、*互斥锁*和其他并发模式。根据系统架构，执行线程可能在一个处理器上并发运行，或者在多个核心上并行运行。
- en: 'In this chapter, we will cover these tools and more in the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方中的这些工具和更多内容：
- en: Sleep for a specific amount of time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠特定的时间长度
- en: Use `std::thread` for concurrency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::thread`实现并发
- en: Use `std::async` for concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::async`实现并发
- en: Run STL algorithms in parallel with execution policies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行策略并行运行STL算法
- en: Share data safely with mutex and locks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁和锁安全地共享数据
- en: Share flags and values with `std::atomic`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::atomic`共享标志和值
- en: Initialize threads with `std::call_once`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::call_once`初始化线程
- en: Use `std::condition_variable` to resolve the producer-consumer problem
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::condition_variable`解决生产者-消费者问题
- en: Implement multiple producers and consumers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多个生产者和消费者
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09)。
- en: Sleep for a specific amount of time
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休眠特定的时间长度
- en: The `<thread>` header provides two functions for putting a thread to sleep,
    `sleep_for()` and `sleep_until()`. Both functions are in the `std::this_thread`
    namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`<thread>`头文件提供了两个用于使线程休眠的功能，`sleep_for()`和`sleep_until()`。这两个函数都在`std::this_thread`命名空间中。'
- en: This recipe explores the use of these functions, as we will be using them later
    in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方探讨了这些函数的使用，因为我们将在本章后面使用它们。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at how to use the `sleep_for()` and `sleep_until()` functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`sleep_for()`和`sleep_until()`函数：
- en: 'The sleep-related functions are in the `std::this_thread` namespace. Because
    it has just a few symbols, we''ll go ahead and issue `using` directives for `std::this_thread`
    and `std::chrono_literals`:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与休眠相关的函数位于`std::this_thread`命名空间中。因为它只有几个符号，我们将继续为`std::this_thread`和`std::chrono_literals`发出`using`指令：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `chrono_literals` namespace has symbols for representing durations, such
    as `1s` for one second, or `100ms` for 100 milliseconds.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrono_literals`命名空间有表示持续时间的符号，例如`1s`表示一秒，或`100ms`表示100毫秒。'
- en: 'In `main()`, we''ll mark a point in time with `steady_clock::now()`, so we
    can time our test:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`中，我们将使用`steady_clock::now()`标记一个时间点，这样我们就可以计时我们的测试：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `sleep_for()` function takes a `duration` object to specify the amount of
    time to sleep. The argument `(1s + 300ms)` uses `chrono_literal` operators to
    return a `duration` object representing 1.3 seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_for()`函数接受一个`duration`对象来指定休眠的时间长度。参数`(1s + 300ms)`使用了`chrono_literal`运算符来返回一个表示1.3秒的`duration`对象。'
- en: The `sleep_until()` function takes a `time_point` object to specify a specific
    time to resume from sleep. In this case, the `chrono_literal` operators are used
    to modify the `time_point` object returned from `steady_clock::now()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_until()`函数接受一个`time_point`对象来指定从休眠中恢复的具体时间。在这种情况下，使用了`chrono_literal`运算符来修改由`steady_clock::now()`返回的`time_point`对象。'
- en: 'This is our output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `sleep_for(duration)` and `sleep_until(time_point)` functions suspend execution
    of the current thread for the specified `duration`, or until the `time_point`
    is reached.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_for(duration)` 和 `sleep_until(time_point)` 函数将暂停当前线程的执行，直到指定的 `duration`
    完成，或者直到 `time_point` 到达。'
- en: The `sleep_for()` function will use the `steady_clock` implementation, if supported.
    Otherwise, the duration may be subject to time adjustments. Both functions may
    block for longer due to scheduling or resource delays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持，`sleep_for()` 函数将使用 `steady_clock` 实现。否则，持续时间可能会受到时间调整的影响。这两个函数可能会因为调度或资源延迟而阻塞更长的时间。
- en: There's more…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Some systems support a POSIX function, `sleep()`, which suspends execution
    for the number of seconds specified:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统支持 POSIX 函数 `sleep()`，该函数暂停执行指定的时间数秒：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `sleep()` function is part of the POSIX standard and is not part of the
    C++ standard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep()` 函数是 POSIX 标准的一部分，而不是 C++ 标准的一部分。'
- en: Use std::thread for concurrency
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::thread` 进行并发
- en: A *thread* is a unit of concurrency. The `main()` function may be thought of
    as the *main thread of execution*. Within the context of the operating system,
    the main thread runs concurrently with other threads owned by other processes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程* 是并发的单位。`main()` 函数可以被认为是 *主要执行线程*。在操作系统的上下文中，主线程与其他进程拥有的线程并发运行。'
- en: The `std::thread` class is the root of concurrency in the STL. All other concurrency
    features are built on the foundation of the `thread` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::thread` 类是 STL 中并发的根基。所有其他并发特性都是建立在 `thread` 类的基础之上。'
- en: In this recipe, we will examine the basics of `std::thread` and how `join()`
    and `detach()` determine its execution context.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查 `std::thread` 的基础知识以及 `join()` 和 `detach()` 如何确定其执行上下文。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we create some `std::thread` objects and experiment with their
    execution options.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一些 `std::thread` 对象，并实验了它们的执行选项。
- en: 'We start with a convenience function for sleeping a thread, in milliseconds:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个用于休眠线程的方便函数开始，以毫秒为单位：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `sleep_for()` function takes a `duration` object and blocks execution of
    the current thread for the specified duration. This `sleepms()` function serves
    as a convenience wrapper that takes an `unsigned` value for the number of milliseconds
    to sleep.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_for()` 函数接受一个 `duration` 对象，并阻塞当前线程的执行，持续指定的时间。这个 `sleepms()` 函数作为一个方便的包装器，接受一个表示休眠毫秒数的
    `unsigned` 值。'
- en: 'Now, we need a function for our thread. This function sleeps for a variable
    number of milliseconds, based on an integer parameter:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个用于我们的线程的函数。这个函数根据一个整数参数休眠可变数量的毫秒：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`fthread()` calls `sleepms()` five times, sleeping each time for `100 * n`
    milliseconds.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`fthread()` 调用 `sleepms()` 五次，每次休眠 `100 * n` 毫秒。'
- en: 'We can run this in a separate thread with `std::thread` from `main()`:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在 `main()` 中使用 `std::thread` 在单独的线程中运行这个操作：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It compiles but we get this error when we run it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以编译，但当我们运行它时得到这个错误：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (Your error message will vary. This is the error message on Debian with GCC.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （你的错误信息可能会有所不同。这是在 Debian 上使用 GCC 时的错误信息。）
- en: The problem is that the operating system doesn't know what to do with the thread
    object when it goes out of scope. We must specify if the caller waits for the
    thread, or if it's detached and runs independently.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于操作系统不知道当线程对象超出作用域时该如何处理。我们必须指定调用者是否等待线程，或者线程是否分离并独立运行。
- en: 'We use the `join()` method to indicate that the caller will wait for the thread
    to finish:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `join()` 方法来表示调用者将等待线程完成：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, `main()` waits for the thread to finish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`main()` 等待线程完成。
- en: 'If we call `detach()` instead of `join()`, then `main()` doesn''t wait, and
    the program ends before the thread can run:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们调用 `detach()` 而不是 `join()`，那么 `main()` 不会等待，程序在线程运行之前就结束了：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the thread is detached, we need to give it time to run:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程分离时，我们需要给它运行的时间：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s start and detach a second thread and see what happens:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们启动并分离第二个线程，看看会发生什么：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because our `fthread()` function uses its parameter as a multiplier for `sleepms()`,
    the second thread runs a bit slower than the first. We can see the timers interlaced
    in the output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的 `fthread()` 函数使用其参数作为 `sleepms()` 的乘数，所以第二个线程比第一个线程运行得慢一些。我们可以在输出中看到计时器的交错。
- en: 'If we do this with `join()` instead of `detatch()`, we get a similar result:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们用 `join()` 而不是 `detach()` 来做这件事，我们会得到类似的结果：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because `join()` waits for the thread to finish, we no longer need the 2-second
    `sleepms()` in `main()` to wait for the threads to finish.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `std::thread` object represents a thread of execution. There is a one-to-one
    relationship between object and thread. One `thread` object represents one thread,
    and one thread is represented by one `thread` object. A `thread` object cannot
    be copied or assigned, but it can be moved.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The `thread` constructor looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A thread is constructed with a function pointer and zero or more arguments.
    The function is called immediately with the arguments provided:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates the object `t1` and immediately calls the function `fthread(int)`
    with the literal value `1` as the argument.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the thread, we must use either `join()` or `detach()` on the
    thread:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `join()` method blocks execution of the calling thread until the `t1` thread
    has completed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `detach()` method allows the calling thread to continue independently of
    the `t1` thread.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++20 provides `std::jthread`, which automatically joins the caller at the
    end of its scope:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows the `t1` thread to execute independently and then automatically
    join the `main()` thread at the end of its scope.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Use std::async for concurrency
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::async()` runs a target function asynchronously and returns a `std::future`
    object to carry the target function''s return value. In this way, `async()` operates
    much like `std::thread` but allows return values.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the use of `std::async()` with a few examples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its simplest forms, the `std::async()` function performs much the same task
    as `std::thread`, without the need to call `join()` or `detach()` and while also
    allowing return values via a `std::future` object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use a function that counts the number of primes in a range.
    We'll use `chrono::steady_clock` to time the execution of each thread.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a couple of convenience aliases:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`std::launch` has launch policy constants, for use with the `async()` call.
    The `secs` alias is a `duration` class, for timing our prime number calculations.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Our target function counts prime numbers in a range. This is essentially a
    way to understand the execution policies by eating some clock cycles:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `prime_time` structure is for the return value, with elements for duration
    and count. This allows us to time the loop itself. The `isprime` lambda returns
    `true` if a value is prime. We use `steady_clock` to calculate the duration of
    the loop that counts primes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we call our function and report its timing:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can run `count_primes()` asynchronously with `std::async()`:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we call `async()` with our `count_primes` function and the `MAX_PRIME`
    parameter. This runs `count_primes()` in the background.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`async()` returns a `std::future` object, which carries the return value of
    an asynchronous operation. The `future` object''s `get()` method blocks until
    the asynchronous function has completed and then returns the return object from
    the function.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`async()`返回一个`std::future`对象，该对象携带异步操作的返回值。`future`对象的`get()`方法会阻塞，直到异步函数完成，然后返回函数的返回对象。'
- en: 'This runs with almost the same timing as we got without `async()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与没有使用`async()`时几乎相同的计时：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `async()` function optionally takes execution policy flags as its first
    parameter:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async()`函数可以可选地将其第一个参数作为执行策略标志：'
- en: '[PRE30]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The choices are `async` or `deferred`. These flags are in the `std::launch`
    namespace.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是`async`或`deferred`。这些标志位于`std::launch`命名空间中。
- en: The `async` flag enables asynchronous operation, and the `deferred` flag enables
    lazy evaluation. These flags are bitmapped and may be combined with the bitwise
    or `|` operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`标志启用异步操作，而`deferred`标志启用延迟评估。这些标志是位映射的，并且可以使用位或`|`运算符组合。'
- en: The default is for both bits to be set, as if `async | deferred` was specified.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，两个位都被设置，就像指定了`async | deferred`一样。
- en: 'We can run several instances of our function simultaneously with `async()`:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`async()`同时运行我们函数的几个实例：
- en: '[PRE31]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We know that `async` returns a `future` object. So, we can run 15 threads by
    storing the `future` objects in a container. Here''s our output on a 6-core i7
    running Windows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`async`返回一个`future`对象。因此，我们可以通过将`future`对象存储在容器中来运行15个线程。以下是在6核i7上运行Windows的输出：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even though the 6-core i7 is not able to run all the processes in separate cores,
    it still completes 15 instances in under 6 seconds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 即使6核i7无法在单独的核心上运行所有进程，它仍然在6秒内完成了15个实例。
- en: It looks like it finishes the first 13 threads in about 4 seconds, and then
    takes another 2 seconds to finish the last 2 threads. It appears to take advantage
    of Intel's Hyper-Threading technology that allows 2 threads to run in one core
    under some circumstances.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来在前13个线程大约用了4秒完成，然后又花了2秒来完成最后2个线程。它似乎利用了Intel的Hyper-Threading技术，在某些情况下允许一个核心下运行2个线程。
- en: 'When we run the same code on a 12-core Xeon, we get this result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在12核Xeon上运行相同的代码时，我们得到这个结果：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The 12-core Xeon gets through all 15 processes in under a second.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 12核Xeon在不到一秒内就完成了所有15个进程。
- en: How it works…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to understanding `std::async` is in its use of `std::promise` and `std::future`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`std::async`的关键在于其使用`std::promise`和`std::future`。
- en: The `promise` class allows a `thread` to store an object that may later be retrieved
    asynchronously by a `future` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise`类允许一个`thread`存储一个对象，该对象可能稍后由一个`future`对象异步检索。'
- en: 'For example, let''s say we have a function like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个这样的函数：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can run it with `std::thread`, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`std::thread`来运行它：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That works fine for a simple function with no return value. When we want to
    return a value from `f()`, we can use `promise` and `future`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有返回值的简单函数来说，这没问题。当我们想要从`f()`函数中返回一个值时，我们可以使用`promise`和`future`。
- en: 'We set up the promise and future objects in the `main()` thread:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`线程中设置了promise和future对象：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we pass the `promise` object to our function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`promise`对象传递给我们的函数：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that a `promise` object cannot be copied, so we need to use `std::move`
    to pass it to the function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`promise`对象不能被复制，因此我们需要使用`std::move`将其传递给函数。
- en: The `promise` object serves as a bridge to a `future` object, which allows us
    to retrieve the value when it becomes available.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise`对象充当了`future`对象的一个桥梁，允许我们在值可用时检索它。'
- en: '`std::async()` is just a helper function to simplify the creation of the `promise`
    and `future` objects. With `async()`, we can do all of that like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::async()`只是一个辅助函数，用于简化`promise`和`future`对象的创建。使用`async()`，我们可以这样做：'
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's the value of `async()`. For many purposes, it makes the use of `promise`
    and `future` much easier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`async()`函数的价值。对于许多用途来说，它使得使用`promise`和`future`变得更加容易。
- en: Run STL algorithms in parallel with execution policies
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行策略并行运行STL算法
- en: Beginning with C++17, many of the standard STL algorithms can run with *parallel
    execution*. This feature allows an algorithm to split its work into sub-tasks
    to run simultaneously on multiple cores. These algorithms accept an execution
    policy object that specifies the kind of parallelism applied to the algorithm.
    This feature requires hardware support.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++17开始，许多标准STL算法可以以*并行执行*的方式运行。这个特性允许算法将其工作分割成子任务，以便在多个核心上同时运行。这些算法接受一个执行策略对象，该对象指定了应用于算法的并行类型。这个特性需要硬件支持。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Execution policies are defined in the `<execution>` header and in the `std::execution`
    namespace. In this recipe, we will test the available policies using the `std::transform()`
    algorithm:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略在 `<execution>` 头文件和 `std::execution` 命名空间中定义。在本例中，我们将使用 `std::transform()`
    算法测试可用的策略：
- en: 'For timing purposes, we''ll use the `duration` object with the `std::milli`
    ratio so that we can measure in milliseconds:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计时，我们将使用带有 `std::milli` 比率的 `duration` 对象，这样我们就可以以毫秒为单位进行测量：
- en: '[PRE39]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For demonstration purposes, we''ll start with a `vector` of `int` with 10 million
    random values:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将从一个包含 1000 万个随机值的 `int` `vector` 开始：
- en: '[PRE40]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we apply a simple transformation:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们应用一个简单的转换：
- en: '[PRE41]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `mul2` lambda simply multiplies a value by 2\. The `transform()` algorithm
    applies `mul2` to every member of the vector.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul2` lambda 简单地将一个值乘以 2。`transform()` 算法将 `mul2` 应用到向量的每个成员上。'
- en: This transformation does not specify an execution policy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此转换没有指定执行策略。
- en: 'Output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can specify an execution policy in the first argument of the algorithm:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在算法的第一个参数中指定执行策略：
- en: '[PRE43]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `seq` policy means that the algorithm shall not be parallelized. This is
    the same as no execution policy.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq` 策略意味着算法不应并行化。这与没有执行策略相同。'
- en: 'Output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that the duration is roughly the same as without a policy. It will never
    be exact because it varies each time it's run.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到持续时间与没有策略时大致相同。它永远不会完全精确，因为每次运行时都会变化。
- en: 'The `execution::par` policy allows the algorithm to parallelize its workload:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution::par` 策略允许算法并行化其工作负载：'
- en: '[PRE45]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that the algorithm runs somewhat faster with the parallel execution policy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到算法在并行执行策略下运行得更快。
- en: 'The `execution::par_unseq` policy allows unsequenced parallel execution of
    the workload:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execution::par_unseq` 策略允许无序并行执行工作负载：'
- en: '[PRE47]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we notice another increase in performance with this policy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们注意到使用此策略性能又有提升。
- en: The `execution::par_unseq` policy has tighter requirements of the algorithm.
    The algorithm must not perform operations that require concurrent or sequential
    operation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`execution::par_unseq` 策略对算法的要求更严格。算法不得执行需要并发或顺序操作的操作。'
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The execution policies interface doesn't specify how the algorithm workloads
    are parallelized. It's designed to work with a diverse set of hardware and processors
    under varying loads and circumstances. It may be implemented entirely in the library
    or rely on compiler or hardware support.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略接口没有指定算法工作负载是如何并行化的。它旨在与各种硬件和处理器在不同负载和环境下一起工作。它可能完全在库中实现，也可能依赖于编译器或硬件支持。
- en: 'Parallelization will show the most improvement on algorithms that do more than
    *O(n)* work. For example, `sort()` shows a dramatic improvement. Here''s a `sort()`
    with no parallelization:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化将在那些做超过 *O(n)* 工作的算法上显示出最大的改进。例如，`sort()` 显示出显著的改进。这是一个没有并行化的 `sort()`：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With `execution::par`, we see significant performance gains:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `execution::par`，我们看到显著的性能提升：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The improvement with `execution::par_unseq` is better still:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `execution::par_unseq` 的改进效果更好：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It's a good idea to do a lot of testing when using the parallelized algorithms.
    If your algorithm or predicates do not lend themselves well to parallelization,
    you may end up with minimal performance gains or unintended side effects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用并行算法时进行大量测试是个好主意。如果你的算法或谓词不适合并行化，你可能会得到最小的性能提升或意外的副作用。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, execution policies are poorly supported in GCC and not
    yet supported by LLVM/Clang. This recipe was tested on a 6-core i7 running Windows
    10 and a preview release of Visual C++.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，执行策略在 GCC 中支持不佳，LLVM/Clang 还不支持。本食谱在运行 Windows 10 的 6 核 i7 和 Visual C++
    预览版上进行了测试。
- en: Share data safely with mutex and locks
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁和锁安全地共享数据
- en: The term *mutex* refers to *mutually exclusive* access to shared resources.
    A mutex is commonly used to avoid data corruption and race conditions, due to
    multiple threads of execution attempting to access the same data. A mutex will
    typically use *locks* to restrict access to one thread at a time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *互斥锁* 指的是对共享资源的互斥访问。互斥锁通常用于避免由于多个执行线程尝试访问相同数据而导致的数据损坏和竞态条件。互斥锁通常会使用 *锁* 来限制一次只允许一个线程访问。
- en: The STL provides *mutex* and *lock* classes in the `<mutex>` header.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: STL 在 `<mutex>` 头文件中提供了 *互斥锁* 和 *锁* 类。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will use a simple `Animal` class to experiment with *locking*
    and *unlocking* a `mutex`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个简单的 `Animal` 类来实验对 `mutex` 的 `锁定` 和 `解锁`：
- en: 'We start by creating a `mutex` object:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `mutex` 对象：
- en: '[PRE55]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `mutex` is declared in the global scope, so it's accessible to all the relevant
    objects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex` 在全局范围内声明，因此它对所有相关对象都是可访问的。'
- en: 'Our `Animal` class has a name and a list of friends:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `Animal` 类有一个名字和一个朋友列表：
- en: '[PRE56]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Adding and deleting friends will be a useful test case for our `mutex`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和删除朋友将是我们 `mutex` 的一个有用的测试用例。
- en: 'The equality operator is the only operator we''ll need:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于运算符是我们唯一需要的运算符：
- en: '[PRE57]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `s_name` member is a `string_view` object, so we can test the address of
    its data store for equality.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`s_name` 成员是一个 `string_view` 对象，因此我们可以测试其数据存储的地址是否相等。'
- en: 'The `is_friend()` method tests if another `Animal` is in the `l_friends` list:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_friend()` 方法测试另一个 `Animal` 是否在 `l_friends` 列表中：'
- en: '[PRE58]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `find_friend()` method returns an `optional`, with an iterator to the `Animal`
    if found:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_friend()` 方法返回一个 `optional`，如果找到则包含对 `Animal` 的迭代器：'
- en: '[PRE59]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `print()` method prints `s_name` along with names of each of the `Animal`
    objects in the `l_friends` list:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()` 方法打印 `s_name` 以及 `l_friends` 列表中每个 `Animal` 对象的名字：'
- en: '[PRE60]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `add_friend()` method adds an `Animal` object to the `l_friends` list:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_friend()` 方法将一个 `Animal` 对象添加到 `l_friends` 列表中：'
- en: '[PRE61]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `delete_friend()` method removes an `Animal` object from the `l_friends`
    list:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_friend()` 方法从 `l_friends` 列表中删除一个 `Animal` 对象：'
- en: '[PRE62]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `main()` function, we create some `Animal` objects:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们创建了一些 `Animal` 对象：
- en: '[PRE63]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We call `add_friends()` on our objects with `async()`, to run them in separate
    threads:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `async()` 在我们的对象上调用 `add_friends()`，以在单独的线程中运行它们：
- en: '[PRE64]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We call `wait()` to allow our threads to complete before continuing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `wait()` 以允许线程在继续之前完成。
- en: 'We call `print()` to see our `Animals` and their relationships:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用 `print()` 来查看我们的 `Animals` 和它们的关系：
- en: '[PRE65]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And finally, we call `delete_friend()` to remove one of our relationships:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们调用 `delete_friend()` 来删除我们的一种关系：
- en: '[PRE66]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At this point, our output looks like this:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的输出看起来是这样的：
- en: '[PRE67]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This output is somewhat scrambled. It will be different each time you run it.
    It may be fine sometimes, but don't let that fool you. We need to add some mutex
    locks to control access to the data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出有些混乱。每次运行时它都会有所不同。有时可能没问题，但不要被它迷惑。我们需要添加一些 mutex 锁来控制对数据的访问。
- en: 'One way to use `mutex` is with its `lock()` and `unlock()` methods. Let''s
    add them to the `add_friend()` function:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mutex` 的一种方法是通过其 `lock()` 和 `unlock()` 方法。让我们将它们添加到 `add_friend()` 函数中：
- en: '[PRE68]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `lock()` method attempts to acquire a lock on the `mutex`. If the mutex
    is already locked, it will wait (block execution) until the `mutex` is unlocked.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock()` 方法尝试获取 `mutex` 的锁。如果 `mutex` 已经被锁定，它将等待（阻塞执行）直到 `mutex` 被解锁。'
- en: 'We also need to add a lock to `delete_friend()`:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要给 `delete_friend()` 添加一个锁：
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we need to add a lock to `print()` so that data is not changed while printing:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们需要给 `print()` 添加一个锁，以确保在打印时数据不会被更改：
- en: '[PRE70]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, our output is sensible:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的输出是有意义的：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Your output may have the lines in a different order due to asynchronous operation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步操作，您的输出行可能顺序不同。
- en: 'The `lock()` and `unlock()` methods are rarely called directly. The `std::lock_guard`
    class manages locks with a proper `add_friend()` method with `lock_guard`:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock()` 和 `unlock()` 方法很少直接调用。`std::lock_guard` 类通过带有 `lock_guard` 的 `add_friend()`
    方法管理锁：'
- en: '[PRE72]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `lock_guard` object is created and holds a lock until it is destroyed. Like
    the `lock()` method, `lock_guard` also blocks until a lock is available.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock_guard` 对象被创建并保持锁定状态，直到它被销毁。像 `lock()` 方法一样，`lock_guard` 也会阻塞，直到获得锁。'
- en: Let's apply `lock_guard` to the `delete_friend()` and `print()` methods.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们将 `lock_guard` 应用于 `delete_friend()` 和 `print()` 方法。
- en: 'Here is `delete_friend()`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `delete_friend()` 的代码：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And here is `print()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `print()` 的代码：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our output remains coherent:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出保持一致：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As before, your output may have the lines in a different order due to asynchronous
    operation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，由于异步操作，您的输出行可能顺序不同。
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's important to understand that a `mutex` does not lock data; it blocks execution.
    As shown in this recipe, when a `mutex` is applied in object methods, it can be
    used to enforce mutually exclusive access to data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 `mutex` 并不会锁定数据；它会阻塞执行。正如这个菜谱所示，当 `mutex` 应用在对象方法中时，它可以用来强制对数据的互斥访问。
- en: When one thread locks a `mutex`, with either `lock()` or `lock_guard`, that
    thread is said to *own* the `mutex`. Any other thread that tries to lock the same
    `mutex` will be blocked until it's unlocked by the owner.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程使用`lock()`或`lock_guard`锁定`mutex`时，该线程被称为*拥有*该`mutex`。任何尝试锁定相同`mutex`的其他线程都将被阻塞，直到它被所有者解锁。
- en: The `mutex` object must not be destroyed while it's owned by any thread. Likewise,
    a thread must not be destroyed while it owns a `mutex`. An RAII-compliant wrapper,
    such as `lock_guard`, will help ensure this doesn't happen.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何线程拥有`mutex`对象时，不能销毁该对象。同样，拥有`mutex`的线程也不能被销毁。符合RAII规范的包装器，如`lock_guard`，将有助于确保这种情况不会发生。
- en: There's more…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'While `std::mutex` provides an exclusive mutex suitable for many purposes,
    the STL does provide a few other choices:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::mutex`提供了适用于许多目的的独占互斥锁，但STL确实提供了一些其他选择：
- en: '`shared_mutex` allows more than one thread to simultaneously own a mutex.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_mutex`允许多个线程同时拥有互斥锁。'
- en: '`recursive_mutex` allows one thread to stack multiple locks on a single mutex.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recursive_mutex`允许一个线程在单个互斥锁上堆叠多个锁。'
- en: '`timed_mutex` provides a timeout for mutex blocks. Both `shared_mutex` and
    `recursive_mutex` also have timed versions available.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timed_mutex`为互斥锁块提供超时。`shared_mutex`和`recursive_mutex`也有可用的定时版本。'
- en: Share flags and values with std::atomic
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::atomic共享标志和值
- en: The `std::atomic` class encapsulates a single object and guarantees it to be
    *atomic*. Writing to the *atomic object* is controlled by memory-order policies
    and reads may occur simultaneously. It's typically used to synchronize access
    among different threads.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`类封装了一个单个对象，并保证它是*原子的*。写入*原子对象*受内存顺序策略控制，并且可以同时发生读取。它通常用于在不同线程之间同步访问。'
- en: '`std::atomic` defines an *atomic type* from its template type. The type must
    be *trivial*. A type is trivial if it occupies contiguous memory, has no user-defined
    constructor, and has no virtual member functions. All primitive types are trivial.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`从其模板类型定义了一个*原子类型*。类型必须是*平凡的*。如果一个类型占用连续的内存，没有用户定义的构造函数，并且没有虚拟成员函数，则该类型是平凡的。所有原始类型都是平凡的。'
- en: While it is possible to construct a trivial type, `std::atomic` is most often
    used with simple primitive types, such as `bool`, `int`, `long`, `float`, and
    `double`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以构造平凡的类型，但`std::atomic`通常与简单的原始类型一起使用，例如`bool`、`int`、`long`、`float`和`double`。
- en: How to do it…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This recipe uses a simple function that loops over a counter to demonstrate
    sharing atomic objects. We will spawn a swarm of these loops as threads that share
    atomic values:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用一个简单的函数，该函数遍历一个计数器来演示共享原子对象。我们将生成一群这样的循环作为共享原子值的线程：
- en: 'Atomic objects are often placed in a global namespace. They must be accessible
    to all the threads that need to share its value:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子对象通常放置在全局命名空间中。它们必须对所有需要共享其值的线程都是可访问的：
- en: '[PRE76]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `ready` object is a `bool` type that gets set to `true` when all the threads
    are ready to start counting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`ready`对象是一个`bool`类型，当所有线程都准备好开始计数时，将其设置为`true`。'
- en: The `g_count` object is a global counter. It is incremented by each of the threads.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_count`对象是一个全局计数器。每个线程都会增加它。'
- en: The `winner` object is a special `atomic_flag` type. It is used to indicate
    which thread finishes first.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`winner`对象是一个特殊的`atomic_flag`类型。它用于指示哪个线程先完成。'
- en: 'We use a couple of constants to control the number of threads and the number
    of loops for each thread:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一些常量来控制线程的数量和每个线程的循环次数：
- en: '[PRE77]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: I've set it to run 100 threads and count 1,000,000 iterations in each thread.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其设置为运行100个线程，并在每个线程中计数1,000,000次迭代。
- en: 'The `countem()` function is spawned for each thread. It loops `max_count` times
    and increments `g_count` for each iteration of the loop. This is where we use
    our atomic values:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个线程生成`countem()`函数。它循环`max_count`次，并在循环的每次迭代中增加`g_count`。这就是我们使用原子值的地方：
- en: '[PRE78]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `ready` atomic value is used to synchronize the threads. Each thread will
    call `yield()` until the `ready` value is set `true`. The `yield()` function yields
    execution to other threads.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ready`原子值来同步线程。每个线程将调用`yield()`，直到`ready`值设置为`true`。`yield()`函数将执行权交给了其他线程。
- en: Each iteration of the `for` loop increments the `g_count` atomic value. The
    final value should be equal to `max_count * max_threads`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的每次迭代都会增加`g_count`原子值。最终值应该等于`max_count * max_threads`。'
- en: After the loop is complete, the `test_and_set()` method of the `winner` object
    is used to report the winning thread. `test_and_set()` is a method of the `atomic_flag`
    class. It sets the flag and returns the `bool` value from before it is set.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，使用`winner`对象的`test_and_set()`方法报告获胜的线程。`test_and_set()`是`atomic_flag`类的一个方法。它设置标志并返回设置之前的`bool`值。
- en: 'We''ve used the `make_commas()` function before. It displays a number with
    thousands of separators:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前已经使用过`make_commas()`函数。它显示带有千位分隔符的数字：
- en: '[PRE79]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `main()` function spawns the threads and reports the results:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数创建线程并报告结果：'
- en: '[PRE80]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we create a `vector<std::thread>` object to hold the threads.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建一个`vector<std::thread>`对象来保存线程。
- en: In the `for` loop, we use `emplace_back()` to create each `thread` in the `vector`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们使用`emplace_back()`在`vector`中创建每个`thread`。
- en: Once the threads have been spawned, we set the `ready` flag so that the threads
    may start their loops.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程被创建，我们设置`ready`标志，以便线程可以开始它们的循环。
- en: 'Output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Every time you run it, a different thread will win.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行它时，都会有一个不同的线程获胜。
- en: How it works…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::atomic` class encapsulates an object to synchronize access among multiple
    threads.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`类封装了一个对象，以在多个线程之间同步访问。'
- en: The encapsulated object must be a *trivial type*, which means it occupies contiguous
    memory, has no user-defined constructor, and has no virtual member functions.
    All primitive types are trivial.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的对象必须是一个*平凡类型*，这意味着它占用连续的内存，没有用户定义的构造函数，并且没有虚成员函数。所有原始类型都是平凡的。
- en: 'It is possible to use a simple struct with `atomic`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个简单的结构体和`atomic`：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: While this usage is possible, it's not practical. Anything beyond setting and
    retrieving compound values loses the benefits of the atomicity and ends up requiring
    a *mutex*. The atomic class is best suited for *scalar* values.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种用法是可能的，但并不实用。任何超出设置和检索复合值的行为都会失去原子性的好处，最终需要使用一个*互斥锁*。原子类最适合*标量*值。
- en: Specializations
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊化
- en: 'There are specializations of the `atomic` class for a few different purposes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic`类有几个特殊化，用于不同的目的：'
- en: '`std::atomic<U*>` specialization includes support for atomic pointer arithmetic
    operations, including `fetch_add()` for addition and `fetch_sub()` for subtraction.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::atomic<U*>`特殊化包括对原子指针算术操作的支持，包括`fetch_add()`用于加法和`fetch_sub()`用于减法。'
- en: '`float`, `double`, and `long double`, `std::atomic` includes support for atomic
    floating-point arithmetic operations, including `fetch_add()` for addition and
    `fetch_sub()` for subtraction.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`、`double`和`long double`，`std::atomic`包括对原子浮点算术操作的支持，包括`fetch_add()`用于加法和`fetch_sub()`用于减法。'
- en: '`std::atomic` provides support for additional atomic operations, including
    `fetch_add()`, `fetch_sub()`, `fetch_and()`, `fetch_or()`, and `fetch_xor()`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::atomic`提供了对额外的原子操作的支持，包括`fetch_add()`、`fetch_sub()`、`fetch_and()`、`fetch_or()`和`fetch_xor()`。'
- en: Standard aliases
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准别名
- en: 'The STL provides type aliases for all the standard scalar integral types. This
    means that instead of these declarations in our code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: STL为所有标准标量整型类型提供了类型别名。这意味着我们可以在代码中使用这些声明：
- en: '[PRE83]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We could use:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'There are 46 standard aliases, one for each of the standard integral types:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有46个标准别名，每个对应一个标准整型类型：
- en: '![](img/B18267_table_9.1.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18267_table_9.1.jpg)'
- en: Lock-free variations
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无锁变体
- en: Most modern architectures provide *atomic CPU instructions* for performing atomic
    operations. `std::atomic` should use hardware support for atomic instructions
    where supported by your hardware. Some atomic types may not be supported on some
    hardware. `std::atomic` may use a *mutex* to ensure thread-safe operations for
    those specializations, causing threads to block while waiting for other threads
    to complete operations. Specializations that use hardware support are said to
    be *lock-free* because they don't require a mutex.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代架构都提供了执行原子操作的*原子CPU指令*。`std::atomic`应该在硬件支持的情况下使用原子指令。某些原子类型可能在某些硬件上不受支持。`std::atomic`可能使用一个*互斥锁*来确保这些特殊化的线程安全操作，导致线程在等待其他线程完成操作时阻塞。使用硬件支持的特殊化被称为*无锁*，因为它们不需要互斥锁。
- en: 'The `is_lock_free()` method checks whether a specialization is lock-free:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_lock_free()`方法检查一个特殊化是否是无锁的：'
- en: '[PRE85]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE86]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This result will be `true` for most modern architectures.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果对于大多数现代架构将是`true`。
- en: 'There are a few guaranteed lock-free variations of `std::atomic` available.
    These specializations guarantee the use of the most efficient hardware atomic
    operations for each purpose:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种保证的 `std::atomic` 无锁变体可用。这些特化保证了每个目的都使用最有效的硬件原子操作：
- en: '`std::atomic_signed_lock_free` is an alias for the most efficient lock-free
    specialization of a signed integral type.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::atomic_signed_lock_free` 是一个对有符号整型最有效无锁特化的别名。'
- en: '`std::atomic_unsigned_lock_free` is an alias for the most efficient lock-free
    specialization of an unsigned integral type.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::atomic_unsigned_lock_free` 是对无符号整型最有效无锁特化的别名。'
- en: The `std::atomic_flag` class provides a lock-free atomic Boolean type.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::atomic_flag` 类提供了一个无锁原子布尔类型。'
- en: Important Note
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Current Windows systems don't support 64-bit hardware integers, even on 64-bit
    systems. When testing this code on one of these systems in my lab, replacing `std::atomic<uint64_t>`
    with `std::atomic_unsigned_lock_free` resulted in a *3x* performance improvement.
    Performance was unchanged on 64-bit Linux and Mac systems.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前Windows系统不支持64位硬件整数，即使在64位系统上也是如此。在我实验室的这些系统上测试此代码时，将 `std::atomic<uint64_t>`
    替换为 `std::atomic_unsigned_lock_free` 导致性能提高了*3倍*。在64位Linux和Mac系统上性能没有变化。
- en: There's more…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When multiple threads read and write variables simultaneously, one thread may
    observe the changes in a different order than they were written. `std::memory_order`
    specifies how memory accesses are ordered around an atomic operation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时读写变量时，一个线程可能观察到的变化顺序与它们写入的顺序不同。`std::memory_order` 指定了原子操作周围的内存访问的排序方式。
- en: '`std::atomic` provides methods for accessing and changing its managed value.
    Unlike the associated operators, these access methods provide arguments for `memory_order`
    to be specified. For example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic` 提供了访问和更改其管理值的方法。与相关运算符不同，这些访问方法提供了指定 `memory_order` 的参数。例如：'
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this case, `memory_order_seq_cst` specifies *sequentially consistent* ordering.
    So, this call to `fetch_add()` will add 1 to the value of `g_count` with sequentially
    consistent ordering.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`memory_order_seq_cst` 指定*顺序一致*排序。因此，这个 `fetch_add()` 调用将以顺序一致排序将1添加到
    `g_count` 的值。
- en: 'The possible `memory_order` constants are:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的 `memory_order` 常量有：
- en: '`memory_order_relaxed`: This is a *relaxed operation*. No synchronization or
    ordering constraints are imposed; only the operation''s atomicity is guaranteed.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_relaxed`：这是一个*非同步操作*。不施加任何同步或排序约束；仅保证操作的原子性。'
- en: '`memory_order_consume`: This is a *consume operation*. Access in the current
    thread that is dependent on the value cannot be reordered before this load. This
    only affects compiler optimization.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_consume`：这是一个*消费操作*。当前线程依赖于值的访问不能在此加载之前进行重排序。这仅影响编译器优化。'
- en: '`memory_order_acquire`: This is an *acquire operation*. Access cannot be reordered
    before this load.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_acquire`：这是一个*获取操作*。访问不能在此加载之前进行重排序。'
- en: '`memory_order_release`: This is a *store operation*. Access in the current
    thread cannot be reordered after this store.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_release`：这是一个*存储操作*。当前线程在此存储之后不能对访问进行重排序。'
- en: '`memory_order_acq_rel`: This is both *acquire* and *release*. Access in the
    current thread cannot be reordered before or after this store.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_acq_rel`：这是*获取*和*释放*的结合。当前线程在此存储之前或之后不能对访问进行重排序。'
- en: '`memory_order_seq_cst`: This is *sequentially consistent* ordering, either
    *acquire* or *release*, depending on the context. A load performs acquire, a store
    performs release, and a read/write/modify performs both. All threads observe all
    modifications in the same order.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_seq_cst`：这是*顺序一致*排序，根据上下文可以是*获取*或*释放*。一个加载执行获取，一个存储执行释放，一个读写/修改同时执行两者。所有线程以相同的顺序观察到所有修改。'
- en: If no `memory_order` is specified, `memory_order_seq_cst` is the default.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定 `memory_order`，则 `memory_order_seq_cst` 是默认值。
- en: Initialize threads with std::call_once
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::call_once 初始化线程
- en: You may need to run the same code in many threads but must initialize that code
    only once.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要在多个线程中运行相同的代码，但只需初始化一次该代码。
- en: One solution would be to call the initialization code before running the threads.
    This approach can work but has some drawbacks. By separating the initialization,
    it may be called when unnecessary, or it may be missed when necessary.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在运行线程之前调用初始化代码。这种方法可以工作，但有一些缺点。通过分离初始化，它可能在不需要时被调用，或者在需要时被遗漏。
- en: The `std::call_once` function provides a more robust solution. `call_once` is
    in the `<mutex>` header.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::call_once` 函数提供了一个更健壮的解决方案。`call_once` 在 `<mutex>` 头文件中。'
- en: How to do it…
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we use a print function for the initialization, so we can clearly
    see when it''s called:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用一个打印函数来进行初始化，这样我们可以清楚地看到它何时被调用：
- en: 'We''ll use a constant for the number of threads to spawn:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用一个常量来指定要生成的线程数：
- en: '[PRE88]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We also need a `std::once_flag` to synchronize the `std::call_once` function:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 `std::once_flag` 来同步 `std::call_once` 函数：
- en: '[PRE89]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Our initialization function simply prints a string to let us know it''s been
    called:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的初始化函数简单地打印一个字符串，让我们知道它已被调用：
- en: '[PRE90]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Our worker function, `do_print()`, uses `std::call_once` to call the initialization
    function then prints its own `id`:'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的工人函数 `do_print()` 使用 `std::call_once` 调用初始化函数然后打印其自己的 `id`：
- en: '[PRE91]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In `main()`, we use a `list` container to manage the `thread` objects:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们使用 `list` 容器来管理 `thread` 对象：
- en: '[PRE92]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Our output shows the initialization happens first, and only once:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果显示初始化首先发生，并且只发生一次：
- en: '[PRE93]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Notice that it's not always the first spawned thread (`0`) that ends up calling
    the initialization function, but it is always called first. If you run this repeatedly,
    you'll see thread `0` gets the initialization often, but not every time. You'll
    see thread `0` in the initialization more often on a system with fewer cores.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并不总是第一个生成的线程（`0`）最终调用初始化函数，但它总是第一个被调用。如果你反复运行它，你会看到线程 `0` 经常得到初始化，但并不总是。在一个核心较少的系统上，你会看到线程
    `0` 在初始化中出现的频率更高。
- en: How it works…
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::call_once` is a template function that takes a flag, a *callable* (function
    or functor), and a parameter pack of arguments:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::call_once` 是一个模板函数，它接受一个标志、一个 *可调用对象*（函数或函数对象）以及参数包：'
- en: '[PRE94]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The callable `f` is called exactly one time. Even if `call_once` is called concurrently
    from several threads, `f` is still called once and only once.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象 `f` 只被调用一次。即使 `call_once` 从多个线程并发调用，`f` 也只会被调用一次。
- en: This requires a `std::once_flag` object for coordination. The `once_flag` constructor
    sets its state to indicate that the callable has not yet been called.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个 `std::once_flag` 对象来进行协调。`once_flag` 构造函数将其状态设置为指示可调用函数尚未被调用。
- en: When `call_once` invokes the callable, any other calls on the same `once_flag`
    are blocked until the callable returns. After the callable returns, the `once_flag`
    is set, and any subsequent calls to `call_once` return without invoking `f`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `call_once` 调用可调用对象时，对同一 `once_flag` 的任何其他调用都会被阻塞，直到可调用对象返回。在可调用对象返回后，`once_flag`
    被设置，并且任何后续对 `call_once` 的调用都不会调用 `f`。
- en: Use std::condition_variable to resolve the producer-consumer problem
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::condition_variable 解决生产者-消费者问题
- en: The simplest version of the *producer-consumer problem* is where you have one
    process that *produces* data and another that *consumes* data, using one *buffer*
    or container to hold the data. This requires coordination between the producer
    and consumer to manage the buffer and prevent unwanted side effects.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 简单版本的 *生产者-消费者问题* 是指有一个进程 *生产* 数据，另一个进程 *消费* 数据，使用一个 *缓冲区* 或容器来存储数据。这需要生产者和消费者之间的协调来管理缓冲区并防止不希望出现的副作用。
- en: How to do it…
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we consider a simple solution to the producer-consumer problem
    using `std::condition_variable` to coordinate the processes:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们考虑了一个简单的解决方案来处理生产者-消费者问题，使用 `std::condition_variable` 来协调进程：
- en: 'We begin with some namespace and alias declarations for convenience:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们开始进行一些命名空间和别名声明：
- en: '[PRE95]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `lock_guard` and `unique_lock` aliases make it easier to use these types
    without error.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock_guard` 和 `unique_lock` 别名使得使用这些类型时更不容易出错。'
- en: 'We use a couple of constants:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一些常量：
- en: '[PRE96]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Keeping these in one place makes it safer and easier to experiment with different
    values.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容放在一个地方可以使其更安全，也更容易对不同值进行实验。
- en: 'We''re using these global variables for coordinating the data store:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用这些全局变量来协调数据存储：
- en: '[PRE97]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We're using `deque` to hold the data as a **First-In-First-Out** (**FIFO**)
    queue.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `deque` 来存储数据，作为一个 **先进先出**（**FIFO**）队列。
- en: '`mutex` is used with the `condition_variable` to coordinate the movement of
    data from producer to consumer.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex` 与 `condition_variable` 一起使用来协调数据从生产者到消费者的移动。'
- en: The `finished` flag indicates that there is no more data.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`finished` 标志表示没有更多数据。'
- en: 'The producer thread will use this function:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者线程将使用这个函数：
- en: '[PRE98]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `producer()` function loops `num_items` iterations and pushes a number onto
    the `deque` each time through the loop.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer()` 函数循环 `num_items` 次迭代，每次循环都将一个数字推入 `deque`。'
- en: We include a `sleep_for()` call to simulate a delay in producing each value.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括一个 `sleep_for()` 调用来模拟每次产生值时的延迟。
- en: The `conditional_variable` requires a `mutex` lock to operate. We use `lock_guard`
    (via the `guard_t` alias) to obtain the lock, then push the value onto the `deque`,
    and then call `notify_all()` on the `conditional_variable`. This tells the consumer
    thread that there is a new value available.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditional_variable` 需要一个 `mutex` 锁来操作。我们使用 `lock_guard`（通过 `guard_t` 别名）来获取锁，然后将值推入
    `deque`，然后在 `conditional_variable` 上调用 `notify_all()`。这告诉消费者线程有新的值可用。'
- en: When the loop completes, we set the `finished` flag and notify the consumer
    thread that the producer is completed.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环完成时，我们设置 `finished` 标志并通知消费者线程生产者已完成。
- en: 'The consumer thread waits for each value from the producer, displays it on
    the console, and waits for the `finished` flag:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者线程等待从生产者那里获取每个值，将其显示在控制台上，然后等待 `finished` 标志：
- en: '[PRE99]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `wait()` method waits to be notified by the producer. It uses the lambda
    as a predicate to continue waiting until the `deque` is *not empty* or the `finished`
    flag is set.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 方法等待被生产者通知。它使用 lambda 作为谓词，继续等待直到 `deque` 不为空或 `finished` 标志被设置。'
- en: When we get a value, we display it and then pop it from the `deque`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取一个值时，我们显示它，然后从 `deque` 中弹出它。
- en: 'We run this in `main()` with simple `thread` objects:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `main()` 中使用简单的 `thread` 对象运行它：
- en: '[PRE100]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Output:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE101]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Notice that there's a 200 ms delay between each line. This tells us that the
    producer-consumer coordination is working as expected.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每行之间有 200 毫秒的延迟。这告诉我们生产者-消费者协调工作如预期。
- en: How it works…
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The producer-consumer problem requires coordination between writing and reading
    a buffer or container. In this example, our container is a `deque<size_t>`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者-消费者问题需要在缓冲区或容器中写入和读取之间进行协调。在这个例子中，我们的容器是一个 `deque<size_t>`：
- en: '[PRE102]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `condition_variable` class can block a thread, or multiple threads, while
    a shared variable is modified. It may then notify other threads that the value
    is available.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_variable` 类可以在修改共享变量时阻塞一个线程或多个线程。然后它可以通知其他线程值已可用。'
- en: '`condition_variable` requires a `mutex` to perform the lock:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_variable` 需要一个 `mutex` 来执行锁定：'
- en: '[PRE103]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `std::lock_guard` acquires a lock, so we can push a value onto our `deque`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::lock_guard` 获取一个锁，这样我们就可以将一个值推入我们的 `deque`。'
- en: 'The `wait()` method on `condition_variable` is used to block the current thread
    until it receives a notification:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_variable` 上的 `wait()` 方法用于阻塞当前线程，直到它收到通知：'
- en: '[PRE104]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The predicate form of `wait()` is equivalent to:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 的谓词形式等同于：'
- en: '[PRE105]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The predicate form is used to prevent spurious waking while waiting for a specific
    condition. We use it with a lambda in our example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词形式用于防止在等待特定条件时产生虚假唤醒。我们在示例中使用 lambda：
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This prevents our consumer from waking until the `deque` has data or the `finished`
    flag is set.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了消费者在 `deque` 有数据或 `finished` 标志被设置之前醒来。
- en: 'The `condition_variable` class has two notification methods:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition_variable` 类有两个通知方法：'
- en: '`notify_one()` unblocks one waiting thread'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_one()` 解锁一个等待的线程'
- en: '`notify_all()` unblocks all waiting threads'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_all()` 解锁所有等待的线程'
- en: We used `notify_all()` in our example. Because there is only one consumer thread,
    either notification method would work the same.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用了 `notify_all()`。因为只有一个消费者线程，所以任何通知方法都会产生相同的效果。
- en: Note
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `unique_lock` is the *only* form of lock that supports the `wait()`
    method on a `condition_variable` object.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`unique_lock` 是支持 `condition_variable` 对象上的 `wait()` 方法的 *唯一* 锁形式。
- en: Implement multiple producers and consumers
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多个生产者和消费者
- en: The *producer-consumer problem* is really a set of problems. Solutions will
    differ if the buffer is bounded or unbounded, or if there are multiple producers,
    multiple consumers, or both.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*生产者-消费者问题* 实际上是一组问题。如果缓冲区是有界的或无界的，或者有多个生产者、多个消费者或两者都有，解决方案将不同。'
- en: Let's consider a case with multiple producers, multiple consumers, and a bounded
    (limited capacity) buffer. This is a common condition.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有多个生产者、多个消费者和有界（有限容量）缓冲区的案例。这是一个常见的情况。
- en: How to do it…
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we''ll look at a case with multiple producers and consumers
    and a *bounded buffer*, using a variety of techniques we''ve covered in this chapter:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看一个具有多个生产者和消费者以及 *有界缓冲区* 的案例，使用我们在本章中介绍的各种技术：
- en: 'We''ll start with some constants for convenience and reliability:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`consumer_wait` is a `duration` object, used with the `consumer` condition
    variable.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue_limt` is the buffer limit – the maximum number of items in the `deque`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_items` is the maximum number of items produced per `producer`.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_producers` is the number of spawned producers.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_producers` is the number of spawned consumers.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need some objects to control the process:'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`q_mutex` controls access to `deque`.*   `cv_producer` is a condition variable
    that coordinates producers.*   `cv_consumer` is a condition variable that coordinates
    consumers.*   `production_complete` is set `true` when all producer threads have
    finished.*   The `producer()` threads run this function:'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The passed value `id` is a sequential number used to identify the producer.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The main `for` loop repeats `num_item` times. The `sleep_for()` function is
    used to simulate some work required to produce an item.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Then we obtain a `unique_lock` from `q_mutex` and invoke `wait()` on `cv_producer`,
    using a lambda that checks the size of the `deque` against the `queue_limit` constant.
    If the `deque` has reached maximum size, the `producer` waits for `consumer` threads
    to reduce the size of the `deque`. This represents the *bounded buffer* limit
    on the producer.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Once the condition is satisfied, we push an *item* onto the `deque`. The item
    is a formatted string with the producer's `id`, the size of `qs`, and an item
    number (`i + 1`) from the loop control variable.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we notify the consumers that new data is available, with `notify_all()`
    on the `cv_consumer` condition variable.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'The `consumer()` threads run this function:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The passed `id` value is a sequential number used to identify the consumer.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The main `while()` loop continues until `production_complete` is set.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: We obtain `unique_lock` from `q_mutex` and invoke `wait_for()` on `cv_consumer`,
    with a timeout and a lambda that tests if the `deque` is empty. We need the timeout
    because it's possible for the `producer` threads to finish while some of the `consumer`
    threads are still running, leaving the `deque` empty.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a non-empty `deque`, we can print (*consume*) an *item* and pop
    it off the `deque`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we use `async()` to spawn the `producer` and `consumer` threads.
    `async()` conforms to the RAII pattern, so I''ll usually prefer it over `thread`,
    where possible. `async()` returns a `future` object, so we''ll keep a list of
    `future<void>` objects for process management:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We use `for` loops to create `producer` and `consumer` threads.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use `list` of `future` objects to determine when our `producer`
    and `consumer` threads are complete:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We loop through our `producers` container, calling `wait()` to allow the `producer`
    threads to complete. Then, we can set the `production_complete` flag. We likewise
    loop through the `consumers` container, calling `wait()` to allow the `consumer`
    threads to complete. We could perform any final analysis or completion processes
    here.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历 `producers` 容器，调用 `wait()` 允许 `producer` 线程完成。然后，我们可以设置 `production_complete`
    标志。我们同样遍历 `consumers` 容器，调用 `wait()` 允许 `consumer` 线程完成。我们可以在这里执行任何最终的解析或完成过程。
- en: 'The output is a bit long to show in its entirety:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出内容较长，无法全部展示：
- en: '[PRE113]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works…
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The heart of this recipe is in the use of two `condition_variable` objects
    to control the `producer` and `consumer` threads asynchronously:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的精髓在于使用两个 `condition_variable` 对象来异步控制 `producer` 和 `consumer` 线程：
- en: '[PRE114]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In the `producer()` function, the `cv_producer` object obtains a `unique_lock`,
    waits for the `deque` to be available, and notifies the `cv_consumer` object when
    an item has been produced:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `producer()` 函数中，`cv_producer` 对象获取一个 `unique_lock`，等待 `deque` 可用，并在有项目被生产时通知
    `cv_consumer` 对象：
- en: '[PRE115]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Conversely, in the `consumer()` function, the `cv_consumer` object obtains
    a `unique_lock`, waits for the `deque` to have items, and notifies the `cv_producer`
    object when an item has been consumed:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 `consumer()` 函数中，`cv_consumer` 对象获取一个 `unique_lock`，等待 `deque` 中有项目，并在有项目被消费时通知
    `cv_producer` 对象：
- en: '[PRE116]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: These complementary locks, waits, and notifications constitute the balance of
    coordination between multiple producers and consumers.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这些互补的锁、等待和通知构成了多个生产者和消费者之间协调的平衡。
