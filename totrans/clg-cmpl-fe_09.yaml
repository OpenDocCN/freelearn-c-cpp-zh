- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clang is renowned for its ability to provide suggestions for code fixes. For
    instance, if you miss a semicolon, Clang will suggest that you insert it. The
    ability to modify source code goes beyond the compilation process and is widely
    used in various tools for code modifications, particularly in refactoring tools.
    The ability to offer fixes is a powerful feature that extends the capabilities
    of a linter framework, such as Clang-Tidy, which not only detects issues but also
    provides suggestions for fixing them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore refactoring tools. We will begin by discussing
    the fundamental classes used for code modification, notably `clang``::``Rewriter`.
    We will use Rewriter to build a custom refactoring tool that changes method names
    within a class. Later in the chapter, we will reimplement the tool using Clang-Tidy
    and delve into `clang``::``FixItHint`, a component of the Clang Diagnostics subsystem
    that is employed by both Clang-Tidy and the Clang compiler to modify source code.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude the chapter, we will introduce a crucial Clang tool called Clang-Format.
    This tool is widely employed for code formatting. We will explore the functionality
    offered by the tool, delve into its design, and understand the rationale behind
    specific design decisions made during its development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a custom Clang tool for code refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate code modifications into a Clang-Tidy check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Clang-Format and how it can be integrated with Clang-Tidy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located in the `chapter7` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Custom code modification tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a Clang tool that will help us to rename methods for a class
    that is used for unit testing. We will start with a description for the `clang``::``Rewriter`
    class – the basic class that is used for code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1 Code modification support at Clang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`clang``::``Rewriter` is a Clang library class that facilitates source code
    rewriting operations within a translation unit. It provides methods for inserting,
    removing, and replacing code within the**Abstract Syntax Tree** **(AST)** of the
    source code. Developers can use `clang``::``Rewriter` for complex code modifications,
    such as restructuring or generating new code constructs. It can be applied for
    both code generation and code refactoring tasks, making it versatile for various
    code transformation purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: The class has several methods for text insertion; for instance, `clang``::``Rewriter`
    `::``InsertText` inserts the text at the specified source location, and `clang`
    `::``SourceLocation` is used to specify the exact location at the buffer, see
    [*Section** 4.4.1*](B19722_04.xhtml#x1-790001)*,* *SourceManager and SourceLocation*.
    In addition to the text insertion, you can also remove text with `clang``::``Rewriter``::``RemoveText`
    or replace text with a new one using `clang``::``Rewriter``::``ReplaceText`. The
    last two use source range (`clang``::``SourceRange`) to specify the positions
    at the text to be removed or replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '`clang``::``Rewriter` uses `clang``::``SourceManager`, as explained in [*Section** 4.4.1*](B19722_04.xhtml#x1-790001)*,
    SourceManager and SourceLocation*, to access the source code that needs to be
    modified. Let’s look at how Rewriter can be used in a real project.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.2 Test class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we have a class that is used for tests. The class name starts with the
    ”Test” prefix (for instance, `TestClass`), but there aren’t any ’test_’ prefixes
    for public methods of the class. For instance, the class has a public method with
    the name ’pos’ (`TestClass``::``pos`) instead of ’test_pos’ (`TestClass``::``test_pos``()`).
    We want to create a tool that will add such a prefix for the class methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Original code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE1]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified code**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 7.1**: Code transformations for TestClass'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we want the method `TestClass``::``pos` (see [Figure 7.1](#x1-136020r1))
    to be replaced with `TestClass``::``test_pos` at the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a code where we make a call to the method, the following replacement
    should be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Original code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE3]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified code**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 7.2**: Code transformations for TestClass’s method calls'
  prefs: []
  type: TYPE_NORMAL
- en: The tool should also ignore all public methods with the required modifications
    already applied, either manually or automatically. In other words, if a method
    already has the required ’test_’ prefix, the tool should not modify it.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a Clang tool called ’methodrename’, which will perform
    all the required code modifications. This tool will utilize the recursive AST
    visitor discussed in [*Section** 3.4*](B19722_03.xhtml#x1-620004)*, Recursive
    AST visitor*. The most crucial aspect is the implementation of the `Visitor` class.
    Let’s examine it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.3 Visitor class implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `Visitor` class should handle specific processing for the following AST
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clang``::``CXXRecordDecl`: This involves processing C++ class definitions
    with names starting with the ”Test” prefix. For such classes, all user-defined
    public methods should be prefixed with ”test_”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang``::``CXXMemberCallExpr`: Additionally, we need to identify all instances
    where the modified method is used and make the corresponding changes following
    the method’s renaming in the class definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The processing for `clang``::``CXXRecordDecl` nodes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.3**: CXXRecordDecl visitor implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 11-16* in [Figure 7.3](#x1-137017r3) represent the conditions that we
    require from the examined node. For example, the corresponding class name should
    start with the ”Test” prefix (see *Lines 15-16* in [Figure 7.3](#x1-137017r3)),
    where we utilize the `starts_with``()` method of the `llvm``::``StringRef` class.'
  prefs: []
  type: TYPE_NORMAL
- en: After verifying these conditions, we proceed to examine the methods within the
    found class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verification process is implemented in the `Visitor``::``processMethod`
    method, and its implementation is presented in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.4**: Implementation of `processMethod`'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 46-51* in [Figure 7.4](#x1-137040r4) contain the checks for the required
    conditions. For instance, in *Lines 46-47*, we verify that the method is public.
    *Lines 48-49* are used to exclude constructors from processing, and *Lines 50-51*
    serve to exclude methods that already have the required prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main replacement logic is implemented in *Lines 53-58*. Particularly, in
    *Lines* *56-57*, we create a special `clang``::``tooling``::``Replacement` object,
    which serves as a wrapper for required code modifications. The object’s parameters
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clang``::``SourceManager`: We obtain the source manager from `clang``::``ASTContext`
    at *Line 55*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`clang``::``SourceLocation`: The source location specifies the starting position
    for replacement. The position is passed as the second parameter of our `processMethod`
    method, as seen in *Line 45*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unsigned`: The length of the replaced text.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`clang``::``StringRef`: The replacement text, which we create at *Line* *54*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We store the replacement in the `Replaces` object, a private member of our
    Visitor class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a special getter to access the object outside the Visitor class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We log the action at *Lines 59-60*, using `LogMessage` as the prefix for the
    log message. Different log messages are used for different AST nodes; for instance,
    we use ”Renamed method” (see [Figure 7.3](#x1-137017r3), *Line 19*) for `clang``::``CXXRecordDecl`.
  prefs: []
  type: TYPE_NORMAL
- en: The log message will be different for the method call. The corresponding processing
    is shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.5**: CXXMemberCallExpr visitor implementation'
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the class name, which holds the test method, starts with the
    ’Test’ prefix at *Lines 27-29*. The replacement source location is obtained at
    *Line 30*. At *Line 31*, we call our `processMethod` function to process the found
    method, passing the ”Renamed method call” as the log message to the call.
  prefs: []
  type: TYPE_NORMAL
- en: The `Visitor` is initialized in the `Consumer` class, which will be our next
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.4 Consumer class implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Consumer` class initializes the Visitor and starts AST traversal in the
    `HandleTranslationUnit` method. The class can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.6**: Consumer class implementation'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the Visitor and begin traversal at *Lines 9-10* (see [Figure 7.6](#x1-138025r6)).
    The Rewriter is created at *Line 13*, and replacements are applied at *Lines 14-19*.
    Finally, the result is stored in the original file at *Lines 22-24*.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor and Consumer classes are wrapped within the `clangbook``::``methodrename`
    namespace. The Consumer instance is created in the FrontendAction class. This
    class’s implementation mirrors that of the `RecursiveVisitor` and `DeclVisitor`,
    as detailed in [Figure 3.8](B19722_03.xhtml#x1-60077r8). The only difference is
    the use of the `clangbook``::``methodrename` namespace for the new tool.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.5 Build configuration and main function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main` function for our tool is similar to the recursive visitor one defined
    in [Figure 3.21](B19722_03.xhtml#x1-62057r21):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.7**: The main function for the ’methodrename’ test tool'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we changed only the namespace name for our custom frontend action
    at *Line 23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build configuration is specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.8**: Build configuration for ’methodrename’ test tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most notable changes, compared to the code from [Figure 3.20](B19722_03.xhtml#x1-62028r20),
    are at *Lines* *23 and 24*, where we added two new libraries to support code modifications:
    `clangToolingCore` and `clangRewrite` . Other changes include the new name for
    the tool (*Line 2*) and the source file that contains the main function (*Line*
    *14*).'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we finish with the code, it’s time to build and run our tool.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.6 Running the code modification tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The program can be compiled using the same sequence of commands as we used
    previously in [*Section** 3.3*](B19722_03.xhtml#x1-590003)*, AST traversal*, see
    [Figure 3.11](B19722_03.xhtml#x1-60132r11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.9**: Configure and build commands for ’methodrename’ tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the create tool on the following test file (`TestClass.cpp` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.10**: Original TestClass.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.11**: Running methodrename Clang Tool on TestClass.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the method `TestClass``::``pos` was renamed to `TestClass``::``test_pos`.
    The method call was also updated, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.12**: Modified TestClass.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The provided example demonstrates how Clang can assist in creating refactoring
    tools. The created Clang Tool uses a recursive visitor to set up the required
    code transformation. Another possible option is to use Clang-Tidy, which we investigated
    earlier in [*Chapter** 5*](B19722_05.xhtml#x1-990005)*, Clang-Tidy Linter Framework*.
    Let’s examine this option in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Clang-Tidy as a code modification tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We plan to investigate `FixItHint`, which is a part of the Clang Diagnostics
    subsystem (see [*Section** 4.4.2*](B19722_04.xhtml#x1-800002)*, Diagnostics support*).
    `FixItHint` can be integrated with `clang``::``Rewriter` and `clang``::``tooling``::``Replacement`
    explored previously, providing advanced diagnostics that are used in powerful
    tools such as Clang-Tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.1 FixItHint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`clang``::``FixItHint` is a class in the Clang compiler that significantly
    enhances its diagnostic capabilities. Its primary role is to provide automated
    suggestions for correcting code errors or issues that the compiler detects. These
    suggestions, known as ”fix-its,” are a part of Clang’s diagnostic messages and
    are intended to guide developers in resolving identified issues in their code.'
  prefs: []
  type: TYPE_NORMAL
- en: When Clang encounters a coding error, warning, or stylistic issue, it generates
    a `FixItHint`. This hint contains specific recommendations for changes in the
    source code. For instance, it may suggest replacing a snippet of text with a corrected
    version or inserting or removing code at a particular location.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.13**: Test file foo.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run a compilation for the file, we will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.14**: Compilation error generated in foo.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the compiler suggests adding the `static` keyword at *Line 2*
    for the program shown in [Figure 7.13](#x1-142007r13).
  prefs: []
  type: TYPE_NORMAL
- en: The error is processed by Clang using the FixItHint object, as shown in [Figure 7.15](#x1-142022r15).
    As seen in [Figure 7.15](#x1-142022r15), when Clang detects an issue in the source
    code and generates a diagnostic, it can also produce a `clang``::``FixItHint`
    that suggests how to fix the issue. The hint is later processed by the Clang diagnostics
    subsystem and displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to highlight that the hint can also be converted into a `Replacement`
    object, which represents the exact text change needed. For example, Clang-Tidy
    uses the `Replacement` object as temporary storage for information from `FixItHint`
    in its `DiagnosticConsumer` class implementation, allowing the FixItHint to be
    converted into a `Replacement` object that represents the exact text change needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.15**: Code fragment from clang/lib/AST/ExprConstant.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, `clang::FixItHint` enhances the user-friendliness and utility of Clang,
    providing developers with practical tools for improving code quality and resolving
    issues efficiently. Its integration into Clang’s diagnostic system exemplifies
    the compiler’s emphasis on not only pinpointing code issues but also aiding in
    their resolution. We are going to utilize this feature in a Clang-Tidy check that
    will rename methods in a test class and convert the code shown in [Figure 7.10](#x1-140016r10)
    to that in [Figure 7.12](#x1-140033r12).
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.2 Creating project skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s create the project skeleton for our Clang-Tidy check. We will name our
    check ”methodrename” and it will be a part of ”misc” set of Clang-Tidy checks.
    We will use the command from [Section 5.4.1](B19722_05.xhtml#x1-1100001)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.16**: Creating a skeleton for the misc-methodrename check'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command from [Figure 7.16](#x1-143002r16) should be run from the root of
    the cloned LLVM project. We specified two parameters for the `add``_new``_check.py`
    script: `misc` – the set of checks that will contain our new check, and `methodrename`
    – the name of our check.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.17**: Artefacts created for misc-methodrename check'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to modify at least two generated files in the `./clang-tools-extra/clang-tidy`
    `/misc` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodrenameCheck.h` : This is the header file for our check. Here, we want
    to add an additional private method `processMethod` for checking the method’s
    properties and displaying diagnostics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MethodrenameCheck.cpp` : This file contains the processing logic, and we need
    to implement three methods: `registerMatchers`, `check`, and the newly added private
    method `processMethod`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 7.3.3 Check implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with modifications to the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.18**: MethodrenameCheck.h modifications'
  prefs: []
  type: TYPE_NORMAL
- en: The added private method `MethodrenameCheck``::``processMethod` has the same
    parameters as the method introduced earlier in our Clang Tool ’methodrename’,
    as seen in [Figure 7.4](#x1-137040r4).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the implementation with the `MethodrenameCheck``::``registerMatchers`
    method of our check as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.19**: Implementation of registerMatchers'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 30 and 31* register two matchers. The first one is for method declarations
    (bound to the ”method” identifier), and the second one is for method calls (bound
    to the ”call” identifier).'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use a **Domain Specific Language (DSL)** defined in [*Section** 3.5*](B19722_03.xhtml#x1-630005)*,*
    *AST matchers*. The `ClassMatcher` specifies that our method declaration has to
    be declared within a class with a name starting with the ”Test” prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The method declaration matcher (`MethodMatcher`) is defined at *Line 28*. It
    must be declared within the class specified by `ClassMatcher` and should be a
    test method (details about the `isNotTestMethod` matcher will be described below).
  prefs: []
  type: TYPE_NORMAL
- en: The last matcher, `CallMatcher`, is defined at *Line 29* and specifies that
    it must be a call to a method that satisfies the conditions of `MethodMatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isNotTestMethod` matcher is an ad-hoc matcher that is used to check our
    specific conditions. We can define our own matchers using `AST_MATCHER` and related
    macros. The implementation for it can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.20**: isNotTestMethod matcher implementation'
  prefs: []
  type: TYPE_NORMAL
- en: The macro has two parameters. The first one specifies the AST node we want to
    check, which is `clang``::``CXXMethodDecl` in our case. The second parameter is
    the matcher name that we want to use for the user-defined matcher, which is `isNotTestMethod`
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: The AST node can be accessed as a `Node` variable at the macro body. The macro
    should return `true` if the Node matches the required conditions. We use the same
    conditions we used for our ’methodrename’ Clang Tool in [Figure 7.4](#x1-137040r4)
    (*Lines* *46-51*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MethodrenameCheck``::``check` is the main method for our check and can
    be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.21**: check implementation'
  prefs: []
  type: TYPE_NORMAL
- en: The code has two blocks. The first one (*Lines 35-37*) processes method declarations,
    and the last one (*Lines 39-42*) processes method calls. Both call `MethodrenameCheck`
    `::``processMethod` to display diagnostics and create the required code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine how it’s implemented and how `clang``::``FixItHint` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.22**: processMethod implementation'
  prefs: []
  type: TYPE_NORMAL
- en: We print diagnostics about the detected issue at *Line 49*. *Lines 50-51* print
    an informational message about the suggested code modifications and create the
    corresponding code replacement at *Line 51*. To insert text, we use `clang``::``FixItHint``::``CreateInsertion`.
    We also display the insertion as a note for our primary warning.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as all the required changes are applied to the generated skeleton, it’s
    time to build and run our check on a test file.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.4 Build and run the check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We assume that build configuration from [Figure 1.12](B19722_01.xhtml#x1-30003r12)
    was used. Thus, we have to run the following command to build our check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can install it to the `install` folder with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run our check as follows on the `TestClass` from [Figure 7.10](#x1-140016r10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.23**: Clang-Tidy misc-methodrename check run on the test file TestClass.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.24**: Warning generated for TestClass.cpp by misc-methodrename check'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the check correctly detected two places where the method name
    has to be changed and created replacements. The command from [Figure 7.23](#x1-145003r23)
    does not modify the original source file. We have to specify an additional argument
    `-fix-notes` to apply the insertions specified as notes to the original warnings.
    The required command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.25**: Clang-Tidy with -fix-notes option'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.26**: Clang-Tidy fixes applied to the TestClass.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the required insertions were applied here. Clang-Tidy has powerful
    tools to control the applied fixes and can be considered a significant resource
    for code modification. Another popular tool used for code modification is Clang-Format.
    As the name suggests, this tool specializes in code formatting. Let’s explore
    it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Code modification and Clang-Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clang-Format is an essential tool in the Clang/LLVM project, designed for formatting
    C, C++, Java, JavaScript, Objective-C, or Protobuf code. It plays a crucial role
    in the Clang tooling ecosystem, offering capabilities for parsing, analyzing,
    and manipulating source code.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format is a part of Clang and has to be installed if we have built and
    installed the Clang compiler. Let’s look at how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1 Clang-Format configuration and usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clang-Format uses `.clang-format` configuration files. The utility will use
    the closest configuration file; i.e., if the file is located at the folder with
    the source files we want to format, then the configuration from the folder will
    be used. The format for configuration files is YAML, which is the same format
    used for Clang-Tidy configuration files, as shown in [*Figure** 5.12*](B19722_05.xhtml#x1-1080002)*,*
    *Clang-Tidy configuration*. Let’s create the following simple configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 7.27**: Simple .clang-format configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file says that we will use the code style defined by LLVM,
    see [https://llvm.org/docs/CodingStandards.html](https://llvm.org/docs/CodingStandards.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a non-formatted file `main.cpp` , then the following command
    will format it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the formatting is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Original code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE36]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatted code**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 7.28**: Formatting for main.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: In the example provided in [Figure 7.28](#x1-147032r28), we can see that the
    indentation defined by the LLVM code style was applied. We can also observe that
    Clang-Format broke *Line 6* in the original source code and made the main function
    definition start on a separate line. Additionally, we can see that Clang-Format
    added a comment to the namespace closing bracket in the formatted code at *Line*
    *6*.
  prefs: []
  type: TYPE_NORMAL
- en: After considering the usage example, it’s time to look at the internal design
    of Clang-Format.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.2 Design considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the core of Clang-Format is the Clang Lexer (see [*Figure** 2.5*](B19722_02.xhtml#x1-380002)*,
    Lexer*), which tokenizes the input source code, breaking it down into individual
    tokens like keywords, identifiers, and literals. These tokens serve as the basis
    for formatting decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial Clang-Format design document considered the Parser and AST as basic
    components for formatting. Despite the advantages provided by advanced data structures
    such as the AST, this approach has some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The Parser requires a full build process and, therefore, build configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Parser has limited capabilities to process a part of the source text, which
    is a typical task for formatting, such as formatting a single function or a source
    range of the source file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting macros is a challenging task when using the AST as the basic structure
    for formatting. For instance, the processed macro may not be called in the compiled
    code and, as a result, may be missed in the AST.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Parser is much slower than the Lexer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang-Format leverages `clang``::``tooling``::``Replacement` to represent code
    formatting changes and utilizes `clang``::``Rewriter` to apply these changes to
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration plays a pivotal role in Clang-Format’s operation. Users define
    their preferred formatting style by configuring rules in a `.clang-format` file.
    This configuration specifies details such as indentation width, brace placement,
    line breaks, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Format supports various predefined and customizable formatting styles,
    such as ”LLVM,” ”Google,” and ”Chromium.” Users can select a style that aligns
    with their project’s coding standards.
  prefs: []
  type: TYPE_NORMAL
- en: Once tokenized, Clang-Format processes the token stream, taking into account
    the current context, indentation level, and configured style rules. It then adjusts
    whitespace and line breaks accordingly to adhere to the chosen style.
  prefs: []
  type: TYPE_NORMAL
- en: One notable feature of Clang-Format is its ability to handle macros effectively,
    preserving the original formatting within macros and complex macros.
  prefs: []
  type: TYPE_NORMAL
- en: Customization is a key aspect of Clang-Format. Users can extend or customize
    its behavior by defining custom rules and formatting options in the configuration
    file. This flexibility allows teams to enforce specific coding standards or adapt
    Clang-Format to project-specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: It offers a user-friendly command-line interface, enabling manual code formatting
    or integration into scripts and automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang-Format utilizes Clang’s Format library to generate formatted code accurately.
    This library ensures that the code consistently follows the desired formatting
    style. The design follows the main paradigm of LLVM: ”everything is a library,”
    as discussed in [*Section** 1.2.1*](B19722_01.xhtml#x1-200001)*, Short LLVM history*.
    Thus, we can effectively use the formatting functionality in other Clang Tools.
    For instance, formatting can be used with Clang-Tidy to format code with fixes
    applied by Clang-Tidy. Let’s consider an example of how this functionality can
    be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3 Clang-Tidy and Clang-Format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The applied Clang-Tidy fixes can break formatting. Clang-Tidy suggests using
    the `-format-style` option to address the problem. This option will apply formatting
    using the functionality provided by the clangFormat library. The formatting is
    applied to the modified lines of code. Consider an example when our TestClass
    has broken formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run Clang-Tidy as we did before (see [Figure 7.25](#x1-145011r25)), then
    the formatting will remain unchanged and broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Original code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE38]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applied fixes**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 7.29**: Applying Clang-Tidy fixes without formatting on TestClassNotFormated.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: We used the following command for [Figure 7.29](#x1-149026r29)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be different if we run Clang-Tidy with `-format-style` option,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see the ’llvm’ formatting style was chosen for the example. The result
    is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Original code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[PRE42]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applied fixes with formatting**'
  prefs: []
  type: TYPE_NORMAL
- en: '****Figure 7.30**: Applying Clang-Tidy fixes with formatting on TestClassNotFormated.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between Clang-Tidy and Clang-Format, as we just demonstrated,
    can be visualized as presented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: Clang-Tidy and Clang-Format integration ](img/Figure7.31_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.31**: Clang-Tidy and Clang-Format integration'
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, both Clang-Tidy and Clang-Format use the `clangFormat` library
    to format the code.
  prefs: []
  type: TYPE_NORMAL
- en: The provided example demonstrates the integration of various Clang Tools. Modularity,
    an essential design decision in LLVM/Clang, is a key component for such integration.
    This example is not unique, and we will explore the further integration of different
    Clang Tools to enhance the development experience in **Integrated Development
    Environments** (**IDEs**) like **Visual Studio Code** (**VS Code**). This will
    be the topic of our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we investigated the different options provided by Clang for
    code modifications. We created a specialized Clang Tool that renames a method
    in a test class. We also rewrote the tool using Clang-Tidy and explored how custom
    AST matchers can be created. Furthermore, we delved into a variety of different
    classes provided by Clang for code modifications. One of these classes, `clang``::``FixItHint`,
    is integrated with the Clang diagnostics subsystem and provides a powerful tool
    for code modification within Clang, as well as in different tools created with
    Clang. We concluded with Clang-Format, the only tool in the book that does not
    use the AST but instead utilizes the Clang Lexer to perform code formatting. The
    next chapter will focus on the integration of different Clang Tools within IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang-Format Style Options: [https://clang.llvm.org/docs/ClangFormatStyleOptions.html](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peter Goldsborough, Emitting Diagnostics in Clang [[23](B19722_Bib.xhtml#Xmisc_peter_goldsborough)]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AST Matcher Reference: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)********************'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
