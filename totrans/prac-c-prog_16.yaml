- en: Low-Level Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, for precise results and in order to overcome the limitations of
    a programming language, you need to control the content of CPU registers at the
    bit level. In such situations, you can make use of two things: bitwise operators
    and assembly language programming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to perform the following recipes in order
    to carry out low-level programming in C:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a binary number into a decimal using a bitwise operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a decimal into binary using a bitwise operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a decimal number into binary using bit masking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplying two numbers using the inline assembly language in C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing two numbers using assembly code in C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every number that we enter into any variable is internally stored in the form
    of binary digits. To perform bit-level operations, C provides the following bitwise
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: '& (binary AND)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This results in a binary 1 if both the operands are 1\. If either of the bits
    is 0, then the result of the & operation is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A&B will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 0111 |'
  prefs: []
  type: TYPE_TB
- en: '| A&B | 0010 |'
  prefs: []
  type: TYPE_TB
- en: '| (binary OR)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This results in a binary 1 if either of the operands is 1\. If both of the bits
    are 0, then the result of the | operation is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A|B will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 0111 |'
  prefs: []
  type: TYPE_TB
- en: '| A&#124;B | 1111 |'
  prefs: []
  type: TYPE_TB
- en: ^ (binary XOR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This results in a binary 1 if either of the operands is 1 but not both. If both
    of the bits are 0, or if both are 1, then the result of the ^ operation is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that operand A has a value of 1010 and operand B has a value of 0111,
    then A^B will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 0111 |'
  prefs: []
  type: TYPE_TB
- en: '| A^B | 1111 |'
  prefs: []
  type: TYPE_TB
- en: ~ (binary complement)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This negates or inverses the binary digits of the operand. That is, the binary
    digit 1 will be converted to 0 and vice versa. Assuming that operand A has a value
    of 1010, then ~A will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| ~A | 0101 |'
  prefs: []
  type: TYPE_TB
- en: << (binary shift left)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This left-shifts the binary digits of the operand by the specified number of
    bits, and the empty space created after the least significant bits is filled with
    0s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that operand A has a value of 00001010, then left-shifting A by 2
    bits (A<<2) will give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 00001010 |'
  prefs: []
  type: TYPE_TB
- en: '| A<<2 | 00101000 |'
  prefs: []
  type: TYPE_TB
- en: On every left-shift, the value of the operand is multiplied by powers of 2\.
    That is, if the operand is left-shifted by 2 bits, that means it is multiplied
    by 2 x 2, that is, 4.
  prefs: []
  type: TYPE_NORMAL
- en: '>> (binary shift right)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This right-shifts the binary digits of the operand by the specified number of
    bits, and the empty space created after the most significant bits is filled with
    0s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that operand A has a value of 00001010, then right-shifting A by 2
    bits (A>>2) will give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | 00001010 |'
  prefs: []
  type: TYPE_TB
- en: '| A>>2 | 00000010 |'
  prefs: []
  type: TYPE_TB
- en: You can see that on right-shifting, the least significant bits are dropped off.
    On every right-shift, the value of the operand is divided by powers of 2\. That
    is, if the operand is right-shifted by 2 bits, that means it is divided by 2 x
    2, that is, 4.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go on to gain some practical knowledge by making some working recipes.
    The first recipe is next.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a binary number into a decimal using a bitwise operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to convert a binary number into a decimal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert a binary number into a decimal, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a binary number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply a mod 10 (`% 10`) operator to the binary digits of the binary number to
    isolate the last bit of the binary number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-shift the binary digit isolated in *step 2* to multiply it by the power
    of 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the product of the previous multiplication to the variable that will store
    the result, that is, the decimal number. Let's call the variable `dec`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last digit of the binary number is truncated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2* to *step 4* until all the bits of the binary digits are over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the decimal in the `dec` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for converting a binary number into a decimal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be prompted to enter a binary number. The number you enter will be
    assigned to the `bin` variable. The binary number is temporarily assigned to a
    `temp` variable. A `while` loop is executed until the binary number in the `bin` variable
    becomes 0.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the binary number entered in the `bin` variable is `1101`.
    Then, we will apply the `mod` (`%`) operator to the binary digits in the `bin` variable
    in order to isolate its last bit. In fact, the `%` operator divides by the specified
    number and returns the remainder. That is, when `% 10` is applied to `1 1 0 1`,
    it will return `1`, which is then assigned to the `num` variable.
  prefs: []
  type: TYPE_NORMAL
- en: A `topower` variable is initialized to `0`. The purpose of the `topower` variable
    is to left-shift the digits, that is, to multiply the binary digits by the power
    of `2`. The binary digit `1` in the `num` variable is added to another variable
    called `dec`. The value of the `topower` variable is incremented to `1`. The binary
    number `1 1 0 1` in the `bin` variable is truncated to `1 1 0` by dividing it
    by `10` and removing the fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the whole procedure is repeated. The last digit in the `bin` variable
    is isolated by the application of the `%10` operator; that is, `0` will be isolated
    from `1 1 0` and assigned to the `num` variable. The binary digit `0` is left-shifted
    by `1` bit, making it `0 0`. So, a value of `0` is then added to the value in the `dec` variable;
    that is, the value in the `dec` variable remains `1`. The value of `topower` is
    incremented to `2`. The last digit of the binary digit `1 1 0` in the `bin` variable
    is removed by dividing it by `10`; therefore, the binary digit in the `bin` variable
    will become `1 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, apply `%10` to `1 1`; the remainder will be `1`, which will be assigned
    to the `num` variable. The binary digit `1` is left-shifted by 2 bits, making
    it `1 0 0`. The binary value `1 0 0` represents `4`, which is then added to the
    value in the `dec` variable. The value in the `dec` variable was `1`, and after
    adding `4` to it, the total in the `dec` variable will become `5`. Again, the
    value in the `topower` variable will be incremented, making its value `3`. The
    last digit of the binary digits (`1 1`) in the `bin` variable will be truncated
    by dividing it by 10\. Hence, the digit in the `bin` variable will become `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, `%10` is applied to binary digit `1` in the `bin` variable. As a result
    of this, `1` will be assigned to the `num` variable. The binary digit `1` in the `num` variable
    is left-shifted by 3 bits, making it `1 0 0 0`. The binary value `1 0 0 0` represents `8`, which
    is then added to the value in the `dec` variable. The current value in the `dec` variable
    is `5`. On adding `8` to it, the value in the `dec` variable will become `13`. The
    value of the `topower` variable is incremented to `4`. The binary value `1` in the `bin` variable
    is divided by `10`, making it `0`. The `while` loop will terminate and the decimal
    value `13` in the `dec` variable is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole procedure can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40a9f30b-d8a8-41ef-b2b4-abf2fd07c7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `binintodec.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, this means the `binintodec.c` program has
    compiled into an executable file, `binintodec.exe`. Let''s run this executable
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully converted a binary number to a decimal using a bitwise
    operator. Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Converting a decimal into binary using a bitwise operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to convert a decimal number into a binary number
    by making use of a bitwise operator. Bitwise operators operate on the binary digits
    of a number and enable us to do precise manipulation as desired.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert a decimal number into a binary number by making use of a bitwise
    operator, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a decimal number. This number is internally stored in the form of binary
    digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Isolate the least significant bit of the decimal number by applying a logical
    AND operation between the entered decimal number and value `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The least significant bit that results from *step 2* is stored in an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-shift the binary digits of the decimal number by 1 bit. On shifting to
    the right, the second least significant bit will become the least significant
    bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 2* to *4* until all the binary digits of the decimal number are
    placed into the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The binary digits assigned to the array are the binary version of the entered
    decimal number. Display the binary digits in an array to get the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for converting a decimal into a binary number using a bitwise operator
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be prompted to enter a decimal number. The number you enter is assigned
    to the `num` variable. The value entered in the `num` variable is temporarily
    assigned to another variable, `temp`. A `while` loop is set to execute until the
    value of `num` becomes `0`. Apply the logical AND operation to isolate each binary
    digit of the number. For example, if the value entered in variable `num` is `13`,
    then, internally, it will be stored in a binary format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/843a9aec-7d2c-4131-9ece-3d1bd50c3e1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the least significant bit is isolated by applying the AND operation. That
    is, the binary digits of `13`are ANDed with `1` as follows. The ANDed means the
    AND operation is applied on binary digits of 13 and 1 :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ab2537f-2235-4ae0-a780-95128ed0d245.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The application of AND on binary digits** `1`** and `1` results in `1`. If
    either of the binary digits is `0`, then the result of AND will be `0`. So, the
    output of `num` AND `1` will be **1**, which will be stored into array `p` at
    index location `0` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de43bfe9-797e-4c46-9902-d77cde9f5efc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, right-shift the digits in the `num` variable by 1 bit. On shifting
    to the right, the least significant bit, `1`, will be dropped off and a `0` will
    be added to the most significant bit. Again, the new set of binary digits in the `num` variables
    is ANDed with `1`, that is, the AND operation is applied between the new set of
    binary digits in `num ` variable and `1`. The output of `num` AND **`1` **will
    be `0`, which is then assigned to array `p` at index location `1`; that is, `0` will
    be assigned to the `p[1]` location as shown in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dbdaf5c-b0e7-4355-ae9b-204533f1ba85.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, right-shift the digits in the `num` variable by 1 bit. Again, the least
    significant bit, `0`, will be dropped off and a `0` will be added to the most
    significant bit. Once more, the new set of binary digits in the `num` variables
    is ANDed with `1`, as shown in *Figure 16.6(a)*. The output of the `num` variable AND `1` will
    be`1`, which is then assigned to array `p` at index location `2`. Thereafter,
    right-shift the digits in the `num` variable again by 1 bit. The most significant
    bit in the `num` variable, `1`, will be dropped off and a `0` bit will be added
    to the most significant bit location. The binary digits in `num` are once more
    ANDed with `1` . ANDed here means, the AND operation is applied between the binary
    digits in num and 1\. The output of the AND operation will be `1`, which will
    be assigned to array `p` at index location `p[3]` (*Figure 16.6(b)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62b2c593-074a-40b4-9ad7-b7450ae8a7af.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 (a) and (b)
  prefs: []
  type: TYPE_NORMAL
- en: Now, the binary digits assigned to array `p` are the binary conversion of the
    number assigned to variable `num`. Simply display the binary digits in array `p` in
    reverse order to get the result. Hence, `1 1 0 1` is the binary conversion of `13`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `convertintobin.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means the `convertintobin.c` program
    has compiled into an executable file, `convertintobin.exe`. Let''s run this executable
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully converted a decimal number into a binary number using
    a bitwise operator. Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Converting a decimal number into binary using bit masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert a decimal number into a binary
    number by masking certain bits of a register. Masking means isolating or separating
    out the desired binary digits. Masking hides the undesired binary digits and makes
    only the desired binary digits visible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert a decimal number into a binary number using bit masking, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a decimal value. The decimal number entered is internally stored in the
    form of binary digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a number `1` followed by 31 zeros to a variable called `mask`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mask each of the binary digits of the decimal number one by one, beginning from
    the most significant bit. Apply an AND operation between the binary digits of
    the entered decimal number and the binary digits in the `mask` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-shift the binary digits in the `mask` variable by `1` bit making it `0
    1` followed by 30 zeros.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this procedure. Apply the AND operation between the entered decimal number
    and the `mask` variable and the resultant binary digit is displayed on the screen.
    The procedure is repeated until the value in the `mask` variable becomes `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for converting a decimal number into binary using bit masking is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be prompted to enter a decimal value. The decimal value you entered
    will be assigned to the `num` variable. Let''s assume that you have entered a
    value of `13`. This value will be internally stored in the form of binary digits
    in the `num` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1115dd56-feaf-42ce-a529-05c91dc5e53a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set a `totbits` variable to `32` bits because an `int` data type in
    C consists of `32` bits, and we have to mask each bit of the number in the `num` variable
    to display its binary version. We will define a `mask` variable and assign a value
    of `1` to it. To make the value `1` in the `mask` variable appear as `10000...00`,
    that is, `1` followed by 31 zeros, we will left-shift value `1` by `31` bits as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c45e3224-6be0-42d6-a744-1d66b328b76d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will execute a `for` loop `32` times to mask or isolate each bit in
    the `num` variable and display it. Within the `for` loop, we will apply an AND
    operation on the `num` and `mask` variables. Consequently, each of the binary
    digits of the two variables will be ANDed. We know that, in the AND operation,
    the output is `1` only when both of the bits are `1`. If either of the bits is `0`,
    the AND operation will return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.9* shows the application of the AND operation on the `num` and `mask` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cbab9b5-10bc-40ee-b527-9c306e0aebf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the value `0` is returned. Thereafter, we will right-shift the binary
    digits in the `mask` variable by `1` bit, making it `0 1` followed by 30 zeros.
    Again, when the AND operation is applied between the `num` and `mask` variables,
    the result will be `0` (refer to the following figure), which is then displayed
    on the screen. So, up until now, we have `0 0` displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/413430bf-f501-4b95-8692-c25a76f815b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will right-shift the binary digits in the `mask` variable by `1` bit,
    making `0 0 1` followed by 29 zeros. Again, when the AND operation is applied
    between the `num` and `mask` variables, the result will be `0`, which is then
    displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure and output will be the same for the next `25` bits; that is,
    we will get 28 zeros on the screen. After that, when we apply another right-shift
    operation on the binary digits of the `mask` variable, it will become `1 0 0 0`.
    On the application of the AND operation on the `num` and `mask` variables, we
    will get an output of `1`, which is then displayed on the screen. So, for now,
    we have 28 zeros followed by `1` bit on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b84697f1-c54a-4d11-b609-89f6569eab28.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.11
  prefs: []
  type: TYPE_NORMAL
- en: 'As we keep repeating the procedure, we will get the outputs shown in *Figure
    16.12*. We will have 28 zeros followed by `1 1` bits on the screen (*Figure 16.12
    (a)*). After another repetition, we will have 28 zeros followed by `1 1 0` bits
    on the screen (*Figure 16.12 (b)*). In the final execution of the `for` loop, the
    final binary version of the number assigned to the `num` variable will be 28 zeros followed
    by `1 1 0 1` (*Figure 16.12 (c)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee8309cc-b22f-4bd8-8cf1-a3b045257609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.12 (a), (b), and (c)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `decintobin.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means the `decintobin.c` program has
    compiled into an executable file, `decintobin.exe`. Let''s run this executable
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully converted a decimal number into binary using bit masking.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to assembly coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The x86 processors have eight 32-bit general-purpose registers. The names of
    some of these general-purpose registers are EAX, EBX, ECX, and EDX. These registers
    can be used in subsections. For example, the least significant 2 bytes of EAX
    can be used as a 16-bit register called AX. Again, the least significant byte
    of AX can be used as an 8-bit register called AL and the most significant byte
    of AX can be used as an 8-bit register called AH. Similarly, the BX register can
    be used in the form of the BH and BL registers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will be writing inline assembly code in this chapter because this code is
    easily integrated with C code during code generation. Consequently, the C and
    assembly code is optimized by the compiler to produce efficient object code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for using inline assembly code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `asm` statements are enclosed within quotes, and the outputs and inputs
    are in the form of `"constraint"` (name) pairs separated by commas. The constraints
    can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constraint ** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | Compiler will decide the register to be used for the variable |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Load into any available register |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Load into the `eax` register |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Load into the `ebx` register |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Load into the `ecx` register |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Load into the `edx` register |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Load into the floating-point register |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Load into the `edi` register |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Load into the `esi` register |'
  prefs: []
  type: TYPE_TB
- en: The outputs and inputs are referenced by numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying two numbers using the inline assembly language in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to multiply two numbers using the inline assembly
    language in C. By making use of inline assembly code, we can have better control
    over CPU registers, manipulate their values up to the bit level, and take advantage
    of C as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To multiply two numbers using the inline assembly language in C, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the two values to be multiplied into `eax` and `ebx` registers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the contents of the `eax` and `ebx` registers and store the result
    in the `eax` register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the content of the `eax` register on the screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for multiplying two digits using inline assembly code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assign the two numbers that we want to multiply to two integer variables, `var1`
    and `var2`. Thereafter, we will load the contents of the `var1` variable into
    the `eax` register and the contents of the `var2` variable into the `ebx` register.
    We will multiply the contents of the `eax` and `ebx` registers and store the result
    in the `eax` register.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the `eax` register is assigned to the `multi` variable. The content
    in this variable, which contains the multiplication of two variables, is displayed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `multiasm.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means the `multiasm.c` program has compiled
    into an executable file, `multiasm.exe`. Let''s run this executable file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully multiplied two numbers using the inline assembly language
    in C. Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Dividing two numbers using assembly code in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to divide two numbers using the inline assembly
    language in C. The assembly language provides us with better control over CPU
    registers, so we have to manually place the divisor and dividend in their respective
    registers. Additionally, after the division, the quotient and remainder will be
    automatically saved in their respective registers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To divide two numbers using assembly code in C, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the dividend into the `eax` register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the divisor into the `ebx` register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the `edx` register to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `divl` assembly statement to divide the content of the `eax` register
    by the content of the `ebx` register. By doing this division, the quotient will
    be assigned to any available register and the remainder will be assigned to the `ebx`
    register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The quotient is retrieved from the available register and the remainder is retrieved
    from the `ebx` register, and both are displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for dividing two digits using inline assembly code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assign the two numbers to be divided to the two variables `var1` and `var2`.
    Assign the dividend to `var1` and the divisor to `var2`. Thereafter, we will load
    the dividend from the `var1` variable into the `eax` register and the divisor
    from the `var2` variable into the `ebx` register.
  prefs: []
  type: TYPE_NORMAL
- en: The `edx` register has to be initialized to zero. To do this, we will initialize
    a `var3` variable to zero. From `var3`, the zero value is loaded into the `edx`
    register. Then, we will execute the `divl` assembly statement to divide the content
    of the `eax` register by the content of the `ebx` register. By doing this division,
    the quotient will be assigned to any available register and the remainder will
    be assigned to the `ebx` register.
  prefs: []
  type: TYPE_NORMAL
- en: The quotient from the available register is loaded into a variable called `quotient`,
    and the remainder from the `ebx` register is loaded into another variable called
    `remainder`. Finally, the quotient and remainder values are displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `asmdivide.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means the `asmdivide.c` program has
    compiled into an executable file, `asmdivide.exe`. Let''s run this executable
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully divided two numbers using assembly code in C.
  prefs: []
  type: TYPE_NORMAL
