- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Extending AI Behaviors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展AI行为
- en: Enhancing an enemy character’s behavior in a multiplayer game is a great way
    of making it more challenging and exciting for players. It can also help create
    a more immersive experience, as enemies become smarter, faster, and stronger.
    By introducing new abilities or changing existing ones, you can make your game
    stand out from other similar titles on the market.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中增强敌人角色的行为是让游戏更具挑战性和趣味性的好方法。它还可以帮助创造更沉浸式的体验，因为敌人变得更聪明、更快、更强。通过引入新的能力或改变现有的能力，你可以让你的游戏在市场上与其他类似标题脱颖而出。
- en: In this chapter, you will learn how to add improvements to your minion’s AI
    behavior – this will involve creating some sort of communication between your
    hero character’s stealth abilities and the undead minion sensing system. Additionally,
    you will learn how to make your opponents communicate and cooperate with each
    other, in order to give your thief a hard time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何为你的随从的AI行为添加改进——这涉及到在你的英雄角色的潜行能力和不死随从感知系统之间建立某种形式的沟通。此外，你还将学习如何让你的对手相互沟通和合作，以便让你的盗贼难以对付。
- en: You will also implement a health system for the AI opponents, make your character
    attack, and impart some damage on them. Finally, you will create some variations
    for the minions in order to make them less predictable and more engaging.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将为AI对手实现一个健康系统，让你的角色攻击，并对他们造成伤害。最后，你将为随从创建一些变化，使它们更不可预测、更有趣。
- en: By the end of this chapter, you will have improved your understanding of managing
    AI Actors in a multiplayer game. Additionally, you will have a strong understanding
    of how to ensure effective communication within a networked environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将提高你在多人游戏中管理AI角色的理解。此外，你将深入了解如何在网络环境中确保有效的沟通。
- en: 'In this chapter, I will guide you through the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将引导你通过以下部分：
- en: Making AI opponents more challenging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使AI对手更具挑战性
- en: Implementing an alert system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现警报系统
- en: Adding health to the AI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为AI添加健康值
- en: Adding a weapon system to a character
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为角色添加武器系统
- en: Creating AI variations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建AI变化
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中介绍的主题，你应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided at this book’s
    companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载本书配套项目仓库提供的`.zip`项目文件：[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 08``End` link.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击`Unreal Shadows –` `Chapter 08``End`链接下载与上一章结尾相符的最新文件。
- en: Making AI opponents more challenging
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使AI对手更具挑战性
- en: So far, your undead lackey is equipped with a (more or less) keen sense of vision,
    allowing it to peer into the abyss of the dungeon, scouting for unsuspecting prey.
    However, even the sneakiest of thieves can unexpectedly bump into a hindrance
    while tip-toeing through the shadows. The cunning Lichlord knows this all too
    well and has bestowed upon his minions the added gift of acute hearing, so not
    even a pin drop goes unnoticed!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的不死随从已经装备了（或多或少）敏锐的视觉，使其能够窥视地牢的深渊，搜寻毫无戒备的猎物。然而，即使是最狡猾的小偷在悄无声息地穿过阴影时也可能意外地撞上障碍。狡猾的巫妖王对此了如指掌，并赐予了他的仆从敏锐的听觉，以至于连针掉落的声音都逃不过他们的耳朵！
- en: 'In this section, you will implement a noise system based on player character
    movement. The game logic you will be adding is based on the following requisites:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将基于玩家角色移动实现一个基于噪音的系统。你将添加的游戏逻辑基于以下要求：
- en: The thief character will make a noise when sprinting
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盗贼角色在冲刺时会发出噪音
- en: The noise level will be based on the character statistics
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪音水平将基于角色统计数据
- en: The AI minions will react when they hear a noise
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI随从在听到噪音时会做出反应
- en: So, open your IDE, as it’s time to add a new component feature to your hero!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开你的IDE，因为现在是时候给你的英雄添加一个新的组件功能了！
- en: Making some noise
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制造一些噪音
- en: In order to let your thief character make noise while it’s sprinting, you will
    add a new component – a **pawn noise emitter**. This component will not spawn
    an actual sound or noise, but it will emit a signal that can be intercepted by
    the pawn-sensing component you have attached to the minion character.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的盗贼角色在冲刺时发出噪音，您将添加一个新的组件——一个**pawn噪音发射器**。这个组件不会产生实际的声音或噪音，但它会发出一个信号，可以被您附加到小兵角色上的pawn感知组件截获。
- en: 'In order to declare this component, open the `US_Character.h` header file,
    and in the `private` section, add the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明这个组件，打开`US_Character.h`头文件，并在`private`部分添加以下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that the component has been declared, it’s time to initialize it. Open
    the `US_Character.cpp` file and add the necessary `include` declaration at the
    top of the file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经声明，是时候初始化它了。打开`US_Character.cpp`文件，并在文件顶部添加必要的`include`声明：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, find the constructor, and just after the `FollowCamera` initialization,
    add these two lines:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，找到构造函数，并在`FollowCamera`初始化之后，添加这两行代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the component creation, we just initialize its lifetime to a really low
    value (i.e., `0.01`) – this value indicates the time that should pass before the
    new noise emission overwrites the previous one. As we use the `Tick()` event to
    emit the noise, and this event is executed every frame, we don’t need a high value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件创建后，我们只需将其生命周期初始化为一个非常低的值（即`0.01`）——这个值表示在新噪音发射覆盖之前的应经过的时间。由于我们使用`Tick()`事件来发射噪音，而这个事件每帧都会执行，所以我们不需要一个高值。
- en: 'Now, look for the `Tick()` function, and just before its closing bracket, add
    the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查找`Tick()`函数，并在其括号关闭之前，添加以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code, we verify whether the character is sprinting and proceed
    further only if the result is affirmative. We then compute the noise, based on
    a unity value divided by the `StealthMultiplier` character. As you will remember
    from [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver the Network*, this value is declared inside the character statistics data
    table, and it grows as the character levels up. This means the higher the multiplier,
    the lower the noise made by the character. After the noise has been evaluated,
    it is emitted by the `NoiseEmitter` component by using the `MakeNoise()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们验证了角色是否在冲刺，并且只有当结果为肯定时才继续进行。然后，我们根据`StealthMultiplier`角色的统一值来计算噪音。如您在[*第6章*](B18203_06.xhtml#_idTextAnchor125)中记得的，*在网络中复制属性*，这个值是在角色统计数据表中声明的，并且随着角色的等级提升而增长。这意味着乘数越高，角色产生的噪音就越低。噪音评估后，通过`NoiseEmitter`组件使用`MakeNoise()`方法发射。
- en: Now that our character has picked up the skill of making noise while sprinting,
    it’s time we equip our undead minions with some sharp-eared talents and set them
    to action!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的人物已经学会了在冲刺时制造噪音的技能，是时候给我们的不死小兵装备一些敏锐的听力才能并将它们投入行动了！
- en: Enabling the hearing sense
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用听觉感知
- en: 'The minion character already has the ability to hear noise through the pawn-sensing
    component, but at the moment, this ability is not used. You’ll need to open the
    `US_Minion.h` header file and add the following declaration to the `protected`
    section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 小兵角色已经通过pawn感知组件具有了听到噪音的能力，但目前这个能力尚未使用。您需要打开`US_Minion.h`头文件，并在`protected`部分添加以下声明：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this is a simple callback declaration that will be used to handle
    the hearing of any noise.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的回调声明，它将被用来处理任何噪音的监听。
- en: 'Next, add the following method declaration to the `public` section:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`public`部分添加以下方法声明：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a simple utility function that we will use to send the minion to the
    origin of the noise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实用函数，我们将用它将小兵发送到噪音的源头。
- en: 'Now, open the `US_Minion.cpp` file and look for the `PostInitializeComponents()`
    implementation. Just before the closing bracket, add the delegate binding for
    the hearing event:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`US_Minion.cpp`文件，查找`PostInitializeComponents()`的实现。在括号关闭之前，添加听觉事件的委托绑定代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, implement the `OnHearNoise()` function by adding the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过添加以下代码来实现`OnHearNoise()`函数：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once a noise has been detected, we send the minion to the location where it
    was generated. As you can see, we don’t check whether the noise instigator is
    our thief character – the Lichlord has commanded his minions to meticulously investigate
    any and all audible disturbances, leaving no corner unexplored!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到噪音，我们就将矮人送到噪音产生的位置。正如你所见，我们没有检查噪音制造者是否是我们的盗贼角色 - Lichlord 命令他的矮人细致入微地调查任何和所有的可听到的干扰，不留任何角落未被探索！
- en: 'Finally, add the implementation for the `GoToLocation()` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `GoToLocation()` 函数的实现：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we just set `PatrolLocation` and send the minion there (it’s nothing fancy
    but extremely useful, as you will see later in the chapter).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是设置 `PatrolLocation` 并将矮人送到那里（这并不复杂，但非常实用，你将在本章后面的部分看到）。
- en: The minion is now ready, so compile your project and start some testing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在矮人已经准备好了，所以编译你的项目并开始测试。
- en: Testing the hearing sense
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试听觉感知
- en: To test the brand-new hearing sense feature, start a game session and walk around
    the minions, paying attention to not enter their sight cone of vision. The minions
    won’t notice the character unless it starts sprinting. At that moment, you should
    get a debug message, and the minion will start chasing the thief. *Figure 9**.1*
    shows a scenario where the character has carelessly run behind a couple of skeleton
    minions and has subsequently been detected by their hearing sense.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试全新的听觉感知功能，开始一个游戏会话，在矮人周围走动，注意不要进入他们的视野锥。除非角色开始冲刺，否则矮人不会注意到这个角色。在那个时刻，你应该会收到一个调试信息，矮人将开始追逐盗贼。*图9**.1*
    展示了一个场景，其中角色不小心跑到了一对骷髅矮人后面，随后被他们的听觉感知发现。
- en: '![Figure 9.1 – The character has been detected](img/Figure_09_01_B18203.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 角色已被发现](img/Figure_09_01_B18203.jpg)'
- en: Figure 9.1 – The character has been detected
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 角色已被发现
- en: In this section, you added a new sense to the minion characters; this will make
    the game more tactical for the players – running around the dungeon like there’s
    no tomorrow won’t be an optionable solution!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你为矮人角色添加了一个新的感官；这将使游戏对玩家更具战术性 - 像明天没有明天一样在地下城中四处奔跑将不再是可行的解决方案！
- en: In the upcoming section, you shall pave the way for a messaging system that
    enables even the humblest minion to unleash a call to arms upon discovering fresh
    prey. Oh, you thought heroism was all smooth sailing, did you? Ah, how fallible
    the human mind can be (smirks the Lichlord).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将为一个消息系统铺路，这个系统能够让最不起眼的矮人在发现新鲜猎物时发出动员令。哦，你以为英雄主义都是一帆风顺的吗？啊，人的思维是多么容易出错（Lichlord
    笑着说）。
- en: Implementing an alert system
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现警报系统
- en: In this section, you will work on a system that allows an AI character to alert
    its fellow minions once it detects a player character. At first glance, you might
    assume that the code logic to alert nearby AI opponents could be implemented directly
    inside the minion class – it’s just a matter of sending them a message, isn’t
    it? But there’s more to it than meets the eye, dear reader. It seems the Lichlord
    has bigger aspirations for communication than you had anticipated. Fear not, for
    he has dictated that you make use of a Gameplay Framework class that has lurked
    unnoticed in the shadows until this moment – the Game Mode.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将工作于一个系统，允许AI角色在检测到玩家角色时向其同伴矮人发出警报。乍一看，你可能认为警报附近AI对手的代码逻辑可以直接在矮人类中实现 -
    这只是发送消息的问题，对吧？但事情远不止如此，亲爱的读者。看起来Lichlord对通信的雄心比你预想的要大。别担心，他已经命令你使用一个直到此刻才被忽视的游戏框架类
    - 游戏模式。
- en: As you will remember from [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting
    Up Your First Multiplayer Environment*, a **Game Mode** is a class that manages
    a game’s rules and settings – this includes tasks such as communicating with AI
    Actors in the level. Alerting them of a new intruder in the dungeon is definitely
    a feature we want to have in this class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从 [*第4章*](B18203_04.xhtml#_idTextAnchor086) 中所记得的，*设置您的第一个多人游戏环境*，**游戏模式**是一个管理游戏规则和设置的类
    - 这包括与关卡中的AI演员通信的任务。在地下城警报新入侵者肯定是我们想在这个类中拥有的功能。
- en: Declaring the Game Mode functions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明游戏模式函数
- en: 'As usual, you will start by declaring the needed functions inside the class
    header – in this case, you will need just one, called `AlertMinions()`. Open the
    `US_GameMode.h` header file and declare it in the `public` section:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你需要在类头文件中声明所需的函数 - 在这种情况下，你需要一个名为 `AlertMinions()` 的函数。打开 `US_GameMode.h`
    头文件，并在 `public` 部分声明它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although this function may appear pretty simple, it will provide valuable information
    such as which minion has detected something, the position where to investigate,
    and the distance at which fellow minions should be alerted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数可能看起来很简单，但它将提供有价值的信息，例如哪个小兵检测到了某些东西，调查的位置，以及其他小兵应该被警报的距离。
- en: 'Now, open the `US_GameMode.cpp` file and add the following `include` declarations
    at the very top of the code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`US_GameMode.cpp`文件，并在代码的顶部添加以下`include`声明：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you already know, those declarations are needed to properly implement the
    code you will write in the class. Once you have added those lines, you can add
    the following method implementation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的那样，这些声明是正确实现你在类中编写的代码所必需的。一旦你添加了这些行，你就可以添加以下方法实现：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code looks for all the classes that extend `AUS_Minion` in the level through
    `GetActorsOfClass()` and stores them in an array. After that, it loops through
    this array, computing the distance between each minion and the alerting one. If
    the distance is within range (i.e., the `Radius` property), the AI will be commanded
    to go to that location and investigate through the `GoToLocation()` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过`GetActorsOfClass()`在关卡中查找所有扩展`AUS_Minion`的类，并将它们存储在数组中。之后，它遍历这个数组，计算每个小兵与警报小兵之间的距离。如果距离在范围内（即`Radius`属性），AI将被命令前往该位置并通过`GoToLocation()`函数进行调查。
- en: The alert behavior for the Game Mode has been implemented; this means it’s now
    possible for minions to call for assistance whenever they detect an intruder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式的警报行为已经实现；这意味着一旦侦测到入侵者，小兵就可以请求援助。
- en: Making the AI send alert messages
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让AI发送警报消息
- en: 'Sending messages from the AI character is a pretty straightforward task, as
    the Game Mode is reachable from any Actor in the game as long as it’s on the server
    – as you may already know, this is an awesome feature provided by the Unreal Engine
    Gameplay Framework. So, let’s open the `US_Minion.h` file and declare the alert
    radius for the soon-to-be-sent messages in the `private` section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从AI角色发送消息是一个相当直接的任务，因为只要它在服务器上，游戏模式就可以从游戏中的任何演员访问——正如你可能已经知道的，这是由虚幻引擎游戏框架提供的酷炫功能。所以，让我们打开`US_Minion.h`文件，并在`private`部分声明即将发送的消息的警报半径：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using a configurable radius range will come in handy to create different types
    of minions – do you want a super-alert, ear-piercing sentinel? Set it to a very
    high value! Or go for a slimy, self-serving AI that’s just in it for the Lichlord’s
    favors and undead promotions by setting it to zero – this way, none of the fellow
    minions will be alerted and the sentinel will (hopefully) be granted a pat on
    the head by its lord upon reaching the player character. The choice is yours!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可配置的半径范围将有助于创建不同类型的小兵——你想要一个超级警觉、刺耳的哨兵吗？将其设置为非常高的值！或者选择一个黏糊糊、自私的AI，只为Lichlord的恩惠和亡灵晋升而存在，将其设置为零——这样，其他小兵都不会被警报，哨兵（希望）在到达玩家角色时会被其主人抚摸一下头。选择权在你！
- en: 'To implement the function, open the `US_Minion.cpp` file and add the following
    `include` at the very beginning of the file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，打开`US_Minion.cpp`文件，并在文件的非常开头添加以下`include`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, locate the `Chase()` method. Before its closing bracket, add this code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定位到`Chase()`方法。在其闭合括号之前，添加以下代码：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, once the Game Mode has been retrieved, we just send the alert
    message with the opportune parameters. It’s now time to compile the project and
    do some testing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦检索到游戏模式，我们只需发送带有适当参数的警报消息。现在是时候编译项目并进行一些测试了。
- en: Testing the alert implementation
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试警报实现
- en: Start a new game session, and once the number of minions is good enough, let
    your character be detected by one of them. Once alerted, all nearby minions will
    begin investigating the area, posing a serious danger to the player as more and
    more AI characters spot them, leading to a potentially dangerous chain reaction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的游戏会话，一旦小兵的数量足够多，让你的角色被其中之一侦测到。一旦警报，所有附近的小兵将开始调查该区域，对玩家构成严重威胁，因为越来越多的AI角色发现了他们，可能导致潜在的连锁反应。
- en: '*Figure 9**.2* shows one such situation – the player has not been stealthy
    enough, and AI opponents have started detecting the character while alerting each
    other.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.2*显示了这种情况之一——玩家不够隐秘，AI对手已经开始检测角色并相互警报。'
- en: '![Figure 9.2 – The alert system in action](img/Figure_09_02_B18203.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 警报系统正在运行](img/Figure_09_02_B18203.jpg)'
- en: Figure 9.2 – The alert system in action
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 警报系统正在运行
- en: In this section, you implemented a messaging system for your AI opponents and
    learned the power of having a centralized place to manage your gameplay logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你为你的AI对手实现了一个消息系统，并学习了拥有集中管理游戏逻辑的力量的重要性。
- en: In the next section, you will use the Gameplay Framework damage system to let
    players defeat enemies. Did you really believe I’d allow the poor thief hero to
    rot in the Lichlord’s grasp without any aid? Well, think again, my dear reader!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用游戏框架伤害系统让玩家击败敌人。你真的相信我会让可怜的盗贼英雄在没有帮助的情况下在巫妖领主的手中腐烂吗？好吧，再想想，亲爱的读者！
- en: Adding health to the AI
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为AI添加健康值
- en: In this part of the project, you will add a health system to the minion AI to
    make it possible to defeat it during gameplay. You will also add a spawn system
    so that when the opponent is defeated, the player will be rewarded with a well-deserved
    prize.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目部分，你将为小兵AI添加一个健康系统，使其在游戏过程中可以被击败。你还将添加一个生成系统，以便当对手被击败时，玩家将获得应得的奖励。
- en: 'To implement such features, we need to open the minion class and start doing
    some coding – open the `US_Minion.h` header, and in the `private` section, add
    these two declarations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些功能，我们需要打开迷你兵类并开始编写代码——打开`US_Minion.h`头文件，并在`private`部分添加以下两个声明：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first one is used to keep track of the enemy health, while the second one
    will contain the class of the item pickup that will be spawned once the minion
    is defeated. Both of them can be modified in a child Blueprint Class (thanks to
    the `EditDefaultsOnly` property specifier), so you can build your own variations
    of the minion.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于跟踪敌人的健康值，而第二个将包含在击败小兵后将生成的物品拾取物的类。两者都可以在子蓝图类（多亏了`EditDefaultsOnly`属性指定符）中进行修改，因此你可以构建自己版本的迷你兵。
- en: 'Now, locate the `protected` section and add the damage handler declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位到`protected`部分，并添加伤害处理声明：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The header is now complete, so it’s time to open the `US_Minion.cpp` file and
    implement the health system. As usual, start by adding the needed `include` declarations
    at the top of the file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标题已经完成，是时候打开`US_Minion.cpp`文件并实现健康系统了。像往常一样，首先在文件顶部添加所需的`include`声明：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, declare the base pickup that will be spawned when the character is defeated;
    you’ll use the pickup coin you created in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver the Network*. Locate the constructor, and just
    before the closing bracket, add this code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明当角色被击败时将生成的基类拾取物；你将使用在[*第6章*](B18203_06.xhtml#_idTextAnchor125)中创建的拾取物硬币，*在网络中复制属性*
    *O**ver the Network*。定位到构造函数，并在闭合括号之前添加以下代码：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code logic should be familiar, as we get a Blueprint asset from the project
    library and assign it the `SpawnedPickup` reference.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码逻辑应该很熟悉，因为我们从项目库中获取一个蓝图资产并将其分配给`SpawnedPickup`引用。
- en: 'Then, we need to implement the damage handler logic. Locate the `PostInitializeComponents()`
    method and add this line of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现伤害处理逻辑。定位到`PostInitializeComponents()`方法，并添加以下代码行：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we just bind the `OnDamage` handler to the `OnTakeAnyDamage` delegate.
    As a last step, we need to implement the `OnDamage()` method, so add this code
    to your class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将`OnDamage`处理程序绑定到`OnTakeAnyDamage`委托。作为最后一步，我们需要实现`OnDamage()`方法，因此将以下代码添加到你的类中：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What this function does is to subtract the `Damage` value from the `Health`
    property; if the minion reaches zero health, it will immediately spawn the prize
    (i.e., the pickup) and then it will destroy itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用是从`Health`属性中减去`Damage`值；如果小兵的生命值达到零，它将立即生成奖励（即拾取物），然后它会自我销毁。
- en: In this section, you created a simple health system for the AI opponent, by
    adding the `Health` property and keeping track of its value as damage is taken
    – whenever the minion has been defeated, it will spawn a coin or a similar prize,
    ready to be picked up by the nearest (or swiftest) character!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你通过添加`Health`属性并跟踪其值（在受到伤害时）为AI对手创建了一个简单的健康系统，当小兵被击败时，它会生成一枚硬币或类似的奖励，供最近的（或最快的）角色拾取！
- en: Unfortunately for your players, the hapless band of thieving heroes is, at the
    moment, ill equipped to dispatch the Lichlord’s minions in the treacherous underground
    realm! Fear not, for we shall come to their aid by adding a splendid weapon inventory
    to their arsenal in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于你的玩家来说，这个不幸的盗贼英雄团伙目前装备不足，无法在险恶的地下领域中派遣巫妖领主的仆从！别担心，我们将在下一节中通过为他们增添丰富的武器库来帮助他们。
- en: Adding a weapon system to the character
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your beloved character has been longing for a weapon system ever since you started
    implementing it. In this section, we shall finally grant its wishes and provide
    it the ability to wield (not-so) powerful tools of destruction. Let’s make our
    character stronger and more formidable by arming it with an amazing weapon!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Since our character hero is a sneaky thief who prefers to avoid direct combat
    with stronger and more heavily armored opponents, we will focus on a throwing
    dagger system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid adding cluttered code in the `US_Character` class, you’ll
    implement a brand-new component that will handle the weapon logic – this means
    that you’ll work on the following features:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: A component that will be added to the character and handle the player input
    and dagger spawn logic
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dagger weapon that will be thrown at runtime and cause damage to the enemy
    opponents
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first step, we will create the weapon projectile that will be spawned by
    the character when attacking during gameplay.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dagger projectile
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is create a projectile class that will serve as a throwable
    dagger. To do so, in the Unreal Editor, create a new C++ class that will extend
    `Actor`, and call it `US_BaseWeaponProjectile`. Once it has been created, open
    the `US_BaseWeaponProjectile.h` file, and in the `private` section, add the following
    component declarations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we will add a collision area to check hits during gameplay,
    a static mesh for the dagger model, and projectile logic to make the dagger move
    once it has been thrown.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Remaining in the `private` section, add the `Damage` property with a base value
    of `1`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in the `public` section, add the usual getter methods for the components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we need to add a handler for when the weapon makes contact with its
    target. Add the following code to the `protected` section:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The header is ready, so we need to implement the logic – open the `US_BaseWeaponProjectile.cpp`
    file and add the necessary `include` declarations at its top:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, locate the constructor and add the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code logic is lengthy but straightforward to comprehend – we just create
    and initialize the necessary components:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`SphereCollision` has some basic values you should be familiar with:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`Mesh` is set to a dagger model and rotated and positioned in order to align
    with the overall Actor'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProjectileMovement` has gravity disabled and a speed that will move the Actor
    fast and simulate a real dagger'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to mention is that we bind the `OnHit()` method to the `OnComponentHit`
    delegate through the `AddDynamic` helper macro. Also, note the final line of code
    that activates replication for the weapon – always keep in mind that Actors are
    not replicated by default!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `OnHit()` implementation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code can be divided into three main parts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we compute the damage, starting from the `Damage` base value.
    If the instigator (i.e., the character that spawned the projectile) is `US_Character`,
    we get its damage multiplier from the statistics and update the provoked damage.
    This means the higher the level of the character, the higher the damage.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分，我们从`Damage`基本值开始计算伤害。如果肇事者（即生成投射物的角色）是`US_Character`，我们将从统计数据中获取其伤害乘数并更新引起的伤害。这意味着角色的等级越高，伤害就越高。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a refresher on how character statistics are managed, please take a look
    back at [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver* *the Network*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想要回顾一下如何管理角色统计数据，请回顾[*第6章*](B18203_06.xhtml#_idTextAnchor125)，*在网络中复制属性* *O**ver*
    *the Network*。
- en: The second part of the code verifies whether the launched projectile has hit
    an Actor. If it has, it will then inflict the corresponding amount of damage.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的第二部分验证发射的投射物是否击中了演员。如果是，它将造成相应的伤害量。
- en: The last and final part simply destroys the projectile – its mission is finished,
    and this means it should be removed from the game.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的部分只是销毁投射物 – 它的任务已经完成，这意味着它应该从游戏中移除。
- en: With the projectile all set up and ready to go, it’s time to implement some
    spawn logic so that your thief hero can unleash the full power of this shiny new
    weapon.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当投射物已经设置好并准备就绪时，是时候实现一些生成逻辑，以便你的盗贼英雄能够释放这把闪亮新武器的全部力量。
- en: Implementing the weapon component
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现武器组件
- en: Let’s start by creating a class that will add new features to the character.
    As you may remember from [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting
    Up Your First Multiplayer Environment*, a component will let you implement reusable
    functionality and can be attached to any Actor or another component. In this case,
    we will implement a weapon system, with a `Transform` property) – this will allow
    you to position the component somewhere inside the character and act as a spawn
    point for the thrown projectiles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个将添加新功能的类。如您从[*第4章*](B18203_04.xhtml#_idTextAnchor086)，*设置您的第一个多人环境*中可能记得，一个组件将允许你实现可重用的功能，并可以附加到任何演员或另一个组件。在这种情况下，我们将实现一个武器系统，具有`Transform`属性）
    – 这将允许你将组件放置在角色内部某个位置，并作为投掷投射物的生成点。
- en: 'Let’s start by creating the class. To do so, create a new class that extends
    from a Scene component and call it `US_WeaponProjectileComponent`. Once the creation
    process has finished, open `US_WeaponProjectileComponent.h`, and in the `private`
    section, add the following declarations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建这个类。为此，创建一个新的类，从场景组件扩展而来，并将其命名为`US_WeaponProjectileComponent`。一旦创建过程完成，打开`US_WeaponProjectileComponent.h`，在`private`部分，添加以下声明：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we declare the projectile class (i.e., the projectile we previously
    created, or a subclass of it). Then, we declare the necessary elements that will
    let us take advantage of the enhanced input system. As we don’t want to add dependencies
    to the main character, we will use a different mapping context from the one used
    in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a Multiplayer
    Environment* – this will let us implement a flexible combat system and add as
    many features as we want, without adding clutter to the main character class.
    Imagine the thrill of watching your sneaky thief hero slipping through the shadows,
    quietly backstabbing the most despised minions of the dreaded Lichlord! The possibilities
    for mayhem and mischief will be endless!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们声明了投射物类（即我们之前创建的投射物，或其子类）。然后，我们声明了必要的元素，这将使我们能够利用增强的输入系统。由于我们不希望向主要角色添加依赖项，我们将使用与[*第5章*](B18203_05.xhtml#_idTextAnchor107)，*在多人环境中管理演员*中使用的不同映射上下文
    – 这将使我们能够实现灵活的战斗系统，并添加我们想要的任何功能，而不会给主要角色类添加杂乱。想象一下，看着你的狡猾盗贼英雄悄悄穿过阴影，静静地从背后刺杀那个令人恐惧的巫妖领主最令人憎恨的走狗！混乱和恶作剧的可能性将是无穷无尽的！
- en: 'Okay, let’s stop dreaming and get back to coding. In the `public` section,
    add a setter for the projectile class that will allow you to change the spawned
    dagger projectile:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们停止做梦，回到编码上来。在`public`部分，添加一个用于投射物类的setter，这将允许你更改生成的匕首投射物：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function has nothing to do with throwing things around, but it will be
    most useful if you plan to add a weapon pickup to your game, in order to improve
    your character’s fighting skills.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与扔东西无关，但如果你想在你的游戏中添加武器拾取功能，以提高角色的战斗技能，它将非常有用。
- en: 'Lastly, in the `protected` section, declare the `Throw()` action and its corresponding
    server call:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`protected`部分，声明`Throw()`动作及其对应的服务器调用：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code will let us spawn the thrown daggers during gameplay from the server
    – always remember that the server should be in command when generating replicated
    Actors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将使我们能够在游戏过程中从服务器生成投掷匕首 – 总是记住，在生成复制的Actor时，服务器应该处于指挥地位。
- en: 'Now that the header file is finished, open the `US_WeaponProjectileComponent.cpp`
    file to start implementing its features. As usual, locate the top of the file,
    and add the `include` declarations for the classes we will use:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头文件已经完成，打开`US_WeaponProjectileComponent.cpp`文件以开始实现其功能。像往常一样，找到文件顶部，并添加我们将使用的类的`include`声明：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in the constructor, add this single line of code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中，添加以下单行代码：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we just declare the base projectile that will be spawned when the throw
    action is triggered; you will obviously be able to change it in the derived Blueprint
    Classes if you need a different weapon.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需声明当抛掷动作被触发时将生成的基礎投射物；显然，如果你需要不同的武器，你可以在派生蓝图类中更改它。
- en: 'Now, locate the `BeginPlay()` method, and just after the `Super::BeginPlay()`
    declaration, add this code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位`BeginPlay()`方法，并在`Super::BeginPlay()`声明之后添加以下代码：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, we check that the component owner is our `US_Character`
    class, in order to get its controller and initialize the mapping context and its
    actions. Note that this initialization is done inside the `BeginPlay()` function,
    which means that these steps will be done just once – that is, when the game is
    started – to be sure that there is an Actor owner and a corresponding controller.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们检查组件所有者是我们的`US_Character`类，以便获取其控制器并初始化映射上下文及其动作。请注意，这个初始化是在`BeginPlay()`函数内完成的，这意味着这些步骤只会执行一次
    – 也就是说，当游戏开始时 – 以确保存在一个Actor所有者和相应的控制器。
- en: 'Now, implement the throw logic by adding the following method implementations:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过添加以下方法实现来实施投掷逻辑：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the `Throw()` method simply calls the server-side implementation
    that will spawn the projectile from the component location. You are already familiar
    with the spawn action (do you remember the minion spawner?), but there is an important
    thing to notice this time – we use the `FActorSpawnParameters` structure to set
    the owner of the projectile and, most importantly, the instigator (i.e., the Actor
    that spawned the object). This property is used by the projectile to retrieve
    the character statistics and handle the damage multiplier, code logic we implemented
    in the previous section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Throw()`方法只是调用服务器端实现，从组件位置生成投射物。你已经熟悉了生成动作（你还记得小兵生成器吗？），但这次有一个重要的事情要注意
    – 我们使用`FActorSpawnParameters`结构来设置投射物的所有者和，最重要的是，发起者（即生成对象的Actor）。这个属性被投射物用来检索角色统计数据和处理伤害乘数，这是我们之前章节中实现的代码逻辑。
- en: 'Lastly, add the setter method that will let you change the weapon spawned by
    the character:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个设置器方法，让你可以更改角色生成的武器：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The component has now been properly set – you just need to attach an instance
    of it to the thief character to make it fully operational.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 组件现在已经被正确设置 – 你只需将其实例附加到盗贼角色上，使其完全可用。
- en: Attaching the WeaponProjectile component to the character
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将武器投射物组件附加到角色上
- en: 'Now that you have created a weapon component, it’s time to add it to the character.
    Open the `US_Character.h` header file, and in the `private` section, add the component
    declaration:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个武器组件，是时候将其添加到角色上了。打开`US_Character.h`头文件，并在`private`部分添加组件声明：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And, as usual, add the corresponding getter utility method to the `public`
    section:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像往常一样，在`public`部分添加相应的获取器实用方法：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, open the `US_Character.cpp` source file and include the component class
    declaration at the top of the file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`US_Character.cpp`源文件，并在文件顶部包含组件类声明：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, locate the constructor, and just after the noise emitter creation and
    initialization, add the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位构造函数，并在噪声发射器创建和初始化之后添加以下代码：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, after we create the component, we attach it to the root component
    of the character and position it at a relative location, set to `(120, 70, 0)`.
    If you want your character to be left-handed, you can just use a negative value
    for the `X` coordinate (i.e., `-120.f`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As hard as it may be to believe, the code to attach the weapon component to
    the character is complete; the code logic is already handled in the component
    itself, so you can sit back, relax, and let everything fall into place like a
    well-oiled machine!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now switch back to the Unreal Editor and compile your project – once
    finished, you can open the `WeaponProjectile` component, with **Projectile Class**
    set to a default value, as depicted in *Figure 9**.3*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The WeaponProjectile component attached to the character Actor](img/Figure_09_03_B18203.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The WeaponProjectile component attached to the character Actor
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: With the `WeaponProjectile` component attached to the character, the last thing
    to do is to create a mapping context for the player input and an input action
    for the throw logic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Adding an input system for the weapon
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the final part of this section, you will define the mapping context and the
    input action for the throw interaction. This is something you are already familiar
    with, as you previously created similar assets in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a* *Multiplayer Environment*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let’s open the Content Browser and navigate to the
    **Content** | **Input** folder. We will create the throw action asset in the following
    steps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the input mapping context for the throw interaction
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the action asset for the throw interaction, follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select `IA_Throw`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the asset to open it, and from the **Value Type** dropdown,
    select **Digital (bool)**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-check that the **Consume Input** checkbox is ticked.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result for the throw action asset is shown in *Figure 9**.4*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The throw action settings](img/Figure_09_04_B18203.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The throw action settings
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now that the action has been set, let’s create a mapping context for the weapon
    interactions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the input mapping context for the weapon interactions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the weapon context mapping, follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select `IMC_Weapons`. Double-click on
    the asset to open it.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new mapping context by clicking on the **+** icon next to the **Mappings**
    field.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down menu that will be added, select **IA_Throw** to add this
    action to the mapping context.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click twice on the **+** icon next to the drop-down menu to add two other control
    bindings for this action (one is set by default). In the drop-down menu next to
    each new field, use the following properties:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first binding should be set to **Left Ctrl** from the **Keyboard** category
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second binding should be set to **Gamepad Face Button Right** from the **Gamepad**
    category
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third binding should be set to **Left Mouse Button** from the **Mouse**
    category
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final result for the weapon mapping context should be like the one depicted
    in *Figure 9**.5*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The weapon mapping context settings](img/Figure_09_05_B18203.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The weapon mapping context settings
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the assets are ready, it’s time to add them to the character:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Open the **BP_Character** Blueprint, select the **Weapon** component, and in
    the **Details** panel, locate the **Input** category.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Weapon Mapping Context** field, assign the **IMC_Weapons** asset.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Throw Action** field, assign the **IA_Throw** asset.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have set these properties, your **Input** category should look like
    the one depicted in *Figure 9**.6*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The updated Input category](img/Figure_09_06_B18203.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The updated Input category
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Now that the input settings have been properly updated, it’s time to do some
    testing to check that everything works properly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Testing the weapon system
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to show the Lichlord’s minions who the boss is and wreak some havoc
    in their underground lairs! Let’s give them a taste of our hero’s targeting skills
    by starting a game session.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: During gameplay, your character should be able to spawn a dagger whenever using
    the throw action – for example, by clicking the left mouse button. The dagger
    should destroy itself whenever it hits something and provoke damage to the AI
    minions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a minion reaches zero health, it should be removed from the game, and
    a coin should spawn in the level. Collecting enough coins will make your character
    level up, and consequently, the character itself will provoke additional damage
    when hitting any enemy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.7* shows the character throwing some daggers during gameplay:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The dagger attack in action](img/Figure_09_07_B18203.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The dagger attack in action
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you implemented a weapon system through a new component that
    is attached to your character and a projectile Actor that can be spawned in the
    game and properly replicated through the network.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, you will introduce some diverse variations of the AI
    opponents, with the aim of enhancing the game’s variety and overall enjoyability.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Creating AI variations
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve got the AI opponents all set up and ready to go for some epic
    battles, let’s add some more variations to AI minions and make things more interesting
    and engaging. If a project has been well planned, changing the behavior of an
    AI – even a basic one such as the one we created in this chapter – is usually
    just a matter of adjusting some settings!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create a new AI opponent, starting from the basic `US_Minion`
    class, and you will tweak its property in order to give it different behavior.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI sentinel
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While watching mindless minions wander around a dungeon cluelessly may cause
    a chuckle or two, it is certainly not enough for the Lichlord’s devious plans.
    He wants to be sure that each and every corner of his realm is safe and well guarded.
    This means you will craft some undead sentinels that will have keen senses and
    be more territorial.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Blueprint Class, inheriting from the basic minion.
    Open the Content Browser and complete the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the `Blueprints` folder, right-click and select **Blueprint Class**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the window that pops up, select **US_Minion** from the **All** **Classes**
    section.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created Blueprint `BP_MinionSentinel`, and then double-click
    on it to open it.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `6000,0`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `60,0`
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `20,0`
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `1000,0`
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9.8*:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The sentinel Minion AI settings](img/Figure_09_08_B18203.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The sentinel Minion AI settings
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `600,0`
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `1000,0`
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `2500,0`
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `60,0`
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9**.9*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The sentinel AI settings](img/Figure_09_09_B18203.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The sentinel AI settings
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: With these settings, you will create a minion that will patrol an approximately
    small area, changing direction frequently and moving very slowly. Its senses will
    be keen, and its alert radius will be larger than a regular minion. When an intruder
    has been spotted, the sentinel will slow down, calling for help, letting its more
    aggressive counterparts handle the chase. It’s not one for combat, but it’s still
    on the lookout for any suspicious activity!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, you can add a couple of glowing eyes for this darkness-gazing
    undead character by changing **Element 5** in the mesh **Materials** list to the
    **M_Base_Emissive** material asset, as shown in *Figure 9**.10*:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Materials settings](img/Figure_09_10_B18203.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The Materials settings
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of the sentinel (with some dramatic lightning add-ons) can
    be seen in *Figure 9**.11*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The sentinel added to the scene](img/Figure_09_11_B18203.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The sentinel added to the scene
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you have created a new AI with just a couple of tweaks to the
    **Details** panel. Let’s create another one, a more aggressive undead minion.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI miniboss
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can actually use the same process that worked in the previous subsection
    to create a new AI that will deal with hero intruders in a totally different way.
    It’s like getting creative with a recipe and making something new and unexpected
    but still (dangerously) delicious!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Content Browser and complete the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In the `Blueprints` folder, right-click and select **Blueprint Class**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the window that pops up, select **US_Minion** from the **All** **Classes**
    section.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created Blueprint `BP_MinionMiniboss`, and then double-click
    on it to open it.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `100,0`
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `100,0`
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `400,0`
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `50000,0`
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9.12*:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The miniboss Minion AI settings](img/Figure_09_12_B18203.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The miniboss Minion AI settings
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `200,0`
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `400,0`
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `200,0`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `20,0`
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9**.13*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The miniboss AI settings](img/Figure_09_13_B18203.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The miniboss AI settings
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: This AI opponent has been set to a really dull behavior while patrolling (low
    perception, slower movement, etc.), but it will become dangerously fast once alerted.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the miniboss started to look a bit dull, so the Lichlord has decided
    to give it a literal armor makeover. To do this, follow these steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Mesh** component and change the **Skeletal Mesh Asset** property
    to the **skeleton_warrior** asset.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Mesh** scale to a value of **1.2** to make it bigger.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Health** property to a value of **20** to make it more damage-resistant.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This foe is about to go from “meh” to menacing, and hero intruders better watch
    out! The final result of the miniboss, compared with a base minion, is shown in
    *Figure 9**.14*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The miniboss minion](img/Figure_09_14_B18203.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The miniboss minion
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of it all is that you can get really creative with your enemy opponents
    and test out all sorts of different behaviors and tactics. And if something just
    isn’t working for you, no worries! Just delete it and start afresh with something
    new in just a few short minutes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: As an additional nice touch to the AI, why not use the pickup spawn system we
    added earlier in this chapter to spice up the game? Depending on how rare or dangerous
    the defeated minion is, you could have it spawn different types of coins!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your undead army ready to go, you can get back to your enemy spawner
    and add the Blueprints to the system – something we will do in the next subsection.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Updating the minion spawner
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have guessed, adding your brand-new minion varieties is just a matter
    of putting their Blueprints inside a spawner. To do so, select the spawner you
    previously added to the level, and in the **Details** panel, locate the **Spawnable
    Minions** array property in the **Spawn System** category – there should already
    be one item in the list, **US_Minion**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Add as many items as you wish, selecting the spawnable minions you need for
    that particular spawn area. *Figure 9**.15* shows my setup for the main spawner
    area in the level:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The spawn area setup](img/Figure_09_15_B18203.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The spawn area setup
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I chose to work with five elements, allocating a 20% chance
    for each to be added to the level every time the `Spawn()` method is called. Since
    the basic minion utilizes three of these elements, there is a 60% chance that
    it will appear as an opponent, compared to the sentinel and miniboss, which only
    have a 20% probability of spawning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我选择了五个元素，每次调用`Spawn()`方法时，每个元素有20%的机会被添加到关卡中。由于基本小兵利用了这三个元素，因此它以60%的概率出现为对手，而哨兵和迷你Boss只有20%的概率生成。
- en: 'Once you are happy with your setup, you can test the game. *Figure 9**.16*
    shows my spawner in action at the start of the game:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对设置满意，您就可以测试游戏。*图9.16*显示了游戏开始时我的生成器正在运行：
- en: '![Figure 9.16 – The spawner at the start of the game](img/Figure_09_16_B18203.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 游戏开始时的生成器](img/Figure_09_16_B18203.jpg)'
- en: Figure 9.16 – The spawner at the start of the game
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 游戏开始时的生成器
- en: In this final section, you created some variations for the base minions; by
    changing some of their base properties, you changed the way they behave during
    gameplay, making your level more engaging and diverse.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，您为基本小兵创建了一些变体；通过改变它们的一些基本属性，您改变了它们在游戏中的行为方式，使您的关卡更具吸引力和多样性。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you actively worked to improve the behavior of your enemy AIs
    within the level. The focus was on developing new features that make the gaming
    experience even more engaging and challenging for players. You actually improved
    the Lichlord’s minions’ sense of hearing to make them even more alert and perceptive
    when it comes to spotting those poor thieving heroes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您积极努力改善关卡内敌人AI的行为。重点是开发新的功能，使游戏体验对玩家来说更具吸引力和挑战性。您实际上改善了Lichlord小兵的听觉，使它们在发现那些可怜的盗贼英雄时更加警觉和敏锐。
- en: On the flip side, you also implemented a health system for the minions and added
    some pretty sharp (literally!) tools to the player’s arsenal that they can use
    to take down those nasty foes! Finally, you created some enemy variations to make
    the dungeon less boring and more engaging for the player.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，您还为小兵实现了健康系统，并为玩家的装备库添加了一些相当锋利（字面意思！）的工具，他们可以使用这些工具击败那些讨厌的敌人！最后，您还创建了一些敌人变体，使地牢对玩家来说不再无聊，更具吸引力。
- en: As you can see from what you have built here, if you plan ahead, improving gameplay
    can be a walk in the park! By taking the time to carefully map out your strategies
    and implement the right features, you can make gameplay engaging and immersive
    for players while also achieving your desired results.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所构建的所示，如果您提前规划，提高游戏玩法可以变得轻而易举！通过花时间仔细制定策略并实施正确的功能，您可以使游戏玩法对玩家更具吸引力和沉浸感，同时也能实现您期望的结果。
- en: In the next chapter, we will improve the overall look and feel of the game by
    adding animations and prisoners to rescue. Additionally, I will provide you with
    some tips on how to take your game to the next level, but let’s be clear – I’m
    not going to code it all for you! I believe in your ability to create something
    amazing, and I can’t wait to see what you come up with!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加动画和需要解救的囚犯来改善游戏的整体外观和感觉。此外，我将为您提供一些如何将您的游戏提升到下一个层次的技巧，但让我们明确一点——我不会为您编写所有代码！我相信您有能力创造出一些惊人的东西，我迫不及待地想看看您能想出什么！
