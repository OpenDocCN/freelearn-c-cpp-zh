- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending AI Behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing an enemy character’s behavior in a multiplayer game is a great way
    of making it more challenging and exciting for players. It can also help create
    a more immersive experience, as enemies become smarter, faster, and stronger.
    By introducing new abilities or changing existing ones, you can make your game
    stand out from other similar titles on the market.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to add improvements to your minion’s AI
    behavior – this will involve creating some sort of communication between your
    hero character’s stealth abilities and the undead minion sensing system. Additionally,
    you will learn how to make your opponents communicate and cooperate with each
    other, in order to give your thief a hard time.
  prefs: []
  type: TYPE_NORMAL
- en: You will also implement a health system for the AI opponents, make your character
    attack, and impart some damage on them. Finally, you will create some variations
    for the minions in order to make them less predictable and more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have improved your understanding of managing
    AI Actors in a multiplayer game. Additionally, you will have a strong understanding
    of how to ensure effective communication within a networked environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will guide you through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Making AI opponents more challenging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an alert system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding health to the AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a weapon system to a character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating AI variations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided at this book’s
    companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 08``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Making AI opponents more challenging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, your undead lackey is equipped with a (more or less) keen sense of vision,
    allowing it to peer into the abyss of the dungeon, scouting for unsuspecting prey.
    However, even the sneakiest of thieves can unexpectedly bump into a hindrance
    while tip-toeing through the shadows. The cunning Lichlord knows this all too
    well and has bestowed upon his minions the added gift of acute hearing, so not
    even a pin drop goes unnoticed!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will implement a noise system based on player character
    movement. The game logic you will be adding is based on the following requisites:'
  prefs: []
  type: TYPE_NORMAL
- en: The thief character will make a noise when sprinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The noise level will be based on the character statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AI minions will react when they hear a noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, open your IDE, as it’s time to add a new component feature to your hero!
  prefs: []
  type: TYPE_NORMAL
- en: Making some noise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to let your thief character make noise while it’s sprinting, you will
    add a new component – a **pawn noise emitter**. This component will not spawn
    an actual sound or noise, but it will emit a signal that can be intercepted by
    the pawn-sensing component you have attached to the minion character.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to declare this component, open the `US_Character.h` header file,
    and in the `private` section, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the component has been declared, it’s time to initialize it. Open
    the `US_Character.cpp` file and add the necessary `include` declaration at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, find the constructor, and just after the `FollowCamera` initialization,
    add these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the component creation, we just initialize its lifetime to a really low
    value (i.e., `0.01`) – this value indicates the time that should pass before the
    new noise emission overwrites the previous one. As we use the `Tick()` event to
    emit the noise, and this event is executed every frame, we don’t need a high value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look for the `Tick()` function, and just before its closing bracket, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we verify whether the character is sprinting and proceed
    further only if the result is affirmative. We then compute the noise, based on
    a unity value divided by the `StealthMultiplier` character. As you will remember
    from [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver the Network*, this value is declared inside the character statistics data
    table, and it grows as the character levels up. This means the higher the multiplier,
    the lower the noise made by the character. After the noise has been evaluated,
    it is emitted by the `NoiseEmitter` component by using the `MakeNoise()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our character has picked up the skill of making noise while sprinting,
    it’s time we equip our undead minions with some sharp-eared talents and set them
    to action!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the hearing sense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The minion character already has the ability to hear noise through the pawn-sensing
    component, but at the moment, this ability is not used. You’ll need to open the
    `US_Minion.h` header file and add the following declaration to the `protected`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a simple callback declaration that will be used to handle
    the hearing of any noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following method declaration to the `public` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple utility function that we will use to send the minion to the
    origin of the noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `US_Minion.cpp` file and look for the `PostInitializeComponents()`
    implementation. Just before the closing bracket, add the delegate binding for
    the hearing event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the `OnHearNoise()` function by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once a noise has been detected, we send the minion to the location where it
    was generated. As you can see, we don’t check whether the noise instigator is
    our thief character – the Lichlord has commanded his minions to meticulously investigate
    any and all audible disturbances, leaving no corner unexplored!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the implementation for the `GoToLocation()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just set `PatrolLocation` and send the minion there (it’s nothing fancy
    but extremely useful, as you will see later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The minion is now ready, so compile your project and start some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the hearing sense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the brand-new hearing sense feature, start a game session and walk around
    the minions, paying attention to not enter their sight cone of vision. The minions
    won’t notice the character unless it starts sprinting. At that moment, you should
    get a debug message, and the minion will start chasing the thief. *Figure 9**.1*
    shows a scenario where the character has carelessly run behind a couple of skeleton
    minions and has subsequently been detected by their hearing sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The character has been detected](img/Figure_09_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The character has been detected
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you added a new sense to the minion characters; this will make
    the game more tactical for the players – running around the dungeon like there’s
    no tomorrow won’t be an optionable solution!
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, you shall pave the way for a messaging system that
    enables even the humblest minion to unleash a call to arms upon discovering fresh
    prey. Oh, you thought heroism was all smooth sailing, did you? Ah, how fallible
    the human mind can be (smirks the Lichlord).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an alert system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will work on a system that allows an AI character to alert
    its fellow minions once it detects a player character. At first glance, you might
    assume that the code logic to alert nearby AI opponents could be implemented directly
    inside the minion class – it’s just a matter of sending them a message, isn’t
    it? But there’s more to it than meets the eye, dear reader. It seems the Lichlord
    has bigger aspirations for communication than you had anticipated. Fear not, for
    he has dictated that you make use of a Gameplay Framework class that has lurked
    unnoticed in the shadows until this moment – the Game Mode.
  prefs: []
  type: TYPE_NORMAL
- en: As you will remember from [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting
    Up Your First Multiplayer Environment*, a **Game Mode** is a class that manages
    a game’s rules and settings – this includes tasks such as communicating with AI
    Actors in the level. Alerting them of a new intruder in the dungeon is definitely
    a feature we want to have in this class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Game Mode functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, you will start by declaring the needed functions inside the class
    header – in this case, you will need just one, called `AlertMinions()`. Open the
    `US_GameMode.h` header file and declare it in the `public` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although this function may appear pretty simple, it will provide valuable information
    such as which minion has detected something, the position where to investigate,
    and the distance at which fellow minions should be alerted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `US_GameMode.cpp` file and add the following `include` declarations
    at the very top of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, those declarations are needed to properly implement the
    code you will write in the class. Once you have added those lines, you can add
    the following method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code looks for all the classes that extend `AUS_Minion` in the level through
    `GetActorsOfClass()` and stores them in an array. After that, it loops through
    this array, computing the distance between each minion and the alerting one. If
    the distance is within range (i.e., the `Radius` property), the AI will be commanded
    to go to that location and investigate through the `GoToLocation()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The alert behavior for the Game Mode has been implemented; this means it’s now
    possible for minions to call for assistance whenever they detect an intruder.
  prefs: []
  type: TYPE_NORMAL
- en: Making the AI send alert messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sending messages from the AI character is a pretty straightforward task, as
    the Game Mode is reachable from any Actor in the game as long as it’s on the server
    – as you may already know, this is an awesome feature provided by the Unreal Engine
    Gameplay Framework. So, let’s open the `US_Minion.h` file and declare the alert
    radius for the soon-to-be-sent messages in the `private` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using a configurable radius range will come in handy to create different types
    of minions – do you want a super-alert, ear-piercing sentinel? Set it to a very
    high value! Or go for a slimy, self-serving AI that’s just in it for the Lichlord’s
    favors and undead promotions by setting it to zero – this way, none of the fellow
    minions will be alerted and the sentinel will (hopefully) be granted a pat on
    the head by its lord upon reaching the player character. The choice is yours!
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the function, open the `US_Minion.cpp` file and add the following
    `include` at the very beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, locate the `Chase()` method. Before its closing bracket, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once the Game Mode has been retrieved, we just send the alert
    message with the opportune parameters. It’s now time to compile the project and
    do some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the alert implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start a new game session, and once the number of minions is good enough, let
    your character be detected by one of them. Once alerted, all nearby minions will
    begin investigating the area, posing a serious danger to the player as more and
    more AI characters spot them, leading to a potentially dangerous chain reaction.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.2* shows one such situation – the player has not been stealthy
    enough, and AI opponents have started detecting the character while alerting each
    other.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The alert system in action](img/Figure_09_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The alert system in action
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you implemented a messaging system for your AI opponents and
    learned the power of having a centralized place to manage your gameplay logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will use the Gameplay Framework damage system to let
    players defeat enemies. Did you really believe I’d allow the poor thief hero to
    rot in the Lichlord’s grasp without any aid? Well, think again, my dear reader!
  prefs: []
  type: TYPE_NORMAL
- en: Adding health to the AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the project, you will add a health system to the minion AI to
    make it possible to defeat it during gameplay. You will also add a spawn system
    so that when the opponent is defeated, the player will be rewarded with a well-deserved
    prize.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement such features, we need to open the minion class and start doing
    some coding – open the `US_Minion.h` header, and in the `private` section, add
    these two declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first one is used to keep track of the enemy health, while the second one
    will contain the class of the item pickup that will be spawned once the minion
    is defeated. Both of them can be modified in a child Blueprint Class (thanks to
    the `EditDefaultsOnly` property specifier), so you can build your own variations
    of the minion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, locate the `protected` section and add the damage handler declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The header is now complete, so it’s time to open the `US_Minion.cpp` file and
    implement the health system. As usual, start by adding the needed `include` declarations
    at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the base pickup that will be spawned when the character is defeated;
    you’ll use the pickup coin you created in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver the Network*. Locate the constructor, and just
    before the closing bracket, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code logic should be familiar, as we get a Blueprint asset from the project
    library and assign it the `SpawnedPickup` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to implement the damage handler logic. Locate the `PostInitializeComponents()`
    method and add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just bind the `OnDamage` handler to the `OnTakeAnyDamage` delegate.
    As a last step, we need to implement the `OnDamage()` method, so add this code
    to your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What this function does is to subtract the `Damage` value from the `Health`
    property; if the minion reaches zero health, it will immediately spawn the prize
    (i.e., the pickup) and then it will destroy itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a simple health system for the AI opponent, by
    adding the `Health` property and keeping track of its value as damage is taken
    – whenever the minion has been defeated, it will spawn a coin or a similar prize,
    ready to be picked up by the nearest (or swiftest) character!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for your players, the hapless band of thieving heroes is, at the
    moment, ill equipped to dispatch the Lichlord’s minions in the treacherous underground
    realm! Fear not, for we shall come to their aid by adding a splendid weapon inventory
    to their arsenal in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a weapon system to the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your beloved character has been longing for a weapon system ever since you started
    implementing it. In this section, we shall finally grant its wishes and provide
    it the ability to wield (not-so) powerful tools of destruction. Let’s make our
    character stronger and more formidable by arming it with an amazing weapon!
  prefs: []
  type: TYPE_NORMAL
- en: Since our character hero is a sneaky thief who prefers to avoid direct combat
    with stronger and more heavily armored opponents, we will focus on a throwing
    dagger system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid adding cluttered code in the `US_Character` class, you’ll
    implement a brand-new component that will handle the weapon logic – this means
    that you’ll work on the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A component that will be added to the character and handle the player input
    and dagger spawn logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dagger weapon that will be thrown at runtime and cause damage to the enemy
    opponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a first step, we will create the weapon projectile that will be spawned by
    the character when attacking during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dagger projectile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is create a projectile class that will serve as a throwable
    dagger. To do so, in the Unreal Editor, create a new C++ class that will extend
    `Actor`, and call it `US_BaseWeaponProjectile`. Once it has been created, open
    the `US_BaseWeaponProjectile.h` file, and in the `private` section, add the following
    component declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we will add a collision area to check hits during gameplay,
    a static mesh for the dagger model, and projectile logic to make the dagger move
    once it has been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remaining in the `private` section, add the `Damage` property with a base value
    of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `public` section, add the usual getter methods for the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add a handler for when the weapon makes contact with its
    target. Add the following code to the `protected` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The header is ready, so we need to implement the logic – open the `US_BaseWeaponProjectile.cpp`
    file and add the necessary `include` declarations at its top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, locate the constructor and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code logic is lengthy but straightforward to comprehend – we just create
    and initialize the necessary components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SphereCollision` has some basic values you should be familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mesh` is set to a dagger model and rotated and positioned in order to align
    with the overall Actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProjectileMovement` has gravity disabled and a speed that will move the Actor
    fast and simulate a real dagger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to mention is that we bind the `OnHit()` method to the `OnComponentHit`
    delegate through the `AddDynamic` helper macro. Also, note the final line of code
    that activates replication for the weapon – always keep in mind that Actors are
    not replicated by default!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `OnHit()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can be divided into three main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we compute the damage, starting from the `Damage` base value.
    If the instigator (i.e., the character that spawned the projectile) is `US_Character`,
    we get its damage multiplier from the statistics and update the provoked damage.
    This means the higher the level of the character, the higher the damage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a refresher on how character statistics are managed, please take a look
    back at [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver* *the Network*.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the code verifies whether the launched projectile has hit
    an Actor. If it has, it will then inflict the corresponding amount of damage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last and final part simply destroys the projectile – its mission is finished,
    and this means it should be removed from the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the projectile all set up and ready to go, it’s time to implement some
    spawn logic so that your thief hero can unleash the full power of this shiny new
    weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the weapon component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a class that will add new features to the character.
    As you may remember from [*Chapter 4*](B18203_04.xhtml#_idTextAnchor086), *Setting
    Up Your First Multiplayer Environment*, a component will let you implement reusable
    functionality and can be attached to any Actor or another component. In this case,
    we will implement a weapon system, with a `Transform` property) – this will allow
    you to position the component somewhere inside the character and act as a spawn
    point for the thrown projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the class. To do so, create a new class that extends
    from a Scene component and call it `US_WeaponProjectileComponent`. Once the creation
    process has finished, open `US_WeaponProjectileComponent.h`, and in the `private`
    section, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we declare the projectile class (i.e., the projectile we previously
    created, or a subclass of it). Then, we declare the necessary elements that will
    let us take advantage of the enhanced input system. As we don’t want to add dependencies
    to the main character, we will use a different mapping context from the one used
    in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107), *Managing Actors in a Multiplayer
    Environment* – this will let us implement a flexible combat system and add as
    many features as we want, without adding clutter to the main character class.
    Imagine the thrill of watching your sneaky thief hero slipping through the shadows,
    quietly backstabbing the most despised minions of the dreaded Lichlord! The possibilities
    for mayhem and mischief will be endless!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s stop dreaming and get back to coding. In the `public` section,
    add a setter for the projectile class that will allow you to change the spawned
    dagger projectile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function has nothing to do with throwing things around, but it will be
    most useful if you plan to add a weapon pickup to your game, in order to improve
    your character’s fighting skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, in the `protected` section, declare the `Throw()` action and its corresponding
    server call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code will let us spawn the thrown daggers during gameplay from the server
    – always remember that the server should be in command when generating replicated
    Actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the header file is finished, open the `US_WeaponProjectileComponent.cpp`
    file to start implementing its features. As usual, locate the top of the file,
    and add the `include` declarations for the classes we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the constructor, add this single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just declare the base projectile that will be spawned when the throw
    action is triggered; you will obviously be able to change it in the derived Blueprint
    Classes if you need a different weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, locate the `BeginPlay()` method, and just after the `Super::BeginPlay()`
    declaration, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we check that the component owner is our `US_Character`
    class, in order to get its controller and initialize the mapping context and its
    actions. Note that this initialization is done inside the `BeginPlay()` function,
    which means that these steps will be done just once – that is, when the game is
    started – to be sure that there is an Actor owner and a corresponding controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the throw logic by adding the following method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Throw()` method simply calls the server-side implementation
    that will spawn the projectile from the component location. You are already familiar
    with the spawn action (do you remember the minion spawner?), but there is an important
    thing to notice this time – we use the `FActorSpawnParameters` structure to set
    the owner of the projectile and, most importantly, the instigator (i.e., the Actor
    that spawned the object). This property is used by the projectile to retrieve
    the character statistics and handle the damage multiplier, code logic we implemented
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, add the setter method that will let you change the weapon spawned by
    the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The component has now been properly set – you just need to attach an instance
    of it to the thief character to make it fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the WeaponProjectile component to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have created a weapon component, it’s time to add it to the character.
    Open the `US_Character.h` header file, and in the `private` section, add the component
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as usual, add the corresponding getter utility method to the `public`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `US_Character.cpp` source file and include the component class
    declaration at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, locate the constructor, and just after the noise emitter creation and
    initialization, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after we create the component, we attach it to the root component
    of the character and position it at a relative location, set to `(120, 70, 0)`.
    If you want your character to be left-handed, you can just use a negative value
    for the `X` coordinate (i.e., `-120.f`).
  prefs: []
  type: TYPE_NORMAL
- en: As hard as it may be to believe, the code to attach the weapon component to
    the character is complete; the code logic is already handled in the component
    itself, so you can sit back, relax, and let everything fall into place like a
    well-oiled machine!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now switch back to the Unreal Editor and compile your project – once
    finished, you can open the `WeaponProjectile` component, with **Projectile Class**
    set to a default value, as depicted in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The WeaponProjectile component attached to the character Actor](img/Figure_09_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The WeaponProjectile component attached to the character Actor
  prefs: []
  type: TYPE_NORMAL
- en: With the `WeaponProjectile` component attached to the character, the last thing
    to do is to create a mapping context for the player input and an input action
    for the throw logic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an input system for the weapon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the final part of this section, you will define the mapping context and the
    input action for the throw interaction. This is something you are already familiar
    with, as you previously created similar assets in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a* *Multiplayer Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let’s open the Content Browser and navigate to the
    **Content** | **Input** folder. We will create the throw action asset in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the input mapping context for the throw interaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the action asset for the throw interaction, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select `IA_Throw`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the asset to open it, and from the **Value Type** dropdown,
    select **Digital (bool)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-check that the **Consume Input** checkbox is ticked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result for the throw action asset is shown in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The throw action settings](img/Figure_09_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The throw action settings
  prefs: []
  type: TYPE_NORMAL
- en: Now that the action has been set, let’s create a mapping context for the weapon
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the input mapping context for the weapon interactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the weapon context mapping, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select `IMC_Weapons`. Double-click on
    the asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new mapping context by clicking on the **+** icon next to the **Mappings**
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the drop-down menu that will be added, select **IA_Throw** to add this
    action to the mapping context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click twice on the **+** icon next to the drop-down menu to add two other control
    bindings for this action (one is set by default). In the drop-down menu next to
    each new field, use the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first binding should be set to **Left Ctrl** from the **Keyboard** category
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second binding should be set to **Gamepad Face Button Right** from the **Gamepad**
    category
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third binding should be set to **Left Mouse Button** from the **Mouse**
    category
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final result for the weapon mapping context should be like the one depicted
    in *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The weapon mapping context settings](img/Figure_09_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The weapon mapping context settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the assets are ready, it’s time to add them to the character:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **BP_Character** Blueprint, select the **Weapon** component, and in
    the **Details** panel, locate the **Input** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Weapon Mapping Context** field, assign the **IMC_Weapons** asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Throw Action** field, assign the **IA_Throw** asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have set these properties, your **Input** category should look like
    the one depicted in *Figure 9**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The updated Input category](img/Figure_09_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The updated Input category
  prefs: []
  type: TYPE_NORMAL
- en: Now that the input settings have been properly updated, it’s time to do some
    testing to check that everything works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the weapon system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to show the Lichlord’s minions who the boss is and wreak some havoc
    in their underground lairs! Let’s give them a taste of our hero’s targeting skills
    by starting a game session.
  prefs: []
  type: TYPE_NORMAL
- en: During gameplay, your character should be able to spawn a dagger whenever using
    the throw action – for example, by clicking the left mouse button. The dagger
    should destroy itself whenever it hits something and provoke damage to the AI
    minions.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a minion reaches zero health, it should be removed from the game, and
    a coin should spawn in the level. Collecting enough coins will make your character
    level up, and consequently, the character itself will provoke additional damage
    when hitting any enemy.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.7* shows the character throwing some daggers during gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The dagger attack in action](img/Figure_09_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – The dagger attack in action
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you implemented a weapon system through a new component that
    is attached to your character and a projectile Actor that can be spawned in the
    game and properly replicated through the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, you will introduce some diverse variations of the AI
    opponents, with the aim of enhancing the game’s variety and overall enjoyability.
  prefs: []
  type: TYPE_NORMAL
- en: Creating AI variations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve got the AI opponents all set up and ready to go for some epic
    battles, let’s add some more variations to AI minions and make things more interesting
    and engaging. If a project has been well planned, changing the behavior of an
    AI – even a basic one such as the one we created in this chapter – is usually
    just a matter of adjusting some settings!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create a new AI opponent, starting from the basic `US_Minion`
    class, and you will tweak its property in order to give it different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI sentinel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While watching mindless minions wander around a dungeon cluelessly may cause
    a chuckle or two, it is certainly not enough for the Lichlord’s devious plans.
    He wants to be sure that each and every corner of his realm is safe and well guarded.
    This means you will craft some undead sentinels that will have keen senses and
    be more territorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Blueprint Class, inheriting from the basic minion.
    Open the Content Browser and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Blueprints` folder, right-click and select **Blueprint Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the window that pops up, select **US_Minion** from the **All** **Classes**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created Blueprint `BP_MinionSentinel`, and then double-click
    on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `6000,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `60,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `20,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `1000,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The sentinel Minion AI settings](img/Figure_09_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The sentinel Minion AI settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `600,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `1000,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `2500,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `60,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The sentinel AI settings](img/Figure_09_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The sentinel AI settings
  prefs: []
  type: TYPE_NORMAL
- en: With these settings, you will create a minion that will patrol an approximately
    small area, changing direction frequently and moving very slowly. Its senses will
    be keen, and its alert radius will be larger than a regular minion. When an intruder
    has been spotted, the sentinel will slow down, calling for help, letting its more
    aggressive counterparts handle the chase. It’s not one for combat, but it’s still
    on the lookout for any suspicious activity!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, you can add a couple of glowing eyes for this darkness-gazing
    undead character by changing **Element 5** in the mesh **Materials** list to the
    **M_Base_Emissive** material asset, as shown in *Figure 9**.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Materials settings](img/Figure_09_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The Materials settings
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of the sentinel (with some dramatic lightning add-ons) can
    be seen in *Figure 9**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The sentinel added to the scene](img/Figure_09_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The sentinel added to the scene
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you have created a new AI with just a couple of tweaks to the
    **Details** panel. Let’s create another one, a more aggressive undead minion.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI miniboss
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can actually use the same process that worked in the previous subsection
    to create a new AI that will deal with hero intruders in a totally different way.
    It’s like getting creative with a recipe and making something new and unexpected
    but still (dangerously) delicious!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Content Browser and complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Blueprints` folder, right-click and select **Blueprint Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the window that pops up, select **US_Minion** from the **All** **Classes**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created Blueprint `BP_MinionMiniboss`, and then double-click
    on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `100,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `100,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `400,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `50000,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The miniboss Minion AI settings](img/Figure_09_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The miniboss Minion AI settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `200,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `400,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `200,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `20,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final settings for this category are shown in *Figure 9**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The miniboss AI settings](img/Figure_09_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The miniboss AI settings
  prefs: []
  type: TYPE_NORMAL
- en: This AI opponent has been set to a really dull behavior while patrolling (low
    perception, slower movement, etc.), but it will become dangerously fast once alerted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the miniboss started to look a bit dull, so the Lichlord has decided
    to give it a literal armor makeover. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Mesh** component and change the **Skeletal Mesh Asset** property
    to the **skeleton_warrior** asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Mesh** scale to a value of **1.2** to make it bigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Health** property to a value of **20** to make it more damage-resistant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This foe is about to go from “meh” to menacing, and hero intruders better watch
    out! The final result of the miniboss, compared with a base minion, is shown in
    *Figure 9**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The miniboss minion](img/Figure_09_14_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The miniboss minion
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of it all is that you can get really creative with your enemy opponents
    and test out all sorts of different behaviors and tactics. And if something just
    isn’t working for you, no worries! Just delete it and start afresh with something
    new in just a few short minutes.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional nice touch to the AI, why not use the pickup spawn system we
    added earlier in this chapter to spice up the game? Depending on how rare or dangerous
    the defeated minion is, you could have it spawn different types of coins!
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your undead army ready to go, you can get back to your enemy spawner
    and add the Blueprints to the system – something we will do in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the minion spawner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have guessed, adding your brand-new minion varieties is just a matter
    of putting their Blueprints inside a spawner. To do so, select the spawner you
    previously added to the level, and in the **Details** panel, locate the **Spawnable
    Minions** array property in the **Spawn System** category – there should already
    be one item in the list, **US_Minion**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add as many items as you wish, selecting the spawnable minions you need for
    that particular spawn area. *Figure 9**.15* shows my setup for the main spawner
    area in the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The spawn area setup](img/Figure_09_15_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The spawn area setup
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I chose to work with five elements, allocating a 20% chance
    for each to be added to the level every time the `Spawn()` method is called. Since
    the basic minion utilizes three of these elements, there is a 60% chance that
    it will appear as an opponent, compared to the sentinel and miniboss, which only
    have a 20% probability of spawning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are happy with your setup, you can test the game. *Figure 9**.16*
    shows my spawner in action at the start of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The spawner at the start of the game](img/Figure_09_16_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The spawner at the start of the game
  prefs: []
  type: TYPE_NORMAL
- en: In this final section, you created some variations for the base minions; by
    changing some of their base properties, you changed the way they behave during
    gameplay, making your level more engaging and diverse.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you actively worked to improve the behavior of your enemy AIs
    within the level. The focus was on developing new features that make the gaming
    experience even more engaging and challenging for players. You actually improved
    the Lichlord’s minions’ sense of hearing to make them even more alert and perceptive
    when it comes to spotting those poor thieving heroes.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, you also implemented a health system for the minions and added
    some pretty sharp (literally!) tools to the player’s arsenal that they can use
    to take down those nasty foes! Finally, you created some enemy variations to make
    the dungeon less boring and more engaging for the player.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from what you have built here, if you plan ahead, improving gameplay
    can be a walk in the park! By taking the time to carefully map out your strategies
    and implement the right features, you can make gameplay engaging and immersive
    for players while also achieving your desired results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will improve the overall look and feel of the game by
    adding animations and prisoners to rescue. Additionally, I will provide you with
    some tips on how to take your game to the next level, but let’s be clear – I’m
    not going to code it all for you! I believe in your ability to create something
    amazing, and I can’t wait to see what you come up with!
  prefs: []
  type: TYPE_NORMAL
