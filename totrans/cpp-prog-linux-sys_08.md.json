["```cpp\n#include <iostream>\n#include <csignal>\n#include <unistd.h>\n#include <sys/time.h>\n#include <atomic>\nstatic std::atomic_bool continue_execution{true};\nint main() {\n    struct sigaction sa{};\n    sa.sa_handler = [](int signum) {\n        // Timer triggered, stop the loop.\n        std::cout << \"Timer expired. Stopping the\n          task...\\n\";\n        continue_execution = false;\n    };\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGALRM, &sa, nullptr);\n    // Configure the timer to trigger every 1 seconds\n    struct itimerval timer{\n        .it_interval{.tv_sec{1}, .tv_usec{0}},\n        .it_value{.tv_sec{1}, .tv_usec{0}}\n    };\n    // Start the timer\n    setitimer(ITIMER_REAL, &timer, nullptr);\n    std::cout << \"Timer started. Waiting for timer\n      expiration...\\n\";\n    // Keep the program running to allow the timer to\n      trigger\n    while (continue_execution) {\n        sleep(1);\n    }\n    return 0;\n}\n```", "```cpp\nProgram returned: 0\nTimer started. Waiting for timer expiration...\nTimer expired. Stopping the task...\n```", "```cpp\n#include <iostream>\n#include <ctime>\nstatic const auto LIMIT{10000};\nvoid just_busy_wait_f() {\n    for (auto i{0}; i < LIMIT; ++i) {\n        for (auto j{0}; j < LIMIT; ++j);\n    }\n}\nint main() {\n    timespec start, end;\n    // Start the timer\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    // Measured code segment\n    just_busy_wait_f();\n    // Stop the timer\n    clock_gettime(CLOCK_MONOTONIC, &end);\n    // Calculate the elapsed time\n    const auto elapsed{(end.tv_sec - start.tv_sec) +\n      (end.tv_nsec - start.tv_nsec) / 1e9};\n    std::cout << \"Elapsed time: \" << elapsed << \"\n      seconds\\n\";\n    return 0;\n}\n```", "```cpp\nProgram returned: 0\nElapsed time: 0.169825 seconds\n```", "```cpp\n#include <iostream>\n#include <chrono>\nusing namespace std::chrono;\nint main() {\n    const auto start{steady_clock::now()}; // {1}\n    just_busy_wait_f(); // {2}\n    const auto end{steady_clock::now()}; // {3}\n    const auto dur{duration_cast<milliseconds>(end -\n      start)}; // {4}\n    std::cout << \"Execution time: \" << dur.count() << \"\n      milliseconds\\n\"; // {5}\n    return 0;\n}\n```", "```cpp\nProgram returned: 0\nExecution time: 179 milliseconds\n```", "```cpp\nusing namespace std::chrono;\nconstexpr std::chrono::duration<int, std::ratio<1>>\n  six_minutes_1{360};\nconstexpr std::chrono::duration<double, std::ratio<3600>>\n  six_minutes_2{0.1};\nconstexpr std::chrono::minutes six_minutes_3{6};\nconstexpr auto six_minutes_4{6min};\nstd::cout << six_minutes_1 << '\\n';\nstd::cout << six_minutes_2 << '\\n';\nstd::cout << six_minutes_3 << '\\n';\nstd::cout << six_minutes_4 << '\\n';\nstatic_assert(six_minutes_1 == six_minutes_2);\nstatic_assert(six_minutes_2 == six_minutes_3);\nstatic_assert(six_minutes_3 == six_minutes_4);\n```", "```cpp\n360s\n0.1h\n6min\n6min\n```", "```cpp\nusing namespace std::chrono;\nconst time_point start{steady_clock::now()}; // {1}\nconst duration epoch_to_start{start.time_since_epoch()}; //\n  {2}\nstd::cout << \"Time since clock epoch: \" << epoch_to_start\n  << '\\n'; // {3}\n```", "```cpp\nTime since clock epoch: 2080809926594ns\n```", "```cpp\nusing namespace std::chrono;\nconst minutes\n  dur_minutes{steady_clock::now().time_since_epoch()};\n```", "```cpp\nusing namespace std::chrono;\nauto dur_from_epoch{steady_clock::now()\n  .time_since_epoch()}; // {1}\nminutes dur_minutes{duration_cast<minutes>\n  (dur_from_epoch)}; // {2}\nstd::cout << \"Duration in nanoseconds: \" << dur_from_epoch\n  << '\\n'; //{3}\nstd::cout << \"Duration in minutes: \" << dur_minutes <<\n  '\\n'; //{4}\n```", "```cpp\nDuration in nanoseconds: 35206835643934ns\nDuration in minutes: 586min\n```", "```cpp\nusing namespace std::chrono;\nseconds dur_sec_1{55s}; //{1}\nseconds dur_sec_2{65s}; //{2}\nminutes dur_min_1{round<minutes>(dur_sec_1)}; //{3}\nminutes dur_min_2{round<minutes>(dur_sec_2)}; //{4}\nstd::cout << \"Rounding up to \" << dur_min_1 << '\\n';\nstd::cout << \"Rounding down to \" << dur_min_2 << '\\n';\n```", "```cpp\nRounding up to 1min\nRounding down to 1min\n```", "```cpp\nusing namespace std::chrono;\ntime_point<system_clock> systemClockEpoch;\nstd::cout << std::format(\"system_clock epoch:\n  {0:%F}T{0:%R%z}.\", systemClockEpoch) << '\\n';\n```", "```cpp\nsystem_clock epoch: 1970-01-01T00:00+0000.\n```", "```cpp\nusing namespace std::chrono;\ntai_time tai{tai_clock::now()};\nutc_time utc{utc_clock::now()};\nstd::cout << \"International atomic time (TAI): \" << tai <<\n  '\\n';\nstd::cout << \"Coordinated universal time (UTC): \" << utc <<\n  '\\n';\n```", "```cpp\nInternational atomic time (TAI): 2023-08-04 14:02:57.95506\nCoordinated universal time (UTC): 2023-08-04 14:02:20.95506\n```", "```cpp\nusing namespace std::chrono;\ntai_time tai{tai_clock::now()};\nstd::cout << \"International atomic time (TAI): \" << tai <<\n  '\\n';\nutc_time utc{clock_cast<utc_clock>(tai)};\nstd::cout << \"Coordinated universal time (UTC): \" << utc <<\n  '\\n';\n```", "```cpp\nInternational atomic time (TAI): 2023-08-04 14:16:22.72521\nCoordinated universal time (UTC): 2023-08-04 14:15:45.72521\n```", "```cpp\nusing namespace std::chrono;\nyear theYear{2023};\nmonth theMonth{8};\nday theDay{4};\nstd::cout << \"Year: \" << theYear;\nstd::cout << \", Month: \" << theMonth;\nstd::cout << \", Day: \" << theDay << '\\n';\n```", "```cpp\nYear: 2023, Month: Aug, Day: 04\n```", "```cpp\nusing namespace std::chrono;\nstd::cout << \"Year: \" << year{2023} ;\nstd::cout << \", Month: \" << month{13};\nstd::cout << \", Day: \" << day{32} << '\\n';\n```", "```cpp\nYear: 2023, Month: 13 is not a valid month, Day: 32 is not a valid day\n```", "```cpp\nusing namespace std::chrono;\nsys_time now{system_clock::now()};\nyear_month_day today{floor<days>(now)};\nstd::cout << \"Today is: \" << today << '\\n';\nyear thisYear{today.year()};\nstd::cout << \"Year \" << thisYear;\nif (thisYear.is_leap()) {\n    std::cout << \" is a leap year\\n\";\n} else {\n    std::cout << \" is not a leap year\\n\";\n}\n```", "```cpp\nToday is: 2023-08-05\nYear 2023 is not a leap year\n```", "```cpp\nusing namespace std::chrono;\nyear_month_day date1{July/5d/2023y};\nyear_month_day date2{1d/October/2023y};\nyear_month_day date3{2023y/January/27d};\nstd::cout << date1 << '\\n';\nstd::cout << date2 << '\\n';\nstd::cout << date3 << '\\n';\n```", "```cpp\n2023-07-05\n2023-10-01\n2023-01-27\n```", "```cpp\nusing namespace std::chrono;\nconst tzdb& tzdb{get_tzdb()};\nconst std::vector<time_zone>& tzs{tzdb.zones};\nfor (const time_zone& tz : tzs) {\n    std::cout << tz.name() << '\\n';\n}\n```", "```cpp\nAfrica/Abidjan\nAfrica/Accra\nAfrica/Addis_Ababa\nAfrica/Algiers\nAfrica/Asmara\nAfrica/Bamako\n...\n```", "```cpp\nusing namespace std::chrono;\nconst tzdb& tzdb{get_tzdb()};\nconst std::vector<time_zone>& tzs{tzdb.zones};\nconst auto& res{std::find_if(tzs.begin(), tzs.end(), []\n  (const time_zone& tz){\n    std::string name{tz.name()};\n    return name.ends_with(\"Sofia\");\n})};\nif (res != tzs.end()) {\n    try {\n        const std::string_view myLocation{res->name()};\n        const std::string_view london{\"Europe/London\"};\n        const time_point now{system_clock::now()};\n        const zoned_time zt_1{myLocation, now};\n        const zoned_time zt_2{london, now};\n        std::cout << myLocation << \": \" << zt_1 << '\\n';\n        std::cout << london << \": \" << zt_2 << '\\n';\n    } catch (const std::runtime_error& e) {\n        std::cout << e.what() << '\\n';\n    }\n}\n```", "```cpp\nEurope/Sofia: 2023-08-05 13:43:53.503184619 EEST\nEurope/London: 2023-08-05 11:43:53.503184619 BST\n```"]