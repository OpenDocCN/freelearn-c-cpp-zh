<html><head></head><body><div><h1 class="header-title">Qt Core Essentials</h1>
                
            
            
                
<p>This chapter will help you master Qt ways of basic data processing and storage. First of all, you will learn how to handle textual data and how to match text against regular expressions. Next, we will provide an overview of Qt containers and describe common pitfalls related to them. Then, you will see how to store and fetch data from files and how to use different storage formats for text and binary data. By the end of this chapter, you will be able to implement non-trivial logic and data processing in your games efficiently. You will also know how to load external data in your games and how to save your own data in permanent storage for future use.</p>
<p>Main topics covered in this chapter:</p>
<ul>
<li>Text handling</li>
<li>Qt containers</li>
<li>Serialization to INI, JSON, XML, and binary data</li>
<li>Saving the application's settings</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Text handling</h1>
                
            
            
                
<p>Applications with a graphical user interface (and games surely fall into this category) are able to interact with users by displaying text and by expecting textual input from the user. We have already scratched the surface of this topic in the previous chapters using the <kbd>QString</kbd> class. Now, we will go into further detail.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">String encodings</h1>
                
            
            
                
<p>The C++ language does not specify encoding of strings. Thus, any <kbd>char*</kbd> array and any <kbd>std::string</kbd> object can use an arbitrary encoding. When using these types for interaction with native APIs and third-party libraries, you have to refer to their documentation to find out which encoding they use. The encoding used by native APIs of the operating system usually depends on the current locale. Third-party libraries often use the same encoding as native APIs, but some libraries may expect another encoding, for example, UTF-8.</p>
<p>A string literal (that is, each bare text you wrap in quotation marks) will use an implementation defined encoding. Since C++11, you have an option to specify the encoding your text will have:</p>
<ul>
<li><kbd>u8"text"</kbd> will produce a UTF-8 encoded <kbd>const char[]</kbd> array</li>
<li><kbd>u"text"</kbd> will produce a UTF-16 encoded <kbd>const char16_t[]</kbd> array</li>
<li><kbd>U"text"</kbd> will produce a UTF-32 encoded <kbd>const char32_t[]</kbd> array</li>
</ul>
<p>Unfortunately, the encoding used for interpreting the source files is still implementation defined, so it's not safe to put non-ASCII symbols in string literals. You should use escape sequences (such as <kbd>\unnnn</kbd>) to write such literals.</p>
<p>Text in Qt is stored using the <kbd>QString</kbd> class that uses Unicode internally. Unicode allows us to represent characters in almost all languages spoken in the world and is the de facto standard for native encoding of text in most modern operating systems. There are multiple Unicode-based encodings. Memory representation of the content of <kbd>QString</kbd> resembles UTF-16 encoding. Basically, it consists of an array of 16-bit values where each Unicode character is represented by either 1 or 2 values.</p>
<p>When constructing a <kbd>QString</kbd> from a <kbd>char</kbd> array or an <kbd>std::string</kbd> object, it's important to use a proper conversion method that depends on the initial encoding of the text. By default, <kbd>QString</kbd> assumes UTF-8 encoding of the input text. UTF-8 is compatible with ASCII, so passing UTF-8 or ASCII-only text to <kbd>QString(const char *str)</kbd> is correct. <kbd>QString</kbd> provides a number of static methods to convert from other encodings such as <kbd>QString::fromLatin1()</kbd> or <kbd>QString::fromUtf16()</kbd>. <kbd>QString::fromLocal8Bit()</kbd> method assumes the encoding corresponding to the system locale.</p>
<p>If you have to combine both <kbd>QString</kbd> and <kbd>std::string</kbd> in one program, <kbd>QString</kbd> offers you the <kbd>toStdString()</kbd> and <kbd>fromStdString()</kbd> methods to perform a conversion. These methods also assume UTF-8 encoding of <kbd>std::string</kbd>, so you can't use them if your strings are in another encoding.</p>
<p>Default representation of string literals (for example, <kbd>"text"</kbd>) is not UTF-16, so each time you convert it to a <kbd>QString</kbd>, an allocation and conversion happens. This overhead can be avoided using the <kbd>QStringLiteral</kbd> macro:</p>
<pre>QString str = QStringLiteral("I'm writing my games using Qt"); </pre>
<p><kbd>QStringLiteral</kbd> does two things:</p>
<ul>
<li>It adds a <kbd>u</kbd> prefix to your string literal to ensure that it will be encoded in UTF-16 at compile time</li>
<li>It cheaply creates a <kbd>QString</kbd> and instructs it to use the literal without performing any allocation or encoding conversion</li>
</ul>
<p>It's a good habit to wrap all your string literals (except the ones that need to be translated) into <kbd>QStringLiteral</kbd> but it is not required, so don't worry if you forget to do that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">QByteArray and QString</h1>
                
            
            
                
<p><kbd>QString</kbd> always contains UTF-16 encoded strings, but what if you have data in an unknown (yet) encoding? Also, what if the data is not even text? In these cases, Qt uses the <kbd>QByteArray</kbd> class. When you read data directly from a file or receive it from a network socket, Qt will return the data as a <kbd>QByteArray</kbd>, indicating that this is an arbitrary array of bytes without any information about the encoding:</p>
<pre>QFile file("/path/to/file");
file.open(QFile::ReadOnly);
QByteArray array = file.readAll();</pre>
<p>The closest equivalent of <kbd>QByteArray</kbd> in the standard library would be <kbd>std::vector&lt;char&gt;</kbd>. As the name implies, this is just an array of bytes with some helpful methods. In the preceding example, if you know that the file you read is in UTF-8, you can convert the data to a string, as follows:</p>
<pre>QString text = QString::fromUtf8(array);</pre>
<p>If you have no idea what encoding the file uses, it may be best to use the system encoding, so <kbd>QString::fromLocal8Bit</kbd> would be better. Similarly, when writing to a file, you need to convert the string to a byte array before passing it to the <kbd>write()</kbd> function:</p>
<pre>QString text = "new file content\n";
QFile file("/path/to/file");
file.open(QFile::WriteOnly);
QByteArray array = text.toUtf8();
file.write(array);</pre>
<p>You can use <kbd>file.close()</kbd> to close the file. <kbd>QFile</kbd> will also automatically close the file when deleted, so if your <kbd>QFile</kbd> object goes out of scope immediately after you've finished working with the file, there is no need for an explicit <kbd>close()</kbd> call.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using other encodings</h1>
                
            
            
                
<p>As we've already mentioned, <kbd>QString</kbd> has convenient methods for decoding and encoding data in the most popular encodings, such as UTF-8, UTF-16, and Latin1. However, Qt knows how to handle many other encodings as well. You can access them using the <kbd>QTextCodec</kbd> class. For example, if you have a file in Big-5 encoding, you can ask Qt for a codec object by its name and make use of the <kbd>fromUnicode()</kbd> and <kbd>toUnicode()</kbd> methods:</p>
<pre>QByteArray big5Encoded = big5EncodedFile.readAll();
QTextCodec *big5Codec = QTextCodec::codecForName("Big5");
QString text = big5Codec-&gt;toUnicode(big5Encoded);
QByteArray big5EncodedBack = big5Codec-&gt;fromUnicode(text); </pre>
<p>You can list the codecs supported on your installation using the <kbd>QTextCodec::availableCodecs()</kbd> static method. In most installations, Qt can handle almost 1,000 different text codecs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Basic string operations</h1>
                
            
            
                
<p>The most basic tasks that involve text strings are the ones where you add or remove characters from the string, concatenate strings, and access the string's content. In this regard, <kbd>QString</kbd> offers an interface that is compatible with <kbd>std::string</kbd>, but it also goes beyond that, exposing many more useful methods.</p>
<p>Adding data at the beginning or at the end of the string can be done using the <kbd>prepend()</kbd> and <kbd>append()</kbd> methods. Inserting data in the middle of a string can be done with the <kbd>insert()</kbd> method that takes the position of the character where we need to start inserting as its first argument and the actual text as its second argument. All these methods have a couple of overloads that accept different objects that can hold textual data, including the classic <kbd>const char*</kbd> array.</p>
<p>Removing characters from a string is similar. The basic way to do this is to use the <kbd>remove()</kbd> method that accepts the position at which we need to delete characters, and the number of characters to delete is as shown:</p>
<pre>QString str = QStringLiteral("abcdefghij");
str.remove(2, 4); // str = "abghij" </pre>
<p>There is also a <kbd>remove()</kbd> overload that accepts another string. When called, all its occurrences are removed from the original string. This overload has an optional argument that states whether comparison should be done in the default case-sensitive (<kbd>Qt::CaseSensitive</kbd>) or case-insensitive (<kbd>Qt::CaseInsensitive</kbd>) way:</p>
<pre>QString str = QStringLiteral("Abracadabra");
str.remove(QStringLiteral("ab"), Qt::CaseInsensitive);
// str = "racadra"</pre>
<p>To concatenate strings, you can either simply add two strings together, or you can append one string to the other:</p>
<pre>QString str1 = QStringLiteral("abc");
QString str2 = QStringLiteral("def");
QString str1_2 = str1 + str2;
QString str2_1 = str2;
str2_1.append(str1); </pre>
<p>Accessing strings can be divided into two use cases. The first is when you wish to extract a part of the string. For this, you can use one of these three methods—<kbd>left()</kbd>, <kbd>right()</kbd>, and <kbd>mid()</kbd>—that return the given number of characters from the beginning or end of the string or extract a substring of a specified length, starting from a given position in the string:</p>
<pre>QString original = QStringLiteral("abcdefghij");
QString l = original.left(3); // "abc"
QString r = original.right(2); // "ij"
QString m = original.mid(2, 5); // "cdefg" </pre>
<p>The second use case is when you wish to access a single character of the string. The use of the index operator works with <kbd>QString</kbd> in a similar fashion as with <kbd>std::string</kbd>, returning a copy or non-const reference to a given character that is represented by the <kbd>QChar</kbd> class, as shown in the following code:</p>
<pre>QString str = "foo";
QChar f = str[0]; // const
str[0] = 'g'; // non-const </pre>
<p>In addition to this, Qt offers a dedicated method—<kbd>at()</kbd>—that returns a copy of the character:</p>
<pre>QChar f = str.at(0); </pre>
<p>You should prefer to use <kbd>at()</kbd> instead of the index operator for operations that do not modify the character, as this explicitly uses a constant method.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The string search and lookup</h1>
                
            
            
                
<p>The second group of functionalities is related to searching for the string. You can use methods such as <kbd>startsWith()</kbd>, <kbd>endsWith()</kbd>, and <kbd>contains()</kbd> to search for substrings in the beginning or end or in an arbitrary place in the string. The number of occurrences of a substring in the string can be retrieved using the <kbd>count()</kbd> method.</p>
<p>Be careful, there is also a <kbd>count()</kbd> method that doesn't take any parameters and returns the number of characters in the string.</p>
<p>If you need to know the exact position of the match, you can use <kbd>indexOf()</kbd> or <kbd>lastIndexOf()</kbd> to receive the position in the string where the match occurs. The first call works by searching forward, and the other one searches backwards. Each of these calls takes two optional parameters—the second one determines whether the search is case-sensitive (similar to how <kbd>remove</kbd> works). The first one is the position in the string where the search begins. It lets you find all the occurrences of a given substring:</p>
<pre>int pos = -1;
QString str = QStringLiteral("Orangutans like bananas.");
do {
    pos = str.indexOf("an", pos + 1);
    qDebug() &lt;&lt; "'an' found starts at position" &lt;&lt; pos;
} while(pos != -1); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Dissecting strings</h1>
                
            
            
                
<p>There is one more group of useful string functionalities that makes <kbd>QString</kbd> different from <kbd>std::string</kbd>, that is, cutting strings into smaller parts and building larger strings from smaller pieces.</p>
<p>Very often, a string contains substrings that are glued together by a repeating separator (for example, <kbd>"1,4,8,15"</kbd>). While you can extract each field from the record using functions that you already know (for example, <kbd>indexOf</kbd>), an easier way exists. <kbd>QString</kbd> contains a <kbd>split()</kbd> method that takes the separator string as its parameter and returns a list of strings that are represented in Qt by the <kbd>QStringList</kbd> class. Then, dissecting the record into separate fields is as easy as calling the following code:</p>
<pre>QString record = "1,4,8,15,16,24,42";
QStringList items = record.split(",");
for(const QString&amp; item: items) {
    qDebug() &lt;&lt; item;
}</pre>
<p>The inverse of this method is the <kbd>join()</kbd> method present in the <kbd>QStringList</kbd> class, which returns all the items in the list as a single string merged with a given separator:</p>
<pre>QStringList fields = { "1", "4", "8", "15", "16", "24", "42" };
QString record = fields.join(","); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Converting between numbers and strings</h1>
                
            
            
                
<p><kbd>QString</kbd> also provides some methods for convenient conversion between textual and numerical values. Methods such as <kbd>toInt()</kbd>, <kbd>toDouble()</kbd>, or <kbd>toLongLong()</kbd> make it easy to extract numerical values from strings. All such methods take an optional <kbd>bool *ok</kbd> parameter. If you pass a pointer to a <kbd>bool</kbd> variable as this parameter, the variable will be set to <kbd>true</kbd> or <kbd>false</kbd>, depending on whether the conversion was successful or not. Methods returning integers also take the second optional parameter that specifies the numerical base (for example, binary, octal, decimal, or hexadecimal) of the value:</p>
<pre>bool ok;
int v1 = QString("42").toInt(&amp;ok, 10);
// v1 = 42, ok = true
long long v2 = QString("0xFFFFFF").toInt(&amp;ok, 16);
// v2 = 16777215, ok = true
double v3 = QString("not really a number").toDouble(&amp;ok);
//v3 = 0.0, ok = false</pre>
<p>A static method called <kbd>number()</kbd> performs the conversion in the other direction—it takes a numerical value and number base and returns the textual representation of the value:</p>
<pre>QString txt = QString::number(42); // txt = "42" </pre>
<p>This function has some optional arguments that allow you to control the string representation of the number. For integers, you can specify the numerical base. For doubles, you can choose the scientific format <kbd>'e'</kbd> or the conventional format <kbd>'f'</kbd> and specify the number of digits after the decimal delimiter:</p>
<pre>QString s1 = QString::number(42, 16); // "2a"
QString s2 = QString::number(42.0, 'f', 6); // "42.000000"
QString s3 = QString::number(42.0, 'e', 6); // "4.200000e+1"</pre>
<p>Some of the other classes that represent values also provide conversions to and from <kbd>QString</kbd>. An example of such a class is <kbd>QDate</kbd>, which represents a date and provides the <kbd>fromString()</kbd> and <kbd>toString()</kbd> methods.</p>
<p>These methods are nice and easy to use for technical purposes, for example, for reading and writing numbers to configuration files. However, they are not suitable when you need to display a number to the user or parse a user input because numbers are written differently in different countries. This brings us to the topic of <em>internationalization</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Internationalization</h1>
                
            
            
                
<p>Most real projects have a target audience in multiple countries. The most notable difference between them is the spoken language, but there are other aspects some developers may not think of. For example, dot <kbd>"."</kbd> and comma <kbd>","</kbd> are both fairly common as the decimal separator throughout the world. Date formats are also very different and incompatible, and using a wrong format (for example, <kbd>mm/dd/yyyy</kbd> instead of <kbd>dd/mm/yyyy</kbd>) will result in a completely different date.</p>
<p>Qt provides the <kbd>QLocale</kbd> class for dealing with locale-dependent operations, including conversions between numbers in strings. In the following code, <kbd>text</kbd> and <kbd>number</kbd> may have different values, depending on the system locale:</p>
<pre>QLocale locale = QLocale::system();
QString text = locale.toString(1.2);
double number = locale.toDouble(QStringLiteral("1,2"));</pre>
<p><kbd>QLocale</kbd> also provides methods for formatting dates and prices, and allows us to request additional information about local conventions.</p>
<p>As for translations, we've already mentioned that any text visible to users should be wrapped in a <kbd>tr()</kbd> function. Now we will explain this requirement.</p>
<p>Qt's translation system makes it possible for developing and translation teams to work independently. The project goes through the following steps:</p>
<ol>
<li>Developers create an application and wrap all text that should be translated in special translation functions (such as <kbd>tr()</kbd>). Visible text in forms is automatically wrapped in translation functions.</li>
<li>A special Qt tool (<strong>lupdate</strong>) searches for all strings wrapped in translation functions and generates a translation file (<kbd>.ts</kbd>).</li>
<li>Translators open this file in a special application called <strong>Qt Linguist</strong>. In that application, they are able to see all strings grouped by <em>context</em>, which is usually the class this text belongs to. They can add translations and save them in the translation file.</li>
<li>When this new translation file is copied back to the project and applied using the <kbd>QCoreApplication::installTranslator</kbd> function, the translation functions start returning translated text instead of simply returning the argument.</li>
<li>As the application evolves and a new untranslated text appears, it's shown untranslated by default. However, it can be automatically added to translation files, and translators can add new translations for new content, without losing the existing translations.</li>
</ol>
<p>We will not go into the details of this process. As a developer, you only need to ensure that all visible strings are wrapped in a translation function and a proper context is provided. The context is necessary because a short text (for example, one word on a button) may not be enough to understand the meaning and provide a proper translation, but how do we specify the context?</p>
<p>The main translation function is <kbd>QCoreApplication::translate()</kbd>. It accepts three arguments: the context, the text to translate, and an optional disambiguation text. The disambiguation argument is rarely needed. It can be used to distinguish between multiple instances of the same text in the same context and when they should have different translations.</p>
<p>Instead of <kbd>QCoreApplication::translate()</kbd>, you should usually use the <kbd>tr()</kbd> function, which is declared in each class that inherits <kbd>QObject</kbd>. <kbd>MyClass::tr(text, disambiguation)</kbd> is a shortcut for <kbd>QCoreApplication::translate(<strong>"MyClass"</strong>, text, disambiguation)</kbd>. Due to this, all translatable texts located in one class will share the same <kbd>context</kbd> string, so they will be grouped in Qt Linguist to make the translator's job easier.</p>
<p>If you have a translatable text outside of a subclass of <kbd>QObject</kbd>, the <kbd>tr()</kbd> function will not be available by default. In this case, you have the following options:</p>
<ul>
<li>Use the <kbd>QCoreApplication::translate()</kbd> function and write the <kbd>context</kbd> argument explicitly</li>
<li>Reuse the <kbd>tr()</kbd> function of a relevant class (for example, <kbd>MyClass::tr()</kbd>)</li>
<li>Declare the <kbd>tr()</kbd> function in your (non-<kbd>QObject</kbd>-based) class by adding the <kbd>Q_DECLARE_TR_FUNCTIONS(context)</kbd> macro at the top of the class declaration</li>
</ul>
<p>Note that the translation functions should receive the string literals directly. Otherwise, <strong>lupdate</strong> will not be able to understand which text is being translated. The following code is incorrect, because the two strings will not be seen by translators:</p>
<pre>const char* text;
if (condition) {
    text = "translatable1";
} else {
    text = "translatable2";
}
QString result = tr(text); // not recognized!</pre>
<p>The simplest way to fix this issue is to apply the <kbd>tr()</kbd> function directly to each string literal:</p>
<pre>QString result;
if (condition) {
    result = tr("translatable1");
} else {
    result = tr("translatable2");
}</pre>
<p>Another solution is to mark translatable text with the <kbd>QT_TR_NOOP</kbd> macro:</p>
<pre>if (condition) {
    text = QT_TR_NOOP("translatable1");
} else {
    text = QT_TR_NOOP("translatable2");
}
QString result = tr(text);</pre>
<p>The <kbd>QT_TR_NOOP</kbd> macro returns its argument as is, but <strong>lupdate</strong> will recognize that these strings must be translated.</p>
<p>It's also possible to add a comment for the translator using a special form of C++ comments: <kbd>//: ...</kbd> or <kbd>/*: ... */</kbd>. Consider this example:</p>
<pre>//: The button for sending attachment files<br/>QPushButton *button = new QPushButton(tr("Send"));</pre>
<p>In this section, we only described the absolute minimum you need to know before starting work on a multilanguage game. This knowledge can save you a lot of time, because it's much easier to mark some text for translation as you write it than to go through a large code base and do it later. However, you will need to learn more to actually implement internationalization in your project. We will cover this topic in depth later (<em>Online</em> c<em>hapter, </em><a href="https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf" target="_blank">https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf</a>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using arguments in strings</h1>
                
            
            
                
<p>A common task is to have a string that needs to be dynamic in such a way that its content depends on the value of some external variable—for instance, you would like to inform the user about the number of files being copied, showing "copying file 1 of 2" or "copying file 2 of 5" depending on the value of counters that denote the current file and the total number of files. It might be tempting to do this by assembling all the pieces together using one of the available approaches:</p>
<pre>QString str = "Copying file " + QString::number(current)
            + " of " + QString::number(total);</pre>
<p>There are a number of drawbacks to such an approach; the biggest one is the problem of translating the string into other languages, wherein different languages their grammar might require the two arguments to be positioned differently than in English.</p>
<p>Instead, Qt allows us to specify positional parameters in strings and then replace them with real values. This approach is called <strong>string interpolation</strong>. Positions in the string are marked with the <kbd>%</kbd> sign (for example, <kbd>%1</kbd>, <kbd>%2</kbd>, and so on) and they are replaced by making a call to <kbd>arg()</kbd> and passing it the value that is used to replace the next lowest marker in the string. Our file copy message construction code then becomes this:</p>
<pre>QString str = tr("Copying file %1 of %2").arg(current).arg(total); </pre>
<p>Contrary to the behavior of the <kbd>printf()</kbd> built-in function, you don't need to specify the types of values in the placeholders (like <kbd>%d</kbd> or <kbd>%s</kbd>). Instead, the <kbd>arg()</kbd> method has a number of overloads that accept single characters, strings, integers, and real numbers. The <kbd>arg()</kbd> method has the same optional arguments that <kbd>QString::number()</kbd> has, allowing you to configure how numbers are formatted. Additionally, the <kbd>arg()</kbd> method has the <kbd>fieldWidth</kbd> argument that forces it to always output the string of a specified length, which is convenient for formatting tables:</p>
<pre>const int fieldWidth = 4;
qDebug() &lt;&lt; QStringLiteral("%1 | %2").arg(5, fieldWidth).arg(6, fieldWidth);
qDebug() &lt;&lt; QStringLiteral("%1 | %2").arg(15, fieldWidth).arg(16, fieldWidth);
// output:
// "   5 |    6"
// "  15 |   16"</pre>
<p>If you want to use a character other than space to fill empty spaces, use the <kbd>fillChar</kbd> optional argument of <kbd>arg()</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Regular expressions</h1>
                
            
            
                
<p>Let's briefly talk about <strong>regular expressions</strong>—usually shortened as "regex" or "regexp". You will need these regular expressions whenever you have to check whether a string or part of it matches a given pattern or when you want to find specific parts inside the text and possibly want to extract them. Both the validity check and the finding/extraction are based on the so-called pattern of the regular expression, which describes the format a string must have to be valid, to be found, or to be extracted. Since this book is focused on Qt, there is unfortunately no time to cover regular expressions in depth. This is not a huge problem, however, since you can find plenty of good websites that provide introductions to regular expressions on the internet.</p>
<p>Even though there are many flavors of the regular expression's syntax, the one that Perl uses has become the <em>de facto</em> standard. In Qt, the <kbd>QRegularExpression</kbd> class provides Perl-compatible regular expressions.</p>
<div><kbd>QRegularExpression</kbd> was first introduced with Qt 5.0. In the previous versions, the only regular exception class was <kbd>QRegExp</kbd>, and it's still available for compatibility. Since <kbd>QRegularExpression</kbd> is closer to the Perl standard and since its execution speed is much faster as compared to <kbd>QRegExp</kbd>, we advise you to use <kbd>QRegularExpression</kbd> whenever possible. Nevertheless, you can read the <kbd>QRegExp</kbd> documentation, which contains a nice general introduction of regular expressions.</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – A simple quiz game</h1>
                
            
            
                
<p>To introduce you to the main usage of <kbd>QRegularExpression</kbd>, let's imagine this game: a photo, showing an object, is shown to multiple players, and each of them has to estimate the object's weight. The player whose estimate is closest to the actual weight wins. The estimates will be submitted via <kbd>QLineEdit</kbd>. Since you can write anything in a line edit, we have to ensure that the content is valid.</p>
<p>So what does valid mean? In this example, we define that a value between 1g and 999kg is valid. Knowing this specification, we can construct a regular expression that will verify the format. The first part of the text is a number, which can be between 1 and 999. Thus, the corresponding pattern looks like <kbd>[1-9]\d{0,2}</kbd>, where <kbd>[1-9]</kbd> allows—and demands—exactly one digit, except zero. It's optionally followed by up to two digits, including zero. This is expressed through <kbd>\d{0,2}</kbd>, where <kbd>\d</kbd> means "any digit", 0 is the minimal allowed count, and 2 is the maximal allowed count. The last part of the input is the weight's unit. With a pattern such as <kbd>(mg|g|kg)</kbd>, we allow the weight to be input in milligrams (<kbd>mg</kbd>), grams (<kbd>g</kbd>), or kilograms (<kbd>kg</kbd>). With <kbd>\s*</kbd>, we finally allow an arbitrary number of whitespace characters between the number and unit. Let's combine it all together and test our regular expression right away:</p>
<pre>QRegularExpression regex("[1-9]\\d{0,2}\\s*(mg|g|kg)");
regex.setPatternOptions(QRegularExpression::CaseInsensitiveOption);
qDebug() &lt;&lt; regex.match("100 kg").hasMatch();       // true
qDebug() &lt;&lt; regex.match("I don't know").hasMatch(); // false</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>In the first line, we constructed the aforementioned <kbd>QRegularExpression</kbd> object, while passing the regular expression's pattern as a parameter to the constructor. Note that we have to escape the <kbd>\</kbd> character, because it has special meaning in C++ syntax.</p>
<p>Regular expressions are case-sensitive by default. However, we want to allow the input to be in uppercase or mixed case. To achieve this, we can, of course, write <kbd>(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)</kbd> or convert the string to lowercase before matching, but there is a much cleaner and more readable solution. On the second line of the code example, you see the answer—a pattern option. We used <kbd>setPatternOptions()</kbd> to set the <kbd>QRegularExpression::CaseInsensitiveOption</kbd> option, which does not respect the case of the characters used. Of course, there are a few more options that you can read about in Qt's documentation on <kbd>QRegularExpression::PatternOption</kbd>. Instead of calling <kbd>setPatternOptions()</kbd>, we could also have passed the option as a second parameter to the constructor of <kbd>QRegularExpression</kbd>:</p>
<pre>QRegularExpression regex("[1-9]\\d{0,2}\\s*(mg|g|kg)",
     QRegularExpression::CaseInsensitiveOption); </pre>
<p>When we need to test an input, all we have to do is call <kbd>match()</kbd>, passing the string we would like to check against it. In return, we get an object of the <kbd>QRegularExpressionMatch</kbd> type that contains all the information that is further needed—and not only to check the validity. With <kbd>QRegularExpressionMatch::hasMatch()</kbd>, we then can determine whether the input matches our criteria, as it returns <kbd>true</kbd> if the pattern could be found. Otherwise, of course, <kbd>false</kbd> is returned.</p>
<p>Our pattern is not quite finished. The <kbd>hasMatch()</kbd> method would also return <kbd>true</kbd> if we matched it against "foo 142g bar". So, we have to define that the pattern is checked from the beginning to the end of the matched string. This is done by the <kbd>\A</kbd> and <kbd>\z</kbd> anchors. The former marks the start of a string and the latter the end of a string. Don't forget to escape the slashes when you use such anchors. The correct pattern will then look like this:</p>
<pre>QRegularExpression regex("\\A[1-9]\\d{0,2}\\s*(mg|g|kg)\\z",
    QRegularExpression::CaseInsensitiveOption); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Extracting information out of a string</h1>
                
            
            
                
<p>After we have checked that the sent guess is well formed, we have to extract the actual weight from the string. In order to be able to easily compare the different guesses, we further need to transform all values to a common reference unit. In this case, it should be a milligram, the lowest unit. So, let's see what <kbd>QRegularExpressionMatch</kbd> can offer us for this task.</p>
<p>With <kbd>capturedTexts()</kbd>, we get a string list of the pattern's captured groups. In our example, this list will contain "23kg" and "kg". The first element is always the string that was fully matched by the pattern. The next elements are all the substrings captured by the used brackets. Since we are missing the actual number, we have to alter the pattern's beginning to <kbd>([1-9]\d{0,2})</kbd>. Now, the list's second element is the number, and the third element is the unit. Thus, we can write the following:</p>
<pre>int getWeight(const QString &amp;input) {
    QRegularExpression regex("\\A([1-9]\\d{0,2})\\s*(mg|g|kg)\\z");
    regex.setPatternOptions(QRegularExpression::CaseInsensitiveOption);
    QRegularExpressionMatch match = regex.match(input);
    if(match.hasMatch()) {
        <strong>const QString number = match.captured(1);</strong>
        int weight = number.toInt();
        <strong>const QString unit = match.captured(2).toLower();</strong>
        if (unit == "g") {
            weight *= 1000;
        } else if (unit == "kg") {
            weight *= 1000000 ;
        }
        return weight;
    } else {
        return -1;
    }
}</pre>
<p>In the function's first two lines, we set up the pattern and its option. Then, we match it against the passed argument. If <kbd>QRegularExpressionMatch::hasMatch()</kbd> returns <kbd>true</kbd>, the input is valid and we extract the number and unit. Instead of fetching the entire list of captured text with <kbd>capturedTexts()</kbd>, we query specific elements directly by calling <kbd>QRegularExpressionMatch::captured()</kbd>. The passed integer argument signifies the element's position inside the list. So, calling <kbd>captured(1)</kbd> returns the matched digits as a <kbd>QString</kbd>.</p>
<p>Be aware that adding a group at a later time will shift the indices of all the following groups by 1, and you will have to adjust your code! If you have long patterns or if there is a high probability that further brackets will be added in future, you can use <strong>named groups</strong> to make your code more maintainable. There is a  <kbd>QRegularExpressionMatch::captured()</kbd> overload that allows you to specify the group name instead of index. For example, if you have written <kbd>(?&lt;number&gt;[1-9][0-9]{0,2})</kbd>, then you can get the digits by calling <kbd>match.captured("number")</kbd>.</p>
<p>To be able to calculate using the extracted number, we need to convert <kbd>QString</kbd> into an integer. This is done by calling <kbd>QString::toInt()</kbd>. The result of this conversion is then stored in the <kbd>weight</kbd> variable. Next, we fetch the unit and transform it to lowercase characters on the fly. This way, we can, for example, easily determine whether the user's guess is expressed in grams by checking the unit against the lowercase "g". We do not need to take care of the capital "G" or the variants "KG", "Kg", and the unusual "kG" for kilogram.</p>
<p>To get the standardized weight in milligrams, we multiply <kbd>weight</kbd> by 1,000 or 1,000,000, depending on whether this was expressed in g or kg. Lastly, we return this standardized weight. If the string wasn't well formed, we return <kbd>-1</kbd> to indicate that the given guess was invalid. It is then the caller's duty to determinate which player's guess was the best.</p>
<p>Pay attention to whether your chosen integer type can handle the weight's value. For our example, 999 million is the biggest possible result, and, fortunately, it's smaller than the maximum possible value of a signed 32-bit integer (2,147,483,647). If you're unsure whether the type you use is big enough on all target systems, use a fixed width integer type (for example, <kbd>int64_t</kbd>).</p>
<p>As an exercise, try to extend the example by allowing decimal numbers so that "23.5g" is a valid guess. To achieve this, you have to alter the pattern in order to enter decimal numbers, and you also have to deal with <kbd>double</kbd> instead of <kbd>int</kbd> for the standardized weight.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Finding all pattern occurrences</h1>
                
            
            
                
<p>Lastly, let's take a final look at how to find, for example, all numbers inside a string, even those leading with zeros:</p>
<pre>QString input = QStringLiteral("123 foo 09 1a 3");
QRegularExpression regex("\\b\\d+\\b");
QRegularExpressionMatchIterator i = regex.globalMatch(input);
while (i.hasNext()) {
    QRegularExpressionMatch match = i.next();
    qDebug() &lt;&lt; match.captured();
}</pre>
<p>The <kbd>input</kbd> string contains an exemplary text in which we would like to find all numbers. The "foo" as well as "1a" variables should not be found by the pattern, since these are not valid numbers. Therefore, we set up the pattern, defining that we require at least one digit, <kbd>\d+</kbd>, and that this digit—or these digits—should be wrapped by word boundaries, <kbd>\b</kbd>. Note that you have to escape the slashes. With this pattern, we initiate the <kbd>QRegularExpression</kbd> object and call <kbd>globalMatch()</kbd> on it. Inside the passed argument, the pattern will be searched. This time, we do not get <kbd>QRegularExpressionMatch</kbd> back; instead, we get an iterator of the <kbd>QRegularExpressionMatchIterator</kbd> type. Since <kbd>QRegularExpressionMatchIterator</kbd> has a convenient <kbd>hasNext()</kbd> method, we check whether there is a further match and if so, we bring up the next match by calling <kbd>next()</kbd>. The type of the returned match is then <kbd>QRegularExpressionMatch</kbd>, which you already know.</p>
<p>If you need to know about the next match inside the <kbd>while</kbd> loop, you can use <kbd>QRegularExpressionMatchIterator::peekNext()</kbd> to receive it. The benefit of this function is that it does not move the iterator.</p>
<p>This way, you can iterate all pattern occurrences in the string. This is helpful if you, for example, want to highlight a search string in text.</p>
<p>Our example will give the output of <kbd>"123"</kbd>, <kbd>"09"</kbd>, and <kbd>"3"</kbd>.</p>
<p>Taking into account that this was just a brief introduction to regular expressions, we would like to encourage you to read the Detailed Description section in the documentation to <kbd>QRegularExpression</kbd>, <kbd>QRegularExpressionMatch</kbd>, and <kbd>QRegularExpressionMatchIterator</kbd>. Regular expressions are very powerful and useful, so, in your daily programming life, you can benefit from the profound knowledge of regular expressions!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Containers</h1>
                
            
            
                
<p>When you need to store a collection of objects, you need a container to hold them. The C++ standard library provides many powerful containers, such as <kbd>std::vector</kbd>, <kbd>std::list</kbd>, or <kbd>std::map</kbd>. However, Qt doesn't use these containers (actually, it hardly uses any standard library classes at all) and provides its own alternative implementation of containers instead. When Qt containers were introduced, they provided significantly more consistent performance on different platforms compared to standard library implementations, so they were required to create reliable cross-platform applications. This is not really the case now, as STL implementations and compilers have since evolved and gained new optimizations and features. However, there are still reasons to use Qt containers, especially in an application that heavily uses other Qt classes:</p>
<ul>
<li>Qt API always uses Qt containers. When you receive a <kbd>QList</kbd>, it will almost never be more efficient or convenient to convert it to a standard library container. Before calling a method that accepts <kbd>QList</kbd>, you should populate the input data in a <kbd>QList</kbd> instead of converting it from an STL container.</li>
<li>Qt containers provide unique features, like implicit sharing (we will discuss it later in this chapter) or Java-style iterators, and some convenience methods STL containers lack.</li>
<li>Qt containers follow Qt's naming scheme and its API conventions, so they look more natural in an application that is centered around Qt. For example, <kbd>QVector::isEmpty()</kbd> is more Qt-like than <kbd>std::vector::empty()</kbd>.</li>
</ul>
<p>In addition, Qt containers provide STL-compatible API (for example, the <kbd>append()</kbd> method has the <kbd>push_back()</kbd> alias) that allows us to replace Qt containers with STL ones without changing much of the code. Range based <kbd>for</kbd> loop and some of the standard library algorithms are also compatible with Qt containers. That being said, if you need some features that are not available in Qt containers, using STL containers is a good idea.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Main container types</h1>
                
            
            
                
<p>When you interact with a Qt API method, you don't have much choice on the container type, because you need to use the container the method uses. However, generally, you are free to choose containers to store your data. Let's go through the main Qt containers and learn when to use them.</p>
<p>We will only give a brief overview of Qt containers and won't go into details such as the algorithmic complexity of different operations. For most Qt containers, there is a similar STL container that we will name. The topic of choosing the right container is widely discussed, and it's not hard to find more information on it, especially for STL containers. You can also find more information on the Container Classes Qt documentation page.</p>
<p><kbd>QVector</kbd> stores items in a continuous region of memory. The items are densely packed, meaning that this type is the most memory efficient and cache friendly. Its STL equivalent is <kbd>std::vector</kbd>. <kbd>QVector</kbd> should be the container of default choice, meaning that you should only use a different container if you have a reason to do it. <kbd>QVector</kbd> provides fast lookup by item number, fast on average appending items to the end and removing items from the end. Inserting and removing items from the beginning or middle of the vector is slow, because it causes all items to the right to shift in memory. Using <kbd>QVector</kbd> is straightforward:</p>
<pre>QVector&lt;int&gt; numbers;
numbers.append(1);
numbers.append(5);
numbers.append(7);
qDebug() &lt;&lt; numbers.count(); // 3
qDebug() &lt;&lt; numbers[1];      // 5</pre>
<p>The <kbd>QLinkedList</kbd> container, as the name implies, implements a linked list. Its STL equivalent is <kbd>std::list</kbd>. As opposed to <kbd>QVector</kbd>, it provides fast inserting and removing items at any location (the beginning, middle, or the end), but slow lookup by index, because it needs to iterate over items from the beginning to find the item by its index. <kbd>QLinkedList</kbd> is suitable when you need to insert or remove items at the middle of a huge list multiple times. However, note that in practice, <kbd>QVector</kbd> still may sometimes be more performant in this case, because <kbd>QLinkedList</kbd> is not densely packed in memory, which adds some overhead.</p>
<p><kbd>QSet</kbd>, a Qt equivalent of <kbd>std::unordered_set</kbd>, is an unordered collection of unique items. Its advantage is the ability to efficiently add items, remove items, and check whether a particular item is present in a collection. The other list classes are not able to do the last operation quickly, because they need to iterate over all items and compare each item with the argument. Like with any other collection, you can iterate over the set's items, but the iteration order is not specified, that is, any item may appear on the first iteration, and so on. An example of the <kbd>QSet</kbd> API is shown in the following code:</p>
<pre>QSet&lt;QString&gt; names;
names.insert("Alice");
names.insert("Bob");
qDebug() &lt;&lt; names.contains("Alice"); // true
qDebug() &lt;&lt; names.contains("John"); // false
for(const QString &amp;name: names) {
    qDebug() &lt;&lt; "Hello," &lt;&lt; name;
}</pre>
<p>The last flat collection is <kbd>QList</kbd>. Using it is currently not recommended, except when interacting with methods that accept or produce <kbd>QList</kbd> objects. Its performance and memory efficiency depends on the item type, and the rules that define "good" item types are complicated. For a "bad" type, <kbd>QList</kbd> is represented as a vector of <kbd>void *</kbd>, with each item stored as a separately allocated object on the heap. It's possible that <kbd>QList</kbd> implementation will change in Qt 6, but there is no official information about this yet.</p>
<p>There are some specialized list containers that provide extra functionality for a particular item type:</p>
<ul>
<li>The already familiar <kbd>QString</kbd> class is essentially a vector of <kbd>QChar</kbd> (16-bit Unicode characters)</li>
<li>The familiar <kbd>QByteArray</kbd> is a vector of <kbd>char</kbd></li>
<li><kbd>QStringList</kbd> is a <kbd>QList&lt;QString&gt;</kbd> with additional convenient operations</li>
<li><kbd>QBitArray</kbd> provides a memory-efficient array of bits with some useful APIs</li>
</ul>
<p>Next, there are two main key-value collections: <kbd>QMap&lt;K, T&gt;</kbd> and <kbd>QHash&lt;K, T&gt;</kbd>. They allow you to associate a value (or multiple values) of type <kbd>T</kbd> with a key of type <kbd>K</kbd>. They both provide relatively fast lookup by key. When iterating over a <kbd>QMap</kbd> (similar to <kbd>std::map</kbd>), the items are sorted by keys, regardless of the insertion order:</p>
<pre>QMap&lt;int, QString&gt; map;
map[3] = "three";
map[1] = "one";
map[2] = "two";
for(auto i = map.begin(); i != map.end(); ++i) {
    qDebug() &lt;&lt; i.key() &lt;&lt; i.value();
}
// output:
// 1 "one"
// 2 "two"
// 3 "three"</pre>
<p><kbd>QHash</kbd> (similar to <kbd>std::unordered_map</kbd>) has very similar APIs to <kbd>QMap</kbd>, but will iterate over items in unspecified order, like <kbd>QSet</kbd>. You can replace <kbd>QMap</kbd> with <kbd>QHash</kbd> in the previous example and see that the iteration order will change even when running the same program repeatedly. In exchange, <kbd>QHash</kbd> provides faster on-average insertions and lookups by key than <kbd>QMap</kbd>. You should use <kbd>QHash</kbd> instead of <kbd>QMap</kbd> if the iteration order doesn't matter to you.</p>
<p>An attentive reader may wonder how the code that looks very deterministic can produce random results. This randomness was intentionally introduced to protect against <em>algorithmic complexity attacks</em> on <kbd>QHash</kbd> and <kbd>QSet</kbd>. You can read the corresponding section of the <kbd>QHash</kbd> documentation page for more details about the attack and ways to configure the randomization.</p>
<p>Finally, <kbd>QPair&lt;T1, T2&gt;</kbd> is a simple class that can hold two values of different types, just like <kbd>std::pair</kbd>. You can use the <kbd>qMakePair()</kbd> function to make a pair out of two values.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Convenience containers</h1>
                
            
            
                
<p>In addition to the containers described earlier, there are a few containers built on top of them that provide APIs and behavior that are more convenient in some special cases:</p>
<p> </p>
<table>
<tbody>
<tr>
<td><strong>Container</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>QStack</kbd></td>
<td>A <kbd>QVector</kbd> implementing the <strong>last in, first out</strong> (<strong>LIFO</strong>) structure. It contains the <kbd>push()</kbd> function for adding items to the stack, the <kbd>pop()</kbd> function for removing the top element, and the <kbd>top()</kbd> function for reading the top element without removing it.</td>
</tr>
<tr>
<td><kbd>QQueue</kbd></td>
<td>A <kbd>QList</kbd> implementing the <strong>first in, first out</strong> (<strong>FIFO</strong>) structure. Use <kbd>enqueue()</kbd> to append an item to the queue, <kbd>dequeue()</kbd> to take the head item from the queue, and <kbd>head()</kbd> to read the head item without removing it.</td>
</tr>
<tr>
<td><kbd>QMultiMap</kbd></td>
<td>A <kbd>QMap</kbd> with an API tailored for having multiple values for one key. <kbd>QMap</kbd> already allows us to do it; for example, you can add multiple items with one key using the <kbd>QMap::insertMulti()</kbd> method. However, <kbd>QMultiMap</kbd> renames it to <kbd>insert()</kbd> and hides the original <kbd>QMap::insert()</kbd> method that doesn't allow multiple values per key.</td>
</tr>
<tr>
<td><kbd>QMultiHash</kbd></td>
<td>Similar to <kbd>QMultiMap</kbd>, it's a <kbd>QHash</kbd> with a more convenient API for storing multiple values per key.</td>
</tr>
<tr>
<td><kbd>QCache</kbd></td>
<td>A key-value storage similar to <kbd>QHash</kbd> that allows you to implement a cache. <kbd>QCache</kbd> will delete its elements when they weren't recently used to keep the size of cache under the maximum allowed size. Since there is no way to know how much space an arbitrary item actually consumes, you can manually specify a <em>cost</em> for each item and the maximum total cost for a particular <kbd>QCache</kbd> object.</td>
</tr>
<tr>
<td><kbd>QContiguousCache</kbd></td>
<td>A flat container that allows you to cache a sublist of a large list. This is useful, for example, when implementing a viewer for a large table, where reads and writes are likely to happen near the current scroll location.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It's a good idea to use one of these classes when your task matches their use case.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Allowed item types</h1>
                
            
            
                
<p>Not all types can be put in containers. All containers can only hold types that provide a default constructor, a copy constructor, and an assignment operator. All primitive types and most Qt data types (such as <kbd>QString</kbd> or <kbd>QPointF</kbd>) satisfy these requirements. Simple structs also can be stored in a container because the required constructors and operators are generated for them automatically, as per C++ standard.</p>
<p>A particular type usually cannot be put in a container because it doesn't have a constructor without arguments or copying this type was deliberately disabled. This is actually the case for <kbd>QObject</kbd> and all its descendants. The usage patterns of <kbd>QObject</kbd> suggest that you usually want to store pointers to a <kbd>QObject</kbd> to refer to it later. If that object was moved to a container or moved within a container, the pointer would be invalidated, so there is no copy constructor for these types. However, you can put pointers to <kbd>QObject</kbd> in containers (for example, <kbd>QVector&lt;QObject *&gt;</kbd>) because a pointer is a primitive type that satisfies all requirements. In this case, you have to manually ensure that your container will not contain any dangling pointers after the objects are deleted.</p>
<p>The preceding restrictions apply to items of lists and <em>values</em> of key-value collections, but what about their keys? It turns out that the key types have more restrictions that depend on the collection type.</p>
<p><kbd>QMap&lt;K, T&gt;</kbd> additionally requires that the key type <kbd>K</kbd> has the comparison operator <kbd>operator&lt;</kbd> that provides a <em>total order</em> (that is, satisfies a particular set of axioms). As an exception, pointer types are also allowed as a key type.</p>
<p><kbd>QHash&lt;K, T&gt;</kbd> and <kbd>QSet&lt;K&gt;</kbd> require that the <kbd>K</kbd> type has <kbd>operator==</kbd>, and a <kbd>qHash(K key)</kbd> function overload exists. Qt provides these overloads for a large number of types for which it's possible, and you can create an overload for your custom type if needed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Implicit sharing</h1>
                
            
            
                
<p>One of the most significant differences between standard library containers and Qt's is the implicit sharing feature. In STL, creating a copy of a container immediately results in a memory allocation and copying the data buffer:</p>
<pre>std::vector&lt;int&gt; x { 1, 2, 3};
std::vector&lt;int&gt; y = x; // full copy</pre>
<p>If you don't intend to edit the copy, this is essentially a waste of resources, and you want to avoid it. This can be easily done in some cases by providing a reference (<kbd>const std::vector&lt;int&gt; &amp;</kbd>) instead of making a copy. However, sometimes it becomes hard to ensure that the reference will be valid long enough, for example, if you want to store it in a class field. An alternative way to solve this task is to wrap a vector in a <kbd>shared_ptr</kbd> to explicitly share it between multiple objects. This becomes unnecessary when you work with Qt containers and some other Qt types.</p>
<p>In Qt, all main container types implement <strong>implicit sharing</strong> or <strong>copy-on-write</strong> semantics. Copying a <kbd>QVector</kbd> will not result in a new memory allocation until either of the two vectors is changed:</p>
<pre>QVector&lt;int&gt; x { 1, 2, 3};
QVector&lt;int&gt; y = x;
// x and y share one buffer now
y[0] = 5; // new allocation happens here
// x and y have different buffers now</pre>
<p>As long as no edits are made to the copy or the original object, the copying is very cheap. This allows you to cheaply and easily share constant data between objects without cluttering the code with manual management of shared objects. This feature is also implemented for <kbd>QString</kbd>, <kbd>QPen</kbd>, and many other Qt value types. Any copy operation still has some runtime overhead caused by reference counting, so you are encouraged to pass references instead of making copies when it's easy. However, this overhead is insignificant in most cases, except places with heavy computations.</p>
<p>If you like implicit sharing, you can implement it in your own data types using <kbd>QSharedDataPointer</kbd>. Refer to its documentation for the in-depth instructions.</p>
<p>In most cases, you can just use the containers as if they didn't implement implicit sharing, but there are a few cases where you have to be aware of it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pointer invalidation</h1>
                
            
            
                
<p>First, implicit sharing means that holding any references or pointers to the container's content is disallowed when there is a possibility of changing this object or any object that shares the same buffer. The following small example illustrates the problem:</p>
<pre>// don't do this!
QVector&lt;int&gt; x { 1, 2, 3 };
int *x0 = x.begin();
QVector&lt;int&gt; y = x;
x[0] = 42;
qDebug() &lt;&lt; *x0; // output: 1</pre>
<p>We initialized the <kbd>x0</kbd> variable with the pointer to the first element of the <kbd>x</kbd> vector. However, when we set a new value for that element and then tried to read it using the pointer, we got the old value again.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>As we copied the <kbd>x</kbd> vector to <kbd>y</kbd>, the state of two vectors became shared and the original buffer was available to both of them. However, when we modified <kbd>x</kbd> using <kbd>operator[]</kbd>, it became <strong>detached</strong>, that is, a new buffer was allocated for it, and <kbd>y</kbd> retained the original buffer. The <kbd>x0</kbd> pointer continues to point at the original buffer, which is now only available to <kbd>y</kbd>. If you remove the <kbd>QVector&lt;int&gt; y = x;</kbd> line, the output will change to the expected 42. The general rule is that you should avoid storing pointers or references to the object's content while it's changed or shared with another object.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Unnecessary allocation</h1>
                
            
            
                
<p>The next question is what actions on the object trigger the actual allocation of a new buffer? Obviously, <kbd>x[0] = 42</kbd> will trigger an allocation because the vector needs a buffer to write the new data to. However, <kbd>int i = x[0]</kbd> will also trigger an allocation if <kbd>x</kbd> is not declared as a <kbd>const</kbd> value or reference. That happens because in C++ this code triggers the non-const overload of <kbd>operator[]</kbd> if it's available, even though it's not necessary in this case. The vector doesn't know whether the requested item will or will not be changed, so it has to assume that it will be, and it triggers an allocation before returning a reference to the item in the new buffer.</p>
<p>The same issue takes effect when using other methods that have const and non-const overloads, for example, <kbd>begin()</kbd> or <kbd>data()</kbd>. The range-based <kbd>for</kbd> loop also calls <kbd>begin()</kbd>, so it will also detach if you iterate over a non-const value.</p>
<p>If you explicitly declare the container variable as const (for example, <kbd>const QVector&lt;int&gt; y</kbd> or <kbd>const QVector&lt;int&gt; &amp;y</kbd>), the non-const methods will not be available, and it will not be possible to trigger an allocation using this variable. An alternative solution is to use special method aliases that are only available for const versions, such as <kbd>at()</kbd> for <kbd>operator=</kbd>, <kbd>constBegin()</kbd> for <kbd>begin()</kbd>, and <kbd>constData()</kbd> for <kbd>data()</kbd>. This solution is not usable with range-based <kbd>for</kbd> loop, though.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Range-based for and Qt foreach macro</h1>
                
            
            
                
<p>Qt provides the <kbd>foreach</kbd> macro for iterating over Qt containers:</p>
<pre>QVector&lt;int&gt; x { 1, 2, 3 };
foreach(const int i, x) {
    qDebug() &lt;&lt; i;
}</pre>
<p>This macro was available long before the range-based <kbd>for</kbd> loop made it into the C++ standard, so it's still very common in Qt code, and you should be familiar with it. The <kbd>foreach</kbd> loop always creates a temporary constant copy of the iterated object. Since it uses implicit sharing, this is very cheap. If you edit <kbd>x</kbd> while iterating over it, the changes will not affect the values of <kbd>i</kbd> because the iteration uses a copy, but this also means that such an operation is safe. Note that when using range-based <kbd>for</kbd> loop, STL-style iterators, or Java-style iterators, editing the same container you're iterating over is generally not safe. For example, changing item values may be permitted, but deleting an item may result in undefined behavior.</p>
<p>We discussed how range-based <kbd>for</kbd> loop can cause a deep copy of the containers. The <kbd>foreach</kbd> macro by itself will never cause a deep copy. However, if you edit the container while iterating over it, this will result in a deep copy, because two versions of data have to be stored somewhere.</p>
<p>When using the range-based <kbd>for</kbd> loop, you should be careful not to pass a reference to a temporary object. For example, this code looks legitimate, but it results in undefined behavior:</p>
<pre>// don't do this!
for(QChar c: QString("abc").replace('a', 'z')) {
    qDebug() &lt;&lt; c;
}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We created a temporary <kbd>QString</kbd> object and called its <kbd>replace()</kbd> method. This method' s return type is <kbd>QString &amp;</kbd>, so it doesn't own the string's data. If we immediately assigned this value to an owning variable, it would be correct because the life of the original temporary <kbd>QString</kbd> lasts until the end of the full expression (in this case, the assignment):</p>
<pre>QString string = QString("abc").replace('a', 'z');
for(QChar c: string) { // correct
    qDebug() &lt;&lt; c;
}</pre>
<p>However, the temporary object in the original example doesn't live until the end of the <kbd>for</kbd> loop, so this will result in a use-after-free bug. The <kbd>foreach</kbd> version of this code would contain an implicit assignment to a variable, so it would be correct.</p>
<p>On the other hand, the macro nature of <kbd>foreach</kbd> is its disadvantage. For example, the following code does not compile because the item type contains a comma:</p>
<pre>QVector&lt;QPair&lt;int, int&gt;&gt; x;
foreach(const QPair&lt;int, int&gt;&amp; i, x) {
    //...
}</pre>
<p>The error is "macro <kbd>Q_FOREACH</kbd> passed 3 arguments, but takes just 2". To fix this issue, you have to create a <kbd>typedef</kbd> for the item type.</p>
<p>Since C++11, range-based <kbd>for</kbd> loop is a native, clean alternative to <kbd>foreach</kbd>, so we suggest that you prefer the native construct over the macro, but keep in mind the pitfalls we described.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data storage</h1>
                
            
            
                
<p>When implementing games, you will often have to work with persistent data; you will need to store the saved game data, load maps, and so on. For that, you have to learn about the mechanisms that let you use the data stored on digital media.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Files and devices</h1>
                
            
            
                
<p>The most basic and low-level mechanism that is used to access data is to save and load it from the files. While you can use the classic file access approaches provided by C and C++, such as <kbd>stdio</kbd> or <kbd>iostream</kbd>, Qt provides its own file abstraction that hides platform-dependent details and provides a clean API that works across all platforms in a uniform manner.</p>
<p>The two basic classes that you will work with when using files are <kbd>QDir</kbd> and <kbd>QFile</kbd>. The former represents the contents of a directory, lets you traverse filesystems, creates and remove directories, and finally, accesses all files in a particular directory.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Traversing directories</h1>
                
            
            
                
<p>Traversing directories with <kbd>QDir</kbd> is really easy. The first thing to do is to have an instance of <kbd>QDir</kbd> in the first place. The easiest way to do this is to pass the directory path to the <kbd>QDir</kbd> constructor.</p>
<div><p>Qt handles file paths in a platform-independent way. Even though the regular directory separator on Windows is a backward slash character (<kbd>\</kbd>) and on other platforms it is the forward slash (<kbd>/</kbd>), Qt internally always uses the forward slash, and paths returned by most Qt methods never contain backward slashes. You can always use forward slashes when passing paths to Qt methods, even on Windows. If you need to convert the Qt's path representation to the native form (for example, for passing it to the standard library or a third-party library), you can use <kbd>QDir::toNativeSeparators()</kbd>. <kbd>QDir::fromNativeSeparators()</kbd>  to perform the inverse operation.</p>
</div>
<p>Qt provides a number of static methods to access some special directories. The following table lists these special directories and functions that access them:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Access function</strong></td>
<td><strong>Directory</strong></td>
</tr>
<tr>
<td>
<p><kbd>QDir::current()</kbd></p>
</td>
<td>
<p>The current working directory</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::home()</kbd></p>
</td>
<td>
<p>The home directory of the current user</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::root()</kbd></p>
</td>
<td>
<p>The root directory—usually <kbd>/</kbd> for Unix and <kbd>C:\</kbd> for Windows</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::temp()</kbd></p>
</td>
<td>
<p>The system temporary directory</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>QStandardPaths</kbd> class provides information about other standard locations present in the system. For example, <kbd>QStandardPaths::writableLocation(QStandardPaths::MusicLocation)</kbd> returns path to the user's music folder.</p>
<p>Refer to the <kbd>QStandardPaths::StandardLocation</kbd> enum documentation for the list of available locations.</p>
<p>When you already have a valid <kbd>QDir</kbd> object, you can start moving between directories. To do that, you can use the <kbd>cd()</kbd> and <kbd>cdUp()</kbd> methods. The former moves to the named subdirectory, while the latter moves to the parent directory. You should always check that these commands were successful. If they return <kbd>false</kbd>, your <kbd>QDir</kbd> object will remain in the same directory!</p>
<p>To list files and subdirectories in a particular directory, you can use the <kbd>entryList()</kbd> method, which returns a list of entries in the directory that match the criteria passed to <kbd>entryList()</kbd>. The <kbd>filters</kbd> argument takes a list of flags that correspond to the different attributes that an entry needs to have to be included in the result. The most useful flags are listed in the following table:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Filter</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>
<p><kbd>QDir::Dirs</kbd>, <kbd>QDir::Files</kbd>, <kbd>QDir::Drives</kbd></p>
</td>
<td>
<p>List directories, files, or Windows drives. You should specify at least one of these filters to get any results.</p>
</td>
</tr>
<tr>
<td><kbd>QDir::AllEntries</kbd></td>
<td>List directories, files, and drives. This is a shortcut for <kbd>Dirs | Files | Drives</kbd>.</td>
</tr>
<tr>
<td>
<p><kbd>QDir::AllDirs</kbd></p>
</td>
<td>
<p>List directories even if they don't match the name filters.</p>
</td>
</tr>
<tr>
<td><kbd>QDir::NoDotAndDotDot</kbd></td>
<td>Don't list <kbd>.</kbd> (current directory) and <kbd>..</kbd> (parent directory) entries. If <kbd>Dirs</kbd> flag is present and <kbd>NoDotAndDotDot</kbd> is not, these entries will always be listed.</td>
</tr>
<tr>
<td>
<p><kbd>QDir::Readable</kbd>, <kbd>QDir::Writable</kbd>, <kbd>QDir::Executable</kbd></p>
</td>
<td>
<p>List only entries that can be read, written to, or executed.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::Hidden</kbd>, <kbd>QDir::System</kbd></p>
</td>
<td>
<p>List hidden files and system files. If these flags are not specified, hidden and system flags will not be listed.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The <kbd>sort</kbd> argument of <kbd>entryList()</kbd> allows you to choose the ordering of the results:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Flag</strong></td>
<td><strong>Meaning</strong></td>
</tr>
<tr>
<td>
<p><kbd>QDir::Unsorted</kbd></p>
</td>
<td>
<p>The order of entries is undefined. It's a good idea to use it if the order doesn't matter to you, since it may be faster.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::Name</kbd>, <kbd>QDir::Time</kbd>, <kbd>QDir::Size</kbd>, <kbd>QDir::Type</kbd></p>
</td>
<td>
<p>Sort by appropriate entry attributes.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::DirsFirst</kbd>, <kbd>QDir::DirsLast</kbd></p>
</td>
<td>
<p>Determines whether directories should be listed before or after files. If neither flag is specified, directories will be mixed with files in the output.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>QDir::Reversed</kbd></p>
</td>
<td>
<p>Reverses the order.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Additionally, there is an overload of <kbd>entryList()</kbd> that accepts a list of file name patterns in the form of <kbd>QStringList</kbd> as its first parameter. Here's an example call that returns all JPEG files in the directory sorted by size:</p>
<pre>QStringList nameFilters = { QStringLiteral("*.jpg"), QStringLiteral("*.jpeg") };
QStringList entries = dir.entryList(nameFilters,
    QDir::Files | QDir::Readable, QDir::Size);</pre>
<p>Besides <kbd>entryList()</kbd>, there is the <kbd>entryInfoList()</kbd> method that wraps each returned file name in a <kbd>QFileInfo</kbd> object that has many convenient functions. For example, <kbd>QFileInfo::absoluteFilePath()</kbd> returns the absolute path to the file, and <kbd>QFileInfo::suffix()</kbd> returns the extension of the file.</p>
<p>If you need to traverse directories recursively (for example, for finding all files in all subdirectories), you can use the <kbd>QDirIterator</kbd> class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading and writing files</h1>
                
            
            
                
<p>Once you know the path to a file (for example, using <kbd>QDir::entryList()</kbd>, <kbd>QFileDialog::getOpenFileName()</kbd>, or some external source), you can pass it to <kbd>QFile</kbd> to receive an object that acts as a handle to the file. Before the file contents can be accessed, the file needs to be opened using the <kbd>open()</kbd> method. The basic variant of this method takes a mode in which we need to open the file. The following table explains the modes that are available:</p>
<table class="table">
<tbody>
<tr>
<td><strong>Mode</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><kbd>ReadOnly</kbd></p>
</td>
<td>
<p>This file can be read from.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>WriteOnly</kbd></p>
</td>
<td>
<p>This file can be written to.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ReadWrite</kbd></p>
</td>
<td>
<p>This file can be read from and written to.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Append</kbd></p>
</td>
<td>
<p>All data writes will be written at the end of the file.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Truncate</kbd></p>
</td>
<td>
<p>If the file is present, its content is deleted before we open it.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Text</kbd></p>
</td>
<td>
<p>When reading, all line endings are transformed to <kbd>\n</kbd>. When writing, all <kbd>\n</kbd> symbols are transformed to the native format (for example, <kbd>\r\n</kbd> on Windows or <kbd>\n</kbd> on Linux).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Unbuffered</kbd></p>
</td>
<td>
<p>The flag prevents the file from being buffered.</p>
</td>
</tr>
</tbody>
</table>
<p>The <kbd>open()</kbd> method returns <kbd>true</kbd> or <kbd>false</kbd>, depending on whether the file was opened or not. The current status of the file can be checked by calling <kbd>isOpen()</kbd> on the file object. Once the file is open, it can be read from or written to, depending on the options that are passed when the file is opened. Reading and writing is done using the <kbd>read()</kbd> and <kbd>write()</kbd> methods. These methods have a number of overloads, but we suggest that you focus on using those variants that accept or return the already familiar <kbd>QByteArray</kbd> objects, because they manage the memory automatically. If you are working with plain text, then a useful overload for <kbd>write</kbd> is the one that accepts the text directly as input. Just remember that the text has to be null terminated. When reading from a file, Qt offers a number of other methods that might come in handy in some situations. One of these methods is <kbd>readLine()</kbd>, which tries to read from the file until it encounters a new line character. If you use it along with the <kbd>atEnd()</kbd> method that tells you whether you have reached the end of the file, you can realize the line-by-line reading of a text file:</p>
<pre>QStringList lines;
while(!file.atEnd()) {
    QByteArray line = file.readLine();
    lines.append(QString::fromUtf8(line));
} </pre>
<p>Another useful method is <kbd>readAll()</kbd>, which simply returns the file content, starting from the current position of the file pointer until the end of the file.</p>
<p>You have to remember, though, that when using these helper methods, you should be really careful if you don't know how much data the file contains. It might happen that when reading line by line or trying to read the whole file into memory in one step, you exhaust the amount of memory that is available for your process. If you only intend to work with small files that fit into memory, you can check the size of the file by calling <kbd>size()</kbd> on the <kbd>QFile</kbd> instance and abort if the file is too large. If you need to handle arbitrary files, however, you should process the file's data in steps, reading only a small portion of bytes at a time. This makes the code more complex but allows us to manage the available resources better.</p>
<p>If you require constant access to the file, you can use the <kbd>map()</kbd> and <kbd>unmap()</kbd> calls that add and remove mappings of the parts of a file to a memory address that you can then use like a regular array of bytes:</p>
<pre>QFile f("myfile");
if(!f.open(QFile::ReadWrite)) {
    return;
}
uchar *addr = f.map(0, f.size());
if(!addr) {
    return;
}
f.close();
doSomeComplexOperationOn(addr);</pre>
<p>The mapping will automatically be removed when the <kbd>QFile</kbd> object is destroyed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Devices</h1>
                
            
            
                
<p><kbd>QFile</kbd> is really a descendant class of <kbd>QIODevice</kbd> ("input/output device"), which is a Qt interface used to abstract entities related to reading and writing of blocks of data. There are two types of devices: sequential and random access devices. <kbd>QFile</kbd> belongs to the latter group; it has the concepts of start, end, size, and current position that can be changed by the user with the <kbd>seek()</kbd> method. Sequential devices, such as sockets and pipes, represent streams of data—there is no way to rewind the stream or check its size; you can only keep reading the data sequentially—piece by piece, and you can check how far away you currently are from the end of data. We will work with such devices in <a href="b2ab510e-2a42-4ccb-b121-ab4ce5541893.xhtml">Chapter 7</a>, <em>Networking</em>.</p>
<p>All I/O devices can be opened and closed. They all implement the <kbd>open()</kbd>, <kbd>read()</kbd>, and <kbd>write()</kbd> interfaces. Writing to the device queues the data for writing; when the data is actually written, the <kbd>bytesWritten()</kbd> signal is emitted that carries the amount of data that was written to the device. If more data becomes available in the sequential device, it emits the <kbd>readyRead()</kbd> signal, which informs you that if you call <kbd>read</kbd> now, you can expect to receive some data from the device.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Implementing a device to encrypt data</h1>
                
            
            
                
<p>Let's implement a really simple device that encrypts or decrypts the data that is streamed through it using a very simple algorithm—the Caesar cipher. When encrypting, it shifts each character in the plaintext by a number of characters defined by the key. It does the reverse when decrypting. Thus, if the key is <kbd>2</kbd> and the plaintext character is <kbd>a</kbd>, the ciphertext becomes <kbd>c</kbd>. Decrypting <kbd>z</kbd> with the key <kbd>4</kbd> will yield the value <kbd>v</kbd>.</p>
<p>First, create a new empty project by selecting the Empty qmake Project template from the Other Project category. Next, add a <kbd>main.cpp</kbd> file and a new <kbd>CaesarCipherDevice</kbd> class derived from <kbd>QIODevice</kbd>. The basic interface of the class will accept an integer key and set an underlying device that serves as the source or destination of data. This is all simple coding that you should already understand, so it shouldn't need any extra explanation, as shown:</p>
<pre>class CaesarCipherDevice : public QIODevice
{
    Q_OBJECT
    Q_PROPERTY(int key READ key WRITE setKey)
public:
    explicit CaesarCipherDevice(QObject *parent = 0)
        : QIODevice(parent) {
        m_key = 0;
        m_baseDevice = 0;
    }
    void setBaseDevice(QIODevice *dev) {
        m_baseDevice = dev;
    }
    QIODevice *baseDevice() const {
        return m_baseDevice;
    }
    void setKey(int k) {
        m_key = k;
    }
    inline int key() const {
        return m_key;
    }
private:
    int m_key;
    QIODevice *m_baseDevice;
}; </pre>
<p>The next thing is to ensure that the device cannot be used if there is no device to operate on (that is, when <kbd>m_baseDevice == nullptr</kbd>). For this, we have to reimplement the <kbd>QIODevice::open()</kbd> method and return <kbd>false</kbd> when we want to prevent operating on our device:</p>
<pre>bool CaesarCipherDevice::open(OpenMode mode) {
    if(!m_baseDevice) {
        return false;
    }
    if(!m_baseDevice-&gt;isOpen()) {
        return false;
    }
    if(m_baseDevice-&gt;openMode() != mode) {
        return false;
    }
    return QIODevice::open(mode);
}</pre>
<p>The method accepts the mode that the user wants to open the device with. We perform an additional check to verify that the base device was opened in the same mode before calling the base class implementation that will mark the device as open.</p>
<p>It's a good idea to call <kbd>QIODevice::setErrorString</kbd> to let the user know about an error. Additionally, you can use <kbd>qWarning("message")</kbd> to print a warning to the console when an error occurs.</p>
<p>To have a fully functional device, we still need to implement the two protected pure virtual methods, which do the actual reading and writing. These methods are called by Qt from other methods of the class when needed. Let's start with <kbd>writeData()</kbd>, which accepts a pointer to a buffer containing the data and size equal to that of a buffer:</p>
<pre>qint64 CaesarCipherDevice::writeData(const char *data, qint64 len) {
    QByteArray byteArray;
    byteArray.resize(len);
    for(int i = 0; i &lt; len; ++i) {
        byteArray[i] = data[i] + m_key;
    }
    int written = m_baseDevice-&gt;write(byteArray);
    emit bytesWritten(written);
    return written;
}</pre>
<p>First, we create a local byte array and resize it to the length of the input. Then, we iterate bytes of the input, add the value of the key to each byte (which effectively performs the encryption) and put it in the byte array. Finally, we try to write the byte array to the underlying device. Before informing the caller about the amount of data that was really written, we emit a signal that carries the same information.</p>
<p>The last method we need to implement is the one that performs decryption by reading from the base device and adding the key to each cell of the data. This is done by implementing <kbd>readData()</kbd>, which accepts a pointer to the buffer that the method needs to write to and the size of the buffer.</p>
<p>The code is quite similar to that of <kbd>writeData()</kbd>, except that we are subtracting the key value instead of adding it:</p>
<pre>qint64 CaesarCipherDevice::readData(char *data, qint64 maxlen) {
    QByteArray baseData = m_baseDevice-&gt;read(maxlen);
    const int size = baseData.size();
    for(int i = 0; i &lt; size; ++i) {
        data[i] = baseData[i] - m_key;
    }
    return size;
}</pre>
<p>First, we try to read <kbd>maxlen</kbd> bytes from the underlying device and store the data in a byte array. Note that the byte array can contain fewer bytes than <kbd>maxlen</kbd> (for example, if we reached the end of the file) but it can't contain more. Then, we iterate the array and set subsequent bytes of data buffer to the decrypted value. Finally, we return the amount of data that was really read.</p>
<p>A simple <kbd>main()</kbd> function that can test the class looks as follows:</p>
<pre>int main(int argc, char **argv) {
    QByteArray ba = "plaintext";
    QBuffer buf;
    buf.open(QIODevice::WriteOnly);
    CaesarCipherDevice encrypt;
    encrypt.setKey(3);
    encrypt.setBaseDevice(&amp;buf);
    encrypt.open(buf.openMode());
    encrypt.write(ba);
    qDebug() &lt;&lt; buf.data();

    CaesarCipherDevice decrypt;
    decrypt.setKey(3);
    decrypt.setBaseDevice(&amp;buf);
    buf.open(QIODevice::ReadOnly);
    decrypt.open(buf.openMode());
    qDebug() &lt;&lt; decrypt.readAll();
    return 0;
} </pre>
<p>We use the <kbd>QBuffer</kbd> class that implements the <kbd>QIODevice</kbd> API and acts as an adapter for <kbd>QByteArray</kbd> or <kbd>QString</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We created an encryption object and set its key to <kbd>3</kbd>. We also told it to use a <kbd>QBuffer</kbd> instance to store the processed content. After opening it for writing, we sent some data to it that gets encrypted and written to the base device. Then, we created a similar device, passing the same buffer again as the base device, but now, we open the device for reading. This means that the base device contains ciphertext. After this, we read all data from the device, which results in reading data from the buffer, decrypting it, and returning the data so that it can be written to the debug console.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Have a go hero – A GUI for the Caesar cipher</h1>
                
            
            
                
<p>You can combine what you already know by implementing a full-blown GUI application that is able to encrypt or decrypt files using the Caesar cipher <kbd>QIODevice</kbd> class that we just implemented. Remember that <kbd>QFile</kbd> is also <kbd>QIODevice</kbd>, so you can pass its pointer directly to <kbd>setBaseDevice()</kbd>.</p>
<p>This is just a starting point for you. The <kbd>QIODevice</kbd> API is quite rich and contains numerous methods that are virtual, so you can reimplement them in subclasses.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Text streams</h1>
                
            
            
                
<p>Much of the data produced by computers nowadays is based on text. You can create such files using a mechanism that you already know—opening <kbd>QFile</kbd> to write, converting all data into strings using <kbd>QString::arg()</kbd>, optionally encoding strings using <kbd>QTextCodec</kbd>, and dumping the resulting bytes to the file by calling <kbd>write</kbd>. However, Qt provides a nice mechanism that does most of this automatically for you in a way similar to how the standard C++ <kbd>iostream</kbd> classes work. The <kbd>QTextStream</kbd> class operates on any <kbd>QIODevice</kbd> API in a stream-oriented way. You can send tokens to the stream using the <kbd>&lt;&lt;</kbd> operator, where they get converted into strings, separated by spaces, encoded using a codec of your choice, and written to the underlying device. It also works the other way round; using the <kbd>&gt;&gt;</kbd> operator, you can stream data from a text file, transparently converting it from strings to appropriate variable types. If the conversion fails, you can discover it by inspecting the result of the <kbd>status()</kbd> method—if you get <kbd>ReadPastEnd</kbd> or <kbd>ReadCorruptData</kbd>, it means that the read has failed.</p>
<p>While <kbd>QIODevice</kbd> is the main class that <kbd>QTextStream</kbd> operates on, it can also manipulate <kbd>QString</kbd> or <kbd>QByteArray</kbd>, which makes it useful for us to compose or parse strings.</p>
<p>Using <kbd>QTextStream</kbd> is simple—you just pass a device to its constructor, and you're good to go. The  <kbd>QTextStream</kbd> object will read to or write from that device. By default, <kbd>QTextStream</kbd> uses the encoding specified by the current locale, but if it encounters a UTF-16 or UTF-32 BOM (byte order mark), it will switch to the encoding specified by the BOM. The stream accepts strings and numerical values:</p>
<pre>QFile file("output.txt");
file.open(QFile::WriteOnly | QFile::Text);
QTextStream stream(&amp;file);
stream &lt;&lt; "Today is " &lt;&lt; QDate::currentDate().toString() &lt;&lt; endl;
QTime t = QTime::currentTime();
stream &lt;&lt; "Current time is " &lt;&lt; t.hour() &lt;&lt; " h and " <br/>       &lt;&lt; t.minute() &lt;&lt; "m." &lt;&lt; endl;</pre>
<p>Apart from directing content into the stream, the stream can accept a number of manipulators, such as <kbd>endl</kbd>, which have a direct or indirect influence on how the stream behaves. For instance, you can tell the stream to display a number as decimal and another as hexadecimal with uppercase digits using the following code (highlighted in the code are all manipulators):</p>
<pre>for(int i = 0;i &lt; 10; ++i) {
    int num = qrand() % 100000;  // random number between 0 and 99999
    stream &lt;&lt; dec &lt;&lt; num
           &lt;&lt; showbase &lt;&lt; hex &lt;&lt; uppercasedigits &lt;&lt; num &lt;&lt; endl;
} </pre>
<p>This is not the end of the capabilities of <kbd>QTextStream</kbd>. It also allows us to display data in a tabular manner by defining column widths and alignments. Consider a game player record defined by the following structure:</p>
<pre>struct Player {
    QString name;
    qint64 experience;
    QPoint position;
    char direction;
};</pre>
<p>Suppose you have a set of records for players stored in a <kbd>QVector&lt;Player&gt; players</kbd> variable. Let's dump such information into a file in a tabular manner:</p>
<pre>QFile file("players.txt");
file.open(QFile::WriteOnly | QFile::Text);
QTextStream stream(&amp;file);
stream &lt;&lt; center;
stream &lt;&lt; qSetFieldWidth(16) &lt;&lt; "Player" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; qSetFieldWidth(10) &lt;&lt; "Experience" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; qSetFieldWidth(13) &lt;&lt; "Position" &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
stream &lt;&lt; "Direction" &lt;&lt; endl;

for(const Player &amp;player: players) {
    stream &lt;&lt; left &lt;&lt; qSetFieldWidth(16) &lt;&lt; player.name
           &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
    stream &lt;&lt; right &lt;&lt; qSetFieldWidth(10) &lt;&lt; player.experience
           &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
    stream &lt;&lt; right &lt;&lt; qSetFieldWidth(6) &lt;&lt; player.position.x()
           &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
    stream &lt;&lt; qSetFieldWidth(6) &lt;&lt; player.position.y()
           &lt;&lt; qSetFieldWidth(0) &lt;&lt; " ";
    stream &lt;&lt; center &lt;&lt; qSetFieldWidth(10);

    switch(player.direction) {
    case 'n' : stream &lt;&lt; "north"; break;
    case 's' : stream &lt;&lt; "south"; break;
    case 'e' : stream &lt;&lt; "east"; break;
    case 'w' : stream &lt;&lt; "west"; break;
    default: stream &lt;&lt; "unknown"; break;
    }
    stream &lt;&lt; qSetFieldWidth(0) &lt;&lt; endl;
}</pre>
<p>The program creates a file that should look like this:</p>
<pre>     Player      Experience   Position    Direction
Gondael               46783     10     -5   north   
Olrael               123648     -5    103    east   
Nazaal             99372641     48    634   south   </pre>
<p>One last thing about <kbd>QTextStream</kbd> is that it can operate on standard C file structures, which makes it possible for us to use <kbd>QTextStream</kbd> to, for example, write to <kbd>stdout</kbd> or read from <kbd>stdin</kbd>, as shown in the following code:</p>
<pre>QTextStream stdoutStream(stdout);
stdoutStream &lt;&lt; "This text goes to standard output." &lt;&lt; endl; </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Binary streams</h1>
                
            
            
                
<p>More than often, we have to store object data in a device-independent way so that it can be restored later, possibly on a different machine with a different data layout and so on. In computer science, this is called <strong>serialization</strong>. Qt provides several serialization mechanisms and now we will take a brief look at some of them.</p>
<p>If you look at <kbd>QTextStream</kbd> from a distance, you will note that what it really does is serialize and deserialize data to a text format. Its close cousin is the <kbd>QDataStream</kbd> class that handles serialization and deserialization of arbitrary data to a binary format. It uses a custom data format to store and retrieve data from <kbd>QIODevice</kbd> in a platform-independent way. It stores enough data so that a stream written on one platform can be successfully read on a different platform.</p>
<p><kbd>QDataStream</kbd> is used in a similar fashion as <kbd>QTextStream</kbd>—the <kbd>&lt;&lt;</kbd> and <kbd>&gt;&gt;</kbd> operators are used to redirect data into or out of the stream. The class supports most of the built-in Qt data types so that you can operate on classes such as <kbd>QColor</kbd>, <kbd>QPoint</kbd>, or <kbd>QStringList</kbd> directly:</p>
<pre>QFile file("outfile.dat");
file.open(QFile::WriteOnly | QFile::Truncate);
QDataStream stream(&amp;file);
double dbl = 3.14159265359;
QColor color = Qt::red;
QPoint point(10, -4);
QStringList stringList { "foo", "bar" };
stream &lt;&lt; dbl &lt;&lt; color &lt;&lt; point &lt;&lt; stringList; </pre>
<p>If you want to serialize custom data types, you can teach <kbd>QDataStream</kbd> to do that by implementing proper redirection operators.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Serialization of a custom structure</h1>
                
            
            
                
<p>Let's perform another small exercise by implementing functions that are required to use <kbd>QDataStream</kbd> to serialize the same simple structure that contains the player information that we used for text streaming:</p>
<pre>struct Player {
    QString name;
    qint64 experience;
    QPoint position;
    char direction;
}; </pre>
<p>For this, two functions need to be implemented, both returning a <kbd>QDataStream</kbd> reference that was taken earlier as an argument to the call. Apart from the stream itself, the serialization operator accepts a constant reference to the class that is being saved. The most simple implementation just streams each member into the stream and returns the stream afterward:</p>
<pre>QDataStream&amp; operator&lt;&lt;(QDataStream &amp;stream, const Player &amp;p) {
    stream &lt;&lt; p.name;
    stream &lt;&lt; p.experience;
    stream &lt;&lt; p.position;
    stream &lt;&lt; p.direction;
    return stream;
} </pre>
<p>Complementary to this, deserializing is done by implementing a redirection operator that accepts a mutable reference to the structure that is filled by data that is read from the stream:</p>
<pre>QDataStream&amp; operator&gt;&gt;(QDataStream &amp;stream, Player &amp;p) {
     stream &gt;&gt; p.name;
     stream &gt;&gt; p.experience;
     stream &gt;&gt; p.position;
     stream &gt;&gt; p.direction;
     return stream;
} </pre>
<p>Again, at the end, the stream itself is returned.</p>
<p>Now we can use <kbd>QDataStream</kbd> to write our object to any I/O device (for example, a file, a buffer, or a network socket):</p>
<pre>Player player = /* ... */;<br/>QDataStream stream(device);<br/>stream &lt;&lt; player;</pre>
<p>Reading the object back is just as simple:</p>
<pre>Player player;<br/>QDataStream stream(device);<br/>stream &gt;&gt; player;</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We provided two standalone functions that define redirection operators for the <kbd>Player</kbd> class to and from a <kbd>QDataStream</kbd> instance. This lets your class be serialized and deserialized using mechanisms offered and used by Qt.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">XML streams</h1>
                
            
            
                
<p>XML has become one of the most popular standards that is used to store hierarchical data. Despite its verbosity and difficulty to read by human eye, it is used in virtually any domain where data persistency is required, as it is very easy to read by machines. Qt provides support for reading and writing XML documents in two modules:</p>
<ul>
<li>The Qt Xml module provides access using the <strong>Document Object Model</strong> (<strong>DOM</strong>) standard with classes such as <kbd>QDomDocument</kbd>, <kbd>QDomElement</kbd>, and others</li>
<li>The Qt Core module contains <kbd>QXmlStreamReader</kbd> and <kbd>QXmlStreamWriter</kbd> classes that implement streaming API</li>
</ul>
<p>One of the downsides of <kbd>QDomDocument</kbd> is that it requires us to load the whole XML tree into the memory before parsing it. Additionally, Qt Xml is not actively maintained. Therefore, we will focus on the streaming approach provided by Qt Core.</p>
<p>In some situations, downsides of the DOM approach are compensated for by its ease of use as compared to a streamed approach, so you can consider using it if you feel that you have found the right task for it. If you want to use the DOM access to XML in Qt, remember to enable the <kbd>QtXml</kbd> module in your applications by adding a <kbd>QT += xml</kbd> line in the project configuration file.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Implementing an XML parser for player data</h1>
                
            
            
                
<p>In this exercise, we will create a parser to fill data that represents players and their inventory in an RPG game. First, let's create the types that will hold the data:</p>
<pre>class InventoryItem {
    Q_GADGET
public:
    enum class Type {
        Weapon,
        Armor,
        Gem,
        Book,
        Other
    };
    Q_ENUM(Type)

    Type type;
    QString subType;
    int durability;

    static Type typeByName(const QStringRef &amp;r);
};

class Player {
public:
    QString name;
    QString password;
    int experience;
    int hitPoints;
    QVector&lt;InventoryItem&gt; inventory;
    QString location;
    QPoint position;
};

struct PlayerInfo {
    QVector&lt;Player&gt; players;
};</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We want to use the <kbd>Q_ENUM</kbd> macro on our enum, because it will allow us to easily convert enum values to strings and back, which is very useful for serialization. Since <kbd>InventoryItem</kbd> is not a <kbd>QObject</kbd>, we need to add a <kbd>Q_GADGET</kbd> macro to the beginning of the class declaration to make the <kbd>Q_ENUM</kbd> macro work. Think of <kbd>Q_GADGET</kbd> as of a lightweight variation of <kbd>Q_OBJECT</kbd> that enables some of its features but not others.</p>
<p>The <kbd>typeByName()</kbd> method will receive a string and return the corresponding enum variant. We can implement this method as follows:</p>
<pre>InventoryItem::Type InventoryItem::typeByName(const QStringRef &amp;r) {
    QMetaEnum metaEnum = QMetaEnum::fromType&lt;InventoryItem::Type&gt;();
    QByteArray latin1 = r.toLatin1();
    int result = metaEnum.keyToValue(latin1.constData());
    return static_cast&lt;InventoryItem::Type&gt;(result);
}</pre>
<p>The implementation may look complicated, but it's much less error-prone than manually writing a bunch of <kbd>if</kbd> statements to choose the correct return value manually. First, we use the <kbd>QMetaEnum::fromType&lt;T&gt;()</kbd> template method to get the <kbd>QMetaEnum</kbd> object corresponding to our <kbd>enum</kbd>. The <kbd>keyToValue()</kbd> method of this object performs the conversion that we need, but it needs to be accompanied with a few conversions.</p>
<p>You can note that we are using a class called <kbd>QStringRef</kbd>. It represents a string reference—a substring in an existing string—and is implemented in a way that avoids expensive string construction; therefore, it is very fast. The similar <kbd>std::string_view</kbd> type was added to the standard library in C++17. We use it as the argument type because <kbd>QXmlStreamReader</kbd> will provide strings in this format.</p>
<p>However, the <kbd>keyToValue()</kbd> method expects a <kbd>const char *</kbd> argument, so we use the <kbd>toLatin1()</kbd> method to convert our string to <kbd>QByteArray</kbd>, and then use <kbd>constData()</kbd> to get the <kbd>const char *</kbd> pointer to its buffer. Finally, we use <kbd>static_cast</kbd> to convert the result from <kbd>int</kbd> to our <kbd>enum</kbd> type.</p>
<p>Save the following XML document somewhere. We will use it to test whether the parser can read it:</p>
<pre>&lt;PlayerInfo&gt;
    &lt;Player hp="40" exp="23456"&gt;
        &lt;Name&gt;Gandalf&lt;/Name&gt;
        &lt;Password&gt;mithrandir&lt;/Password&gt;
        &lt;Inventory&gt;
            &lt;InvItem type="Weapon" durability="3"&gt;
                &lt;SubType&gt;Long sword&lt;/SubType&gt;
            &lt;/InvItem&gt;
            &lt;InvItem type="Armor" durability="10"&gt;
                &lt;SubType&gt;Chain mail&lt;/SubType&gt;
            &lt;/InvItem&gt;
        &lt;/Inventory&gt;
        &lt;Location name="room1"&gt;
            &lt;Position x="1" y="0"/&gt;
        &lt;/Location&gt;
    &lt;/Player&gt;
&lt;/PlayerInfo&gt; </pre>
<p>Let's create a class called <kbd>PlayerInfoReader</kbd> that will wrap <kbd>QXmlStreamReader</kbd> and expose a parser interface for the <kbd>PlayerInfo</kbd> instances:</p>
<pre>class PlayerInfoReader {
public:
    PlayerInfoReader(QIODevice *device);
    PlayerInfo read();
private:
    QXmlStreamReader reader;
}; </pre>
<p>The class constructor accepts a <kbd>QIODevice</kbd> pointer that the reader will use to retrieve data as it needs it. The constructor is trivial, as it simply passes the device to the <kbd>reader</kbd> object:</p>
<pre>PlayerInfoReader(QIODevice *device) {
    reader.setDevice(device);
} </pre>
<p>Before we go into parsing, let's prepare some code to help us with the process. First, let's add an enumeration type to the class that will list all the possible tokens—tag names that we want to handle in the parser:</p>
<pre>enum class Token {
    Invalid = -1,
    PlayerInfo, // root tag
    Player,     // in PlayerInfo
    Name, Password, Inventory, Location, // in Player
    Position,   // in Location
    InvItem     // in Inventory
};</pre>
<p>Then, just like we did in the <kbd>InventoryItem</kbd> class, we use the <kbd>Q_GADGET</kbd> and <kbd>Q_ENUM</kbd> macros and implement the <kbd>PlayerInfoReader::tokenByName()</kbd> convenience method.</p>
<p>Now, let's implement the entry point of the parsing process:</p>
<pre>PlayerInfo PlayerInfoReader::read() {
    if(!reader.readNextStartElement()) {
        return PlayerInfo();
    }
    if (tokenByName(reader.name()) != Token::PlayerInfo) {
        return PlayerInfo();
    }
    PlayerInfo info;
    while(reader.readNextStartElement()) {
        if(tokenByName(reader.name()) == Token::Player) {
            Player p = readPlayer();
            info.players.append(p);
        } else {
            reader.skipCurrentElement();
        }
    }
    return info;
}</pre>
<p>First, we call <kbd>readNextStartElement()</kbd> on the reader to make it find the starting tag of the first element, and if it is found, we check whether the root tag of the document is what we expect it to be. If not, we return a default-constructed <kbd>PlayerInfo</kbd>, indicating that no data is available.</p>
<p>Next, we create a <kbd>PlayerInfo</kbd> variable. We iterate all the starting sub-elements in the current tag (<kbd>PlayerInfo</kbd>). For each of them, we check whether it is a <kbd>Player</kbd> tag and call <kbd>readPlayer()</kbd> to descend into the level of parsing data for a single player. Otherwise, we call <kbd>skipCurrentElement()</kbd>, which fast-forwards the stream until a matching ending element is encountered.</p>
<p>The other methods in this class will usually follow the same pattern. Each parsing method iterates all the starting elements, handling those it knows and ignoring all others. Such an approach lets us maintain forward compatibility, since all tags introduced in the newer versions of the document are silently skipped by an older parser.</p>
<p>The structure of <kbd>readPlayer()</kbd> is similar; however, it is more complicated, as we also want to read data from the attributes of the <kbd>Player</kbd> tag itself. Let's take a look at the function piece by piece. First, we get the list of attributes associated with the opening tag and ask for values of the two attributes that we are interested in:</p>
<pre>Player p;
const QXmlStreamAttributes&amp; playerAttrs = reader.attributes();
p.hitPoints = playerAttrs.value("hp").toString().toInt();
p.experience = playerAttrs.value("exp").toString().toInt();</pre>
<p>After this, we loop all child tags and fill the <kbd>Player</kbd> structure based on the tag names. By converting tag names to tokens, we can use a <kbd>switch</kbd> statement to neatly structure the code in order to extract information from different tag types, as in the following code:</p>
<pre>while(reader.readNextStartElement()) {
    Token t = tokenByName(reader.name());
    switch(t) {
    case Token::Name:
        p.name = reader.readElementText();
        break;
    case Token::Password:
        p.password = reader.readElementText();
        break;
    case Token::Inventory:
        p.inventory = readInventory();
        break;
    //...
    }
}</pre>
<p>If we are interested in the textual content of the tag, we can use <kbd>readElementText()</kbd> to extract it. This method reads until it encounters the closing tag and returns the text contained within it. For the <kbd>Inventory</kbd> tag, we call the dedicated <kbd>readInventory()</kbd> method.</p>
<p>For the <kbd>Location</kbd> tag, the code is more complex than earlier as we again descend into reading child tags, extracting the required information and skipping all unknown tags:</p>
<pre>case Token::Location:
    p.location = reader.attributes().value("name").toString();
    while(reader.readNextStartElement()) {
        if(tokenByName(reader.name()) == Token::Position) {
            const QXmlStreamAttributes&amp; attrs = reader.attributes();
            p.position.setX(attrs.value("x").toString().toInt());
            p.position.setY(attrs.value("y").toString().toInt());
            reader.skipCurrentElement();
        } else {
            reader.skipCurrentElement();
        }
    }
    break;</pre>
<p>Next, we again skip the tags that didn't match any known tokens. At the end of <kbd>readPlayer()</kbd>, we simply return the populated <kbd>Player</kbd> value.</p>
<p>The last method is similar in structure to the previous one—iterate all the tags, skip everything that we don't want to handle (everything that is not an inventory item), fill the inventory item data structure, and append the item to the list of already parsed items, as follows:</p>
<pre>QVector&lt;InventoryItem&gt; PlayerInfoReader::readInventory() {
    QVector&lt;InventoryItem&gt; inventory;
    while(reader.readNextStartElement()) {
        if(tokenByName(reader.name()) != Token::InvItem) {
            reader.skipCurrentElement();
            continue;
        }
        InventoryItem item;
        const QXmlStreamAttributes&amp; attrs = reader.attributes();
        item.durability = attrs.value("durability").toString().toInt();
        item.type = InventoryItem::typeByName(attrs.value("type"));
        while(reader.readNextStartElement()) {
            if(reader.name() == "SubType") {
                item.subType = reader.readElementText();
            }
            else {
                reader.skipCurrentElement();
            }
        }
        inventory &lt;&lt; item;
    }
    return inventory;
}</pre>
<p>In <kbd>main()</kbd> of your project, write some code that will check whether the parser works correctly. You can use the <kbd>qDebug()</kbd> statements to output the sizes of lists and contents of variables. Take a look at the following code for an example:</p>
<pre>QFile file(filePath);
file.open(QFile::ReadOnly | QFile::Text);
PlayerInfoReader reader(&amp;file);
PlayerInfo playerInfo = reader.read();
if (!playerInfo.players.isEmpty()) {
    qDebug() &lt;&lt; "Count:" &lt;&lt; playerInfo.players.count();
    qDebug() &lt;&lt; "Size of inventory:" &lt;&lt;
                playerInfo.players.first().inventory.size();
    qDebug() &lt;&lt; "Inventory item:"
             &lt;&lt; playerInfo.players.first().inventory[0].type
             &lt;&lt; playerInfo.players.first().inventory[0].subType;
    qDebug() &lt;&lt; "Room:" &lt;&lt; playerInfo.players.first().location
             &lt;&lt; playerInfo.players.first().position;
}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>The code you just wrote implements a full top-down parser of the XML data. First, the data goes through a tokenizer, which returns identifiers that are much easier to handle than strings. Then, each method can easily check whether the token it receives is an acceptable input for the current parsing stage. Based on the child token, the next parsing function is determined and the parser descends to a lower level until there is nowhere to descend to. Then, the flow goes back up one level and processes the next child. If, at any point, an unknown tag is found, it gets ignored. This approach supports a situation when a new version of software introduces new tags to the file format specification, but an old version of software can still read the file by skipping all the tags that it doesn't understand.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Have a go hero – An XML serializer for player data</h1>
                
            
            
                
<p>Now that you know how to parse XML data, you can create the complementary part—a module that will serialize <kbd>PlayerInfo</kbd> structures into XML documents using <kbd>QXmlStreamWriter</kbd>. Use methods such as <kbd>writeStartDocument()</kbd>, <kbd>writeStartElement()</kbd>, <kbd>writeCharacters()</kbd>, and <kbd>writeEndElement()</kbd> for this. Verify that the documents saved with your code can be parsed with what we implemented together.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">QVariant</h1>
                
            
            
                
<p><kbd>QVariant</kbd> is a class that can hold values of multiple types:</p>
<pre>QVariant intValue = 1;<br/>int x = intValue.toInt();<br/>QVariant stringValue = "ok";<br/>QString y = stringValue.toString();</pre>
<p>When you assign a value to a <kbd>QVariant</kbd> object, that value is stored inside along with the type information. You can use its <kbd>type()</kbd> method to find out which type of value it holds. The default constructor of <kbd>QVariant</kbd> creates an invalid value that you can detect using the <kbd>isValid()</kbd> method.</p>
<p><kbd>QVariant</kbd> supports a great amount of types, including Qt value types such as <kbd>QDateTime</kbd>, <kbd>QColor</kbd>, and <kbd>QPoint</kbd>. You can also register your own types to store them in <kbd>QVariant</kbd>. One of the most powerful features of <kbd>QVariant</kbd> is the ability to store a collection or a hierarchy of values. You can use the <kbd>QVariantList</kbd> type (which is a <kbd>typedef</kbd> for <kbd>QList&lt;QVariant&gt;</kbd>) to create a list of <kbd>QVariant</kbd> objects, and you can actually put the whole list into a single <kbd>QVariant</kbd> object! You'll be able to retrieve the list and examine individual values:</p>
<pre>QVariant listValue = QVariantList { 1, "ok" };<br/>for(QVariant item: listValue.toList()) {<br/>  qDebug() &lt;&lt; item.toInt() &lt;&lt; item.toString();<br/>}</pre>
<p>Similarly, you can use <kbd>QVariantMap</kbd> or <kbd>QVariantHash</kbd> to create a key-value collection with <kbd>QString</kbd> keys and <kbd>QVariant</kbd> values. Needless to say, you can store such a collection in a single <kbd>QVariant</kbd> as well. This allows you to construct a hierarchy with unlimited depth and arbitrary structure.</p>
<p>As you can see, <kbd>QVariant</kbd> is a pretty powerful class, but how can we use it for serializing? For a start, <kbd>QVariant</kbd> is supported by <kbd>QDataStream</kbd>, so you can use the binary serialization described earlier to serialize and restore any <kbd>QVariant</kbd> value you can construct. For example, instead of putting each field of your structure into <kbd>QDataStream</kbd>, you can put them into a <kbd>QVariantMap</kbd> and then put it into the stream:</p>
<pre>Player player;<br/>QVariantMap map;<br/>map["name"] = player.name;<br/>map["experience"] = player.experience;<br/>//...<br/>stream &lt;&lt; map;</pre>
<p>Loading the data is also straightforward:</p>
<pre>QVariantMap map;<br/>stream &gt;&gt; map;<br/>Player player;<br/>player.name = map["name"].toString();<br/>player.experience = map["experience"].toLongLong();</pre>
<p>This approach allows you to store arbitrary data in an arbitrary location. However, you can also use <kbd>QVariant</kbd> along with <kbd>QSettings</kbd> to conveniently store the data in an appropriate location.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">QSettings</h1>
                
            
            
                
<p>While not strictly a serialization issue, the aspect of storing application settings is closely related to the described subject. A Qt solution for this is the <kbd>QSettings</kbd> class. By default, it uses different backends on different platforms, such as system registry on Windows or INI files on Linux. The basic use of <kbd>QSettings</kbd> is very easy—you just need to create the object and use <kbd>setValue()</kbd> and <kbd>value()</kbd> to store and load data from it:</p>
<pre>QSettings settings;
settings.setValue("level", 4);
settings.setValue("playerName", "Player1");
// ...
int level = settings.value("level").toInt(); </pre>
<p>The only thing you need to remember is that it operates on <kbd>QVariant</kbd>, so the return value needs to be converted to the proper type if needed, like <kbd>toInt()</kbd> in the preceding code. A call to <kbd>value()</kbd> can take an additional argument that contains the value to be returned if the requested key is not present in the map. This allows you to handle default values, for example, in a situation when the application is first started and the settings are not saved yet:</p>
<pre>int level = settings.value("level", 1).toInt(); </pre>
<p>If you don't specify the default value, an invalid <kbd>QVariant</kbd> will be returned when nothing is stored, and you can check for that using the <kbd>isValid()</kbd> method.</p>
<p>In order for the default settings location to be correct, you need to set the organization name and the application name. They determine where exactly <kbd>QSettings</kbd> store data by default and ensure that the stored data will not conflict with another application. This is typically done at the beginning of your <kbd>main()</kbd> function:</p>
<pre>int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    <strong>QCoreApplication::setOrganizationName("Packt");
    QCoreApplication::setApplicationName("Game Programming using Qt");</strong>
    //...
}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Settings hierarchy</h1>
                
            
            
                
<p>The simplest scenario assumes that settings are "flat", in that all keys are defined on the same level. However, this does not have to be the case—correlated settings can be put into named groups. To operate on a group, you can use the <kbd>beginGroup()</kbd>   and  <kbd>endGroup()</kbd> calls:</p>
<pre>settings.beginGroup("server");
QString serverIP = settings.value("host").toString();
int port = settings.value("port").toInt();
settings.endGroup();</pre>
<p>When using this syntax, you have to remember to end the group after you are done with it. An alternative way to do the same thing is to pass the group name directly to invocation of <kbd>value()</kbd>, using <kbd>/</kbd> to separate it from the value name:</p>
<pre>QString serverIP = settings.value("server/host").toString();
int port = settings.value("server/port").toInt(); </pre>
<p>You can create multiple nested groups by calling <kbd>beginGroup()</kbd> multiple times (or, equivalently, writing multiple slashes in the value name).</p>
<p>There is another way to introduce a non-flat structure to <kbd>QSettings</kbd>. It can handle composite <kbd>QVariant</kbd> values—<kbd>QVariantMap</kbd> and <kbd>QVariantList</kbd>. You can simply convert your data to a <kbd>QVariant</kbd>, much like we converted it to a <kbd>QJsonValue</kbd> earlier:</p>
<pre>QVariant inventoryItemToVariant(const InventoryItem &amp;item) {
    QVariantMap map;
    map["type"]       = InventoryItem::typeToName(item.type);
    map["subtype"]    = item.subType;
    map["durability"] = item.durability;
    return map;
}</pre>
<p>This <kbd>QVariant</kbd> value can be passed to <kbd>QSettings::setValue()</kbd>. Of course, you will need to implement the inverse operation as well. More than that, nothing stops you from converting your data to JSON and saving it to <kbd>QSettings</kbd> as a <kbd>QByteArray</kbd>. However, these approaches may be slower than proper serialization, and the resulting settings file will be hard to edit manually.</p>
<p>Various Qt classes have methods that are meant to be used with <kbd>QSettings</kbd> to easily save a set of properties. For example, <kbd>QWidget::saveGeometry()</kbd>  and  <kbd>QWidget::restoreGeometry()</kbd> helpers allow you to save the window's position and size to <kbd>QSettings</kbd>:</p>
<pre>settings.setValue("myWidget/geometry", myWidget-&gt;saveGeometry());
//...
myWidget-&gt;restoreGeometry(
    settings.value("myWidget/geometry").toByteArray());</pre>
<p>Similarly, multiple widget classes have <kbd>saveState()</kbd> and <kbd>restoreState()</kbd> methods to save information about the widget's state:</p>
<ul>
<li><kbd>QMainWindow</kbd> can save positions of toolbars and dock widgets</li>
<li><kbd>QSplitter</kbd> can save positions of its handles</li>
<li><kbd>QHeaderView</kbd> can save sizes of the table's rows or columns</li>
<li><kbd>QFileDialog</kbd> can save the dialog's layout, history, and current directory</li>
</ul>
<p>These methods are a great way to preserve all changes the user has made in your application's interface.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Customizing the settings location and format</h1>
                
            
            
                
<p>The constructor of the <kbd>QSettings</kbd> class has a number of overloads that allow you to change the location where the data will be stored by a particular <kbd>QSettings</kbd> object, instead of using the default location. First, you can override the organization name and the application name:</p>
<pre>QSettings settings("Packt", "Game Programming using Qt"); </pre>
<p>Next, you can use the system-wide storage location by passing  <kbd>QSettings::SystemScope </kbd> as the <kbd>scope</kbd> argument:</p>
<pre>QSettings settings(QSettings::SystemScope, <br/>    "Packt", "Game Programming using Qt");</pre>
<p>In this case, <kbd>QSettings</kbd> will try to read the settings for all users and then fall back to the user-specific location. Note that a system-wide location may not be writable, so using <kbd>setValue()</kbd> on it won't have the desired effect.</p>
<p>You can also opt out of the preferred format detection using the  <kbd>QSettings::setDefaultFormat()</kbd> function. For example, use the following code on Windows to disable using the registry:</p>
<pre>QSettings::setDefaultFormat(QSettings::IniFormat);</pre>
<p>Finally, there is one more option available for total control of where the settings data resides—tell the constructor directly where the data should be located:</p>
<pre>QSettings settings(
    QStandardPaths::writableLocation(QStandardPaths::ConfigLocation) +
        "/myapp.ini", <br/>    QSettings::IniFormat
); </pre>
<p>If you pass <kbd>QSettings::NativeFormat</kbd> to this constructor, the meaning of the path will depend on the platform. For example, it will be interpreted as a registry path on Windows.</p>
<p>Since you can use <kbd>QSettings</kbd> to read and write to an arbitrary INI file, it's a convenient and easy way to implement serialization of an object to the INI format, which is suitable in simple cases.</p>
<p><kbd>QSettings</kbd> also allows you to register your own formats so that you can control the way your settings are stored, for example, by storing them using XML or by adding on-the-fly encryption. This is done using <kbd>QSettings::registerFormat()</kbd>, where you need to pass the file extension and two pointers to functions that perform reading and writing of the settings, respectively, as follows:</p>
<pre>bool readCCFile(QIODevice &amp;device, QSettings::SettingsMap &amp;map) {
    CeasarCipherDevice ccDevice;
    ccDevice.setBaseDevice(&amp;device);
    // ...
    return true;
}
bool writeCCFile(QIODevice &amp;device, const QSettings::SettingsMap &amp;map) { <br/>    // ... <br/>}
const QSettings::Format CCFormat = QSettings::registerFormat(
    "ccph", readCCFile, writeCCFile);</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">JSON files</h1>
                
            
            
                
<p><strong>JSON</strong> stands for "JavaScript Object Notation", which is a popular lightweight textual format that is used to store object-oriented data in a human-readable form. It comes from JavaScript where it is the native format used to store object information; however, it is commonly used across many programming languages and a popular format for web data exchange. Qt Core supports JSON format, as we'll see in the following code. A simple JSON-formatted definition looks as follows:</p>
<pre>{
    "name": "Joe",
    "age": 14,
    "inventory": [
        { "type": "gold", "amount": "144000" },
        { "type": "short_sword", "material": "iron" }
    ]
} </pre>
<p>JSON objects can contain values of the following types:</p>
<table>
<tbody>
<tr>
<td><strong>Type</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>bool</td>
<td>A boolean value (<kbd>true</kbd> or <kbd>false</kbd>).</td>
</tr>
<tr>
<td>double</td>
<td>A number value (for example, <kbd>42.1</kbd>).</td>
</tr>
<tr>
<td>string</td>
<td>A quoted string (for example, <kbd>"Qt"</kbd>).</td>
</tr>
<tr>
<td>array</td>
<td>A collection of values of any type enclosed in square brackets (for example, <kbd>[42.1, "Qt"]</kbd>).</td>
</tr>
<tr>
<td>object</td>
<td>
<p class="mce-root">A set of key-value pairs enclosed in braces. Keys are strings, and values can be of any type (for example, <kbd>{ "key1": 42.1, "key2": [42.1, "Qt"] }</kbd>).</p>
</td>
</tr>
<tr>
<td>null</td>
<td>
<p class="mce-root">A special value (<kbd>null</kbd>) indicating lack of data.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>A proper <strong>JSON document</strong> must have either an array or an object at the top level. In the preceding example, we had an object containing three properties: name, age, and inventory. The first two properties are simple values, and the last property is an array that contains two objects with two properties each.</p>
<p>Qt can create and read JSON descriptions using the <kbd>QJsonDocument</kbd> class. A document can be created from the UTF-8-encoded text using the <kbd>QJsonDocument::fromJson()</kbd> static method, and can later be stored in a textual form again using <kbd>toJson()</kbd>. Once a JSON document is created, you can check whether it represents an object or an array using one of the <kbd>isArray()</kbd> and <kbd>isObject()</kbd> calls. Then, the document can be transformed into <kbd>QJsonArray</kbd> or <kbd>QJsonObject</kbd> using the <kbd>array()</kbd> or <kbd>object()</kbd> methods.</p>
<p>Since the structure of JSON closely resembles that of <kbd>QVariant</kbd> (which can also hold key-value pairs using <kbd>QVariantMap</kbd> and arrays using <kbd>QVariantList</kbd>), conversion methods <kbd>QJsonDocument::fromVariant()</kbd> and <kbd>QJsonDocument::toVariant()</kbd> also exist.</p>
<p><kbd>QJsonObject</kbd> is an iterable type that can be queried for a list of keys (using <kbd>keys()</kbd>) or asked for a value of a specific key (with a <kbd>value()</kbd> method or <kbd>operator[]</kbd>). Values are represented using the <kbd>QJsonValue</kbd> class, which can store any of the value types listed earlier. New properties can be added to the object using the <kbd>insert()</kbd> method that takes a key as a string, and a value can be added as <kbd>QJsonValue</kbd>. The existing properties can be removed using <kbd>remove()</kbd>.</p>
<p><kbd>QJsonArray</kbd> is also an iterable type that contains a classic list API; it contains methods such as <kbd>append()</kbd>, <kbd>insert()</kbd>, <kbd>removeAt()</kbd>, <kbd>at()</kbd>, and <kbd>size()</kbd> to manipulate entries in the array, again working on <kbd>QJsonValue</kbd> as the item type.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – The player data JSON serializer</h1>
                
            
            
                
<p>Our next exercise is to create a serializer of the same <kbd>PlayerInfo</kbd> structure as we used for the XML exercise, but this time the destination data format will be JSON.</p>
<p>Start by creating a <kbd>PlayerInfoJson</kbd> class and give it an interface similar to the one shown in the following code:</p>
<pre>class PlayerInfoJson {
public:
    PlayerInfoJson() {}
    QByteArray playerInfoToJson(const PlayerInfo &amp;pinfo);
}; </pre>
<p>All that is really required is to implement the <kbd>playerInfoToJson</kbd> method. Generally, we need to convert our <kbd>PlayerInfo</kbd> data to a <kbd>QJsonArray</kbd> and then use <kbd>QJsonDocument</kbd> to encode it as JSON:</p>
<pre>QByteArray PlayerInfoJson::playerInfoToJson(const PlayerInfo &amp;pinfo)
{
    QJsonDocument doc(toJson(pinfo));
    return doc.toJson();
}</pre>
<p>Now, let's start implementing the <kbd>toJson()</kbd> method:</p>
<pre>QJsonArray PlayerInfoJson::toJson(const PlayerInfo &amp;pinfo) {
    QJsonArray array;
    for(const Player &amp;p: pinfo.players) {
        array &lt;&lt; toJson(p);
    }
    return array;
}</pre>
<p>Since the structure is really a list of players, we can iterate over it, convert each player to a <kbd>QJsonValue</kbd>, and append the result to <kbd>QJsonArray</kbd>. Having this function ready, we can descend a level and implement an overload for <kbd>toJson()</kbd> that takes a <kbd>Player</kbd> object:</p>
<pre>QJsonValue PlayerInfoJson::toJson(const Player &amp;player) {
    QJsonObject object;
    object["name"]       = player.name;
    object["password"]   = player.password;
    object["experience"] = player.experience;
    object["hitpoints"]  = player.hitPoints;
    object["location"]   = player.location;
    object["position"]   = QJsonObject({ { "x", player.position.x() },
                                         { "y", player.position.y() } });
    object["inventory"]  = toJson(player.inventory);
    return object;
}</pre>
<p>This time, we are using <kbd>QJsonObject</kbd> as our base type, since we want to associate values with keys. For each key, we use the index operator to add entries to the object. The position key holds a <kbd>QPoint</kbd> value, which is not a valid JSON value, so we convert the point to a <kbd>QJsonObject</kbd> with two keys (<kbd>x</kbd> and <kbd>y</kbd>) using the C++11 initializer list. The situation is different with the inventory—again, we have to write an overload for <kbd>toJson</kbd> that will perform the conversion:</p>
<pre>QJsonValue PlayerInfoJson::toJson(const QVector&lt;InventoryItem&gt; &amp;items) {
    QJsonArray array;
    for(const InventoryItem &amp;item: items) {
        array &lt;&lt; toJson(item);
    }
    return array;
}</pre>
<p>The code is almost identical to the one handling <kbd>PlayerInfo</kbd> objects, so let's focus on the last overload of <kbd>toVariant</kbd>—the one that accepts <kbd>Item</kbd> instances:</p>
<pre>QJsonValue PlayerInfoJson::toJson(const InventoryItem &amp;item) {
    QJsonObject object;
    object["type"] = InventoryItem::typeToName(item.type);
    object["subtype"] = item.subType;
    object["durability"] = item.durability;
    return object;
}</pre>
<p>There is not much to comment here—we add all keys to the object, converting the item type to a string. For this, we have to add the static <kbd>InventoryItem::typeToName()</kbd> method that is the reverse of <kbd>typeByName()</kbd>, that is, it takes a enum variant and outputs its name as a string:</p>
<pre>const char *InventoryItem::typeToName(InventoryItem::Type value)
{
    QMetaEnum metaEnum = QMetaEnum::fromType&lt;InventoryItem::Type&gt;();
    return metaEnum.valueToKey(static_cast&lt;int&gt;(value));
}</pre>
<p>This is pretty much a wrapper over the <kbd>QMetaEnum::valueToKey()</kbd> method that does all the magic that wouldn't be possible without Qt.</p>
<p>The serializer is complete! Now you can use <kbd>PlayerInfoJson::playerInfoToJson()</kbd> to convert <kbd>PlayerInfo</kbd> into a <kbd>QByteArray</kbd> containing the JSON. It's suitable for writing it to a file or sending it over the network. However, to make it more useful, we need to implement the reverse operation (deserialization).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – Implementing a JSON parser</h1>
                
            
            
                
<p>Let's extend the <kbd>PlayerInfoJSON</kbd> class and equip it with a <kbd>playerInfoFromJson()</kbd> method:</p>
<pre>PlayerInfo PlayerInfoJson::playerInfoFromJson(const QByteArray &amp;ba) {
    QJsonDocument doc = QJsonDocument::fromJson(ba);
    if(!doc.isArray()) {
        return PlayerInfo();
    }
    QJsonArray array = doc.array();
    PlayerInfo pinfo;
    for(const QJsonValue &amp;value: array) {
        pinfo.players &lt;&lt; playerFromJson(value.toObject());
    }
    return pinfo;
}</pre>
<p>First, we read the document and check whether it is valid and holds the expected array. Upon failure, an empty structure is returned; otherwise, we iterate over the received array and convert each of its elements to an object. Similar to the serialization example, we create a helper function for each complex item of our data structure. Thus, we write a new <kbd>playerFromJson()</kbd> method that converts <kbd>QJsonObject</kbd> to a <kbd>Player</kbd>, that is, performs a reverse operation as compared to <kbd>toJson(Player)</kbd>:</p>
<pre>Player PlayerInfoJson::playerFromJson(const QJsonObject &amp;object) {
    Player player;
    player.name       = object["name"].toString();
    player.password   = object["password"].toString();
    player.experience = object["experience"].toDouble();
    player.hitPoints  = object["hitpoints"].toDouble();
    player.location   = object["location"].toString();
    QJsonObject positionObject = object["position"].toObject();
    player.position   = QPoint(positionObject["x"].toInt(),
                               positionObject["y"].toInt());
    player.inventory  = inventoryFromJson(object["inventory"].toArray());
    return player;
}</pre>
<p>In this function, we used <kbd>operator[]</kbd> to extract data from <kbd>QJsonObject</kbd>, and then we used different functions to convert the data to the desired type. Note that in order to convert to <kbd>QPoint</kbd>, we first converted it to <kbd>QJsonObject</kbd> and then extracted the values before using them to build <kbd>QPoint</kbd>. In each case, if the conversion fails, we get a default value for that type (for example, an empty string or a zero number). To read the inventory, we employ another custom method:</p>
<pre>QVector&lt;InventoryItem&gt; PlayerInfoJson::inventoryFromJson(<br/>    const QJsonArray &amp;array) <br/>{
    QVector&lt;InventoryItem&gt; inventory;
    for(const QJsonValue &amp;value: array) {
      inventory &lt;&lt; inventoryItemFromJson(value.toObject());
    }
    return inventory;
}</pre>
<p>What remains is to implement <kbd>inventoryItemFromJson()</kbd>:</p>
<pre>InventoryItem PlayerInfoJson::inventoryItemFromJson(<br/>    const QJsonObject &amp;object) <br/>{
    InventoryItem item;
    item.type = InventoryItem::typeByName(object["type"].toString());
    item.subType = object["subtype"].toString();
    item.durability = object["durability"].toDouble();
    return item;
}</pre>
<p>Unfortunately, our <kbd>typeByName()</kbd> function requires <kbd>QStringRef</kbd>, not <kbd>QString</kbd>. We can fix this by adding a couple of overloads and forwarding them to a single implementation:</p>
<pre><strong>InventoryItem::Type InventoryItem::typeByName(const QStringRef &amp;r) {</strong><br/><strong>    return typeByName(r.toLatin1());</strong><br/><strong>}</strong><br/><strong>InventoryItem::Type InventoryItem::typeByName(const QString &amp;r) {</strong><br/><strong>    return typeByName(r.toLatin1());</strong><br/><strong>}</strong><br/>InventoryItem::Type InventoryItem::typeByName(const QByteArray &amp;latin1) {<br/>    QMetaEnum metaEnum = QMetaEnum::fromType&lt;InventoryItem::Type&gt;();<br/>    int result = metaEnum.keyToValue(<strong>latin1.constData()</strong>);<br/>    return static_cast&lt;InventoryItem::Type&gt;(result);<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>The class that was implemented can be used for bidirectional conversion between <kbd>Item</kbd> instances and a <kbd>QByteArray</kbd> object, which contains the object data in the JSON format. We didn't do any error checking here; instead, we relied on Qt's rule that an error results in a sensible default value.</p>
<p>What if you want to perform error checking? The most straightforward solution in this case is to use exceptions, as they will automatically propagate from the multiple nested calls to the caller's location. Ensure that you catch any exceptions you throw, or the application will terminate. A more Qt-like solution is to create a <kbd>bool *ok</kbd> argument in all methods (including internal ones) and set the boolean value to <kbd>false</kbd> in case of any error.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pop quiz</h1>
                
            
            
                
<p>Q1. What is the closest equivalent of <kbd>std::string</kbd> in Qt?</p>
<ol>
<li><kbd>QString</kbd></li>
<li><kbd>QByteArray</kbd></li>
<li><kbd>QStringLiteral</kbd></li>
</ol>
<p>Q2. Which strings match the <kbd>\A\d\z</kbd> regular expression?</p>
<ol>
<li>Strings consisting of digits</li>
<li>Strings consisting of a single digit</li>
<li>This is not a valid regular expression</li>
</ol>
<p>Q3. Which of the following container types can you use to store a list of widgets?</p>
<ol>
<li><kbd>QVector&lt;QWidget&gt;</kbd></li>
<li><kbd>QList&lt;QWidget&gt;</kbd></li>
<li><kbd>QVector&lt;QWidget*&gt;</kbd></li>
</ol>
<p>Q4. Which class can you use to convert a text string containing JSON to a Qt JSON representation?</p>
<ol>
<li><kbd>QJsonValue</kbd></li>
<li><kbd>QJsonObject</kbd></li>
<li><kbd>QJsonDocument</kbd></li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned a number of core Qt technologies, ranging from text manipulation and containers to accessing devices that can be used to transfer or store data, using a number of popular technologies such as XML or JSON. You should be aware that we have barely scratched the surface of what Qt offers and there are many other interesting classes you should familiarize yourself with, but this minimum amount of information should give you a head start and show you the direction to follow with your future research.</p>
<p>In the next chapter, we will go beyond the boundaries of your computer and explore ways to use the powerful world of the modern internet. You will learn how to interact with the existing network services, check the current network availability, and implement your own servers and clients. This knowledge will come in handy if you want to implement multiplayer networked games.</p>


            

            
        
    </div>



  </body></html>