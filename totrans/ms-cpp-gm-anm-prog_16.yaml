- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Advanced Collision Detection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级碰撞检测
- en: Welcome to *Chapter 12*! In the previous chapter, we added the ability to load
    static level data to the virtual world. Now the instances no longer have to run
    in thin air; they can get a virtual home. First, we explored the differences between
    model and level data, which file formats are mostly used for level data, and where
    to find game maps on the internet. Then, we added code to load level data and
    replaced the two-dimensional quadtree with a three-dimensional octree. Finally,
    we implemented the level data rendering, including debug data for wireframe, octree,
    and level AABB lines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第12章**！在前一章中，我们向虚拟世界添加了加载静态关卡数据的能力。现在实例不再需要在空中运行；它们可以拥有一个虚拟的家。首先，我们探讨了模型数据和关卡数据之间的差异，以及主要用于关卡数据的文件格式，以及在哪里可以找到互联网上的游戏地图。然后，我们添加了加载关卡数据的代码，并用三维八叉树替换了二维四叉树。最后，我们实现了关卡数据的渲染，包括线框、八叉树和关卡AABB线的调试数据。
- en: In this chapter, we will extend the level data from the previous chapter. First,
    we will add a specialized octree for the level data and update the code to also
    support collision detection between instances and level geometry. Then, we will
    add a simplified form of gravity to the virtual world to keep the instances at
    ground level instead of having them floating around. As the last step, we will
    introduce inverse kinematics for the instance legs to allow the instances to climb
    slopes and stairs with more natural leg motions and to prevent the feet from clipping
    into the ground or floating in the air.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展前一章中的关卡数据。首先，我们将为关卡数据添加一个专门的八叉树，并更新代码以支持实例和关卡几何之间的碰撞检测。然后，我们将向虚拟世界添加一种简化的重力形式，以使实例保持在地面水平，而不是在空中漂浮。作为最后一步，我们将为实例腿部引入逆运动学，以允许实例以更自然的腿部动作爬坡和上楼梯，并防止脚部嵌入地面或漂浮在空中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Enhancing collision detection for level data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升关卡数据的碰撞检测
- en: Using gravity to keep the instances at floor level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重力使实例保持在地板水平
- en: Adding inverse kinematics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加逆运动学
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code for this chapter is available in the `chapter12` folder, in
    the `01_opengl_adv_collision` subfolder for OpenGL, and the `02_vulkan_adv_collision`
    subfolder for Vulkan.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于`chapter12`文件夹中，对于OpenGL位于`01_opengl_adv_collision`子文件夹，对于Vulkan位于`02_vulkan_adv_collision`子文件夹。
- en: Enhancing collision detection for level data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升关卡数据的碰撞检测
- en: To speed up collision detection between instances and level geometry, we will
    create spatial partitioning for the level data, like the octree. But instead of
    adding the level triangles to the instance octree, we build a specialized octree
    for the triangle data alone.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速实例和关卡几何之间的碰撞检测，我们将为关卡数据创建空间分区，例如八叉树。但是，我们不会将关卡三角形添加到实例八叉树中，而是为三角形数据单独构建一个专门的八叉树。
- en: Adding a new octree type
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的八叉树类型
- en: 'Using a separate data structure for level data makes more sense than trying
    to mix both data types in the existing octree for several reasons:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的数据结构来处理关卡数据比试图将两种数据类型混合到现有的八叉树中更有意义，原因如下：
- en: The level data is static while the instance positions change frequently. We
    need to do costly updates to a quite heavily utilized octree on every instance
    position change, possibly resulting in a lot of additional split and merge operations
    when removing and re-adding the instances.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡数据是静态的，而实例位置频繁变化。我们需要在每次实例位置变化时对高度使用的八叉树进行昂贵的更新，这可能导致在移除和重新添加实例时进行大量的分割和合并操作。
- en: The number of subdivisions for level data and instances may be completely different,
    depending on the level’s complexity and the number of instances. Having only a
    small number of instances roaming around a detailed level may lead to a huge overhead
    when searching for nearby triangles or instances.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡数据和实例的细分数量可能完全不同，这取决于关卡复杂性和实例数量。在详细关卡周围只有少数实例漫游可能会导致在搜索附近的三角形或实例时产生巨大的开销。
- en: We are using an octree for the level data for simplicity, but other data structures,
    like BSP trees or **boundary volume hierarchies (BVHs)**, are more common. Since
    BSP trees and BVHs cannot be dynamically updated as quickly as our octree, a split
    between level data and instances would still be necessary.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为了简化，使用八叉树来处理关卡数据，但其他数据结构，如BSP树或**边界体积层次（BVHs）**，更为常见。由于BSP树和BVHs不能像我们的八叉树那样快速动态更新，因此在关卡数据和实例之间仍然需要进行分割。
- en: With two different octrees, we can overcome these mentioned problems. The level
    data octree is kept unchanged after adding all the level triangles, both octrees
    have their own subdivisions, depending on the amount of data per octant, but we
    can still combine the information by using the instance bounding boxes in the
    level octree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个不同的八叉树，我们可以克服上述提到的问题。在添加所有级别三角形后，级别数据八叉树保持不变，两个八叉树都有它们自己的细分，这取决于每个八分体的数据量，但我们可以通过使用级别八叉树中的实例边界框来组合信息。
- en: 'As the first step for the level octree, we add a new `struct` named `MeshTriangle`
    to the `OGLRenderData.h` file in the `opengl` folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为级别八叉树的第一步，我们在 `opengl` 文件夹中的 `OGLRenderData.h` 文件中添加了一个名为 `MeshTriangle` 的新
    `struct`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For Vulkan, the triangle `struct` will be added to the `VkRenderData.h` file
    in the `vulkan` folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vulkan，三角形 `struct` 将添加到 `vulkan` 文件夹中的 `VkRenderData.h` 文件中。
- en: The `index` member is mostly for debugging purposes and will be added to a log
    output line in case some triangles cannot be added to the octree. In the `points`
    array, we save the world positions of each of the three points of a triangle.
    The world position is needed to create the proper bounding box for the triangle,
    we will use the world position also later for collision detection. And the `boundingBox`
    member contains the `AABB` for every triangle of the level data mesh.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 成员主要用于调试目的，如果某些三角形无法添加到八叉树中，它将被添加到日志输出行中。在 `points` 数组中，我们保存三角形三个点的世界位置。世界位置用于创建三角形适当边界框，我们稍后也将使用世界位置进行碰撞检测。`boundingBox`
    成员包含级别数据网格中每个三角形的 `AABB`。'
- en: Using bounding boxes instead of the real triangle data in the octree simplifies
    the query operations a lot since we do not have to check the exact outline of
    every triangle when searching for collision. We may end up with more triangles
    to check by using the AABB, but the `AABB` checks are cheap since we only need
    a maximum of six simple `float` comparisons. As most parts of a level geometry
    are either wall or ground, the additional size of the `AABB` does not matter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边界框而不是八叉树中的实际三角形数据大大简化了查询操作，因为我们不需要在搜索碰撞时检查每个三角形的精确轮廓。我们可能会通过使用 AABB 检查出更多的三角形，但由于我们只需要进行最多六个简单的
    `float` 比较即可，因此 AABB 检查的成本很低。由于大多数级别的几何部分要么是墙壁要么是地面，因此 `AABB` 的额外大小并不重要。
- en: Next, we add the new octree class named `TriangleOctree`. The new triangle octree
    will be implemented in the two new files, `TriangleOctree.h` and `TriangleOctree.cpp`,
    in the `octree` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `octree` 文件夹中添加了新的八叉树类 `TriangleOctree`。新的三角形八叉树将在两个新文件 `TriangleOctree.h`
    和 `TriangleOctree.cpp` 中实现。
- en: 'The `TriangleOctree` class is a copy of the normal `Octree` class, with a few
    exceptions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`TriangleOctree` 类是正常 `Octree` 类的一个副本，但有几点例外：'
- en: We store the triangle data in the tree instead of the instance index.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在树中存储三角形数据而不是实例索引。
- en: Since the level data octree will be kept read-only, we don’t need the methods
    to update or remove objects or merge octants.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于级别数据八叉树将保持只读状态，我们不需要更新或删除对象或合并八分体的方法。
- en: We handle only static data in the triangle octree, a search for intersections
    between triangles of the level does not return any useful information for us.
    So, the `findAllIntersections()` and `findIntersectionsInDescendants()` methods
    can be skipped too.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在三角形八叉树中，我们只处理静态数据，对同一级别的三角形进行交点搜索不会为我们提供任何有用的信息。因此，`findAllIntersections()`
    和 `findIntersectionsInDescendants()` 方法也可以省略。
- en: In addition to the reasons to use a separate octree for the level data mentioned
    in the *Adding a new octree type* section, we also use a different approach for
    objects not fitting in a single octant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 *添加新的八叉树类型* 部分中提到的使用单独八叉树存储级别数据的理由外，我们还为不适合单个八分体的对象使用不同的方法。
- en: In the instance octree, a bounding box of an instance will be only in rare cases
    larger than a single octant, for instance when an instance is scaled by a large
    factor. But within the level octree, the bounding box of many triangles may not
    fit into a single subdivided octant. The creator of a level will try to minimize
    the number of triangles in a level for good rendering performance, resulting in
    areas of the level made of only a few large triangles.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例八叉树中，实例的边界框只有在罕见情况下才会大于单个八分体，例如实例通过大因子缩放时。但在级别八叉树中，许多三角形的边界框可能无法适应单个细分八分体。级别的创建者会尝试最小化级别中的三角形数量，以获得良好的渲染性能，从而产生仅由少数大三角形组成的地形区域。
- en: 'We could overcome the size problem with one of the following three methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下三种方法之一克服大小问题：
- en: Keep a large triangle in the octant big enough to contain the entire triangle.
    This solution would store additional objects in a parent node, not only in a leaf.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持一个足够大的三角形在八分界中，以包含整个三角形。这种解决方案将在父节点中存储额外的对象，而不仅仅是叶子节点。
- en: Add the triangle to all affected subdivided octants. We would only have data
    in the leaves but would duplicate the triangle data in the worst case 8 times.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三角形添加到所有受影响的细分八分界中。我们只有在最坏的情况下才会重复8次三角形数据，但叶子节点中只有数据。
- en: Split the triangle on the octant boundaries and add only the sub-triangles to
    each octant. Again, we would have an additional triangle per affected octant,
    plus possible problems with rounding errors in the split lines.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在八分界线上分割三角形，并将子三角形添加到每个八分界中。同样，每个受影响的八分界将增加一个额外的三角形，并且可能在分割线上存在舍入误差的问题。
- en: To keep the code simple, we will use the first method and add any triangle exceeding
    the dimensions of a subdivided octant only in the parent octant.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码简单，我们将使用第一种方法，并且只在父八分界中添加超出细分八分界尺寸的任何三角形。
- en: 'We can achieve the storage process for oversized triangles with a two-step
    check in the `add()` and `split()` methods. First, we iterate over all child octants
    to find possible intersections of the triangle with the boundaries of the child
    octant:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`add()`和`split()`方法中进行两步检查来实现超大三角形的存储过程。首先，我们遍历所有子八分界以找到三角形与子八分界边界的可能交点：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we find an intersection with a child octant, we increment the `intersectingChildren`
    variable. Then, for the `add()` method, we check how many child octants the triangle
    would intersect. In case of more than one octant, the triangle is kept in the
    current octant:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与子八分界相交，我们增加`intersectingChildren`变量。然后，对于`add()`方法，我们检查三角形将与多少个子八分界相交。如果超过一个八分界，则保持三角形在当前八分界中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And if we found only an intersection with a single child octant, we hand over
    the triangle recursively to the child octant.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只与单个子八分界相交，我们将递归地将三角形交给子八分界。
- en: 'For the `split()` method, we do the same, and keep the triangle in the current
    octant if we find more than one intersection with the future child octants:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`split()`方法，我们做同样的事情，如果在当前八分界中找到与未来子八分界的多个交点，则保持三角形在当前八分界中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `query()` methods to query the triangle octree for collisions with a bounding
    box and `getTreeBoxes()` boxes to show octree debug lines remain the same as in
    the original octree, only the data type for the `private` `query()` method needs
    to be adjusted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查询三角形八叉树以检测与边界框的碰撞的`query()`方法和显示八叉树调试线的`getTreeBoxes()`方法与原始八叉树相同，只需调整`private`
    `query()`方法的数据类型。
- en: After the `TriangleOctree` is ready, we can add the level data to the new octree
    and query for the tree for collisions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TriangleOctree`准备就绪后，我们可以将级别数据添加到新的八叉树中，并查询树以检测碰撞。
- en: Filling the level data octree
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充级别数据八叉树
- en: 'Like the instance octree, we need to add the `TriangleOctree.h` header to the
    renderer header, and then add a new `private` member named `mTriangleOctree` and
    the two `private` methods `initTriangleOctree()` and `generateLevelOctree()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如同实例八叉树一样，我们需要将`TriangleOctree.h`头文件添加到渲染器头文件中，然后添加一个名为`mTriangleOctree`的新`private`成员和两个`private`方法`initTriangleOctree()`和`generateLevelOctree()`：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To have default values for threshold and depth and to be able to control the
    settings via UI later, two new variables named `rdLevelOctreeThreshold` and `rdLevelOctreeMaxDepth`
    are stored in the `OGLRenderData` `struct` in the `OGLRenderData.h` file in the
    `opengl` folder:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有默认的阈值和深度值，并且能够通过UI稍后控制设置，在`opengl`文件夹中的`OGLRenderData.h`文件中的`OGLRenderData`
    `struct`中存储了两个新变量`rdLevelOctreeThreshold`和`rdLevelOctreeMaxDepth`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, for Vulkan, the two variables are added to the `VkRenderData` `struct`
    in the `VkRenderData.h` file in the `vulkan` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，在`vulkan`文件夹中的`VkRenderData.h`文件中添加了两个变量到`VkRenderData` `struct`。
- en: 'During the `init()` method of the renderer, `initTriangleOctree()` is called
    to create an octree with the given threshold and maximum depth:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的`init()`方法中，调用`initTriangleOctree()`来创建具有给定阈值和最大深度的八叉树：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The world boundaries are updated during level `AABB` generation, so our triangle
    octree is exactly the same size as the level data after the level was loaded.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成级别AABB期间更新世界边界，因此我们的三角形八叉树在加载级别后与级别数据大小完全相同。
- en: Filling the level data octree is done in the `generateLevelOctree()` method.
    We just walk through the important parts here since the outer code is only a loop
    over all levels in the `micLevels` vector of the `ModelInstanceCamData` struct.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`generateLevelOctree()`方法中完成填充级别数据八叉树。我们在这里只是走过重要的部分，因为外部代码只是遍历`ModelInstanceCamData`结构体中的`micLevels`向量的所有级别。
- en: 'For every level in `micLevels`, we get the level meshes in the form of optimized
    meshes for drawing the level. Then, we iterate over all the indices of the level
    mesh:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`micLevels`中的每个级别，我们以绘制级别的优化网格形式获取级别网格。然后，我们遍历级别网格的所有索引：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For Vulkan, the `levelMeshes` vector will contain the `VkMesh` data type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，`levelMeshes`向量将包含`VkMesh`数据类型。
- en: We must use the indices to draw the triangles since the triangle data is stored
    based on indices; using the vertices directly would not give us the correct information
    to deduce the triangles’ vertices. We also retrieve the world and normal transformation
    matrices from the level. The normal transformation matrix is just the transpose
    of the inverse world transform matrix, the `getNormalTransformMatrix()` method
    has been added to keep the additional transformations in the `AssimpLevel` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用索引来绘制三角形，因为三角形数据是根据索引存储的；直接使用顶点将不会给我们提供正确的信息来推断三角形的顶点。我们还从级别中检索世界和法线变换矩阵。法线变换矩阵只是世界变换矩阵的逆矩阵的转置，已经添加了`getNormalTransformMatrix()`方法来保持`AssimpLevel`类中的额外变换。
- en: 'Next, we create an empty `MeshTriangle` and use the transformation matrix of
    the level to transform the level vertices to the world position:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个空的`MeshTriangle`并使用级别的变换矩阵将级别顶点变换到世界位置：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now it is time to create the boundaries for each triangle:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为每个三角形创建边界了：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using an `AABB` makes it easy to calculate the bounding box coordinates. From
    this `AABB`, we create a `BoundingBox3D` and store the result in the `boundingBox`
    member of the `MeshTriangle` `struct`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AABB`可以轻松计算边界框坐标。从这个`AABB`中，我们创建一个`BoundingBox3D`并将结果存储在`MeshTriangle` `struct`的`boundingBox`成员中：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding a small offset is needed to keep triangles that are coplanar to one of
    the `X`, `Y`, or `Z` planes in the level. Without the offset, the dimension for
    the bounding box of a triangle could become zero in one or more dimensions, making
    it impossible for us to detect collisions with that triangle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持与`X`、`Y`或`Z`平面共面的三角形，需要添加一个小偏移量。如果没有偏移量，三角形的边界框在某个或多个维度上的尺寸可能会变成零，这将使我们无法检测与该三角形的碰撞。
- en: 'Finally, we store and increment the debug index number and add the triangle
    to the level data octree:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们存储并增加调试索引号并将三角形添加到级别数据八叉树：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By calling `generateLevelOctree` whenever level data has been added or removed,
    we assure that our octree has the correct world positions for all triangles. The
    best way to achieve the update on level changes is to tie the octree update to
    the already implemented `AABB` update for level data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在添加或删除级别数据时调用`generateLevelOctree`，我们确保我们的八叉树具有所有三角形的正确世界位置。在级别变化时实现更新的最佳方式是将八叉树更新与已经实现的级别数据`AABB`更新绑定。
- en: 'To achieve this coupling, we add a new `private` method named `generateLevelVertexData()`
    and call `AABB` and octree generation there:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种耦合，我们添加了一个名为`generateLevelVertexData()`的新`private`方法，并在那里调用`AABB`和八叉树生成：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, all occurrences of `generateLevelAABB()` are replaced by the new `generateLevelVertexData()`
    method, and whenever the level data or other properties, such as rotation or scaling,
    are changed, the level octree is also updated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有`generateLevelAABB()`的出现都被新的`generateLevelVertexData()`方法所替换，并且每当级别数据或其他属性，如旋转或缩放，发生变化时，级别八叉树也会更新。
- en: With an up-to-date level octree, we can finally check if the instances collide
    with level geometry.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新的级别八叉树，我们最终可以检查实例是否与级别几何体发生碰撞。
- en: Detecting instance/level collisions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测实例/级别碰撞
- en: By using the same strategy as we used in the *Adding a quadtree to store nearby
    model instances* section in [*Chapter 8*](Chapter_8.xhtml), for instance/instance
    collisions, finding collisions between instances and level triangles is easy.
    All we must do is loop over all instances, get the bounding box of the instance,
    and query the triangle octree for collisions with that bounding box. The octree
    delivers us all the triangles where the bounding box of the triangle collides
    with the bounding box of the instance, even if the instance is not stored inside
    the triangle octree.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与我们在[*第8章*](Chapter_8.xhtml)中“添加四叉树以存储附近的模型实例”部分相同的策略，对于实例/实例碰撞，找到实例与关卡三角形的碰撞很容易。我们只需遍历所有实例，获取实例的边界框，并查询三角形八叉树以获取与该边界框的碰撞。八叉树为我们提供了所有三角形，其中三角形的边界框与实例的边界框发生碰撞，即使实例未存储在三角形八叉树中。
- en: 'To implement collision detection between instances and level data, follow these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现实例和关卡数据之间的碰撞检测，请按照以下步骤操作：
- en: 'First, we add a new member named `isCollidingTriangles` to the `InstanceSettings`
    `struct` in the `InstanceSettings.h` file to store the colliding triangles:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`InstanceSettings.h`文件中的`InstanceSettings` `struct`中添加一个新的成员`isCollidingTriangles`，用于存储碰撞的三角形：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, a new `public` method called `setCollidingTriangles()` of the `AssimpInstance`
    class is created, storing the incoming triangle data in the instance settings:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`AssimpInstance`类中创建一个新的`public`方法`setCollidingTriangles()`，将传入的三角形数据存储在实例设置中：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we create a new private method called `checkForLevelCollisions()` in
    the renderer. We start by getting the instance settings and skipping the null
    instance:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在渲染器中创建一个新的私有方法`checkForLevelCollisions()`。我们首先获取实例设置并跳过空实例：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we simply query the triangle octree with the bounding box of the instances:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们简单地使用实例的边界框查询三角形八叉树：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just knowing that we have collisions is nice, but we want to store the collision
    data for further actions, such as reacting to collisions or drawing debug lines.
    So, we store the vector of `MeshTriangles` in the instance settings:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅知道存在碰撞是好的，但我们希望存储碰撞数据以供进一步操作，例如响应碰撞或绘制调试线。因此，我们将`MeshTriangles`的向量存储在实例设置中：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method `checkForLevelCollisions()` is called to the `draw()` method of the
    renderer, after the instances have been rendered and before the UI is drawn. Now
    all instances are checked in every frame for collisions with the level geometry,
    and if colliding triangles were found, we store them in the `InstanceSettings`
    of the instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例渲染完毕且在UI绘制之前，调用`checkForLevelCollisions()`方法到渲染器的`draw()`方法。现在，每一帧都会检查所有实例与关卡几何体的碰撞，如果找到碰撞的三角形，我们将它们存储在实例的`InstanceSettings`中。
- en: Although you could have trust in the general functionality of collision detection
    to work, seeing is believing. We add extra debug lines for the various level data
    now, allowing us to draw viable information as overlaying lines on the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以信任碰撞检测的一般功能能够工作，但眼见为实。我们现在为各种关卡数据添加额外的调试线，允许我们在屏幕上作为叠加线绘制有效信息。
- en: Drawing debug lines
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制调试线
- en: 'If we would like to see the collisions in real time on the screen, we can highlight
    the affected triangles in the level geometry. To achieve this highlighting, we
    will follow these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在屏幕上实时看到碰撞，我们可以突出显示关卡几何体中受影响的三角形。为了实现这种突出显示，我们将遵循以下步骤：
- en: 'We add a new `private` member, `mLevelCollidingTriangleMesh`, to store the
    colliding triangle meshes to the renderer:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向渲染器添加一个新的`private`成员`mLevelCollidingTriangleMesh`，用于存储碰撞的三角形网格：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in `checkForLevelCollisions()`, we clear the mesh:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`checkForLevelCollisions()`中，我们清除网格：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we iterate over all colliding triangles, adding the vertices pairwise
    to the mesh storage to create a line for every side of the triangle:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有碰撞的三角形，将顶点成对添加到网格存储中，为三角形的每一边创建一条线：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have saved the outlines of the detected triangles for all instances.
    Rendering the triangles to the screen can be done with a simple line draw call:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经保存了所有实例检测到的三角形的轮廓。将三角形渲染到屏幕上可以通过简单的线绘制调用完成：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the application with instance/level collision and debug drawing results
    in a picture similar to *Figure 12.1*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有实例/关卡碰撞和调试绘制的应用程序，结果类似于*图12.1*：
- en: '![](img/figure_12_01.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_01.png)'
- en: 'Figure 12.1: Collision between an instance and the level geometry'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：实例与关卡几何体的碰撞
- en: In *Figure 12.1*, the instance collides with the ground and several walls. All
    the triangles were detected by using their bounding boxes, so don’t be alarmed
    if a triangle is highlighted while the instance is still a bit away from the triangle
    itself. In this case, the bounding box of the triangle was hit, spanning a larger
    area than the triangle itself. But the number of false positives among the detected
    collisions is low and may only affect the performance of the collision detection
    by a small amount.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.1*中，实例与地面和几堵墙发生了碰撞。所有三角形都是通过使用它们的边界框被检测到的，所以当实例仍然离三角形本身有点距离时，如果三角形被高亮显示，请不要感到惊讶。在这种情况下，三角形的边界框被击中，覆盖了一个比三角形本身更大的区域。但是，检测到的碰撞中的误报数量很低，可能只会对碰撞检测的性能产生很小的影响。
- en: To add a proper reaction of the instance to a collision with the level geometry,
    we will enhance the node tree next.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让实例对与关卡几何形状的碰撞有适当的反应，我们将增强节点树。
- en: Extending the node tree to support level geometry collisions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展节点树以支持关卡几何形状碰撞
- en: 'Thanks to the good foundation built in the last chapters, adding a new collision
    type takes a matter of minutes by following these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢在前几章中建立的良好基础，通过遵循这些步骤，添加新的碰撞类型只需几分钟：
- en: 'First, we add the new event type to the `nodeEvent` `enum` in the `Enums.h`
    file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将新的事件类型添加到`Enums.h`文件中的`nodeEvent` `enum`：
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also add some text to the `micNodeUpdateMap` during the `init()` method
    of the renderer to add a name in the node tree:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在渲染器的`init()`方法期间向`micNodeUpdateMap`添加了一些文本，以便在节点树中添加一个名称：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in `checkForLevelCollisions()`, trigger the new event if we have at least
    one colliding triangle:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`checkForLevelCollisions()`函数中，如果有至少一个碰撞的三角形，就触发新的事件：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The event informs the node tree of the instance that a collision with level
    geometry occurred. As an example, we could just let the instance turn around by
    180 degrees, as shown in *Figure 12.2*:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件通知实例节点发生了与关卡几何形状的碰撞。例如，我们可以让实例通过180度转身，如图*图12.2*所示：
- en: '![](img/figure_12_02.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2](img/figure_12_02.png)'
- en: 'Figure 12.2: An Event node reacting to instance/level collisions'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：一个响应实例/关卡碰撞的事件节点
- en: In the Event node in *Figure 12.2*, the instance would instantly turn around
    when running into a collision with the level. Also, a cooldown of 250 milliseconds
    has been added. Using a cooldown should give the instance a bit of time to walk
    far enough away from the affected level geometry to avoid immediately re-triggering
    a level collision.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.2*中的事件节点中，实例在遇到关卡碰撞时会立即转身。此外，还添加了250毫秒的冷却时间。使用冷却时间应该会给实例一些时间，让它足够远离受影响的关卡几何形状，以避免立即重新触发关卡碰撞。
- en: 'But right now, collision detection has a huge drawback: the instances keep
    walking at the same height level, thus running through hills or walking in the
    air when the elevation changes.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前，碰撞检测有一个巨大的缺点：实例始终在相同的高度水平上行走，因此在海拔变化时，会穿过山丘或在空中行走。
- en: To keep the instances on the ground, let’s add a simple form of gravity to the
    application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让实例保持在地面，让我们给应用程序添加一种简单的重力形式。
- en: Using gravity to keep the instances on the floor
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用重力来保持实例在地板上
- en: Gravity is literally always around us, accelerating objects downwards until
    they hit some other, immovable object, such as the ground. We mostly don’t realize
    the effects of gravity while walking around or standing still; we only realize
    its power when something falls down and most probably breaks when it hits the
    ground.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重力实际上始终在我们周围，加速物体向下直到它们撞击某个其他不可移动的物体，例如地面。我们在四处走动或站立时通常不会意识到重力的作用；我们只有在某物掉落并很可能在撞击地面时破碎时才会意识到它的力量。
- en: Before we can add gravity, we need to find a way to detect if a triangle in
    the level geometry belongs to the ground or not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以添加重力之前，我们需要找到一种方法来检测关卡几何形状中的三角形是否属于地面。
- en: Finding ground triangles in level data
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在关卡数据中找到地面三角形
- en: For real-world levels, extra attributes could be used to mark areas of a level
    as walkable or not. Since we want to keep the ground-level technique as generic
    as possible, we will use a different approach and use the triangle normal to check
    if the area around us belongs to the floor or a wall, and up to which angle a
    sloped area can be walked on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界的关卡，可以使用额外的属性来标记关卡区域是否可通行。由于我们希望将地面级别的技术尽可能通用，我们将采用不同的方法，并使用三角形的法线来检查我们周围的区域是否属于地板或墙壁，以及斜面区域可以行走到哪个角度。
- en: 'We store the `normal` of each triangle as 3-element vector inside the `MeshTriangle`
    `struct`, along with the other triangle data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个三角形的`normal`作为3元素向量存储在`MeshTriangle` `struct`中，以及其他三角形数据：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When generating the triangle octree in `generateLevelOctree()`, the normal
    from the first vertex of the triangle is taken:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`generateLevelOctree()`中生成三角形八叉树时，取三角形第一个顶点的法线：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Due to the indexed structure of the level data, using one of the normals of
    the vertices could lead to artifacts caused by reusing the same vertex for different
    triangles. In this case, we could alter the calculation of the normal to be the
    cross product of two edges of every triangle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于级别数据的索引结构，使用顶点的一个法线可能会导致由于为不同的三角形重复使用相同的顶点而产生的伪影。在这种情况下，我们可以改变法线的计算方法，使其成为每个三角形两条边的叉积：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To be able to control the ground slope in the user interface, we add a new
    variable called `rdMaxLevelGroundSlopeAngle` to the `OGLRenderData` `struct`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在用户界面中控制地面坡度，我们在`OGLRenderData` `struct`中添加了一个名为`rdMaxLevelGroundSlopeAngle`的新变量：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For Vulkan, as always, the variable will be added to the `VkRenderData` `struct`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，像往常一样，变量将被添加到`VkRenderData` `struct`中。
- en: 'Then, in `checkForLevelCollisions()`, we add a new check to find out if the
    angle between an upward-pointing vector and the normal of the triangle is larger
    than the maximum configurable ground slope:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`checkForLevelCollisions()`中，我们添加了一个新的检查，以确定向上指向的向量与三角形法线之间的角度是否大于可配置的最大地面坡度：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the `if` block, we can now limit the event sending code to be triggered
    only for walls, no longer for ground triangles. We also change the color of the
    debug lines for triangles detected as ground triangles to blue while wall triangles
    remain red:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部，我们现在可以将事件发送代码的限制条件改为仅触发墙壁，而不是地面三角形。我们还更改了检测为地面三角形的三角形的调试线条颜色为蓝色，而墙壁三角形的颜色保持为红色：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the **Levels...** section of the `UserInterface` class, we add a float slider
    to enable controlling the maximum ground slope interactively:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserInterface`类的**级别...**部分，我们添加了一个浮点滑块以交互式地控制最大地面坡度：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now the application draws collisions with walls and ground in different colors,
    as shown in *Figure 12.3*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序以不同的颜色绘制墙壁和地面碰撞，如图*图12.3*所示：
- en: '![](img/figure_12_03.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_03.png)'
- en: 'Figure 12.3: Separate collisions for ground and walls'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：地面和墙壁的独立碰撞
- en: As you can see in *Figure 12.3*, wall collisions are now marked by red triangle
    edges, while ground collisions are highlighted by blue triangle edges. The slope
    angle can be configured by a slider, allowing finetuning of which slope of a hill
    or edge will be still seen as the ground.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图12.3*所示，墙壁碰撞现在由红色三角形边缘标记，而地面碰撞则由蓝色三角形边缘突出显示。可以通过滑块配置斜率角度，允许微调哪些斜坡或边缘仍被视为地面。
- en: In addition to the distinct colors for collisions between instances and walls
    or the ground, the event reporting also differs. For a ground collision, no instance/level
    geometry collision event will be generated, allowing the instances to run around
    in the level and only collide with walls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例与墙壁或地面之间的碰撞具有不同的颜色之外，事件报告也有所不同。对于地面碰撞，不会生成实例/级别几何碰撞事件，允许实例在级别中运行并仅与墙壁发生碰撞。
- en: After we can check if an instance collides with a ground polygon, it’s time
    to add the gravity to the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以检查实例是否与地面多边形发生碰撞后，是时候将重力添加到代码中。
- en: Adding basic gravity
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加基本重力
- en: For our application, we are using only simple gravity. We just move the instance
    down by some amount every frame, without thinking about more complex patterns,
    such as acceleration over time. If you want to implement more details, the *Addition
    resources* section contains the ISBNs of books that dive into advanced physics
    and collision detection topics. Also, a task in the *Practical sessions* section
    implements enhanced gravity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们只使用简单的重力。我们只是在每一帧中将实例向下移动一定的距离，而不考虑更复杂的模式，例如随时间变化的加速度。如果你想实现更多细节，*附加资源*部分包含了深入探讨高级物理和碰撞检测主题的书籍的ISBN。此外，*实践环节*部分的一个任务实现了增强重力。
- en: 'To be able to add a gravity effect to an instance, we create a new `public`
    method named `applyGravity()` to the `AssimpInstance` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够向实例添加重力效果，我们在`AssimpInstance`类中创建了一个名为`applyGravity()`的新`public`方法：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The private variable `GRAVITY_CONSTANT` is defined in the `AssimpInstance.h`
    header and set to `9.81`, similar to the real gravity on earth. The gravity is
    then applied in the instances loop in the `draw()` method of the renderer:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssimpInstance.h`头文件中定义了私有变量`GRAVITY_CONSTANT`并将其设置为`9.81`，类似于地球上的真实重力。然后，在渲染器的`draw()`方法中的实例循环中应用重力：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `rdEnableSimpleGravity` variable has been added to the `OGLRenderData` `struct`
    in the `OGLRenderData.h` file for OpenGL, and to the `VkRenderData` `struct` in
    the `VkRenderData.h` header for Vulkan.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OGLRenderData.h`文件中，为OpenGL添加了`rdEnableSimpleGravity`变量到`OGLRenderData` `struct`，在`VkRenderData.h`头文件中为Vulkan添加了到`VkRenderData`
    `struct`。
- en: 'In the **Levels...** collapsing header of the `createFrame()` method in the
    `UserInterface` class, a checkbox is used to control the gravity:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserInterface`类的`createFrame()`方法的`Levels...`折叠标题中，使用复选框来控制重力：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will use this checkbox to prevent all instances from falling when no level
    geometry is loaded.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个复选框来防止在没有加载级别几何体时所有实例掉落。
- en: One last step is needed to enable instances to roam around on the floor of the
    levels. Let’s create the final parts of the code the finish the ground handling
    for the instances.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使实例能够在级别的地板上四处游走。让我们创建代码的最终部分来完成实例的地面处理。
- en: Keeping the instances on the ground triangles
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持实例在地面三角形上
- en: With the code from the previous sections of this chapter, we can detect collisions
    between instances and level walls and floors and the handle wall collision. For
    ground collisions, we need special handling since the instance will, most of the
    time, stay on the floor of the level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章前面部分的代码，我们可以检测实例与级别墙壁和地板之间的碰撞，并处理墙壁碰撞。对于地面碰撞，我们需要特殊处理，因为实例大多数时候将停留在级别的地板上。
- en: A naive idea for ground collision would be to move the instance upward a bit
    after gravity is applied. Sadly, applying gravity and moving the instance back
    leads to oscillations if the amounts of vertical movement are not identical. But
    instead of moving the instance up, we can avoid applying gravity in the first
    place, leaving the instance on the ground triangle once the collision is detected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地面碰撞的一个简单想法是在应用重力后向上移动实例一点。遗憾的是，如果垂直移动量不相同，应用重力并将实例移回会导致振荡。但我们可以避免首先应用重力，一旦检测到碰撞，就将实例留在地面三角形上。
- en: 'The functionality to keep instances on the ground triangles of the level will
    be implemented by the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤实现保持实例在级别地面三角形上的功能：
- en: 'For every instance, we store the “on ground” state by using a new Boolean variable
    named `isInstanceOnGround` in the `InstanceSettings` `struct` in the `InstanceSettings.h`
    file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个实例，我们使用名为`isInstanceOnGround`的新布尔变量在`InstanceSettings.h`文件中的`InstanceSettings`
    `struct`中存储“在地面上”的状态：
- en: '[PRE35]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `AssimpInstance` class, a `public` setter for the state will be added
    too:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssimpInstance`类中，也将添加一个`public`的设置器用于状态：
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we update the `applyGravity()` method to disable adding the gravity to
    the vertical position if the instance is found to reside on the ground:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们更新`applyGravity()`方法，如果发现实例位于地面上，则禁用在垂直位置添加重力：
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To set the `isInstanceOnGround` instance variable in the renderer, a new checking
    code will be added to the `draw()` method of the renderer, right below the `query()`
    call to the triangle octree. This way, we make sure we are using the most recent
    triangle colliding data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染器中设置`isInstanceOnGround`实例变量，需要在渲染器的`draw()`方法中添加新的检查代码，紧接在调用三角形八叉树的`query()`方法下方。这样，我们确保使用的是最新的三角形碰撞数据。
- en: 'First, we set the local `instanceOnGround` Boolean to `true`, which prevents
    instances from falling if the gravity is disabled. Next, we calculate the gravity
    with the same formula as the instance, and we initialize the current `footPoint`
    of the instance with the world position:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将局部`instanceOnGround`布尔值设置为`true`，这样如果禁用重力，实例将不会掉落。接下来，我们使用与实例相同的公式计算重力，并将实例的当前`footPoint`初始化为世界位置：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need the foot point in the next step to have a valid position for the instance
    in case the ground detection fails.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们需要脚点有一个有效的位置，以防地面检测失败。
- en: 'Now, we set `instanceOnGround` to false as the default setting for ground-level
    detection, and we iterate over all colliding triangles:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将`instanceOnGround`设置为默认设置`false`用于地面级检测，并遍历所有碰撞的三角形：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, the same angle check between the normal vector of the triangle and an
    upwards pointing vector as in `checkForLevelCollisions()` is used to find out
    if the triangle is a ground triangle and thus considered walkable:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用与`checkForLevelCollisions()`中相同的检查角度，检查三角形的法向量与一个向上指的向量之间的角度，以确定三角形是否是地面三角形，从而被认为是可走的：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the triangle is walkable ground, we try to get the intersection between
    a virtual ray pointing upwards, originating from the instance after it has already
    been sunk slightly into the ground:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果三角形是可走的地面，我们尝试获取一个虚拟射线与地面的交点，该射线从实例向上指，且实例已经稍微沉入地面：
- en: '[PRE41]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Checking the instance after applying the gravity value is required because no
    collision will be reported if the instance is exactly at the same level as the
    ground triangle.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用重力值后检查实例是必要的，因为如果实例与地面三角形完全处于同一水平，则不会报告任何碰撞。
- en: The helper function `rayTriangleIntersection()` in the `Tools` class implements
    the Möller-Trumbore algorithm to find an intersection between a ray and a triangle.
    This algorithm detects if a ray intersects the triangle and returns the exact
    point of the intersection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tools`类中的辅助函数`rayTriangleIntersection()`实现了Möller-Trumbore算法，以找到射线和三角形之间的交点。该算法检测射线是否与三角形相交，并返回交点的确切位置。'
- en: 'A visualization of the algorithm is shown in *Figure 12.4*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.4*中展示了算法的可视化：
- en: '![](img/figure_12_04.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_04.png)'
- en: 'Figure 12.4: Visualization of the Möller-Trumbore algorithm'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：Möller-Trumbore算法的可视化
- en: The Möller-Trumbore algorithm uses the barycentric coordinates of the triangle
    created by the three vertices `V0`, `V1`, and `V2` to check if the ray is inside
    or outside of the triangle. To simplify the detection process, the algorithm transforms
    both the triangle vertices and the ray so that two of the triangle sides are mapped
    to the `X` and `Y` axes of the Cartesian coordinate system, defining a unit triangle.
    The barycentric coordinates of the intersection point stay intact during these
    transformations. The final test for intersection just needs to check if the `x`
    and `y` coordinates of the intersection point are inside the triangle by testing
    for valid barycentric coordinates. A link to the mathematical backgrounds of the
    algorithm is available in the *Additional resources* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Möller-Trumbore算法使用由三个顶点`V0`、`V1`和`V2`创建的三角形的重心坐标来检查射线是否在三角形内部或外部。为了简化检测过程，该算法将三角形顶点和射线都进行了转换，使得三角形的两个边映射到笛卡尔坐标系统的`X`和`Y`轴上，定义了一个单位三角形。交点的重心坐标在这些转换过程中保持不变。最终测试交点只需要检查交点的`x`和`y`坐标是否在三角形内部，通过测试有效的重心坐标来完成。在*附加资源*部分提供了一个链接，可以了解该算法的数学背景。
- en: 'As the last step in the `draw()` call part of the new renderer code, we set
    the ground flag to the instance and apply the gravity:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新渲染器代码的`draw()`调用部分的最后一步，我们将地面标志设置为实例并应用重力：
- en: '[PRE42]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The extra check for `rdEnableSimpleGravity` around `applyGravity()` that was
    added in the *Adding basic gravity* section can be removed. We already ensure
    that no gravity will be added if `rdEnableSimpleGravity` is `false` by setting
    the default value of `instanceOnGround` to `true`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加基本重力”部分添加的针对`rdEnableSimpleGravity`的额外检查可以在`applyGravity()`周围被移除。我们通过将`instanceOnGround`的默认值设置为`true`，已经确保如果`rdEnableSimpleGravity`为`false`时不会添加重力。
- en: 'Running the application with collision triangle debug draw enabled and the
    ground slope adjusted will result in an image similar to *Figure 12.5*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用碰撞三角形调试绘制并调整地面坡度的情况下运行应用程序，将得到类似于*图12.5*的图像：
- en: '![](img/figure_12_05.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_05.png)'
- en: 'Figure 12.5: Instances walking at different heights of the level'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：不同高度的层级上的实例行走
- en: In *Figure 12.5*, we can see that the instances are walking on their own level,
    with the left instance climbing up a small slope. In the running application,
    you will see that climbing down a hill is also working as expected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.5*中，我们可以看到实例正在它们自己的层级上行走，左侧的实例正在爬上一个小的斜坡。在运行的应用程序中，你将看到下山也是按预期工作的。
- en: 'After level gravity is enabled, the instances are running on the level floor.
    But on an uneven floor, one either intersects with the floor when going up a hill,
    or one of the feet is still in the air when going down a slope. You can see this
    effect on the right foot of the left instance: the entire foot is clipping into
    the ground triangle.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用水平重力后，实例在水平地面上运行。但在不平的地面上，一个实例在爬坡时可能会与地面相交，或者在下坡时其中一只脚仍然悬在空中。你可以在左侧实例的右脚上看到这个效果：整个脚都嵌入到地面三角形中。
- en: Let’s fix the instance feet by adding inverse kinematics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加逆向运动学来固定实例的脚。
- en: Adding inverse kinematics
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加逆向运动学
- en: The word “kinematics” is defined as the mechanics behind the motion of an object,
    but without referencing the forces that cause this motion. So, every part of our
    daily motion can be described in terms of kinematics as the movement of our bones.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “运动学”这个词被定义为物体运动背后的力学，但不涉及引起这种运动的力量。因此，我们日常的每一个动作都可以用运动学的术语来描述，即我们骨骼的运动。
- en: The two types of kinematics
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种类型的运动学
- en: 'The type of animation of our characters in the previous chapters is called
    **forward kinematics**. An example of forward kinematics is shown in *Figure 12.6*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前章节中我们角色的动画类型被称为 **正向运动学**。正向运动学的例子在 *图 12.6* 中展示：
- en: '![](img/figure_12_06.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6](img/figure_12_06.png)'
- en: 'Figure 12.6: Raising the hand of the simple skeleton by using Forward Kinematics'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：通过正向运动学抬起简单骨骼的手
- en: The skeleton in *Figure 12.6* raises its simplified hand by rotating at bone
    number one, the shoulder, and number two, the elbow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.6* 中的骨骼通过在第一根骨头（肩部）和第二根骨头（肘部）旋转来抬起其简化的手。'
- en: During the movement or rotation of the skeletal bone, all the other nodes attached
    to it are also affected. Rotating the arm around the shoulder does not change
    the elbow or the forearm, as we only change one bone at a time. Next, the forearm
    is rotated around the elbow, bringing the hand to the final position. This final
    position of the hand is defined by the concatenation of the changes of all the
    bones before the hand.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在骨骼骨的运动或旋转过程中，所有连接到它的其他节点也会受到影响。围绕肩部旋转手臂不会改变肘部或前臂，因为我们一次只改变一根骨头。接下来，前臂围绕肘部旋转，将手带到最终位置。手的这个最终位置是由手之前所有骨骼的变化的连接定义的。
- en: But… what happens if we only know the desired final position of the hand?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……如果我们只知道手期望的最终位置会怎样？
- en: If we want to move the hand of the skeleton in *Figure 12.7* to the green target
    point, or we want to put the foot onto the green target block, our only option
    with forward kinematics would be trial and error.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将 *图 12.7* 中的骨骼手移动到绿色目标点，或者想将脚放到绿色目标块上，使用正向运动学我们唯一的选项就是试错。
- en: '![](img/figure_12_07.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7](img/figure_12_07.png)'
- en: 'Figure 12.7: How to move the hand to the target, or put the foot on the box?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：如何将手移动到目标点，或者将脚放到盒子上？
- en: We would have to adjust all the nodes on the arm or the leg over and over again
    until we reach a matching position. This is where **inverse kinematics** comes
    into play. Instead of rotating the nodes directly, we calculate bone positions
    matching the final movement and read the node rotations from the final bone positions,
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要反复调整手臂或腿上的所有节点，直到达到匹配的位置。这就是 **逆向运动学** 发挥作用的地方。我们不是直接旋转节点，而是计算与最终运动匹配的骨骼位置，并从最终骨骼位置读取节点旋转，
- en: In inverse kinematics, the name **effector** is used to describe the part of
    the skeleton that should reach the **target**. If the target is too far away to
    be reached by the effector node, we should at least try to find a position as
    close as possible to the target. In addition to effector and target, a **root
    node** must be chosen. The root node is the first unchanged node of the skeleton.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在逆向运动学中，**执行器**这个名词用来描述骨骼中应该到达 **目标** 的部分。如果目标太远，执行器节点无法触及，我们至少应该尝试找到一个尽可能接近目标的位置。除了执行器和目标之外，还必须选择一个
    **根节点**。根节点是骨骼的第一个未改变的节点。
- en: 'Although many inverse kinematics solver algorithms have been created, we will
    use one of the basic algorithms: FABRIK, the **Forward And Backward Reaching Inverse
    Kinematics** solver. FABRIK is easy to understand and implement and finds good
    solutions for the nodes. So, let’s dive into inverse kinematics with FABRIK.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然已经创建了多种逆向运动学求解器算法，但我们将使用其中一种基本算法：FABRIK，即 **正向和反向到达逆向运动学** 求解器。FABRIK 容易理解且易于实现，并且为节点找到良好的解决方案。因此，让我们通过
    FABRIK 深入了解逆向运动学。
- en: Understanding the FABRIK basics
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 FABRIK 基础知识
- en: FABRIK was introduced in 2011 by Dr. Andreas Aristidou. The FABRIK algorithm
    solves the inverse kinematics problem by moving the nodes of a bone chain one
    by one closer to the target and then rescaling the bones back to the original
    length. Also, FABRIK moves along the chain of bones in both directions, forward
    and backward, hence its name.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法由Andreas Aristidou博士于2011年提出。FABRIK算法通过逐个移动骨骼链的节点，使其逐渐接近目标，然后重新缩放骨骼回到原始长度来解决逆运动学问题。此外，FABRIK沿着骨骼链在两个方向上移动，即正向和反向，因此得名。
- en: We will use a simple robotics arm to describe the steps to solve an inverse
    kinematics problem with FABRIK. Four nodes of the arm define three bones, and
    the target and the effector were drawn in every step, with the blue node attached
    to the ground as the root node and the outer red node used as the effector. All
    the steps are shown in *Figure 12.8* to *Figure 12.11*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的机器人臂来描述使用FABRIK解决逆运动学问题的步骤。手臂的四个节点定义了三个骨骼，目标和效应节点在每一步都被绘制出来，蓝色节点连接到地面作为根节点，外部的红色节点用作效应节点。所有步骤都显示在*图12.8*到*图12.11*中。
- en: Let’s step through a single iteration of the algorithm. First, we will examine
    the *forward* solving part of FABRIK.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析算法的单次迭代。首先，我们将检查FABRIK的*正向*求解部分。
- en: '![](img/figure_12_08.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_08.png)'
- en: 'Figure 12.8: Doing inverse kinematics using FABRIK forward iteration – part
    1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：使用FABRIK正向迭代进行逆运动学计算 – 第1部分
- en: 'The start situation is shown in *Figure 12.8* (**1**):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 起始情况如*图12.8*（**1**）所示：
- en: As shown in *Figure 12.8* (**2**), we will *move* the effector to the position
    of the target as the first step. You can see that moving the node stretches the
    red bone far beyond its original length.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图12.8*（**2**）所示，我们将第一步*移动*效应节点到目标的位置。你可以看到移动节点会使红色骨骼远远超出其原始长度。
- en: We must correct the length of the red bone, so we need to save the length of
    our bone before moving the effector. By using the saved length, we scale the red
    bone back to its original length, right after the effector has been moved, as
    shown in *Figure 12.8* (**3**). Scaling back the red bone to the previous length
    rips apart our robotics arm, as seen in *Figure 12.8* (**3**), but this is an
    intended behavior during a FABRIK iteration.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须纠正红色骨骼的长度，因此我们需要在移动效应节点之前保存骨骼的长度。通过使用保存的长度，我们将红色骨骼缩回到原始长度，正如*图12.8*（**3**）所示。将红色骨骼缩回到之前的长度会撕裂我们的机器人臂，正如*图12.8*（**3**）所示，但在FABRIK迭代过程中这是一种预期的行为。
- en: Then, we will move the outer node of the purple bone back to the end of the
    red bone, scaling it again to an arbitrary length. *Figure 12.8* (**4**) shows
    the result after the robotics arm has been reconnected.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将紫色骨骼的外节点移回到红色骨骼的末端，再次将其缩放到任意长度。*图12.8*（**4**）显示了在机器人臂重新连接后的结果。
- en: The purple bone is scaled back to its previous length, as shown in *Figure 12.9*
    (**5**), moving the end node away from the blue bone.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紫色骨骼缩回到其之前的长度，如*图12.9*（**5**）所示，将末端节点移离蓝色骨骼。
- en: '![](img/figure_12_09.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_09.png)'
- en: 'Figure 12.9: Inverse kinematics using FABRIK forward iteration – part 2'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：使用FABRIK正向迭代进行逆运动学计算 – 第2部分
- en: Finally, we will repeat *steps 4* and *5* of the purple bone movement with the
    blue bone. We will reconnect the arm every time and scale the bone back to its
    original length, as shown in *Figure 12.9* (**6**) and *Figure 12.9* (**7**).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将重复紫色骨骼移动的*步骤4*和*步骤5*，使用蓝色骨骼。我们将在每次重新连接手臂并将骨骼缩回到原始长度，正如*图12.9*（**6**）和*图12.9*（**7**）所示。
- en: '*Figure 12.9* (**8**) shows the result after the *forward* steps of the FABRIK
    algorithm are finished. But having the robotic arm disconnected from the ground
    is not the result we want. To fix the arm, we will repeat the same steps, but
    this time *backward* on the same chain of bones.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.9*（**8**）显示了FABRIK算法的*正向*步骤完成后得到的结果。但是，机器人臂与地面断开连接并不是我们想要的结果。为了修复手臂，我们将重复相同的步骤，但这次是在同一骨骼链上*反向*进行。'
- en: In the *backward* part of FABRIK, we will swap the target, effector node, and
    root node. We use the original connection point of the arm as the target, the
    end of the blue bone becomes the effector, and the original effector node is the
    new root node.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在FABRIK的*反向*部分，我们将交换目标节点、效应节点和根节点。我们使用手臂的原始连接点作为目标，蓝色骨骼的末端成为效应节点，原始效应节点成为新的根节点。
- en: As the first step in the backward operation, we will reconnect the arm to the
    ground, as shown in *Figure 12.10* (**9**).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反向操作的第一步，我们将手臂重新连接到地面，如*图12.10*（**9**）所示。
- en: '![](img/figure_12_10.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_10.png)'
- en: 'Figure 12.10: Inverse kinematics using FABRIK backward iteration – part 1'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：使用FABRIK向后迭代进行逆运动学 – 第1部分
- en: Then, we scale the blue bone back to its previous size and move the purple bone
    in the same way as we did initially in *steps 2* and *3*. In *Figure 12.10* (**10**),
    *Figure 12.10* (**11**), and *Figure 12.10* (**12**), the results of adjusting
    the blue and purple bones are shown.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将蓝色骨骼缩放到其原始大小，并以与最初在*步骤2*和*步骤3*中相同的方式移动紫色骨骼。在*图12.10*（**10**）、*图12.10*（**11**）和*图12.10*（**12**）中，展示了调整蓝色和紫色骨骼的结果。
- en: Now, the lower node of the red bone will move, and the red bone is scaled back
    to its previous size, as shown in *Figure 12.11* (**13**) and *Figure 12.11* (**14**).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，红色骨骼的较低节点将移动，红色骨骼缩回到其原始大小，如图*图12.11*（**13**）和*图12.11*（**14**）所示。
- en: '![](img/figure_12_11.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_11.png)'
- en: 'Figure 12.11: Inverse kinematics using FABRIK backward iteration - part 2'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：使用FABRIK向后迭代进行逆运动学 – 第2部分
- en: '*Figure 12.11* (**14**) moves the effector away from the position of the target,
    but again, this is the intended behavior in FABRIK if the target cannot be reached.
    In *Figure 12.11* (**15**), a single FABRIK iteration has ended.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.11*（**14**）将执行器从目标位置移开，但再次强调，这是FABRIK中目标无法到达时的预期行为。在*图12.11*（**15**）中，一个FABRIK迭代已经结束。'
- en: For the next iterations of FABRIK, *steps 2* to *9* are repeated until the effector
    node reaches the target position, or until we hit the maximum number of iterations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FABRIK的后续迭代，重复*步骤2*到*步骤9*，直到执行器节点达到目标位置，或者达到最大迭代次数。
- en: 'By using simple pseudo-code, FABRIK can be melted down to this procedure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用简单的伪代码，FABRIK可以简化为以下过程：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `SolveForward` and `SolveBackwards` methods are similar, so we can look
    only at pseudo-code for the forward-solving part of FABRIK:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`SolveForward`和`SolveBackwards`方法类似，所以我们只需查看FABRIK前向求解部分的伪代码：'
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The backward-solving part just starts with the saved root node position and
    iterates over the bones in the opposite direction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 向后求解部分仅从保存的根节点位置开始，以相反的方向遍历骨骼。
- en: As you can see, the number of steps is small and the actions in these steps
    are simple. Armed with the new knowledge, let’s add a FABRIK solver.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，步骤数量很少，这些步骤中的动作也很简单。掌握了新知识后，让我们添加一个FABRIK求解器。
- en: Implementing the FABRIK inverse kinematics algorithm
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现FABRIK逆运动学算法
- en: 'The inverse kinematics solver using the FABRIK algorithm is implemented by
    the following steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FABRIK算法的逆运动学求解器通过以下步骤实现：
- en: For the FABRIK inverse kinematics solver, we create a new class, `IKSolver`,
    by adding the `IKSolver.h` and `IKSolver.cpp` files to the `tools` folder.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于FABRIK逆运动学求解器，我们在`tools`文件夹中添加`IKSolver.h`和`IKSolver.cpp`文件来创建一个新的类`IKSolver`。
- en: 'Next to the constructor and a setter for the number of iterations, a `public`
    method named `solveFABRIK()` is added:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了构造函数和设置迭代次数的setter外，还添加了一个名为`solveFABRIK()`的`public`方法：
- en: '[PRE45]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We also add the two `private` members, `mNodePositions` and `mBoneLengths`,
    and three private methods, `solveFABRIKForward()`, `solveFABRIKBackwards()`, and
    `calculateOrigBoneLengths()`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了两个`private`成员`mNodePositions`和`mBoneLengths`，以及三个`private`方法`solveFABRIKForward()`、`solveFABRIKBackwards()`和`calculateOrigBoneLengths()`：
- en: '[PRE46]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In `mNodePositions`, we store the world positions of the nodes during calculation,
    and in `mBoneLengths`, the required original bone lengths are saved. The name
    of the `calculateOrigBoneLengths()` method speaks for itself; we don’t need to
    dive into details there. But let’s do a quick walkthrough of the three remaining
    methods.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mNodePositions`中，我们存储计算过程中节点的世界位置，在`mBoneLengths`中保存所需的原始骨骼长度。`calculateOrigBoneLengths()`方法的名字本身就说明了问题；我们不需要深入细节。但让我们快速浏览一下剩下的三个方法。
- en: 'The forward part of FABRIK is handled in `solveFABRIKForward()`. First, we
    set the first element of `mNodePositions` to the target position:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FABRIK的前向部分由`solveFABRIKForward()`处理。首先，我们将`mNodePositions`的第一个元素设置为目标位置：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Then we loop over the remaining nodes, calculate the new direction of the bone
    after moving the previous node, and calculate the new position of the node by
    using the original length. Finally, we move the node to the new position, retaining
    the length.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们遍历剩余的节点，在移动前一个节点后计算骨骼的新方向，并使用原始长度计算节点的新位置。最后，我们将节点移动到新位置，保持长度不变。
- en: 'In `solveFABRIKBackwards()`, we do the same operations as in *steps 5 and 6*
    but in the opposite direction along the node chain. We start with the root node
    position as the target and adjust the node positions one by one:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`solveFABRIKBackwards()`中，我们执行与*步骤5和6*相同的操作，但沿着节点链相反的方向。我们以根节点位置为目标，逐个调整节点位置：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last method, `solveFARBIK()`, is used to control the iterations of FABRIK
    plus the comparison of the effector and target positions. We start with a simple
    check for an empty node matrix vector. In this case, we return an empty vector:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个方法`solveFARBIK()`用于控制FABRIK的迭代以及效应节点和目标位置的比较。我们从一个简单的空节点矩阵向量的检查开始。在这种情况下，我们返回一个空向量：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we resize and fill the `mNodePositions` vector:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调整并填充`mNodePositions`向量：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the helper method `extractGlobalPosition()`, the translational part of the
    node matrix is extracted and returned. Now we can calculate the bone lengths,
    and we store the position of the root node for the backward part of FABRIK:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在辅助方法`extractGlobalPosition()`中，提取节点矩阵的平移部分并返回。现在我们可以计算骨骼长度，并存储根节点位置以用于FABRIK的反向部分：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We need to store the root node position because we alter the `mNodePositions`
    vector during the forward calculations. Without saving the original root node,
    the backward part would be impossible to solve.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要存储根节点位置，因为我们会在前向计算中更改`mNodePositions`向量。如果没有保存原始根节点，反向部分将无法解决。
- en: 'Then, we start a loop with the maximum number of iterations:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们启动一个循环，最大迭代次数为：
- en: '[PRE52]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At the start of the loop, we compare the positions of the effector node and
    the desired target. If the positions are close together, we return the current
    node positions as solutions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环开始时，我们比较效应节点和目标位置。如果位置接近，则返回当前节点位置作为解决方案。
- en: 'Now comes the FABRIK solving part. We call the forward solver method with the
    target position and then the backward solver method with the saved root node position:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是FABRIK解决部分。我们使用目标位置调用前向求解方法，然后使用保存的根节点位置调用反向求解方法：
- en: '[PRE53]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After both solving parts are finished, we continue with the next iteration.
    Finally, we return the positions FABRIK found for the nodes:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决两个部分之后，我们继续下一个迭代。最后，我们返回FABRIK找到的节点位置：
- en: '[PRE54]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It’s possible that the effector node is unable to reach the target position,
    i.e., because the node chain is too short. In this case, the best position FABRIK
    could find will be returned.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可能效应节点无法达到目标位置，即因为节点链太短。在这种情况下，FABRIK能找到的最佳位置将被返回。
- en: Before we can continue with the last part of the FABRIK, we need to make sure
    to configure the root and effector nodes of the model. Here, we will use only
    the feet to create a natural appearance while walking up or down a hill.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以继续FABRIK的最后部分之前，我们需要确保配置模型的根节点和效应节点。在这里，我们将仅使用脚部来创建在上下坡时自然的外观。
- en: Defining the node chain for the instance’s feet
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实例脚部的节点链
- en: 'To be able to configure the nodes for the feet, two new members of the `ModelSettings`
    `struct` in the `ModelSettings.h` file are added:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够配置脚部的节点，我们在`ModelSettings.h`文件中的`ModelSettings`结构体中添加了两个新成员：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `msFootIKChainPair` array, we store the node IDs of the effector and
    the root node for the left foot and right foot. We only need this pair for the
    user interface since the contents of the `msFootIKChainNodes` array will be calculated
    from the effector and root node IDs.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`msFootIKChainPair`数组中，我们存储左脚和右脚的效应节点和根节点的节点ID。我们只需要这对用户界面，因为`msFootIKChainNodes`数组的内容将根据效应节点和根节点ID计算得出。
- en: For the user interface, we use the names from the bone name list of the instance’s
    model. Since we have a 1:1 relationship between the bone IDs and the names, iterating
    over the list to create a combo box is easy.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面，我们使用实例模型骨骼名称列表中的名称。由于骨骼ID和名称之间存在1:1的关系，因此遍历列表以创建组合框很容易。
- en: 'Together with a Boolean variable to enable or disable inverse kinematics and
    an iteration slider, the user interface for the section about inverse kinematics
    for the model’s feet looks like *Figure 12.12*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与一个布尔变量一起，用于启用或禁用逆运动学以及一个迭代滑块，关于模型脚部逆运动学的部分用户界面看起来像*图12.12*：
- en: '![](img/figure_12_12.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_12.png)'
- en: 'Figure 12.12: Configured inverse kinematics for the Women model'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：为女性模型配置的逆运动学
- en: For *Figure 12.12*, the `Women` model was used as an example. For other models,
    the node names may be different.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*图12.12*，使用了`Women`模型作为示例。对于其他模型，节点名称可能不同。
- en: Inverse kinematics depends on the model
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 逆运动学依赖于模型
- en: The ability to configure inverse kinematics for the feet of a model depends
    heavily on the model’s skeleton. It’s likely that some models you find on the
    internet may miss some parent-child relationships between nodes of the skeleton,
    for instance between leg and feet nodes, leading to non-working inverse kinematics.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 配置模型脚部逆运动学的能力在很大程度上取决于模型的骨骼。很可能你在互联网上找到的一些模型可能缺少骨骼节点之间的某些父子关系，例如腿部和脚部节点之间的关系，导致逆运动学无法正常工作。
- en: The FABRIK algorithm has another part that adjusts the world positions of the
    original nodes by using the calculated positions. We skipped the code for the
    final part in the *Implementing the FABRIK inverse kinematics algorithm* section
    since we have to split the FABRIK algorithm for technical reasons – the node data
    used by the FABRIK algorithm resides on the GPU, but some of the calculations
    are easier to handle on the CPU.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法还有另一部分通过使用计算出的位置调整原始节点的世界位置。我们在*实现FABRIK逆运动学算法*部分跳过了最终部分的代码，因为出于技术原因我们必须拆分FABRIK算法——FABRIK算法使用的节点数据位于GPU上，但一些计算在CPU上更容易处理。
- en: Let’s combine the node positions now.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来合并节点位置。
- en: Adjusting the node positions
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整节点位置
- en: Due to the usage of compute shaders, the matrices containing the rotation, translation,
    and scale plus the data for the world positions of the nodes only reside in GPU
    memory. Plus, the node positions are calculated for performance reasons in a compute
    shader. We need to copy the data back and forth between the CPU and the GPU to
    adjust the node rotations to the results delivered by the FABRIK solver. After
    calculating the final node positions for all instances with FABRIK, the rotation
    data for every node from target to effector is updated. The resulting transform
    matrices are uploaded to the GPU, and a compute shader is used to calculate the
    new transform matrices. Since all child nodes of a node are affected by the transform
    matrix, we have to perform these steps for each node individually.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了计算着色器，包含旋转、平移、缩放以及节点世界位置的矩阵仅存在于GPU内存中。此外，为了性能原因，节点位置在计算着色器中计算。我们需要在CPU和GPU之间来回复制数据，以调整节点旋转以适应FABRIK求解器提供的结果。使用FABRIK计算所有实例的最终节点位置后，每个节点从目标到执行器的旋转数据都会更新。结果变换矩阵被上传到GPU，并使用计算着色器计算新的变换矩阵。由于一个节点的所有子节点都受变换矩阵的影响，我们必须为每个节点单独执行这些步骤。
- en: Keeping the node transformations separate
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持节点变换的分离
- en: To simplify using the data calculated in the compute shaders, we will not combine
    the rotation, translation, and scale data for the TRS matrix into a single matrix.
    Instead, we store the values in a new `struct`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用计算着色器中计算出的数据，我们不会将TRS矩阵的旋转、平移和缩放数据合并成一个单一的矩阵。相反，我们将值存储在一个新的`struct`中。
- en: 'In the three shaders files, `assimp_instance_matrix_mult.comp`, `assimp_instance_transform.comp`,
    and `assimp_instance_headmove_transform.comp`, we add the following `TRSMat` `struct`
    at the top:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个着色器文件`assimp_instance_matrix_mult.comp`、`assimp_instance_transform.comp`和`assimp_instance_headmove_transform.comp`中，我们在顶部添加以下`TRSMat`
    `struct`：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Be aware that the `rotation` element is a quaternion; we just use a `vec4` for
    the transport to the shader since GLSL does not support quaternions directly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rotation`元素是一个四元数；我们只是使用`vec4`将其传输到着色器，因为GLSL不支持直接使用四元数。
- en: 'To avoid adding translation, rotation, and scale to a matrix in one shader
    and extracting the values again in another shader, we will keep the decomposed
    transformation data as separate values in the SSBO:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在一个着色器中添加平移、旋转和缩放到一个矩阵，然后在另一个着色器中再次提取值，我们将分解的变换数据作为单独的值保存在SSBO中：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Creating the final TRS matrix is moved into the matrix multiplication shader,
    along with the `createTRSMatrix()`, `createTranslationMatrix()`, `createScaleMatrix()`,
    and `createRotationMatrix()` helper methods. The TRS matrices will be created
    on the fly instead of doing a lookup in the `main()` method of the `assimp_instance_matrix_mult.comp`
    shader:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建最终的TRS矩阵的操作移动到矩阵乘法着色器中，包括`createTRSMatrix()`、`createTranslationMatrix()`、`createScaleMatrix()`和`createRotationMatrix()`辅助方法。TRS矩阵将实时创建，而不是在`assimp_instance_matrix_mult.comp`着色器的`main()`方法中进行查找：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Since the calculation was done entirely on the GPU, the only change in the
    renderer code to reflect the TRS data split is the size calculation for the `mShaderTRSMatrixBuffer`
    SSBO:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算完全在GPU上完成，渲染器代码中反映TRS数据拆分的唯一更改是`mShaderTRSMatrixBuffer` SSBO的大小计算：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Instead of a `glm::mat4` for the full TRS matrix, we use three `glm::vec4` instances
    here, keeping the node transform split into translation, rotation, and scale like
    in the compute shader.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用完整的TRS矩阵的`glm::mat4`不同，这里我们使用三个`glm::vec4`实例，将节点变换拆分为平移、旋转和缩放，就像在计算着色器中一样。
- en: 'In the `OGLRenderData.h` file, a matching `TRSMatrixData` `struct` is added:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OGLRenderData.h`文件中，添加了一个匹配的`TRSMatrixData` `struct`：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For Vulkan, the addition of `TRSMatrixData` happens in the `VkRenderData.h`
    file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan，`TRSMatrixData`的添加发生在`VkRenderData.h`文件中。
- en: Right after the final node positions were calculated by the compute shaders,
    but before the instances are rendered, new code will be added for the animated
    instances.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算着色器计算出最终节点位置之后，但在实例渲染之前，将添加新的代码以处理动画实例。
- en: Adding the code for the animated instances
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加动画实例的代码
- en: 'We start by retrieving the current contents of the TRS buffer:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检索TRS缓冲区的当前内容：
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then we iterate over the two feet and calculate the size of the node chain
    for each foot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历两只脚并计算每只脚的节点链大小：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the foot node chain is empty, we continue immediately since we don’t have
    anything to calculate here. But if we have a valid foot node chain, we iterate
    backward over the node chain, and in each node chain, we iterate forward over
    all instances:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚节点链为空，我们将立即继续，因为我们在这里没有要计算的内容。但是，如果我们有一个有效的脚节点链，我们将遍历节点链，并在每个节点链中，我们遍历所有实例：
- en: '[PRE63]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The order of the loops – foot first, then the node chain, and instance last
    – has a good reason: it is much easier to handle cases where one of the foot node
    chains is empty or the foot node chains have different sizes, as we can skip an
    entire loop or use a different number of iterations. Iterating the node chain
    backward is necessary because the foot chain vector contains the nodes in order
    from the effector to the root node, but the world position update starts with
    the root node as the first node.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的顺序——先脚，然后节点链，最后实例——有很好的理由：处理一个脚节点链为空或脚节点链大小不同的情况要容易得多，因为我们可以跳过一个整个循环或使用不同数量的迭代。反向遍历节点链是必要的，因为脚链向量包含从效应器到根节点的节点顺序，但世界位置更新是从根节点作为第一个节点开始的。
- en: 'In the inner loop, we extract the node IDs of the current node and the previous
    node from the foot node chains:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在内循环中，我们从脚节点链中提取当前节点和前一个节点的节点ID：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'By using the two node IDs, we extract the world position of the nodes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个节点ID，我们提取节点的世界位置：
- en: '[PRE65]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After multiplying the inverse of the bone offset node, the current node position,
    and the instance world position, we get the world position of the two adjacent
    nodes of the foot node chain.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘以骨骼偏移节点的逆矩阵、当前节点位置和实例世界位置之后，我们得到脚节点链的两个相邻节点的世界位置。
- en: 'With the two positions, we calculate the normalized `toNext` vector:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个位置，我们计算归一化的`toNext`向量：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To calculate the desired rotation for the node, we need to find a quaternion
    that rotates the bone from the current world rotation to the rotation computed
    by the FABRIK algorithm.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算节点的期望旋转，我们需要找到一个四元数，该四元数将骨骼从当前世界旋转旋转到由FABRIK算法计算的旋转。
- en: Creating the new world positions
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的世界位置
- en: 'We extract the new world positions of the same nodes calculated by FABRIK,
    calculate the normalized `toDesired` vector between the new world positions, and
    compute the rotation angle between the `toNext` and `toDesired` vectors as a quaternion,
    `nodeRotation`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取由FABRIK计算的同节点的新世界位置，计算新世界位置之间的归一化`toDesired`向量，并计算`toNext`和`toDesired`向量之间的旋转角度作为四元数，`nodeRotation`：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: At this point, we have the world-level rotation between the current position
    of the bone and the new position of the same bone of the model’s skeleton.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了骨骼当前位置和模型骨骼相同骨骼的新位置之间的世界级旋转。
- en: 'Now we extract the world-level rotation of the current node and calculate the
    local rotation that would be needed to match the world-level rotation of the node:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提取当前节点的世界级旋转并计算匹配节点世界级旋转所需的局部旋转：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we read the current local rotation of the node, concatenate the new
    rotation, and store the rotation back to the TRS data:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们读取节点的当前局部旋转，连接新的旋转，并将旋转存储回TRS数据：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: By running the `mAssimpMatrixComputeShader` and uploading the updated TRS data,
    the new node matrices for all the nodes in the foot node chain are recalculated.
    As the last step, we read back the contents of the `mShaderBoneMatrixBuffer` to
    have the new node matrices available for the next node in the foot node chain.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`mAssimpMatrixComputeShader`并上传更新的TRS数据，重新计算脚节点链中所有节点的新的节点矩阵。作为最后一步，我们读取`mShaderBoneMatrixBuffer`的内容，以便将新的节点矩阵用于脚节点链中的下一个节点。
- en: We are just one step away from a working inverse kinematics implementation.
    What’s left now is detecting the collisions between the foot position and the
    ground triangle. Let’s tackle the last section of this chapter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离一个工作的逆运动学实现只有一步之遥。现在剩下的只是检测脚位置与地面三角形之间的碰撞。让我们处理本章的最后部分。
- en: Detecting feet-to-ground collisions
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测脚与地面的碰撞
- en: The general idea behind detecting collisions between instance feet and the ground
    is the same as for the instances. We use the ray-to-triangle check to find the
    intersection of a ray with the triangle below or above the defined foot node.
    This intersection point is then used as the target position for the FABRIK solver.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 检测实例脚与地面之间碰撞的一般思想与实例相同。我们使用射线到三角形的检查来找到射线与定义的脚节点下方或上方的三角形的交点。然后，这个交点被用作FABRIK求解器的目标位置。
- en: 'For both feet of every instance, we use the same method to extract the world
    position as in the last step of the FABRIK solver code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个实例的两个脚，我们使用与FABRIK求解器代码的最后一步相同的方法来提取世界位置：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We also calculate the offset of the foot node from the ground:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算脚节点与地面的偏移量：
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This `footDistAboveGround` offset is needed to let the foot hover above the
    sloped ground triangle at the same distance as the foot would be on a plain ground
    triangle. Then, we use the `AABB` of the instance to calculate the full and half
    height of the bounding box:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`footDistAboveGround`偏移量是必要的，以便让脚在斜地面三角形上以与平地面三角形上相同的距离悬浮。然后，我们使用实例的`AABB`来计算边界框的完整高度和半高度：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With the two height values, we create a ray to detect the intersection with
    the ground triangle. Next, we set a default value for the final `hitPoint` of
    the intersection and iterate over the colliding triangles:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个高度值，我们创建一个射线来检测与地面三角形的交点。接下来，我们为交点的最终`hitPoint`设置一个默认值，并遍历碰撞的三角形：
- en: '[PRE73]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then we check every colliding triangle for an intersection with a ray starting
    at the half height of the instance, pointing at most the entire instance height
    down:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查每个碰撞的三角形是否与从实例半高度开始的射线相交，指向最多整个实例高度向下：
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Using an upper and lower limit for the ray helps prevent the misdetection of
    any nearby triangles. Next, we check if we have found an intersection:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用射线的一个上限和下限有助于防止误检测任何附近的三角形。接下来，我们检查是否找到了交点：
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we add the `footDistAboveGround` to the resulting value to keep the original
    distance from the animation to the ground. *Figure 12.13* shows a simplified example
    of how keeping the foot-to-ground distance affects the instance:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`footDistAboveGround`添加到结果值中，以保持动画与地面之间的原始距离。*图12.13*展示了保持脚与地面距离如何影响实例的简化示例：
- en: '![](img/figure_12_13.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_12_13.png)'
- en: 'Figure 12.13: Retaining the distance of the foot above the ground'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：保持脚在地面上的距离
- en: Now we can run the inverse kinematics solver to calculate the adjusted node
    positions.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行逆运动学求解器来计算调整后的节点位置。
- en: Running the FABRIK solver
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行FABRIK求解器
- en: 'First, we clear the vector containing positions to solve. Then, we place the
    matrices of the nodes in the current foot node chain in `mIKWorldPositionsToSolve`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们清除包含要解决的位置的向量。然后，我们将当前脚节点链中节点的矩阵放置在`mIKWorldPositionsToSolve`中：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As the final step of the inverse kinematics, we let FABRIK solve the node positions
    for the intersection point we have found, and insert the results into the `mNewNodePositions`
    vector for the foot we are working on:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 作为逆运动学的最后一步，我们让FABRIK解决我们找到的交点处的节点位置，并将结果插入到我们正在工作的脚的`mNewNodePositions`向量中：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: At this point, the foot positions are ready for the node matrix and TRS updates
    from the *Detecting foot to ground collisions* section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，脚的位置已经准备好从*检测脚与地面碰撞*部分进行节点矩阵和TRS更新。
- en: 'Enabling and configuring inverse kinematics after loading a level will render
    an image similar to *Figure 12.14* to the screen:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载关卡后启用和配置逆运动学会在屏幕上渲染出类似于*图12.14*的图像：
- en: '![](img/figure_12_14.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_12_14.png)'
- en: 'Figure 12.14: The right foot of the right instance has less intersection on
    sloped ground'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：右侧实例的右脚在斜坡地面上的交点较少
- en: As you can see in the right instance in *Figure 12.14*, the right foot no longer
    fully intersects the ground triangle. Also, the angle of the right knee has been
    adjusted to allow the foot to be placed on the higher part of the ground triangle.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*图12.14*右侧的实例中看到的那样，右侧的脚不再完全与地面三角形相交。此外，右侧膝盖的角度已经被调整，以便脚能够放置在地面三角形的较高部分。
- en: There is still some intersection with the toes on the left. Fixing the remaining
    intersection by aligning the toes to the ground slope is a task in the *Practical
    sessions* section. But even with this minimal intersection, it’s a lot of fun
    to watch the instances going up and down on hills much more like a real human.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些交叉点在左侧的脚趾上。在*实践环节*部分，通过将脚趾对齐到地面斜坡来修复剩余的交叉点是一个任务。但即使有这种最小的交叉点，观看实例在山丘上上下下，更像真实的人类，也是非常有趣的。
- en: Limitations of FABRIK
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FABRIK的限制
- en: Animations created by using a FABRIK solver for inverse kinematics usually look
    good, but the algorithm has some limitations that should be addressed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FABRIK求解器创建的逆运动学动画通常看起来很好，但该算法有一些限制需要解决。
- en: The biggest problem arises when note rotations create unnatural bone positions.
    For example, a human cannot bend their knees forward, but our instances on the
    screen can do so. Without checking and restricting the rotations of the nodes,
    the bones of the instances can end up in virtually any position. A task in the
    *Practical sessions* section handles this issue by limiting node rotations.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点旋转创建出不自然的骨骼位置时，会出现最大的问题。例如，人类不能向前弯曲膝盖，但屏幕上的实例可以这样做。如果不检查和限制节点的旋转，实例的骨骼可能会最终处于几乎任何位置。在*实践环节*部分有一个任务通过限制节点旋转来处理这个问题。
- en: Another problem emerges if the target is too far away from the effector, thus
    becoming unreachable. FABRIK solves unreachable targets by stretching the entire
    bone chain from the root node to the effector node in a straight line, causing
    the instance to walk around with stiff legs like a robot. Since we can detect
    if the target cannot be reached by the effector, handling these situations is
    easier than unlimited node rotations. There is a task in the *Practical sessions*
    section to solve problems with unreachable targets.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标点离效应器太远，就会变得无法触及，这时就会出现另一个问题。FABRIK通过将整个骨骼链从根节点拉伸到效应器节点成一条直线来解决这个问题，导致实例像机器人一样用僵硬的腿行走。由于我们可以检测到效应器无法触及目标，因此处理这些情况比无限旋转节点要容易。在*实践环节*部分有一个任务是用来解决无法触及目标的问题。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we enhanced the collision detection in our level. First, we
    added a separate and specialized octree for the level data, allowing us to do
    a quick check for collisions between instances and level geometry. Then, we added
    simple gravity to the virtual world and adjusted the collision detection to allow
    instances to walk on the level floor. Finally, we added inverse kinematics for
    the feet of the instances, bringing a more natural foot and leg movement on sloped
    grounds by avoiding the feet floating above the ground or clipping into ground
    triangles of the level.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们增强了我们关卡中的碰撞检测。首先，我们为关卡数据添加了一个单独的、专门的八叉树，使我们能够快速检查实例和关卡几何之间的碰撞。然后，我们在虚拟世界中添加了简单的重力，并调整了碰撞检测以允许实例在关卡地面上行走。最后，我们为实例的脚添加了逆运动学，通过避免脚在地面上方漂浮或切入关卡地面三角形的地面，使得在斜坡地面上有更自然的脚和腿的运动。
- en: In the next chapter, we will add a final extension to the level data and add
    simple navigation. We will start with a brief roundup of several ways to implement
    navigation in games. Next, we will explore the A* pathfinding algorithm and implement
    it in the application. Then, we will add waypoints to the map, serving as targets
    for A* calculations. Finally, we will implement waypoint navigation to the instances,
    enabling the instances to move to random waypoints or to patrol between a set
    of defined waypoints.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将对关卡数据进行最终扩展并添加简单的导航。我们将首先简要回顾几种在游戏中实现导航的方法。接下来，我们将探讨 A* 寻路算法并将其实现到应用中。然后，我们将向地图中添加航点，作为
    A* 计算的目标。最后，我们将实现航点导航到实例，使实例能够移动到随机的航点或巡逻于一系列定义好的航点之间。
- en: Practical sessions
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些你可以添加到代码中的改进：
- en: Add a more complete gravity.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更完整的重力。
- en: Instead of just manipulating the vertical position of the instances, use a more
    complex way to apply gravity by using vertical acceleration. Since gravity is
    used in two places, in the instance for the speed and in the renderer for the
    collision detection, synchronization between both code parts is needed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅操纵实例的垂直位置，使用垂直加速度以更复杂的方式应用重力。由于重力在两个地方使用，一个是在实例中用于速度，另一个是在渲染器中用于碰撞检测，因此需要在这两部分代码之间进行同步。
- en: Add collision detection for the third-person camera.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第三人称摄像机添加碰撞检测。
- en: In real games, the camera is also a normal object in the virtual world. And
    instead of clipping through the level data, the camera always stays inside the
    same boundaries as the character it follows, connected by a spring arm structure
    to allow adjustments if the camera is unable to keep the exact position behind
    the character. You can try to add a bounding box for the third-person camera and
    check the boundaries against the level octree too. Remember to also check and
    change the distance and height of the camera if a collision occurs.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实游戏中，摄像机也是虚拟世界中的一个普通对象。并且摄像机不会穿过关卡数据，它总是保持在跟随的角色相同的边界内，通过弹簧臂结构连接，以便在摄像机无法保持角色精确后方位置时进行调整。你可以尝试为第三人称摄像机添加边界框，并检查边界与关卡八叉树的对齐。记住，如果发生碰撞，也要检查和更改摄像机的距离和高度。
- en: Enhance stair and cliff detection.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强楼梯和悬崖检测。
- en: To enable the instances climbing stairs, basic logic has been added to the code
    that compares the step height of stairs with the instance position. This idea
    may not work for different kinds of game maps, plus the instance may fall off
    a cliff when the stair detection returns the wrong result. Enhance the logic to
    have better stair detection and also prevent the instance from falling down when
    it “thinks” it is standing in front of a step when it is actually on the edge
    of an abyss.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实例能够爬楼梯，代码中已经添加了基本的逻辑，该逻辑比较楼梯的步高与实例的位置。这个想法可能不适用于不同类型的游戏地图，而且当楼梯检测返回错误结果时，实例可能会从悬崖上掉下来。增强逻辑以实现更好的楼梯检测，并防止实例在“认为”它站在台阶前面时实际上站在深渊边缘时掉下来。
- en: Align the instance’s feet to follow the slope and normal if the floor.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例的脚对齐以跟随斜坡和法线，如果地面的话。
- en: Right now, the feet of the instances may still intersect the ground, depending
    on the slope of the ground and the instance position. Add some code, and maybe
    even more nodes to the model(s), to align the feet of the instance to the ground
    triangle. This adjustment should work for forward/backward inclination and for
    a sideway rotation of the feet to match the ground.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，实例的脚可能仍然会与地面相交，这取决于地面的斜坡和实例的位置。添加一些代码，甚至可能向模型添加更多节点，以将实例的脚对齐到地面三角形。这种调整应该适用于向前/向后倾斜以及脚的侧向旋转以匹配地面。
- en: Handle unreachable targets.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理无法到达的目标。
- en: Implement logic to detect if the effector cannot reach the target and add some
    kind of default rotations for the nodes, for instance, taken from the current
    frame of the animation clip.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 实现逻辑以检测效应器是否无法到达目标，并为节点添加一些默认旋转，例如，从当前动画剪辑帧中获取。
- en: Move the node update part of FABRIK to a compute shader.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 FABRIK 的节点更新部分移动到计算着色器中。
- en: To keep the FABRIK code for updating the final node rotations simple and easy
    to follow, a CPU/GPU combination was used. The downside of the current code is
    the need to copy both TRS matrix data and final node positions from GPU memory
    at the start of every update of the node chain. By creating a compute shader for
    the node rotation updates, you can keep the entire node update process on the
    GPU.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使FABRIK代码更新最终节点旋转简单易懂，使用了CPU/GPU组合。当前代码的缺点是在每次更新节点链的开始时，需要从GPU内存中复制TRS矩阵数据和最终节点位置。通过创建用于节点旋转更新的计算着色器，可以将整个节点更新过程保持在GPU上。
- en: 'Extended difficulty: Write a compute shader for inverse kinematics.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展难度：编写一个用于逆运动学的计算着色器。
- en: The FABRIK inverse kinematics algorithm is simple and straightforward. Implementing
    the same algorithm in a compute shader should not be too hard. You can use the
    matrix multiplication compute shader as an example of how to do loops in GLSL
    code without hard coding the loop variable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK逆运动学算法简单直接。在计算着色器中实现相同的算法不应太难。你可以使用矩阵乘法计算着色器作为如何在GLSL代码中执行循环的示例，而不需要硬编码循环变量。
- en: 'Extended difficulty: Add node limits to the inverse kinematics algorithm.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展难度：将节点限制添加到逆运动学算法中。
- en: 'In the default version, inverse kinematics does not worry about unnatural bone
    rotations when solving for the position. For a game character, it looks strange
    if a knee or an elbow is bent in the wrong direction. By adding per-node limits
    for all three rotation axes, the target may not be reachable, but the character
    still looks like a human. But be warned: adding node limits may influence the
    stability of the inverse kinematics algorithm.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认版本中，逆运动学在求解位置时不会担心不自然的骨骼旋转。对于一个游戏角色来说，如果膝盖或肘部向错误的方向弯曲，看起来会很奇怪。通过为所有三个旋转轴添加每个节点的限制，目标可能无法达到，但角色仍然看起来像人类。但请注意：添加节点限制可能会影响逆运动学算法的稳定性。
- en: 'Extended difficulty: Use a **bounding volume hierarchy** (**BVH**) for collision
    detection.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展难度：使用**边界体积层次结构**（**BVH**）进行碰撞检测。
- en: The idea of a bounding volume hierarchy was mentioned in the *Using spatial
    partitioning to reduce complexity* section of [*Chapter 8*](Chapter_8.xhtml),
    and the book *Real-Time Collision Detection* by Christer Ericson has an entire
    chapter about BHVs. Replacing the octree with a BHV to detect collisions may be
    a long task since the creation of the hierarchy already adds a significant amount
    of complexity to collision detection.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](Chapter_8.xhtml)的“使用空间划分来降低复杂性”部分提到了边界体积层次结构的概念，而克里斯蒂安·埃里克森的《*实时碰撞检测*》一书有一个关于BHV的完整章节。用BHV替换八叉树来检测碰撞可能是一项长期任务，因为创建层次结构已经给碰撞检测增加了相当大的复杂性。
- en: Additional resources
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充资源
- en: 'Introduction to the Jacobian Matrix: [https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2](https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雅可比矩阵简介：[https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2](https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2)
- en: '*Collision Detection in Interactive 3D Environments* by *Gino van den Bergen*,
    published by *CRC Press*: ISBN 978-1558608016'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*交互式3D环境中的碰撞检测*》由*吉诺·范登伯格*著，由*CRC出版社*出版：ISBN 978-1558608016
- en: '*Game Physics Engine Development* by *Ian Millington*, published by *CRC Press*:
    ISBN 978-0123819765'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*游戏物理引擎开发*》由*伊恩·米林顿*著，由*CRC出版社*出版：ISBN 978-0123819765
- en: '*Game Physics* by *David H. Eberly*, published by *Morgan Kaufmann*: ISBN 978-0123749031'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*游戏物理*》由*大卫·H·埃伯利*著，由*摩根考夫曼出版社*出版：ISBN 978-0123749031
- en: '*Real-Time Collision Detection* by *Christer Ericson*, published by *CRC Press*:
    ISBN 9781000750553'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*实时碰撞检测*》由*克里斯蒂安·埃里克森*著，由*CRC出版社*出版：ISBN 9781000750553
- en: 'FABRIK publications: [http://www.andreasaristidou.com/FABRIK.html](http://www.andreasaristidou.com/FABRIK.html)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FABRIK出版物：[http://www.andreasaristidou.com/FABRIK.html](http://www.andreasaristidou.com/FABRIK.html)
- en: 'Inverse kinematics in Unreal Engine: [https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27](https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine中的逆运动学：[https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27](https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27)
- en: 'Full body inverse kinematic: [https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全身逆运动学：[https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine)
- en: 'Möller-Trumbore algorithm for ray-triangle intersection checks: [http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/](http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Möller-Trumbore算法用于光线-三角形交点检测：[http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/](http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/)
