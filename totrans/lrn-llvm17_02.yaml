- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing LLVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to learn how to work with LLVM, it is best to begin by compiling LLVM
    from source. LLVM is an umbrella project and the GitHub repository contains the
    source of all projects belonging to LLVM. Each LLVM project is in a top-level
    directory of the repository. Besides cloning the repository, your system must
    also have all tools installed that are required by the build system. In this chapter,
    you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Getting the prerequisites ready, which will show you how to set up your build
    system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning the repository and building from source, which will cover how to get
    the LLVM source code, and how to compile and install the LLVM core libraries and
    clang with CMake and Ninja
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the build process, which will talk about the various possibilities
    for influencing the build process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling LLVM versus installing binaries
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can install LLVM binaries from various sources. If you are using Linux,
    then your distribution contains the LLVM libraries. Why bother compiling LLVM
    yourself?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: First, not all install packages contain all the files required for developing
    with LLVM. Compiling and installing LLVM yourself prevents this problem. Another
    reason stems from the fact that LLVM is highly customizable. With building LLVM,
    you learn how you can customize LLVM, and this will enable you to diagnose problems
    that may arise if you bring your LLVM application to another platform. And last,
    in the third part of this book, you will extend LLVM itself, and for this, you
    need the skill of building LLVM yourself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: However, it is perfectly fine to avoid compiling LLVM for the first steps. If
    you want to go on this route, then you only need to install the prerequisites
    as described in the next section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Many Linux distributions split LLVM into several packages. Please make sure
    that you install the development package. For example, on Ubuntu, you need to
    install the `llvm-dev` package. Please also make sure that you install LLVM 17\.
    For other versions, the examples in this book may require changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Getting the prerequisites ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with LLVM, your development system should run a common operating system
    such as Linux, FreeBSD, macOS, or Windows. You can build LLVM and clang in different
    modes. A build with debug symbols enabled can take up to 30 GB of space. The required
    disk space depends heavily on the chosen build options. For example, building
    only the LLVM core libraries in release mode, targeting only one platform, requires
    about 2 GB of free disk space, which is the bare minimum needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To reduce compile times, a fast CPU (such as a quad-core CPU with a 2.5 GHz
    clock speed) and a fast SSD are also helpful. It is even possible to build LLVM
    on a small device such as a Raspberry Pi – it only takes a lot of time. The examples
    within this book were developed on a laptop with an Intel quad-core CPU running
    at a 2.7 GHz clock speed, with 40 GB RAM and 2.5 TB SSD disk space. This system
    is well suited for the development task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Your development system must have some prerequisite software installed. Let’s
    review the minimal required version of these software packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: To check out the source from GitHub, you need **Git** ([https://git-scm.com/](https://git-scm.com/)).
    There is no requirement for a specific version. The GitHub help pages recommend
    using at least version 1.17.10\. Due to known security issues found in the past,
    it is recommended to use the latest available version, which is 2.39.1 at the
    time of writing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The LLVM project uses **CMake** ([https://cmake.org/](https://cmake.org/)) as
    the build file generator. At least the 3.20.0 version is required. CMake can generate
    build files for various build systems. In this book, **Ninja** ([https://ninja-build.org/](https://ninja-build.org/))
    is used because it is fast and available on all platforms. The latest version,
    1.11.1, is recommended.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, you also need a **C/C++ compiler**. The LLVM projects are written
    in modern C++, based on the C++17 standard. A conforming compiler and standard
    library are required. The following compilers are known to work with LLVM 17:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: gcc 7.1.0 or later
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clang 5.0 or later
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple clang 10.0 or later
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 16.7 or later
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that with further development of the LLVM project, the requirements
    for the compiler are most likely to change. In general, you should use the latest
    compiler version available for your system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Python** ([https://python.org/](https://python.org/)) is used during the
    generation of the build files and for running the test suite. It should be at
    least the 3.8 version.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Although not covered in this book, there can be reasons that you need to use
    Make instead of Ninja. In this case, you need to use `ninja` in each command with
    `make` for the scenarios described below.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: LLVM also depends on the `zlib` library ([https://www.zlib.net/](https://www.zlib.net/)).
    You should have at least version 1.2.3.4 installed. As usual, we recommend using
    the latest version, 1.2.13.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To install the prerequisite software, the easiest way is to use the package
    manager from your operating system. In the following sections, the commands required
    to install the software are shown for the most popular operating systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ubuntu 22.04 uses the `apt` package manager. Most of the basic utilities are
    already installed; only the development tools are missing. To install all packages
    at once, you type the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fedora and RedHat
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The package manager of Fedora 37 and RedHat Enterprise Linux 9 is called `dnf`.
    Like Ubuntu, most of the basic utilities are already installed. To install all
    packages at once, you type the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: FreeBSD
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On FreeBSD 13 or later, you have to use the `pkg` package manager. FreeBSD
    differs from Linux-based systems in that the clang compiler is already installed.
    To install all other packages at once, you type the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: OS X
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For development on OS X, it is best to install **Xcode** from the Apple store.
    While the Xcode IDE is not used in this book, it comes with the required C/C++
    compilers and supporting utilities. For installation of the other tools, the package
    manager **Homebrew** ([https://brew.sh/](https://brew.sh/)) can be used. To install
    all packages at once, you type the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Windows
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like OS X, Windows does not come with a package manager. For the C/C++ compiler,
    you need to download **Visual Studio Community 2022** ([https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/)),
    which is free for personal use. Please make sure that you install the workload
    named **Desktop Development with C++**. You can use the package manager **Scoop**
    ([https://scoop.sh/](https://scoop.sh/)) to install the other packages. After
    installing Scoop as described on the website, you open **x64 Native Tools Command
    Prompt for VS 2022** from your Windows menu. To install the required packages,
    you type the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please watch the output from Scoop closely. For the Python and `zlib` packages,
    it advises adding some registry keys. These entries are needed so that other software
    can find these packages. To add the registry keys, you’d best copy and paste the
    output from Scoop, which looks like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After each command, a message window from the registry editor will pop up asking
    whether you really want to import those registry keys. You need to click on **Yes**
    to finish the import. Now all prerequisites are installed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: For all examples in this book, you must use the **x64 Native Tools Command Prompt**
    for VS 2022\. Using this command prompt, the compiler is automatically added to
    the search path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The LLVM code base is very large. To comfortably navigate the source, we recommend
    using an IDE that allows you to jump to the definition of classes and search through
    the source. We find **Visual Studio Code** ([https://code.visualstudio.com/download](https://code.visualstudio.com/download)),
    which is an extensible cross-platform IDE, very comfortable to use. However, this
    is no requirement for following the examples in this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the repository and building from source
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the build tools ready, you can now check out all LLVM projects from GitHub
    and build LLVM. This process is essentially the same on all platforms:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Configure Git.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the repository.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the build directory.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the build system files.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, build and install LLVM.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s begin with configuring Git.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Git
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The LLVM project uses Git for version control. If you have not used Git before,
    then you should do some basic configuration of Git first before continuing: to
    set the username and email address. Both pieces of information are used if you
    commit changes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'One can check whether they previously had an email and username already configured
    in Git with the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding commands will output the respective email and username that you
    already have set when using Git. However, in the event that you are setting the
    username and email for the first time, the following commands can be entered for
    first-time configuration. In the following commands, you can simply replace `Jane`
    with your name and `jane@email.org` with your email:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These commands change the global Git configuration. Inside a Git repository,
    you can locally overwrite those values by not specifying the `--``global` option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Git uses the **vi** editor for commit messages. If you prefer another
    editor, then you can change the configuration in a similar way. To use the **nano**
    editor, you type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For more information about Git, please see the *Git Version Control* *Cookbook*
    ([https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545](https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to clone the LLVM repository from GitHub.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the repository
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command to clone the repository is essentially the same on all platforms.
    Only on Windows, it is recommended to turn off the auto-translation of line endings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'On all non-Windows platforms, you type the following command to clone the repository:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only on Windows, add the option to disable auto-translation of line endings.
    Here, you type the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This Git command clones the latest source code from GitHub into a local directory
    named `llvm-project`. Now change the current directory into the new `llvm-project`
    directory with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the directory are all LLVM projects, each one in its own directory.
    Most notably, the LLVM core libraries are in the `llvm` subdirectory. The LLVM
    project uses branches for subsequent release development (“release/17.x”) and
    tags (“llvmorg-17.0.1”) to mark a certain release. With the preceding clone command,
    you get the current development state. This book uses LLVM 17\. To check out the
    first release of LLVM 17 into a branch called `llvm-17`, you type the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the previous steps, you cloned the whole repository and created a branch
    from a tag. This is the most flexible approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Git also allows you to clone only a branch or a tag (including history). With
    `git clone --branch release/17.x https://github.com/llvm/llvm-project`, you only
    clone the `release/17.x` branch and its history. You then have the latest state
    of the LLVM 17 release branch, so you only need to create a branch from the release
    tag like before if you need the exact release version. With the additional `–-depth=1`
    option, which is known as a **shallow clone with Git**, you prevent the cloning
    of the history, too. This saves time and space but obviously limits what you can
    do locally, including checking out a branch based on the release tags.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build directory
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike many other projects, LLVM does not support inline builds and requires
    a separate build directory. Most easily, this is created inside the `llvm-project`
    directory, which is your current directory. Let us name the build directory, `build`,
    for simplicity. Here, the commands for Unix and Windows systems differ. On a Unix-like
    system, you use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And on Windows, use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you are ready to create the build system files with the CMake tool inside
    this directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Generating the build system files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to generate build system files to compile LLVM and clang using Ninja,
    you run the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `-G` option tells CMake for which system to generate build files. Often-used
    values for that option are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`Ninja` – for the Ninja build system'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unix Makefiles` – for GNU Make'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Visual Studio 17 VS2022` – for Visual Studio and MS Build'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xcode` – for Xcode projects'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `–B` option, you tell CMake the path of the build directory. Similarly,
    you specify the source directory with the `–S` option. The generation process
    can be influenced by setting various variables with the `–D` option. Usually,
    they are prefixed with `CMAKE_` (if defined by CMake) or `LLVM_` (if defined by
    LLVM).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we are also interested in compiling clang alongside
    LLVM. With the `LLVM_ENABLE_PROJECTS=clang` variable setting, this allows CMake
    to generate the build files for clang in addition to LLVM. Furthermore, the `CMAKE_BUILD_TYPE=Release`
    variable tells CMake that it should generate build files for a release build.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for the `–G` option depends on your platform, and the default
    value for the build type depends on the toolchain. However, you can define your
    own preference with environment variables. The `CMAKE_GENERATOR` variable controls
    the generator, and the `CMAKE_BUILD_TYPE` variable specifies the build type. If
    you use **bash** or a similar shell, then you can set the variables with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you are using the Windows command prompt instead, then you set the variables
    with the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With these settings, the command to create the build system files becomes the
    following, which is easier to type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will find more about CMake variables in the *Customizing the build* *process*
    section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and installing LLVM
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the build files are generated, LLVM and clang can be compiled with the
    following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command runs Ninja under the hood because we told CMake to generate Ninja
    files in the configuration step. However, if you generate build files for a system
    such as Visual Studio, which supports multiple build configurations, then you
    need to specify the configuration to use for the build with the `--config` option.
    Depending on the hardware resources, this command runs for between 15 minutes
    (server with lots of CPU cores, memory, and fast storage) and several hours (dual-core
    Windows notebook with limited memory).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: By default, Ninja utilizes all available CPU cores. This is good for the speed
    of compilation but may prevent other tasks from running; for example, on a Windows-based
    notebook, it is almost impossible to surf the internet while Ninja is running.
    Fortunately, you can limit the resource usage with the `–``j` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you have four CPU cores available and Ninja should only use two
    (because you have parallel tasks to run); you then use this command for compilation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After compilation is finished, a best practice is to run the test suite to
    check whether everything works as expected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, the runtime of this command varies widely with the available hardware
    resources. The `check-all` Ninja target runs all test cases. Targets are generated
    for each directory containing test cases. Using `check-llvm` instead of `check-all`
    runs the LLVM tests but not the clang tests; `check-llvm-codegen` runs only the
    tests in the `CodeGen` directory from LLVM (that is, the `llvm/test/CodeGen` directory).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do a quick manual check. One of the LLVM applications is `-version`
    option, it shows the LLVM version, the host CPU, and all supported architectures:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you have trouble getting LLVM compiled, then you should consult the *Common
    Problems* section of the *Getting Started with the LLVM System* documentation
    https://releases.llvm.org/17.0.1/docs/GettingStarted.html#common-problems) for
    solutions to typical problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, you can install the binaries:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On a Unix-like system, the install directory is `/usr/local`. On Windows, `C:\Program
    Files\LLVM` is used. This can be changed, of course. The next section explains
    how.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the build process
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CMake system uses a project description in the `CMakeLists.txt` file. The
    top-level file is in the `llvm` directory, `llvm/CMakeLists.txt`. Other directories
    also have `CMakeLists.txt` files, which are recursively included during the generation
    process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Based on the information provided in the project description, CMake checks which
    compilers are installed, detects libraries and symbols, and creates the build
    system files, for example, `build.ninja` or `Makefile` (depending on the chosen
    generator). It is also possible to define reusable modules, for example, a function
    to detect whether LLVM is installed. These scripts are placed in the special `cmake`
    directory (`llvm/cmake`), which is searched automatically during the generation
    process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The build process can be customized with the definition of CMake variables.
    The command-line option `–D` is used to set a variable to a value. The variables
    are used in the CMake scripts. Variables defined by CMake itself are almost always
    prefixed with `CMAKE_` and these variables can be used in all projects. Variables
    defined by LLVM are prefixed with `LLVM_` but they can only be used if the project
    definition includes the use of LLVM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Variables defined by CMake
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some variables are initialized with the value of environment variables. Most
    notable are `CC` and `CXX`, which define the C and C++ compilers to be used for
    building. CMake tries to locate a C and a C++ compiler automatically, using the
    current shell search path. It picks the first compiler found. If you have several
    compilers installed, for example, gcc and clang or different versions of clang,
    then this might not be the compiler you want for building LLVM.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you like to use clang17 as a C compiler and clang++17 as a C++ compiler.
    Then, you can invoke CMake in a Unix shell in the following way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This sets the value of the environment variables only for the invocation of
    `cmake`. If necessary, you can specify an absolute path for the compiler executables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`CC` is the default value of the `CMAKE_C_COMPILER` CMake variable, and `CXX`
    is the default value of the `CMAKE_CXX_COMPILER` CMake variable. Instead of using
    the environment variables, you can set the CMake variables directly. This is equivalent
    to the preceding call:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Other useful variables defined by CMake are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable name** | **Purpose** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `CMAKE_INSTALL_PREFIX` | This is a path prefix that is prepended to every
    path during installation. The default is `/usr/local` on Unix and `C:\Program
    Files\<Project>` on Windows. To install LLVM in the `/opt/llvm` directory, you
    specify `-DCMAKE_INSTALL_PREFIX=/opt/llvm`. The binaries are copied to `/opt/llvm/bin`,
    library files to `/opt/llvm/lib`, and so on. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `CMAKE_BUILD_TYPE` | Different types of build require different settings.
    For example, a debug build needs to specify options to generate debug symbols
    and usually link against debug versions of system libraries. In contrast, a release
    build uses optimization flags and links against production versions of libraries.
    This variable is only used for build systems that can only handle one build type,
    for example, Ninja or Make. For IDE build systems, all variants are generated
    and you have to use the mechanism of the IDE to switch between build types. Possible
    values are as follows:`DEBUG`: build with debug symbols`RELEASE`: build with optimization
    for speed`RELWITHDEBINFO`: release build with debug symbols`MINSIZEREL`: build
    with optimization for sizeThe default build type is taken from the `CMAKE_BUILD_TYPE`
    environment variable. If this variable is not set, then the default depends on
    the used toolchain and is often empty. In order to generate build files for a
    release build, you specify `-DCMAKE_BUILD_TYPE=RELEASE`. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `CMAKE_C_FLAGS``CMAKE_CXX_FLAGS` | These are extra flags used when compiling
    C and C++ source files. The initial values are taken from the `CFLAGS` and `CXXFLAGS`
    environment variables, which can be used as an alternative. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `CMAKE_MODULE_PATH` | This specifies additional directories that are searched
    for CMake modules. The specified directories are searched before the default ones.
    The value is a semicolon-separated list of directories. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `PYTHON_EXECUTABLE` | If the Python interpreter is not found or if the wrong
    one is picked in case you have installed multiple versions, you can set this variable
    to the path of the Python binary. This variable only has an effect if the Python
    module of CMake is included (which is the case for LLVM). |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: Table 1.1 - Additional useful variables provided by CMake
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake provides built-in help for variables. The `--help-variable var` option
    prints help for the `var` variable. For instance, you can type the following to
    get help for `CMAKE_BUILD_TYPE`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also list all variables with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This list is very long. You may want to pipe the output to `more` or a similar
    program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Using LLVM-defined build configuration variables
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build configuration variables defined by LLVM work in the same way as those
    defined by CMake except that there is no built-in help. The most useful variables
    are found in the following tables, where they are divided into variables that
    are useful for first-time users installing LLVM, and also variables for more advanced
    LLVM users.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Variables useful for first-time users installing LLVM
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Variable name** | **Purpose** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_TARGETS_TO_BUILD` | LLVM supports code generation for different CPU
    architectures. By default, all these targets are built. Use this variable to specify
    the list of targets to build, separated by semicolons. The current targets are
    `AArch64`, `AMDGPU`, `ARM`, `AVR,` `BPF`, `Hexagon`, `Lanai`, `LoongArch`, `Mips`,
    `MSP430`, `NVPTX`, `PowerPC`, `RISCV`, `Sparc`, `SystemZ`, `VE`, `WebAssembly`,
    `X86`, and `XCore`. `all` can be used as shorthand for all targets. The names
    are case-sensitive. To only enable the PowerPC and the System Z target, you specify
    `-DLLVM_TARGETS_TO_BUILD="PowerPC;SystemZ"`. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_EXPERIMENTAL_TARGETS_TO_BUILD` | In addition to the official targets,
    the LLVM source tree also contains experimental targets. These targets are under
    development and often do not yet support the full functionality of a backend.
    The current list of experimental targets is `ARC`, `CSKY`, `DirectX`, `M68k`,
    `SPIRV`, and `Xtensa`. To build the `M68k` target, you specify `-``D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M68k`.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_PROJECTS` | This is a list of the projects you want to build,
    separated by semicolons. The source for the projects must be on the same level
    as the `llvm` directory (side-by-side layout). The current list is `bolt`, `clang`,
    `clang-tools-extra`, `compiler-rt`, `cross-project-tests`, `libc`, `libclc`, `lld`,
    `lldb`, `mlir`, `openmp`, `polly`, and `pstl`. `all` can be used as shorthand
    for all projects in this list. Additionally, you can specify the `flang` project
    here. Due to some special build requirements, it is not yet part of the `all`
    list.To build clang and bolt together with LLVM, you specify `-DLLVM_ENABLE_PROJECT="clang;bolt"`.
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: Table 1.2 - Useful variables for first-time LLVM users
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Variables for advanced users of LLVM
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| `LLVM_ENABLE_ASSERTIONS` | If set to `ON`, then assertion checks are enabled.
    These checks help to find errors and are very useful during development. The default
    value is `ON` for a `DEBUG` build and otherwise `OFF`. To turn assertion checks
    on (e.g. for a `RELEASE` build), you specify `–DLLVM_ENABLE_ASSERTIONS=ON`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_EXPENSIVE_CHECKS` | This enables some expensive checks that
    can really slow down compilation speed or consume large amounts of memory. The
    default value is `OFF`. To turn these checks on, you specify `-DLLVM_ENABLE_EXPENSIVE_CHECKS=ON`.
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_APPEND_VC_REV` | LLVM tools such as `llc` display the LLVM version
    they are based on besides other information if the `–version` command-line option
    is given. This version information is based on the `LLVM_REVISION` C macro. By
    default, not only the LLVM version but also the current Git hash is part of the
    version information. This is handy in case you are following the development of
    the master branch because it makes clear on which Git commit the tool is based.
    If not needed, then this can be turned off with `–DLLVM_APPEND_VC_REV=OFF`. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_THREADS` | LLVM automatically includes thread support if a threading
    library is detected (usually the `pthreads` library). Further, LLVM assumes in
    this case that the compiler supports `-DLLVM_ENABLE_THREADS=OFF`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_EH` | The LLVM projects do not use C++ exception handling and
    therefore turn exception support off by default. This setting can be incompatible
    with other libraries your project is linking with. If needed, you can enable exception
    support by specifying `–DLLVM_ENABLE_EH=ON`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_RTTI` | LLVM uses a lightweight, self-build system for runtime
    type information. The generation of C++ RTTI is turned off by default. Like the
    exception handling support, this may be incompatible with other libraries. To
    turn generation of C++ RTTI on, you specify `–DLLVM_ENABLE_RTTI=ON`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_WARNINGS` | Compiling LLVM should generate no warning messages
    if possible. The option to print warning messages is therefore turned on by default.
    To turn it off, you specify `–DLLVM_ENABLE_WARNINGS=OFF`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_PEDANTIC` | The LLVM source should be C/C++ language standard-conforming;
    hence, pedantic checking of the source is enabled by default. If possible, compiler-specific
    extensions are also disabled. To reverse this setting, you specify `–DLLVM_ENABLE_PEDANTIC=OFF`.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_ENABLE_WERROR` | If set to `ON`, then all warnings are treated as errors
    – the compilation aborts as soon as warnings are found. It helps to find all remaining
    warnings in the source. By default, it is turned off. To turn it on, you specify
    `–DLLVM_ENABLE_WERROR=ON`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_OPTIMIZED_TABLEGEN` | Usually, the tablegen tool is built with the
    same options as all other parts of LLVM. At the same time, tablegen is used to
    generate large parts of the code generator. As a result, tablegen is much slower
    in a debug build, increasing the compile time noticeably. If this option is set
    to `ON`, then tablegen is compiled with optimization turned on even for a debug
    build, possibly reducing compile time. The default is `OFF`. To turn it on, you
    specify `–DLLVM_OPTIMIZED_TABLEGEN=ON`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `LLVM_USE_SPLIT_DWARF` | If the build compiler is gcc or clang, then turning
    on this option will instruct the compiler to generate the DWARF debug information
    in a separate file. The reduced size of the object files reduces the link time
    of debug builds significantly. The default is `OFF`. To turn it on, you specify
    `-LLVM_USE_SPLIT_DWARF=ON`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: Table 1.3 - Useful variables for advanced LLVM users
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: LLVM defines many more CMake variables. You can find the complete list in the
    LLVM documentation about CMake [https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables](https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables).
    The preceding list contains only the ones you are most likely to need.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you prepared your development machine to compile LLVM. You
    cloned the GitHub repository and compiled your own version of LLVM and clang.
    The build process can be customized with CMake variables. You learned about useful
    variables and how to change them. Equipped with this knowledge, you can tweak
    LLVM to your needs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已准备好你的开发机器以编译 LLVM。你已克隆了 GitHub 仓库并编译了你自己的 LLVM 和 clang 版本。构建过程可以通过 CMake
    变量进行自定义。你了解了有用的变量以及如何更改它们。掌握了这些知识，你可以根据需要调整 LLVM。
- en: In the next section, we will be taking a closer look at the structure of a compiler.
    We will be exploring the different components found inside the compiler, as well
    as different types of analyses that occur in it – specifically, the lexical, syntactical,
    and semantic analyses. Finally, we will also briefly touch on interfacing with
    an LLVM backend for code generation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨编译器的结构。我们将探讨编译器内部的不同组件，以及在其中发生的不同类型的分析——特别是词法、语法和语义分析。最后，我们还将简要介绍与用于代码生成的
    LLVM 后端进行接口连接。
