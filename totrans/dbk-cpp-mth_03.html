<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-38">
    <a id="_idTextAnchor037">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor038">
    </a>
    
     There’s a Single C++, and It Is Object-Oriented
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      Only if you ignore all
     
    </em>
    
     <em class="italic">
      
       the others
      
     </em>
    
   </p>
   <p>
    
     C++ was born as C with objects, which makes many developers still consider it an OOP language.
    
    
     We will see in this chapter that C++ allows multiple paradigms, and you could safely describe it as multiple programming languages in one.
    
    
     We will look at a few paradigms supported in C++, including structured programming, OOP, functional programming, and metaprogramming, in combination with the choice of strong versus
    
    
     
      quasi-optional types.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      The multiple facets
     
     
      
       of C++
      
     
    </li>
    <li>
     
      Functional programming
     
     
      
       in C++
      
     
    </li>
    <li>
     
      
       Metaprogramming
      
     
    </li>
    <li>
     
      Strong types to
     
     
      
       the limit
      
     
    </li>
    <li>
     
      What about
     
     
      
       ignoring types?
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-40">
    <a id="_idTextAnchor039">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code for this chapter is available from the GitHub repository
    
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     
    </a>
    
     , in the
    
    <strong class="source-inline">
     
      ch3
     
    </strong>
    
     folder.
    
    
     It uses Makefile, g++, and the doctest library (
    
    <a href="https://github.com/doctest/doctest">
     
      https://github.com/doctest/doctest
     
    </a>
    
     ) for unit testing.
    
    
     The code is compiled
    
    
     
      for C++20.
     
    
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor040">
    </a>
    
     The multiple facets of C++
    
   </h1>
   <p>
    
     If you, like me, frequently move between different organizations, teams, and technical conferences, you will quickly notice two things: C++ programmers
    
    <a id="_idIndexMarker070">
    </a>
    
     have distinct interests compared to other developers, and the
    
    <a id="_idIndexMarker071">
    </a>
    
     C++ community
    
    <a id="_idIndexMarker072">
    </a>
    
     is more aptly described as small, specialized pockets of C++ developers.
    
    
     That’s different from other communities; if you discuss Java, you’ll likely end up talking about Spring Framework and REST APIs or the Android toolkit.
    
    
     C#
    
    <a id="_idIndexMarker073">
    </a>
    
     is mostly fairly standardized around the Microsoft libraries, and JavaScript is mostly about React.
    
    
     But get 100 C++ programmers in a room from different organizations and you’ll soon notice the differences.
    
    
     Embedded C++ is all about keeping all the resources in check because adding an extra 1 MB of memory to a device sold in millions of units quickly pumps up the cost.
    
    
     Game developers are on the other side of the spectrum, looking at how to squeeze extra frame rate out of next-generation GPUs and CPUs.
    
    
     The high-frequency trading people know all about avoiding CPU cache misses and how to brush off a picosecond of the automated transaction algorithm because the smallest time fraction can mean millions of euros.
    
    
     Engineering software developers are more relaxed, but still worried about the validity of the changes in a complex rendering model.
    
    
     And then you find the programmers dealing with automated systems for rails, cars, or factories, whose main concern is resilience
    
    
     
      and robustness.
     
    
   </p>
   <p>
    
     This picture, while far from complete, is enough to show us the immense variability of C++ programmers, unlike their peers using any other language.
    
    
     We could almost say that from a certain point of view, C++ is the last remaining de facto general-purpose language, since the other mainstream ones are used in practice mostly for specific types of programs: Java for enterprise backend services and Android development, C# for web and Windows applications and services, JavaScript for rich web frontends and serverless backends, and Python for scripts, data science, and DevOps.
    
    
     But C++ is in embedded software, factory systems, trading, simulations, engineering tools, operating systems, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     The old saying “form follows function” is about design applying to everything built by people, including programming languages, and applies equally well to C++.
    
    
     The large variability in projects and types of programmers fed into the language, along with Stroustrup’s desire to make it as capable as possible.
    
    
     C++ is not a single language; every programmer uses a subset of C++ that is often different from their colleagues working in the
    
    
     
      same organization.
     
    
   </p>
   <p>
    
     Yes, C++ started as C with objects, at a time when OOP was on the rise.
    
    
     But, at the same time, C++ is backward compatible with C, which means you can still write structured programming in C++.
    
    
     Then, templates were needed.
    
    
     Then, lambdas were useful.
    
    
     While C++ has always been a collection of
    
    <a id="_idIndexMarker074">
    </a>
    
     different languages, today it’s even more so.
    
    
     To prove this point, let’s look at a few paradigms you can use in C++, starting with
    
    
     
      functional programming.
     
    
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor041">
    </a>
    
     Functional programming in C++
    
   </h1>
   <p>
    
     I remember being in university, fascinated about
    
    <a id="_idIndexMarker075">
    </a>
    
     programming, and already quite adept at writing BASIC, Pascal, Logo, and simple C++.
    
    
     I think it was in my second year
    
    <a id="_idIndexMarker076">
    </a>
    
     when I took a course on functional programming.
    
    
     The teacher was very passionate and eager to show us the wonders of this paradigm, explaining a lot of concepts that I couldn’t quite grasp.
    
    
     The course turned into a complete miss for me, since the only thing I learned was how to write imperative code in Lisp and how to translate the idioms I knew into something that would work in this weird language that wears its parentheses on the outside
    
    
     
      of expressions.
     
    
   </p>
   <p>
    
     I tried to go back to functional programming after starting my career as a software engineer.
    
    
     There were plenty of resources online, only the way they explained the paradigm didn’t help.
    
    
     “It’s basically category theory,” they said.
    
    
     Everything is a function, even numbers (check out Church encoding).
    
    
     You can easily understand monads since they are a monoid in the category of endofunctors.
    
    
     This style of explanation uses a more complicated concept to explain a practical one and doesn’t
    
    
     
      facilitate understanding.
     
    
   </p>
   <p>
    
     This is why it took me years to understand what functional programming is and how it helps with software development.
    
    
     I became a fan, but not a fanatic, of this paradigm.
    
    
     Like any engineer, I like to solve problems, and in my case, most often I solve them with code.
    
    
     Having code that is simpler is always great, although often simpler does not mean
    
    
     
      more familiar.
     
    
   </p>
   <p>
    
     If I were to explain functional programming today, I would focus on three important things:
    
    <em class="italic">
     
      immutability
     
    </em>
    
     ,
    
    <em class="italic">
     
      pure functions
     
    </em>
    
     , and
    
    <em class="italic">
     
      operations with functions
     
    </em>
    
     .
    
    
     Perhaps unexpectedly, C++ is a good fit for all these traits.
    
    
     Immutability is where C++ shines compared to the other mainstream programming languages (although less than Rust, but we’ll talk about that in the
    
    
     
      final chapter).
     
    
   </p>
   <p>
    
     However, there’s one catch: functional programming is a different paradigm, with its own trade-offs.
    
    
     I’ve noticed that C++ programmers find it difficult to think about lambdas since they see lambdas not as a fundamental concept but as something built on top of the existing language.
    
    
     That’s fair enough since lambdas are objects and not first-class design elements in C++.
    
    
     However, thinking in a functional paradigm requires the programmers to temporarily forget this knowledge and embrace the functional design elements.
    
    
     You can go back to
    
    <a id="_idIndexMarker077">
    </a>
    
     this knowledge when you have implemented something that works and are
    
    <a id="_idIndexMarker078">
    </a>
    
     looking
    
    
     
      for improvements.
     
    
   </p>
   <p>
    
     Let’s explain the three characteristics in more detail and then discuss the impact of using functional programming on our
    
    
     
      software architecture.
     
    
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor042">
    </a>
    
     Immutability
    
   </h2>
   <p>
    
     Immutability
    
    <a id="_idIndexMarker079">
    </a>
    
     fundamentally
    
    <a id="_idIndexMarker080">
    </a>
    
     means that each variable is initialized with a value, but a new value cannot be assigned to the variable.
    
    
     In C++, this can be done with
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     , depending on whether we want the value to be immutable at runtime or at
    
    
     
      compile time.
     
    
   </p>
   <p>
    
     While immutability is easy to understand for simple types, collections and objects introduce challenges.
    
    
     An immutable collection is one that returns a new collection upon every change.
    
    
     So, for example, the following code shows a
    
    
     
      mutable collection:
     
    
   </p>
   <pre class="source-code">
vector&lt;int&gt; numbers {1, 2, 3};
numbers.push_back(4);
assert(numbers == vector&lt;int&gt; {1, 2, 3, 4});</pre>
   <p>
    
     Contrast this example with a hypothetic immutable collection, shown in the next code sample, that returns a new collection upon adding
    
    
     
      to it:
     
    
   </p>
   <pre class="source-code">
immutable_vector&lt;int&gt; numbers {1, 2, 3};
immutable_vector&lt;int&gt; moreNumbers = numbers.push_back(4);
assert(numbers == immutable_vector&lt;int&gt; {1, 2, 3});
assert(moreNumbers == immutable_vector&lt;int&gt; {1, 2, 3, 4});</pre>
   <p>
    
     This trait guarantees that you’re using the correct version of the data structure that you need.
    
    
     But the memory optimization bells might ring in your C++ brain.
    
    
     There seems to be a lot of memory allocation happening for immutable collections!
    
    
     Isn’t that
    
    
     
      a waste?
     
    
   </p>
   <p>
    
     It is indeed possible to be temporarily using more memory than you’d expect upon performing a change in an immutable collection.
    
    
     However, functional languages have found smart ways to avoid this, and C++ is perfectly capable of using the same mechanisms.
    
    
     It depends on
    
    
     
      the implementation.
     
    
   </p>
   <p>
    
     The way to
    
    <a id="_idIndexMarker081">
    </a>
    
     optimize memory for immutable
    
    <a id="_idIndexMarker082">
    </a>
    
     collections is to use
    
    <em class="italic">
     
      smart pointers
     
    </em>
    
     .
    
    
     Remember that values are immutable once assigned to a
    
    <a id="_idIndexMarker083">
    </a>
    
     variable.
    
    
     Therefore, when the collection is first initialized, memory is allocated for each element of the collection and each memory area is assigned to a specific value.
    
    
     When a new element is added, the pointers to each element are copied and a new memory area is allocated for the new value.
    
    
     If an element is removed from the collection, all the pointers to existing elements are copied except the one pointing to the removed element.
    
    
     Once a memory area is no longer referenced by any pointer, it
    
    
     
      gets deleted.
     
    
   </p>
   <p>
    
     While
    
    <a id="_idIndexMarker084">
    </a>
    
     immutable collections are not implemented as such in STL, libraries such as immer (
    
    <a href="https://github.com/arximboldi/immer">
     
      https://github.com/arximboldi/immer
     
    </a>
    
     ) allow you to use this pattern without worrying too much about the
    
    
     
      internal details.
     
    
   </p>
   <p>
    
     OK, but what about immutable objects?
    
    
     Isn’t the whole purpose of OOP to mix behavior
    
    
     
      with data?
     
    
   </p>
   <p>
    
     To this, I have three things
    
    
     
      to say.
     
    
   </p>
   <p>
    
     First,
    
    
     
      good question!
     
    
   </p>
   <p>
    
     Second, OOP was misunderstood to be about encapsulation, inheritance, and polymorphism when in fact it’s about message passing.
    
    
     C++ was unfortunately the trendsetter for what I like to call “class-oriented programming”: a style of programming focused on classes and their relationships instead of objects and
    
    
     
      their relationships.
     
    
   </p>
   <p>
    
     And third, functional programming has in fact no qualms with objects.
    
    
     Implementing immutable objects is very simple: either we implement an immutable data structure using
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     , or every method that changes data returns instead a new object with the
    
    
     
      modified data.
     
    
   </p>
   <p>
    
     It’s worth mentioning at this point that you don’t have to use immutability to its fullest in your programs to benefit from functional programming.
    
    
     I write enough code that maximizes constness but still uses the standard STL collections and objects that change their internal data.
    
    
     However, you need to be aware that the level of immutability described previously allows you to introduce parallelism much more easily into your programs.
    
    
     If values cannot change, you have no problems with critical sections.
    
    
     Each thread works with its
    
    <a id="_idIndexMarker085">
    </a>
    
     own value, and changing the value will
    
    <a id="_idIndexMarker086">
    </a>
    
     change it only for the specific thread.
    
    
     Indeed, this is one of the side benefits of immutability.
    
    
     I say side benefits because immutability combined with pure functions and good naming gives you programs that are easier to understand once you get used to the building blocks.
    
    
     So, let’s look at pure
    
    
     
      functions next.
     
    
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor043">
    </a>
    
     Pure functions
    
   </h2>
   <p>
    
     A pure function
    
    <a id="_idIndexMarker087">
    </a>
    
     is a function that returns the same output for the same input and doesn’t change any value in the context.
    
    
     By definition, a pure
    
    <a id="_idIndexMarker088">
    </a>
    
     function cannot do
    
    <strong class="bold">
     
      Input/Output
     
    </strong>
    
     (
    
    <strong class="bold">
     
      I/O
     
    </strong>
    
     ) operations.
    
    
     However, any non-trivial
    
    <a id="_idIndexMarker089">
    </a>
    
     program can be written as a combination of pure functions and
    
    
     
      I/O functions.
     
    
   </p>
   <p>
    
     Pure functions are the simplest types of functions you can think of.
    
    
     They are easy to understand, very predictable, and cacheable because they lack side effects.
    
    
     This leads to easy testing with data-driven unit tests and potential optimizations such as caching the result of the function upon first call with specific inputs and reusing
    
    
     
      it later.
     
    
   </p>
   <p>
    
     Pure functions are at the core of functional programming.
    
    
     In C++, they are very easy to implement using the support
    
    
     
      for immutability.
     
    
   </p>
   <p>
    
     The original way of writing functions in pure functional languages is lambdas.
    
    
     Lambdas have made their way into the standard since C++11.
    
    
     However, C++ lambdas can be mutable because they can change the variables they capture in their context.
    
    
     So, writing pure functions in C++, even with lambdas, requires you to ensure the constness of all
    
    
     
      variables involved.
     
    
   </p>
   <p>
    
     In a functional paradigm, everything is either a function or a data structure, and in pure functional languages, the two are interchangeable.
    
    
     So, how do we create complex behaviors from simple functions?
    
    
     We compose functions using various operations,
    
    
     
      of course.
     
    
   </p>
   <h2 id="_idParaDest-45">
    <a id="_idTextAnchor044">
    </a>
    
     Operations on functions
    
   </h2>
   <p>
    
     Since functions are the main design element
    
    <a id="_idIndexMarker090">
    </a>
    
     of functional programming, it’s par to the course to think about how functions can change through operations.
    
    
     The most common functional operations are partial application
    
    
     
      and composition.
     
    
   </p>
   <p>
    
     Partial application refers to creating a new function by binding the value of one parameter of a function to a specific value.
    
    
     For example, if we have a function,
    
    <strong class="source-inline">
     
      add(const int first, const int second)
     
    </strong>
    
     , we can obtain the
    
    <strong class="source-inline">
     
      increment(const int)
     
    </strong>
    
     function by binding the
    
    <strong class="source-inline">
     
      second
     
    </strong>
    
     parameter to the value
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     .
    
    
     Let’s take a moment to consider the consequence: every function, no matter how many arguments it receives, can be reduced through subsequent partial applications to functions that take no parameters.
    
    
     This gives us a universal language for expressing anything
    
    
     
      in code.
     
    
   </p>
   <p>
    
     To implement a partial application in C++, we can use the
    
    <strong class="source-inline">
     
      std::bind
     
    </strong>
    
     function from the
    
    <strong class="source-inline">
     
      &lt;functional&gt;
     
    </strong>
    
     header.
    
    
     Let’s see how we can obtain the
    
    <strong class="source-inline">
     
      increment
     
    </strong>
    
     function from the
    
    <strong class="source-inline">
     
      add
     
    </strong>
    
     function by binding the second parameter of
    
    <strong class="source-inline">
     
      add
     
    </strong>
    
     to the
    
    
     
      value
     
    
    
     <strong class="source-inline">
      
       1
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
#include &lt;functional&gt;
auto add = [](const int first, const int second){ return first + second; };
auto increment = std::bind(add, std::placeholders::_1, 1);
TEST_CASE("add"){
        CHECK_EQ(10, add(4, 6));
}
TEST_CASE("increment"){
        CHECK_EQ(10, increment(9));
}</pre>
   <p>
    
     This is a neat solution from a functional programming perspective.
    
    
     However, the return value is complicated and approximates a function instead of being a function.
    
    
     This is one of the mental hurdles for C++ programmers when trying functional programming.
    
    
     I’ve been away from the language long enough to allow myself to think in higher-level concepts instead of always analyzing the implementation.
    
    
     So, when I use
    
    <strong class="source-inline">
     
      std::bind
     
    </strong>
    
     to do the partial application, I treat the result as a function and hope the implementors have done their job of optimizing and providing the
    
    
     
      necessary behaviors.
     
    
   </p>
   <p>
    
     The other fundamental operation with functions is functional composition.
    
    
     You’ve probably encountered this construct in mathematics.
    
    
     Functional composition refers to creating a function,
    
    <em class="italic">
     
      f
     
    </em>
    
     , from two functions,
    
    <em class="italic">
     
      g
     
    </em>
    
     and
    
    <em class="italic">
     
      h
     
    </em>
    
     , such that
    
    <em class="italic">
     
      f(x) = g(h(x))
     
    </em>
    
     for any value
    
    <em class="italic">
     
      x
     
    </em>
    
     .
    
    
     This is commonly denoted in math as
    
    <em class="italic">
     
      f =
     
    </em>
    
     <em class="italic">
      
       g
      
     </em>
    
    
     <em class="italic">
      
       ∘
      
     </em>
    
    
     <em class="italic">
      
       h
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Unfortunately, there’s no
    
    <a id="_idIndexMarker091">
    </a>
    
     function or operation in the C++ standard that implements functional composition, but it’s easy to implement this operation with templates.
    
    
     Once again, the result of this operation in C++ is complicated, but I encourage you to think about it as a function rather than the actual
    
    
     
      data structure.
     
    
   </p>
   <p>
    
     Let’s see a possible implementation for functional composition in C++.
    
    
     The
    
    <strong class="source-inline">
     
      compose
     
    </strong>
    
     function takes two type parameters,
    
    <strong class="source-inline">
     
      F
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      G
     
    </strong>
    
     , that each denote the type of functions
    
    <strong class="source-inline">
     
      f
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      g
     
    </strong>
    
     to compose.
    
    
     The
    
    <strong class="source-inline">
     
      compose
     
    </strong>
    
     function returns a lambda that takes one parameter,
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     , and
    
    
     
      returns
     
    
    
     <strong class="source-inline">
      
       f(g(value)
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
template &lt;class F, class G&gt;
auto compose(F f, G g){
  return [=](auto value){return f(g(value));};
}</pre>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     The preceding example is borrowed from Alex’s other book on the topic with Packt Publishing,
    
    <em class="italic">
     
      Hands-On Functional Programming
     
    </em>
    
     <em class="italic">
      
       in C++
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Let’s see how we could use this function with a simple example.
    
    
     Let’s implement a price calculator that takes as parameters the price, a discount, a service fee, and tax and returns the final price.
    
    
     Let’s look first at an imperative implementation, using a single function that computes everything inline.
    
    
     The
    
    <strong class="source-inline">
     
      computePriceImperative
     
    </strong>
    
     function takes the price, subtracts the discount, adds the service fee, and then adds the tax percentage
    
    
     
      on top:
     
    
   </p>
   <pre class="source-code">
double computePriceImperative(const int taxPercentage, const int serviceFee, const double price, const int discount){
return (price - discount + serviceFee) * (1 + (static_cast&lt;double&gt;(taxPercentage) / 100));
}
TEST_CASE("compute price imperative"){
        int taxPercentage = 18;
        int serviceFee = 10;
        double price = 100;
        int discount = 10;
                                   double result = computePriceImperative(taxPercentage, serviceFee, price, discount);
        CHECK_EQ(118, result);
}</pre>
   <p>
    
     This is a simple implementation, and good enough to give a result.
    
    
     Challenges usually appear for this type of code when we need to add more types of discounts, modify taxes depending on items, or change the order of discounts.
    
    
     Of course, we can apply an imperative or object-oriented style when the time comes, and extract multiple functions, one for each operation, that we then combine however
    
    
     
      we need.
     
    
   </p>
   <p>
    
     But let’s look at the functional
    
    <a id="_idIndexMarker092">
    </a>
    
     style now.
    
    
     The first thing we can do is to use lambdas for every operation, and another lambda for the final computation.
    
    
     We implement a few lambdas: one that subtracts the discount from the price, a second that applies the service fee, a third that applies the tax, and a final one that computes the price by chaining calls to all the previously defined lambdas.
    
    
     We end up with the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
auto discountPrice = [](const double price, const int discount){return price - discount;};
auto addServiceFee = [](const double price, const int serviceFee){ return price + serviceFee; };
auto applyTax = [](const double price, const int taxPercentage){ return price * (1 + static_cast&lt;double&gt;(taxPercentage)/100); };
auto computePriceLambda = [](const int taxPercentage, const int serviceFee, const double price, const int discount){
return applyTax(addServiceFee(discountPrice(price, discount), serviceFee), taxPercentage);
};
TEST_CASE("compute price with lambda"){
int taxPercentage = 18;
int serviceFee = 10;
double price = 100;
int discount = 10;
double result = computePriceLambda(taxPercentage, serviceFee, price, discount);
CHECK_EQ(118, result);
}</pre>
   <p>
    
     Is this code better?
    
    
     Well, it depends.
    
    
     One factor is familiarity with this paradigm, but don’t let that stop you; as I said before, familiarity is often confused with simplicity, but the two are not the same.
    
    
     Another factor is to see the lambdas as functions and not as data structures.
    
    
     Once you pass these two challenges, we notice a few things: the lambdas are very small, they are
    
    <a id="_idIndexMarker093">
    </a>
    
     easy to understand, and they are pure functions, which are objectively the simplest types of functions out there.
    
    
     We can chain the calls in multiple ways, for example, applying the discount at the price with tax, so we have more options with this implementation.
    
    
     Still, there’s nothing we couldn’t do with imperative programming
    
    
     
      until now.
     
    
   </p>
   <p>
    
     Let’s then take the next
    
    <a id="_idIndexMarker094">
    </a>
    
     step and make this fully functional.
    
    
     We will use the lambdas we created, but instead of returning a value, our implementation will use partial application and functional composition to return a function that gives us the answer we are looking for.
    
    
     Since the preceding lambdas have two parameters, we need to bind one of the arguments to the corresponding input before applying the functional composition.
    
    
     So, for the
    
    <strong class="source-inline">
     
      discountPrice
     
    </strong>
    
     lambda, we bind the discount argument to the value passed to the
    
    <strong class="source-inline">
     
      computePriceFunctional
     
    </strong>
    
     function and we obtain a lambda that takes a single parameter, the initial price, and returns the price with a discount.
    
    
     For the
    
    <strong class="source-inline">
     
      addServiceFee
     
    </strong>
    
     lambda, we bind the
    
    <strong class="source-inline">
     
      serviceFee
     
    </strong>
    
     argument to the value passed to the
    
    <strong class="source-inline">
     
      computePriceFunctional
     
    </strong>
    
     function and obtain a function that takes a single parameter, the price before service, and returns the price with the service fee.
    
    
     For the
    
    <strong class="source-inline">
     
      applyTax
     
    </strong>
    
     lambda, we bind the
    
    <strong class="source-inline">
     
      taxPercentage
     
    </strong>
    
     argument to the value passed to the
    
    <strong class="source-inline">
     
      computePriceFunctional
     
    </strong>
    
     function and we obtain a function that takes a single parameter, the price without tax, and returns the price with tax.
    
    
     Once we obtain these functions that take a single parameter, we compose them using the
    
    <strong class="source-inline">
     
      compose
     
    </strong>
    
     function shown previously, and we obtain a function that takes a single argument price and, when called, computes the correct final price.
    
    
     Here is
    
    
     
      the result:
     
    
   </p>
   <pre class="source-code">
auto computePriceFunctional(const int taxPercentage, const int serviceFee, const double price, const int discount){
using std::bind;
using std::placeholders::_1;
auto discountLambda = bind(discountPrice, _1, discount);
auto serviceFeeLambda = bind(addServiceFee, _1, serviceFee);
auto applyTaxLambda = bind(applyTax, _1, taxPercentage);
return compose( applyTaxLambda, compose(serviceFeeLambda, discountLambda));
}
TEST_CASE("compute price functional"){
int taxPercentage = 18;
int serviceFee = 10;
double price = 100;
int discount = 10;
auto computePriceLambda = computePriceFunctional(taxPercentage, serviceFee, price, discount);
double result = computePriceLambda(price);
CHECK_EQ(118, result);
}</pre>
   <p>
    
     This style of programming is at first glance very different from what OOP or structured programming does.
    
    
     But if you think for a little bit, you will realize that an object is just a set of cohesive, partially applied functions.
    
    
     If you extract the functions from objects, you need to pass in the data members used in the object, a style familiar to those who have ever programmed in C.
    
    
     Including a method in an object is therefore equivalent to binding a few of the
    
    <a id="_idIndexMarker095">
    </a>
    
     arguments to the object data members that are initialized by the constructor.
    
    
     Therefore, OOP and functional programming are not really enemies, just different and equivalent ways of expressing the same behavior, with
    
    
     
      different trade-offs.
     
    
   </p>
   <p>
    
     As a prelude to the
    
    <em class="italic">
     
      Metaprogramming
     
    </em>
    
     section coming later, let’s look at making all these functions available at compile time.
    
    
     We need to do a little bit of magic with templates and pass in the value parameters as template arguments, and we need to add a lot of
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     , but the following code works
    
    
     
      equally well:
     
    
   </p>
   <pre class="source-code">
template &lt;class F, class G&gt;
  constexpr auto compose(F f, G g){
    return [=](auto value){return f(g(value));};
  }
constexpr auto discountPriceCompile = [](const double price,   const int discount){return price - discount;};
  constexpr auto addServiceFeeCompile = [](const double price,   const int serviceFee){ return price + serviceFee; };
  constexpr auto applyTaxCompile = [](const double price, cons  t int taxPercentage){ return price * (1 + static_cast&lt;double  &gt;(taxPercentage)/100); };
  template&lt;int taxPercentage, int serviceFee, double price, in  t discount&gt;
  constexpr auto computePriceFunctionalCompile() {
          using std::bind;
          using std::placeholders::_1;
          constexpr auto discountLambda = bind(discountPrice,   _1, discount);
          constexpr auto serviceFeeLambda = bind(addServiceFee  , _1, serviceFee);
          constexpr auto applyTaxLambda = bind(applyTax, _1, t  axPercentage);
          return compose( applyTaxLambda, compose(serviceFeeLa  mbda, discountLambda));
  }
TEST_CASE("compute price functional compile"){
        constexpr int taxPercentage = 18;
        constexpr int serviceFee = 10;
        constexpr double price = 100;
        constexpr int discount = 10;
        constexpr auto computePriceLambda = computePriceFunctionalCompile&lt;taxPercentage, serviceFee, price, discount&gt;();
        double result = computePriceLambda(price);
        CHECK_EQ(118, result);
}</pre>
   <p>
    
     With this, we have seen the fundamental blocks of functional programming in C++.
    
    
     Let’s now look at where and why they
    
    
     
      are useful.
     
    
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor045">
    </a>
    
     Architectural patterns in functional style
    
   </h2>
   <p>
    
     Let’s first look at how we would
    
    <a id="_idIndexMarker096">
    </a>
    
     implement an application going all the way to the functional style.
    
    
     We can’t discuss all the possible design patterns of such an application, but we can show a
    
    
     
      few examples.
     
    
   </p>
   <p>
    
     We notice first that functional programming places a few constraints upon our design.
    
    
     We favor immutability and pure functions.
    
    
     We use data structures, but they are immutable, meaning that every change to the data structure gives us a new version.
    
    
     Finally, the I/O part needs to be separate and as thin as possible since it
    
    
     
      needs mutations.
     
    
   </p>
   <p>
    
     A simple design pattern using these constraints is the pipe pattern.
    
    
     Let’s imagine we receive a file in XML format, and we call web services with data from it.
    
    
     We have an input layer that reads the XML file, an output layer that writes to web services, and a layer in the center that uses a functional style.
    
    
     We can now consider the input and output data and implement consequent transformations on the input that lead to the desired output.
    
    
     Each of these transformations is a pure function working on immutable
    
    
     
      data structures.
     
    
   </p>
   <p>
    
     Such a process is highly parallelizable because of the lack of mutation.
    
    
     In fact, C++17 introduced the
    
    <strong class="source-inline">
     
      &lt;execution&gt;
     
    </strong>
    
     header, which allows running the common STL algorithms in parallel.
    
    
     Similar patterns are used in data transformation architectures such as
    
    <strong class="bold">
     
      Extract, Transform, Load
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ETL
     
    </strong>
    
     ) and in
    
    <a id="_idIndexMarker097">
    </a>
    
     the MapReduce architecture made popular
    
    
     
      by Hadoop.
     
    
   </p>
   <p>
    
     The pattern can be extended beyond data
    
    <a id="_idIndexMarker098">
    </a>
    
     transformation, to the more loosely defined
    
    <strong class="bold">
     
      functional core, imperative shell
     
    </strong>
    
     architecture, aptly named by Gary Bernhardt.
    
    
     If you want more specific details, look into the hexagonal architecture with a
    
    
     
      functional core.
     
    
   </p>
   <p>
    
     This shows not only that we can design programs using a functional paradigm in C++ but also that there are situations when this architecture fits.
    
    
     It also shows that we can take some parts of this style of programming and use it on pieces of
    
    
     
      our implementation.
     
    
   </p>
   <h1 id="_idParaDest-47">
    <a id="_idTextAnchor046">
    </a>
    
     Metaprogramming
    
   </h1>
   <p>
    
     One thing seems to unite programmers, no
    
    <a id="_idIndexMarker099">
    </a>
    
     matter how different they are otherwise: the enjoyment of jokes on recursion.
    
    
     There’s something in the programmer’s mind that appreciates a certain type of symmetry.
    
    
     When it comes to programming languages and programming paradigms, you’d be hard-pressed to find a more symmetrical type of language than one that can
    
    
     
      understand itself.
     
    
   </p>
   <p>
    
     The corresponding programming paradigm is called metaprogramming, and programming languages that take this idea to the limit are known as homoiconic, meaning that a program can manipulate another program’s representation or its own as data.
    
    
     Programming languages that have this property include Lisp and its derived dialects, the latest
    
    
     
      being Clojure.
     
    
   </p>
   <p>
    
     Metaprogramming is very powerful, but also very difficult to master, and can introduce a lot of issues in large projects.
    
    
     Some features connected to metaprogramming are available in modern languages, such as instrumentation, reflection, or dynamic execution of instructions.
    
    
     But other than using annotations, very little of all this is used
    
    
     
      in practice.
     
    
   </p>
   <p>
    
     C++ is different, however.
    
    
     One feature of metaprogramming is the ability to move computations from runtime to compile time, and C++ has fully embraced it with template metaprogramming.
    
    
     In more recent versions of the language, the implementation of compile-time computations has been simplified with the introduction of generalized constant expressions with
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       consteval
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     A typical example of this technique is the
    
    <a id="_idIndexMarker100">
    </a>
    
     factorial implementation.
    
    
     A recursive factorial implementation computed at runtime looks
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
int factorial(const int number){
    if(number == 0) return 1;
    return number * factorial(number – 1);
}</pre>
   <p>
    
     The same implementation
    
    <a id="_idIndexMarker101">
    </a>
    
     can be done using template metaprogramming.
    
    
     It is perhaps a lesser-known characteristic of C++ templates that they can take a value as a parameter, not just a type.
    
    
     Moreover, both a generic template, for example, one that takes any integer value as a parameter, and a specialization, which takes only a specific value, can be provided.
    
    
     In our case, we can implement a factorial template that takes an integer and a specialization for the value
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , resulting in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
template&lt;int number&gt;
struct Factorial {
enum { value = number * Factorial&lt;number – 1&gt;::value};
};
template&lt;&gt;
struct Factorial&lt;0&gt;{
enum {value = 1};
};</pre>
   <p>
    
     This implementation achieves the same goal as the previous one, with the exception that a call to
    
    <strong class="source-inline">
     
      Factorial&lt;25&gt;
     
    </strong>
    
     , for example, will be computed at compile time rather than runtime.
    
    
     Starting with C++11 and generalized constant expressions, we can avoid templates altogether and instead use
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      consteval
     
    </strong>
    
     to tell the compiler which values are to be computed at compile time.
    
    
     Here’s a simplified implementation of the same code with a
    
    
     
      constant expression:
     
    
   </p>
   <pre class="source-code">
constexpr int factorial(const int number) {
return (number == 0) ? 1 : (number * factorial(number - 1));
}</pre>
   <p>
    
     These metaprogramming techniques available to C++ programmers allow more flexibility in decisions related to what happens at compile time versus runtime.
    
    
     They offer a trade-off of CPU cycles versus the executable size.
    
    
     If you have a lot of memory available but the
    
    <a id="_idIndexMarker102">
    </a>
    
     computations need to happen extremely fast, caching results in the executable can be the way to go, and
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      consteval
     
    </strong>
    
     become
    
    
     
      your friends.
     
    
   </p>
   <p>
    
     But the possibilities don’t stop here.
    
    
     We can create in C++ programs that are demonstrably valid from compilation.
    
    
     We just need to take strong types to
    
    
     
      their limit.
     
    
   </p>
   <h1 id="_idParaDest-48">
    <a id="_idTextAnchor047">
    </a>
    
     Strong types to the limit
    
   </h1>
   <p>
    
     One of the biggest challenges in software development is avoiding bugs.
    
    
     This is such a pervasive problem that we have taken to naming it something that suggests something bad has happened to our code.
    
    
     In fact, however, we should be calling bugs
    
    <em class="italic">
     
      mistakes
     
    </em>
    
     , because that is what
    
    
     
      they are.
     
    
   </p>
   <p>
    
     Since we have compilers, why can’t we place enough restrictions on the code so that they tell us when there’s a bug?
    
    
     We might be able to do just that, only not for free.
    
    
     We discussed template metaprogramming in the previous section, but we have left out one important characteristic: template metaprogramming is
    
    <a id="_idIndexMarker103">
    </a>
    
     Turing complete.
    
    
     This means that for any program that we can write in the normal way, we can also write it using
    
    
     
      template metaprogramming.
     
    
   </p>
   <p>
    
     This idea is very powerful, and it has been discussed in various contexts over time.
    
    
     If you want to try a programming language built entirely around this notion, try
    
    <a id="_idIndexMarker104">
    </a>
    
     Idris (
    
    <a href="https://www.idris-lang.org/">
     
      https://www.idris-lang.org/
     
    </a>
    
     ).
    
    
     Many programmers might be familiar with the support available in Haskell for validation at compilation time.
    
    
     But my first encounter with this idea was Andrei Alexandrescu’s seminal book
    
    <em class="italic">
     
      Modern C++ Design: Generic Programming and Design Patterns Applied
     
    </em>
    
     , published
    
    
     
      in 2001.
     
    
   </p>
   <p>
    
     Let’s consider a simple problem.
    
    
     One of the common sources for bugs
    
    <a id="_idIndexMarker105">
    </a>
    
     and code smell
    
    <a id="_idIndexMarker106">
    </a>
    
     is the so-called
    
    <strong class="bold">
     
      primitive obsession
     
    </strong>
    
     , that is, the
    
    <a id="_idIndexMarker107">
    </a>
    
     obsession to use primitive types to represent complex data.
    
    
     A typical example of primitive obsession is to represent length, money, temperature, or weight as a number, by completely ignoring their units of measure.
    
    
     Rather than doing this, a specific type for money would use a value that allows for a specific precision depending on the context, such as seven decimals for accounting and banks, and the currency.
    
    
     This is often useful in software development even when the program deals with a single currency because one thing you can bet on when it comes to features is that eventually, one thing will become more – there will be a time when your client will ask you to add a
    
    
     
      second currency.
     
    
   </p>
   <p>
    
     A typical challenge relating to
    
    <a id="_idIndexMarker108">
    </a>
    
     primitive obsession is with constraining primitive types.
    
    
     For example, consider a type that can store the hour of the day.
    
    
     Not only is this value an unsigned int, but it can only be from 0 to 23, assuming a 24-hour format for simplicity.
    
    
     It would be great to be able to tell the compiler that no value outside of the 0-23 range is ever accepted as an hour and to give a relevant error when passing, for example, a value
    
    
     
      of 27.
     
    
   </p>
   <p>
    
     In this case, an enum can be a solution, since the number of values is small.
    
    
     But we’ll ignore this option and consider first how we would implement this at runtime.
    
    
     We can imagine a class called
    
    <strong class="source-inline">
     
      Hour
     
    </strong>
    
     that throws an exception if the value passed in the constructor is not between 0
    
    
     
      and 23:
     
    
   </p>
   <pre class="source-code">
class Hour{
private:
int theValue = 0;
void setValue(int candidateValue) {
if(candidateValue &gt;= 0 &amp;&amp; candidateValue &lt;= 23){
theValue = candidateValue;
}
else{
throw std::out_of_range("Value out of range");
}
}
public:
Hour(int theValue){
setValue(theValue);
}
int value() const {
return theValue;
}
};
TEST_CASE("Valid hour"){
Hour hour(10);
CHECK_EQ(10, hour.value());
}
TEST_CASE("Invalid hour"){
CHECK_THROWS(Hour(30));
}</pre>
   <p>
    
     What if we want to move the check at
    
    <a id="_idIndexMarker109">
    </a>
    
     compile time?
    
    
     Well, time to use the power of
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     to tell the compiler what values are defined at compile time, and
    
    <strong class="source-inline">
     
      static_assert
     
    </strong>
    
     to verify
    
    
     
      the range:
     
    
   </p>
   <pre class="source-code">
template &lt;int Min, int Max&gt;
class RangedInteger{
private:
int theValue;
constexpr RangedInteger(int theValue) : theValue(theValue) {}
public:
template &lt;int CandidateValue&gt;
static constexpr RangedInteger make() {
static_assert(CandidateValue &gt;= Min &amp;&amp; CandidateValue &lt;= Max, "Value out of range.");
return CandidateValue;
}
constexpr int value() const {
return theValue;
}
};
using Hour = RangedInteger&lt;0, 23&gt;;</pre>
   <p>
    
     With the
    
    <a id="_idIndexMarker110">
    </a>
    
     preceding implementation, the following code
    
    
     
      works perfectly:
     
    
   </p>
   <pre class="source-code">
TEST_CASE("Valid hour"){
constexpr Hour h = Hour::make&lt;10&gt;();
CHECK_EQ(10, h.value());
}</pre>
   <p>
    
     But if we try to pass a value outside the range, we get a
    
    
     
      compilation error:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">TEST_CASE("Invalid hour"){</strong>
<strong class="bold">constexpr Hour h2 = Hour::make&lt;30&gt;();</strong>
<strong class="bold">}</strong>
Hour.h: In instantiation of 'static constexpr RangedInteger&lt;Min, Max&gt; RangedInteger&lt;Min, Max&gt;::make() [with int CandidateValue = 30; int Min = 0; int Max = 23]':
Hour.h:11:87: error: static assertion failed: Value out of range.
   11 |                                 static_assert(CandidateValue &gt;= Min &amp;&amp; CandidateValue &lt;= Max, "Value out of range.");
      |                ~~~~~~~~~~~~~~~^~~~~~
Hour.h:11:87: note: '(30 &lt;= 23)' evaluates to false</pre>
   <p>
    
     This error tells us that we can’t have an hour with the value 30, which is precisely what
    
    
     
      we needed!
     
    
   </p>
   <p>
    
     This is just one technique in the toolbox of C++ programmers who want to create programs that are provably valid at compile time.
    
    
     As we mentioned, template metaprogramming is Turing complete, which means we can theoretically implement any program at compile time that we can implement at runtime.
    
    
     As always, there are trade-offs.
    
    
     Notice how the
    
    <strong class="source-inline">
     
      Hour
     
    </strong>
    
     value must be
    
    <strong class="source-inline">
     
      constexpr
     
    </strong>
    
     , which means the value will be stored in the executable.
    
    
     This is by design, since the only way to constrain the types to the maximum is to compile them into
    
    
     
      the unit.
     
    
   </p>
   <p>
    
     In practice, I noticed that this
    
    <a id="_idIndexMarker111">
    </a>
    
     technique can easily lead to code that is extremely difficult to understand and modify.
    
    
     Making changes to this code requires a strong discipline, since modifying existing code can still introduce bugs that we otherwise have weeded out through our strong types.
    
    
     The fundamental technique is always to add, never to modify, unless to fix issues.
    
    
     We have kept this code clean until now, but types can get very abstract very quickly, which makes reconstructing the reasoning that led to them very difficult after, say, six months.
    
    
     On the upside, this technique works best when creating libraries focused on a very
    
    
     
      specific domain.
     
    
   </p>
   <p>
    
     While I find this technique intriguing, I tend to prefer more freedom when I program.
    
    
     I use my own disciplines – test-driven development, merciless refactoring, extreme attention to names, and simple design – when I code.
    
    
     I’d rather have a way to write the code that I want and let the compiler figure out the details, which is why the last paradigm I’m going to discuss ignores types as much
    
    
     
      as possible.
     
    
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor048">
    </a>
    
     What about ignoring types?
    
   </h1>
   <p>
    
     A few years ago, I led a
    
    <a id="_idIndexMarker112">
    </a>
    
     team that built a few web applications in a language called Groovy with a framework named Grails.
    
    
     Groovy
    
    <a id="_idIndexMarker113">
    </a>
    
     is an optionally typed and dynamic language, meaning that
    
    <a id="_idIndexMarker114">
    </a>
    
     it assigns types at runtime, but you can provide type hints for the compiler.
    
    
     It can also be compiled statically, and since it’s built on JVM, the code ends up in a
    
    
     
      Java unit.
     
    
   </p>
   <p>
    
     I had noticed in previous web projects that types were useful at the edges of the system, for checking request parameters, interacting with databases, and other I/O operations.
    
    
     But types in the core of a web application tended to make things more difficult.
    
    
     We often had to change code or write extra code to accommodate new ways of using the already-implemented behaviors, since users of web apps often notice a scenario that is useful and want it to work in other contexts or for other types of data.
    
    
     So, I decided from the very beginning that we would use types for request validation, to ensure security and correctness, and for the interaction with external systems, to ensure simplicity.
    
    
     But we did not use types in
    
    
     
      the core.
     
    
   </p>
   <p>
    
     The plan was always to use a sound strategy for automated testing so that all the code was proven valid through tests.
    
    
     I expected that the lack of types would make us write more tests, but I was in for a big surprise: the number of tests was relatively the same as before, but we had less code.
    
    
     Also, the code we wrote, because there were no types involved, pushed us to name things very carefully since names were the only hints we had as programmers as to what a function or a variable
    
    
     
      was doing.
     
    
   </p>
   <p>
    
     This is, to this day, my favorite style of programming.
    
    
     I want to write the code as I want, and as expressive as I can, and let the compiler work out the types.
    
    
     You can think about this approach as extreme polymorphism: if you pass a variable of a type that has the required methods, the code should work irrespective of the type you pass in.
    
    
     It is not a style I would recommend for everyone, because it’s not obvious if it works solely in combination with a specific design experience, but it is a style that you can experiment with.
    
    
     However, the first hurdle is to let go of controlling what the compiler does, a feat more difficult to achieve for C++ programmers who are
    
    
     
      very detailed-oriented.
     
    
   </p>
   <p>
    
     How would this work in C++?
    
    
     Well, fortunately for me, the
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     keyword was introduced in C++ since C++11, and its features were improved little by little in consequent standards.
    
    
     On the downside, C++ is not as permissive as Groovy on dynamic typing, so occasionally I
    
    
     
      need templates.
     
    
   </p>
   <p>
    
     First, let me amaze you with the most polymorphic function you
    
    
     
      can write:
     
    
   </p>
   <pre class="source-code">
auto identity(auto value){ return value;}
TEST_CASE("Identity"){
CHECK_EQ(1, identity(1));
CHECK_EQ("asdfasdf", identity("asdfasdf"));
CHECK_EQ(vector{1, 2, 3}, identity(vector{1, 2, 3}));
}</pre>
   <p>
    
     This function works no matter what we
    
    <a id="_idIndexMarker115">
    </a>
    
     pass into it.
    
    
     Isn’t that neat?
    
    
     Imagine that you have a bunch of functions like this that you can use in the core of your system, without needing to change them.
    
    
     That sounds like an ideal programming environment to me.
    
    
     Alas, life is more complicated than this, and programs need more than
    
    
     
      identity functions.
     
    
   </p>
   <p>
    
     Let’s look at a slightly more complicated example.
    
    
     We’ll start by checking whether a string is a palindrome, that is, whether it reads the same both forward and reversed.
    
    
     A simple implementation in C++ is to take the string, reverse it by using
    
    <strong class="source-inline">
     
      std::reverse_copy
     
    </strong>
    
     , and then compare the initial string with
    
    
     
      its reverse:
     
    
   </p>
   <pre class="source-code">
bool isStringPalindrome(std::string value){
std::vector&lt;char&gt; characters(value.begin(), value.end());
std::vector&lt;char&gt; reversedCharacters;
std::reverse_copy(characters.begin(), characters.end(), std::back_insert_iterator(reversedCharacters));
return characters == reversedCharacters;
}
TEST_CASE("Palindrome"){
CHECK(isStringPalindrome("asddsa"));
CHECK(isStringPalindrome("12321"));
CHECK_FALSE(isStringPalindrome("123123"));
CHECK_FALSE(isStringPalindrome("asd"));
}</pre>
   <p>
    
     What if we were to make this code less interested in types?
    
    
     First, we would change the parameter type to
    
    <strong class="source-inline">
     
      auto
     
    </strong>
    
     .
    
    
     Then, we need a way to reverse it without constraining ourselves to a string input.
    
    
     Fortunately, the
    
    <strong class="source-inline">
     
      ranges
     
    </strong>
    
     library has a
    
    <strong class="source-inline">
     
      reverse_view
     
    </strong>
    
     that we can use.
    
    
     Finally, we need to
    
    <a id="_idIndexMarker116">
    </a>
    
     compare the initial value with the reversed one, again without restraining the type too much.
    
    
     C++ provides us with
    
    <strong class="source-inline">
     
      std::equal
     
    </strong>
    
     .
    
    
     So, we end up with the following code, which we can use not only for strings but also for a
    
    <strong class="source-inline">
     
      vector&lt;string&gt;
     
    </strong>
    
     that represents a phrase, or with tokens defined in an enum.
    
    
     Let’s see the extreme polymorphism
    
    
     
      in action:
     
    
   </p>
   <pre class="source-code">
bool isPalindrome(auto value){
auto tokens = value | std::views::all;
auto reversedTokens = value | std::views::reverse;
return std::equal(tokens.begin(), tokens.end(), reversedTokens.begin());
};
enum Token{
X, Y
};
TEST_CASE("Extreme polymorphic palindrome"){
CHECK(isPalindrome(string("asddsa")));
CHECK(isPalindrome(vector&lt;string&gt;{"asd", "dsa", "dsa", "asd"}));
CHECK(isPalindrome(vector&lt;Token&gt;{Token::X, Token::Y, Token::Y, Token::X}));
}</pre>
   <p>
    
     Perhaps I have now shown you why I find this style of programming very appealing.
    
    
     If we ignore the types, or make our functions extremely polymorphic, we can write code that applies to future situations without needing to change.
    
    
     The trade-off is that the code has its constraints in the deducted types and that the names of the parameters and functions matter a lot.
    
    
     For example, if I pass in an integer value to
    
    <strong class="source-inline">
     
      isPalindrome
     
    </strong>
    
     , I will get a complicated error instead of the simple one telling me that the parameter is of the incorrect type.
    
    
     This is the beginning of the g++ compiler output on my computer when
    
    <a id="_idIndexMarker117">
    </a>
    
     trying to pass in
    
    
     
      an integer:
     
    
   </p>
   <pre class="source-code">
In file included from testPalindrome.cpp:3:
Palindrome.h: In instantiation of 'bool isPalindrome(auto:21)
[with auto:21 = int]':
testPalindrome.cpp:30:2:   required from here
Palindrome.h:14:29: error: no match for 'operator|' (operand t
ypes are 'int' and 'const std::ranges::views::_All')
   14 |         auto tokens = value | std::views::all;
      |                       ~~~~~~^~~~~~~~~~~~~~~~~</pre>
   <p>
    
     It’s now up to you: do you prefer strong types or extreme polymorphic behavior?
    
    
     Both have their trade-offs and their own
    
    
     
      application domains.
     
    
   </p>
   <h1 id="_idParaDest-50">
    <a id="_idTextAnchor049">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We have seen in this chapter that we can use multiple paradigms to program in C++.
    
    
     We looked briefly at a few: functional programming, metaprogramming, types that ensure compile-time validation, and extreme polymorphism.
    
    
     Each of these approaches, as well as the standard object-oriented and structured programming, are useful for various contexts when building libraries or specific programs.
    
    
     Each of them has something to offer to the curious programmer who wants to learn as much as possible about their craft.
    
    
     Each of them has its trade-offs and its own implementations in the world of
    
    
     
      software development.
     
    
   </p>
   <p>
    
     We have shown that C++ programmers perhaps only use a subset of the language, and it doesn’t have to be an object-oriented one.
    
    
     Instead, it’s best to experiment with all of them, making the most of the fact that C++ is powerful enough to offer so many options, and to pick and choose depending on the task
    
    
     
      at hand.
     
    
   </p>
   <p>
    
     In the next chapter, we will see that the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function might not actually be the entry point of
    
    
     
      our applications.
     
    
   </p>
  </div>
 </body></html>