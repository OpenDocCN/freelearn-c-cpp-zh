<html><head></head><body>
  <div id="_idContainer009">
   <h1 class="chapter-number" id="_idParaDest-38">
    <a id="_idTextAnchor037">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     3
    </span>
   </h1>
   <h1 id="_idParaDest-39">
    <a id="_idTextAnchor038">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     There’s a Single C++, and It Is Object-Oriented
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      Only if you ignore all
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       the others
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     C++ was born as C with objects, which makes many developers still consider it an OOP language.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We will see in this chapter that C++ allows multiple paradigms, and you could safely describe it as multiple programming languages in one.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     We will look at a few paradigms supported in C++, including structured programming, OOP, functional programming, and metaprogramming, in combination with the choice of strong versus
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      quasi-optional types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      The multiple facets
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       of C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Functional programming
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       in C++
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.13.1">
       Metaprogramming
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Strong types to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       the limit
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      What about
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       ignoring types?
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-40">
    <a id="_idTextAnchor039">
    </a>
    <span class="koboSpan" id="kobo.18.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.19.1">
     The code for this chapter is available from the GitHub repository
    </span>
    <a href="https://github.com/PacktPublishing/Debunking-CPP-Myths">
     <span class="koboSpan" id="kobo.20.1">
      https://github.com/PacktPublishing/Debunking-CPP-Myths
     </span>
    </a>
    <span class="koboSpan" id="kobo.21.1">
     , in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.22.1">
      ch3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.23.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.23.2">
     It uses Makefile, g++, and the doctest library (
    </span>
    <a href="https://github.com/doctest/doctest">
     <span class="koboSpan" id="kobo.24.1">
      https://github.com/doctest/doctest
     </span>
    </a>
    <span class="koboSpan" id="kobo.25.1">
     ) for unit testing.
    </span>
    <span class="koboSpan" id="kobo.25.2">
     The code is compiled
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.26.1">
      for C++20.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor040">
    </a>
    <span class="koboSpan" id="kobo.27.1">
     The multiple facets of C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     If you, like me, frequently move between different organizations, teams, and technical conferences, you will quickly notice two things: C++ programmers
    </span>
    <a id="_idIndexMarker070">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     have distinct interests compared to other developers, and the
    </span>
    <a id="_idIndexMarker071">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     C++ community
    </span>
    <a id="_idIndexMarker072">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     is more aptly described as small, specialized pockets of C++ developers.
    </span>
    <span class="koboSpan" id="kobo.31.2">
     That’s different from other communities; if you discuss Java, you’ll likely end up talking about Spring Framework and REST APIs or the Android toolkit.
    </span>
    <span class="koboSpan" id="kobo.31.3">
     C#
    </span>
    <a id="_idIndexMarker073">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     is mostly fairly standardized around the Microsoft libraries, and JavaScript is mostly about React.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     But get 100 C++ programmers in a room from different organizations and you’ll soon notice the differences.
    </span>
    <span class="koboSpan" id="kobo.32.3">
     Embedded C++ is all about keeping all the resources in check because adding an extra 1 MB of memory to a device sold in millions of units quickly pumps up the cost.
    </span>
    <span class="koboSpan" id="kobo.32.4">
     Game developers are on the other side of the spectrum, looking at how to squeeze extra frame rate out of next-generation GPUs and CPUs.
    </span>
    <span class="koboSpan" id="kobo.32.5">
     The high-frequency trading people know all about avoiding CPU cache misses and how to brush off a picosecond of the automated transaction algorithm because the smallest time fraction can mean millions of euros.
    </span>
    <span class="koboSpan" id="kobo.32.6">
     Engineering software developers are more relaxed, but still worried about the validity of the changes in a complex rendering model.
    </span>
    <span class="koboSpan" id="kobo.32.7">
     And then you find the programmers dealing with automated systems for rails, cars, or factories, whose main concern is resilience
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      and robustness.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     This picture, while far from complete, is enough to show us the immense variability of C++ programmers, unlike their peers using any other language.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     We could almost say that from a certain point of view, C++ is the last remaining de facto general-purpose language, since the other mainstream ones are used in practice mostly for specific types of programs: Java for enterprise backend services and Android development, C# for web and Windows applications and services, JavaScript for rich web frontends and serverless backends, and Python for scripts, data science, and DevOps.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     But C++ is in embedded software, factory systems, trading, simulations, engineering tools, operating systems, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     The old saying “form follows function” is about design applying to everything built by people, including programming languages, and applies equally well to C++.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     The large variability in projects and types of programmers fed into the language, along with Stroustrup’s desire to make it as capable as possible.
    </span>
    <span class="koboSpan" id="kobo.36.3">
     C++ is not a single language; every programmer uses a subset of C++ that is often different from their colleagues working in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      same organization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.38.1">
     Yes, C++ started as C with objects, at a time when OOP was on the rise.
    </span>
    <span class="koboSpan" id="kobo.38.2">
     But, at the same time, C++ is backward compatible with C, which means you can still write structured programming in C++.
    </span>
    <span class="koboSpan" id="kobo.38.3">
     Then, templates were needed.
    </span>
    <span class="koboSpan" id="kobo.38.4">
     Then, lambdas were useful.
    </span>
    <span class="koboSpan" id="kobo.38.5">
     While C++ has always been a collection of
    </span>
    <a id="_idIndexMarker074">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     different languages, today it’s even more so.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     To prove this point, let’s look at a few paradigms you can use in C++, starting with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      functional programming.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor041">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     Functional programming in C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     I remember being in university, fascinated about
    </span>
    <a id="_idIndexMarker075">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     programming, and already quite adept at writing BASIC, Pascal, Logo, and simple C++.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     I think it was in my second year
    </span>
    <a id="_idIndexMarker076">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     when I took a course on functional programming.
    </span>
    <span class="koboSpan" id="kobo.44.2">
     The teacher was very passionate and eager to show us the wonders of this paradigm, explaining a lot of concepts that I couldn’t quite grasp.
    </span>
    <span class="koboSpan" id="kobo.44.3">
     The course turned into a complete miss for me, since the only thing I learned was how to write imperative code in Lisp and how to translate the idioms I knew into something that would work in this weird language that wears its parentheses on the outside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      of expressions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.46.1">
     I tried to go back to functional programming after starting my career as a software engineer.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     There were plenty of resources online, only the way they explained the paradigm didn’t help.
    </span>
    <span class="koboSpan" id="kobo.46.3">
     “It’s basically category theory,” they said.
    </span>
    <span class="koboSpan" id="kobo.46.4">
     Everything is a function, even numbers (check out Church encoding).
    </span>
    <span class="koboSpan" id="kobo.46.5">
     You can easily understand monads since they are a monoid in the category of endofunctors.
    </span>
    <span class="koboSpan" id="kobo.46.6">
     This style of explanation uses a more complicated concept to explain a practical one and doesn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      facilitate understanding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     This is why it took me years to understand what functional programming is and how it helps with software development.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     I became a fan, but not a fanatic, of this paradigm.
    </span>
    <span class="koboSpan" id="kobo.48.3">
     Like any engineer, I like to solve problems, and in my case, most often I solve them with code.
    </span>
    <span class="koboSpan" id="kobo.48.4">
     Having code that is simpler is always great, although often simpler does not mean
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      more familiar.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     If I were to explain functional programming today, I would focus on three important things:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.51.1">
      immutability
     </span>
    </em>
    <span class="koboSpan" id="kobo.52.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.53.1">
      pure functions
     </span>
    </em>
    <span class="koboSpan" id="kobo.54.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.55.1">
      operations with functions
     </span>
    </em>
    <span class="koboSpan" id="kobo.56.1">
     .
    </span>
    <span class="koboSpan" id="kobo.56.2">
     Perhaps unexpectedly, C++ is a good fit for all these traits.
    </span>
    <span class="koboSpan" id="kobo.56.3">
     Immutability is where C++ shines compared to the other mainstream programming languages (although less than Rust, but we’ll talk about that in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      final chapter).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     However, there’s one catch: functional programming is a different paradigm, with its own trade-offs.
    </span>
    <span class="koboSpan" id="kobo.58.2">
     I’ve noticed that C++ programmers find it difficult to think about lambdas since they see lambdas not as a fundamental concept but as something built on top of the existing language.
    </span>
    <span class="koboSpan" id="kobo.58.3">
     That’s fair enough since lambdas are objects and not first-class design elements in C++.
    </span>
    <span class="koboSpan" id="kobo.58.4">
     However, thinking in a functional paradigm requires the programmers to temporarily forget this knowledge and embrace the functional design elements.
    </span>
    <span class="koboSpan" id="kobo.58.5">
     You can go back to
    </span>
    <a id="_idIndexMarker077">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     this knowledge when you have implemented something that works and are
    </span>
    <a id="_idIndexMarker078">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     looking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      for improvements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Let’s explain the three characteristics in more detail and then discuss the impact of using functional programming on our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      software architecture.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor042">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     Immutability
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     Immutability
    </span>
    <a id="_idIndexMarker079">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     fundamentally
    </span>
    <a id="_idIndexMarker080">
    </a>
    <span class="koboSpan" id="kobo.67.1">
     means that each variable is initialized with a value, but a new value cannot be assigned to the variable.
    </span>
    <span class="koboSpan" id="kobo.67.2">
     In C++, this can be done with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      const
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     , depending on whether we want the value to be immutable at runtime or at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      compile time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.73.1">
     While immutability is easy to understand for simple types, collections and objects introduce challenges.
    </span>
    <span class="koboSpan" id="kobo.73.2">
     An immutable collection is one that returns a new collection upon every change.
    </span>
    <span class="koboSpan" id="kobo.73.3">
     So, for example, the following code shows a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      mutable collection:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.75.1">
vector&lt;int&gt; numbers {1, 2, 3};
numbers.push_back(4);
assert(numbers == vector&lt;int&gt; {1, 2, 3, 4});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     Contrast this example with a hypothetic immutable collection, shown in the next code sample, that returns a new collection upon adding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.77.1">
      to it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.78.1">
immutable_vector&lt;int&gt; numbers {1, 2, 3};
immutable_vector&lt;int&gt; moreNumbers = numbers.push_back(4);
assert(numbers == immutable_vector&lt;int&gt; {1, 2, 3});
assert(moreNumbers == immutable_vector&lt;int&gt; {1, 2, 3, 4});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     This trait guarantees that you’re using the correct version of the data structure that you need.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     But the memory optimization bells might ring in your C++ brain.
    </span>
    <span class="koboSpan" id="kobo.79.3">
     There seems to be a lot of memory allocation happening for immutable collections!
    </span>
    <span class="koboSpan" id="kobo.79.4">
     Isn’t that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      a waste?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     It is indeed possible to be temporarily using more memory than you’d expect upon performing a change in an immutable collection.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     However, functional languages have found smart ways to avoid this, and C++ is perfectly capable of using the same mechanisms.
    </span>
    <span class="koboSpan" id="kobo.81.3">
     It depends on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      the implementation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     The way to
    </span>
    <a id="_idIndexMarker081">
    </a>
    <span class="koboSpan" id="kobo.84.1">
     optimize memory for immutable
    </span>
    <a id="_idIndexMarker082">
    </a>
    <span class="koboSpan" id="kobo.85.1">
     collections is to use
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.86.1">
      smart pointers
     </span>
    </em>
    <span class="koboSpan" id="kobo.87.1">
     .
    </span>
    <span class="koboSpan" id="kobo.87.2">
     Remember that values are immutable once assigned to a
    </span>
    <a id="_idIndexMarker083">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     Therefore, when the collection is first initialized, memory is allocated for each element of the collection and each memory area is assigned to a specific value.
    </span>
    <span class="koboSpan" id="kobo.88.3">
     When a new element is added, the pointers to each element are copied and a new memory area is allocated for the new value.
    </span>
    <span class="koboSpan" id="kobo.88.4">
     If an element is removed from the collection, all the pointers to existing elements are copied except the one pointing to the removed element.
    </span>
    <span class="koboSpan" id="kobo.88.5">
     Once a memory area is no longer referenced by any pointer, it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.89.1">
      gets deleted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.90.1">
     While
    </span>
    <a id="_idIndexMarker084">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     immutable collections are not implemented as such in STL, libraries such as immer (
    </span>
    <a href="https://github.com/arximboldi/immer">
     <span class="koboSpan" id="kobo.92.1">
      https://github.com/arximboldi/immer
     </span>
    </a>
    <span class="koboSpan" id="kobo.93.1">
     ) allow you to use this pattern without worrying too much about the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      internal details.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     OK, but what about immutable objects?
    </span>
    <span class="koboSpan" id="kobo.95.2">
     Isn’t the whole purpose of OOP to mix behavior
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.96.1">
      with data?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     To this, I have three things
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      to say.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     First,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      good question!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     Second, OOP was misunderstood to be about encapsulation, inheritance, and polymorphism when in fact it’s about message passing.
    </span>
    <span class="koboSpan" id="kobo.101.2">
     C++ was unfortunately the trendsetter for what I like to call “class-oriented programming”: a style of programming focused on classes and their relationships instead of objects and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      their relationships.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     And third, functional programming has in fact no qualms with objects.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     Implementing immutable objects is very simple: either we implement an immutable data structure using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.104.1">
      const
     </span>
    </strong>
    <span class="koboSpan" id="kobo.105.1">
     , or every method that changes data returns instead a new object with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      modified data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.107.1">
     It’s worth mentioning at this point that you don’t have to use immutability to its fullest in your programs to benefit from functional programming.
    </span>
    <span class="koboSpan" id="kobo.107.2">
     I write enough code that maximizes constness but still uses the standard STL collections and objects that change their internal data.
    </span>
    <span class="koboSpan" id="kobo.107.3">
     However, you need to be aware that the level of immutability described previously allows you to introduce parallelism much more easily into your programs.
    </span>
    <span class="koboSpan" id="kobo.107.4">
     If values cannot change, you have no problems with critical sections.
    </span>
    <span class="koboSpan" id="kobo.107.5">
     Each thread works with its
    </span>
    <a id="_idIndexMarker085">
    </a>
    <span class="koboSpan" id="kobo.108.1">
     own value, and changing the value will
    </span>
    <a id="_idIndexMarker086">
    </a>
    <span class="koboSpan" id="kobo.109.1">
     change it only for the specific thread.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     Indeed, this is one of the side benefits of immutability.
    </span>
    <span class="koboSpan" id="kobo.109.3">
     I say side benefits because immutability combined with pure functions and good naming gives you programs that are easier to understand once you get used to the building blocks.
    </span>
    <span class="koboSpan" id="kobo.109.4">
     So, let’s look at pure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      functions next.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor043">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     Pure functions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     A pure function
    </span>
    <a id="_idIndexMarker087">
    </a>
    <span class="koboSpan" id="kobo.113.1">
     is a function that returns the same output for the same input and doesn’t change any value in the context.
    </span>
    <span class="koboSpan" id="kobo.113.2">
     By definition, a pure
    </span>
    <a id="_idIndexMarker088">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     function cannot do
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.115.1">
      Input/Output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.117.1">
      I/O
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     ) operations.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     However, any non-trivial
    </span>
    <a id="_idIndexMarker089">
    </a>
    <span class="koboSpan" id="kobo.119.1">
     program can be written as a combination of pure functions and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      I/O functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     Pure functions are the simplest types of functions you can think of.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     They are easy to understand, very predictable, and cacheable because they lack side effects.
    </span>
    <span class="koboSpan" id="kobo.121.3">
     This leads to easy testing with data-driven unit tests and potential optimizations such as caching the result of the function upon first call with specific inputs and reusing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      it later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     Pure functions are at the core of functional programming.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     In C++, they are very easy to implement using the support
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      for immutability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     The original way of writing functions in pure functional languages is lambdas.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     Lambdas have made their way into the standard since C++11.
    </span>
    <span class="koboSpan" id="kobo.125.3">
     However, C++ lambdas can be mutable because they can change the variables they capture in their context.
    </span>
    <span class="koboSpan" id="kobo.125.4">
     So, writing pure functions in C++, even with lambdas, requires you to ensure the constness of all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      variables involved.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     In a functional paradigm, everything is either a function or a data structure, and in pure functional languages, the two are interchangeable.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     So, how do we create complex behaviors from simple functions?
    </span>
    <span class="koboSpan" id="kobo.127.3">
     We compose functions using various operations,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      of course.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-45">
    <a id="_idTextAnchor044">
    </a>
    <span class="koboSpan" id="kobo.129.1">
     Operations on functions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     Since functions are the main design element
    </span>
    <a id="_idIndexMarker090">
    </a>
    <span class="koboSpan" id="kobo.131.1">
     of functional programming, it’s par to the course to think about how functions can change through operations.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     The most common functional operations are partial application
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.132.1">
      and composition.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.133.1">
     Partial application refers to creating a new function by binding the value of one parameter of a function to a specific value.
    </span>
    <span class="koboSpan" id="kobo.133.2">
     For example, if we have a function,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.134.1">
      add(const int first, const int second)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     , we can obtain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.136.1">
      increment(const int)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     function by binding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      second
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     parameter to the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     .
    </span>
    <span class="koboSpan" id="kobo.141.2">
     Let’s take a moment to consider the consequence: every function, no matter how many arguments it receives, can be reduced through subsequent partial applications to functions that take no parameters.
    </span>
    <span class="koboSpan" id="kobo.141.3">
     This gives us a universal language for expressing anything
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.142.1">
      in code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.143.1">
     To implement a partial application in C++, we can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      std::bind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     function from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      &lt;functional&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     header.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     Let’s see how we can obtain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      increment
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     function from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     function by binding the second parameter of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      value
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.155.1">
       1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.157.1">
#include &lt;functional&gt;
auto add = [](const int first, const int second){ return first + second; };
auto increment = std::bind(add, std::placeholders::_1, 1);
TEST_CASE("add"){
        CHECK_EQ(10, add(4, 6));
}
TEST_CASE("increment"){
        CHECK_EQ(10, increment(9));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     This is a neat solution from a functional programming perspective.
    </span>
    <span class="koboSpan" id="kobo.158.2">
     However, the return value is complicated and approximates a function instead of being a function.
    </span>
    <span class="koboSpan" id="kobo.158.3">
     This is one of the mental hurdles for C++ programmers when trying functional programming.
    </span>
    <span class="koboSpan" id="kobo.158.4">
     I’ve been away from the language long enough to allow myself to think in higher-level concepts instead of always analyzing the implementation.
    </span>
    <span class="koboSpan" id="kobo.158.5">
     So, when I use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.159.1">
      std::bind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.160.1">
     to do the partial application, I treat the result as a function and hope the implementors have done their job of optimizing and providing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      necessary behaviors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     The other fundamental operation with functions is functional composition.
    </span>
    <span class="koboSpan" id="kobo.162.2">
     You’ve probably encountered this construct in mathematics.
    </span>
    <span class="koboSpan" id="kobo.162.3">
     Functional composition refers to creating a function,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.163.1">
      f
     </span>
    </em>
    <span class="koboSpan" id="kobo.164.1">
     , from two functions,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.165.1">
      g
     </span>
    </em>
    <span class="koboSpan" id="kobo.166.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.167.1">
      h
     </span>
    </em>
    <span class="koboSpan" id="kobo.168.1">
     , such that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.169.1">
      f(x) = g(h(x))
     </span>
    </em>
    <span class="koboSpan" id="kobo.170.1">
     for any value
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.171.1">
      x
     </span>
    </em>
    <span class="koboSpan" id="kobo.172.1">
     .
    </span>
    <span class="koboSpan" id="kobo.172.2">
     This is commonly denoted in math as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.173.1">
      f =
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.174.1">
       g
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.175.1">
       ∘
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.176.1">
       h
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.178.1">
     Unfortunately, there’s no
    </span>
    <a id="_idIndexMarker091">
    </a>
    <span class="koboSpan" id="kobo.179.1">
     function or operation in the C++ standard that implements functional composition, but it’s easy to implement this operation with templates.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     Once again, the result of this operation in C++ is complicated, but I encourage you to think about it as a function rather than the actual
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      data structure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     Let’s see a possible implementation for functional composition in C++.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      compose
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     function takes two type parameters,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      F
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.186.1">
      G
     </span>
    </strong>
    <span class="koboSpan" id="kobo.187.1">
     , that each denote the type of functions
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.188.1">
      f
     </span>
    </strong>
    <span class="koboSpan" id="kobo.189.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.190.1">
      g
     </span>
    </strong>
    <span class="koboSpan" id="kobo.191.1">
     to compose.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      compose
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     function returns a lambda that takes one parameter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     , and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      returns
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.197.1">
       f(g(value)
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.199.1">
template &lt;class F, class G&gt;
auto compose(F f, G g){
  return [=](auto value){return f(g(value));};
}</span></pre>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.200.1">
     Note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.201.1">
     The preceding example is borrowed from Alex’s other book on the topic with Packt Publishing,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.202.1">
      Hands-On Functional Programming
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.203.1">
       in C++
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.205.1">
     Let’s see how we could use this function with a simple example.
    </span>
    <span class="koboSpan" id="kobo.205.2">
     Let’s implement a price calculator that takes as parameters the price, a discount, a service fee, and tax and returns the final price.
    </span>
    <span class="koboSpan" id="kobo.205.3">
     Let’s look first at an imperative implementation, using a single function that computes everything inline.
    </span>
    <span class="koboSpan" id="kobo.205.4">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      computePriceImperative
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     function takes the price, subtracts the discount, adds the service fee, and then adds the tax percentage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      on top:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.209.1">
double computePriceImperative(const int taxPercentage, const int serviceFee, const double price, const int discount){
return (price - discount + serviceFee) * (1 + (static_cast&lt;double&gt;(taxPercentage) / 100));
}
TEST_CASE("compute price imperative"){
        int taxPercentage = 18;
        int serviceFee = 10;
        double price = 100;
        int discount = 10;
                                   double result = computePriceImperative(taxPercentage, serviceFee, price, discount);
        CHECK_EQ(118, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     This is a simple implementation, and good enough to give a result.
    </span>
    <span class="koboSpan" id="kobo.210.2">
     Challenges usually appear for this type of code when we need to add more types of discounts, modify taxes depending on items, or change the order of discounts.
    </span>
    <span class="koboSpan" id="kobo.210.3">
     Of course, we can apply an imperative or object-oriented style when the time comes, and extract multiple functions, one for each operation, that we then combine however
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.211.1">
      we need.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.212.1">
     But let’s look at the functional
    </span>
    <a id="_idIndexMarker092">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     style now.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     The first thing we can do is to use lambdas for every operation, and another lambda for the final computation.
    </span>
    <span class="koboSpan" id="kobo.213.3">
     We implement a few lambdas: one that subtracts the discount from the price, a second that applies the service fee, a third that applies the tax, and a final one that computes the price by chaining calls to all the previously defined lambdas.
    </span>
    <span class="koboSpan" id="kobo.213.4">
     We end up with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.215.1">
auto discountPrice = [](const double price, const int discount){return price - discount;};
auto addServiceFee = [](const double price, const int serviceFee){ return price + serviceFee; };
auto applyTax = [](const double price, const int taxPercentage){ return price * (1 + static_cast&lt;double&gt;(taxPercentage)/100); };
auto computePriceLambda = [](const int taxPercentage, const int serviceFee, const double price, const int discount){
return applyTax(addServiceFee(discountPrice(price, discount), serviceFee), taxPercentage);
};
TEST_CASE("compute price with lambda"){
int taxPercentage = 18;
int serviceFee = 10;
double price = 100;
int discount = 10;
double result = computePriceLambda(taxPercentage, serviceFee, price, discount);
CHECK_EQ(118, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     Is this code better?
    </span>
    <span class="koboSpan" id="kobo.216.2">
     Well, it depends.
    </span>
    <span class="koboSpan" id="kobo.216.3">
     One factor is familiarity with this paradigm, but don’t let that stop you; as I said before, familiarity is often confused with simplicity, but the two are not the same.
    </span>
    <span class="koboSpan" id="kobo.216.4">
     Another factor is to see the lambdas as functions and not as data structures.
    </span>
    <span class="koboSpan" id="kobo.216.5">
     Once you pass these two challenges, we notice a few things: the lambdas are very small, they are
    </span>
    <a id="_idIndexMarker093">
    </a>
    <span class="koboSpan" id="kobo.217.1">
     easy to understand, and they are pure functions, which are objectively the simplest types of functions out there.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     We can chain the calls in multiple ways, for example, applying the discount at the price with tax, so we have more options with this implementation.
    </span>
    <span class="koboSpan" id="kobo.217.3">
     Still, there’s nothing we couldn’t do with imperative programming
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.218.1">
      until now.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.219.1">
     Let’s then take the next
    </span>
    <a id="_idIndexMarker094">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     step and make this fully functional.
    </span>
    <span class="koboSpan" id="kobo.220.2">
     We will use the lambdas we created, but instead of returning a value, our implementation will use partial application and functional composition to return a function that gives us the answer we are looking for.
    </span>
    <span class="koboSpan" id="kobo.220.3">
     Since the preceding lambdas have two parameters, we need to bind one of the arguments to the corresponding input before applying the functional composition.
    </span>
    <span class="koboSpan" id="kobo.220.4">
     So, for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      discountPrice
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     lambda, we bind the discount argument to the value passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      computePriceFunctional
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     function and we obtain a lambda that takes a single parameter, the initial price, and returns the price with a discount.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     For the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      addServiceFee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     lambda, we bind the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      serviceFee
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     argument to the value passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      computePriceFunctional
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     function and obtain a function that takes a single parameter, the price before service, and returns the price with the service fee.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     For the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      applyTax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     lambda, we bind the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.233.1">
      taxPercentage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.234.1">
     argument to the value passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      computePriceFunctional
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     function and we obtain a function that takes a single parameter, the price without tax, and returns the price with tax.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Once we obtain these functions that take a single parameter, we compose them using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      compose
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     function shown previously, and we obtain a function that takes a single argument price and, when called, computes the correct final price.
    </span>
    <span class="koboSpan" id="kobo.238.2">
     Here is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      the result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.240.1">
auto computePriceFunctional(const int taxPercentage, const int serviceFee, const double price, const int discount){
using std::bind;
using std::placeholders::_1;
auto discountLambda = bind(discountPrice, _1, discount);
auto serviceFeeLambda = bind(addServiceFee, _1, serviceFee);
auto applyTaxLambda = bind(applyTax, _1, taxPercentage);
return compose( applyTaxLambda, compose(serviceFeeLambda, discountLambda));
}
TEST_CASE("compute price functional"){
int taxPercentage = 18;
int serviceFee = 10;
double price = 100;
int discount = 10;
auto computePriceLambda = computePriceFunctional(taxPercentage, serviceFee, price, discount);
double result = computePriceLambda(price);
CHECK_EQ(118, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     This style of programming is at first glance very different from what OOP or structured programming does.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     But if you think for a little bit, you will realize that an object is just a set of cohesive, partially applied functions.
    </span>
    <span class="koboSpan" id="kobo.241.3">
     If you extract the functions from objects, you need to pass in the data members used in the object, a style familiar to those who have ever programmed in C.
    </span>
    <span class="koboSpan" id="kobo.241.4">
     Including a method in an object is therefore equivalent to binding a few of the
    </span>
    <a id="_idIndexMarker095">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     arguments to the object data members that are initialized by the constructor.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     Therefore, OOP and functional programming are not really enemies, just different and equivalent ways of expressing the same behavior, with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      different trade-offs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     As a prelude to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.245.1">
      Metaprogramming
     </span>
    </em>
    <span class="koboSpan" id="kobo.246.1">
     section coming later, let’s look at making all these functions available at compile time.
    </span>
    <span class="koboSpan" id="kobo.246.2">
     We need to do a little bit of magic with templates and pass in the value parameters as template arguments, and we need to add a lot of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.247.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.248.1">
     , but the following code works
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      equally well:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.250.1">
template &lt;class F, class G&gt;
  constexpr auto compose(F f, G g){
    return [=](auto value){return f(g(value));};
  }
constexpr auto discountPriceCompile = [](const double price,   const int discount){return price - discount;};
  constexpr auto addServiceFeeCompile = [](const double price,   const int serviceFee){ return price + serviceFee; };
  constexpr auto applyTaxCompile = [](const double price, cons  t int taxPercentage){ return price * (1 + static_cast&lt;double  &gt;(taxPercentage)/100); };
  template&lt;int taxPercentage, int serviceFee, double price, in  t discount&gt;
  constexpr auto computePriceFunctionalCompile() {
          using std::bind;
          using std::placeholders::_1;
          constexpr auto discountLambda = bind(discountPrice,   _1, discount);
          constexpr auto serviceFeeLambda = bind(addServiceFee  , _1, serviceFee);
          constexpr auto applyTaxLambda = bind(applyTax, _1, t  axPercentage);
          return compose( applyTaxLambda, compose(serviceFeeLa  mbda, discountLambda));
  }
TEST_CASE("compute price functional compile"){
        constexpr int taxPercentage = 18;
        constexpr int serviceFee = 10;
        constexpr double price = 100;
        constexpr int discount = 10;
        constexpr auto computePriceLambda = computePriceFunctionalCompile&lt;taxPercentage, serviceFee, price, discount&gt;();
        double result = computePriceLambda(price);
        CHECK_EQ(118, result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     With this, we have seen the fundamental blocks of functional programming in C++.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     Let’s now look at where and why they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      are useful.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-46">
    <a id="_idTextAnchor045">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     Architectural patterns in functional style
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     Let’s first look at how we would
    </span>
    <a id="_idIndexMarker096">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     implement an application going all the way to the functional style.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     We can’t discuss all the possible design patterns of such an application, but we can show a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      few examples.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     We notice first that functional programming places a few constraints upon our design.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     We favor immutability and pure functions.
    </span>
    <span class="koboSpan" id="kobo.257.3">
     We use data structures, but they are immutable, meaning that every change to the data structure gives us a new version.
    </span>
    <span class="koboSpan" id="kobo.257.4">
     Finally, the I/O part needs to be separate and as thin as possible since it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      needs mutations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     A simple design pattern using these constraints is the pipe pattern.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     Let’s imagine we receive a file in XML format, and we call web services with data from it.
    </span>
    <span class="koboSpan" id="kobo.259.3">
     We have an input layer that reads the XML file, an output layer that writes to web services, and a layer in the center that uses a functional style.
    </span>
    <span class="koboSpan" id="kobo.259.4">
     We can now consider the input and output data and implement consequent transformations on the input that lead to the desired output.
    </span>
    <span class="koboSpan" id="kobo.259.5">
     Each of these transformations is a pure function working on immutable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      data structures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     Such a process is highly parallelizable because of the lack of mutation.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     In fact, C++17 introduced the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      &lt;execution&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     header, which allows running the common STL algorithms in parallel.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     Similar patterns are used in data transformation architectures such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.264.1">
      Extract, Transform, Load
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.266.1">
      ETL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     ) and in
    </span>
    <a id="_idIndexMarker097">
    </a>
    <span class="koboSpan" id="kobo.268.1">
     the MapReduce architecture made popular
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      by Hadoop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     The pattern can be extended beyond data
    </span>
    <a id="_idIndexMarker098">
    </a>
    <span class="koboSpan" id="kobo.271.1">
     transformation, to the more loosely defined
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.272.1">
      functional core, imperative shell
     </span>
    </strong>
    <span class="koboSpan" id="kobo.273.1">
     architecture, aptly named by Gary Bernhardt.
    </span>
    <span class="koboSpan" id="kobo.273.2">
     If you want more specific details, look into the hexagonal architecture with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      functional core.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     This shows not only that we can design programs using a functional paradigm in C++ but also that there are situations when this architecture fits.
    </span>
    <span class="koboSpan" id="kobo.275.2">
     It also shows that we can take some parts of this style of programming and use it on pieces of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      our implementation.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-47">
    <a id="_idTextAnchor046">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     Metaprogramming
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     One thing seems to unite programmers, no
    </span>
    <a id="_idIndexMarker099">
    </a>
    <span class="koboSpan" id="kobo.279.1">
     matter how different they are otherwise: the enjoyment of jokes on recursion.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     There’s something in the programmer’s mind that appreciates a certain type of symmetry.
    </span>
    <span class="koboSpan" id="kobo.279.3">
     When it comes to programming languages and programming paradigms, you’d be hard-pressed to find a more symmetrical type of language than one that can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      understand itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     The corresponding programming paradigm is called metaprogramming, and programming languages that take this idea to the limit are known as homoiconic, meaning that a program can manipulate another program’s representation or its own as data.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Programming languages that have this property include Lisp and its derived dialects, the latest
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      being Clojure.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     Metaprogramming is very powerful, but also very difficult to master, and can introduce a lot of issues in large projects.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     Some features connected to metaprogramming are available in modern languages, such as instrumentation, reflection, or dynamic execution of instructions.
    </span>
    <span class="koboSpan" id="kobo.283.3">
     But other than using annotations, very little of all this is used
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      in practice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.285.1">
     C++ is different, however.
    </span>
    <span class="koboSpan" id="kobo.285.2">
     One feature of metaprogramming is the ability to move computations from runtime to compile time, and C++ has fully embraced it with template metaprogramming.
    </span>
    <span class="koboSpan" id="kobo.285.3">
     In more recent versions of the language, the implementation of compile-time computations has been simplified with the introduction of generalized constant expressions with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      constexpr
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.288.1">
       consteval
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     A typical example of this technique is the
    </span>
    <a id="_idIndexMarker100">
    </a>
    <span class="koboSpan" id="kobo.291.1">
     factorial implementation.
    </span>
    <span class="koboSpan" id="kobo.291.2">
     A recursive factorial implementation computed at runtime looks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.293.1">
int factorial(const int number){
    if(number == 0) return 1;
    return number * factorial(number – 1);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     The same implementation
    </span>
    <a id="_idIndexMarker101">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     can be done using template metaprogramming.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     It is perhaps a lesser-known characteristic of C++ templates that they can take a value as a parameter, not just a type.
    </span>
    <span class="koboSpan" id="kobo.295.3">
     Moreover, both a generic template, for example, one that takes any integer value as a parameter, and a specialization, which takes only a specific value, can be provided.
    </span>
    <span class="koboSpan" id="kobo.295.4">
     In our case, we can implement a factorial template that takes an integer and a specialization for the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     , resulting in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.299.1">
template&lt;int number&gt;
struct Factorial {
enum { value = number * Factorial&lt;number – 1&gt;::value};
};
template&lt;&gt;
struct Factorial&lt;0&gt;{
enum {value = 1};
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.300.1">
     This implementation achieves the same goal as the previous one, with the exception that a call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.301.1">
      Factorial&lt;25&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     , for example, will be computed at compile time rather than runtime.
    </span>
    <span class="koboSpan" id="kobo.302.2">
     Starting with C++11 and generalized constant expressions, we can avoid templates altogether and instead use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.303.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      consteval
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     to tell the compiler which values are to be computed at compile time.
    </span>
    <span class="koboSpan" id="kobo.306.2">
     Here’s a simplified implementation of the same code with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      constant expression:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.308.1">
constexpr int factorial(const int number) {
return (number == 0) ? </span><span class="koboSpan" id="kobo.308.2">1 : (number * factorial(number - 1));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     These metaprogramming techniques available to C++ programmers allow more flexibility in decisions related to what happens at compile time versus runtime.
    </span>
    <span class="koboSpan" id="kobo.309.2">
     They offer a trade-off of CPU cycles versus the executable size.
    </span>
    <span class="koboSpan" id="kobo.309.3">
     If you have a lot of memory available but the
    </span>
    <a id="_idIndexMarker102">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     computations need to happen extremely fast, caching results in the executable can be the way to go, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.313.1">
      consteval
     </span>
    </strong>
    <span class="koboSpan" id="kobo.314.1">
     become
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      your friends.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     But the possibilities don’t stop here.
    </span>
    <span class="koboSpan" id="kobo.316.2">
     We can create in C++ programs that are demonstrably valid from compilation.
    </span>
    <span class="koboSpan" id="kobo.316.3">
     We just need to take strong types to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      their limit.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-48">
    <a id="_idTextAnchor047">
    </a>
    <span class="koboSpan" id="kobo.318.1">
     Strong types to the limit
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     One of the biggest challenges in software development is avoiding bugs.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     This is such a pervasive problem that we have taken to naming it something that suggests something bad has happened to our code.
    </span>
    <span class="koboSpan" id="kobo.319.3">
     In fact, however, we should be calling bugs
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.320.1">
      mistakes
     </span>
    </em>
    <span class="koboSpan" id="kobo.321.1">
     , because that is what
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      they are.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.323.1">
     Since we have compilers, why can’t we place enough restrictions on the code so that they tell us when there’s a bug?
    </span>
    <span class="koboSpan" id="kobo.323.2">
     We might be able to do just that, only not for free.
    </span>
    <span class="koboSpan" id="kobo.323.3">
     We discussed template metaprogramming in the previous section, but we have left out one important characteristic: template metaprogramming is
    </span>
    <a id="_idIndexMarker103">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     Turing complete.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     This means that for any program that we can write in the normal way, we can also write it using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.325.1">
      template metaprogramming.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     This idea is very powerful, and it has been discussed in various contexts over time.
    </span>
    <span class="koboSpan" id="kobo.326.2">
     If you want to try a programming language built entirely around this notion, try
    </span>
    <a id="_idIndexMarker104">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     Idris (
    </span>
    <a href="https://www.idris-lang.org/">
     <span class="koboSpan" id="kobo.328.1">
      https://www.idris-lang.org/
     </span>
    </a>
    <span class="koboSpan" id="kobo.329.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.329.2">
     Many programmers might be familiar with the support available in Haskell for validation at compilation time.
    </span>
    <span class="koboSpan" id="kobo.329.3">
     But my first encounter with this idea was Andrei Alexandrescu’s seminal book
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.330.1">
      Modern C++ Design: Generic Programming and Design Patterns Applied
     </span>
    </em>
    <span class="koboSpan" id="kobo.331.1">
     , published
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      in 2001.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     Let’s consider a simple problem.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     One of the common sources for bugs
    </span>
    <a id="_idIndexMarker105">
    </a>
    <span class="koboSpan" id="kobo.334.1">
     and code smell
    </span>
    <a id="_idIndexMarker106">
    </a>
    <span class="koboSpan" id="kobo.335.1">
     is the so-called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.336.1">
      primitive obsession
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     , that is, the
    </span>
    <a id="_idIndexMarker107">
    </a>
    <span class="koboSpan" id="kobo.338.1">
     obsession to use primitive types to represent complex data.
    </span>
    <span class="koboSpan" id="kobo.338.2">
     A typical example of primitive obsession is to represent length, money, temperature, or weight as a number, by completely ignoring their units of measure.
    </span>
    <span class="koboSpan" id="kobo.338.3">
     Rather than doing this, a specific type for money would use a value that allows for a specific precision depending on the context, such as seven decimals for accounting and banks, and the currency.
    </span>
    <span class="koboSpan" id="kobo.338.4">
     This is often useful in software development even when the program deals with a single currency because one thing you can bet on when it comes to features is that eventually, one thing will become more – there will be a time when your client will ask you to add a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      second currency.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.340.1">
     A typical challenge relating to
    </span>
    <a id="_idIndexMarker108">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     primitive obsession is with constraining primitive types.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     For example, consider a type that can store the hour of the day.
    </span>
    <span class="koboSpan" id="kobo.341.3">
     Not only is this value an unsigned int, but it can only be from 0 to 23, assuming a 24-hour format for simplicity.
    </span>
    <span class="koboSpan" id="kobo.341.4">
     It would be great to be able to tell the compiler that no value outside of the 0-23 range is ever accepted as an hour and to give a relevant error when passing, for example, a value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      of 27.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     In this case, an enum can be a solution, since the number of values is small.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     But we’ll ignore this option and consider first how we would implement this at runtime.
    </span>
    <span class="koboSpan" id="kobo.343.3">
     We can imagine a class called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      Hour
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     that throws an exception if the value passed in the constructor is not between 0
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      and 23:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.347.1">
class Hour{
private:
int theValue = 0;
void setValue(int candidateValue) {
if(candidateValue &gt;= 0 &amp;&amp; candidateValue &lt;= 23){
theValue = candidateValue;
}
else{
throw std::out_of_range("Value out of range");
}
}
public:
Hour(int theValue){
setValue(theValue);
}
int value() const {
return theValue;
}
};
TEST_CASE("Valid hour"){
Hour hour(10);
CHECK_EQ(10, hour.value());
}
TEST_CASE("Invalid hour"){
CHECK_THROWS(Hour(30));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     What if we want to move the check at
    </span>
    <a id="_idIndexMarker109">
    </a>
    <span class="koboSpan" id="kobo.349.1">
     compile time?
    </span>
    <span class="koboSpan" id="kobo.349.2">
     Well, time to use the power of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     to tell the compiler what values are defined at compile time, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      static_assert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     to verify
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      the range:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.355.1">
template &lt;int Min, int Max&gt;
class RangedInteger{
private:
int theValue;
constexpr RangedInteger(int theValue) : theValue(theValue) {}
public:
template &lt;int CandidateValue&gt;
static constexpr RangedInteger make() {
static_assert(CandidateValue &gt;= Min &amp;&amp; CandidateValue &lt;= Max, "Value out of range.");
return CandidateValue;
}
constexpr int value() const {
return theValue;
}
};
using Hour = RangedInteger&lt;0, 23&gt;;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     With the
    </span>
    <a id="_idIndexMarker110">
    </a>
    <span class="koboSpan" id="kobo.357.1">
     preceding implementation, the following code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      works perfectly:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.359.1">
TEST_CASE("Valid hour"){
constexpr Hour h = Hour::make&lt;10&gt;();
CHECK_EQ(10, h.value());
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     But if we try to pass a value outside the range, we get a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      compilation error:
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.362.1">TEST_CASE("Invalid hour"){</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">constexpr Hour h2 = Hour::make&lt;30&gt;();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.364.1">}</span></strong><span class="koboSpan" id="kobo.365.1">
Hour.h: In instantiation of 'static constexpr RangedInteger&lt;Min, Max&gt; RangedInteger&lt;Min, Max&gt;::make() [with int CandidateValue = 30; int Min = 0; int Max = 23]':
Hour.h:11:87: error: static assertion failed: Value out of range.
</span><span class="koboSpan" id="kobo.365.2">   11 |                                 static_assert(CandidateValue &gt;= Min &amp;&amp; CandidateValue &lt;= Max, "Value out of range.");
      |                ~~~~~~~~~~~~~~~^~~~~~
Hour.h:11:87: note: '(30 &lt;= 23)' evaluates to false</span></pre>
   <p>
    <span class="koboSpan" id="kobo.366.1">
     This error tells us that we can’t have an hour with the value 30, which is precisely what
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      we needed!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.368.1">
     This is just one technique in the toolbox of C++ programmers who want to create programs that are provably valid at compile time.
    </span>
    <span class="koboSpan" id="kobo.368.2">
     As we mentioned, template metaprogramming is Turing complete, which means we can theoretically implement any program at compile time that we can implement at runtime.
    </span>
    <span class="koboSpan" id="kobo.368.3">
     As always, there are trade-offs.
    </span>
    <span class="koboSpan" id="kobo.368.4">
     Notice how the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.369.1">
      Hour
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     value must be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      constexpr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     , which means the value will be stored in the executable.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     This is by design, since the only way to constrain the types to the maximum is to compile them into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      the unit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     In practice, I noticed that this
    </span>
    <a id="_idIndexMarker111">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     technique can easily lead to code that is extremely difficult to understand and modify.
    </span>
    <span class="koboSpan" id="kobo.375.2">
     Making changes to this code requires a strong discipline, since modifying existing code can still introduce bugs that we otherwise have weeded out through our strong types.
    </span>
    <span class="koboSpan" id="kobo.375.3">
     The fundamental technique is always to add, never to modify, unless to fix issues.
    </span>
    <span class="koboSpan" id="kobo.375.4">
     We have kept this code clean until now, but types can get very abstract very quickly, which makes reconstructing the reasoning that led to them very difficult after, say, six months.
    </span>
    <span class="koboSpan" id="kobo.375.5">
     On the upside, this technique works best when creating libraries focused on a very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      specific domain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     While I find this technique intriguing, I tend to prefer more freedom when I program.
    </span>
    <span class="koboSpan" id="kobo.377.2">
     I use my own disciplines – test-driven development, merciless refactoring, extreme attention to names, and simple design – when I code.
    </span>
    <span class="koboSpan" id="kobo.377.3">
     I’d rather have a way to write the code that I want and let the compiler figure out the details, which is why the last paradigm I’m going to discuss ignores types as much
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      as possible.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor048">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     What about ignoring types?
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.380.1">
     A few years ago, I led a
    </span>
    <a id="_idIndexMarker112">
    </a>
    <span class="koboSpan" id="kobo.381.1">
     team that built a few web applications in a language called Groovy with a framework named Grails.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     Groovy
    </span>
    <a id="_idIndexMarker113">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     is an optionally typed and dynamic language, meaning that
    </span>
    <a id="_idIndexMarker114">
    </a>
    <span class="koboSpan" id="kobo.383.1">
     it assigns types at runtime, but you can provide type hints for the compiler.
    </span>
    <span class="koboSpan" id="kobo.383.2">
     It can also be compiled statically, and since it’s built on JVM, the code ends up in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      Java unit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     I had noticed in previous web projects that types were useful at the edges of the system, for checking request parameters, interacting with databases, and other I/O operations.
    </span>
    <span class="koboSpan" id="kobo.385.2">
     But types in the core of a web application tended to make things more difficult.
    </span>
    <span class="koboSpan" id="kobo.385.3">
     We often had to change code or write extra code to accommodate new ways of using the already-implemented behaviors, since users of web apps often notice a scenario that is useful and want it to work in other contexts or for other types of data.
    </span>
    <span class="koboSpan" id="kobo.385.4">
     So, I decided from the very beginning that we would use types for request validation, to ensure security and correctness, and for the interaction with external systems, to ensure simplicity.
    </span>
    <span class="koboSpan" id="kobo.385.5">
     But we did not use types in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.386.1">
      the core.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.387.1">
     The plan was always to use a sound strategy for automated testing so that all the code was proven valid through tests.
    </span>
    <span class="koboSpan" id="kobo.387.2">
     I expected that the lack of types would make us write more tests, but I was in for a big surprise: the number of tests was relatively the same as before, but we had less code.
    </span>
    <span class="koboSpan" id="kobo.387.3">
     Also, the code we wrote, because there were no types involved, pushed us to name things very carefully since names were the only hints we had as programmers as to what a function or a variable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      was doing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     This is, to this day, my favorite style of programming.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     I want to write the code as I want, and as expressive as I can, and let the compiler work out the types.
    </span>
    <span class="koboSpan" id="kobo.389.3">
     You can think about this approach as extreme polymorphism: if you pass a variable of a type that has the required methods, the code should work irrespective of the type you pass in.
    </span>
    <span class="koboSpan" id="kobo.389.4">
     It is not a style I would recommend for everyone, because it’s not obvious if it works solely in combination with a specific design experience, but it is a style that you can experiment with.
    </span>
    <span class="koboSpan" id="kobo.389.5">
     However, the first hurdle is to let go of controlling what the compiler does, a feat more difficult to achieve for C++ programmers who are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      very detailed-oriented.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.391.1">
     How would this work in C++?
    </span>
    <span class="koboSpan" id="kobo.391.2">
     Well, fortunately for me, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     keyword was introduced in C++ since C++11, and its features were improved little by little in consequent standards.
    </span>
    <span class="koboSpan" id="kobo.393.2">
     On the downside, C++ is not as permissive as Groovy on dynamic typing, so occasionally I
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      need templates.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     First, let me amaze you with the most polymorphic function you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      can write:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.397.1">
auto identity(auto value){ return value;}
TEST_CASE("Identity"){
CHECK_EQ(1, identity(1));
CHECK_EQ("asdfasdf", identity("asdfasdf"));
CHECK_EQ(vector{1, 2, 3}, identity(vector{1, 2, 3}));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     This function works no matter what we
    </span>
    <a id="_idIndexMarker115">
    </a>
    <span class="koboSpan" id="kobo.399.1">
     pass into it.
    </span>
    <span class="koboSpan" id="kobo.399.2">
     Isn’t that neat?
    </span>
    <span class="koboSpan" id="kobo.399.3">
     Imagine that you have a bunch of functions like this that you can use in the core of your system, without needing to change them.
    </span>
    <span class="koboSpan" id="kobo.399.4">
     That sounds like an ideal programming environment to me.
    </span>
    <span class="koboSpan" id="kobo.399.5">
     Alas, life is more complicated than this, and programs need more than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      identity functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Let’s look at a slightly more complicated example.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     We’ll start by checking whether a string is a palindrome, that is, whether it reads the same both forward and reversed.
    </span>
    <span class="koboSpan" id="kobo.401.3">
     A simple implementation in C++ is to take the string, reverse it by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.402.1">
      std::reverse_copy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.403.1">
     , and then compare the initial string with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.404.1">
      its reverse:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.405.1">
bool isStringPalindrome(std::string value){
std::vector&lt;char&gt; characters(value.begin(), value.end());
std::vector&lt;char&gt; reversedCharacters;
std::reverse_copy(characters.begin(), characters.end(), std::back_insert_iterator(reversedCharacters));
return characters == reversedCharacters;
}
TEST_CASE("Palindrome"){
CHECK(isStringPalindrome("asddsa"));
CHECK(isStringPalindrome("12321"));
CHECK_FALSE(isStringPalindrome("123123"));
CHECK_FALSE(isStringPalindrome("asd"));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     What if we were to make this code less interested in types?
    </span>
    <span class="koboSpan" id="kobo.406.2">
     First, we would change the parameter type to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.407.1">
      auto
     </span>
    </strong>
    <span class="koboSpan" id="kobo.408.1">
     .
    </span>
    <span class="koboSpan" id="kobo.408.2">
     Then, we need a way to reverse it without constraining ourselves to a string input.
    </span>
    <span class="koboSpan" id="kobo.408.3">
     Fortunately, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      ranges
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     library has a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      reverse_view
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     that we can use.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     Finally, we need to
    </span>
    <a id="_idIndexMarker116">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     compare the initial value with the reversed one, again without restraining the type too much.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     C++ provides us with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      std::equal
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     .
    </span>
    <span class="koboSpan" id="kobo.415.2">
     So, we end up with the following code, which we can use not only for strings but also for a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      vector&lt;string&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     that represents a phrase, or with tokens defined in an enum.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     Let’s see the extreme polymorphism
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.418.1">
      in action:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.419.1">
bool isPalindrome(auto value){
auto tokens = value | std::views::all;
auto reversedTokens = value | std::views::reverse;
return std::equal(tokens.begin(), tokens.end(), reversedTokens.begin());
};
enum Token{
X, Y
};
TEST_CASE("Extreme polymorphic palindrome"){
CHECK(isPalindrome(string("asddsa")));
CHECK(isPalindrome(vector&lt;string&gt;{"asd", "dsa", "dsa", "asd"}));
CHECK(isPalindrome(vector&lt;Token&gt;{Token::X, Token::Y, Token::Y, Token::X}));
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     Perhaps I have now shown you why I find this style of programming very appealing.
    </span>
    <span class="koboSpan" id="kobo.420.2">
     If we ignore the types, or make our functions extremely polymorphic, we can write code that applies to future situations without needing to change.
    </span>
    <span class="koboSpan" id="kobo.420.3">
     The trade-off is that the code has its constraints in the deducted types and that the names of the parameters and functions matter a lot.
    </span>
    <span class="koboSpan" id="kobo.420.4">
     For example, if I pass in an integer value to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      isPalindrome
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     , I will get a complicated error instead of the simple one telling me that the parameter is of the incorrect type.
    </span>
    <span class="koboSpan" id="kobo.422.2">
     This is the beginning of the g++ compiler output on my computer when
    </span>
    <a id="_idIndexMarker117">
    </a>
    <span class="koboSpan" id="kobo.423.1">
     trying to pass in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.424.1">
      an integer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.425.1">
In file included from testPalindrome.cpp:3:
Palindrome.h: In instantiation of 'bool isPalindrome(auto:21)
[with auto:21 = int]':
testPalindrome.cpp:30:2:   required from here
Palindrome.h:14:29: error: no match for 'operator|' (operand t
ypes are 'int' and 'const std::ranges::views::_All')
   14 |         auto tokens = value | std::views::all;
      |                       ~~~~~~^~~~~~~~~~~~~~~~~</span></pre>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     It’s now up to you: do you prefer strong types or extreme polymorphic behavior?
    </span>
    <span class="koboSpan" id="kobo.426.2">
     Both have their trade-offs and their own
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      application domains.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-50">
    <a id="_idTextAnchor049">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     We have seen in this chapter that we can use multiple paradigms to program in C++.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     We looked briefly at a few: functional programming, metaprogramming, types that ensure compile-time validation, and extreme polymorphism.
    </span>
    <span class="koboSpan" id="kobo.429.3">
     Each of these approaches, as well as the standard object-oriented and structured programming, are useful for various contexts when building libraries or specific programs.
    </span>
    <span class="koboSpan" id="kobo.429.4">
     Each of them has something to offer to the curious programmer who wants to learn as much as possible about their craft.
    </span>
    <span class="koboSpan" id="kobo.429.5">
     Each of them has its trade-offs and its own implementations in the world of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      software development.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     We have shown that C++ programmers perhaps only use a subset of the language, and it doesn’t have to be an object-oriented one.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     Instead, it’s best to experiment with all of them, making the most of the fact that C++ is powerful enough to offer so many options, and to pick and choose depending on the task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.432.1">
      at hand.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.433.1">
     In the next chapter, we will see that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.434.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     function might not actually be the entry point of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      our applications.
     </span>
    </span>
   </p>
  </div>
 </body></html>