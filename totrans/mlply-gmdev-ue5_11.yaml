- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging a Multiplayer Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging an application is a crucial aspect of programming in general, and
    this holds particularly true when dealing with multiplayer game programming. The
    debugging process helps developers identify and resolve any issues that may arise
    when running a networked application or game. By understanding the basics of network
    debugging, programmers can ensure their games run smoothly and efficiently on
    all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to debugging networks with Unreal Engine, there are several tools
    available to help make the process easier for programmers. The first step in this
    process is setting up logging within your project settings so that you can track
    errors as they occur during the development or testing phases of your game’s life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, developing an emulated multiplayer environment can be a highly
    effective method of replicating real-life scenarios, while simultaneously assessing
    the operational efficacy of your systems.
  prefs: []
  type: TYPE_NORMAL
- en: What’s more, tools such as the Network Profiler will provide detailed insights
    into critical metrics such as connection speeds and latencies, enabling the identification
    of potential issues and areas that require improvement.
  prefs: []
  type: TYPE_NORMAL
- en: As you progress through this chapter, you will acquire a comprehensive understanding
    of the optimization techniques, enabling you to fine-tune the performance of your
    project and ensure a seamless multiplayer game experience. Furthermore, you will
    learn how to effectively isolate and troubleshoot any existing issues that may
    disrupt the overall gameplay experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, I will guide you through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing network debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating a networked environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Network Profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance and bandwidth utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the previous
    chapter by clicking the `Unreal Shadows –` [*Chapter 10*](B18203_10.xhtml#_idTextAnchor196)`End`
    link.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing network debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network testing and debugging is an essential skill for any professional working
    on multiplayer games. It requires a deep understanding of networking protocols
    and technologies, as well as an ability to identify and diagnose problems quickly.
    Additionally, it involves troubleshooting both client-side issues on the user’s
    device and server-side issues on the game’s servers. By mastering this skill,
    you can ensure that games are running smoothly with minimal latency for all players
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you embark on the development of a networked game, it is imperative to consider
    the following obstacles that come with creating a seamless and engaging multiplayer
    experience for your audience, as opposed to a single-player game:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to debug multiple running instances of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network communication, by its nature, may be unreliable and unstable, and different
    clients may have different issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client will work differently as opposed to a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreal Engine comes equipped with a range of dedicated tools and workflows specifically
    designed for debugging networked applications. By following the guides provided
    in this chapter, you will gain valuable insights into how to effectively utilize
    these tools, as well as learn expert tips and best practices for troubleshooting
    any common networking problems that you may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Before I delve into how Unreal Engine’s debugging tools operate, it’s essential
    to have a basic understanding of game debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining game debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of **debugging** involves testing every part of the project to make
    sure everything works as expected and identifying any areas where improvements
    can be made – this will ensure optimal performance and stability for players when
    they’re playing your games. Debugging also includes checking the code functionality
    across different platforms and devices (for example, mobile platforms, desktop,
    or VR devices), running automated tests on builds before deployment, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, good debugging practices will allow you to find small details that
    might otherwise go unnoticed and cause serious problems in development if they’re
    not addressed early on!
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, you utilized many debug tools provided by Unreal Engine
    – probably the most used one has been the `GEngine->AddOnScreenDebugMessage()`
    command, which adds the capability of showing messages on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Some other tools for debugging are purely visuals – such as `DrawDebugSphere()`,
    which you used in [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147), *Using Remote
    Procedure Calls (RPC)*, to show the position of the Actors your player character
    can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with tools such as Microsoft Visual Studio, JetBrains Rider,
    or any other programming IDE, you will most probably know how important it is
    to use **breakpoints** – points in the code where the execution of the code can
    be temporarily stopped so that you can inspect a program’s data and state.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a multiplayer game – due to its very specialized nature – needs some
    more tools to inspect what is happening behind the scenes. In the following subsections,
    I will introduce you to some of these tools to help you improve your multiplayer
    programming expertise.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing multiplayer options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065), *Testing the Multiplayer
    System with a Project Prototype*, you have used the most common tool for testing
    a multiplayer environment by selecting **Listen Server Net Mode** and choosing
    the number of players to emulate. These settings are just part of the **Multiplayer
    Options** category that can be tweaked in the project settings. To see the full
    range of options, from the main menu, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Window** | **Editor Preferences** option and locate the **Level
    Editor** | **Play** setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for the **Multiplayer Options** category, as shown in *Figure 11**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The Multiplayer Options category](img/Figure_11_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The Multiplayer Options category
  prefs: []
  type: TYPE_NORMAL
- en: This category offers a plethora of options for customizing and debugging your
    game – you have already used **Play Net Mode** and **Play Number of Clients**
    (located in the **Client** subsection), even if you set these values from another
    part of the Unreal Editor (that is, the main toolbar). But there’s much more than
    this!
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you can locate the **Multiplayer Viewport Size (in pixels)**
    option and, from the **Common Resolutions** dropdown, select the client display
    resolution. This will let you test the look and feel of your game once it’s played
    on your target devices. *Figure 11**.2* shows the look of the game once played
    on a **720x1280 Razer** **Phone** device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The smartphone display emulation](img/Figure_11_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The smartphone display emulation
  prefs: []
  type: TYPE_NORMAL
- en: Hey, I know our project wasn’t originally designed to be played on a smartphone,
    but you get the idea anyway, right?
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, I will demonstrate some additional features within the
    **Multiplayer Options** section – for instance, the traffic emulation settings
    – that will enhance your proficiency during the debugging phase of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in a networked environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may already know, in Unreal Engine – or any programming environment –
    **logging** can be used to debug and track the flow of code at runtime. Logging
    is a widely used practice in software development, and multiplayer development
    is no exception. Unreal Engine offers a wide variety of log categories and some
    of them are dedicated to networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Output Log** window keeps track of all the messages and can be opened
    by clicking on the dedicated button at the bottom of Unreal Engine, as shown in
    *Figure 11**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The Output Log activation button](img/Figure_11_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The Output Log activation button
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, all log messages are saved in a `.log` file located in your project
    folder (that is, `[Your` `Project Folder]/Saved/Logs/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each log message is categorized and can be filtered – as an example, *Figure
    11**.4* shows the log window after I resized the game viewport from the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The log window open](img/Figure_11_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The log window open
  prefs: []
  type: TYPE_NORMAL
- en: The most common category you will be using while network debugging is **LogNet**,
    which includes the majority of network logs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For an exhaustive list of all the log categories available in a networked environment,
    check out the official documentation: [https://docs.unrealengine.com/5.1/en-US/logging-for-networked-games-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/logging-for-networked-games-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the LogNet category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have some basic knowledge of the network log system, you can try
    playing the game and checking the **Output Log** window to see what’s happening
    under the hood. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your project in Unreal Engine and click on the **Output Log** button at
    the bottom of the editor. Optionally, you can click the **Dock in Layout** button
    to dock the window inside the editor and make it non-collapsible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the log window is open, locate the **Filters** button and click on it to
    open all the filters. You will notice that the LogNet category is not shown. To
    enable it, you need to start a game session – once in Play Mode, you will notice
    that the category is visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Filters** list, click on the **Categories** section and untick the
    **Show All** option to deselect all the categories, and then locate the **LogNet**
    category to enable it, as shown in *Figure 11**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The log categories filter](img/Figure_11_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The log categories filter
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have enabled only the **LogNet** category, you will get a filtered
    log list, as depicted in *Figure 11**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The LogNet output](img/Figure_11_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The LogNet output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there’s a lot of stuff going on here, and it depends on your
    game session.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra exercise, take some time and read the log messages. You probably
    won’t understand much at first sight but, as time goes by, this kind of communication
    with Unreal Engine will become familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, you will learn how to create a log category so that
    you can easily track what’s happening inside your application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom log category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, when you are caught up in the whirlwind of a project, the temptation
    is to use log messages without worrying too much about categorizing them. This
    is a mistake that, of course, will be paid for in the long run. Creating customized
    categories for your logs is simple, and there are no good reasons not to do it.
  prefs: []
  type: TYPE_NORMAL
- en: To define a custom category, you need to use the `DECLARE_LOG_CATEGORY_EXTERN`
    macro inside a header and, in the corresponding source file, introduce the `DEFINE_LOG_CATEGORY`
    macro. Additionally, the category name must be named with a `Log` prefix – for
    instance, `LogMyApp`. As an example, in the next few steps, you will be creating
    a custom log category for your game, named `LogUnrealShadows`, which you can then
    use anywhere in your project.
  prefs: []
  type: TYPE_NORMAL
- en: So, open your programming IDE and create a new empty class named `US_CustomLogs`
    – you won’t need an Unreal class, just a regular C++ one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open the `US_CustomLogs.h` file and remove the class declaration as you
    won’t be using it. After that, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This macro declares `LogUnrealShadows` as a new log category to be used in your
    project. The verbosity for this category is set to `Display`; this means that
    the message will be printed to the console and the log file – if you need to print
    the message just in the log file and not in the console, you can use the `Log`
    value instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `US_CustomLogs.cpp` file and define the log category by adding
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro will let you use the `LogUnrealShadows` category anywhere in your
    project. Once in Play Mode, you will be able to select the `LogUnrealShadows`
    category from the **Output Log** filter, as shown in *Figure 11**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The LogUnrealShadows category](img/Figure_11_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The LogUnrealShadows category
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the category has been defined, you can use it to add your logs in
    the game – to do this, you can use the `UE_LOG()` macro. As an example, open the
    `US_GameMode.cpp` file and add the needed `include` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to log an alert message inside the `AlertMinions()` function class, you
    must add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 11**.8* shows the aforementioned message in the **Output Log** panel
    once a character has been detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The custom message in the Output Log panel](img/Figure_11_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The custom message in the Output Log panel
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced you to some of the key debugging tools that are available
    in Unreal Engine and explained how to effectively utilize them. In the upcoming
    section, you’ll be presented with how to simulate a networked environment on your
    personal computer, providing you with the ability to test your project under conditions
    where major issues may arise during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating a networked environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a replica of a multiplayer network environment can be an effective
    way to simulate real-world scenarios and test the performance of your systems.
    By leveraging Unreal’s capabilities, you’ll be able to test multiple connections
    on a single machine and provide a realistic experience that will give you an accurate
    idea of your game behavior once it has been deployed online.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network emulation** is an important feature that helps you simulate lag and
    packet loss for both servers and clients. This is especially important in identifying
    and troubleshooting networking issues. Unreal Editor, the command line console,
    and configuration files all offer configurable settings for network emulation
    to ensure that it can be tailored precisely to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling network emulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Network emulation can be enabled from the **Editor Preferences** window, in
    the **Level Editor** | **Play** section. To enable this tool, locate the **Multiplayer
    Options** category and tick the **Enable Network Emulation** option, as depicted
    in *Figure 11**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Enable Network Emulation](img/Figure_11_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Enable Network Emulation
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting this option will enable a set of options you can use to test different
    situations during a multiplayer session. Firstly, you can select which target
    to emulate through the **Emulation Target** property – there are three options
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Only**: This option will emulate just the server’s behavior over the
    network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clients Only**: This option will emulate just the client’s behavior over
    the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everyone**: This option will emulate both the client’s and the server’s behavior
    over the network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secondly, you have access to **Network Emulation Profile**, which will let
    you select different scenarios for a networked game – there are three options
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Average**: This option will emulate a regular multiplayer game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad**: This option will create a worst-case scenario, with a high time lag
    and a lot of data packets lost during the networked game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: This option will let you customize the emulation experience with
    your own values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aforementioned profiles will initialize a set of values for the **Incoming
    Traffic** and the **Outgoing Traffic** values of the client or the server (or
    both), depending on the **Emulation Target** selection. *Figure 11**.10* shows
    the expanded profile options with the custom option selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 - The emulation profiles expanded](img/Figure_11_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 - The emulation profiles expanded
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, I will present you the meaning of most of the settings
    for this section of the **Multiplayer** **Options** category.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Incoming Traffic option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Activating the **Incoming Traffic** option will introduce delays or loss in
    the reception of packets during playtime. You can modify the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum Latency**: This indicates the minimum amount of time lag in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Latency**: This indicates the maximum amount of time lag in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet Loss Percentage**: This indicates the chance that a packet will be
    lost before being received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, a typical bad situation of incoming traffic will have a latency
    of about 100 to 200 milliseconds and a probability of losing incoming data of
    about 5%. To create a similar scenario, your settings may have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`100` milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200` milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the Outgoing Traffic option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, activating the **Outgoing Traffic** option will introduce delays
    or losses when you’re sending packets during playtime. You can modify the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimum Latency**: This indicates the minimum amount of time lag in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Latency**: This indicates the maximum amount of time lag in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet Loss Percentage**: This indicates the chance that a packet will be
    lost before being received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, you may simulate an average situation (that is, one that is
    not optimal but still acceptable) by having a latency of about 30 to 60 milliseconds
    and a probability of losing data of about 1%. Your settings may have the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`30` milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`60` milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`%'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve now learned about all the ways you can simulate a real networked game
    environment. It’s now time to put that knowledge to the test and try it out with
    your multiplayer game! The Lichlord is getting a bit restless and is eagerly waiting
    for you. It’s best not to keep him waiting too long, so let’s not waste any time!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game with network emulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a game in a networked emulation is quite straightforward once you have
    understood the aforementioned elements – select your preferred settings and run
    the game. We will be emulating the game under different network scenarios, so
    open the project you have been working on in the previous chapters and get ready
    to do some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game under average conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this scenario, you will be testing one of the default profiles available
    in the **Editor Preferences** area and checking the game’s behavior. To do so,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Editor Preferences** and locate the **Play** | **Multiplayer** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Enable Network Emulation** checkbox and set **Emulation Target to
    Everyone**; with this option, we will be testing both the client and the server
    network traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Network Emulation Profile** drop-down menu, select **Average**. The
    settings are shown in *Figure 11**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Network emulation with the Average profile](img/Figure_11_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Network emulation with the Average profile
  prefs: []
  type: TYPE_NORMAL
- en: With this profile set up, start a **Play as a Listen Server** game session and
    analyze your game. You should see the game work almost smoothly, with no lag or
    synchronization issues. This is because we opted for a very low percentage of
    packet loss (that is, 1%) and a lag latency for both the server and the clients
    that will be in the range of 30 to 60 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: What we have here is an acceptable game scenario and the player experience will
    be nice and smooth. Now, let’s try using some harsh conditions to see how the
    game behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game under the worst conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this second test, you’ll be testing a worst-case scenario, where the network
    will have a high percentage of packet loss and the traffic latency will emulate
    a bad network bandwidth. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Editor Preferences** and locate the **Play** | **Multiplayer** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Enable Network Emulation** checkbox and set **Emulation Target to
    Everyone**; with this option, we will be testing both the client and the server
    network traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Network Emulation Profile** drop-down menu, select **Custom**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both the `450`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `550`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `10`. The settings are shown in *Figure 11.12*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Network emulation in a worst-case scenario](img/Figure_11_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Network emulation in a worst-case scenario
  prefs: []
  type: TYPE_NORMAL
- en: With this profile set up, start a **Play as a Listen Server** game session and
    analyze your game. You will experience an almost broken experience! The same character
    will seem to move completely out of sync in the different windows and the same
    thing will stay true for your character attack.
  prefs: []
  type: TYPE_NORMAL
- en: But notice that I said “almost” – as the server is authoritative and we are
    using reliable RPCs for the most important operations, such as throwing daggers,
    the game will go on flawlessly from an execution point of view. This means that
    the same character position will – sooner or later – be synchronized on all clients
    and the daggers will always be thrown, no matter the packet loss percentage.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test a totally broken game, try setting `100`, meaning that no
    packet will be received by the server or the clients. When entering Play Mode,
    the client won’t even start and all you will get will be a black screen. But this
    means the Lichlord has laid down a wickedly powerful enchantment on the network,
    stranding your fearless gang of thieves in a mystical quagmire. Unless some tech-savvy
    wizard at the King’s court can conjure a nifty counter-magic to unweave the spell,
    that is!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to test your game in a networked emulation
    environment directly from your trusty computer. One of the most powerful features
    available is the ability to simulate data loss and network lags – this means checking
    the player experience under any scenario, including a worst-case one, where the
    player will have an almost totally broken experience due to bad networking technology.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be presented with another important topic in improving
    your game – how to profile a networked application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Network Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine’s **Network Profiler** is a powerful standalone tool capable of
    analyzing and optimizing the performance of multiplayer game networks. A Profiler
    session will give you detailed insights into connection speeds, latency times,
    and other important metrics that can be used to identify potential issues or areas
    of improvement. By leveraging this information, you will be able to get optimal
    network performance and achieve a nicer user experience. In this section, I will
    guide you through the main features of this tool.
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, the Network Profiler is a standalone application that
    can be found in your Unreal Engine executable folder. Depending on your engine
    installation, the location path may vary, but it is usually located at `[Your
    PC]/Programs` `Files/Epic Games/UE_5.1/Engine/Binaries/DotNET/NetworkProfiler.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Network Profiler application is shown in *Figure 11**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – The Network Profiler application](img/Figure_11_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – The Network Profiler application
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, I will show you how to record a network session and
    peek into its data through the Network Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a profiling session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the Network Profiler, you need to collect some data for it to analyze.
    To accomplish this, you’ll need to work with an engine version that has stat tracking
    enabled, such as a debugger or editor built for non-debug configurations – in
    our case, we will be recording the data directly from the Unreal Engine Editor
    with the default **Average** emulation profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To record a profiling session, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Play** | **Multiplayer Options** category in the **Editor Preferences**
    window, as explained in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick **Enable Network Emulation** and set **Emulation Target** to **Everyone**.
    Then, set **Network Emulation Profile** to **Average**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start your game and locate the **Console Command** prompt located at the bottom
    of the editor (or at the bottom of any **Output Log** window that’s open), as
    depicted in *Figure 11**.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The Console Command prompt](img/Figure_11_14_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The Console Command prompt
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the prompt, enter this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will start a profile recording session and the **Output Log** window should
    display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Play your game for a couple of minutes and then enter the following command.
    This will close the profiling session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will close the profiling session and save a `.nprof` file with
    all the recorded data in your project folder at the following location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an alternative, you can just use the `netprofile` command, which will toggle
    the Profiler every time it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have saved your profiling session, you can open it with the profiling
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a profiling session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After launching the Profiler application, you can click the `Profiling` folder
    to open the session you have recorded. An example session is depicted in *Figure
    11**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – A profiling session example](img/Figure_11_15_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – A profiling session example
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a lot of information here, including a graph containing all the
    networking information. Let’s focus on the bottom-right section, where you will
    see a list of IP addresses, as shown in *Figure 11**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – The list of server and client IP addresses](img/Figure_11_16_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – The list of server and client IP addresses
  prefs: []
  type: TYPE_NORMAL
- en: This list represents the clients and the server that were profiled during the
    session – as you can see, in my example, I have a server (using port **17777**)
    and two clients (using ports **54897** and **54898**). You can select the client
    or the server you need to analyze and click the **Apply Filters** button to show
    just its profiled data. Additionally, you can enable some of the drop-down menus
    that will let you filter additional data, such as a single Actor type in the game.
    An example of this is the **BP_Character** Blueprint Class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected the client or the server you need to analyze, you can
    select a portion of the graph that represents a group of frames during gameplay
    just by clicking and dragging on the chart data, as shown in *Figure 11**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – A selected portion of the chart data](img/Figure_11_17_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – A selected portion of the chart data
  prefs: []
  type: TYPE_NORMAL
- en: 'If needed, you can even select a single frame by just clicking on the graph.
    *Figure 11**.18* shows the frame selection in the graph chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – A single frame in the chart data](img/Figure_11_18_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – A single frame in the chart data
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, select the **Actors** tab, located at the bottom left of the application;
    you will be presented with all the Actors that were replicated during the selected
    frame range. My profiled record is shown in *Figure 11**.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – The Actors tab](img/Figure_11_19_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – The Actors tab
  prefs: []
  type: TYPE_NORMAL
- en: One of the most interesting columns here is **MS**, which shows how many milliseconds
    were needed to replicate an Actor. Using this value, you can determine whether
    the Actor is taking an excessive amount of time to replicate and then proceed
    to investigate the underlying causes of this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Another really important column to consider is `NetUpdateFrequency` value (that
    is, the time interval that will pass when updating data over the network) of your
    Actor to a higher value to update its values less often.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select one of the Actors, you will get detailed information on the replicated
    properties during the analyzed time range. As an example, *Figure 11**.20* shows
    the `BP_WoodenDoor` data in a time range of about 1 minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – The profiled data for the BP_WoodenDoor Blueprint](img/Figure_11_20_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – The profiled data for the BP_WoodenDoor Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: During gameplay, one of the characters interacted with the door, so you can
    see the **DoorOpen** property replicated twice – one for the starting value and
    one for when the character was opened – and **60** replications for the **RelativeRotation**
    property – when the opening animation was activated.
  prefs: []
  type: TYPE_NORMAL
- en: What’s wrong here is the `NetUpdateFrequency` to a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the positive side, take a look at the **Waste** value for the **BP_MinionMiniboss**
    Actor, as depicted in *Figure 11**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – The profiled data for the BP_Miniboss Blueprint](img/Figure_11_21_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – The profiled data for the BP_Miniboss Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: I have achieved a nice **27.32%** for 1 minute of gameplay! But pay attention...
    this does not mean that I have spent fewer resources on this Actor replication.
    This indicates that I’m utilizing the available resources more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **All RPCs** tab located at the top of the application; you will
    get a list of the remote procedure calls that were used during the selected frame
    range. *Figure 11**.22* shows my situation for the example I have used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – The RPC profiling window](img/Figure_11_22_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – The RPC profiling window
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can analyze how many times a remote call was made and the
    cost of calling it – this additional information can help you optimize your code
    and streamline your program’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I presented you with one of the most important tools when working
    on a multiplayer game – the Network Profiler. With a strong knowledge of how to
    use it, you will be able to analyze various aspects of your game’s network performance,
    such as the frequency and cost of remote calls, as well as potential bottlenecks.
    This information can help you identify areas where you can optimize your game’s
    performance while providing a smoother and more enjoyable experience for players.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll share some tips with you that I hope will be useful
    in improving your multiplayer project and help you avoid common issues that can
    arise once your game is played online.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance and bandwidth utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Unreal Engine strives to maximize the efficiency of replicating Actors,
    it is typically a time-consuming process that can negatively impact performance.
    To facilitate this task, there are a few steps that you can take to optimize replication
    and make it more efficient. In this section, I will give you some advice on how
    to improve performance and avoid bottlenecks that may stop your game from working
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Turning on replication only when necessary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When replicating Actors, the server performs various checks, such as relevance,
    frequency of updates, and dormancy, among others. Avoid turning on replication
    on Actors that won’t need this feature to put them off these checks.
  prefs: []
  type: TYPE_NORMAL
- en: If you really need Actor replication, consider fine-tuning `NetUpdateFrequency`
    for less important (or less frequently changing) Actors. This property will set
    the maximum update frequency over the network for the Actor. As an example, a
    background Actor such as an NPC may update at a very slow rate – say every 0.5
    seconds – while a fast-moving enemy may need an update every 0.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you may want to implement custom net relevancy rules (or override
    available variables), which can help in reducing network load at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding invoking RPCs that are not required or essential
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An RPC that could have been avoided is considered an unnecessary RPC and should
    be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, server-specific logic does not have to be included in a server
    RPC if you can ensure that a non-replicated function will run only on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is a method call on a client – if you can guarantee that the
    client is locally controlled (that is, by using `APawn::IsLocallyControlled()`),
    you can avoid using an RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between reliable and unreliable RPCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know from [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147), *Using
    Remote Procedure Calls (RPCs)*, any replicated method can either be reliable or
    unreliable and, by default, RPCs are unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the right choice between the two options may change the way your game
    will behave radically. To help you with this, here’s a list of the pros and cons
    of reliable and unreliable RPCs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable RPCs**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pro**: Functions will arrive at their destination in the same order as they
    were sent'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Con**: Functions will consume more bandwidth and may lead to longer latency'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unreliable RPCs**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pro**: Functions will result in lower bandwidth usage compared to reliable
    calls; this makes them good candidates for functions that need to be called frequently.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Con**: Functions may not successfully reach their destination or may arrive
    with gaps in the RPC calls, even though they will be processed in the correct
    order.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, you should refrain from sending reliable events too frequently,
    such as on the `Tick()` event, since the engine’s buffer of reliable events may
    become overloaded and disconnect the associated player. This kind of call is safer
    to use with an unreliable function – for instance, on non-critical cosmetic events,
    such as spawning sound and visual effects.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using C++, RPCs are the only way to pass data from the client to
    the server and vice versa, so it is a good habit to validate it whenever needed.
    The concept behind having a validation function for an RPC is that if it discovers
    any invalid parameters, it can signal the system to disconnect the client or server
    that initiated the RPC call. To ensure responsiveness, it’s preferable to retrieve
    data directly from the client and validate it on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Remembering that the GameMode exists only on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This may seem like a pretty basic topic, but you should always keep in mind
    that the GameMode is a non-replicated Actor and that it runs only on the server.
    This means that, whenever you will try to get it from a client, you will get a
    `null` value. Consequently, calling an RPC on it is simply nonsense as it will
    run locally only on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using a naming convention for RPCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your project grows in size, keeping track of which functions are RPCs and
    which are not can become challenging; this means that using a good naming convention
    may be a time-saver. You can use a `_Server` and `_Client` suffix, as I showed
    you during the previous chapters, or you can opt for a `Server_` and `Client_`
    prefix. You can even differentiate between `_Client` and `_Multicast` RPCs if
    you wish.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working with a team, this is typically a requirement. However, even
    if you’re working solo, you’ll find this convention to be useful in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, improving your game is a constant journey that never
    truly ends. You’ll always be tweaking things, analyzing data, and identifying
    any obstacles. With the tips I’ve mentioned, I hope to make this process a little
    less stressful for you!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I talked about a really important topic in game programming
    – making sure that your game works properly and fixing any issues that come up.
    In earlier chapters, we covered some tools for finding and fixing problems in
    Unreal Engine, but now, I’ve given you some even stronger and more helpful tools
    that you can use to make your game development even better. First of all, you
    learned how to configure **Multiplayer Options** from **Editor Preferences**,
    after which you created a log category to properly set custom messages when debugging.
    You were then presented with how to emulate a real multiplayer environment on
    a single PC by testing network issues such as packet loss or low bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I presented the Network Profiler, a standalone piece of software that
    will let you read and analyze a multiplayer session to help you find possible
    issues and bottlenecks in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, I gave you some advice on how to improve your project even more.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging a game before release can help ensure that it runs smoothly
    and offers a positive experience to players. Additionally, being equipped with
    the right tools and knowledge for debugging can make the process faster and easier,
    saving valuable time and resources during development. Understanding how to debug
    a multiplayer game is crucial because the involvement of multiple players can
    create technical challenges that are more intricate, such as synchronization and
    latency issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll get back to our project (and the wicked machinations
    of the Lichlord!). Our goal this time around? Mastering the art of managing a
    gameplay session to ensure an unforgettable experience for our future, enthusiastic
    players. Let’s make sure they keep coming back for more, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Part 4:Deploying Your Game Online
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part of the book, you will become acquainted with the more intricate
    elements of the Unreal Engine multiplayer system. You will begin by delving into
    game session management and progress to constructing a deployable build of your
    game. Finally, you will gain insight into cloud services, which can enhance the
    appeal of your game to players.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18203_12.xhtml#_idTextAnchor239), *Managing Multiplayer Sessions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18203_13.xhtml#_idTextAnchor255), *Handling Data During a Session*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18203_14.xhtml#_idTextAnchor275), *Deploying Multiplayer Games*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18203_15.xhtml#_idTextAnchor288), *Adding Epic Online Services
    (EOS)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
