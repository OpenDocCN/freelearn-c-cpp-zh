["```cpp\n#include <type_traits>\nint main() {\n   static_assert(std::is_object_v<int>);\n   static_assert(!std::is_object_v<decltype(main)>);\n}\n```", "```cpp\nint n = 3; // n is an int object\nchar c;\n// int *p = &c; // no, illegal\nint *p = &n;\n```", "```cpp\nint m = 4, n = 3;\nint *p; // p declares (and defines) a pointer to an int\n        // (currently uninitialized), introducing a name\np = 0; // p is a null pointer (it does not necessarily\n       // point to address zero; 0 as used here is\n       // just a convention)\np = nullptr; // likewise, but clearer. Prefer nullptr to\n             // literal 0 whenever possible to describe\n             // a null pointer\np = &m; // p points to m (p contains the address of m)\nassert(*p == 4); // p already exists; with *p we are\n                 // accessing what p points to\np = &n; // p now points to n (p contains the address of n)\nint *q = &n; // q declares (and defines) a pointer to an\n             // int and &n represents the address of n, the\n             // address of an int: q is a pointer to an int\nassert(*q == 3); // n holds 3 at this stage, and q points\n                 // to n, so what q points to has value 3\nassert(*p == 3); // the same holds for p\nassert(p == q); // p and q point to the same int object\n*q = 4; // q already exists, so *q means \"whatever q\n        // points to\"\nassert(n == 4); // indeed, n now holds value 4 since we\n                // modified it indirectly through q\nauto qq = &q;   // qq is the address of q, and its type is\n                // \"pointer to a pointer to an int\", thus\n                // int **... But we will rarely – if ever –\n                // need this\nint &r = n; // declaration of r as a reference to integer n\n            // (see below). Note that & is used in a\n            // declaration in this case\n```", "```cpp\nint *f();\nchar *g();\nint danger() {\n   auto p = f(); // p points to whatever f() returned\n   int *q = p + 3; // q points to where p points to plus\n                   // three times the size of an int. No\n                   // clue where this is, but it's a bad,\n                   // bad idea...\n   auto pc = g(); // pc points to whatever g() returned\n   char * qc = pc + 3; // qc points to where pc points\n                       // to plus three times the size\n                       // of a char. Please don't make\n                       // your pointers go to places you\n                       // don't know about like this\n}\n```", "```cpp\nint n = 3;\nint *p = &n; // fine so far\nvoid *pv = p; // Ok, a pointer is an address\n// p = pv; // no, a void* does not necessarily point to\n           // an int (Ok in C, not in C++)\np = static_cast<int *>(pv); // fine, you asked for it, but\n                            // if you're wrong you're on\n                            // your own\n```", "```cpp\n#include <iostream>\n#include <type_traits>\nusing namespace std;\nbool same_bytes(const char *p0, const char *p1,\n                std::size_t n) {\n    for(std::size_t i = 0; i != n; ++i)\n        if(*(p0 + i) != *(p1 + i))\n            return false;\n    return true;\n}\ntemplate <class T, class U>\n   bool same_bytes(const T &a, const U &b) {\n      using namespace std;\n       static_assert(sizeof a == sizeof b);\n       static_assert(has_unique_object_representations_v<\n          T\n       >);\n       static_assert(has_unique_object_representations_v<\n          U\n       >);\n       return same_bytes(reinterpret_cast<const char*>(&a),\n                         reinterpret_cast<const char*>(&b),\n                         sizeof a);\n   }\nstruct X {\n   int x {2}, y{3};\n};\nstruct Y {\n   int x {2}, y{3};\n};\n#include <cassert>\nint main() {\n    constexpr X x;\n    constexpr Y y;\n    assert(same_bytes(x, y));\n}\n```", "```cpp\n// int &nope; // would not compile (what would nope\n              // refer to?)\nint n = 3;\nint &r = n; // r refers to n\n++r; // n becomes 4\nassert(&r == &n); // taking the address of r means taking\n                  // the address of n\n```", "```cpp\n#include <string>\n#include <iostream>\n#include <format>\nstruct X {\n   std::string s;\n   X(std::string_view s) : s{ s } {\n      std::cout << std::format(\"X::X({})\\n\", s);\n   }\n   ~X(){\n      std::cout << std::format(\"~X::X() for {}\\n\", s);\n   }\n};\nX glob { \"glob\" };\nvoid g() {\n   X xg{ «g()» };\n}\nint main() {\n   X *p0 = new X{ \"p0\" };\n   [[maybe_unused]] X *p1 = new X{ \"p1\" }; // will leak\n   X xmain{ \"main()\" };\n   g();\n   delete p0;\n   // oops, forgot delete p1\n}\n```", "```cpp\nX::X(glob)\nX::X(p0)\nX::X(p1)\nX::X(main())\nX::X(g())\n~X::X() for g()\n~X::X() for p0\n~X::X() for main()\n~X::X() for glob\n```", "```cpp\nclass B; // forward declaration: there will be a class B\n         // at some point in the future\nvoid f(B*); // fine, we know what B is, even if we don't\n            // know the details yet, and all object\n            // addresses are of the same size\n// class D : B {}; // oops! To know what a D is, we have\n                   // to know how big a B is and what a\n                   // B object contains since a D is a B\n```", "```cpp\nchar c;\n// a char occupies precisely one byte of storage, per\n// standard wording\nstatic_assert(sizeof c == 1); // for objects parentheses\n                              // are not required\nstatic_assert(sizeof(c) == 1); // ... but you can use them\nstatic_assert(sizeof(char) == 1); // for types, parentheses\n                                  // are required\nstruct Tiny {};\n// all C++ types occupy non-zero bytes of storage by\n// definition, even if they are \"empty\" like type Tiny\nstatic_assert(sizeof(Tiny) > 0);\n```", "```cpp\nclass X {};\nclass Y {\n   X x;\n};\nint main() {\n   static_assert(sizeof(X) > 0);\n   static_assert(sizeof(Y) == sizeof(X)); // <-- here\n}\n```", "```cpp\nclass X {\n   char c;\n};\nclass Y {\n   X x;\n};\nint main() {\n   static_assert(sizeof(X) == sizeof(char)); // <-- here\n   static_assert(sizeof(Y) == sizeof(X)); // <-- here too\n}\n```", "```cpp\nclass X { };\nclass Y {\n   X x;\n   char c;\n};\nint main() {\n   static_assert(sizeof(Y) >= sizeof(char) + sizeof(X));\n}\n```", "```cpp\nclass X { };\nclass Y : X { // <--  private inheritance\n   char c;\n};\nint main() {\n   static_assert(sizeof(Y) == sizeof(char)); // <-- here\n}\n```", "```cpp\nclass X { };\nclass Y {\n   char c;\n   [[no_unique_address]] X x;\n};\nint main() {\n   static_assert(sizeof(X) > 0);\n   static_assert(sizeof(Y) == sizeof(char)); // <-- here\n}\n```", "```cpp\nclass X {\n   char c; // sizeof(char) == 1 by definition\n   short s;\n   int n;\n};\nint main() {\n   static_assert(sizeof(short) == 2); // we suppose this...\n   static_assert(sizeof(int) == 4);   // ... and this\n   static_assert(\n      sizeof(X) >= sizeof(char)+sizeof(short)+sizeof(int)\n   );\n}\n```", "```cpp\nclass X {\n   char c;\n   short s;\n   int n;\n};\nint main() {\n   static_assert(sizeof(short) == alignof(short));\n   static_assert(sizeof(int) == alignof(int));\n   static_assert(sizeof(X) == 8); // highly probable\n   static_assert(alignof(X) == alignof(int)); // likewise\n}\n```", "```cpp\nclass X {\n   short s;\n   int n;\n   char c;\n};\nint main() {\n   static_assert(sizeof(short) == alignof(short));\n   static_assert(sizeof(int) == alignof(int));\n   static_assert(alignof(X) == alignof(int));\n   static_assert(sizeof(X) == 12); // highly probable\n}\n```", "```cpp\nstruct Point2D {\n   float x{}, y{};\n};\n```", "```cpp\nstruct Point2D {\n   float x{}, y{};\n   Point2D(float x, float y) : x{ x }, y{ y } {\n   }\n};\nvoid oops() {\n   Point2D pt; // does not compile, pt has no default ctor\n}\n```", "```cpp\nstruct Point2D {\n   float x, y; // no need for default initializations\n   Point2D(float x, float y) : x{ x }, y{ y } {\n   }\n   Point2D() : x{ }, y{ } { // <-- here\n   }\n};\nvoid oops() {\n   Point2D pt; // Ok\n}\n```", "```cpp\nstruct Point2D {\n   float x, y; // no need for default initializations\n   Point2D(float x, float y) : x{ x }, y{ y } {\n   }\n   Point2D() : Point2D{ 0, 0 } { // <-- here\n   }\n};\nvoid oops() {\n   Point2D pt; // Ok\n}\n```", "```cpp\nstruct Point2D {\n   float x{}, y{};\n   Point2D(float x, float y) : x{ x }, y{ y } {\n   }\n   Point2D() = default; // <-- here\n};\nvoid oops() {\n   Point2D pt; // Ok\n}\n```", "```cpp\n#include <cstring> // std::strlen()\n#include <algorithm> // std::copy()\nclass naive_string { // too simple to be useful\n   char *p {}; // pointer to the elements (nullptr)\n   std::size_t nelems {}; // number of elements (zero)\npublic:\n   std::size_t size() const {\n      return nelems;\n   }\n   bool empty() const {\n      return size() == 0;\n   }\n   naive_string() = default; // empty string\n   naive_string(const char *s)\n      : nelems{ std::strlen(s) } {\n      p = new char[size() + 1]; // leaving room for a\n                                // (convenient) trailing 0\n      std::copy(s, s + size(), p);\n      p[size()] = '\\0';\n   }\n   // index-wise access to characters, const and non-const\n   // versions: the const version is useful for const\n   // naive_string objects, whereas the non-const version\n   // lets user code modify elements\n   // precondition: n < size()\n   char operator[](std::size_t n) const { return p[n]; }\n   char& operator[](std::size_t n) { return p[n]; }\n   // ... additional code (below) goes here\n};\n```", "```cpp\n// ...\n   ~naive_string() {\n      delete [] p;\n   }\n// ...\n```", "```cpp\n// ...\nvoid f(naive_string); // pass-by-value\nvoid copy_construction_examples() {\n   naive_string s0{ \"What a fine day\" };\n   naive_string s1 = s0; // constructs s1 so this is\n                         // copy construction\n   naive_string s2(s0); // ...this too\n   naive_string s3{ s0 }; // ...and so is this\n   f(s0); // likewise because of pass-by-value\n   s1 = s0; // this is not a copy construction as s1\n            // already exists: this is a copy assignment\n}\n```", "```cpp\n// ...\n   naive_string(const naive_string &other)\n      : p{ new char[other.size() + 1] },\n        nelems{ other.size() } {\n      std::copy(other.p, other.p + other.size(), p);\n      p[size()] = '\\0';\n   }\n// ...\n```", "```cpp\n// ...\n   // bad copy assignment operator\n   naive_string& operator=(const naive_string &other) {\n      // first, release the memory held by *this\n      delete [] p;\n      // then, allocate a new chunk of memory\n      p = new char[other.size() + 1]; // <-- note this line\n      // copy the contents themselves\n      std::copy(other.p, other.p + other.size(), p);\n      // adjust the size and add the trailing zero\n      nelems = other.size();\n      p[size()] = '\\0';\n      return *this;\n   }\n// ...\n```", "```cpp\n// ...\n   // another bad copy assignment operator\n   naive_string& operator=(const naive_string &other) {\n      // first, allocate a new chunk of memory\n      char *q = new char[other.size() + 1];\n      // then release the memory held by *this and make\n      // p point to the new chunk\n      delete [] p; // <-- pay attention to this line\n      p = q;\n      // copy the contents themselves\n      std::copy(other.p, other.p + other.size(), p);\n      // adjust the size and add the trailing zero\n      nelems = other.size();\n      p[size()] = '\\0';\n      return *this;\n   }\n// ...\n```", "```cpp\nvoid test_self_assignment() {\n   naive_string s0 { \"This is not going to end well...\" };\n   s0 = s0; // oops!\n}\n```", "```cpp\n// ...\n   // this works, but it's getting complicated and\n   // is a sign we're doing something wrong\n   naive_string& operator=(const naive_string &other) {\n      // prevent self-assignment\n      if(this == &other) return *this;\n      // then, do that sequence of steps\n      char *q = new char[other.size() + 1];\n      delete [] p; // <-- pay attention to this line\n      p = q;\n      std::copy(other.p, other.p + other.size(), p);\n      nelems = other.size();\n      p[size()] = '\\0';\n      return *this;\n   }\n// ...\n```", "```cpp\n// ...\n   void swap(naive_string &other) noexcept {\n      using std::swap; // make the standard swap function\n                       // available\n      swap(p, other.p); // swap data members\n      swap(nelems, other.nelems);\n   }\n   // idiomatic copy assignment\n   naive_string& operator=(const naive_string &other) {\n      naive_string { other }.swap(*this); // <-- here\n      return *this; // yes, that's it!\n   }\n// ...\n```", "```cpp\n// returns the concatenation of s0 and s1\nnaive_string operator+(naive_string s0, naive_string s1);\n```", "```cpp\nnaive_string make_message(naive_string name) {\n   naive_string s0{ \"Hello \"},\n                s1{ \"!\" };\n   return s0 + name + s1; // <-- note this line\n}\n```", "```cpp\n// ...\n   return s0 + name + s1;\n// ...\n```", "```cpp\n// ...\n   return (s0 + name) + s1;\n//         ^^^^^^^^^^^ <-- anonymous object (we cannot\n/                          refer to it afterward)\n// ...\n```", "```cpp\n// ...\n   ((s0 + name) + s1);\n// ^^^^^^^^^^^^^^^^^^^ <-- anonymous object (idem)\n// ...\n```", "```cpp\n// ...\n   naive_string(naive_string &&other) noexcept\n      : p{ std::move(other.p) },\n        nelems{ std::move(other.nelems) } {\n      other.p = nullptr;\n      other.nelems = 0;\n   }\n// ...\n```", "```cpp\na = std::exchange(b, c);\n```", "```cpp\n// ...\n   naive_string(naive_string &&other) noexcept\n      : p{ std::exchange(other.p, nullptr) },\n        nelems{ std::exchange(other.nelems, 0) } {\n   }\n// ...\n```", "```cpp\n   // idiomatic copy assignment\n   naive_string& operator=(naive_string &&other) noexcept {\n      naive_string { std::move(other) }.swap(*this);\n      return *this;\n   }\n```", "```cpp\nint a0[10];\nstd::string a1[20];\n```", "```cpp\narr[i]\n```", "```cpp\n*(arr + i)\n```", "```cpp\nint a0[5]; // Ok\nstatic_assert(sizeof a0 == 5 * sizeof(int));\nenum { N = sizeof a0 / sizeof a0[0] }; // N == 5\n// int a1[0]; // not allowed: the array would be at the\n              // same address as the next object in memory!\nint *p0 = new int[5]; // Ok, but you have to manage the\n                      // pointee now\nint *p1 = new int[0]; // Ok, dynamically allocated; you\n                      // still have to manage the pointee\n// ...\ndelete [] p1; // good\ndelete [] p0; // good; be responsible\n```"]