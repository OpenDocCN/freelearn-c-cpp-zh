<html><head></head><body>
		<div><h1 id="_idParaDest-178"><a id="_idTextAnchor183"/><em class="italic">Chapter 8</em>: SFML Views – Starting the Zombie Shooter Game</h1>
			<p>In this project, we will be making even more use of <code>View</code> class. This versatile class will allow us to easily divide our game up into layers for different aspects of the game. In the Zombie Shooter project, we will have a layer for the HUD and a layer for the main game. This is necessary because as the game world expands each time the player clears a wave of zombies and, eventually, the game world will be bigger than the screen and will need to scroll. The use of the <code>View</code> class will prevent the text of the HUD from scrolling with the background. In the next project, we will take things even further and create a co-op split screen game with the SFML <code>View</code> class doing most of the hard work.</p>
			<p>This is what we will do in this chapter:</p>
			<ul>
				<li>Planning and starting the Zombie Arena game</li>
				<li>Coding the <code>Player</code> class</li>
				<li>Learning about the SFML <code>View</code> class</li>
				<li>Building the Zombie Arena game engine</li>
				<li>Putting the <code>Player</code> class to work</li>
			</ul>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor184"/>Planning and starting the Zombie Arena game</h1>
			<p>At this point, if you haven't already, I suggest you go and watch a video of <em class="italic">Over 9000 Zombies</em> (<a href="http://store.steampowered.com/app/273500/">http://store.steampowered.com/app/273500/</a>) and <em class="italic">Crimson Land</em> (<a href="http://store.steampowered.com/app/262830/">http://store.steampowered.com/app/262830/</a>). Our game will obviously not be as in-depth or advanced as either of these examples, but we will also have the same basic set of features and game mechanics, such as the following:</p>
			<ul>
				<li>A Heads Up Display (HUD) that shows details such as the score, high score, and bullets in clip, the number of bullets left, player health, and the number of zombies left to kill.</li>
				<li>The player will shoot zombies while frantically running away from them.</li>
				<li>Move around a scrolling world using the <em class="italic">WASD</em> keyboard keys while aiming the gun using the mouse.</li>
				<li>In-between each level, the player will choose a "level-up" that will affect the way the game needs to be played for the player to win.</li>
				<li>The player will need to collect "pick-ups" to restore health and ammunition.</li>
				<li>Each wave brings more zombies and a bigger arena to make it more challenging.</li>
			</ul>
			<p>There will be three types of zombies to splatter. They will have different attributes, such as appearance, health, and speed. We will call them chasers, bloaters, and crawlers. Take a look at the following annotated screenshot of the game to see some of the features in action and the components and assets that make up the game:</p>
			<div><div><img src="img/B14278_08_01.jpg" alt=""/>
				</div>
			</div>
			<p>Here is some more information about each of the numbered points:</p>
			<ol>
				<li>The score and hi-score. These, along with the other parts of the HUD, will be drawn in a separate layer, known as a view, and represented by an instance of the <code>View</code> class. The hi-score will be saved and loaded to a file.</li>
				<li>A texture that will build a wall around the arena. This texture is contained in a single graphic called a <strong class="bold">sprite sheet</strong>, along with the other background textures (points <strong class="bold">3</strong>, <strong class="bold">5</strong>, and <strong class="bold">6</strong>).</li>
				<li>The first of two mud textures from the sprite sheet.</li>
				<li>This is an "ammo pick-up." When the player gets this, they will be given more ammunition. There is a "health pick-up" as well, from which the player will receive more health. These pick-ups can be chosen by the player to be upgraded in-between waves of zombies.</li>
				<li>A grass texture, also from the sprite sheet.</li>
				<li>The second mud texture from the sprite sheet.</li>
				<li>A blood splat where there used to be a zombie.</li>
				<li>The bottom part of the HUD. From left to right, there is an icon to represent ammo, the number of bullets in the clip, the number of spare bullets, a health bar, the current wave of zombies, and the number of zombies remaining for the current wave.</li>
				<li>The player's character.</li>
				<li>A crosshair, which the player aims with the mouse.</li>
				<li>A slow-moving, but strong, "bloater" zombie.</li>
				<li>A slightly faster-moving, but weaker, "crawler" zombie. There is also a "chaser zombie" that is very fast and weak. Unfortunately, I couldn't manage to get one in the screenshot before they were all killed.</li>
			</ol>
			<p>So, we have a lot to do and new C++ skills to learn. Let's start by creating a new project.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>Creating a new project</h2>
			<p>As creating a project is a relatively involved process, I will detail all the steps again. For even more detail and images, please refer to the <em class="italic">Setting up the Timber project</em> section in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>.</p>
			<p>As setting up a project is a fiddly process, we will go through it step by step, like we did for the Timber project. I won't show you the same images as I did for the Timber project, but the process is the same, so flip back to <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em> if you want a reminder of the locations of the various project properties. Let's look at the following steps:</p>
			<ol>
				<li value="1">Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. If you have another project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click on the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <code>Zombie Arena</code> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field. </li>
				<li>In the <code>VS Projects</code> folder.</li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>. </li>
				<li>When you have completed the preceding steps, click on <strong class="bold">Create</strong>. </li>
				<li>We will now configure the project to use the SFML files that we put in the <code>SFML</code> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">Zombie Arena properties…</strong>. At this stage, you should have the <strong class="bold">Zombie Arena Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">Zombie Arena Property Pages</strong> window, take the following steps. Select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> dropdown menu.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>Next, locate the <code>\SFML\include</code>. The full path to type, if you located your <code>SFML</code> folder on your D drive, will be <code>D:\SFML\include</code>. Vary your path if you installed SFML on a different drive.</li>
				<li>Click on <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform these next steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <code>SFML</code> folder is, followed by <code>\SFML\lib</code>. So, the full path to type, if you located your <code>SFML</code> folder on your D drive, will be <code>D:\SFML\lib</code>. Change your path if you installed SFML to a different drive.</li>
				<li>Click on <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> dropdown menu to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <code>sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</code>. Be extra careful to place the cursor exactly at the start of the edit box's current content so as not to overwrite any of the text that is already there.</li>
				<li>Click on <strong class="bold">OK</strong>.</li>
				<li>Click on <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
			</ol>
			<p>Now, you have configured the project properties and you are nearly ready to go. Next, we need to copy the SFML <code>.dll</code> files into the main project directory by following these steps:</p>
			<ol>
				<li value="1">My main project directory is <code>D:\VS Projects\Zombie Arena</code>. This folder was created by Visual Studio in the previous steps. If you put your <code>Projects</code> folder somewhere else, then perform this step in your directory. The files we need to copy into the project folder are in your <code>SFML\bin</code> folder. Open a window for each of the two locations and highlight all the <code>.dll</code> files.</li>
				<li>Now, copy and paste the highlighted files into the project.</li>
			</ol>
			<p>The project is now set up and ready to go. Next, we will explore and add the project assets.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor186"/>The project assets</h2>
			<p>The assets in this project are more numerous and more diverse than the previous games. The assets include the following:</p>
			<ul>
				<li>A font for the text on the screen</li>
				<li>Sound effects for different actions such as shooting, reloading, or getting hit by a zombie</li>
				<li>Graphics for the character, zombies, and a sprite sheet for the various background textures</li>
			</ul>
			<p>All the graphics and sound effects that are required for the game are included in the download bundle. They can be found in the <code>Chapter 8/graphics</code> and <code>Chapter 8/sound</code> folders, respectively. </p>
			<p>The font that is required has not been supplied. This is done to avoid any possible ambiguity regarding the license. This will not cause a problem because the links for downloading the fonts and how and where to choose the font will be provided.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>Exploring the assets</h2>
			<p>The graphical assets make up the parts of the scene of our Zombie Arena game. Look at the following graphical assets; it should be clear to you where the assets in the game will be used:</p>
			<div><div><img src="img/B14278_08_03.jpg" alt=""/>
				</div>
			</div>
			<p>What might be less obvious, however, is the <code>background_sheet.png</code> file, which contains four different images. This is the sprite sheet we mentioned previously. We will see how we can save memory and increase the speed of our game using the sprite sheet in <a href="B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200"><em class="italic">Chapter 9</em></a>,<em class="italic"> C++ References, Sprite Sheets, and Vertex Arrays</em>.</p>
			<p>The sound files are all in <code>.wav</code> format. These are files that contain the sound effects that will be played when certain events are triggered. They are as follows:</p>
			<ul>
				<li><code>hit.wav</code>: A sound that plays when a zombie comes into contact with the player.</li>
				<li><code>pickup.wav</code>: A sound that plays when the player collides or steps on (collects) a health boost (pick-up).</li>
				<li><code>powerup.wav</code>: A sound for when the player chooses an attribute to increase their strength (power-up) in-between each wave of zombies.</li>
				<li><code>reload.wav</code>: A satisfying click to let the player know they have loaded a fresh clip of ammunition. </li>
				<li><code>reload_failed.wav</code>: A less satisfying sound that indicates failing to load new bullets.</li>
				<li><code>shoot.wav</code>: A shooting sound.</li>
				<li><code>splat.wav</code>: A sound like a zombie being hit by a bullet.</li>
			</ul>
			<p>Once you have decided which assets you will use, it is time to add them to the project.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor188"/>Adding the assets to the project</h2>
			<p>The following instructions will assume you are using all the assets that were supplied is the book's download bundle. Where you are using your own assets, simply replace the appropriate sound or graphic file with your own, using the same filename. Let's take a look at the steps:</p>
			<ol>
				<li value="1">Browse to <code>D:\VS Projects\ZombieArena</code>.</li>
				<li>Create three new folders within this folder and name them <code>graphics</code>, <code>sound</code>, and <code>fonts</code>.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 8/graphics</code> into the <code>D:\VS Projects\ZombieArena\graphics</code> folder.</li>
				<li>From the download bundle, copy the entire contents of <code>Chapter 6/sound</code> into the <code>D:\VS Projects\ZombieArena\sound</code> folder.</li>
				<li>Now, visit <a href="http://www.1001freefonts.com/zombie_control.font">http://www.1001freefonts.com/zombie_control.font</a> in your web browser and download the <strong class="bold">Zombie Control</strong> font.</li>
				<li>Extract the contents of the zipped download and add the <code>zombiecontrol.ttf</code> file to the <code>D:\VS Projects\ZombieArena\fonts</code> folder. </li>
			</ol>
			<p>Now, it's time to consider how OOP will help us with this project and then we can start writing the code for Zombie Arena.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor189"/>OOP and the Zombie Arena project</h1>
			<p>The initial problem we are faced with is the complexity of the current project. Let's consider that there is just a single zombie; here is what we need to make it function in the game:</p>
			<ul>
				<li>Its horizontal and vertical position</li>
				<li>Its size</li>
				<li>The direction it is facing</li>
				<li>A different texture for each zombie type</li>
				<li>A Sprite</li>
				<li>A different speed for each zombie type</li>
				<li>A different health for each zombie type</li>
				<li>Keeping track of the type of each zombie</li>
				<li>Collision detection data</li>
				<li>Its intelligence (to chase the player), which is slightly different for each type of zombie</li>
				<li>An indication of whether the zombie is alive or dead </li>
			</ul>
			<p>This suggests perhaps a dozen variables for just one zombie, and entire arrays of each of these variables will be required for managing a zombie horde. But what about all the bullets from the machine gun, the pick-ups, and the different level-ups? The simple Timber!!! and Pong games also started to get a bit unmanageable, and it is easy to speculate that this more complicated shooter will be many times worse!</p>
			<p>Fortunately, we will put all the OOP skills we learned in the previous two chapters into action, as well as learn some new C++ techniques.</p>
			<p>We will start our coding for this project with a class to represent the player.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor190"/>Building the player – the first class</h1>
			<p>Let's think about what our <code>Player</code> class will need to do and what we require for it. The class will need to <em class="italic">know</em> how fast it can move, where in the game world it currently is, and how much health it has. As the <code>Player</code> class, in the player's eyes, is represented as a 2D graphical character, the class will need both a <code>Sprite</code> object and a <code>Texture</code> object.</p>
			<p>Furthermore, although the reasons might not be obvious at this point, our <code>Player</code> class will also benefit from knowing a few details about the overall environment the game is running in. These details are screen resolution, the size of the tiles that make up an arena, and the overall size of the current arena.</p>
			<p>As the <code>Player</code> class will be taking full responsibility for updating itself in each frame (like the bat and ball did), it will need to know the player's intentions at any given moment. For example, is the player currently holding down a keyboard direction key? Or is the player currently holding down multiple keyboard direction keys? Boolean variables are used to determine the status of the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys and will be essential.</p>
			<p>It is clear that we are going to need quite a selection of variables in our new class. Having learned all we have about OOP, we will, of course, be making all of these variables private. This means that we must provide access, where appropriate, from the <code>main</code> function.</p>
			<p>We will use a whole bunch of getter functions as well as some functions to set up our object. These functions are quite numerous. There are 21 functions in this class. At first, this might seem a little daunting, but we will go through them all and see that most of them simply set or get one of the private variables. </p>
			<p>There are just a few in-depth functions: <code>update</code>, which will be called once each frame from the <code>main</code> function, and <code>spawn</code>, which will handle initializing some of the private variables each time the player is spawned. As we will see, however, there is nothing complicated and they will all be described in detail. </p>
			<p>The best way to proceed is to code the header file. This will give us the opportunity to see all the private variables and examine all the function signatures. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Pay close attention to the return values and argument types, as this will make understanding the code in the function definitions much easier.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor191"/>Coding the Player class header file</h2>
			<p>Start by right-clicking on <code>Player.h</code>. Finally, click on the <strong class="bold">Add</strong> button. We are now ready to code the header file for our first class.</p>
			<p>Start coding the <code>Player</code> class by adding the declaration, including the opening and closing curly braces, followed by a semicolon:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Player
{
};</pre>
			<p>Now, let's add all our private member variables in the file. Based on what we have already discussed, see whether you can work out what each of them will do. We will go through them individually in a moment:</p>
			<pre>class Player
{
<strong class="bold">private:</strong>
<strong class="bold">    const float START_SPEED = 200;</strong>
<strong class="bold">    const float START_HEALTH = 100;</strong>
<strong class="bold">    // Where is the player</strong>
<strong class="bold">    Vector2f m_Position;</strong>
<strong class="bold">    // Of course, we will need a sprite</strong>
<strong class="bold">    Sprite m_Sprite;</strong>
<strong class="bold">    // And a texture</strong>
<strong class="bold">    // !!Watch this space – Interesting changes here soon!!</strong>
<strong class="bold">    Texture m_Texture;</strong>
<strong class="bold">    // What is the screen resolution</strong>
<strong class="bold">    Vector2f m_Resolution;</strong>
<strong class="bold">    // What size is the current arena</strong>
<strong class="bold">    IntRect m_Arena;</strong>
<strong class="bold">    // How big is each tile of the arena</strong>
<strong class="bold">    int m_TileSize;</strong>
<strong class="bold">    // Which direction(s) is the player currently moving in</strong>
<strong class="bold">    bool m_UpPressed;</strong>
<strong class="bold">    bool m_DownPressed;</strong>
<strong class="bold">    bool m_LeftPressed;</strong>
<strong class="bold">    bool m_RightPressed;</strong>
<strong class="bold">    // How much health has the player got?</strong>
<strong class="bold">    int m_Health;</strong>
<strong class="bold">    // What is the maximum health the player can have</strong>
<strong class="bold">    int m_MaxHealth;</strong>
<strong class="bold">    // When was the player last hit</strong>
<strong class="bold">    Time m_LastHit;</strong>
<strong class="bold">    // Speed in pixels per second</strong>
<strong class="bold">    float m_Speed;</strong>
<strong class="bold">// All our public functions will come next</strong>
};</pre>
			<p>The previous code declares all our member variables. Some are regular variables, while some of them are objects. Notice that they are all under the <code>private:</code> section of the class and, therefore, are not directly accessible from outside the class.</p>
			<p>Also, notice that we are using the naming convention of prefixing <code>m_</code> to all the names of the non-constant variables. The <code>m_</code> prefix will remind us, while coding the function definitions, that they are member variables, are distinct from the local variables we will create in some of the functions, and are also distinct from the function parameters. </p>
			<p>All the variables that are used are straightforward, such as <code>m_Position</code>, <code>m_Texture</code>, and <code>m_Sprite</code>, which are for the current location, texture, and sprite of the player, respectively. In addition to this, each variable (or group of variables) is commented to make its usage plain.</p>
			<p>However, why exactly they are needed, and the context they will be used in, might not be so obvious. For example, <code>m_LastHit</code>, which is an object of the <code>Time</code> type, is for recording the time that the player last received a hit from a zombie. It is not obvious <em class="italic">why</em> we might need this information, but we will go over this soon.</p>
			<p>As we piece the rest of the game together, the context for each of the variables will become clearer. The important thing, for now, is to familiarize yourself with the names and data types to make following along with the rest of the project trouble-free.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You don't need to memorize the variable names and types as we will discuss all the code when they are used. You do, however, need to take your time to look over them and get more familiar with them. Furthermore, as we proceed, it might be worth referring to this header file if anything seems unclear.</p>
			<p>Now, we can add a complete long list of functions. Add the following highlighted code and see whether you can work out what it all does. Pay close attention to the return types, parameters, and the name of each function. This is key to understanding the code we will write throughout the rest of this project. What do they tell us about each function? Add the following highlighted code and then we will examine it:</p>
			<pre>// All our public functions will come next
<strong class="bold">public:</strong>
<strong class="bold">    Player();</strong>
<strong class="bold">    void spawn(IntRect arena, Vector2f resolution, int tileSize);</strong>
<strong class="bold">    // Call this at the end of every game</strong>
<strong class="bold">    void resetPlayerStats();</strong>
<strong class="bold">    </strong>
<strong class="bold">    // Handle the player getting hit by a zombie</strong>
<strong class="bold">    bool hit(Time timeHit);</strong>
<strong class="bold">    // How long ago was the player last hit</strong>
<strong class="bold">    Time getLastHitTime();</strong>
<strong class="bold">    // Where is the player</strong>
<strong class="bold">    FloatRect getPosition();</strong>
<strong class="bold">    // Where is the center of the player</strong>
<strong class="bold">    Vector2f getCenter();</strong>
<strong class="bold">    // What angle is the player facing</strong>
<strong class="bold">    float getRotation();</strong>
<strong class="bold">    // Send a copy of the sprite to the main function</strong>
<strong class="bold">    Sprite getSprite();</strong>
<strong class="bold">    // The next four functions move the player</strong>
<strong class="bold">    void moveLeft();</strong>
<strong class="bold">    void moveRight();</strong>
<strong class="bold">    void moveUp();</strong>
<strong class="bold">    void moveDown();</strong>
<strong class="bold">    // Stop the player moving in a specific direction</strong>
<strong class="bold">    void stopLeft();</strong>
<strong class="bold">    void stopRight();</strong>
<strong class="bold">    void stopUp();</strong>
<strong class="bold">    void stopDown();</strong>
<strong class="bold">    // We will call this function once every frame</strong>
<strong class="bold">    void update(float elapsedTime, Vector2i mousePosition);</strong>
<strong class="bold">    // Give the player a speed boost</strong>
<strong class="bold">    void upgradeSpeed();</strong>
<strong class="bold">    // Give the player some health</strong>
<strong class="bold">    void upgradeHealth();</strong>
<strong class="bold">    // Increase the maximum amount of health the player can have</strong>
<strong class="bold">    void increaseHealthLevel(int amount);</strong>
<strong class="bold">    // How much health has the player currently got?</strong>
<strong class="bold">    int getHealth();</strong>
<strong class="bold">};</strong></pre>
			<p>Firstly, note that all the functions are public. This means we can call all of these functions using an instance of the class from the <code>main</code> function with code like this:</p>
			<pre><code>player.getSprite();</code></pre>
			<p>Assuming <code>player</code> is a fully set up instance of the <code>Player</code> class, the previous code will return a copy of <code>m_Sprite</code>. Putting this code into a real context, we could, in the <code>main</code> function, write code like this:</p>
			<pre>window.draw(player.getSprite());</pre>
			<p>The previous code would draw the player graphic in its correct location, just as if the sprite was declared in the <code>main</code> function itself. This is what we did with the <code>Bat</code> class in the Pong project.</p>
			<p>Before we move on to implement (that is, write the definitions) of these functions in a corresponding <code>.cpp</code> file, let's take a closer look at each of them in turn:</p>
			<ul>
				<li><code>void spawn(IntRect arena, Vector2f resolution, int tileSize)</code>: This function does what its name suggests. It will prepare the object ready for use, which includes putting it in its starting location (that is, spawning it). Notice that it doesn't return any data, but it does have three arguments. It receives an <code>IntRect</code> instance called <code>arena</code>, which will be the size and location of the current level; a <code>Vector2f</code> instance, which will contain the screen resolution; and an <code>int</code>, which will hold the size of a background tile.</li>
				<li><code>void resetPlayerStats</code>: Once we give the player the ability to level up between waves, we will need to be able to take away/reset those abilities at the start of a new game.</li>
				<li><code>Time getLastHitTime()</code>: This function does just one thing – it returns the time when the player was last hit by a zombie. We will use this function when detecting collisions, and it will allow us to make sure the player isn't punished <em class="italic">too</em> frequently for making contact with a zombie.</li>
				<li><code>FloatRect getPosition()</code>: This function returns a <code>FloatRect</code> instance that describes the horizontal and vertical floating-point coordinates of the rectangle, which contains the player graphic. This is also useful for collision detection.</li>
				<li><code>Vector2f getCenter()</code>: This is slightly different to <code>getPosition</code> because it is a <code>Vector2f</code> type and contains just the <em class="italic">x</em> and <em class="italic">y</em> locations of the very center of the player graphic.</li>
				<li><code>float getRotation()</code>: The code in the <code>main</code> function will sometimes need to know, in degrees, which way the player is currently facing. 3 o'clock is 0 degrees and increases clockwise.</li>
				<li><code>Sprite getSprite()</code>: As we discussed previously, this function returns a copy of the sprite that represents the player.</li>
				<li><code>void moveLeft()</code>, <code>..Right()</code>, <code>..Up()</code>, <code>..Down()</code>: These four functions have no return type or parameters. They will be called from the <code>main</code> function and the <code>Player</code> class will then be able to act when one or more of the <em class="italic">WASD</em> keys have been pressed.</li>
				<li><code>void stopLeft()</code>, <code>..Right()</code>, <code>..Up()</code>, <code>..Down()</code>: These four functions have no return type or parameters. They will be called from the <code>main</code> function, and the <code>Player</code> class will then be able to act when one or more of the <em class="italic">WASD</em> keys have been released.</li>
				<li><code>void update(float elapsedTime, Vector2i mousePosition)</code>: This will be the only long function of the entire class. It will be called once per frame from <code>main</code>. It will do everything necessary to make sure the <code>player</code> object's data is updated so that it's ready for collision detection and drawing. Notice that it returns no data but receives the amount of elapsed time since the last frame, along with a <code>Vector2i</code> instance, which will hold the horizontal and vertical screen location of the mouse pointer/crosshair. <p class="callout-heading">Important note</p><p class="callout">Note that these are integer screen coordinates and are distinct from the floating-point world coordinates.</p></li>
				<li><code>void upgradeSpeed()</code>: A function that can be called from the leveling up screen when the player chooses to make the player faster.</li>
				<li><code>void upgradeHealth()</code>: Another function that can be called from the leveling up screen when the player chooses to make the player stronger (that is, have more health).</li>
				<li><code>void increaseHealthLevel(int amount)</code>: A subtle but important difference regarding the previous function in that this one will increase the amount of health the player has, up to the maximum that's currently set. This function will be used when the player picks up a health pick-up.</li>
				<li><code>int getHealth()</code>: With the level of health being as dynamic as it is, we need to be able to determine how much health the player has at any given moment. This function returns an <code>int</code>, which holds that value. </li>
			</ul>
			<p>Like the variables, it should now be plain what each of the functions is for. Also the <em class="italic">why</em> and the precise context of using some of these functions will only reveal themselves as we progress with the project.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You don't need to memorize the function names, return types, or parameters as we will discuss the code when they are used. You do, however, need to take your time to look over them, along with the previous explanations, and get more familiar with them. Furthermore, as we proceed, it might be worth referring to this header file if anything seems unclear.</p>
			<p>Now, we can move on to the meat of our functions: the definitions.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Coding the Player class function definitions</h2>
			<p>Finally, we can begin writing the code that does the work of our class.</p>
			<p><em class="italic">Right-click</em> on <code>Player.cpp</code>. Finally, click on the <strong class="bold">Add</strong> button. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">From now on, I will simply ask you to create a new class or header file. So, commit the preceding step to memory or refer back here if you need a reminder.</p>
			<p>We are now ready to code the <code>.cpp</code> file for our first class in this project.</p>
			<p>Here are the necessary include directives, followed by the definition of the constructor. Remember, the constructor will be called when we first instantiate an object of the <code>Player</code> type. Add the following code to the <code>Player.cpp</code> file and then we can take a closer look at it:</p>
			<pre>#include "player.h"
Player::Player()
{
    m_Speed = START_SPEED;
    m_Health = START_HEALTH;
    m_MaxHealth = START_HEALTH;
    // Associate a texture with the sprite
    // !!Watch this space!!
    m_Texture.loadFromFile("graphics/player.png");
    m_Sprite.setTexture(m_Texture);
    // Set the origin of the sprite to the center, 
    // for smooth rotation
    m_Sprite.setOrigin(25, 25);
}</pre>
			<p>In the constructor function, which, of course, has the same name as the class and no return type, we write code that begins to set up the <code>Player</code> object, ready for use.</p>
			<p>To be clear; this code will run when we write the following code from the <code>main</code> function:</p>
			<pre>Player player;</pre>
			<p>Don't add the previous line of code just yet.</p>
			<p>All we do in the constructor is initialize <code>m_Speed</code>, <code>m_Health</code>, and <code>m_MaxHealth</code> from their related constants. Then, we load the player graphic into <code>m_Texture</code>, associate <code>m_Texture</code> with <code>m_Sprite</code>, and set the origin of <code>m_Sprite</code> to the center, <code>(25, 25)</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note the cryptic comment, <code>// !!Watch this space!!</code>, indicating that we will return to the loading of our texture and some important issues regarding it. We will eventually change how we deal with this texture once we have discovered a problem and learned a bit more C++. We will do so in <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a><em class="italic">, Pointers, the Standard Template Library, and Texture Management</em>.</p>
			<p>Next, we will code the <code>spawn</code> function. We will only ever create one instance of the <code>Player</code> class. We will, however, need to spawn it into the current level for each wave. This is what the <code>spawn</code> function will handle for us. Add the following code to the <code>Player.cpp</code> file and be sure to examine the details and read the comments:</p>
			<pre>void Player::spawn(IntRect arena, 
        Vector2f resolution, 
        int tileSize)
{
    // Place the player in the middle of the arena
    m_Position.x = arena.width / 2;
    m_Position.y = arena.height / 2;
    // Copy the details of the arena 
    // to the player's m_Arena
    m_Arena.left = arena.left;
    m_Arena.width = arena.width;
    m_Arena.top = arena.top;
    m_Arena.height = arena.height;
    // Remember how big the tiles are in this arena
    m_TileSize = tileSize;
    // Store the resolution for future use
    m_Resolution.x = resolution.x;
    m_Resolution.y = resolution.y;
}</pre>
			<p>The preceding code starts off by initializing the <code>m_Position.x</code> and <code>m_Position.y</code> values to half the height and width of the passed in <code>arena</code>. This has the effect of moving the player to the center of the level, regardless of its size.</p>
			<p>Next, we copy all the coordinates and dimensions of the passed in <code>arena</code> to the member object of the same type, <code>m_Arena</code>. The details of the size and coordinates of the current arena are used so frequently that it makes sense to do this. We can now use <code>m_Arena</code> for tasks such as making sure the player can't walk through walls. In addition to this, we copy the passed in <code>tileSize</code> instance to the member variable, <code>m_TileSize</code>, for the same purpose. We will see <code>m_Arena</code> and <code>m_TileSize</code> in action in the <code>update</code> function.</p>
			<p>The final two lines from the preceding code copy the screen resolution from the <code>Vector2f</code>,<code> resolution</code>, which is a parameter of <code>spawn</code>, into <code>m_Resolution</code>, which is a member variable of <code>Player</code>. We now have access to these values inside the <code>Player</code> class.</p>
			<p>Now, add the very straightforward code of the <code>resetPlayerStats</code> function: </p>
			<pre>void Player::resetPlayerStats()
{
    m_Speed = START_SPEED;
    m_Health = START_HEALTH;
    m_MaxHealth = START_HEALTH;
}</pre>
			<p>When the player dies, we will use this to reset any upgrades they might have used.</p>
			<p>We will not write the code that calls the <code>resetPlayerStats</code> function until nearly completing the project, but it is there ready for when we need it.</p>
			<p>In the next part of the code, we will add two more functions. They will handle what happens when the player is hit by a zombie. We will be able to call <code>player.hit()</code> and pass in the current game time. We will also be able to query the last time that the player was hit by calling <code>player.getLastHitTime()</code>. Exactly how these functions are useful will become apparent when we have some zombies.</p>
			<p>Add the two new definitions to the <code>Player.cpp</code> file and then examine the C++ code a little more closely:</p>
			<pre>Time Player::getLastHitTime()
{
    return m_LastHit;
}
bool Player::hit(Time timeHit)
{
    if (timeHit.asMilliseconds() 
        - m_LastHit.asMilliseconds() &gt; 200)
    {
        m_LastHit = timeHit;
        m_Health -= 10;
        return true;
    }
    else
    {
        return false;
    }
}</pre>
			<p>The code for <code>getLastHitTime()</code> is very straightforward; it will return whatever value is stored in <code>m_LastHit</code>. </p>
			<p>The <code>hit</code> function is a bit more in-depth and nuanced. First, the <code>if</code> statement checks to see whether the time that's passed in as a parameter is 200 milliseconds further ahead than the time stored in <code>m_LastHit</code>. If it is, <code>m_LastHit</code> is updated with the time passed in and <code>m_Health</code> has 10 deducted from its current value. The last line of code in this <code>if</code> statement is <code>return true</code>. Notice that the <code>else</code> clause simply returns <code>false</code> to the calling code.</p>
			<p>The overall effect of this function is that health points will only be deducted from the player up to five times per second. Remember that our game loop might be running at thousands of iterations per second. In this scenario, without the restriction this function provides, a zombie would only need to be in contact with the player for one second and tens of thousands of health points would be deducted. The <code>hit</code> function controls and restricts this phenomenon. It also lets the calling code know whether a new hit has been registered (or not) by returning <code>true</code> or <code>false</code>.</p>
			<p>This code implies that we will detect collisions between a zombie and the player in the <code>main</code> function. We will then call <code>player.hit()</code> to determine whether to deduct any health points.</p>
			<p>Next, for the <code>Player</code> class, we will implement a bunch of getter functions. They allow us to keep the data neatly encapsulated in the <code>Player</code> class, at the same time as making their values available to the <code>main</code> function.</p>
			<p>Add the following code, right after the previous block:</p>
			<pre>FloatRect Player::getPosition()
{
    return m_Sprite.getGlobalBounds();
}
Vector2f Player::getCenter()
{
    return m_Position;
}
float Player::getRotation()
{
    return m_Sprite.getRotation();
}
Sprite Player::getSprite()
{
    return m_Sprite;
}
int Player::getHealth()
{
    return m_Health;
}</pre>
			<p>The previous code is very straightforward. Each one of the previous five functions returns the value of one of our member variables. Look carefully at each of them and familiarize yourself with which function returns which value.</p>
			<p>The next eight short functions enable the keyboard controls (which we will use from the <code>main</code> function) so that we can change the data contained in our object of the <code>Player</code> type. Add the following code to the <code>Player.cpp</code> file and then we will summarize how it all works:</p>
			<pre>void Player::moveLeft()
{
    m_LeftPressed = true;
}
void Player::moveRight()
{
    m_RightPressed = true;
}
void Player::moveUp()
{
    m_UpPressed = true;
}
void Player::moveDown()
{
    m_DownPressed = true;
}
void Player::stopLeft()
{
    m_LeftPressed = false;
}
void Player::stopRight()
{
    m_RightPressed = false;
}
void Player::stopUp()
{
    m_UpPressed = false;
}
void Player::stopDown()
{
    m_DownPressed = false;
}</pre>
			<p>The previous code has four functions (<code>moveLeft</code>, <code>moveRight</code>, <code>moveUp</code>, and <code>moveDown</code>), which set the related Boolean variables (<code>m_LeftPressed</code>, <code>m_RightPressed</code>, <code>m_UpPressed</code>, and <code>m_DownPressed</code>) to <code>true</code>. The other four functions (<code>stopLeft</code>, <code>stopRight</code>, <code>stopUp</code>, and <code>stopDown</code>) do the opposite and set the same Boolean variables to <code>false</code>. The instance of the <code>Player</code> class can now be kept informed of which of the <em class="italic">WASD</em> keys were pressed and which were not.</p>
			<p>The following function is the one that does all the hard work. The <code>update</code> function will be called once in every single frame of our game loop. Add the following code, and then we will examine it in detail. If we followed along with the previous eight functions and we remember how we animated the clouds and bees for the Timber!!! project and the bat and ball for Pong, we will probably understand most of the following code:</p>
			<pre>void Player::update(float elapsedTime, Vector2i mousePosition)
{
    if (m_UpPressed)
    {
        m_Position.y -= m_Speed * elapsedTime;
    }
    if (m_DownPressed)
    {
        m_Position.y += m_Speed * elapsedTime;
    }
    if (m_RightPressed)
    {
        m_Position.x += m_Speed * elapsedTime;
    }
    if (m_LeftPressed)
    {
        m_Position.x -= m_Speed * elapsedTime;
    }
    m_Sprite.setPosition(m_Position);
    // Keep the player in the arena
    if (m_Position.x &gt; m_Arena.width - m_TileSize)
    {
        m_Position.x = m_Arena.width - m_TileSize;
    }
    if (m_Position.x &lt; m_Arena.left + m_TileSize)
    {
        m_Position.x = m_Arena.left + m_TileSize;
    }
    if (m_Position.y &gt; m_Arena.height - m_TileSize)
    {
        m_Position.y = m_Arena.height - m_TileSize;
    }
    if (m_Position.y &lt; m_Arena.top + m_TileSize)
    {
        m_Position.y = m_Arena.top + m_TileSize;
    }
    // Calculate the angle the player is facing
    float angle = (atan2(mousePosition.y - m_Resolution.y / 2,
        mousePosition.x - m_Resolution.x / 2)
        * 180) / 3.141;
    m_Sprite.setRotation(angle);
}</pre>
			<p>The first portion of the previous code moves the player sprite. The four <code>if</code> statements check which of the movement-related Boolean variables (<code>m_LeftPressed</code>, <code>m_RightPressed</code>, <code>m_UpPressed</code>, or <code>m_DownPressed</code>) are true and changes <code>m_Position.x</code> and <code>m_Position.y</code> accordingly. The same formula, from the previous two projects, to calculate the amount to move is also used: </p>
			<p><strong class="bold">position (+ or -) speed * elapsed time.</strong></p>
			<p>After these four <code>if</code> statements, <code>m_Sprite.setPosition</code> is called and <code>m_Position</code> is passed in. The sprite has now been adjusted by exactly the right amount for that one frame.</p>
			<p>The next four <code>if</code> statements check whether <code>m_Position.x</code> or <code>m_Position.y</code> is beyond any of the edges of the current arena. Remember that the confines of the current arena were stored in <code>m_Arena</code>, in the <code>spawn</code> function. Let's look at the first one of these four <code>if</code> statements in order to understand them all:</p>
			<pre>if (m_Position.x &gt; m_Arena.width - m_TileSize)
{
    m_Position.x = m_Arena.width - m_TileSize;
}</pre>
			<p>The previous code tests to see whether <code>m_position.x</code> is greater than <code>m_Arena.width</code>, minus the size of a tile (<code>m_TileSize</code>). As we will see when we create the background graphics, this calculation will detect the player straying into the wall.</p>
			<p>When the <code>if</code> statement is true, the <code>m_Arena.width - m_TileSize</code> calculation is used to initialize <code>m_Position.x</code>. This means that the center of the player graphic will never be able to stray past the left-hand edge of the right-hand wall.</p>
			<p>The next three <code>if</code> statements, which follow the one we have just discussed, do the same thing but for the other three walls.</p>
			<p>The last two lines in the preceding code calculate and set the angle that the player sprite is rotated to (that is, facing). This line of code might look a little complex, but it is simply using the position of the crosshair (<code>mousePosition.x</code> and <code>mousePosition.y</code>) and the center of the screen (<code>m_Resolution.x</code> and <code>m_Resolution.y</code>) in a tried-and-tested trigonometric function. </p>
			<p>How <code>atan</code> uses these coordinates along with Pi (3.141) is quite complicated, and that is why it is wrapped up in a handy function for us. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you want to explore trigonometric functions in more detail, you can do so here: <a href="http://www.cplusplus.com/reference/cmath/">http://www.cplusplus.com/reference/cmath/</a>.</p>
			<p>The last three functions we will add for the <code>Player</code> class make the player 20% faster, increase the player's health by 20%, and increase the player's health by the amount passed in, respectively.</p>
			<p>Add the following code at the end of the <code>Player.cpp</code> file, and then we will take a closer look at it:</p>
			<pre>void Player::upgradeSpeed()
{
    // 20% speed upgrade
    m_Speed += (START_SPEED * .2);
}
void Player::upgradeHealth()
{
    // 20% max health upgrade
    m_MaxHealth += (START_HEALTH * .2);
}
void Player::increaseHealthLevel(int amount)
{
    m_Health += amount;
    // But not beyond the maximum
    if (m_Health &gt; m_MaxHealth)
    {
        m_Health = m_MaxHealth;
    }
}</pre>
			<p>In the preceding code, the <code>upgradeSpeed()</code> and <code>upgradeHealth()</code> functions increase the value stored in <code>m_Speed</code> and <code>m_MaxHealth</code>, respectively. These values are increased by 20% by multiplying the starting values by .2 and adding them to the current values. These functions will be called from the <code>main</code> function when the player is choosing what attributes of their character they wish to improve (that is, level up) between levels.</p>
			<p>The <code>increaseHealthLevel()</code> function takes an <code>int</code> value from <code>main</code> in the <code>amount</code> parameter. This <code>int</code> value will be provided by a class called <code>Pickup</code>, which we will write in <a href="B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249"><em class="italic">Chapter 11</em></a><em class="italic">, Collision Detection, Pickups, and Bullets</em>. The <code>m_Health</code> member variable is increased by the passed-in value. However, there is a catch for the player. The <code>if</code> statement checks whether <code>m_Health</code> has exceeded <code>m_MaxHealth</code> and, if it has, sets it to <code>m_MaxHealth</code>. This means the player cannot simply gain infinite health from pick-ups. Instead, they must carefully balance the upgrades they choose between levels.</p>
			<p>Of course, our <code>Player</code> class can't do anything until we instantiate it and put it to work in our game loop. Before we do that, let's look at the concept of a game camera.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Controlling the game camera with SFML View</h1>
			<p>In my opinion, the SFML <code>View</code> class is one of the neatest classes. After finishing this book, when we make games without using a media/gaming library, we will really notice the absence of <code>View</code>. </p>
			<p>The <code>View</code> class allows us to consider our game as taking place in its own world, with its own properties. What do I mean? Well, when we create a game, we are usually trying to create a virtual world. That virtual world rarely, if ever, is measured in pixels, and rarely, if ever, will that world be the same number of pixels as the player's monitor. We need a way to abstract the virtual world we are building so that it can be of whatever size or shape we like.</p>
			<p>Another way to think of SFML <code>View</code> is as a camera through which the player views a part of our virtual world. Most games will have more than one camera/view of the world.</p>
			<p>For example, consider a split screen game where two players can be in different parts of the world at the same time.</p>
			<p>Or, consider a game where there is a small area of the screen that represents the entire game world, but at a very high level/zoomed out, like a mini map.</p>
			<p>Even if our games are much simpler than the previous two examples and don't need split screens or mini maps, we will likely want to create a world that is bigger than the screen it is being played on. This is, of course, the case with Zombie Arena.</p>
			<p>Additionally, if we are constantly moving the game camera around to show different parts of the virtual world (usually to track the player), what happens to the HUD? If we draw the score and other onscreen HUD information and then we scroll the world around to follow the player, the score would move relative to that camera.</p>
			<p>The SFML <code>View</code> class easily enables all these of features and solves this problem with very straightforward code. The trick is to create an instance of <code>View</code> for every camera – perhaps a <code>View</code> instance for the mini map, a <code>View</code> instance for the scrolling game world, and then a <code>View</code> instance for the HUD.</p>
			<p>The instances of <code>View</code> can be moved around, sized, and positioned as required. So, the main <code>View</code> instance following the game can track the player, the mini-map view can remain in a fixed, zoomed-out small corner of the screen, and the HUD can overlay the entire screen and never move, despite the fact the main <code>View</code> instance could go wherever the player goes. </p>
			<p>Let's look at some code using a few instances of <code>View</code>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This code is being used to introduce the <code>View</code> class. Don't add this code to the Zombie Arena project.</p>
			<p>Create and initialize a few instances of <code>View</code>:</p>
			<pre>// Create a view to fill a 1920 x 1080 monitor
View mainView(sf::FloatRect(0, 0, 1920, 1080));
// Create a view for the HUD
View hudView(sf::FloatRect(0, 0, 1920, 1080));</pre>
			<p>The previous code creates two <code>View</code> objects that fill a 1920 x 1080 monitor. Now, we can do some magic with <code>mainView</code> while leaving <code>hudView</code> completely alone:</p>
			<pre>// In the update part of the game
// There are lots of things you can do with a View
// Make the view centre around the player                
mainView.setCenter(player.getCenter());
// Rotate the view 45 degrees
mainView.rotate(45)
// Note that hudView is totally unaffected by the previous code</pre>
			<p>When we manipulate the properties of a <code>View</code> instance, we do so like this. When we draw sprites, text, or other objects to a view, we must specifically <strong class="bold">set</strong> the view as the current view for the window:</p>
			<pre>// Set the current view
window.setView(mainView);</pre>
			<p>Now, we can draw everything we want into that view:</p>
			<pre>// Do all the drawing for this view
window.draw(playerSprite);
window.draw(otherGameObject);
// etc</pre>
			<p>The player might be at any coordinate whatsoever; it doesn't matter because <code>mainView</code> is centered around the graphic.</p>
			<p>Now, we can draw the HUD into <code>hudView</code>. Note that just like we draw individual elements (background, game objects, text, and so on) in layers from back to front, we also draw views from back to front as well. Hence, a HUD is drawn after the main game scene:</p>
			<pre>// Switch to the hudView
window.setView(hudView);
// Do all the drawing for the HUD
window.draw(scoreText);
window.draw(healthBar);
// etc</pre>
			<p>Finally, we can draw/show the window and all its views for the current frame in the usual way:</p>
			<pre>window.display();</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to take your understanding of SFML <code>View</code> further than is necessary for this project, including how to achieve split screens and mini maps, then the best guide on the web is on the official SFML website: <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-view.php">https://www.sfml-dev.org/tutorials/2.5/graphics-view.php</a>.</p>
			<p>Now that we have learned about <code>View</code>, we can start coding the Zombie Arena <code>main</code> function and use our first <code>View</code> instance for real. In <a href="B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 12</em></a>,<em class="italic"> Layering Views and Implementing the HUD</em>, we will introduce a second instance of <code>View</code> for the HUD and layer it over the top of the main <code>View</code> instance.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor194"/>Starting the Zombie Arena game engine</h1>
			<p>In this game, we will need a slightly upgraded game engine in <code>main</code>. We will have an enumeration called <code>state</code>, which will track what the current state of the game is. Then, throughout <code>main</code>, we can wrap parts of our code so that different things happen in different states.</p>
			<p>When we created the project, Visual Studio created a file for us called <code>ZombieArena.cpp</code>. This will be the file that contains our <code>main</code> function and the code that instantiates and controls all our classes.</p>
			<p>We begin with the now-familiar <code>main</code> function and some include directives. Note the addition of an include directive for the <code>Player</code> class.</p>
			<p>Add the following code to the <code>ZombieArena.cpp</code> file:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
#include "Player.h"
using namespace sf;
int main()
{
    return 0;
}</pre>
			<p>The previous code has nothing new in it except that the <code>#include "Player.h"</code> line means we can now use the <code>Player</code> class within our code.</p>
			<p>Let's flesh out some more of our game engine. The following code does quite a lot. Be sure to read the comments when you add the code to get an idea of what is going on. We will then go through it in more detail.</p>
			<p>Add the following highlighted code at the start of the <code>main</code> function:</p>
			<pre>int main()
{
<strong class="bold">    // The game will always be in one of four states</strong>
<strong class="bold">    enum class State { PAUSED, LEVELING_UP, </strong>
<strong class="bold">            GAME_OVER, PLAYING };</strong>
<strong class="bold">            </strong>
<strong class="bold">    // Start with the GAME_OVER state</strong>
<strong class="bold">    State state = State::GAME_OVER;</strong>
<strong class="bold">    // Get the screen resolution and </strong>
<strong class="bold">    // create an SFML window</strong>
<strong class="bold">    Vector2f resolution;</strong>
<strong class="bold">    resolution.x = </strong>
<strong class="bold">        VideoMode::getDesktopMode().width;</strong>
<strong class="bold">    resolution.y = </strong>
<strong class="bold">        VideoMode::getDesktopMode().height;</strong>
<strong class="bold">    RenderWindow window(</strong>
<strong class="bold">        VideoMode(resolution.x, resolution.y), </strong>
<strong class="bold">        "Zombie Arena", Style::Fullscreen);</strong>
<strong class="bold">    // Create a an SFML View for the main action</strong>
<strong class="bold">    View mainView(sf::FloatRect(0, 0, </strong>
<strong class="bold">            resolution.x, resolution.y));</strong>
<strong class="bold">    // Here is our clock for timing everything</strong>
<strong class="bold">    Clock clock;</strong>
<strong class="bold">    // How long has the PLAYING state been active</strong>
<strong class="bold">    Time gameTimeTotal;</strong>
<strong class="bold">    // Where is the mouse in </strong>
<strong class="bold">    // relation to world coordinates</strong>
<strong class="bold">    Vector2f mouseWorldPosition;</strong>
<strong class="bold">    // Where is the mouse in </strong>
<strong class="bold">    // relation to screen coordinates</strong>
<strong class="bold">    Vector2i mouseScreenPosition;</strong>
<strong class="bold">    // Create an instance of the Player class</strong>
<strong class="bold">    Player player;</strong>
<strong class="bold">    // The boundaries of the arena</strong>
<strong class="bold">    IntRect arena;</strong>
<strong class="bold">    // The main game loop</strong>
<strong class="bold">    while (window.isOpen())</strong>
<strong class="bold">    {</strong>
<strong class="bold">    </strong>
<strong class="bold">    }</strong>
    return 0;
}</pre>
			<p>Let's run through each section of all the code that we entered. Just inside the <code>main</code> function, we have the following code:</p>
			<pre>// The game will always be in one of four states
enum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING };
// Start with the GAME_OVER state
State state = State::GAME_OVER;</pre>
			<p>The previous code creates a new enumeration class called <code>State</code>. Then, the code creates an instance of the <code>State</code> class called <code>state</code>. The <code>state</code> enumeration can now be one of four values, as defined in the declaration. Those values are <code>PAUSED</code>, <code>LEVELING_UP</code>, <code>GAME_OVER</code>, and <code>PLAYING</code>. These four values will be just what we need for keeping track and responding to the different states that the game can be in at any given time. Note that it is not possible for <code>state</code> to hold more than one value at a time.</p>
			<p>Immediately after, we added the following code:</p>
			<pre>// Get the screen resolution and create an SFML window
Vector2f resolution;
resolution.x = VideoMode::getDesktopMode().width;
resolution.y = VideoMode::getDesktopMode().height;
RenderWindow window(VideoMode(resolution.x, resolution.y), 
    "Zombie Arena", Style::Fullscreen);</pre>
			<p>The previous code declares a <code>Vector2f</code> instance called <code>resolution</code>. We initialize the two member variables of <code>resolution</code> (<code>x</code> and <code>y</code>) by calling the <code>VideoMode::getDesktopMode</code> function for both <code>width</code> and <code>height</code>. The <code>resolution</code> object now holds the resolution of the monitor on which the game is running. The final line of code creates a new <code>RenderWindow</code> instance called <code>window</code> using the appropriate resolution.</p>
			<p>The following code creates an SFML <code>View</code> object. The view is positioned (initially) at the exact coordinates of the pixels of the monitor. If we were to use this <code>View</code> to do some drawing in this current position, it would be the same as drawing to a window without a view. However, we will eventually start to move this view to focus on the parts of our game world that the player needs to see. Then, when we start to use a second <code>View</code> instance, which remains fixed (for the HUD), we will see how this <code>View</code> instance can track the action while the other remains static to display the HUD:</p>
			<pre>// Create a an SFML View for the main action
View mainView(sf::FloatRect(0, 0, resolution.x, resolution.y));</pre>
			<p>Next, we created a <code>Clock</code> instance to do our timing and a <code>Time</code> object called <code>gameTimeTotal</code> that will keep a running total of the game time that has elapsed. As the project progresses, we will also introduce more variables and objects to handle timing:</p>
			<pre>// Here is our clock for timing everything
Clock clock;
// How long has the PLAYING state been active
Time gameTimeTotal;</pre>
			<p>The following code declares two vectors: one holding two <code>float</code> variables, called <code>mouseWorldPosition</code>, and one holding two integers, called <code>mouseScreenPosition</code>. The mouse pointer is something of an anomaly because it exists in two different coordinate spaces. We could think of these as parallel universes if we like. Firstly, as the player moves around the world, we will need to keep track of where the crosshair is in that world. These will be floating-point coordinates and will be stored in <code>mouseWorldCoordinates</code>. Of course, the actual pixel coordinates of the monitor itself never change. They will always be 0,0 to horizontal resolution -1, vertical resolution -1. We will track the mouse pointer position that is relative to this coordinate space using the integers stored in <code>mouseScreenPosition</code>:</p>
			<pre>// Where is the mouse in relation to world coordinates
Vector2f mouseWorldPosition;
// Where is the mouse in relation to screen coordinates
Vector2i mouseScreenPosition;</pre>
			<p>Finally, we get to use our <code>Player</code> class. This line of code will cause the constructor function (<code>Player::Player</code>) to execute. Refer to <code>Player.cpp</code> if you want to refresh your memory about this function:</p>
			<pre>// Create an instance of the Player class
Player player;</pre>
			<p>This <code>IntRect</code> object will hold starting horizontal and vertical coordinates, as well as a width and a height. Once initialized, we will be able to access the size and location details of the current arena with code such as <code>arena.left</code>, <code>arena.top</code>, <code>arena.width</code>, and <code>arena.height</code>:</p>
			<pre>// The boundaries of the arena
IntRect arena;</pre>
			<p>The last part of the code that we added previously is, of course, our game loop:</p>
			<pre>// The main game loop
while (window.isOpen())
{
}</pre>
			<p>We have probably noticed that the code is getting quite long. We'll talk about this inconvenience in the following section.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor195"/>Managing the code files</h1>
			<p>One of the advantages of abstraction using classes and functions is that the length (number of lines) of our code files can be reduced. Even though we will be using more than a dozen code files for this project, the length of the code in <code>ZombieArena.cpp</code> will still get a little unwieldy toward the end. In the final project, Space Invaders++, we will look at even more ways to abstract and manage our code. </p>
			<p>For now, use this tip to keep things manageable. Notice that on the left-hand side of the code editor in Visual Studio, there are several <strong class="bold">+</strong> and <strong class="bold">-</strong> signs, one of which is shown in this diagram:</p>
			<div><div><img src="img/B14278_08_04.jpg" alt=""/>
				</div>
			</div>
			<p>There will be one sign for each block (<code>if</code>, <code>while</code>, <code>for</code>, and so on) of the code. You can expand and collapse these blocks by clicking on the <strong class="bold">+</strong> and <strong class="bold">-</strong> signs. I recommend keeping all the code not currently under discussion collapsed. This will make things much clearer. </p>
			<p>Furthermore, we can create our own collapsible blocks. I suggest making a collapsible block out of all the code before the start of the main game loop. To do so, highlight the code and then <em class="italic">right-click</em> and choose <strong class="bold">Outlining</strong> | <strong class="bold">Hide Selection</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_08_05.jpg" alt=""/>
				</div>
			</div>
			<p>Now, you can click the <strong class="bold">-</strong> and <strong class="bold">+</strong> signs to expand and collapse the block. Each time we add code before the main game loop (and that will be quite often), you can expand the code, add the new lines, and then collapse it again. The following screenshot shows what the code looks like when it is collapsed:</p>
			<div><div><img src="img/B14278_08_06.jpg" alt=""/>
				</div>
			</div>
			<p>This is much more manageable than it was before. Now, we can make a start with the main game loop.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor196"/>Starting to code the main game loop</h1>
			<p>As you can see, the last part of the preceding code is the game loop (<code>while (window.isOpen()){}</code>). We will turn our attention to this now. Specifically, we will be coding the input handling section of the game loop.</p>
			<p>The code that we will be adding is quite long. There is nothing complicated about it, though, and we will examine it all in a moment.</p>
			<p>Add the following highlighted code to the game loop:</p>
			<pre>// The main game loop
while (window.isOpen())
{
<strong class="bold">    /*</strong>
<strong class="bold">    ************</strong>
<strong class="bold">    Handle input</strong>
<strong class="bold">    ************</strong>
<strong class="bold">    */</strong>
<strong class="bold">    // Handle events by polling</strong>
<strong class="bold">    Event event;</strong>
<strong class="bold">    while (window.pollEvent(event))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (event.type == Event::KeyPressed)</strong>
<strong class="bold">        {                                    </strong>
<strong class="bold">            // Pause a game while playing</strong>
<strong class="bold">            if (event.key.code == Keyboard::Return &amp;&amp;</strong>
<strong class="bold">                state == State::PLAYING)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                state = State::PAUSED;</strong>
<strong class="bold">            }</strong>
<strong class="bold">            // Restart while paused</strong>
<strong class="bold">            else if (event.key.code == Keyboard::Return &amp;&amp;</strong>
<strong class="bold">                state == State::PAUSED)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                state = State::PLAYING;</strong>
<strong class="bold">                // Reset the clock so there isn't a frame jump</strong>
<strong class="bold">                clock.restart();</strong>
<strong class="bold">            }</strong>
<strong class="bold">            // Start a new game while in GAME_OVER state</strong>
<strong class="bold">            else if (event.key.code == Keyboard::Return &amp;&amp;</strong>
<strong class="bold">                state == State::GAME_OVER)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                state = State::LEVELING_UP;</strong>
<strong class="bold">            }</strong>
<strong class="bold">            if (state == State::PLAYING)</strong>
<strong class="bold">            {</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }// End event polling</strong>
}// End game loop</pre>
			<p>In the preceding code, we instantiate an object of the <code>Event</code> type. We will use <code>event</code>, like we did in the previous projects, to poll for system events. To do so, we wrap the rest of the code from the previous block in a <code>while</code> loop with the <code>window.pollEvent(event)</code> condition. This will keep looping each frame until there are no more events to process. </p>
			<p>Inside this <code>while</code> loop, we handle the events we are interested in. First, we test for <code>Event::KeyPressed</code> events. If the <em class="italic">Return</em> key is pressed while the game is in the <code>PLAYING</code> state, then we switch <code>state</code> to <code>PAUSED</code>. </p>
			<p>If the <em class="italic">Return</em> key is pressed while the game is in the <code>PAUSED</code> state, then we switch <code>state</code> to <code>PLAYING</code> and restart the <code>clock</code> object. The reason we restart <code>clock</code> after switching from <code>PAUSED</code> to <code>PLAYING</code> is because, while the game is paused, the elapsed time still accumulates. If we didn't restart the clock, all our objects would update their locations as if the frame had just taken a very long time. This will become more apparent as we flesh out the rest of the code in this file.</p>
			<p>We then have an <code>else if</code> block to test whether the <code>Return</code> key was pressed while the game was in the <code>GAME_OVER</code> state. If it was, then <code>state</code> is changed to <code>LEVELING_UP</code>. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the <code>GAME_OVER</code> state is the state where the home screen is displayed. So, the <code>GAME_OVER</code> state is the state after the player has just died and when the player first runs the game. The first thing that the player gets to do each game is pick an attribute to improve (that is, level up).</p>
			<p>In the previous code, there is a final <code>if</code> condition to test whether the state is equal to <code>PLAYING</code>. This <code>if</code> block is empty and we will add code to it throughout the project.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We will add code to lots of different parts of this file throughout the project. Therefore, it is worthwhile taking the time to understand the different states our game can be in and where we handle them. It will also be very beneficial to collapse and expand the different <code>if</code>, <code>else</code>, and <code>while</code> blocks as and when appropriate.</p>
			<p>Spend some time thoroughly familiarizing yourself with the <code>while</code>, <code>if</code>, and <code>else if</code> blocks we have just coded. We will be referring to them regularly.</p>
			<p>Next, immediately after the previous code and still inside the game loop, which is still dealing with handling input, add the following highlighted code. Note the existing code (not highlighted) that shows exactly where the new (highlighted) code goes:</p>
			<pre>    }// End event polling
<strong class="bold">    // Handle the player quitting</strong>
<strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Escape))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        window.close();</strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Handle WASD while playing</strong>
<strong class="bold">    if (state == State::PLAYING)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Handle the pressing and releasing of the WASD keys</strong>
<strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::W))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.moveUp();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.stopUp();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::S))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.moveDown();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.stopDown();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::A))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.moveLeft();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.stopLeft();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::D))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.moveRight();</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            player.stopRight();</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }// End WASD while playing</strong>
}// End game loop</pre>
			<p>In the preceding code, we first test to see whether the player has pressed the <em class="italic">Escape</em> key. If it is pressed, the game window will be closed.</p>
			<p>Next, within one big <code>if(state == State::PLAYING)</code> block, we check each of the <em class="italic">WASD</em> keys in turn. If a key is pressed, we call the appropriate <code>player.move...</code> function. If it is not, we call the related <code>player.stop...</code> function.</p>
			<p>This code ensures that, in each frame, the player object will be updated with the <em class="italic">WASD</em> keys that are pressed and those that are not. The <code>player.move...</code> and <code>player.stop...</code> functions store the information in the member Boolean variables (<code>m_LeftPressed</code>, <code>m_RightPressed</code>, <code>m_UpPressed</code>, and <code>m_DownPressed</code>). The <code>Player</code> class then responds to the value of these Booleans, in each frame, in the <code>player.update</code> function, which we will call in the update section of the game loop.</p>
			<p>Now, we can handle the keyboard input to allow the player to level up at the start of each game and in-between each wave. Add and study the following highlighted code and then we will discuss it:</p>
			<pre>    }// End WASD while playing
<strong class="bold">    // Handle the LEVELING up state</strong>
<strong class="bold">    if (state == State::LEVELING_UP)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Handle the player LEVELING up</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num1)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num2)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num3)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num4)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num5)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (event.key.code == Keyboard::Num6)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::PLAYING;</strong>
<strong class="bold">        }</strong>
<strong class="bold">        </strong>
<strong class="bold">        if (state == State::PLAYING)</strong>
<strong class="bold">        {            </strong>
<strong class="bold">            // Prepare the level</strong>
<strong class="bold">            // We will modify the next two lines later</strong>
<strong class="bold">            arena.width = 500;</strong>
<strong class="bold">            arena.height = 500;</strong>
<strong class="bold">            arena.left = 0;</strong>
<strong class="bold">            arena.top = 0;</strong>
<strong class="bold">            // We will modify this line of code later</strong>
<strong class="bold">            int tileSize = 50;</strong>
<strong class="bold">            // Spawn the player in the middle of the arena</strong>
<strong class="bold">            player.spawn(arena, resolution, tileSize);</strong>
<strong class="bold">            </strong>
<strong class="bold">            // Reset the clock so there isn't a frame jump</strong>
<strong class="bold">            clock.restart();</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }// End LEVELING up</strong>
    
}// End game loop</pre>
			<p>In the preceding code, which is all wrapped in a test to see whether the current value of <code>state</code> is equal to <code>LEVELING_UP</code>, we handle the keyboard keys <em class="italic">1</em>, <em class="italic">2</em>, <em class="italic">3</em>, <em class="italic">4</em>, <em class="italic">5</em>, and <em class="italic">6</em>. In the <code>if</code> block for each, we simply set <code>state</code> to <code>State::PLAYING</code>. We will add some code to deal with each level up option later in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a><em class="italic">, Sound Effects, File I/O, and Finishing the Game</em>.</p>
			<p>This code does the following things:</p>
			<ol>
				<li value="1">If the <code>state</code> is equal to <code>LEVELING_UP</code>, wait for either the <em class="italic">1</em>, <em class="italic">2</em>, <em class="italic">3</em>, <em class="italic">4</em>, <em class="italic">5</em>, or <em class="italic">6</em> keys to be pressed.</li>
				<li>When pressed, change <code>state</code> to <code>PLAYING</code>.</li>
				<li>When the state changes, still within the <code>if (state == State::LEVELING_UP)</code> block, the nested <code>if(state == State::PLAYING)</code> block will run.</li>
				<li>Within this block, we set the location and size of <code>arena</code>, set the <code>tileSize</code> to <code>50</code>, pass all the information to <code>player.spawn</code>, and call <code>clock.restart</code>.</li>
			</ol>
			<p>Now, we have an actual spawned player object that is aware of its environment and can respond to key presses. We can now update the scene on each pass through the loop.</p>
			<p>Be sure to neatly collapse the code from the input handling part of the game loop since we are done with that for now. The following code is in the updating part of the game loop. Add and study the following highlighted code and then we can discuss it:</p>
			<pre>    }// End LEVELING up
<strong class="bold">    /*</strong>
<strong class="bold">    ****************</strong>
<strong class="bold">    UPDATE THE FRAME</strong>
<strong class="bold">    ****************</strong>
<strong class="bold">    */</strong>
<strong class="bold">    if (state == State::PLAYING)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Update the delta time</strong>
<strong class="bold">        Time dt = clock.restart();</strong>
<strong class="bold">        </strong>
<strong class="bold">        // Update the total game time</strong>
<strong class="bold">        gameTimeTotal += dt;</strong>
<strong class="bold">        </strong>
<strong class="bold">        // Make a decimal fraction of 1 from the delta time</strong>
<strong class="bold">        float dtAsSeconds = dt.asSeconds();</strong>
<strong class="bold">        // Where is the mouse pointer</strong>
<strong class="bold">        mouseScreenPosition = Mouse::getPosition();</strong>
<strong class="bold">        // Convert mouse position to world coordinates of mainView</strong>
<strong class="bold">        mouseWorldPosition = window.mapPixelToCoords(</strong>
<strong class="bold">            Mouse::getPosition(), mainView);</strong>
<strong class="bold">        // Update the player</strong>
<strong class="bold">        player.update(dtAsSeconds, Mouse::getPosition());</strong>
<strong class="bold">        // Make a note of the players new position</strong>
<strong class="bold">        Vector2f playerPosition(player.getCenter());</strong>
<strong class="bold">        </strong>
<strong class="bold">        // Make the view centre around the player                </strong>
<strong class="bold">        mainView.setCenter(player.getCenter());</strong>
<strong class="bold">    }// End updating the scene</strong>
    
}// End game loop</pre>
			<p>First, note that the previous code is wrapped in a test to make sure the game is in the <code>PLAYING</code> state. We don't want this code to run if the game has been paused, it has ended, or if the player is choosing what to level up.</p>
			<p>First, we restart the clock and store the time that the previous frame took in the <code>dt</code> variable:</p>
			<pre>// Update the delta time
Time dt = clock.restart();</pre>
			<p>Next, we add the time that the previous frame took to the accumulated time the game has been running for, as held by <code>gameTimeTotal</code>:</p>
			<pre>// Update the total game time
gameTimeTotal += dt;</pre>
			<p>Now, we initialize a <code>float</code> variable called <code>dtAsSeconds</code> with the value returned by the <code>dt.AsSeconds</code> function. For most frames, this will be a fraction of one. This is perfect for passing into the <code>player.update</code> function to be used to calculate how much to move the player sprite.</p>
			<p>Now, we can initialize <code>mouseScreenPosition</code> using the <code>MOUSE::getPosition</code> function.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You might be wondering about the slightly unusual syntax for getting the position of the mouse. This is called a <strong class="bold">static function</strong>. If we define a function in a class with the static keyword, we can call that function using the class name and without an instance of the class. C++ OOP has lots of quirks and rules like this. We will see more as we progress.</p>
			<p>We then initialize <code>mouseWorldPosition</code> using the SFML <code>mapPixelToCoords</code> function on <code>window</code>. We discussed this function when talking about the <code>View</code> class earlier in this chapter.</p>
			<p>At this point, we are now able to call <code>player.update</code> and pass in <code>dtAsSeconds</code> and the position of the mouse, as is required.</p>
			<p>We store the player's new center in a <code>Vector2f</code> instance called <code>playerPosition</code>. At the moment, this is unused, but we will have a use for this later in the project.</p>
			<p>We can then center the view around the center of the player's up-to-date position with <code>mainView.setCenter(player.getCenter())</code>.</p>
			<p>We are now able to draw the player to the screen. Add the following highlighted code, which splits the draw section of the main game loop into different states:</p>
			<pre>        }// End updating the scene
<strong class="bold">        /*</strong>
<strong class="bold">        **************</strong>
<strong class="bold">        Draw the scene</strong>
<strong class="bold">        **************</strong>
<strong class="bold">        */</strong>
<strong class="bold">        if (state == State::PLAYING)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            window.clear();</strong>
<strong class="bold">            // set the mainView to be displayed in the window</strong>
<strong class="bold">            // And draw everything related to it</strong>
<strong class="bold">            window.setView(mainView);</strong>
<strong class="bold">            // Draw the player</strong>
<strong class="bold">            window.draw(player.getSprite());</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (state == State::LEVELING_UP)</strong>
<strong class="bold">        {</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (state == State::PAUSED)</strong>
<strong class="bold">        {</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (state == State::GAME_OVER)</strong>
<strong class="bold">        {</strong>
<strong class="bold">        }</strong>
<strong class="bold">        window.display();</strong>
    }// End game loop
    return 0;
}</pre>
			<p>Within the <code>if(state == State::PLAYING)</code> section of the previous code, we clear the screen, set the view of the window to <code>mainView</code>, and then draw the player sprite with <code>window.draw(player.getSprite())</code>.</p>
			<p>After all the different states have been handled, the code shows the scene in the usual manner with <code>window.display();</code>.</p>
			<p>You can run the game and see our player character spin around in response to moving the mouse.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you run the game, you need to press <em class="italic">Enter</em> to start the game, and then select a number from <em class="italic">1</em> to <em class="italic">6</em> to simulate choosing an upgrade option. Then, the game will start.</p>
			<p>You can also move the player around within the (empty) 500 x 500 pixel arena. You can see our lonely player in the center of the screen, as shown here:</p>
			<div><div><img src="img/B14278_08_07.jpg" alt=""/>
				</div>
			</div>
			<p>You c<a id="_idTextAnchor197"/>an't, however, get any sense of movement because we haven't implemented the background. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor198"/>Summary</h1>
			<p>Phew! That was a long one. We have done a lot in this chapter: we built our first class for the Zombie Arena project, <code>Player</code>, and put it to use in the game loop. We also learned about and used an instance of the <code>View</code> class, although we haven't explored the benefits this gives us just yet.</p>
			<p>In the next chapter, we will build our arena background by exploring what sprite sheets are. We will also learn about C++ <strong class="bold">references</strong>, which allow us to manipulate variables, even when they are out of scope (that is, in another function).</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor199"/>FAQ</h1>
			<p>Q) I noticed we have coded quite a few functions of the <code>Player</code> class that we don't use. Why is this?</p>
			<p>A) Rather than keep coming back to the <code>Player</code> class, we have added all the code that we will need throughout the project. By the end of <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>, <em class="italic">Sound Effects, File I/O, and Finishing the Game</em>, we will have made full use of all of these functions.</p>
		</div>
	</body></html>