<html><head></head><body>
		<div id="_idContainer064">
			<h1 id="_idParaDest-178"><a id="_idTextAnchor183"/><em class="italic">Chapter 8</em>: SFML Views – Starting the Zombie Shooter Game</h1>
			<p>In this project, we will be making even more use of <strong class="bold">OOP</strong> and to a powerful effect. We will also be exploring the SFML <strong class="source-inline">View</strong> class. This versatile class will allow us to easily divide our game up into layers for different aspects of the game. In the Zombie Shooter project, we will have a layer for the HUD and a layer for the main game. This is necessary because as the game world expands each time the player clears a wave of zombies and, eventually, the game world will be bigger than the screen and will need to scroll. The use of the <strong class="source-inline">View</strong> class will prevent the text of the HUD from scrolling with the background. In the next project, we will take things even further and create a co-op split screen game with the SFML <strong class="source-inline">View</strong> class doing most of the hard work.</p>
			<p>This is what we will do in this chapter:</p>
			<ul>
				<li>Planning and starting the Zombie Arena game</li>
				<li>Coding the <strong class="source-inline">Player</strong> class</li>
				<li>Learning about the SFML <strong class="source-inline">View</strong> class</li>
				<li>Building the Zombie Arena game engine</li>
				<li>Putting the <strong class="source-inline">Player</strong> class to work</li>
			</ul>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor184"/>Planning and starting the Zombie Arena game</h1>
			<p>At this point, if you haven't already, I suggest you go and watch a video of <em class="italic">Over 9000 Zombies</em> (<a href="http://store.steampowered.com/app/273500/">http://store.steampowered.com/app/273500/</a>) and <em class="italic">Crimson Land</em> (<a href="http://store.steampowered.com/app/262830/">http://store.steampowered.com/app/262830/</a>). Our game will obviously not be as in-depth or advanced as either of these examples, but we will also have the same basic set of features and game mechanics, such as the following:</p>
			<ul>
				<li>A Heads Up Display (HUD) that shows details such as the score, high score, and bullets in clip, the number of bullets left, player health, and the number of zombies left to kill.</li>
				<li>The player will shoot zombies while frantically running away from them.</li>
				<li>Move around a scrolling world using the <em class="italic">WASD</em> keyboard keys while aiming the gun using the mouse.</li>
				<li>In-between each level, the player will choose a "level-up" that will affect the way the game needs to be played for the player to win.</li>
				<li>The player will need to collect "pick-ups" to restore health and ammunition.</li>
				<li>Each wave brings more zombies and a bigger arena to make it more challenging.</li>
			</ul>
			<p>There will be three types of zombies to splatter. They will have different attributes, such as appearance, health, and speed. We will call them chasers, bloaters, and crawlers. Take a look at the following annotated screenshot of the game to see some of the features in action and the components and assets that make up the game:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B14278_08_01.jpg" alt=""/>
				</div>
			</div>
			<p>Here is some more information about each of the numbered points:</p>
			<ol>
				<li>The score and hi-score. These, along with the other parts of the HUD, will be drawn in a separate layer, known as a view, and represented by an instance of the <strong class="source-inline">View</strong> class. The hi-score will be saved and loaded to a file.</li>
				<li>A texture that will build a wall around the arena. This texture is contained in a single graphic called a <strong class="bold">sprite sheet</strong>, along with the other background textures (points <strong class="bold">3</strong>, <strong class="bold">5</strong>, and <strong class="bold">6</strong>).</li>
				<li>The first of two mud textures from the sprite sheet.</li>
				<li>This is an "ammo pick-up." When the player gets this, they will be given more ammunition. There is a "health pick-up" as well, from which the player will receive more health. These pick-ups can be chosen by the player to be upgraded in-between waves of zombies.</li>
				<li>A grass texture, also from the sprite sheet.</li>
				<li>The second mud texture from the sprite sheet.</li>
				<li>A blood splat where there used to be a zombie.</li>
				<li>The bottom part of the HUD. From left to right, there is an icon to represent ammo, the number of bullets in the clip, the number of spare bullets, a health bar, the current wave of zombies, and the number of zombies remaining for the current wave.</li>
				<li>The player's character.</li>
				<li>A crosshair, which the player aims with the mouse.</li>
				<li>A slow-moving, but strong, "bloater" zombie.</li>
				<li>A slightly faster-moving, but weaker, "crawler" zombie. There is also a "chaser zombie" that is very fast and weak. Unfortunately, I couldn't manage to get one in the screenshot before they were all killed.</li>
			</ol>
			<p>So, we have a lot to do and new C++ skills to learn. Let's start by creating a new project.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>Creating a new project</h2>
			<p>As creating a project is a relatively involved process, I will detail all the steps again. For even more detail and images, please refer to the <em class="italic">Setting up the Timber project</em> section in <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>.</p>
			<p>As setting up a project is a fiddly process, we will go through it step by step, like we did for the Timber project. I won't show you the same images as I did for the Timber project, but the process is the same, so flip back to <a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em> if you want a reminder of the locations of the various project properties. Let's look at the following steps:</p>
			<ol>
				<li value="1">Start Visual Studio and click on the <strong class="bold">Create New Project</strong> button. If you have another project open, you can select <strong class="bold">File</strong> | <strong class="bold">New project</strong>.</li>
				<li>In the window shown next, choose <strong class="bold">Console app</strong> and click on the <strong class="bold">Next</strong> button. You will then see the <strong class="bold">Configure your new project</strong> window. </li>
				<li>In the <strong class="bold">Configure your new project</strong> window, type <strong class="source-inline">Zombie Arena</strong> in the <strong class="bold">Project</strong> <strong class="bold">name</strong> field. </li>
				<li>In the <strong class="bold">Location</strong> field, browse to the <strong class="source-inline">VS Projects</strong> folder.</li>
				<li>Check the option to <strong class="bold">Place solution and project in the same directory</strong>. </li>
				<li>When you have completed the preceding steps, click on <strong class="bold">Create</strong>. </li>
				<li>We will now configure the project to use the SFML files that we put in the <strong class="source-inline">SFML</strong> folder. From the main menu, select <strong class="bold">Project</strong> | <strong class="bold">Zombie Arena properties…</strong>. At this stage, you should have the <strong class="bold">Zombie Arena Property Pages</strong> window open. </li>
				<li>In the <strong class="bold">Zombie Arena Property Pages</strong> window, take the following steps. Select <strong class="bold">All Configurations</strong> from the <strong class="bold">Configuration:</strong> dropdown menu.</li>
				<li>Now, select <strong class="bold">C/C++</strong> and then <strong class="bold">General</strong> from the left-hand menu.</li>
				<li>Next, locate the <strong class="bold">Additional Include Directories</strong> edit box and type the drive letter where your SFML folder is located, followed by <strong class="source-inline">\SFML\include</strong>. The full path to type, if you located your <strong class="source-inline">SFML</strong> folder on your D drive, will be <strong class="source-inline">D:\SFML\include</strong>. Vary your path if you installed SFML on a different drive.</li>
				<li>Click on <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Now, still in the same window, perform these next steps. From the left-hand menu, select <strong class="bold">Linker</strong> and then <strong class="bold">General</strong>.</li>
				<li>Now, find the <strong class="bold">Additional Library Directories</strong> edit box and type the drive letter where your <strong class="source-inline">SFML</strong> folder is, followed by <strong class="source-inline">\SFML\lib</strong>. So, the full path to type, if you located your <strong class="source-inline">SFML</strong> folder on your D drive, will be <strong class="source-inline">D:\SFML\lib</strong>. Change your path if you installed SFML to a different drive.</li>
				<li>Click on <strong class="bold">Apply</strong> to save your configurations so far.</li>
				<li>Next, still in the same window, perform these steps. Switch the <strong class="bold">Configuration:</strong> dropdown menu to <strong class="bold">Debug </strong>as we will be running and testing Pong in debug mode.</li>
				<li>Select <strong class="bold">Linker</strong> and then <strong class="bold">Input</strong>.</li>
				<li>Find the <strong class="bold">Additional Dependencies</strong> edit box and click on it in the far left-hand side. Now copy and paste/type the following: <strong class="source-inline">sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;</strong>. Be extra careful to place the cursor exactly at the start of the edit box's current content so as not to overwrite any of the text that is already there.</li>
				<li>Click on <strong class="bold">OK</strong>.</li>
				<li>Click on <strong class="bold">Apply</strong> and then <strong class="bold">OK</strong>.</li>
			</ol>
			<p>Now, you have configured the project properties and you are nearly ready to go. Next, we need to copy the SFML <strong class="source-inline">.dll</strong> files into the main project directory by following these steps:</p>
			<ol>
				<li value="1">My main project directory is <strong class="source-inline">D:\VS Projects\Zombie Arena</strong>. This folder was created by Visual Studio in the previous steps. If you put your <strong class="source-inline">Projects</strong> folder somewhere else, then perform this step in your directory. The files we need to copy into the project folder are in your <strong class="source-inline">SFML\bin</strong> folder. Open a window for each of the two locations and highlight all the <strong class="source-inline">.dll</strong> files.</li>
				<li>Now, copy and paste the highlighted files into the project.</li>
			</ol>
			<p>The project is now set up and ready to go. Next, we will explore and add the project assets.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor186"/>The project assets</h2>
			<p>The assets in this project are more numerous and more diverse than the previous games. The assets include the following:</p>
			<ul>
				<li>A font for the text on the screen</li>
				<li>Sound effects for different actions such as shooting, reloading, or getting hit by a zombie</li>
				<li>Graphics for the character, zombies, and a sprite sheet for the various background textures</li>
			</ul>
			<p>All the graphics and sound effects that are required for the game are included in the download bundle. They can be found in the <strong class="source-inline">Chapter 8/graphics</strong> and <strong class="source-inline">Chapter 8/sound</strong> folders, respectively. </p>
			<p>The font that is required has not been supplied. This is done to avoid any possible ambiguity regarding the license. This will not cause a problem because the links for downloading the fonts and how and where to choose the font will be provided.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>Exploring the assets</h2>
			<p>The graphical assets make up the parts of the scene of our Zombie Arena game. Look at the following graphical assets; it should be clear to you where the assets in the game will be used:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B14278_08_03.jpg" alt=""/>
				</div>
			</div>
			<p>What might be less obvious, however, is the <strong class="source-inline">background_sheet.png</strong> file, which contains four different images. This is the sprite sheet we mentioned previously. We will see how we can save memory and increase the speed of our game using the sprite sheet in <a href="B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200"><em class="italic">Chapter 9</em></a>,<em class="italic"> C++ References, Sprite Sheets, and Vertex Arrays</em>.</p>
			<p>The sound files are all in <strong class="source-inline">.wav</strong> format. These are files that contain the sound effects that will be played when certain events are triggered. They are as follows:</p>
			<ul>
				<li><strong class="source-inline">hit.wav</strong>: A sound that plays when a zombie comes into contact with the player.</li>
				<li><strong class="source-inline">pickup.wav</strong>: A sound that plays when the player collides or steps on (collects) a health boost (pick-up).</li>
				<li><strong class="source-inline">powerup.wav</strong>: A sound for when the player chooses an attribute to increase their strength (power-up) in-between each wave of zombies.</li>
				<li><strong class="source-inline">reload.wav</strong>: A satisfying click to let the player know they have loaded a fresh clip of ammunition. </li>
				<li><strong class="source-inline">reload_failed.wav</strong>: A less satisfying sound that indicates failing to load new bullets.</li>
				<li><strong class="source-inline">shoot.wav</strong>: A shooting sound.</li>
				<li><strong class="source-inline">splat.wav</strong>: A sound like a zombie being hit by a bullet.</li>
			</ul>
			<p>Once you have decided which assets you will use, it is time to add them to the project.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor188"/>Adding the assets to the project</h2>
			<p>The following instructions will assume you are using all the assets that were supplied is the book's download bundle. Where you are using your own assets, simply replace the appropriate sound or graphic file with your own, using the same filename. Let's take a look at the steps:</p>
			<ol>
				<li value="1">Browse to <strong class="source-inline">D:\VS Projects\ZombieArena</strong>.</li>
				<li>Create three new folders within this folder and name them <strong class="source-inline">graphics</strong>, <strong class="source-inline">sound</strong>, and <strong class="source-inline">fonts</strong>.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 8/graphics</strong> into the <strong class="source-inline">D:\VS Projects\ZombieArena\graphics</strong> folder.</li>
				<li>From the download bundle, copy the entire contents of <strong class="source-inline">Chapter 6/sound</strong> into the <strong class="source-inline">D:\VS Projects\ZombieArena\sound</strong> folder.</li>
				<li>Now, visit <a href="http://www.1001freefonts.com/zombie_control.font">http://www.1001freefonts.com/zombie_control.font</a> in your web browser and download the <strong class="bold">Zombie Control</strong> font.</li>
				<li>Extract the contents of the zipped download and add the <strong class="source-inline">zombiecontrol.ttf</strong> file to the <strong class="source-inline">D:\VS Projects\ZombieArena\fonts</strong> folder. </li>
			</ol>
			<p>Now, it's time to consider how OOP will help us with this project and then we can start writing the code for Zombie Arena.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor189"/>OOP and the Zombie Arena project</h1>
			<p>The initial problem we are faced with is the complexity of the current project. Let's consider that there is just a single zombie; here is what we need to make it function in the game:</p>
			<ul>
				<li>Its horizontal and vertical position</li>
				<li>Its size</li>
				<li>The direction it is facing</li>
				<li>A different texture for each zombie type</li>
				<li>A Sprite</li>
				<li>A different speed for each zombie type</li>
				<li>A different health for each zombie type</li>
				<li>Keeping track of the type of each zombie</li>
				<li>Collision detection data</li>
				<li>Its intelligence (to chase the player), which is slightly different for each type of zombie</li>
				<li>An indication of whether the zombie is alive or dead </li>
			</ul>
			<p>This suggests perhaps a dozen variables for just one zombie, and entire arrays of each of these variables will be required for managing a zombie horde. But what about all the bullets from the machine gun, the pick-ups, and the different level-ups? The simple Timber!!! and Pong games also started to get a bit unmanageable, and it is easy to speculate that this more complicated shooter will be many times worse!</p>
			<p>Fortunately, we will put all the OOP skills we learned in the previous two chapters into action, as well as learn some new C++ techniques.</p>
			<p>We will start our coding for this project with a class to represent the player.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor190"/>Building the player – the first class</h1>
			<p>Let's think about what our <strong class="source-inline">Player</strong> class will need to do and what we require for it. The class will need to <em class="italic">know</em> how fast it can move, where in the game world it currently is, and how much health it has. As the <strong class="source-inline">Player</strong> class, in the player's eyes, is represented as a 2D graphical character, the class will need both a <strong class="source-inline">Sprite</strong> object and a <strong class="source-inline">Texture</strong> object.</p>
			<p>Furthermore, although the reasons might not be obvious at this point, our <strong class="source-inline">Player</strong> class will also benefit from knowing a few details about the overall environment the game is running in. These details are screen resolution, the size of the tiles that make up an arena, and the overall size of the current arena.</p>
			<p>As the <strong class="source-inline">Player</strong> class will be taking full responsibility for updating itself in each frame (like the bat and ball did), it will need to know the player's intentions at any given moment. For example, is the player currently holding down a keyboard direction key? Or is the player currently holding down multiple keyboard direction keys? Boolean variables are used to determine the status of the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys and will be essential.</p>
			<p>It is clear that we are going to need quite a selection of variables in our new class. Having learned all we have about OOP, we will, of course, be making all of these variables private. This means that we must provide access, where appropriate, from the <strong class="source-inline">main</strong> function.</p>
			<p>We will use a whole bunch of getter functions as well as some functions to set up our object. These functions are quite numerous. There are 21 functions in this class. At first, this might seem a little daunting, but we will go through them all and see that most of them simply set or get one of the private variables. </p>
			<p>There are just a few in-depth functions: <strong class="source-inline">update</strong>, which will be called once each frame from the <strong class="source-inline">main</strong> function, and <strong class="source-inline">spawn</strong>, which will handle initializing some of the private variables each time the player is spawned. As we will see, however, there is nothing complicated and they will all be described in detail. </p>
			<p>The best way to proceed is to code the header file. This will give us the opportunity to see all the private variables and examine all the function signatures. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Pay close attention to the return values and argument types, as this will make understanding the code in the function definitions much easier.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor191"/>Coding the Player class header file</h2>
			<p>Start by right-clicking on <strong class="bold">Header Files</strong> in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item…</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking on it) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Player.h</strong>. Finally, click on the <strong class="bold">Add</strong> button. We are now ready to code the header file for our first class.</p>
			<p>Start coding the <strong class="source-inline">Player</strong> class by adding the declaration, including the opening and closing curly braces, followed by a semicolon:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Player</p>
			<p class="source-code">{</p>
			<p class="source-code">};</p>
			<p>Now, let's add all our private member variables in the file. Based on what we have already discussed, see whether you can work out what each of them will do. We will go through them individually in a moment:</p>
			<p class="source-code">class Player</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">private:</strong></p>
			<p class="source-code"><strong class="bold">    const float START_SPEED = 200;</strong></p>
			<p class="source-code"><strong class="bold">    const float START_HEALTH = 100;</strong></p>
			<p class="source-code"><strong class="bold">    // Where is the player</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f m_Position;</strong></p>
			<p class="source-code"><strong class="bold">    // Of course, we will need a sprite</strong></p>
			<p class="source-code"><strong class="bold">    Sprite m_Sprite;</strong></p>
			<p class="source-code"><strong class="bold">    // And a texture</strong></p>
			<p class="source-code"><strong class="bold">    // !!Watch this space – Interesting changes here soon!!</strong></p>
			<p class="source-code"><strong class="bold">    Texture m_Texture;</strong></p>
			<p class="source-code"><strong class="bold">    // What is the screen resolution</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f m_Resolution;</strong></p>
			<p class="source-code"><strong class="bold">    // What size is the current arena</strong></p>
			<p class="source-code"><strong class="bold">    IntRect m_Arena;</strong></p>
			<p class="source-code"><strong class="bold">    // How big is each tile of the arena</strong></p>
			<p class="source-code"><strong class="bold">    int m_TileSize;</strong></p>
			<p class="source-code"><strong class="bold">    // Which direction(s) is the player currently moving in</strong></p>
			<p class="source-code"><strong class="bold">    bool m_UpPressed;</strong></p>
			<p class="source-code"><strong class="bold">    bool m_DownPressed;</strong></p>
			<p class="source-code"><strong class="bold">    bool m_LeftPressed;</strong></p>
			<p class="source-code"><strong class="bold">    bool m_RightPressed;</strong></p>
			<p class="source-code"><strong class="bold">    // How much health has the player got?</strong></p>
			<p class="source-code"><strong class="bold">    int m_Health;</strong></p>
			<p class="source-code"><strong class="bold">    // What is the maximum health the player can have</strong></p>
			<p class="source-code"><strong class="bold">    int m_MaxHealth;</strong></p>
			<p class="source-code"><strong class="bold">    // When was the player last hit</strong></p>
			<p class="source-code"><strong class="bold">    Time m_LastHit;</strong></p>
			<p class="source-code"><strong class="bold">    // Speed in pixels per second</strong></p>
			<p class="source-code"><strong class="bold">    float m_Speed;</strong></p>
			<p class="source-code"><strong class="bold">// All our public functions will come next</strong></p>
			<p class="source-code">};</p>
			<p>The previous code declares all our member variables. Some are regular variables, while some of them are objects. Notice that they are all under the <strong class="source-inline">private:</strong> section of the class and, therefore, are not directly accessible from outside the class.</p>
			<p>Also, notice that we are using the naming convention of prefixing <strong class="source-inline">m_</strong> to all the names of the non-constant variables. The <strong class="source-inline">m_</strong> prefix will remind us, while coding the function definitions, that they are member variables, are distinct from the local variables we will create in some of the functions, and are also distinct from the function parameters. </p>
			<p>All the variables that are used are straightforward, such as <strong class="source-inline">m_Position</strong>, <strong class="source-inline">m_Texture</strong>, and <strong class="source-inline">m_Sprite</strong>, which are for the current location, texture, and sprite of the player, respectively. In addition to this, each variable (or group of variables) is commented to make its usage plain.</p>
			<p>However, why exactly they are needed, and the context they will be used in, might not be so obvious. For example, <strong class="source-inline">m_LastHit</strong>, which is an object of the <strong class="source-inline">Time</strong> type, is for recording the time that the player last received a hit from a zombie. It is not obvious <em class="italic">why</em> we might need this information, but we will go over this soon.</p>
			<p>As we piece the rest of the game together, the context for each of the variables will become clearer. The important thing, for now, is to familiarize yourself with the names and data types to make following along with the rest of the project trouble-free.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You don't need to memorize the variable names and types as we will discuss all the code when they are used. You do, however, need to take your time to look over them and get more familiar with them. Furthermore, as we proceed, it might be worth referring to this header file if anything seems unclear.</p>
			<p>Now, we can add a complete long list of functions. Add the following highlighted code and see whether you can work out what it all does. Pay close attention to the return types, parameters, and the name of each function. This is key to understanding the code we will write throughout the rest of this project. What do they tell us about each function? Add the following highlighted code and then we will examine it:</p>
			<p class="source-code">// All our public functions will come next</p>
			<p class="source-code"><strong class="bold">public:</strong></p>
			<p class="source-code"><strong class="bold">    Player();</strong></p>
			<p class="source-code"><strong class="bold">    void spawn(IntRect arena, Vector2f resolution, int tileSize);</strong></p>
			<p class="source-code"><strong class="bold">    // Call this at the end of every game</strong></p>
			<p class="source-code"><strong class="bold">    void resetPlayerStats();</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    // Handle the player getting hit by a zombie</strong></p>
			<p class="source-code"><strong class="bold">    bool hit(Time timeHit);</strong></p>
			<p class="source-code"><strong class="bold">    // How long ago was the player last hit</strong></p>
			<p class="source-code"><strong class="bold">    Time getLastHitTime();</strong></p>
			<p class="source-code"><strong class="bold">    // Where is the player</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect getPosition();</strong></p>
			<p class="source-code"><strong class="bold">    // Where is the center of the player</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f getCenter();</strong></p>
			<p class="source-code"><strong class="bold">    // What angle is the player facing</strong></p>
			<p class="source-code"><strong class="bold">    float getRotation();</strong></p>
			<p class="source-code"><strong class="bold">    // Send a copy of the sprite to the main function</strong></p>
			<p class="source-code"><strong class="bold">    Sprite getSprite();</strong></p>
			<p class="source-code"><strong class="bold">    // The next four functions move the player</strong></p>
			<p class="source-code"><strong class="bold">    void moveLeft();</strong></p>
			<p class="source-code"><strong class="bold">    void moveRight();</strong></p>
			<p class="source-code"><strong class="bold">    void moveUp();</strong></p>
			<p class="source-code"><strong class="bold">    void moveDown();</strong></p>
			<p class="source-code"><strong class="bold">    // Stop the player moving in a specific direction</strong></p>
			<p class="source-code"><strong class="bold">    void stopLeft();</strong></p>
			<p class="source-code"><strong class="bold">    void stopRight();</strong></p>
			<p class="source-code"><strong class="bold">    void stopUp();</strong></p>
			<p class="source-code"><strong class="bold">    void stopDown();</strong></p>
			<p class="source-code"><strong class="bold">    // We will call this function once every frame</strong></p>
			<p class="source-code"><strong class="bold">    void update(float elapsedTime, Vector2i mousePosition);</strong></p>
			<p class="source-code"><strong class="bold">    // Give the player a speed boost</strong></p>
			<p class="source-code"><strong class="bold">    void upgradeSpeed();</strong></p>
			<p class="source-code"><strong class="bold">    // Give the player some health</strong></p>
			<p class="source-code"><strong class="bold">    void upgradeHealth();</strong></p>
			<p class="source-code"><strong class="bold">    // Increase the maximum amount of health the player can have</strong></p>
			<p class="source-code"><strong class="bold">    void increaseHealthLevel(int amount);</strong></p>
			<p class="source-code"><strong class="bold">    // How much health has the player currently got?</strong></p>
			<p class="source-code"><strong class="bold">    int getHealth();</strong></p>
			<p class="source-code"><strong class="bold">};</strong></p>
			<p>Firstly, note that all the functions are public. This means we can call all of these functions using an instance of the class from the <strong class="source-inline">main</strong> function with code like this:</p>
			<p class="source-code"><strong class="source-inline">player.getSprite();</strong></p>
			<p>Assuming <strong class="source-inline">player</strong> is a fully set up instance of the <strong class="source-inline">Player</strong> class, the previous code will return a copy of <strong class="source-inline">m_Sprite</strong>. Putting this code into a real context, we could, in the <strong class="source-inline">main</strong> function, write code like this:</p>
			<p class="source-code">window.draw(player.getSprite());</p>
			<p>The previous code would draw the player graphic in its correct location, just as if the sprite was declared in the <strong class="source-inline">main</strong> function itself. This is what we did with the <strong class="source-inline">Bat</strong> class in the Pong project.</p>
			<p>Before we move on to implement (that is, write the definitions) of these functions in a corresponding <strong class="source-inline">.cpp</strong> file, let's take a closer look at each of them in turn:</p>
			<ul>
				<li><strong class="source-inline">void spawn(IntRect arena, Vector2f resolution, int tileSize)</strong>: This function does what its name suggests. It will prepare the object ready for use, which includes putting it in its starting location (that is, spawning it). Notice that it doesn't return any data, but it does have three arguments. It receives an <strong class="source-inline">IntRect</strong> instance called <strong class="source-inline">arena</strong>, which will be the size and location of the current level; a <strong class="source-inline">Vector2f</strong> instance, which will contain the screen resolution; and an <strong class="source-inline">int</strong>, which will hold the size of a background tile.</li>
				<li><strong class="source-inline">void resetPlayerStats</strong>: Once we give the player the ability to level up between waves, we will need to be able to take away/reset those abilities at the start of a new game.</li>
				<li><strong class="source-inline">Time getLastHitTime()</strong>: This function does just one thing – it returns the time when the player was last hit by a zombie. We will use this function when detecting collisions, and it will allow us to make sure the player isn't punished <em class="italic">too</em> frequently for making contact with a zombie.</li>
				<li><strong class="source-inline">FloatRect getPosition()</strong>: This function returns a <strong class="source-inline">FloatRect</strong> instance that describes the horizontal and vertical floating-point coordinates of the rectangle, which contains the player graphic. This is also useful for collision detection.</li>
				<li><strong class="source-inline">Vector2f getCenter()</strong>: This is slightly different to <strong class="source-inline">getPosition</strong> because it is a <strong class="source-inline">Vector2f</strong> type and contains just the <em class="italic">x</em> and <em class="italic">y</em> locations of the very center of the player graphic.</li>
				<li><strong class="source-inline">float getRotation()</strong>: The code in the <strong class="source-inline">main</strong> function will sometimes need to know, in degrees, which way the player is currently facing. 3 o'clock is 0 degrees and increases clockwise.</li>
				<li><strong class="source-inline">Sprite getSprite()</strong>: As we discussed previously, this function returns a copy of the sprite that represents the player.</li>
				<li><strong class="source-inline">void moveLeft()</strong>, <strong class="source-inline">..Right()</strong>, <strong class="source-inline">..Up()</strong>, <strong class="source-inline">..Down()</strong>: These four functions have no return type or parameters. They will be called from the <strong class="source-inline">main</strong> function and the <strong class="source-inline">Player</strong> class will then be able to act when one or more of the <em class="italic">WASD</em> keys have been pressed.</li>
				<li><strong class="source-inline">void stopLeft()</strong>, <strong class="source-inline">..Right()</strong>, <strong class="source-inline">..Up()</strong>, <strong class="source-inline">..Down()</strong>: These four functions have no return type or parameters. They will be called from the <strong class="source-inline">main</strong> function, and the <strong class="source-inline">Player</strong> class will then be able to act when one or more of the <em class="italic">WASD</em> keys have been released.</li>
				<li><strong class="source-inline">void update(float elapsedTime, Vector2i mousePosition)</strong>: This will be the only long function of the entire class. It will be called once per frame from <strong class="source-inline">main</strong>. It will do everything necessary to make sure the <strong class="source-inline">player</strong> object's data is updated so that it's ready for collision detection and drawing. Notice that it returns no data but receives the amount of elapsed time since the last frame, along with a <strong class="source-inline">Vector2i</strong> instance, which will hold the horizontal and vertical screen location of the mouse pointer/crosshair. <p class="callout-heading">Important note</p><p class="callout">Note that these are integer screen coordinates and are distinct from the floating-point world coordinates.</p></li>
				<li><strong class="source-inline">void upgradeSpeed()</strong>: A function that can be called from the leveling up screen when the player chooses to make the player faster.</li>
				<li><strong class="source-inline">void upgradeHealth()</strong>: Another function that can be called from the leveling up screen when the player chooses to make the player stronger (that is, have more health).</li>
				<li><strong class="source-inline">void increaseHealthLevel(int amount)</strong>: A subtle but important difference regarding the previous function in that this one will increase the amount of health the player has, up to the maximum that's currently set. This function will be used when the player picks up a health pick-up.</li>
				<li><strong class="source-inline">int getHealth()</strong>: With the level of health being as dynamic as it is, we need to be able to determine how much health the player has at any given moment. This function returns an <strong class="source-inline">int</strong>, which holds that value. </li>
			</ul>
			<p>Like the variables, it should now be plain what each of the functions is for. Also the <em class="italic">why</em> and the precise context of using some of these functions will only reveal themselves as we progress with the project.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You don't need to memorize the function names, return types, or parameters as we will discuss the code when they are used. You do, however, need to take your time to look over them, along with the previous explanations, and get more familiar with them. Furthermore, as we proceed, it might be worth referring to this header file if anything seems unclear.</p>
			<p>Now, we can move on to the meat of our functions: the definitions.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Coding the Player class function definitions</h2>
			<p>Finally, we can begin writing the code that does the work of our class.</p>
			<p><em class="italic">Right-click</em> on <strong class="bold">Source Files</strong> in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by <em class="italic">left-clicking </em>on) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Player.cpp</strong>. Finally, click on the <strong class="bold">Add</strong> button. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">From now on, I will simply ask you to create a new class or header file. So, commit the preceding step to memory or refer back here if you need a reminder.</p>
			<p>We are now ready to code the <strong class="source-inline">.cpp</strong> file for our first class in this project.</p>
			<p>Here are the necessary include directives, followed by the definition of the constructor. Remember, the constructor will be called when we first instantiate an object of the <strong class="source-inline">Player</strong> type. Add the following code to the <strong class="source-inline">Player.cpp</strong> file and then we can take a closer look at it:</p>
			<p class="source-code">#include "player.h"</p>
			<p class="source-code">Player::Player()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Speed = START_SPEED;</p>
			<p class="source-code">    m_Health = START_HEALTH;</p>
			<p class="source-code">    m_MaxHealth = START_HEALTH;</p>
			<p class="source-code">    // Associate a texture with the sprite</p>
			<p class="source-code">    // !!Watch this space!!</p>
			<p class="source-code">    m_Texture.loadFromFile("graphics/player.png");</p>
			<p class="source-code">    m_Sprite.setTexture(m_Texture);</p>
			<p class="source-code">    // Set the origin of the sprite to the center, </p>
			<p class="source-code">    // for smooth rotation</p>
			<p class="source-code">    m_Sprite.setOrigin(25, 25);</p>
			<p class="source-code">}</p>
			<p>In the constructor function, which, of course, has the same name as the class and no return type, we write code that begins to set up the <strong class="source-inline">Player</strong> object, ready for use.</p>
			<p>To be clear; this code will run when we write the following code from the <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">Player player;</p>
			<p>Don't add the previous line of code just yet.</p>
			<p>All we do in the constructor is initialize <strong class="source-inline">m_Speed</strong>, <strong class="source-inline">m_Health</strong>, and <strong class="source-inline">m_MaxHealth</strong> from their related constants. Then, we load the player graphic into <strong class="source-inline">m_Texture</strong>, associate <strong class="source-inline">m_Texture</strong> with <strong class="source-inline">m_Sprite</strong>, and set the origin of <strong class="source-inline">m_Sprite</strong> to the center, <strong class="source-inline">(25, 25)</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note the cryptic comment, <strong class="source-inline">// !!Watch this space!!</strong>, indicating that we will return to the loading of our texture and some important issues regarding it. We will eventually change how we deal with this texture once we have discovered a problem and learned a bit more C++. We will do so in <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a><em class="italic">, Pointers, the Standard Template Library, and Texture Management</em>.</p>
			<p>Next, we will code the <strong class="source-inline">spawn</strong> function. We will only ever create one instance of the <strong class="source-inline">Player</strong> class. We will, however, need to spawn it into the current level for each wave. This is what the <strong class="source-inline">spawn</strong> function will handle for us. Add the following code to the <strong class="source-inline">Player.cpp</strong> file and be sure to examine the details and read the comments:</p>
			<p class="source-code">void Player::spawn(IntRect arena, </p>
			<p class="source-code">        Vector2f resolution, </p>
			<p class="source-code">        int tileSize)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Place the player in the middle of the arena</p>
			<p class="source-code">    m_Position.x = arena.width / 2;</p>
			<p class="source-code">    m_Position.y = arena.height / 2;</p>
			<p class="source-code">    // Copy the details of the arena </p>
			<p class="source-code">    // to the player's m_Arena</p>
			<p class="source-code">    m_Arena.left = arena.left;</p>
			<p class="source-code">    m_Arena.width = arena.width;</p>
			<p class="source-code">    m_Arena.top = arena.top;</p>
			<p class="source-code">    m_Arena.height = arena.height;</p>
			<p class="source-code">    // Remember how big the tiles are in this arena</p>
			<p class="source-code">    m_TileSize = tileSize;</p>
			<p class="source-code">    // Store the resolution for future use</p>
			<p class="source-code">    m_Resolution.x = resolution.x;</p>
			<p class="source-code">    m_Resolution.y = resolution.y;</p>
			<p class="source-code">}</p>
			<p>The preceding code starts off by initializing the <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong> values to half the height and width of the passed in <strong class="source-inline">arena</strong>. This has the effect of moving the player to the center of the level, regardless of its size.</p>
			<p>Next, we copy all the coordinates and dimensions of the passed in <strong class="source-inline">arena</strong> to the member object of the same type, <strong class="source-inline">m_Arena</strong>. The details of the size and coordinates of the current arena are used so frequently that it makes sense to do this. We can now use <strong class="source-inline">m_Arena</strong> for tasks such as making sure the player can't walk through walls. In addition to this, we copy the passed in <strong class="source-inline">tileSize</strong> instance to the member variable, <strong class="source-inline">m_TileSize</strong>, for the same purpose. We will see <strong class="source-inline">m_Arena</strong> and <strong class="source-inline">m_TileSize</strong> in action in the <strong class="source-inline">update</strong> function.</p>
			<p>The final two lines from the preceding code copy the screen resolution from the <strong class="source-inline">Vector2f</strong>,<strong class="source-inline"> resolution</strong>, which is a parameter of <strong class="source-inline">spawn</strong>, into <strong class="source-inline">m_Resolution</strong>, which is a member variable of <strong class="source-inline">Player</strong>. We now have access to these values inside the <strong class="source-inline">Player</strong> class.</p>
			<p>Now, add the very straightforward code of the <strong class="source-inline">resetPlayerStats</strong> function: </p>
			<p class="source-code">void Player::resetPlayerStats()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Speed = START_SPEED;</p>
			<p class="source-code">    m_Health = START_HEALTH;</p>
			<p class="source-code">    m_MaxHealth = START_HEALTH;</p>
			<p class="source-code">}</p>
			<p>When the player dies, we will use this to reset any upgrades they might have used.</p>
			<p>We will not write the code that calls the <strong class="source-inline">resetPlayerStats</strong> function until nearly completing the project, but it is there ready for when we need it.</p>
			<p>In the next part of the code, we will add two more functions. They will handle what happens when the player is hit by a zombie. We will be able to call <strong class="source-inline">player.hit()</strong> and pass in the current game time. We will also be able to query the last time that the player was hit by calling <strong class="source-inline">player.getLastHitTime()</strong>. Exactly how these functions are useful will become apparent when we have some zombies.</p>
			<p>Add the two new definitions to the <strong class="source-inline">Player.cpp</strong> file and then examine the C++ code a little more closely:</p>
			<p class="source-code">Time Player::getLastHitTime()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LastHit;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool Player::hit(Time timeHit)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (timeHit.asMilliseconds() </p>
			<p class="source-code">        - m_LastHit.asMilliseconds() &gt; 200)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LastHit = timeHit;</p>
			<p class="source-code">        m_Health -= 10;</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The code for <strong class="source-inline">getLastHitTime()</strong> is very straightforward; it will return whatever value is stored in <strong class="source-inline">m_LastHit</strong>. </p>
			<p>The <strong class="source-inline">hit</strong> function is a bit more in-depth and nuanced. First, the <strong class="source-inline">if</strong> statement checks to see whether the time that's passed in as a parameter is 200 milliseconds further ahead than the time stored in <strong class="source-inline">m_LastHit</strong>. If it is, <strong class="source-inline">m_LastHit</strong> is updated with the time passed in and <strong class="source-inline">m_Health</strong> has 10 deducted from its current value. The last line of code in this <strong class="source-inline">if</strong> statement is <strong class="source-inline">return true</strong>. Notice that the <strong class="source-inline">else</strong> clause simply returns <strong class="source-inline">false</strong> to the calling code.</p>
			<p>The overall effect of this function is that health points will only be deducted from the player up to five times per second. Remember that our game loop might be running at thousands of iterations per second. In this scenario, without the restriction this function provides, a zombie would only need to be in contact with the player for one second and tens of thousands of health points would be deducted. The <strong class="source-inline">hit</strong> function controls and restricts this phenomenon. It also lets the calling code know whether a new hit has been registered (or not) by returning <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>.</p>
			<p>This code implies that we will detect collisions between a zombie and the player in the <strong class="source-inline">main</strong> function. We will then call <strong class="source-inline">player.hit()</strong> to determine whether to deduct any health points.</p>
			<p>Next, for the <strong class="source-inline">Player</strong> class, we will implement a bunch of getter functions. They allow us to keep the data neatly encapsulated in the <strong class="source-inline">Player</strong> class, at the same time as making their values available to the <strong class="source-inline">main</strong> function.</p>
			<p>Add the following code, right after the previous block:</p>
			<p class="source-code">FloatRect Player::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f Player::getCenter()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Position;</p>
			<p class="source-code">}</p>
			<p class="source-code">float Player::getRotation()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite.getRotation();</p>
			<p class="source-code">}</p>
			<p class="source-code">Sprite Player::getSprite()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite;</p>
			<p class="source-code">}</p>
			<p class="source-code">int Player::getHealth()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Health;</p>
			<p class="source-code">}</p>
			<p>The previous code is very straightforward. Each one of the previous five functions returns the value of one of our member variables. Look carefully at each of them and familiarize yourself with which function returns which value.</p>
			<p>The next eight short functions enable the keyboard controls (which we will use from the <strong class="source-inline">main</strong> function) so that we can change the data contained in our object of the <strong class="source-inline">Player</strong> type. Add the following code to the <strong class="source-inline">Player.cpp</strong> file and then we will summarize how it all works:</p>
			<p class="source-code">void Player::moveLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LeftPressed = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::moveRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_RightPressed = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::moveUp()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_UpPressed = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::moveDown()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_DownPressed = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::stopLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LeftPressed = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::stopRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_RightPressed = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::stopUp()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_UpPressed = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::stopDown()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_DownPressed = false;</p>
			<p class="source-code">}</p>
			<p>The previous code has four functions (<strong class="source-inline">moveLeft</strong>, <strong class="source-inline">moveRight</strong>, <strong class="source-inline">moveUp</strong>, and <strong class="source-inline">moveDown</strong>), which set the related Boolean variables (<strong class="source-inline">m_LeftPressed</strong>, <strong class="source-inline">m_RightPressed</strong>, <strong class="source-inline">m_UpPressed</strong>, and <strong class="source-inline">m_DownPressed</strong>) to <strong class="source-inline">true</strong>. The other four functions (<strong class="source-inline">stopLeft</strong>, <strong class="source-inline">stopRight</strong>, <strong class="source-inline">stopUp</strong>, and <strong class="source-inline">stopDown</strong>) do the opposite and set the same Boolean variables to <strong class="source-inline">false</strong>. The instance of the <strong class="source-inline">Player</strong> class can now be kept informed of which of the <em class="italic">WASD</em> keys were pressed and which were not.</p>
			<p>The following function is the one that does all the hard work. The <strong class="source-inline">update</strong> function will be called once in every single frame of our game loop. Add the following code, and then we will examine it in detail. If we followed along with the previous eight functions and we remember how we animated the clouds and bees for the Timber!!! project and the bat and ball for Pong, we will probably understand most of the following code:</p>
			<p class="source-code">void Player::update(float elapsedTime, Vector2i mousePosition)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_UpPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y -= m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_DownPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y += m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_RightPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x += m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_LeftPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x -= m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">    // Keep the player in the arena</p>
			<p class="source-code">    if (m_Position.x &gt; m_Arena.width - m_TileSize)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x = m_Arena.width - m_TileSize;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Position.x &lt; m_Arena.left + m_TileSize)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x = m_Arena.left + m_TileSize;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Position.y &gt; m_Arena.height - m_TileSize)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y = m_Arena.height - m_TileSize;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Position.y &lt; m_Arena.top + m_TileSize)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y = m_Arena.top + m_TileSize;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Calculate the angle the player is facing</p>
			<p class="source-code">    float angle = (atan2(mousePosition.y - m_Resolution.y / 2,</p>
			<p class="source-code">        mousePosition.x - m_Resolution.x / 2)</p>
			<p class="source-code">        * 180) / 3.141;</p>
			<p class="source-code">    m_Sprite.setRotation(angle);</p>
			<p class="source-code">}</p>
			<p>The first portion of the previous code moves the player sprite. The four <strong class="source-inline">if</strong> statements check which of the movement-related Boolean variables (<strong class="source-inline">m_LeftPressed</strong>, <strong class="source-inline">m_RightPressed</strong>, <strong class="source-inline">m_UpPressed</strong>, or <strong class="source-inline">m_DownPressed</strong>) are true and changes <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong> accordingly. The same formula, from the previous two projects, to calculate the amount to move is also used: </p>
			<p><strong class="bold">position (+ or -) speed * elapsed time.</strong></p>
			<p>After these four <strong class="source-inline">if</strong> statements, <strong class="source-inline">m_Sprite.setPosition</strong> is called and <strong class="source-inline">m_Position</strong> is passed in. The sprite has now been adjusted by exactly the right amount for that one frame.</p>
			<p>The next four <strong class="source-inline">if</strong> statements check whether <strong class="source-inline">m_Position.x</strong> or <strong class="source-inline">m_Position.y</strong> is beyond any of the edges of the current arena. Remember that the confines of the current arena were stored in <strong class="source-inline">m_Arena</strong>, in the <strong class="source-inline">spawn</strong> function. Let's look at the first one of these four <strong class="source-inline">if</strong> statements in order to understand them all:</p>
			<p class="source-code">if (m_Position.x &gt; m_Arena.width - m_TileSize)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.x = m_Arena.width - m_TileSize;</p>
			<p class="source-code">}</p>
			<p>The previous code tests to see whether <strong class="source-inline">m_position.x</strong> is greater than <strong class="source-inline">m_Arena.width</strong>, minus the size of a tile (<strong class="source-inline">m_TileSize</strong>). As we will see when we create the background graphics, this calculation will detect the player straying into the wall.</p>
			<p>When the <strong class="source-inline">if</strong> statement is true, the <strong class="source-inline">m_Arena.width - m_TileSize</strong> calculation is used to initialize <strong class="source-inline">m_Position.x</strong>. This means that the center of the player graphic will never be able to stray past the left-hand edge of the right-hand wall.</p>
			<p>The next three <strong class="source-inline">if</strong> statements, which follow the one we have just discussed, do the same thing but for the other three walls.</p>
			<p>The last two lines in the preceding code calculate and set the angle that the player sprite is rotated to (that is, facing). This line of code might look a little complex, but it is simply using the position of the crosshair (<strong class="source-inline">mousePosition.x</strong> and <strong class="source-inline">mousePosition.y</strong>) and the center of the screen (<strong class="source-inline">m_Resolution.x</strong> and <strong class="source-inline">m_Resolution.y</strong>) in a tried-and-tested trigonometric function. </p>
			<p>How <strong class="source-inline">atan</strong> uses these coordinates along with Pi (3.141) is quite complicated, and that is why it is wrapped up in a handy function for us. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you want to explore trigonometric functions in more detail, you can do so here: <a href="http://www.cplusplus.com/reference/cmath/">http://www.cplusplus.com/reference/cmath/</a>.</p>
			<p>The last three functions we will add for the <strong class="source-inline">Player</strong> class make the player 20% faster, increase the player's health by 20%, and increase the player's health by the amount passed in, respectively.</p>
			<p>Add the following code at the end of the <strong class="source-inline">Player.cpp</strong> file, and then we will take a closer look at it:</p>
			<p class="source-code">void Player::upgradeSpeed()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // 20% speed upgrade</p>
			<p class="source-code">    m_Speed += (START_SPEED * .2);</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::upgradeHealth()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // 20% max health upgrade</p>
			<p class="source-code">    m_MaxHealth += (START_HEALTH * .2);</p>
			<p class="source-code">}</p>
			<p class="source-code">void Player::increaseHealthLevel(int amount)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Health += amount;</p>
			<p class="source-code">    // But not beyond the maximum</p>
			<p class="source-code">    if (m_Health &gt; m_MaxHealth)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Health = m_MaxHealth;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">upgradeSpeed()</strong> and <strong class="source-inline">upgradeHealth()</strong> functions increase the value stored in <strong class="source-inline">m_Speed</strong> and <strong class="source-inline">m_MaxHealth</strong>, respectively. These values are increased by 20% by multiplying the starting values by .2 and adding them to the current values. These functions will be called from the <strong class="source-inline">main</strong> function when the player is choosing what attributes of their character they wish to improve (that is, level up) between levels.</p>
			<p>The <strong class="source-inline">increaseHealthLevel()</strong> function takes an <strong class="source-inline">int</strong> value from <strong class="source-inline">main</strong> in the <strong class="source-inline">amount</strong> parameter. This <strong class="source-inline">int</strong> value will be provided by a class called <strong class="source-inline">Pickup</strong>, which we will write in <a href="B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249"><em class="italic">Chapter 11</em></a><em class="italic">, Collision Detection, Pickups, and Bullets</em>. The <strong class="source-inline">m_Health</strong> member variable is increased by the passed-in value. However, there is a catch for the player. The <strong class="source-inline">if</strong> statement checks whether <strong class="source-inline">m_Health</strong> has exceeded <strong class="source-inline">m_MaxHealth</strong> and, if it has, sets it to <strong class="source-inline">m_MaxHealth</strong>. This means the player cannot simply gain infinite health from pick-ups. Instead, they must carefully balance the upgrades they choose between levels.</p>
			<p>Of course, our <strong class="source-inline">Player</strong> class can't do anything until we instantiate it and put it to work in our game loop. Before we do that, let's look at the concept of a game camera.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Controlling the game camera with SFML View</h1>
			<p>In my opinion, the SFML <strong class="source-inline">View</strong> class is one of the neatest classes. After finishing this book, when we make games without using a media/gaming library, we will really notice the absence of <strong class="source-inline">View</strong>. </p>
			<p>The <strong class="source-inline">View</strong> class allows us to consider our game as taking place in its own world, with its own properties. What do I mean? Well, when we create a game, we are usually trying to create a virtual world. That virtual world rarely, if ever, is measured in pixels, and rarely, if ever, will that world be the same number of pixels as the player's monitor. We need a way to abstract the virtual world we are building so that it can be of whatever size or shape we like.</p>
			<p>Another way to think of SFML <strong class="source-inline">View</strong> is as a camera through which the player views a part of our virtual world. Most games will have more than one camera/view of the world.</p>
			<p>For example, consider a split screen game where two players can be in different parts of the world at the same time.</p>
			<p>Or, consider a game where there is a small area of the screen that represents the entire game world, but at a very high level/zoomed out, like a mini map.</p>
			<p>Even if our games are much simpler than the previous two examples and don't need split screens or mini maps, we will likely want to create a world that is bigger than the screen it is being played on. This is, of course, the case with Zombie Arena.</p>
			<p>Additionally, if we are constantly moving the game camera around to show different parts of the virtual world (usually to track the player), what happens to the HUD? If we draw the score and other onscreen HUD information and then we scroll the world around to follow the player, the score would move relative to that camera.</p>
			<p>The SFML <strong class="source-inline">View</strong> class easily enables all these of features and solves this problem with very straightforward code. The trick is to create an instance of <strong class="source-inline">View</strong> for every camera – perhaps a <strong class="source-inline">View</strong> instance for the mini map, a <strong class="source-inline">View</strong> instance for the scrolling game world, and then a <strong class="source-inline">View</strong> instance for the HUD.</p>
			<p>The instances of <strong class="source-inline">View</strong> can be moved around, sized, and positioned as required. So, the main <strong class="source-inline">View</strong> instance following the game can track the player, the mini-map view can remain in a fixed, zoomed-out small corner of the screen, and the HUD can overlay the entire screen and never move, despite the fact the main <strong class="source-inline">View</strong> instance could go wherever the player goes. </p>
			<p>Let's look at some code using a few instances of <strong class="source-inline">View</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This code is being used to introduce the <strong class="source-inline">View</strong> class. Don't add this code to the Zombie Arena project.</p>
			<p>Create and initialize a few instances of <strong class="source-inline">View</strong>:</p>
			<p class="source-code">// Create a view to fill a 1920 x 1080 monitor</p>
			<p class="source-code">View mainView(sf::FloatRect(0, 0, 1920, 1080));</p>
			<p class="source-code">// Create a view for the HUD</p>
			<p class="source-code">View hudView(sf::FloatRect(0, 0, 1920, 1080));</p>
			<p>The previous code creates two <strong class="source-inline">View</strong> objects that fill a 1920 x 1080 monitor. Now, we can do some magic with <strong class="source-inline">mainView</strong> while leaving <strong class="source-inline">hudView</strong> completely alone:</p>
			<p class="source-code">// In the update part of the game</p>
			<p class="source-code">// There are lots of things you can do with a View</p>
			<p class="source-code">// Make the view centre around the player                </p>
			<p class="source-code">mainView.setCenter(player.getCenter());</p>
			<p class="source-code">// Rotate the view 45 degrees</p>
			<p class="source-code">mainView.rotate(45)</p>
			<p class="source-code">// Note that hudView is totally unaffected by the previous code</p>
			<p>When we manipulate the properties of a <strong class="source-inline">View</strong> instance, we do so like this. When we draw sprites, text, or other objects to a view, we must specifically <strong class="bold">set</strong> the view as the current view for the window:</p>
			<p class="source-code">// Set the current view</p>
			<p class="source-code">window.setView(mainView);</p>
			<p>Now, we can draw everything we want into that view:</p>
			<p class="source-code">// Do all the drawing for this view</p>
			<p class="source-code">window.draw(playerSprite);</p>
			<p class="source-code">window.draw(otherGameObject);</p>
			<p class="source-code">// etc</p>
			<p>The player might be at any coordinate whatsoever; it doesn't matter because <strong class="source-inline">mainView</strong> is centered around the graphic.</p>
			<p>Now, we can draw the HUD into <strong class="source-inline">hudView</strong>. Note that just like we draw individual elements (background, game objects, text, and so on) in layers from back to front, we also draw views from back to front as well. Hence, a HUD is drawn after the main game scene:</p>
			<p class="source-code">// Switch to the hudView</p>
			<p class="source-code">window.setView(hudView);</p>
			<p class="source-code">// Do all the drawing for the HUD</p>
			<p class="source-code">window.draw(scoreText);</p>
			<p class="source-code">window.draw(healthBar);</p>
			<p class="source-code">// etc</p>
			<p>Finally, we can draw/show the window and all its views for the current frame in the usual way:</p>
			<p class="source-code">window.display();</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to take your understanding of SFML <strong class="source-inline">View</strong> further than is necessary for this project, including how to achieve split screens and mini maps, then the best guide on the web is on the official SFML website: <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-view.php">https://www.sfml-dev.org/tutorials/2.5/graphics-view.php</a>.</p>
			<p>Now that we have learned about <strong class="source-inline">View</strong>, we can start coding the Zombie Arena <strong class="source-inline">main</strong> function and use our first <strong class="source-inline">View</strong> instance for real. In <a href="B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 12</em></a>,<em class="italic"> Layering Views and Implementing the HUD</em>, we will introduce a second instance of <strong class="source-inline">View</strong> for the HUD and layer it over the top of the main <strong class="source-inline">View</strong> instance.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor194"/>Starting the Zombie Arena game engine</h1>
			<p>In this game, we will need a slightly upgraded game engine in <strong class="source-inline">main</strong>. We will have an enumeration called <strong class="source-inline">state</strong>, which will track what the current state of the game is. Then, throughout <strong class="source-inline">main</strong>, we can wrap parts of our code so that different things happen in different states.</p>
			<p>When we created the project, Visual Studio created a file for us called <strong class="source-inline">ZombieArena.cpp</strong>. This will be the file that contains our <strong class="source-inline">main</strong> function and the code that instantiates and controls all our classes.</p>
			<p>We begin with the now-familiar <strong class="source-inline">main</strong> function and some include directives. Note the addition of an include directive for the <strong class="source-inline">Player</strong> class.</p>
			<p>Add the following code to the <strong class="source-inline">ZombieArena.cpp</strong> file:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "Player.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>The previous code has nothing new in it except that the <strong class="source-inline">#include "Player.h"</strong> line means we can now use the <strong class="source-inline">Player</strong> class within our code.</p>
			<p>Let's flesh out some more of our game engine. The following code does quite a lot. Be sure to read the comments when you add the code to get an idea of what is going on. We will then go through it in more detail.</p>
			<p>Add the following highlighted code at the start of the <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    // The game will always be in one of four states</strong></p>
			<p class="source-code"><strong class="bold">    enum class State { PAUSED, LEVELING_UP, </strong></p>
			<p class="source-code"><strong class="bold">            GAME_OVER, PLAYING };</strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">    // Start with the GAME_OVER state</strong></p>
			<p class="source-code"><strong class="bold">    State state = State::GAME_OVER;</strong></p>
			<p class="source-code"><strong class="bold">    // Get the screen resolution and </strong></p>
			<p class="source-code"><strong class="bold">    // create an SFML window</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f resolution;</strong></p>
			<p class="source-code"><strong class="bold">    resolution.x = </strong></p>
			<p class="source-code"><strong class="bold">        VideoMode::getDesktopMode().width;</strong></p>
			<p class="source-code"><strong class="bold">    resolution.y = </strong></p>
			<p class="source-code"><strong class="bold">        VideoMode::getDesktopMode().height;</strong></p>
			<p class="source-code"><strong class="bold">    RenderWindow window(</strong></p>
			<p class="source-code"><strong class="bold">        VideoMode(resolution.x, resolution.y), </strong></p>
			<p class="source-code"><strong class="bold">        "Zombie Arena", Style::Fullscreen);</strong></p>
			<p class="source-code"><strong class="bold">    // Create a an SFML View for the main action</strong></p>
			<p class="source-code"><strong class="bold">    View mainView(sf::FloatRect(0, 0, </strong></p>
			<p class="source-code"><strong class="bold">            resolution.x, resolution.y));</strong></p>
			<p class="source-code"><strong class="bold">    // Here is our clock for timing everything</strong></p>
			<p class="source-code"><strong class="bold">    Clock clock;</strong></p>
			<p class="source-code"><strong class="bold">    // How long has the PLAYING state been active</strong></p>
			<p class="source-code"><strong class="bold">    Time gameTimeTotal;</strong></p>
			<p class="source-code"><strong class="bold">    // Where is the mouse in </strong></p>
			<p class="source-code"><strong class="bold">    // relation to world coordinates</strong></p>
			<p class="source-code"><strong class="bold">    Vector2f mouseWorldPosition;</strong></p>
			<p class="source-code"><strong class="bold">    // Where is the mouse in </strong></p>
			<p class="source-code"><strong class="bold">    // relation to screen coordinates</strong></p>
			<p class="source-code"><strong class="bold">    Vector2i mouseScreenPosition;</strong></p>
			<p class="source-code"><strong class="bold">    // Create an instance of the Player class</strong></p>
			<p class="source-code"><strong class="bold">    Player player;</strong></p>
			<p class="source-code"><strong class="bold">    // The boundaries of the arena</strong></p>
			<p class="source-code"><strong class="bold">    IntRect arena;</strong></p>
			<p class="source-code"><strong class="bold">    // The main game loop</strong></p>
			<p class="source-code"><strong class="bold">    while (window.isOpen())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Let's run through each section of all the code that we entered. Just inside the <strong class="source-inline">main</strong> function, we have the following code:</p>
			<p class="source-code">// The game will always be in one of four states</p>
			<p class="source-code">enum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING };</p>
			<p class="source-code">// Start with the GAME_OVER state</p>
			<p class="source-code">State state = State::GAME_OVER;</p>
			<p>The previous code creates a new enumeration class called <strong class="source-inline">State</strong>. Then, the code creates an instance of the <strong class="source-inline">State</strong> class called <strong class="source-inline">state</strong>. The <strong class="source-inline">state</strong> enumeration can now be one of four values, as defined in the declaration. Those values are <strong class="source-inline">PAUSED</strong>, <strong class="source-inline">LEVELING_UP</strong>, <strong class="source-inline">GAME_OVER</strong>, and <strong class="source-inline">PLAYING</strong>. These four values will be just what we need for keeping track and responding to the different states that the game can be in at any given time. Note that it is not possible for <strong class="source-inline">state</strong> to hold more than one value at a time.</p>
			<p>Immediately after, we added the following code:</p>
			<p class="source-code">// Get the screen resolution and create an SFML window</p>
			<p class="source-code">Vector2f resolution;</p>
			<p class="source-code">resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">RenderWindow window(VideoMode(resolution.x, resolution.y), </p>
			<p class="source-code">    "Zombie Arena", Style::Fullscreen);</p>
			<p>The previous code declares a <strong class="source-inline">Vector2f</strong> instance called <strong class="source-inline">resolution</strong>. We initialize the two member variables of <strong class="source-inline">resolution</strong> (<strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>) by calling the <strong class="source-inline">VideoMode::getDesktopMode</strong> function for both <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>. The <strong class="source-inline">resolution</strong> object now holds the resolution of the monitor on which the game is running. The final line of code creates a new <strong class="source-inline">RenderWindow</strong> instance called <strong class="source-inline">window</strong> using the appropriate resolution.</p>
			<p>The following code creates an SFML <strong class="source-inline">View</strong> object. The view is positioned (initially) at the exact coordinates of the pixels of the monitor. If we were to use this <strong class="source-inline">View</strong> to do some drawing in this current position, it would be the same as drawing to a window without a view. However, we will eventually start to move this view to focus on the parts of our game world that the player needs to see. Then, when we start to use a second <strong class="source-inline">View</strong> instance, which remains fixed (for the HUD), we will see how this <strong class="source-inline">View</strong> instance can track the action while the other remains static to display the HUD:</p>
			<p class="source-code">// Create a an SFML View for the main action</p>
			<p class="source-code">View mainView(sf::FloatRect(0, 0, resolution.x, resolution.y));</p>
			<p>Next, we created a <strong class="source-inline">Clock</strong> instance to do our timing and a <strong class="source-inline">Time</strong> object called <strong class="source-inline">gameTimeTotal</strong> that will keep a running total of the game time that has elapsed. As the project progresses, we will also introduce more variables and objects to handle timing:</p>
			<p class="source-code">// Here is our clock for timing everything</p>
			<p class="source-code">Clock clock;</p>
			<p class="source-code">// How long has the PLAYING state been active</p>
			<p class="source-code">Time gameTimeTotal;</p>
			<p>The following code declares two vectors: one holding two <strong class="source-inline">float</strong> variables, called <strong class="source-inline">mouseWorldPosition</strong>, and one holding two integers, called <strong class="source-inline">mouseScreenPosition</strong>. The mouse pointer is something of an anomaly because it exists in two different coordinate spaces. We could think of these as parallel universes if we like. Firstly, as the player moves around the world, we will need to keep track of where the crosshair is in that world. These will be floating-point coordinates and will be stored in <strong class="source-inline">mouseWorldCoordinates</strong>. Of course, the actual pixel coordinates of the monitor itself never change. They will always be 0,0 to horizontal resolution -1, vertical resolution -1. We will track the mouse pointer position that is relative to this coordinate space using the integers stored in <strong class="source-inline">mouseScreenPosition</strong>:</p>
			<p class="source-code">// Where is the mouse in relation to world coordinates</p>
			<p class="source-code">Vector2f mouseWorldPosition;</p>
			<p class="source-code">// Where is the mouse in relation to screen coordinates</p>
			<p class="source-code">Vector2i mouseScreenPosition;</p>
			<p>Finally, we get to use our <strong class="source-inline">Player</strong> class. This line of code will cause the constructor function (<strong class="source-inline">Player::Player</strong>) to execute. Refer to <strong class="source-inline">Player.cpp</strong> if you want to refresh your memory about this function:</p>
			<p class="source-code">// Create an instance of the Player class</p>
			<p class="source-code">Player player;</p>
			<p>This <strong class="source-inline">IntRect</strong> object will hold starting horizontal and vertical coordinates, as well as a width and a height. Once initialized, we will be able to access the size and location details of the current arena with code such as <strong class="source-inline">arena.left</strong>, <strong class="source-inline">arena.top</strong>, <strong class="source-inline">arena.width</strong>, and <strong class="source-inline">arena.height</strong>:</p>
			<p class="source-code">// The boundaries of the arena</p>
			<p class="source-code">IntRect arena;</p>
			<p>The last part of the code that we added previously is, of course, our game loop:</p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>We have probably noticed that the code is getting quite long. We'll talk about this inconvenience in the following section.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor195"/>Managing the code files</h1>
			<p>One of the advantages of abstraction using classes and functions is that the length (number of lines) of our code files can be reduced. Even though we will be using more than a dozen code files for this project, the length of the code in <strong class="source-inline">ZombieArena.cpp</strong> will still get a little unwieldy toward the end. In the final project, Space Invaders++, we will look at even more ways to abstract and manage our code. </p>
			<p>For now, use this tip to keep things manageable. Notice that on the left-hand side of the code editor in Visual Studio, there are several <strong class="bold">+</strong> and <strong class="bold">-</strong> signs, one of which is shown in this diagram:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B14278_08_04.jpg" alt=""/>
				</div>
			</div>
			<p>There will be one sign for each block (<strong class="source-inline">if</strong>, <strong class="source-inline">while</strong>, <strong class="source-inline">for</strong>, and so on) of the code. You can expand and collapse these blocks by clicking on the <strong class="bold">+</strong> and <strong class="bold">-</strong> signs. I recommend keeping all the code not currently under discussion collapsed. This will make things much clearer. </p>
			<p>Furthermore, we can create our own collapsible blocks. I suggest making a collapsible block out of all the code before the start of the main game loop. To do so, highlight the code and then <em class="italic">right-click</em> and choose <strong class="bold">Outlining</strong> | <strong class="bold">Hide Selection</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B14278_08_05.jpg" alt=""/>
				</div>
			</div>
			<p>Now, you can click the <strong class="bold">-</strong> and <strong class="bold">+</strong> signs to expand and collapse the block. Each time we add code before the main game loop (and that will be quite often), you can expand the code, add the new lines, and then collapse it again. The following screenshot shows what the code looks like when it is collapsed:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B14278_08_06.jpg" alt=""/>
				</div>
			</div>
			<p>This is much more manageable than it was before. Now, we can make a start with the main game loop.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor196"/>Starting to code the main game loop</h1>
			<p>As you can see, the last part of the preceding code is the game loop (<strong class="source-inline">while (window.isOpen()){}</strong>). We will turn our attention to this now. Specifically, we will be coding the input handling section of the game loop.</p>
			<p>The code that we will be adding is quite long. There is nothing complicated about it, though, and we will examine it all in a moment.</p>
			<p>Add the following highlighted code to the game loop:</p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    /*</strong></p>
			<p class="source-code"><strong class="bold">    ************</strong></p>
			<p class="source-code"><strong class="bold">    Handle input</strong></p>
			<p class="source-code"><strong class="bold">    ************</strong></p>
			<p class="source-code"><strong class="bold">    */</strong></p>
			<p class="source-code"><strong class="bold">    // Handle events by polling</strong></p>
			<p class="source-code"><strong class="bold">    Event event;</strong></p>
			<p class="source-code"><strong class="bold">    while (window.pollEvent(event))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (event.type == Event::KeyPressed)</strong></p>
			<p class="source-code"><strong class="bold">        {                                    </strong></p>
			<p class="source-code"><strong class="bold">            // Pause a game while playing</strong></p>
			<p class="source-code"><strong class="bold">            if (event.key.code == Keyboard::Return &amp;&amp;</strong></p>
			<p class="source-code"><strong class="bold">                state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                state = State::PAUSED;</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">            // Restart while paused</strong></p>
			<p class="source-code"><strong class="bold">            else if (event.key.code == Keyboard::Return &amp;&amp;</strong></p>
			<p class="source-code"><strong class="bold">                state == State::PAUSED)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">                // Reset the clock so there isn't a frame jump</strong></p>
			<p class="source-code"><strong class="bold">                clock.restart();</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">            // Start a new game while in GAME_OVER state</strong></p>
			<p class="source-code"><strong class="bold">            else if (event.key.code == Keyboard::Return &amp;&amp;</strong></p>
			<p class="source-code"><strong class="bold">                state == State::GAME_OVER)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                state = State::LEVELING_UP;</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">            if (state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }// End event polling</strong></p>
			<p class="source-code">}// End game loop</p>
			<p>In the preceding code, we instantiate an object of the <strong class="source-inline">Event</strong> type. We will use <strong class="source-inline">event</strong>, like we did in the previous projects, to poll for system events. To do so, we wrap the rest of the code from the previous block in a <strong class="source-inline">while</strong> loop with the <strong class="source-inline">window.pollEvent(event)</strong> condition. This will keep looping each frame until there are no more events to process. </p>
			<p>Inside this <strong class="source-inline">while</strong> loop, we handle the events we are interested in. First, we test for <strong class="source-inline">Event::KeyPressed</strong> events. If the <em class="italic">Return</em> key is pressed while the game is in the <strong class="source-inline">PLAYING</strong> state, then we switch <strong class="source-inline">state</strong> to <strong class="source-inline">PAUSED</strong>. </p>
			<p>If the <em class="italic">Return</em> key is pressed while the game is in the <strong class="source-inline">PAUSED</strong> state, then we switch <strong class="source-inline">state</strong> to <strong class="source-inline">PLAYING</strong> and restart the <strong class="source-inline">clock</strong> object. The reason we restart <strong class="source-inline">clock</strong> after switching from <strong class="source-inline">PAUSED</strong> to <strong class="source-inline">PLAYING</strong> is because, while the game is paused, the elapsed time still accumulates. If we didn't restart the clock, all our objects would update their locations as if the frame had just taken a very long time. This will become more apparent as we flesh out the rest of the code in this file.</p>
			<p>We then have an <strong class="source-inline">else if</strong> block to test whether the <strong class="source-inline">Return</strong> key was pressed while the game was in the <strong class="source-inline">GAME_OVER</strong> state. If it was, then <strong class="source-inline">state</strong> is changed to <strong class="source-inline">LEVELING_UP</strong>. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the <strong class="source-inline">GAME_OVER</strong> state is the state where the home screen is displayed. So, the <strong class="source-inline">GAME_OVER</strong> state is the state after the player has just died and when the player first runs the game. The first thing that the player gets to do each game is pick an attribute to improve (that is, level up).</p>
			<p>In the previous code, there is a final <strong class="source-inline">if</strong> condition to test whether the state is equal to <strong class="source-inline">PLAYING</strong>. This <strong class="source-inline">if</strong> block is empty and we will add code to it throughout the project.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We will add code to lots of different parts of this file throughout the project. Therefore, it is worthwhile taking the time to understand the different states our game can be in and where we handle them. It will also be very beneficial to collapse and expand the different <strong class="source-inline">if</strong>, <strong class="source-inline">else</strong>, and <strong class="source-inline">while</strong> blocks as and when appropriate.</p>
			<p>Spend some time thoroughly familiarizing yourself with the <strong class="source-inline">while</strong>, <strong class="source-inline">if</strong>, and <strong class="source-inline">else if</strong> blocks we have just coded. We will be referring to them regularly.</p>
			<p>Next, immediately after the previous code and still inside the game loop, which is still dealing with handling input, add the following highlighted code. Note the existing code (not highlighted) that shows exactly where the new (highlighted) code goes:</p>
			<p class="source-code">    }// End event polling</p>
			<p class="source-code"><strong class="bold">    // Handle the player quitting</strong></p>
			<p class="source-code"><strong class="bold">    if (Keyboard::isKeyPressed(Keyboard::Escape))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        window.close();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Handle WASD while playing</strong></p>
			<p class="source-code"><strong class="bold">    if (state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Handle the pressing and releasing of the WASD keys</strong></p>
			<p class="source-code"><strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::W))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.moveUp();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.stopUp();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::S))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.moveDown();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.stopDown();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::A))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.moveLeft();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.stopLeft();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (Keyboard::isKeyPressed(Keyboard::D))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.moveRight();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            player.stopRight();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }// End WASD while playing</strong></p>
			<p class="source-code">}// End game loop</p>
			<p>In the preceding code, we first test to see whether the player has pressed the <em class="italic">Escape</em> key. If it is pressed, the game window will be closed.</p>
			<p>Next, within one big <strong class="source-inline">if(state == State::PLAYING)</strong> block, we check each of the <em class="italic">WASD</em> keys in turn. If a key is pressed, we call the appropriate <strong class="source-inline">player.move...</strong> function. If it is not, we call the related <strong class="source-inline">player.stop...</strong> function.</p>
			<p>This code ensures that, in each frame, the player object will be updated with the <em class="italic">WASD</em> keys that are pressed and those that are not. The <strong class="source-inline">player.move...</strong> and <strong class="source-inline">player.stop...</strong> functions store the information in the member Boolean variables (<strong class="source-inline">m_LeftPressed</strong>, <strong class="source-inline">m_RightPressed</strong>, <strong class="source-inline">m_UpPressed</strong>, and <strong class="source-inline">m_DownPressed</strong>). The <strong class="source-inline">Player</strong> class then responds to the value of these Booleans, in each frame, in the <strong class="source-inline">player.update</strong> function, which we will call in the update section of the game loop.</p>
			<p>Now, we can handle the keyboard input to allow the player to level up at the start of each game and in-between each wave. Add and study the following highlighted code and then we will discuss it:</p>
			<p class="source-code">    }// End WASD while playing</p>
			<p class="source-code"><strong class="bold">    // Handle the LEVELING up state</strong></p>
			<p class="source-code"><strong class="bold">    if (state == State::LEVELING_UP)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Handle the player LEVELING up</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num1)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num2)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num3)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num4)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num5)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (event.key.code == Keyboard::Num6)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::PLAYING;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        if (state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">        {            </strong></p>
			<p class="source-code"><strong class="bold">            // Prepare the level</strong></p>
			<p class="source-code"><strong class="bold">            // We will modify the next two lines later</strong></p>
			<p class="source-code"><strong class="bold">            arena.width = 500;</strong></p>
			<p class="source-code"><strong class="bold">            arena.height = 500;</strong></p>
			<p class="source-code"><strong class="bold">            arena.left = 0;</strong></p>
			<p class="source-code"><strong class="bold">            arena.top = 0;</strong></p>
			<p class="source-code"><strong class="bold">            // We will modify this line of code later</strong></p>
			<p class="source-code"><strong class="bold">            int tileSize = 50;</strong></p>
			<p class="source-code"><strong class="bold">            // Spawn the player in the middle of the arena</strong></p>
			<p class="source-code"><strong class="bold">            player.spawn(arena, resolution, tileSize);</strong></p>
			<p class="source-code"><strong class="bold">            </strong></p>
			<p class="source-code"><strong class="bold">            // Reset the clock so there isn't a frame jump</strong></p>
			<p class="source-code"><strong class="bold">            clock.restart();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }// End LEVELING up</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">}// End game loop</p>
			<p>In the preceding code, which is all wrapped in a test to see whether the current value of <strong class="source-inline">state</strong> is equal to <strong class="source-inline">LEVELING_UP</strong>, we handle the keyboard keys <em class="italic">1</em>, <em class="italic">2</em>, <em class="italic">3</em>, <em class="italic">4</em>, <em class="italic">5</em>, and <em class="italic">6</em>. In the <strong class="source-inline">if</strong> block for each, we simply set <strong class="source-inline">state</strong> to <strong class="source-inline">State::PLAYING</strong>. We will add some code to deal with each level up option later in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a><em class="italic">, Sound Effects, File I/O, and Finishing the Game</em>.</p>
			<p>This code does the following things:</p>
			<ol>
				<li value="1">If the <strong class="source-inline">state</strong> is equal to <strong class="source-inline">LEVELING_UP</strong>, wait for either the <em class="italic">1</em>, <em class="italic">2</em>, <em class="italic">3</em>, <em class="italic">4</em>, <em class="italic">5</em>, or <em class="italic">6</em> keys to be pressed.</li>
				<li>When pressed, change <strong class="source-inline">state</strong> to <strong class="source-inline">PLAYING</strong>.</li>
				<li>When the state changes, still within the <strong class="source-inline">if (state == State::LEVELING_UP)</strong> block, the nested <strong class="source-inline">if(state == State::PLAYING)</strong> block will run.</li>
				<li>Within this block, we set the location and size of <strong class="source-inline">arena</strong>, set the <strong class="source-inline">tileSize</strong> to <strong class="source-inline">50</strong>, pass all the information to <strong class="source-inline">player.spawn</strong>, and call <strong class="source-inline">clock.restart</strong>.</li>
			</ol>
			<p>Now, we have an actual spawned player object that is aware of its environment and can respond to key presses. We can now update the scene on each pass through the loop.</p>
			<p>Be sure to neatly collapse the code from the input handling part of the game loop since we are done with that for now. The following code is in the updating part of the game loop. Add and study the following highlighted code and then we can discuss it:</p>
			<p class="source-code">    }// End LEVELING up</p>
			<p class="source-code"><strong class="bold">    /*</strong></p>
			<p class="source-code"><strong class="bold">    ****************</strong></p>
			<p class="source-code"><strong class="bold">    UPDATE THE FRAME</strong></p>
			<p class="source-code"><strong class="bold">    ****************</strong></p>
			<p class="source-code"><strong class="bold">    */</strong></p>
			<p class="source-code"><strong class="bold">    if (state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Update the delta time</strong></p>
			<p class="source-code"><strong class="bold">        Time dt = clock.restart();</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        // Update the total game time</strong></p>
			<p class="source-code"><strong class="bold">        gameTimeTotal += dt;</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        // Make a decimal fraction of 1 from the delta time</strong></p>
			<p class="source-code"><strong class="bold">        float dtAsSeconds = dt.asSeconds();</strong></p>
			<p class="source-code"><strong class="bold">        // Where is the mouse pointer</strong></p>
			<p class="source-code"><strong class="bold">        mouseScreenPosition = Mouse::getPosition();</strong></p>
			<p class="source-code"><strong class="bold">        // Convert mouse position to world coordinates of mainView</strong></p>
			<p class="source-code"><strong class="bold">        mouseWorldPosition = window.mapPixelToCoords(</strong></p>
			<p class="source-code"><strong class="bold">            Mouse::getPosition(), mainView);</strong></p>
			<p class="source-code"><strong class="bold">        // Update the player</strong></p>
			<p class="source-code"><strong class="bold">        player.update(dtAsSeconds, Mouse::getPosition());</strong></p>
			<p class="source-code"><strong class="bold">        // Make a note of the players new position</strong></p>
			<p class="source-code"><strong class="bold">        Vector2f playerPosition(player.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">        // Make the view centre around the player                </strong></p>
			<p class="source-code"><strong class="bold">        mainView.setCenter(player.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">    }// End updating the scene</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">}// End game loop</p>
			<p>First, note that the previous code is wrapped in a test to make sure the game is in the <strong class="source-inline">PLAYING</strong> state. We don't want this code to run if the game has been paused, it has ended, or if the player is choosing what to level up.</p>
			<p>First, we restart the clock and store the time that the previous frame took in the <strong class="source-inline">dt</strong> variable:</p>
			<p class="source-code">// Update the delta time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p>Next, we add the time that the previous frame took to the accumulated time the game has been running for, as held by <strong class="source-inline">gameTimeTotal</strong>:</p>
			<p class="source-code">// Update the total game time</p>
			<p class="source-code">gameTimeTotal += dt;</p>
			<p>Now, we initialize a <strong class="source-inline">float</strong> variable called <strong class="source-inline">dtAsSeconds</strong> with the value returned by the <strong class="source-inline">dt.AsSeconds</strong> function. For most frames, this will be a fraction of one. This is perfect for passing into the <strong class="source-inline">player.update</strong> function to be used to calculate how much to move the player sprite.</p>
			<p>Now, we can initialize <strong class="source-inline">mouseScreenPosition</strong> using the <strong class="source-inline">MOUSE::getPosition</strong> function.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You might be wondering about the slightly unusual syntax for getting the position of the mouse. This is called a <strong class="bold">static function</strong>. If we define a function in a class with the static keyword, we can call that function using the class name and without an instance of the class. C++ OOP has lots of quirks and rules like this. We will see more as we progress.</p>
			<p>We then initialize <strong class="source-inline">mouseWorldPosition</strong> using the SFML <strong class="source-inline">mapPixelToCoords</strong> function on <strong class="source-inline">window</strong>. We discussed this function when talking about the <strong class="source-inline">View</strong> class earlier in this chapter.</p>
			<p>At this point, we are now able to call <strong class="source-inline">player.update</strong> and pass in <strong class="source-inline">dtAsSeconds</strong> and the position of the mouse, as is required.</p>
			<p>We store the player's new center in a <strong class="source-inline">Vector2f</strong> instance called <strong class="source-inline">playerPosition</strong>. At the moment, this is unused, but we will have a use for this later in the project.</p>
			<p>We can then center the view around the center of the player's up-to-date position with <strong class="source-inline">mainView.setCenter(player.getCenter())</strong>.</p>
			<p>We are now able to draw the player to the screen. Add the following highlighted code, which splits the draw section of the main game loop into different states:</p>
			<p class="source-code">        }// End updating the scene</p>
			<p class="source-code"><strong class="bold">        /*</strong></p>
			<p class="source-code"><strong class="bold">        **************</strong></p>
			<p class="source-code"><strong class="bold">        Draw the scene</strong></p>
			<p class="source-code"><strong class="bold">        **************</strong></p>
			<p class="source-code"><strong class="bold">        */</strong></p>
			<p class="source-code"><strong class="bold">        if (state == State::PLAYING)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            window.clear();</strong></p>
			<p class="source-code"><strong class="bold">            // set the mainView to be displayed in the window</strong></p>
			<p class="source-code"><strong class="bold">            // And draw everything related to it</strong></p>
			<p class="source-code"><strong class="bold">            window.setView(mainView);</strong></p>
			<p class="source-code"><strong class="bold">            // Draw the player</strong></p>
			<p class="source-code"><strong class="bold">            window.draw(player.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (state == State::LEVELING_UP)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (state == State::PAUSED)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (state == State::GAME_OVER)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        window.display();</strong></p>
			<p class="source-code">    }// End game loop</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Within the <strong class="source-inline">if(state == State::PLAYING)</strong> section of the previous code, we clear the screen, set the view of the window to <strong class="source-inline">mainView</strong>, and then draw the player sprite with <strong class="source-inline">window.draw(player.getSprite())</strong>.</p>
			<p>After all the different states have been handled, the code shows the scene in the usual manner with <strong class="source-inline">window.display();</strong>.</p>
			<p>You can run the game and see our player character spin around in response to moving the mouse.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you run the game, you need to press <em class="italic">Enter</em> to start the game, and then select a number from <em class="italic">1</em> to <em class="italic">6</em> to simulate choosing an upgrade option. Then, the game will start.</p>
			<p>You can also move the player around within the (empty) 500 x 500 pixel arena. You can see our lonely player in the center of the screen, as shown here:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B14278_08_07.jpg" alt=""/>
				</div>
			</div>
			<p>You c<a id="_idTextAnchor197"/>an't, however, get any sense of movement because we haven't implemented the background. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor198"/>Summary</h1>
			<p>Phew! That was a long one. We have done a lot in this chapter: we built our first class for the Zombie Arena project, <strong class="source-inline">Player</strong>, and put it to use in the game loop. We also learned about and used an instance of the <strong class="source-inline">View</strong> class, although we haven't explored the benefits this gives us just yet.</p>
			<p>In the next chapter, we will build our arena background by exploring what sprite sheets are. We will also learn about C++ <strong class="bold">references</strong>, which allow us to manipulate variables, even when they are out of scope (that is, in another function).</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor199"/>FAQ</h1>
			<p>Q) I noticed we have coded quite a few functions of the <strong class="source-inline">Player</strong> class that we don't use. Why is this?</p>
			<p>A) Rather than keep coming back to the <strong class="source-inline">Player</strong> class, we have added all the code that we will need throughout the project. By the end of <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>, <em class="italic">Sound Effects, File I/O, and Finishing the Game</em>, we will have made full use of all of these functions.</p>
		</div>
	</body></html>