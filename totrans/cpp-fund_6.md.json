["```cpp\nclass Vehicle {\n  public:\n    TankLevel getTankLevel() const;\n    void turnOn();\n};\nclass Car : public Vehicle {\n  public:\n    bool isTrunkOpen();\n};\n```", "```cpp\nclass Car : public Vehicle, public Transport {\n}\n```", "```cpp\nCar car;\ncar.turnOn();\n```", "```cpp\nclass Fruit {\n};\nclass Citrus: public Fruit {\n};\nclass Orange: public Citrus {\n};\n```", "```cpp\n    #include <iostream>\n    ```", "```cpp\n    // first base class \n    class Vehicle { \n      public: \n        int getTankCapacity(){\n          const int tankLiters = 10;\n          std::cout << \"The current tank capacity for your car is \" << tankLiters << \" Liters.\"<<std::endl;\n          return tankLiters;\n        }\n    };\n    ```", "```cpp\n    // second base class \n    class CollectorItem { \n      public: \n        float getValue() {\n          return 100;\n        }\n    }; \n    ```", "```cpp\n    // Subclass derived from two base classes\n    class Ferrari250GT: protected Vehicle, public CollectorItem { \n      public:\n        Ferrari250GT() {\n          std::cout << \"Thank you for buying the Ferrari 250 GT with tank capacity \" << getTankCapacity() << std::endl;\n          return 0;\n        }\n    }; \n    ```", "```cpp\n    int main()\n    {\n      Ferrari250GT ferrari;\n      std::cout << \"The value of the Ferrari is \" << ferrari.getValue() << std::endl;\n      /* Cannot call ferrari.getTankCapacity() because Ferrari250GT inherits from Vehicle with the protected specifier */\n      return 0;\n    }\n    ```", "```cpp\n    Output:\n    The current tank capacity for your car is 10 Liters.\n    Thank you for buying the Ferrari 250 GT with tank capacity 10\n    The value of the Ferrari is 100\n    ```", "```cpp\nclass A {\n  public:\n    A(const std::string& name);\n};\nclass B: public A {\n  public:\n    B(int number) : A(\"A's name\"), d_number(number) {}\n  private:\n    int d_number;\n};\n\n}\n```", "```cpp\nstruct A {\n};\nstruct B {\n};\nstruct C : A, B {\n};\n```", "```cpp\nstruct A {\n  void foo() {}\n};\nstruct B {\n  void foo() {}\n};\nstruct C: A, B {\n  void bar() { foo(); }\n};\n```", "```cpp\n    #include <iostream>\n    ```", "```cpp\n    class DataScienceDev {\n    public:\n        DataScienceDev(){\n            std::cout << \"Welcome to the Data Science Developer Community.\" << std::endl;\n        }\n    };\n    class FutureCppDev {\n    public:\n        FutureCppDev(){\n            std::cout << \"Welcome to the C++ Developer Community.\" << std::endl;\n          }\n    };\n    ```", "```cpp\n    class Student : public DataScienceDev, public FutureCppDev {\n        public:\n        Student(){\n            std::cout << \"Student is a Data Developer and C++ Developer.\" << std::endl;\n        }\n    };\n    ```", "```cpp\n    int main(){\n        Student S1;\n        return 0;\n    }\n    ```", "```cpp\n    Welcome to the Data Science Developer Community.\n    Welcome to the C++ Developer Community.\n    Student is a Data Developer and C++ Developer.\n    ```", "```cpp\n    struct Position {\n        std::string positionIdentifier;\n    };\n    ```", "```cpp\n    class Hero : public Character {\n    };\n    class Enemy : public Character {\n    };\n    ```", "```cpp\n    class Spell {\n    public:\n        Spell(std::string name) : d_name(name) {}\n        std::string name() const {\n            return d_name;\n        }\n    private:\n        std::string d_name;\n    }\n    ```", "```cpp\n    int main()\n    {\n        Position position{\"Enemy castle\"};\n        Hero hero;\n        Enemy enemy;\n    }\n    ```", "```cpp\n    Moved to position Enemy castle\n    Moved to position Enemy castle\n    Casting spell fireball\n    Swinging sword\n    ```", "```cpp\nstruct A {\n};\nstruct B: A{\n};\nstruct C: A {\n};\n//We can write\nB b;\nC c;\nA& ref1 = b;\nA& ref2 = c;\nA* ptr = nullptr;\nif (runtime_condition()) {\n  ptr = &b;\n} else {\n  ptr = &c;\n}\n```", "```cpp\nA* ptr = &b; // ptr dynamic type is B\nptr = &c; // ptr dynamic type is now C\n```", "```cpp\nB b;\nA a = b;\n```", "```cpp\nvoid safeTurnOn(Vehicle& vehicle) {\n  if (vehicle.getFuelInTank() > 0.1 && vehicle.batteryHasEnergy()) {\n    vehicle.turnOn();\n  }\n}\n```", "```cpp\nCar myCar;\nTruck truck;\nsafeTurnOn(myCar);\nsafeTurnOn(truck);\n```", "```cpp\nclass Vehicle {\n  public:\n    virtual void turnOn();\n};\n```", "```cpp\n    class Vehicle {\n      public:\n        void turnOn() {\n          std::cout << \"Vehicle: turn on\" << std::endl;\n        }\n    };\n    ```", "```cpp\n    class Car : public Vehicle {\n      public:\n        virtual void turnOn()  {\n          std::cout << \"Car: turn on\" << std::endl;\n        }\n    };\n    void myTurnOn(Vehicle& vehicle) {\n      std::cout << \"Calling turnOn() on the vehicle reference\" << std::endl;\n      vehicle.turnOn();\n    }\n    ```", "```cpp\n    int main() {\n      Car car;\n      myTurnOn(car);\n    }\n    ```", "```cpp\n    Calling turnOn() on the vehicle reference\n    Vehicle: turn on\n    ```", "```cpp\nstruct Base {\n  virtual void foo(int) = 0;\n};\nstruct Derived: Base {\n  /* This is an override: we are redefining a virtual method of the base class, using the same signature. */\n  void foo(int) { }\n  /* This is an overload: we are defining a method with the same name of a method of the base class, but the signature is different. The rules regarding virtual do not apply between Base::foo(int) and Derived:foo(float). */\n  void foo(float) {}\n};\n```", "```cpp\nstruct A {\n  virtual void foo() {\n    std::cout << \"A's foo\" << std::endl;\n  }\n};\nstruct B: A {\n  virtual void foo() override {\n    std::cout << \"B's foo\" << std::endl;\n  }\n};\nstruct C: B {\n  virtual void foo() override {\n    std::cout << \"C's foo\" << std::endl;\n  }\n};\nint main() {\n  B b;\n  C c;\n  A* a = &b;\n  a->foo();  // B::foo() is executed\n  a = &c;\n  a->foo();\n  /* C::foo() is executed, because it's the most derived Class overriding foo(). */\n}\n```", "```cpp\n    class Department {\n    public:\n        Department(int expectedEarning, int effectiveEarning)\n        : d_expectedEarning(expectedEarning), d_effectiveEarning(effectiveEarning)\n        {}\n        bool hasReachedTarget() const {return d_effectiveEarning >= d_expectedEarning;}\n        int expectedEarning() const {return d_expectedEarning;}\n        int effectiveEarning() const {return d_effectiveEarning;}\n    private:\n        int d_expectedEarning;\n        int d_effectiveEarning;\n    };\n    ```", "```cpp\n    class Employee {\n    public:\n        virtual int getBaseSalary() const { return 100; }\n        virtual int getBonus(const Department& dep) const {\n            if (dep.hasReachedTarget()) {\n                return int(0.1 * getBaseSalary());\n            }\n            return 0;\n        }\n    };\n    ```", "```cpp\n        int getTotalComp(const Department& dep) {\n                return getBaseSalary() + getBonus(dep);\n        }\n    ```", "```cpp\n    class Manager : public Employee {\n    public:\n        virtual int getBaseSalary() const override { return 150; }\n        virtual int getBonus(const Department& dep) const override {\n            if (dep.hasReachedTarget()) {\n                int additionalDeparmentEarnings = dep.effectiveEarning() - dep.expectedEarning();\n                return int(0.2 * getBaseSalary() + 0.01 * additionalDeparmentEarnings);\n            }\n            return 0;\n        }\n    };\n    ```", "```cpp\n    Employee: 110\\. Manager: 181\n    ```", "```cpp\nclass Vehicle {\n  public:\n    virtual void turnOn() = 0;\n};\n```", "```cpp\nclass GasolineVehicle: public Vehicle {\n  public:\n    virtual void fillTank() = 0;\n};\nclass Car : public GasolineVehicle {\n  virtual void turnOn() override {}\n  virtual void fillTank() override {}\n};\n```", "```cpp\nCar redCar;\nCar blueCar;\nVehicle& redVehicle = redCar;\nVehicle& redVehicle = blueCar;\nredVehicle = blueVehicle;\n// Problem: object slicing!\n```", "```cpp\n    struct UserProfile {};\n    struct UserId {};\n    class UserProfileStorage {\n      public:\n        virtual UserProfile getUserProfile(const UserId& id) const = 0;\n\n        virtual ~UserProfileStorage() = default;\n      protected:\n        UserProfileStorage() = default;\n        UserProfileStorage(const UserProfileStorage&) = default;\n        UserProfileStorage& operator=(const UserProfileStorage&) = default;\n    };\n    ```", "```cpp\n    class UserProfileCache : public UserProfileStorage {\n    public:\n        UserProfile getUserProfile(const UserId& id) const override {\n            std::cout << \"Getting the user profile from the cache\" << std::endl;\n            return UserProfile();\n        }\n    };\n    void exampleOfUsage(const UserProfileStorage& storage) {\n        UserId user;\n        std::cout << \"About to retrieve the user profile from the storage\" << std::endl;\n        UserProfile userProfile = storage.getUserProfile(user);\n    }\n    ```", "```cpp\n    int main()\n    {\n      UserProfileCache cache;\n      exampleOfUsage (cache);\n    }\n    ```", "```cpp\nAbout to retrieve the user profile from the storage\nGetting the user profile from the cache\n```", "```cpp\nCar* myCar = new myCar();\n```", "```cpp\ndelete myCar;\n```", "```cpp\nCar myCar; // automatic variable\ndelete &myCar; // This is an error and will likely crash the program\n```", "```cpp\nint n = 15;\nCar* cars = new Car[n];\ndelete[] cars;\n```", "```cpp\nLogger* createLogger() {\n  if (are_tests_running()) {\n    TestLogger* logger = new TestLogger();\n    return logger;\n  } else {\n    ReleaseLogger logger = new ReleaseLogger(\"Release logger\");\n    return logger;\n  }\n}\n```", "```cpp\nLogger* logger = createLogger();\nmyOperation(logger, argument1, argument2);\ndelete logger;\n```", "```cpp\nvoid foo() {\n  int number;\n  do_action(number);\n}\n```", "```cpp\nclass A {\n  int number;\n};\n```", "```cpp\nvoid foo() {\n  int* number = new number();\n  do_action(number);\n  delete number;\n}\n```", "```cpp\nclass A {\n    A() : number(new int(0)) {\n    }\n    ~A() {\n        delete number;\n    }\n    int* number;\n};\n```", "```cpp\nstd::unique_ptr<Logger> logger = createLogger();\n```", "```cpp\nstd::unique_ptr<Logger>createLogger();\n```", "```cpp\nstd::unique_ptr<Logger>createLogger() {\n  if (are_tests_running()) {\n    std::unique_ptr<TestLogger> logger = std::make_unique<TestLogger>();\n     return logger; // logger is implicitly moved\n  } else {\n    std::unique_ptr<ReleaseLogger> logger = std::make_unique<ReleaseLogger>(\"Release logger\");\n    return logger; // logger is implicitly moved\n  }\n}\n```", "```cpp\nclass A {\n  A(): number(std::make_unique<int>()) {}\n  std::unique_ptr<int> number;\n};\n```", "```cpp\nclass Node {\n  public:\n    void addConnectedNode(std::shared_ptr<Node> node);\n    void removeConnectedNode(std::shared_ptr<Node> node);\n  private:\n    std::vector<std::shared_ptr<Node>>d_connections;\n};\n```", "```cpp\nstd::unique_ptr<int[]>ints = std::make_unique<int[]>();\nstd::shared_ptr<float[]>floats = std::make_shared<float[]>();\n```", "```cpp\n    class UserProfileStorageFactory {\n    public:\n        std::unique_ptr<UserProfileStorage> create() const {\n            // Create the storage and return it\n        }\n    };\n    ```", "```cpp\n    void updateWithConnection(std::shared_ptr<DatabaseConnection> connection) {\n        updateOrderList(*connection);\n    }\n    void scheduleWithConnection(std::shared_ptr<DatabaseConnection> connection) {\n        scheduleOrderProcessing(*connection);\n    }\n    ```", "```cpp\n    int main()\n    {\n        std::shared_ptr<DatabaseConnection> connection = std::make_shared<DatabaseConnection>();\n        std::async(std::launch::async, updateWithConnection, connection);\n        std::async(std::launch::async, scheduleWithConnection, connection);\n    }\n    ```", "```cpp\n    Updating order and scheduling order processing in parallel\n    Schedule order processing\n    Updating order list\n    ```"]