- en: Programming the Arduino - The Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have been programming as long as I can remember, everything from teletypes
    and mainframes to personal computers and embedded devices. I have programmed games,
    business applications, websites and mobile apps but I can honestly say that I
    enjoy programming microcontroller boards like the Arduino the most.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is with microcontrollers my programs can interact with the
    outside world through various sensors and motors rather than programming for simple
    human interaction. With microcontrollers we are only limited by our imagination
    and ingenuity however before we can begin conquering the world, we must first
    learn the basics of the Arduino programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What variables and constants are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What math functions the Arduino programming language offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add comments to our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make decisions with the Arduino programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create loops to repeat blocks of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](b7889fa4-0da5-4063-838a-51b8d57f71ac.xhtml), *Arduino IDE* we
    learned how to use the Arduino IDE and the Web Editor. We also examined the `setup()`
    and `loop()` functions and learned how to use them. In this chapter and [Chapter
    7](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml), *Programming the Arduino–Beyond
    the Basics*, we will learn about the Arduino programming language and how to use
    the language to develop applications for the Arduino. Let's start off by looking
    at the curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Curly brackets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The left curly brackets ( { ) defines where a block of code starts and the right
    curly bracket ( } ) defines where it ends. We saw these brackets when we looked
    at the `setup()` and `loop()` functions; however, curly brackets are not limited
    to defining the code within a function they are also used to define other blocks
    of code as well. We will see examples of this in the *Decision making* and *Looping*
    sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a left curly bracket there must also be a right curly bracket.
    We say that the curly brackets are balanced when we have an equal number of left
    and right curly brackets. Unbalanced curly brackets can lead to crypt compiler
    errors. If you are receiving very crypt and hard to understand compiler errors,
    you may want to begin your troubleshooting by verifying that the curly brackets
    are balanced.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A semicolon is used at the end of every statement to separate one statement
    from the next. If a statement does not end with a semicolon it will result in
    a compile-time error. The error text for forgetting a semicolon is pretty obvious
    and will include the line number of the statement that is missing it.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons are also used in the `for` loop to separate the different elements.
    We will look at the `for` loop in the *Looping* section of this chapter. Now let's
    look at how we can add comments to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of comments that can be used to within our Arduino code.
    These are block comments and line comments. Block comments are used when the text
    of the comment will span multiple lines and are usually used before function calls
    to let the reader know what a function does. The line comments are used when a
    short one-line comment is needed and are usually used within function blocks to
    let the reader know what a specific line of code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A block comment begins with `/*` and ends with `*/`. The following code shows
    what a block comment would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A line comment starts with `//` and goes until the end of the line. The line
    comment can start at the beginning of the line or it may be after a statement
    ends. The following examples show what a line comment would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is always a good idea to add comments to your code to let the reader know
    what certain blocks of code are doing. Now let's look at what variables are.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable is used to store information that can be referenced or manipulated
    within the code. A variable is given a unique name which can then be used to access
    the information. The name of the variable should be something that describes what
    the variable is so anyone that looks at the code will understand what the variable
    is used for. Camel case should be used when naming a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Camel case is used when creating a name out of multiple words are phases where
    the first letter of the name is lowercase, but the beginning of each remaining
    word is uppercase. Some examples of camel case are ledOne, myVariable and redLedOnRightSide.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a variable is declared it is usually a good idea to give it an initial
    value. This helps to avoid accidentally accessing the variable prior to initializing
    it. To declare a variable, we define the type of variable followed by the name
    of the variable and then if we are going to give it an initial value we add the
    equal sign followed by the initial value. The following code shows how we would
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we declared a variable named `myInt` of the integer
    (`int`) type with an initial value of `0`. Let's look at some of the more popular
    built-in data types that we can use with the Arduino language.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous, built-in, data types in the Arduino programming language.
    In this section, we will look at the most commonly used ones. Let's begin by looking
    at the Boolean type.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean data type can contain one of two possible values, `true` or `false`.
    The following example shows how to declare a variable to be of the Boolean type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares a variable named `myBool` of the Boolean type and
    sets an initial value of `true`. Boolean types are used a lot within a standard
    Arduino program and all comparison operations, as we will see later in this chapter,
    return a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Byte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The byte data type is an 8-bit numerical value that ranges from 0 to 255\.
    The following shows how we would declare a variable of the byte type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares a variable named `myByte` of the `byte` type with
    an initial value of `128`.
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The integer is the primary data type used to store numerical data when a decimal
    value is not needed. A variable of the integer type can contain numbers ranging
    from -32,768 to 32,768\. An integer is defined using the `int` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare an integer to be unsigned by using the `unsigned` keyword. An
    unsigned integer can range from 0 to 65,535 whereas the normal integer has a range
    of -32,768 to 32,768\. The following code shows how we would define both a regular
    integer and an unsigned integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared a variable named `mySignedInt` of the integer
    type with an initial value of `25`. We also declared a second variable named `myUnsignedInt`
    of the unsigned integer type with an initial value of `15`.
  prefs: []
  type: TYPE_NORMAL
- en: On some Arduino boards like the Due or SAMD, the integer can store values larger
    than the 32,768 and smaller than the -32,768 value. Since most of the boards have
    an integer range of -32,768 to 32,768, I would recommend always assuming that
    is the range you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Long
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The long data type can store integers from -2,147,483,648 to 2,147,483,647\.
    The following code shows how we would define a long variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared a variable named `myLong` of the `long` type
    and gave it a value of 123,456,789\. It is good practice to avoid using the long
    data type unless it is necessary to store larger numbers because it uses more
    memory than the integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Double and float
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double and float data types are floating point numbers which means they are
    numbers that can contain a decimal point. Both the double and float types can
    hold values ranging from -3.4028235E+38 to 3.4028235E+38.
  prefs: []
  type: TYPE_NORMAL
- en: On most platforms, the float data type has a precision of six or seven decimal
    digits while the double data type usually has fifteen digits; however, this is
    not true on the Arduino platform. On the Arduino platform, the double and float
    types are exactly the same, therefore they both have the precision to six or seven
    decimal digits.
  prefs: []
  type: TYPE_NORMAL
- en: There are two very good reasons not to use a double or float value unless you
    absolutely need a decimal number. The first reason is with precision inaccuracy,
    as an example 6.0 divided by 3.0 may not always equal 2\. You may end up getting
    something like 1.9999999999\. The second reason is floating point math is much
    slower than integer math.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to define both a double and float variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare a variable named `myDouble` of the `double`
    type with a value of `1.25`. We also declare a variable named `myFloat` of the
    `float` type with a value of `1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The char data type is usually described as the data type that stores a character,
    however, this is not technically correct. The char data type stores a character
    as a numeric value based on the ASCII chart. When a char variable is defined,
    it can be defined with either the number that represents the character or the
    character itself as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, both lines declare a variable named `myChar` of the `char`
    type with a capital `A` as the value. Having a type that can hold only a single
    character is useful, but it would be more useful if we could store entire words
    or sentences. Later in this chapter, we will see how we can store words or sentences
    by using an array of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array is an ordered collection of variables which are of the same type.
    Each variable in the array is called an **element**, and these elements can be
    accessed by the location (index) in the array. When an array is defined we must
    declare the type of variables that will be stored in it. There are several ways
    that an array can be defined. The following examples show some of the basic ways
    to define an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each of these examples defines an array of integers. The first example defines
    an uninitialized array of ten integers. Be careful when defining uninitialized
    arrays because the memory locations are never initialized, which could lead to
    very unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: The second example defines an array of four integers were all of the elements
    are initialized with values. This array is automatically sized to the number of
    elements that is in the initialization array.
  prefs: []
  type: TYPE_NORMAL
- en: The last example defines an array of eight integers where the first five elements
    are initialized with values, but the last three elements are not initialized.
    Once again, I would recommend not defining an array like this because the last
    three elements are not initialized. In a moment, we will see what happens when
    we attempt to access an element in an array whose value was not initialized but
    first we need to see how we would access elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We access an element in an array by the index. We put the index of the element
    we wish to retrieve between two square brackets as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by defining an array of four integers and initialize
    all four values. In the next line, we retrieve the element at index `1` and put
    the value in the `myInt` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be incorrect to think the `myInt` variable contains the number `1`
    because arrays are zero indexed which means the first value would be at index
    `0` therefore the `myInt` variable contains the number `2`. The following code
    shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What this code shows is when we declared an array of four integers the valid
    indexes for this array start at `0` and end at `3`. Now that we know how to access
    an array let''s see what happens when we access elements that aren''t initialized.
    Add the following code in the `setup()` function of a sketch and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Serial Monitor, you will see five values printed out but they can be
    any valid integer value because the elements were never initialized. Assigning
    a new value to an element in the array is exactly like assigning a value to any
    variable. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined an array of two integers and then assigned
    the value of `0` to the first element and a value of `1` to the second element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create multi-dimensional arrays, which are basically arrays of
    arrays. The following code shows two ways that we would define a 3 × 4 array of
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Elements in a multidimensional array are accessed by the indexes just like
    a single dimensional array. The following code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to use arrays, let's see how we can use character
    arrays to store words and sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Character arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw earlier in this chapter that we can use the character (`char`) type
    to store a single character; however, what if we wanted to store whole words or
    sentences? We can use an array of characters to do this. Character arrays can
    be initiated exactly like other arrays as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Generally, character arrays are called **strings**. In the preceding code, we
    define an uninitialized string that can contain up to ten characters and also
    a character array that contains the word *Arduino*.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that at the end of the *Arduino* string there is a `\0` character.
    This character represents a null. When defining a string we should always terminate
    the string with the null character, this is called **Null Termination**. By ending
    the string with a null character, functions like the `serial.println()` function
    know where in memory the string ends. Without the null characters, these functions
    would continue to read memory until a null character is encountered, which will
    cause a lot of garbage to appear in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are easier ways to declare a string as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first line initializes a string containing the word
    Arduino and the array is automatically sized with the null terminator added at
    the end. In the second line, we initialize a string that contains the word Arduino
    and contains additional space. The null terminator is added at the end of the
    work Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino language does contain a separate string object; however, you will
    find that character arrays are used a lot in the sample code. We will look at
    the string object in [Chapter 7](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml),
    *Programming the Arduino – Beyond the Basics.*
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use variables and arrays, let's look at how to
    define a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A constant is a value that never changes. In the Arduino programming language,
    we have two ways to declare constants. We can use the `const` keyword or the `#define`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The `#define` component enables us to give a name to a constant value prior
    to the application being compiled. The compiler will replace all references to
    these constants, with the assigned value, prior to the application being compiled.
    This means that the defined constants do not take up any program space in memory,
    which may be an advantage if you are trying to squeeze a large program into an
    Arduino Nano.
  prefs: []
  type: TYPE_NORMAL
- en: The `#define` component does have some drawbacks where the biggest drawback
    being if the name that is defined for the constant is also included in some other
    constant or variable name then the name would be replaced by the value defined
    in the `#define` component. For this reason, when I use the `#define` to define
    a constant I usually use all capital letters for the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `#define` component. You will note
    in the following code that with the `#define` component there is no semicolon
    at the end of the line. When using a directive like `#define`, you do not need
    to use a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The second way to declare a constant is to use the `const` keyword. The `const`
    keyword is a variable qualifier that modifies the variable's behavior making it
    read-only. This will enable us to use the variable exactly as we would any other
    variable except that we are unable to change the variable's value. If we attempted
    to change the value, we would receive a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `const` keyword is generally preferred of the `#define` component; however,
    with devices with limited memory the `#define` can be used. Now let's see how
    we can perform math functions in the Arduino programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino programming language includes operators that enable us to calculate
    the sum, difference, product and quotient of two operands. To use these operators,
    the two operands must be of the same type. This means, as an example, we have
    the ability to calculate the sum of two integer variables; however, we are unable
    to calculate the sum of a float variable and an integer variable without casting
    one of the variables forcing them to be of the same type. We will look at casting
    a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we calculate the sum, difference, product,
    and quotient of two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we perform a division operation there are times where we only need the
    remainder. For this, we can use the modulo operator. If we divided 5 by 2 the
    result would be 2.5, therefore with the modulo operator the result will be 5 since
    that is the remainder. The following code example shows how to use the modulo
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The Arduino programming language also includes compound assignment operators
    that enable us to combine the arithmetic and variable assignment operations. This
    enables us to perform an arithmetic operation and assign the result to the original
    variable. The following code shows the compound operators in the Arduino programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also numerous math functions that enable us to perform various common
    math functions. The following code shows some of the more common functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen the arithmetic operators and functions that the Arduino
    programming language provides, let's look at the comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Arduino programming language includes comparison operators that enable
    us to compare the values of two operands. The comparison operators return a Boolean
    value indicating if the comparison was true or false. The following code shows
    how we would use these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen the comparison operators that the Arduino programming
    language provides, let's look at the logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several logical operators included in the Arduino programming language.
    These operators are the AND, OR and NOT operators. The NOT operator enables us
    to reverse a comparison operation. The AND and OR operators enable us to combine
    multiple comparison operators into one step. The following code shows how to use
    the logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how we can cast a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cast operator will convert the variable type to a different type. This will
    enable us to perform operations, like arithmetic operations, on variables of different
    types. For example, if we want to add two variables where one is of the float
    type and the other is of the integer type, then we will need to cast one of them,
    so the two variables are of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is when we cast a float value to an integer value the value
    is truncated and not rounded. This means that if the float variable contains the
    value 2.9 and we cast it to an integer, the value will be 2\. With this in mind,
    we generally want to cast integer values to float values rather than float values
    to integer values even if it means the operation will take longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we could cast an integer variable as a float variable
    to perform arithmetic calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are very few useful applications that we can write that do not have some
    sort of logic in them. This logic is usually performed by deciding what to do
    based on some input. This requires our applications to make decisions. Let's see
    how we can do this with the Arduino programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Decision making
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Arduino programming language, we make decisions with the `if` statement.
    The `if` statement will check if a condition is true and if so will execute the
    block of code within the curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the syntax for the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can use an `else` statement after the `if` statement to execute a block of
    code if the condition is not true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the syntax for the `if/else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition, in the `if` statement, can be any Boolean value or an operation
    that returns a Boolean result. You will find that the majority of the `if` statements
    in your code will contain comparison operations. Let''s look at some code that
    will illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the greater than (`>`) comparison operator to
    see if `varA` is greater than `varB`. If the comparison operation returned `true`
    then the code sends the `varA is greater than varB` message to the console. If
    the comparison operation returned false then the `varB is greater or equal to
    varA` message is sent to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also string the `if` statements together by using an `if` statement
    with an `else` statement. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the equal (`==`) comparison operator to see if
    `varA` equaled `varB` and if so we send the `varA is equal to varB` message to
    the console. If they were not equal, we then used the greater than (`>`) comparison
    operator to see if `varA` is greater than `varB` and if so we send the `varA is
    greater than varB` message to the console. If neither one of the two comparison
    operations were successful we then send the `varA is equal to varB` message to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `else` and `if` statements together, the code will execute the
    first block of code that returns a `true` condition and will then ignore the remainder
    of the `else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `if` and `else` statements is the most common way to perform logic
    within an application; however, the code can get very messy if we have more than
    two or three conditions to check. Just imagine if the last `if`/`else` example
    has ten different conditions that we needed to check. If there is a need to check
    more than two or three conditions, we can use the `switch`/`case` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `switch`/`case` statement takes a value, compares it to the several possible
    matches, and executes the appropriate block of code based on the first successful
    match. The `switch` statement is an alternative to using multiple `else-if` statements
    when there could be several possible matches. The `switch` statement is preferred
    over the `else-if` statements if there are three or more possible matches. The
    `switch` statement takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code starts off with a switch statement and within the parenthesis
    of the `switch` statement, there is a variable named `var`. The code will attempt
    to match the value of the `var` variable with each case statement starting with
    the first one and once it finds a match it will execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: The code within each `case` statement should end with a `break` statement. The
    `break` statement is needed because once the `switch` statement matches a case
    it will not only execute the code within that `case` statement but also the code
    in each subsequent `case` statement. This means that if we did not include the
    `break` statements and the `var` variable matched the value in the `match2` case,
    the code within the `match2` case, the `match3` case and default will all execute.
    The code encounters the `break` statement it immediately exits out of the `switch`
    statement preventing the code in the other `case` statements from executing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to make decisions in the Arduino programming language,
    let's look at how to perform looping.
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino programming language has three looping statements which are the
    `for`, `while` and `do`/`while` loops. We will start off by looking at the `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop is used to repeatedly execute a block of code. The `for` loop
    is usually used to execute a block of code a specific number of times or to access
    elements in an array. There are three parts to the `for` statement. These parts
    are the initialization, condition, and increment.
  prefs: []
  type: TYPE_NORMAL
- en: In the initialization portion of the `for` statement, we initialize any variables
    that need to be initialized. There can be multiple initializations separated by
    commas, but I would recommend avoiding any initialization here that is not directly
    related to the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The condition portion of the `for` statement, expect a statement that will return
    either a `true` or `false` and it usually contains a conditional statement. This
    portion of the loop determines when the loop will end. While the conditional statement
    returns `true`, the `for` loop will continue to execute the block of code. Once
    the conditional statement returns `false` the loop will exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The increment portion of the `for` statement is used to change the value of
    a variable. This change is performed each time the loop is executed. The following
    code shows the syntax for the `for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how this would look with actual code, the following shows how we would
    create a `for` statement that will loop ten times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the for statement initializes the `i` variable to zero
    in the initialization portion. In the condition portion, the `for` statements
    checks to see if the `i` variable is less than ten and if it is, the code will
    continue to loop. In the change portion, the `for` loop increments the `i` variable
    by one each time the loop is executed. In the example, the `for` loop will initially
    assign the value of `0` to the `i` variable and then increment it each loop until
    the `i` variable is equal to `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next loop that we will look at is the `while` loop. The `while` loop will
    repeatedly execute a block of code until the condition defined in the `while`
    statement returns `false`. This can be a dangerous loop to use because if the
    condition never returns `false` then the loop will continue indefinitely. The
    `while` statement takes the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition within the `while` statement should return either `true` or `false`.
    This condition is usually a comparison statement. The following code shows an
    example of the `while` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the block of code is executed while the `x` variable
    is less than `200`. At the end of the code block, the `x` variable is incremented
    by 1\. If we had forgotten to put the line that incremented `x` in the code block
    then the `while` loop would loop indefinitely. It is very important to make sure
    you put the change statement within the code block, otherwise the loop will never
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: With the `while` loop, the condition is checked prior to the block of code being
    executed. That means that if the conditions return `false` when the `while` statement
    is first called then the code block would never be executed. If we require that
    the block of code be executed once, prior to the condition being check, we can
    use the `do/while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `do`/`while` loop is exactly like the `while` loop except that the condition
    is checked after the block of code is executed rather than before. The following
    code shows the syntax for this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `while` loop, the condition within the `while` statement should
    return either a `true` or `false` and is usually a comparison statement. The following
    codes show an example of the `do`/`while` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will execute the block of code 200 times, exactly like the
    code in the previous `while` loop. The only difference is, in the `while` loop,
    the condition is checked prior to executing the block of code and in the `do`/`while`
    loop the condition is checked after.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function is a named block of code that performs a specific task. When a new
    sketch is created, the IDE or Web Editor automatically creates two functions for
    us as we saw in the previous chapter; however, we are not limited to only those
    two functions, we also have the ability to declare custom functions ourselves.
    The following code shows the syntax for creating a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To declare a function, we need to declare what type the function is. The function
    type is the value that is returned by the function. If the function is not going
    to return a value, as with the `setup()` and `loop()` functions, then the function
    type would be `void`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the function type is declared we define the name of the function. The function
    name should be something that describes what the function does. For example, if
    we are creating a sketch that will turn a LED on or off, then we may have functions
    named `ledOff()` and `ledOn()`. It is good practice to use camel case when naming
    a function as with variables.
  prefs: []
  type: TYPE_NORMAL
- en: After the name of the function, we put the parameters of the function within
    parentheses. Parameters are data that are passed to the function by the code that
    calls it. The function usually relies on the data to perform it's required logic.
    You may have multiple parameters within the parentheses by separating them with
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use curly brackets to define the start and end of the code block for the
    function. The left curly bracket indicates the start of the function while the
    right curly bracket indicates the end of the function. The following examples
    show different examples of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first function has a return type of `void` which means it does not return
    any value. It also does not have any parameters. This type of function would be
    used to perform a task that does not need to return any information back to the
    code that called it and does not require any additional information to perform
    its required task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function also has a return type of `void`, but it does accept one
    parameter. This type of function would be used if the function needs some information,
    from the code that called it, to perform its task. The first part of the parameter
    is the parameter type. In this example, the type is an `int`, which means the
    data will be of the integer type. The second part of the parameter is the name
    of the parameter. This would mean that the parameter in this example is named
    `param` and is of the integer type. To declare multiple parameters, we would separate
    them with commas like this: `(int param1, int param2, float param3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The third function has an `int` return type, which means it must return an integer;
    however, it does not take any parameters. This type of function would be used
    if we wanted to pass information from the function back to the code that called
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth function returns an integer and accepts a parameter. This type of
    function would be used if we wanted to pass information back to the code that
    called it and it needed information from that code to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `return` statement to return a value from a function. The following
    code shows how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When a variable is created within a function, as we saw in the last example,
    the variable is only accessible within that function. The following code illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `g` variable, since it is declared outside of the
    functions, is accessible by any of the functions. When you declare a variable
    outside of the functions like this it is considered to be a global variable. The
    `x1` variable is only accessible within the `myFunction1()` function and the `x2`
    variable is accessible only within the `myFunction2()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of the Arduino programming language.
    The material in this chapter lays the groundwork for everything else that is covered
    in this book, therefore, it is important to understand the items presented here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some more advanced features of the Arduino
    programming language and the Arduino development environments.
  prefs: []
  type: TYPE_NORMAL
