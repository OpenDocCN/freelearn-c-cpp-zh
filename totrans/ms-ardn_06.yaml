- en: Programming the Arduino - The Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程 Arduino - 基础知识
- en: I have been programming as long as I can remember, everything from teletypes
    and mainframes to personal computers and embedded devices. I have programmed games,
    business applications, websites and mobile apps but I can honestly say that I
    enjoy programming microcontroller boards like the Arduino the most.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我编程的时间已经很长了，从电传打字机和大型机到个人电脑和嵌入式设备，我编写过游戏、商业应用、网站和移动应用，但我可以诚实地说我最喜欢编程微控制器板，如
    Arduino。
- en: The reason for this is with microcontrollers my programs can interact with the
    outside world through various sensors and motors rather than programming for simple
    human interaction. With microcontrollers we are only limited by our imagination
    and ingenuity however before we can begin conquering the world, we must first
    learn the basics of the Arduino programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，对于微控制器，我的程序可以通过各种传感器和电机与外部世界交互，而不是为简单的用户交互编程。使用微控制器，我们只受限于我们的想象力和独创性；然而，在我们开始征服世界之前，我们必须首先学习
    Arduino 编程语言的基础知识。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What variables and constants are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和常量的含义以及如何使用它们
- en: What math functions the Arduino programming language offer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino 编程语言提供的数学函数
- en: How to add comments to our code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何给我们的代码添加注释
- en: How to make decisions with the Arduino programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Arduino 编程语言进行决策
- en: How to create loops to repeat blocks of code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建循环以重复代码块
- en: In [Chapter 5](b7889fa4-0da5-4063-838a-51b8d57f71ac.xhtml), *Arduino IDE* we
    learned how to use the Arduino IDE and the Web Editor. We also examined the `setup()`
    and `loop()` functions and learned how to use them. In this chapter and [Chapter
    7](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml), *Programming the Arduino–Beyond
    the Basics*, we will learn about the Arduino programming language and how to use
    the language to develop applications for the Arduino. Let's start off by looking
    at the curly brackets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](b7889fa4-0da5-4063-838a-51b8d57f71ac.xhtml) *Arduino IDE* 中，我们学习了如何使用
    Arduino IDE 和 Web 编辑器。我们还检查了`setup()`和`loop()`函数，并学习了如何使用它们。在本章和[第 7 章](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml)
    *编程 Arduino – 超越基础知识* 中，我们将学习 Arduino 编程语言以及如何使用该语言为 Arduino 开发应用程序。让我们从查看花括号开始。
- en: Curly brackets
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 花括号
- en: The left curly brackets ( { ) defines where a block of code starts and the right
    curly bracket ( } ) defines where it ends. We saw these brackets when we looked
    at the `setup()` and `loop()` functions; however, curly brackets are not limited
    to defining the code within a function they are also used to define other blocks
    of code as well. We will see examples of this in the *Decision making* and *Looping*
    sections of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 左花括号（{）定义了代码块开始的位置，而右花括号（}）定义了结束的位置。我们在查看`setup()`和`loop()`函数时看到了这些括号；然而，花括号不仅限于定义函数内的代码，它们还用于定义其他代码块。我们将在本章的*决策*和*循环*部分看到这方面的例子。
- en: Whenever there is a left curly bracket there must also be a right curly bracket.
    We say that the curly brackets are balanced when we have an equal number of left
    and right curly brackets. Unbalanced curly brackets can lead to crypt compiler
    errors. If you are receiving very crypt and hard to understand compiler errors,
    you may want to begin your troubleshooting by verifying that the curly brackets
    are balanced.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有左花括号时，也必须有一个右花括号。当我们左右花括号数量相等时，我们说花括号是平衡的。不平衡的花括号可能导致编译器错误。如果你收到非常复杂且难以理解的编译器错误，你可能想从验证花括号是否平衡开始进行故障排除。
- en: Now let's look at semicolons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看分号的使用。
- en: Semicolons
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分号
- en: A semicolon is used at the end of every statement to separate one statement
    from the next. If a statement does not end with a semicolon it will result in
    a compile-time error. The error text for forgetting a semicolon is pretty obvious
    and will include the line number of the statement that is missing it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句的末尾都使用分号来分隔一个语句与下一个语句。如果一个语句不以分号结束，将导致编译时错误。忘记分号的错误文本非常明显，并将包括缺少分号的语句的行号。
- en: Semicolons are also used in the `for` loop to separate the different elements.
    We will look at the `for` loop in the *Looping* section of this chapter. Now let's
    look at how we can add comments to our code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 分号也用于`for`循环中，以分隔不同的元素。我们将在本章的*循环*部分查看`for`循环。现在让我们看看我们如何给我们的代码添加注释。
- en: Comments
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: There are two types of comments that can be used to within our Arduino code.
    These are block comments and line comments. Block comments are used when the text
    of the comment will span multiple lines and are usually used before function calls
    to let the reader know what a function does. The line comments are used when a
    short one-line comment is needed and are usually used within function blocks to
    let the reader know what a specific line of code is doing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Arduino 代码中可以使用两种类型的注释。这些是块注释和行注释。块注释用于注释文本跨越多行的情况，通常用于函数调用之前，让读者知道函数的作用。行注释用于需要简短的单行注释的情况，通常用于函数块内，让读者知道特定代码行的作用。
- en: 'A block comment begins with `/*` and ends with `*/`. The following code shows
    what a block comment would look like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 块注释以 `/*` 开头，以 `*/` 结尾。以下代码展示了块注释的外观：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A line comment starts with `//` and goes until the end of the line. The line
    comment can start at the beginning of the line or it may be after a statement
    ends. The following examples show what a line comment would look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 行注释以 `//` 开头，直到行尾。行注释可以位于行的开头，或者可以在语句结束后。以下示例展示了行注释的外观：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is always a good idea to add comments to your code to let the reader know
    what certain blocks of code are doing. Now let's look at what variables are.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总是给代码添加注释，让读者知道某些代码块的作用是一个好主意。现在让我们看看什么是变量。
- en: Variables
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: A variable is used to store information that can be referenced or manipulated
    within the code. A variable is given a unique name which can then be used to access
    the information. The name of the variable should be something that describes what
    the variable is so anyone that looks at the code will understand what the variable
    is used for. Camel case should be used when naming a variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 变量用于在代码中存储可以引用或操作的信息。变量被赋予一个唯一的名称，然后可以使用该名称访问信息。变量的名称应该是描述变量内容的，这样任何查看代码的人都能理解变量用于什么。
- en: Camel case is used when creating a name out of multiple words are phases where
    the first letter of the name is lowercase, but the beginning of each remaining
    word is uppercase. Some examples of camel case are ledOne, myVariable and redLedOnRightSide.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当从多个单词或短语创建名称时，使用驼峰式命名法，其中名称的第一个字母小写，但每个剩余单词的开头字母大写。一些驼峰式命名的例子有 ledOne、myVariable
    和 redLedOnRightSide。
- en: 'When a variable is declared it is usually a good idea to give it an initial
    value. This helps to avoid accidentally accessing the variable prior to initializing
    it. To declare a variable, we define the type of variable followed by the name
    of the variable and then if we are going to give it an initial value we add the
    equal sign followed by the initial value. The following code shows how we would
    do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个变量时，通常给它一个初始值是一个好主意。这有助于避免在初始化之前意外访问变量。要声明一个变量，我们定义变量的类型，然后是变量的名称，然后如果我们打算给它一个初始值，我们添加等号后跟初始值。以下代码展示了我们如何这样做：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding line of code, we declared a variable named `myInt` of the integer
    (`int`) type with an initial value of `0`. Let's look at some of the more popular
    built-in data types that we can use with the Arduino language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们声明了一个名为 `myInt` 的整型 (`int`) 变量，并赋予其初始值 `0`。让我们看看一些在 Arduino 语言中使用的一些更流行的内置数据类型。
- en: Data types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: There are numerous, built-in, data types in the Arduino programming language.
    In this section, we will look at the most commonly used ones. Let's begin by looking
    at the Boolean type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 编程语言中有许多内置的数据类型。在本节中，我们将查看最常用的类型。让我们首先看看布尔类型。
- en: Boolean
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔
- en: 'The Boolean data type can contain one of two possible values, `true` or `false`.
    The following example shows how to declare a variable to be of the Boolean type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型可以包含两个可能的值之一，`true` 或 `false`。以下示例展示了如何声明一个布尔类型的变量：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code declares a variable named `myBool` of the Boolean type and
    sets an initial value of `true`. Boolean types are used a lot within a standard
    Arduino program and all comparison operations, as we will see later in this chapter,
    return a Boolean value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了一个名为 `myBool` 的布尔类型变量，并设置了初始值 `true`。布尔类型在标准的 Arduino 程序中使用得很多，所有比较操作，正如我们将在本章后面看到的，都返回布尔值。
- en: Byte
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节
- en: 'The byte data type is an 8-bit numerical value that ranges from 0 to 255\.
    The following shows how we would declare a variable of the byte type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` 数据类型是一个 8 位数值，其范围从 0 到 255。以下展示了如何声明 `byte` 类型的变量：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code declares a variable named `myByte` of the `byte` type with
    an initial value of `128`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了一个名为 `myByte` 的 `byte` 类型变量，其初始值为 `128`。
- en: Integer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: The integer is the primary data type used to store numerical data when a decimal
    value is not needed. A variable of the integer type can contain numbers ranging
    from -32,768 to 32,768\. An integer is defined using the `int` keyword.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型是当不需要小数时存储数值数据的主要数据类型。整数类型的变量可以包含从 -32,768 到 32,768 的数字。整数使用 `int` 关键字定义。
- en: 'We can declare an integer to be unsigned by using the `unsigned` keyword. An
    unsigned integer can range from 0 to 65,535 whereas the normal integer has a range
    of -32,768 to 32,768\. The following code shows how we would define both a regular
    integer and an unsigned integer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `unsigned` 关键字声明一个无符号整数。无符号整数可以从 0 到 65,535，而正常整数范围是 -32,768 到 32,768。以下代码展示了如何定义一个常规整数和一个无符号整数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we declared a variable named `mySignedInt` of the integer
    type with an initial value of `25`. We also declared a second variable named `myUnsignedInt`
    of the unsigned integer type with an initial value of `15`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为 `mySignedInt` 的整数类型变量，其初始值为 `25`。我们还声明了一个名为 `myUnsignedInt`
    的无符号整数类型变量，其初始值为 `15`。
- en: On some Arduino boards like the Due or SAMD, the integer can store values larger
    than the 32,768 and smaller than the -32,768 value. Since most of the boards have
    an integer range of -32,768 to 32,768, I would recommend always assuming that
    is the range you can use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些 Arduino 板（如 Due 或 SAMD）上，整数可以存储大于 32,768 和小于 -32,768 的值。由于大多数板子的整数范围是 -32,768
    到 32,768，我建议始终假设你可以使用这个范围。
- en: Long
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长
- en: 'The long data type can store integers from -2,147,483,648 to 2,147,483,647\.
    The following code shows how we would define a long variable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`long` 数据类型可以存储从 -2,147,483,648 到 2,147,483,647 的整数。以下代码展示了如何定义 `long` 变量：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we declared a variable named `myLong` of the `long` type
    and gave it a value of 123,456,789\. It is good practice to avoid using the long
    data type unless it is necessary to store larger numbers because it uses more
    memory than the integer type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为 `myLong` 的 `long` 类型变量，并给它赋值为 123,456,789。如果需要存储比整数类型更大的数字，则应避免使用
    `long` 数据类型，因为它比整数类型使用更多的内存。
- en: Double and float
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`double` 和 `float`'
- en: Double and float data types are floating point numbers which means they are
    numbers that can contain a decimal point. Both the double and float types can
    hold values ranging from -3.4028235E+38 to 3.4028235E+38.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 和 `float` 数据类型是浮点数，这意味着它们可以包含小数点。`double` 和 `float` 类型都可以存储从 -3.4028235E+38
    到 3.4028235E+38 的值。'
- en: On most platforms, the float data type has a precision of six or seven decimal
    digits while the double data type usually has fifteen digits; however, this is
    not true on the Arduino platform. On the Arduino platform, the double and float
    types are exactly the same, therefore they both have the precision to six or seven
    decimal digits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数平台上，`float` 数据类型的精度为六或七位小数，而 `double` 数据类型通常有十五位小数；然而，在 Arduino 平台上并非如此。在
    Arduino 平台上，`double` 和 `float` 类型完全相同，因此它们都具有六或七位小数的精度。
- en: There are two very good reasons not to use a double or float value unless you
    absolutely need a decimal number. The first reason is with precision inaccuracy,
    as an example 6.0 divided by 3.0 may not always equal 2\. You may end up getting
    something like 1.9999999999\. The second reason is floating point math is much
    slower than integer math.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个非常好的理由不使用 `double` 或 `float` 值，除非你绝对需要小数。第一个原因是精度不准确，例如，6.0 除以 3.0 可能并不总是等于
    2。你可能会得到类似 1.9999999999 的结果。第二个原因是浮点数运算比整数运算慢得多。
- en: 'The following code shows how to define both a double and float variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何定义一个 `double` 和 `float` 变量：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we declare a variable named `myDouble` of the `double`
    type with a value of `1.25`. We also declare a variable named `myFloat` of the
    `float` type with a value of `1.5`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为 `myDouble` 的 `double` 类型变量，其值为 `1.25`。我们还声明了一个名为 `myFloat`
    的 `float` 类型变量，其值为 `1.5`。
- en: Character
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符
- en: 'The char data type is usually described as the data type that stores a character,
    however, this is not technically correct. The char data type stores a character
    as a numeric value based on the ASCII chart. When a char variable is defined,
    it can be defined with either the number that represents the character or the
    character itself as shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`数据类型通常被描述为存储字符的数据类型，然而，这在技术上是不正确的。`char`数据类型将字符存储为基于ASCII表的数值。当定义一个`char`变量时，它可以定义为表示字符的数字或字符本身，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, both lines declare a variable named `myChar` of the `char`
    type with a capital `A` as the value. Having a type that can hold only a single
    character is useful, but it would be more useful if we could store entire words
    or sentences. Later in this chapter, we will see how we can store words or sentences
    by using an array of characters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两行都声明了一个名为`myChar`的`char`类型变量，其值为大写字母`A`。能够只存储单个字符的类型是有用的，但如果可以存储整个单词或句子会更有用。在本章的后面部分，我们将看到如何通过使用字符数组来存储单词或句子。
- en: Arrays
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is an ordered collection of variables which are of the same type.
    Each variable in the array is called an **element**, and these elements can be
    accessed by the location (index) in the array. When an array is defined we must
    declare the type of variables that will be stored in it. There are several ways
    that an array can be defined. The following examples show some of the basic ways
    to define an array:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是有序变量的集合，这些变量类型相同。数组中的每个变量称为**元素**，这些元素可以通过数组中的位置（索引）来访问。当定义一个数组时，我们必须声明将要存储在其中的变量的类型。定义数组有多种方式。以下示例展示了定义数组的一些基本方法：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of these examples defines an array of integers. The first example defines
    an uninitialized array of ten integers. Be careful when defining uninitialized
    arrays because the memory locations are never initialized, which could lead to
    very unexpected results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的每一个都定义了一个整数数组。第一个示例定义了一个未初始化的包含十个整数的数组。在定义未初始化的数组时要小心，因为内存位置永远不会初始化，这可能导致非常意外的结果。
- en: The second example defines an array of four integers were all of the elements
    are initialized with values. This array is automatically sized to the number of
    elements that is in the initialization array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例定义了一个包含四个整数的数组，所有元素都初始化了值。此数组自动调整大小以匹配初始化数组中的元素数量。
- en: The last example defines an array of eight integers where the first five elements
    are initialized with values, but the last three elements are not initialized.
    Once again, I would recommend not defining an array like this because the last
    three elements are not initialized. In a moment, we will see what happens when
    we attempt to access an element in an array whose value was not initialized but
    first we need to see how we would access elements in an array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例定义了一个包含八个整数的数组，其中前五个元素初始化了值，但最后三个元素未初始化。再次建议不要定义这样的数组，因为最后三个元素未初始化。一会儿我们将看到当我们尝试访问一个未初始化值的数组元素时会发生什么，但首先我们需要看到我们如何访问数组中的元素。
- en: 'We access an element in an array by the index. We put the index of the element
    we wish to retrieve between two square brackets as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过索引访问数组中的元素。我们将要检索的元素的索引放在两个方括号之间，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we begin by defining an array of four integers and initialize
    all four values. In the next line, we retrieve the element at index `1` and put
    the value in the `myInt` variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先定义了一个包含四个整数的数组并初始化了所有四个值。在下一行中，我们检索索引`1`处的元素并将值放入`myInt`变量中。
- en: 'It would be incorrect to think the `myInt` variable contains the number `1`
    because arrays are zero indexed which means the first value would be at index
    `0` therefore the `myInt` variable contains the number `2`. The following code
    shows how this works:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 认为变量`myInt`包含数字`1`是不正确的，因为数组是零索引的，这意味着第一个值将在索引`0`处，因此`myInt`变量包含数字`2`。以下代码展示了这是如何工作的：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What this code shows is when we declared an array of four integers the valid
    indexes for this array start at `0` and end at `3`. Now that we know how to access
    an array let''s see what happens when we access elements that aren''t initialized.
    Add the following code in the `setup()` function of a sketch and run it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示的是当我们声明了一个包含四个整数的数组时，这个数组的有效索引从`0`开始，到`3`结束。现在我们知道了如何访问数组，让我们看看当我们访问未初始化的元素时会发生什么。在脚本的`setup()`函数中添加以下代码并运行它：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the Serial Monitor, you will see five values printed out but they can be
    any valid integer value because the elements were never initialized. Assigning
    a new value to an element in the array is exactly like assigning a value to any
    variable. The following code shows this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行监视器中，你会看到打印出五个值，但它们可以是任何有效的整数值，因为元素从未被初始化。将新值赋给数组中的元素就像将值赋给任何变量一样。以下代码显示了这一点：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we defined an array of two integers and then assigned
    the value of `0` to the first element and a value of `1` to the second element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个包含两个整数的数组，并将值`0`赋给第一个元素，将值`1`赋给第二个元素。
- en: 'We can also create multi-dimensional arrays, which are basically arrays of
    arrays. The following code shows two ways that we would define a 3 × 4 array of
    integers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建多维数组，它们基本上是数组的数组。以下代码显示了两种定义3×4整数数组的方法：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Elements in a multidimensional array are accessed by the indexes just like
    a single dimensional array. The following code shows how to do this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组中的元素可以通过索引访问，就像单维数组一样。以下代码显示了如何做到这一点：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have seen how to use arrays, let's see how we can use character
    arrays to store words and sentences.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用数组，让我们看看我们如何使用字符数组来存储单词和句子。
- en: Character arrays
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符数组
- en: 'We saw earlier in this chapter that we can use the character (`char`) type
    to store a single character; however, what if we wanted to store whole words or
    sentences? We can use an array of characters to do this. Character arrays can
    be initiated exactly like other arrays as the following code shows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们看到了我们可以使用字符（`char`）类型来存储单个字符；然而，如果我们想存储整个单词或句子呢？我们可以使用字符数组来做到这一点。字符数组可以像其他数组一样初始化，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Generally, character arrays are called **strings**. In the preceding code, we
    define an uninitialized string that can contain up to ten characters and also
    a character array that contains the word *Arduino*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字符数组被称为**字符串**。在前面代码中，我们定义了一个未初始化的字符串，它可以包含多达十个字符，还有一个包含单词*Arduino*的字符数组。
- en: You may notice that at the end of the *Arduino* string there is a `\0` character.
    This character represents a null. When defining a string we should always terminate
    the string with the null character, this is called **Null Termination**. By ending
    the string with a null character, functions like the `serial.println()` function
    know where in memory the string ends. Without the null characters, these functions
    would continue to read memory until a null character is encountered, which will
    cause a lot of garbage to appear in the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在*Arduino*字符串的末尾有一个`\0`字符。这个字符代表一个空字符。当我们定义一个字符串时，我们应该始终以空字符结束字符串，这被称为**空终止**。通过以空字符结束字符串，像`serial.println()`这样的函数就知道字符串在内存中的结束位置。如果没有空字符，这些函数将继续读取内存，直到遇到空字符，这将在控制台中产生大量垃圾。
- en: 'There are easier ways to declare a string as the following code shows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有更简单的方式来声明一个字符串，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the first line initializes a string containing the word
    Arduino and the array is automatically sized with the null terminator added at
    the end. In the second line, we initialize a string that contains the word Arduino
    and contains additional space. The null terminator is added at the end of the
    work Arduino.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一行初始化了一个包含单词Arduino的字符串，数组自动调整大小，并在末尾添加了空终止符。在第二行中，我们初始化了一个包含单词Arduino的字符串，并包含额外的空间。空终止符被添加到单词Arduino的末尾。
- en: The Arduino language does contain a separate string object; however, you will
    find that character arrays are used a lot in the sample code. We will look at
    the string object in [Chapter 7](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml),
    *Programming the Arduino – Beyond the Basics.*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino语言确实包含一个单独的字符串对象；然而，你会发现字符数组在示例代码中用得很多。我们将在[第7章](97f86abb-08ca-4f9d-b4dd-c6f49c0949a1.xhtml)中查看字符串对象，*Arduino编程——超越基础*。
- en: Now that we have seen how to use variables and arrays, let's look at how to
    define a constant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用变量和数组，让我们看看如何定义一个常量。
- en: Constants
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: A constant is a value that never changes. In the Arduino programming language,
    we have two ways to declare constants. We can use the `const` keyword or the `#define`
    component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是一个永远不会改变的值。在Arduino编程语言中，我们有两种声明常量的方式。我们可以使用`const`关键字或`#define`组件。
- en: The `#define` component enables us to give a name to a constant value prior
    to the application being compiled. The compiler will replace all references to
    these constants, with the assigned value, prior to the application being compiled.
    This means that the defined constants do not take up any program space in memory,
    which may be an advantage if you are trying to squeeze a large program into an
    Arduino Nano.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define`组件使我们能够在应用程序编译之前给一个常量值命名。编译器将在应用程序编译之前替换所有对这些常量的引用，用分配的值替换。这意味着定义的常量在内存中不占用任何程序空间，如果您试图将大型程序压缩到Arduino
    Nano中，这可能是一个优点。'
- en: The `#define` component does have some drawbacks where the biggest drawback
    being if the name that is defined for the constant is also included in some other
    constant or variable name then the name would be replaced by the value defined
    in the `#define` component. For this reason, when I use the `#define` to define
    a constant I usually use all capital letters for the name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define`组件确实有一些缺点，其中最大的缺点是如果为常量定义的名称也包含在其他常量或变量名称中，则该名称将被`#define`组件中定义的值替换。因此，当我使用`#define`来定义常量时，我通常使用全部大写字母作为名称。'
- en: 'The following code shows how to use the `#define` component. You will note
    in the following code that with the `#define` component there is no semicolon
    at the end of the line. When using a directive like `#define`, you do not need
    to use a semicolon:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用`#define`组件。您将在以下代码中注意到，使用`#define`组件时，行尾没有分号。当使用像`#define`这样的指令时，您不需要使用分号：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second way to declare a constant is to use the `const` keyword. The `const`
    keyword is a variable qualifier that modifies the variable's behavior making it
    read-only. This will enable us to use the variable exactly as we would any other
    variable except that we are unable to change the variable's value. If we attempted
    to change the value, we would receive a compile-time error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 声明常量的第二种方式是使用`const`关键字。`const`关键字是一个变量限定符，它修改了变量的行为，使其变为只读。这将使我们能够像使用任何其他变量一样使用该变量，但我们无法更改变量的值。如果我们尝试更改值，我们将收到编译时错误。
- en: 'The following code shows how to use the `const` keyword:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用`const`关键字：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `const` keyword is generally preferred of the `#define` component; however,
    with devices with limited memory the `#define` can be used. Now let's see how
    we can perform math functions in the Arduino programming language.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`关键字通常比`#define`组件更受欢迎；然而，对于内存有限的设备，可以使用`#define`。现在让我们看看如何在Arduino编程语言中执行数学函数。'
- en: Arithmetic functions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术函数
- en: The Arduino programming language includes operators that enable us to calculate
    the sum, difference, product and quotient of two operands. To use these operators,
    the two operands must be of the same type. This means, as an example, we have
    the ability to calculate the sum of two integer variables; however, we are unable
    to calculate the sum of a float variable and an integer variable without casting
    one of the variables forcing them to be of the same type. We will look at casting
    a little later in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino编程语言包括运算符，使我们能够计算两个操作数的和、差、积和商。要使用这些运算符，两个操作数必须是同一类型。这意味着，例如，我们能够计算两个整型变量的和；然而，如果我们不将其中一个变量强制转换为同一类型，我们就无法计算浮点变量和整型变量的和。我们将在本章稍后讨论类型转换。
- en: 'The following example shows how we calculate the sum, difference, product,
    and quotient of two variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何计算两个变量的和、差、积和商：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we perform a division operation there are times where we only need the
    remainder. For this, we can use the modulo operator. If we divided 5 by 2 the
    result would be 2.5, therefore with the modulo operator the result will be 5 since
    that is the remainder. The following code example shows how to use the modulo
    operator:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行除法操作时，有时我们只需要余数。为此，我们可以使用取模运算符。如果我们用5除以2，结果将是2.5，因此使用取模运算符的结果将是5，因为那是余数。以下代码示例展示了如何使用取模运算符：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Arduino programming language also includes compound assignment operators
    that enable us to combine the arithmetic and variable assignment operations. This
    enables us to perform an arithmetic operation and assign the result to the original
    variable. The following code shows the compound operators in the Arduino programming
    language:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino编程语言还包括复合赋值运算符，使我们能够将算术和变量赋值操作结合起来。这使得我们能够在执行算术运算的同时将结果赋值给原始变量。以下代码展示了Arduino编程语言中的复合运算符：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are also numerous math functions that enable us to perform various common
    math functions. The following code shows some of the more common functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也有许多数学函数，使我们能够执行各种常见的数学运算。以下代码展示了其中一些更常见的函数：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have seen the arithmetic operators and functions that the Arduino
    programming language provides, let's look at the comparison operators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Arduino编程语言提供的算术运算符和函数，让我们来看看比较运算符。
- en: Comparison operators
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'The Arduino programming language includes comparison operators that enable
    us to compare the values of two operands. The comparison operators return a Boolean
    value indicating if the comparison was true or false. The following code shows
    how we would use these operators:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino编程语言包括比较运算符，使我们能够比较两个操作数的值。比较运算符返回一个布尔值，指示比较是否为真或假。以下代码展示了我们如何使用这些运算符：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have seen the comparison operators that the Arduino programming
    language provides, let's look at the logical operators.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Arduino编程语言提供的比较运算符，让我们来看看逻辑运算符。
- en: Logical operators
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'There are several logical operators included in the Arduino programming language.
    These operators are the AND, OR and NOT operators. The NOT operator enables us
    to reverse a comparison operation. The AND and OR operators enable us to combine
    multiple comparison operators into one step. The following code shows how to use
    the logical operators:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino编程语言中包含几个逻辑运算符。这些运算符是AND、OR和NOT运算符。NOT运算符使我们能够反转比较操作。AND和OR运算符使我们能够将多个比较运算符组合成一步。以下代码展示了如何使用逻辑运算符：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now let's see how we can cast a variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何进行变量类型转换。
- en: Casting
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: The cast operator will convert the variable type to a different type. This will
    enable us to perform operations, like arithmetic operations, on variables of different
    types. For example, if we want to add two variables where one is of the float
    type and the other is of the integer type, then we will need to cast one of them,
    so the two variables are of the same type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换运算符将变量类型转换为不同的类型。这将使我们能够在不同类型的变量上执行操作，例如算术运算。例如，如果我们想要将两个变量相加，其中一个为浮点类型，另一个为整型，那么我们需要将其中一个变量进行类型转换，以便两个变量具有相同的类型。
- en: One thing to note is when we cast a float value to an integer value the value
    is truncated and not rounded. This means that if the float variable contains the
    value 2.9 and we cast it to an integer, the value will be 2\. With this in mind,
    we generally want to cast integer values to float values rather than float values
    to integer values even if it means the operation will take longer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，当我们把浮点值转换为整型值时，值会被截断而不是四舍五入。这意味着如果浮点变量包含值为2.9，而我们将其转换为整型，值将是2。考虑到这一点，我们通常希望将整型值转换为浮点值，而不是将浮点值转换为整型值，即使这意味着操作会花费更长的时间。
- en: 'The following code shows how we could cast an integer variable as a float variable
    to perform arithmetic calculations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何将整型变量转换为浮点变量以执行算术计算：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are very few useful applications that we can write that do not have some
    sort of logic in them. This logic is usually performed by deciding what to do
    based on some input. This requires our applications to make decisions. Let's see
    how we can do this with the Arduino programming language.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写的几乎所有有用的应用程序都包含某种逻辑。这种逻辑通常是通过根据某些输入来决定做什么来实现的。这要求我们的应用程序做出决策。让我们看看如何使用Arduino编程语言来实现这一点。
- en: Decision making
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策
- en: In the Arduino programming language, we make decisions with the `if` statement.
    The `if` statement will check if a condition is true and if so will execute the
    block of code within the curly brackets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino编程语言中，我们使用`if`语句来做出决策。`if`语句将检查条件是否为真，如果是，将执行花括号内的代码块。
- en: 'The following shows the syntax for the `if` statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了`if`语句的语法：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can use an `else` statement after the `if` statement to execute a block of
    code if the condition is not true.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`if`语句之后使用`else`语句来执行一个代码块，如果条件不成立。
- en: 'The following shows the syntax for the `if/else` statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了`if/else`语句的语法：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The condition, in the `if` statement, can be any Boolean value or an operation
    that returns a Boolean result. You will find that the majority of the `if` statements
    in your code will contain comparison operations. Let''s look at some code that
    will illustrate this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句中的条件可以是任何布尔值或返回布尔结果的运算。你会发现你代码中的大多数`if`语句都将包含比较操作。让我们看看一些将说明这一点的代码：'
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we used the greater than (`>`) comparison operator to
    see if `varA` is greater than `varB`. If the comparison operation returned `true`
    then the code sends the `varA is greater than varB` message to the console. If
    the comparison operation returned false then the `varB is greater or equal to
    varA` message is sent to the console.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了大于（`>`）比较运算符来查看`varA`是否大于`varB`。如果比较操作返回`true`，则将`varA is greater
    than varB`消息发送到控制台。如果比较操作返回`false`，则将`varB is greater or equal to varA`消息发送到控制台。
- en: 'We can also string the `if` statements together by using an `if` statement
    with an `else` statement. The following code illustrates this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用带有`else`语句的`if`语句将`if`语句串联起来。以下代码说明了这一点：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, we used the equal (`==`) comparison operator to see if
    `varA` equaled `varB` and if so we send the `varA is equal to varB` message to
    the console. If they were not equal, we then used the greater than (`>`) comparison
    operator to see if `varA` is greater than `varB` and if so we send the `varA is
    greater than varB` message to the console. If neither one of the two comparison
    operations were successful we then send the `varA is equal to varB` message to
    the console.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了等于（`==`）比较运算符来查看`varA`是否等于`varB`，如果是这样，我们就将`varA is equal to varB`消息发送到控制台。如果不相等，我们随后使用大于（`>`）比较运算符来查看`varA`是否大于`varB`，如果是这样，我们就将`varA
    is greater than varB`消息发送到控制台。如果两个比较操作都不成功，我们就将`varA is equal to varB`消息发送到控制台。
- en: When using the `else` and `if` statements together, the code will execute the
    first block of code that returns a `true` condition and will then ignore the remainder
    of the `else` statements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`else`和`if`语句一起时，代码将执行第一个返回`true`条件的代码块，然后忽略`else`语句的其余部分。
- en: Using the `if` and `else` statements is the most common way to perform logic
    within an application; however, the code can get very messy if we have more than
    two or three conditions to check. Just imagine if the last `if`/`else` example
    has ten different conditions that we needed to check. If there is a need to check
    more than two or three conditions, we can use the `switch`/`case` statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`和`else`语句是在应用程序中执行逻辑的最常见方式；然而，如果我们需要检查两个或三个以上的条件，代码可能会变得非常混乱。只需想象一下，如果最后的`if`/`else`示例有十个不同的条件需要检查。如果需要检查两个或三个以上的条件，我们可以使用`switch`/`case`语句。
- en: 'The `switch`/`case` statement takes a value, compares it to the several possible
    matches, and executes the appropriate block of code based on the first successful
    match. The `switch` statement is an alternative to using multiple `else-if` statements
    when there could be several possible matches. The `switch` statement is preferred
    over the `else-if` statements if there are three or more possible matches. The
    `switch` statement takes the following format:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`/`case`语句接受一个值，将其与几个可能的匹配项进行比较，并根据第一个成功的匹配执行相应的代码块。当存在多个可能的匹配项时，`switch`语句是使用多个`else-if`语句的替代方案。如果有三个或更多的可能匹配项，则首选`switch`语句而不是`else-if`语句。`switch`语句的格式如下：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code starts off with a switch statement and within the parenthesis
    of the `switch` statement, there is a variable named `var`. The code will attempt
    to match the value of the `var` variable with each case statement starting with
    the first one and once it finds a match it will execute the code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码以`switch`语句开始，并在`switch`语句的括号内有一个名为`var`的变量。代码将尝试将`var`变量的值与每个从第一个开始的`case`语句进行匹配，一旦找到匹配项，它就会执行代码。
- en: The code within each `case` statement should end with a `break` statement. The
    `break` statement is needed because once the `switch` statement matches a case
    it will not only execute the code within that `case` statement but also the code
    in each subsequent `case` statement. This means that if we did not include the
    `break` statements and the `var` variable matched the value in the `match2` case,
    the code within the `match2` case, the `match3` case and default will all execute.
    The code encounters the `break` statement it immediately exits out of the `switch`
    statement preventing the code in the other `case` statements from executing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`case`语句中的代码应该以`break`语句结束。需要`break`语句是因为一旦`switch`语句匹配到某个`case`，它不仅会执行该`case`语句中的代码，还会执行每个后续`case`语句中的代码。这意味着如果我们没有包含`break`语句，并且`var`变量与`match2`中的值匹配，`match2`、`match3`和`default`中的代码都将执行。代码遇到`break`语句后立即退出`switch`语句，防止其他`case`语句中的代码执行。
- en: Now that we have seen how to make decisions in the Arduino programming language,
    let's look at how to perform looping.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在Arduino编程语言中做出决策，让我们看看如何执行循环。
- en: Looping
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: The Arduino programming language has three looping statements which are the
    `for`, `while` and `do`/`while` loops. We will start off by looking at the `for`
    loop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino编程语言有三种循环语句，即`for`循环、`while`循环和`do`/`while`循环。我们将从查看`for`循环开始。
- en: The `for` loop is used to repeatedly execute a block of code. The `for` loop
    is usually used to execute a block of code a specific number of times or to access
    elements in an array. There are three parts to the `for` statement. These parts
    are the initialization, condition, and increment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环用于重复执行代码块。`for`循环通常用于执行特定次数的代码块或访问数组中的元素。`for`语句有三个部分。这些部分是初始化、条件和增量。'
- en: In the initialization portion of the `for` statement, we initialize any variables
    that need to be initialized. There can be multiple initializations separated by
    commas, but I would recommend avoiding any initialization here that is not directly
    related to the `for` loop.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`语句的初始化部分，我们初始化需要初始化的任何变量。可以有多个初始化，用逗号分隔，但我建议避免在此处进行与`for`循环不直接相关的任何初始化。
- en: The condition portion of the `for` statement, expect a statement that will return
    either a `true` or `false` and it usually contains a conditional statement. This
    portion of the loop determines when the loop will end. While the conditional statement
    returns `true`, the `for` loop will continue to execute the block of code. Once
    the conditional statement returns `false` the loop will exit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的条件部分期望一个返回`true`或`false`的语句，它通常包含一个条件语句。这个循环部分决定了循环何时结束。当条件语句返回`true`时，`for`循环将继续执行代码块。一旦条件语句返回`false`，循环将退出。'
- en: 'The increment portion of the `for` statement is used to change the value of
    a variable. This change is performed each time the loop is executed. The following
    code shows the syntax for the `for` statement:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的增量部分用于改变变量的值。这种改变在每次循环执行时都会进行。以下代码展示了`for`语句的语法：'
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To see how this would look with actual code, the following shows how we would
    create a `for` statement that will loop ten times:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际代码的运行效果，以下展示了如何创建一个将循环十次的`for`语句：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the for statement initializes the `i` variable to zero
    in the initialization portion. In the condition portion, the `for` statements
    checks to see if the `i` variable is less than ten and if it is, the code will
    continue to loop. In the change portion, the `for` loop increments the `i` variable
    by one each time the loop is executed. In the example, the `for` loop will initially
    assign the value of `0` to the `i` variable and then increment it each loop until
    the `i` variable is equal to `9`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`for`语句在初始化部分将`i`变量初始化为零。在条件部分，`for`语句检查`i`变量是否小于十，如果是，代码将继续循环。在变化部分，每次循环执行时，`for`循环将`i`变量增加一。在示例中，`for`循环最初将`0`赋值给`i`变量，然后每次循环增加它，直到`i`变量等于`9`。
- en: 'The next loop that we will look at is the `while` loop. The `while` loop will
    repeatedly execute a block of code until the condition defined in the `while`
    statement returns `false`. This can be a dangerous loop to use because if the
    condition never returns `false` then the loop will continue indefinitely. The
    `while` statement takes the following syntax:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一个循环是`while`循环。`while`循环将重复执行一个代码块，直到`while`语句中定义的条件返回`false`。这可能是一个危险的循环，因为如果条件永远不会返回`false`，则循环将无限继续。`while`语句的语法如下：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The condition within the `while` statement should return either `true` or `false`.
    This condition is usually a comparison statement. The following code shows an
    example of the `while` statement:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句中的条件应该返回`true`或`false`。这个条件通常是一个比较语句。以下代码展示了`while`语句的示例：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, the block of code is executed while the `x` variable
    is less than `200`. At the end of the code block, the `x` variable is incremented
    by 1\. If we had forgotten to put the line that incremented `x` in the code block
    then the `while` loop would loop indefinitely. It is very important to make sure
    you put the change statement within the code block, otherwise the loop will never
    exit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，代码块在`x`变量小于`200`时执行。在代码块结束时，`x`变量增加1。如果我们忘记在代码块中放置增加`x`的行，那么`while`循环将无限循环。确保将更改语句放在代码块内非常重要，否则循环将永远不会退出。
- en: With the `while` loop, the condition is checked prior to the block of code being
    executed. That means that if the conditions return `false` when the `while` statement
    is first called then the code block would never be executed. If we require that
    the block of code be executed once, prior to the condition being check, we can
    use the `do/while` loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环时，条件在执行代码块之前被检查。这意味着如果当`while`语句首次被调用时条件返回`false`，则代码块将永远不会被执行。如果我们需要确保代码块在条件检查之前至少执行一次，我们可以使用`do/while`循环。
- en: 'The `do`/`while` loop is exactly like the `while` loop except that the condition
    is checked after the block of code is executed rather than before. The following
    code shows the syntax for this loop:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while`循环与`while`循环完全相同，只是条件是在执行代码块之后而不是之前被检查的。以下代码展示了这个循环的语法：'
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As with the `while` loop, the condition within the `while` statement should
    return either a `true` or `false` and is usually a comparison statement. The following
    codes show an example of the `do`/`while` statement:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环一样，`while`语句中的条件应该返回`true`或`false`，通常是一个比较语句。以下代码展示了`do/while`语句的示例：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code will execute the block of code 200 times, exactly like the
    code in the previous `while` loop. The only difference is, in the `while` loop,
    the condition is checked prior to executing the block of code and in the `do`/`while`
    loop the condition is checked after.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将执行代码块200次，这与上一个`while`循环中的代码完全一样。唯一的区别是，在`while`循环中，条件在执行代码块之前被检查，而在`do/while`循环中，条件在执行代码块之后被检查。
- en: Functions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'A function is a named block of code that performs a specific task. When a new
    sketch is created, the IDE or Web Editor automatically creates two functions for
    us as we saw in the previous chapter; however, we are not limited to only those
    two functions, we also have the ability to declare custom functions ourselves.
    The following code shows the syntax for creating a function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个具有特定任务的命名代码块。当创建一个新的草图时，IDE或Web编辑器会自动为我们创建两个函数，正如我们在上一章中看到的；然而，我们不仅限于只有这两个函数，我们还有能力自己声明自定义函数。以下代码展示了创建函数的语法：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To declare a function, we need to declare what type the function is. The function
    type is the value that is returned by the function. If the function is not going
    to return a value, as with the `setup()` and `loop()` functions, then the function
    type would be `void`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个函数，我们需要声明函数的类型。函数类型是函数返回的值。如果函数不打算返回值，就像`setup()`和`loop()`函数一样，那么函数类型将是`void`。
- en: Once the function type is declared we define the name of the function. The function
    name should be something that describes what the function does. For example, if
    we are creating a sketch that will turn a LED on or off, then we may have functions
    named `ledOff()` and `ledOn()`. It is good practice to use camel case when naming
    a function as with variables.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了函数类型，我们就定义函数的名称。函数名称应该是描述函数功能的。例如，如果我们正在创建一个可以打开或关闭LED的草图，那么我们可能会有名为`ledOff()`和`ledOn()`的函数。在命名函数时使用驼峰式命名法是一种良好的做法，就像变量一样。
- en: After the name of the function, we put the parameters of the function within
    parentheses. Parameters are data that are passed to the function by the code that
    calls it. The function usually relies on the data to perform it's required logic.
    You may have multiple parameters within the parentheses by separating them with
    commas.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名称之后，我们在括号内放置函数的参数。参数是通过调用它的代码传递给函数的数据。函数通常依赖于这些数据来执行其所需的逻辑。您可以在括号内通过逗号分隔来放置多个参数。
- en: 'We use curly brackets to define the start and end of the code block for the
    function. The left curly bracket indicates the start of the function while the
    right curly bracket indicates the end of the function. The following examples
    show different examples of functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用花括号来定义函数代码块的开始和结束。左花括号表示函数的开始，而右花括号表示函数的结束。以下示例展示了不同类型的函数：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first function has a return type of `void` which means it does not return
    any value. It also does not have any parameters. This type of function would be
    used to perform a task that does not need to return any information back to the
    code that called it and does not require any additional information to perform
    its required task.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数的返回类型是`void`，这意味着它不返回任何值。它也没有任何参数。这种类型的函数会被用来执行不需要返回任何信息回调用它的代码且不需要任何额外信息来执行其所需任务的任务。
- en: 'The second function also has a return type of `void`, but it does accept one
    parameter. This type of function would be used if the function needs some information,
    from the code that called it, to perform its task. The first part of the parameter
    is the parameter type. In this example, the type is an `int`, which means the
    data will be of the integer type. The second part of the parameter is the name
    of the parameter. This would mean that the parameter in this example is named
    `param` and is of the integer type. To declare multiple parameters, we would separate
    them with commas like this: `(int param1, int param2, float param3)`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数也有`void`类型的返回值，但它接受一个参数。这种类型的函数会在函数需要从调用它的代码中获取一些信息以执行其任务时使用。参数的第一部分是参数类型。在这个例子中，类型是`int`，这意味着数据将是整数类型。参数的第二部分是参数的名称。这意味着在这个例子中，参数名为`param`，是整数类型。要声明多个参数，我们可以用逗号将它们分开，如下所示：`(int
    param1, int param2, float param3)`。
- en: The third function has an `int` return type, which means it must return an integer;
    however, it does not take any parameters. This type of function would be used
    if we wanted to pass information from the function back to the code that called
    it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数的返回类型是`int`，这意味着它必须返回一个整数；然而，它不接受任何参数。如果我们想要从函数传递信息回调用它的代码，这种类型的函数会被使用。
- en: The fourth function returns an integer and accepts a parameter. This type of
    function would be used if we wanted to pass information back to the code that
    called it and it needed information from that code to perform its task.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个函数返回一个整数并接受一个参数。如果我们想要将信息传递回调用它的代码，并且需要从该代码中获取信息以执行其任务，这种类型的函数会被使用。
- en: 'We use the `return` statement to return a value from a function. The following
    code shows how we would do this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`return`语句从函数返回一个值。以下代码展示了如何做到这一点：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When a variable is created within a function, as we saw in the last example,
    the variable is only accessible within that function. The following code illustrates
    this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数内部创建变量时，就像我们在上一个示例中看到的那样，该变量只能在那个函数内部访问。以下代码说明了这一点：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, the `g` variable, since it is declared outside of the
    functions, is accessible by any of the functions. When you declare a variable
    outside of the functions like this it is considered to be a global variable. The
    `x1` variable is only accessible within the `myFunction1()` function and the `x2`
    variable is accessible only within the `myFunction2()` function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`g`变量，因为它是在函数外部声明的，所以可以被任何函数访问。当你像这样在函数外部声明变量时，它被视为一个全局变量。`x1`变量只能在`myFunction1()`函数内部访问，而`x2`变量只能在`myFunction2()`函数内部访问。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of the Arduino programming language.
    The material in this chapter lays the groundwork for everything else that is covered
    in this book, therefore, it is important to understand the items presented here.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Arduino编程语言的基础知识。本章中的材料为本书中涵盖的所有其他内容奠定了基础，因此，理解这里所展示的项目非常重要。
- en: In the next chapter, we will look at some more advanced features of the Arduino
    programming language and the Arduino development environments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Arduino编程语言和Arduino开发环境的一些更高级的功能。
