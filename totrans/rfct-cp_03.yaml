- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Causes of Bad Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed coding standards in C++ and the core
    development principles. As we delve into refactoring existing code, it is crucial
    to understand what leads to subpar or bad code. Recognizing these causes enables
    us to avoid repeating the same mistakes, address existing issues, and prioritize
    future improvements effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Bad code can result from various factors, ranging from external pressures to
    internal team dynamics. One significant factor is the need to deliver the product
    quickly, especially in fast-paced environments such as start-ups. Here, the pressure
    to release features rapidly often leads to compromises in code quality as developers
    might cut corners or skip essential best practices to meet tight deadlines.
  prefs: []
  type: TYPE_NORMAL
- en: Another contributing factor is the multiple ways of solving the same problem
    in C++. The language’s flexibility and richness, while powerful, can result in
    inconsistencies and difficulties in maintaining a coherent code base. Different
    developers might approach the same problem in various ways, leading to a fragmented
    and harder-to-maintain code base.
  prefs: []
  type: TYPE_NORMAL
- en: The developer’s personal taste also plays a role. Individual preferences and
    coding styles can impact the overall quality and readability of the code. What
    one developer considers elegant, another might find convoluted, leading to subjective
    differences that affect code consistency and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, a lack of knowledge of modern C++ features can result in inefficient
    or error-prone code. As C++ evolves, it introduces new features and paradigms
    that require a deep understanding to be used effectively. When developers are
    not up to date with these advancements, they might fall back on outdated practices,
    missing out on improvements that can enhance code quality and performance.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring these aspects, we aim to provide a thorough understanding of the
    factors contributing to bad code. This knowledge is essential for any developer
    aiming to refactor and improve an existing code base effectively. Let’s dive in
    and uncover the root causes of bad code in C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: The need to deliver the product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developers examine pre-existing code, they may question why it was written
    in a manner that is less elegant or lacks extensibility. It is often easy to criticize
    the job done by others, but it is crucial to understand the original developer’s
    circumstances. Suppose the project was originally developed in a start-up company.
    In that case, it is important to consider that start-up culture significantly
    emphasizes fast product delivery and the need to outpace competitors. While this
    can be advantageous, it can also lead to the development of bad code. One of the
    main reasons for this is the pressure to deliver quickly, which may cause developers
    to cut corners or skip essential coding practices (for example, the SOLID principles
    mentioned in previous chapters) in order to meet deadlines. This can result in
    code that lacks proper documentation, is difficult to maintain, and may be susceptible
    to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the limited resources and small development teams of start-ups
    can exacerbate the need for speed, as developers may not have the manpower to
    focus on optimizing and refining the code base. As a result, the code can become
    cluttered and inefficient, leading to decreased performance and increased bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the focus on fast delivery in start-up culture can make it difficult
    for developers to keep up with the latest advancements in C++. This may result
    in outdated code that lacks important features, uses inefficient or deprecated
    functions, and is not optimized for performance.
  prefs: []
  type: TYPE_NORMAL
- en: The developer’s personal taste
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another significant factor contributing to bad code is the developer’s personal
    taste. Individual preferences and coding styles can vary widely, leading to subjective
    differences that impact code consistency and readability. For example, consider
    two developers, Bob and Alice. Bob prefers using concise, compact code that leverages
    advanced C++ features, while Alice favors more explicit and verbose code, prioritizing
    clarity and simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob might write a function using modern C++ features such as lambda expressions
    and the `auto` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alice, on the other hand, might prefer a more traditional approach, avoiding
    lambdas and using explicit types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While both approaches are valid and achieve the same result, the difference
    in style can lead to confusion and inconsistency within the code base. If Bob
    and Alice are working on the same project without adhering to a common coding
    standard, the code can become a patchwork of differing styles, making it harder
    to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Bob’s use of modern features might introduce complexity that could
    be difficult for team members unfamiliar with these features, while Alice’s verbose
    style might be seen as overly simplistic and inefficient by those who prefer more
    concise code. These differences, rooted in personal taste, underscore the importance
    of establishing and following team-wide coding standards to ensure consistency
    and maintainability in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: By recognizing and addressing the impact of personal coding preferences, teams
    can work toward creating a cohesive and readable code base that aligns with best
    practices and enhances overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple ways of solving the same problem in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a versatile language that offers multiple ways to solve the same problem,
    a characteristic that can both empower and confuse developers. This flexibility
    often leads to inconsistencies within a code base, especially when different developers
    have varying levels of expertise and preferences. In this chapter, we will show
    a few examples to illustrate how the same problem can be approached in different
    ways, highlighting the potential benefits and pitfalls of each method. As discussed
    in the *The developer’s personal taste* section, developers such as Bob and Alice
    might approach the same problem using different techniques, leading to a fragmented
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Bob and Alice’s example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To recap, Bob used modern C++ features such as lambda expressions and `auto`
    to process data concisely, while Alice preferred a more explicit and verbose approach.
    Both methods achieve the same result, but the difference in style can lead to
    confusion and inconsistency within the code base. While Bob’s approach is more
    compact and leverages modern C++ features, Alice’s method is straightforward and
    easier to understand for those unfamiliar with lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Raw pointers and C functions versus Standard Library functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a project that heavily uses raw pointers and C functions for copying
    data, a common practice in older C++ code bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach, while functional, is prone to errors such as buffer overflows
    and requires manual memory management. In contrast, a modern C++ approach would
    use standard library functions such as `std::copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `std::copy` not only simplifies the code but also leverages well-tested
    library functions that handle edge cases and improve safety.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance versus templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another area where C++ offers multiple solutions is code reuse and abstraction.
    Some projects prefer using inheritance, which can lead to a rigid and complex
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While inheritance provides a clear structure and allows polymorphic behavior,
    it can become cumbersome as the hierarchy grows. An alternative approach is to
    use templates to achieve polymorphism without the overhead of virtual functions.
    Here’s how templates can be used to achieve similar functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `ShapeDrawer` uses templates to achieve polymorphic behavior.
    `ShapeDrawer` can work with any type that provides a `draw` method. This approach
    avoids the overhead associated with virtual function calls and can be more efficient,
    especially in performance-critical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Example – handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another example of solving the same problem in different ways is error handling.
    Consider a project where Bob uses a traditional error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alice, on the other hand, prefers using exceptions for error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using exceptions can make the code cleaner by separating error handling from
    the main logic, but it requires an understanding of exception safety and handling.
    Error code, while simpler, can clutter the code with repetitive checks and may
    be less informative.
  prefs: []
  type: TYPE_NORMAL
- en: Projects using different approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In real-world projects, you might encounter a mix of these approaches, reflecting
    the varied backgrounds and preferences of different developers, such as these
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project A** uses raw pointers and C functions for performance-critical sections,
    relying on the developers’ expertise to manage memory safely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project B** prefers standard library containers and algorithms, prioritizing
    safety and readability over raw performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project C** employs a deep inheritance hierarchy to model its domain, emphasizing
    clear relationships between entities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project D** utilizes templates extensively to achieve high performance and
    flexibility, despite the steeper learning curve and potential complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each approach has its pros and cons, and choosing the right one depends on the
    project’s requirements, the team’s expertise, and the specific problem being solved.
    However, these multiple ways of solving the same problem can lead to a fragmented
    and inconsistent code base if not managed carefully.
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides multiple ways to solve the same problem, from raw pointers and
    C functions to standard library containers and templates. While this flexibility
    is powerful, it can also lead to inconsistencies and complexity in a code base.
    Understanding the strengths and weaknesses of each approach and striving for consistency
    through coding standards and team agreements is crucial for maintaining high-quality,
    maintainable code. By embracing modern C++ features and best practices, developers
    can write code that is both efficient and robust, reducing the likelihood of errors
    and improving overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of knowledge in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major contributors to bad code is a lack of knowledge in C++. C++
    is a complex and evolving language with a wide range of features, and staying
    updated with its latest standards requires continuous learning. Developers who
    are not familiar with modern C++ practices can inadvertently write inefficient
    or error-prone code. This section explores how gaps in understanding C++ can lead
    to various issues, using examples to illustrate common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Consider two developers, Bob and Alice. Bob has extensive experience with older
    versions of C++ but hasn’t kept up with recent updates, while Alice is well versed
    in modern C++ features.
  prefs: []
  type: TYPE_NORMAL
- en: Using raw pointers and manual memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob might use raw pointers and manual memory management, a common practice
    in older C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is prone to errors such as memory leaks and undefined behavior
    if `delete[]` is missed or incorrectly matched with `new`. For instance, if an
    exception is thrown after the allocation but before `delete[]`, the memory will
    leak. Alice, familiar with modern C++, would use `std::vector` to manage memory
    safely and efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using `std::vector` eliminates the need for manual memory management, reducing
    the risk of memory leaks and making the code more robust and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect use of smart pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob tries to adopt modern practices but misuses `std::shared_ptr`, leading
    to potential performance issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach involves two separate allocations: one for the integer and another
    for the control block of `std::shared_ptr`. Alice, knowing the benefits of `std::make_shared`,
    uses it to optimize memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`std::make_shared` combines the allocations into a single memory block, improving
    performance and cache locality.'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient use of move semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob might not fully understand move semantics and how they can improve performance
    when dealing with temporary objects. Consider a function that appends elements
    to `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach involves copying each element from `source` to `target`, which
    can be inefficient. Alice, understanding move semantics, would optimize this by
    using `std::move`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `std::move`, Alice ensures that each element is moved rather than
    copied, which is more efficient. Additionally, Alice might also consider using
    `std::move` for the entire container if `source` is no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This approach moves the elements of the entire container efficiently, leveraging
    move semantics to avoid unnecessary copying.
  prefs: []
  type: TYPE_NORMAL
- en: Misusing const correctness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob might neglect const correctness, leading to potential bugs and unclear
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Without const correctness, it’s unclear whether `get_value` modifies the state
    of the object. Alice applies const correctness to clarify the intent and improve
    safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Marking `get_value` as `const` guarantees that it does not modify the object,
    making the code clearer and preventing accidental modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient string handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob might handle strings using C-style character arrays, which can lead to
    buffer overflows and complex code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is error-prone and difficult to manage. Alice, aware of the capabilities
    of `std::string`, simplifies the code and avoids potential errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using `std::string` provides automatic memory management and a rich set of functions
    for string manipulation, making the code safer and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined behavior with lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lambda functions introduced in C++11 provide powerful capabilities, but they
    can lead to undefined behavior if not used correctly. Bob might write a lambda
    that captures a local variable by reference and returns it, leading to dangling
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alice, understanding the risks, captures the variable by value to ensure it
    remains valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Capturing by value avoids the risk of dangling references and ensures the lambda
    remains safe to use.
  prefs: []
  type: TYPE_NORMAL
- en: Misunderstanding undefined behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob might inadvertently write code that leads to undefined behavior by relying
    on uninitialized variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing uninitialized variables can lead to unpredictable behavior and hard-to-debug
    issues. Alice, understanding the importance of initialization, ensures that all
    variables are properly initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Properly initializing variables prevents undefined behavior and makes the code
    more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Misuse of C-style arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using C-style arrays can lead to various issues, such as a lack of bounds checking
    and difficulty in managing array sizes. Consider the following example where a
    function creates a C array on the stack and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning a pointer to a local array leads to undefined behavior because the
    array goes out of scope when the function returns. A safer approach is to use
    `std::array`, which can be returned safely from a function. It provides the `size`
    method and is compatible with C++ algorithms such as `std::sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `std::array` not only avoids undefined behavior but also enhances safety
    and interoperability with the C++ Standard Library. For example, sorting an array
    becomes straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Insufficient pointer usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern C++ provides smart pointers such as `std::unique_ptr` and `std::shared_ptr`
    to manage dynamic memory more safely and efficiently. It’s generally better to
    use `std::unique_ptr` instead of raw pointers for exclusive ownership. When multiple
    actors need to share ownership of a resource, `std::shared_ptr` can be used. However,
    there are common issues related to the misuse of `std::shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Building std::shared_ptr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the constructor of `std::shared_ptr` to create an object leads to separate
    allocations for the control block and the managed object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A better approach is to use `std::make_shared`, which combines the allocations
    into a single memory block, improving performance and cache locality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Copying std::shared_ptr by value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copying `std::shared_ptr` by value within the same thread stack is less efficient
    because the reference counter is atomic. It’s recommended to pass `std::shared_ptr`
    by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Cyclic dependencies with std::shared_ptr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cyclic dependencies can occur when two or more `std::shared_ptr` instances
    reference each other, preventing the reference count from reaching zero and causing
    memory leaks. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, `A` and `B` reference each other, creating a cycle that prevents
    their destruction. This issue can be resolved using `std::weak_ptr` to break the
    cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Checking the std::weak_ptr status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common mistake when using `std::weak_ptr` is to check its status with `expired()`
    and then lock it, which is not thread-safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct approach is to lock `std::weak_ptr` and check that the returned
    `std::shared_ptr` is not `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Lack of knowledge in C++ can lead to various issues, from memory management
    errors to inefficient and unreadable code. By staying updated with modern C++
    features and best practices, developers can write code that is safer, more efficient,
    and easier to maintain. Continuous learning and adaptation are key to overcoming
    these challenges and improving overall code quality. Bob and Alice’s examples
    highlight the importance of understanding and applying modern C++ practices to
    avoid common pitfalls and produce high-quality code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various causes of bad code in C++ and how a lack
    of knowledge in modern C++ practices can lead to inefficient, error-prone, or
    undefined behavior. By examining specific examples, we highlighted the importance
    of continuous learning and adaptation to keep up with the evolving features of
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: We began by discussing the pitfalls of using raw pointers and manual memory
    management, showing how modern C++ practices such as `std::vector` can eliminate
    the need for manual memory management and reduce the risk of memory leaks. The
    advantages of using `std::unique_ptr` for exclusive ownership and `std::shared_ptr`
    for shared ownership were emphasized, while common issues such as inefficient
    memory allocation, unnecessary copying, and cyclic dependencies were highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of `std::shared_ptr`, we demonstrated the benefits of using `std::make_shared`
    over the constructor to reduce memory allocations and improve performance. The
    efficiency gained by passing `std::shared_ptr` by reference rather than by value
    due to the atomic reference counter was also explained. We illustrated the problem
    of cyclic dependencies and how `std::weak_ptr` can be used to break cycles and
    prevent memory leaks. The correct way to check and use `std::weak_ptr` by locking
    it and checking the resulting `std::shared_ptr` to ensure thread safety was also
    covered.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient use of move semantics was discussed to optimize performance by reducing
    unnecessary copying of temporary objects. Using `std::move` and `std::make_move_iterator`
    can significantly enhance program performance. The importance of const correctness
    was highlighted, showing how applying `const` to methods can clarify intent and
    improve code safety.
  prefs: []
  type: TYPE_NORMAL
- en: We addressed the dangers of using C-style character arrays and how `std::string`
    can simplify string handling, reduce errors, and provide better memory management.
    The misuse of C-style arrays was explored, and `std::array` was presented as a
    safer and more robust alternative. By using `std::array`, we can avoid undefined
    behavior and leverage C++ Standard Library algorithms such as `std::sort`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the proper use of lambda functions was discussed, along with the potential
    pitfalls of capturing variables by reference, which can lead to dangling references.
    Capturing variables by value ensures that the lambda remains safe to use.
  prefs: []
  type: TYPE_NORMAL
- en: Through these examples, we learned about the critical importance of adopting
    modern C++ features and best practices to write safer, more efficient, and maintainable
    code. By staying updated with the latest standards and continuously improving
    our understanding of C++, we can avoid common pitfalls and produce high-quality
    software.
  prefs: []
  type: TYPE_NORMAL
