<html><head></head><body>
        

                            
                    <h1 class="header-title">Drawing Shapes and Applying Textures</h1>
                
            
            
                
<p class="mce-root">The previous chapter was all about setting up our project to use different types of libraries, such as GLFW, GLEW, SMFL, and SDL. In this chapter, we'll go beyond the setup part and learn to implement some really cool OpenGL stuff. We'll learn about shaders and how to use them to create various shapes. Then, we'll move on to learn how to create a separate shader file and reference that in our code. We'll also discuss how to apply different textures to shapes using the SOIL library.</p>
<p>In this chapter, we'll cover the following topics in detail:</p>
<ul>
<li>Learning to draw a triangle using a shader</li>
<li>Creating a separate shader file and referencing it in the main code</li>
<li>Drawing a rectangle and applying textures to it using the SOIL library</li>
</ul>
<p class="mce-root">This chapter will initiate you into OpenGL coding and you'll learn a lot of concepts related to it.</p>
<p class="mce-root">Before we get started with coding, there a few things that we need to understand. Firstly, the code we’ll be writing from now on is platform- and framework-independent. So, it doesn’t matter if you are using Xcode on Mac or Visual Studio on Windows, the OpenGL code on any platform will be the same, as OpenGL is a platform-independent programming language. Secondly, for this chapter, we’ll be using the GLFW library. As we won’t be writing any GLFW-specific code, the code in this chapter will be relevant for SFML, SDL, or any other library that you wish to use.</p>
<p>So, let's get started.</p>
<p>You can refer to all the code files for this chapter in the <kbd>Chapter02</kbd> folder on GitHub. The GitHub link can be found in the preface of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a triangle</h1>
                
            
            
                
<p class="mce-root">In this section, we’ll be looking at how to draw a triangle in OpenGL using the GLFW library. To begin with, let’s go to the file in which we wrote code to create an OpenGL rendering window using the GLFW library in the previous chapter, and make the necessary changes to it. Let's take a look at the following steps to understand the code required to draw a triangle:</p>
<ol>
<li>We'll begin by including the essential header files in our code:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">#include &lt;iostream&gt;<br/>// GLEW<br/>#define GLEW_STATIC<br/>#include &lt;GL/glew.h&gt;<br/>// GLFW<br/>#include &lt;GLFW/glfw3.h&gt;<br/>// Window dimensions<br/>const GLuint WIDTH = 800, HEIGHT = 600;</pre>
<ol start="2">
<li class="mce-root">To create shapes in modern OpenGL, we need to create shaders. So, let’s begin by adding some shaders to our code. Firstly, we’ll add a constant, <kbd>GLchar *</kbd>, and we’ll call it <kbd>vertexShaderSource</kbd>. This is going to be a string and its version will be <kbd>330 core</kbd> :</li>
</ol>
<pre style="padding-left: 60px">// Shaders<br/>const GLchar* vertexShaderSource = "#version 330 core\n"</pre>
<p style="padding-left: 60px">The <kbd>330 core</kbd> defines the core shader language version for OpenGL version 3.3. If you're using OpenGL version 4.0, then the shader language version won't necessarily be <kbd>440</kbd>; it could be something different. By looking for it on the internet, you can get an idea of which shader version you should be using.</p>
<ol start="3">
<li class="mce-root">The <kbd>vertexShaderSource</kbd> that we mentioned in the preceding line of code is just going to handle the <strong>location</strong> and <strong>positioning</strong> of our triangle, which we’ll define as follows:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">"layout (location = 0) in vec3 position;\n"<br/>"void main()\n"<br/>"{\n"<br/>"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"<br/>"}\0";</pre>
<ol start="4">
<li class="mce-root">And in the following code, we’ll have another shader source that is the <kbd>fragmentShaderSource</kbd>. This will handle the <strong>color</strong> and <strong>texture</strong> of our triangle. At the moment, we are explicitly setting only the color value in our shader, in the <kbd>vec4</kbd> variable:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">const GLchar* fragmentShaderSource = "#version 330 core\n"<br/>"out vec4 color;\n"<br/>"void main()\n"<br/>"{\n"<br/>"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"<br/>"}\n\0";</pre>
<p class="mce-root" style="padding-left: 60px">To the variable <kbd>vec4</kbd> in the preceding code, we've assigned the values <kbd>1.0f</kbd>, <kbd>0.5f</kbd>, <kbd>0.2f</kbd>, and <kbd>1.0f</kbd>, which are the red, green, blue, and alpha values. The colors that we have defined here have ranges between 0 and 1, with 0 being off and 1 being full intensity; this is very similar to RGB color values ranging between 0 and 255.</p>
<ol start="5">
<li class="mce-root">Next, in the following lines of code, we will define our rendering window as discussed in the previous chapter, just take a look at the following code for review:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> // The MAIN function, from here we start the application and run the game loop<br/> int main()<br/> {<br/> // Init GLFW<br/> glfwInit( );<br/> <br/> // Set all the required options for GLFW<br/> glfwWindowHint( GLFW_CONTEXT_VERSION_MAJOR, 3 );<br/> glfwWindowHint( GLFW_CONTEXT_VERSION_MINOR, 3 );<br/> glfwWindowHint( GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE );<br/> glfwWindowHint( GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE );<br/><br/> glfwWindowHint( GLFW_RESIZABLE, GL_FALSE );<br/> <br/> // Create a GLFWwindow object that we can use for GLFW's functions<br/> GLFWwindow *window = glfwCreateWindow( WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr );<br/> <br/> int screenWidth, screenHeight;<br/> glfwGetFramebufferSize( window, &amp;screenWidth, &amp;screenHeight );<br/> <br/> if ( nullptr == window )<br/> {<br/> std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;<br/> glfwTerminate( );<br/> <br/> return EXIT_FAILURE;<br/> }<br/> <br/> glfwMakeContextCurrent( window );<br/>// Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions<br/> glewExperimental = GL_TRUE;<br/> // Initialize GLEW to setup the OpenGL Function pointers<br/> if ( GLEW_OK != glewInit( ) )<br/> {<br/> std::cout &lt;&lt; "Failed to initialize GLEW" &lt;&lt; std::endl;<br/> return EXIT_FAILURE;<br/> }<br/> <br/> // Define the viewport dimensions<br/> glViewport( 0, 0, screenWidth, screenHeight );</pre>
<ol start="6">
<li>Now, before the <kbd>while</kbd> loop, we'll add a line of code to define our shader. Let's begin by adding the following code to our program:</li>
</ol>
<pre style="padding-left: 60px"> // Build and compile our shader program<br/> // Vertex shader<br/> GLuint vertexShader = glCreateShader( GL_VERTEX_SHADER );<br/> glShaderSource( vertexShader, 1, &amp;vertexShaderSource, NULL );</pre>
<p style="padding-left: 60px">In the preceding lines of code, we created a variable for <kbd>vertexShader</kbd> and defined the source of the shader with <kbd>glShaderSource()</kbd>. And for that function, we passed the parameters, number <kbd>1</kbd> as a reference to the <kbd>vertexShaderSource</kbd>, and for the final parameter, we passed <kbd>NULL</kbd> for now.</p>
<ol start="7">
<li>Next, we are going to compile the shader using <kbd>glCompileShader()</kbd>, and in there we'll pass <kbd>vertexShader</kbd>. Then, we're going to check for any compilation errors using <kbd>GLint success</kbd>. We'll display these compilation errors to the developers in the form of a log. Therefore, we define a <kbd>char</kbd> variable, <kbd>infoLog</kbd>, and it's going to be an array of 512 items:</li>
</ol>
<pre style="padding-left: 60px">glCompileShader( vertexShader );<br/> // Check for compile time errors<br/> GLint success;<br/> GLchar infoLog[512];</pre>
<ol start="8">
<li>Then, we'll add <kbd>glGetShaderiv()</kbd> function to our code. Which will return in params the values of parameter for our shader object. For that function, we'll pass the parameters like <kbd>vertexShader</kbd>, the status of compilation <kbd>GL_COMPILE_STATUS</kbd> and then pass <kbd>&amp;success</kbd>:</li>
</ol>
<pre style="padding-left: 60px">glGetShaderiv( vertexShader, GL_COMPILE_STATUS, &amp;success );</pre>
<ol start="9">
<li>Next, we'll check whether our shader has successfully compiled with the help of an <kbd>if</kbd> statement. If it hasn't been successfully compiled, a shader log will be generated and it will let the developer know about the compilation errors. To display the errors, we'll add <kbd>glGetShaderInfoLog()</kbd> function and in it, we'll pass the parameters as <kbd>vertexShader</kbd>, <kbd>512</kbd>, <kbd>NULL</kbd>, and <kbd>infoLog</kbd>, and then add
<p><kbd>std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</kbd> and log out the <kbd>infoLog</kbd> so we can see it in more depth:</p>
</li>
</ol>
<pre style="padding-left: 60px">if ( !success )<br/> {<br/> glGetShaderInfoLog( vertexShader, 512, NULL, infoLog );<br/> std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;<br/> }</pre>
<ol start="10">
<li>Now, we'll do the same for the fragment shader, take a look at the following highlighted lines of code, to understand the changes made for the fragment shader:</li>
</ol>
<pre style="padding-left: 60px"> // Fragment shader<br/> GLuint<strong> fragmentShader = </strong>glCreateShader(<strong> GL_FRAGMENT_SHADER</strong> );<br/> glShaderSource(<strong> fragmentShader, 1, &amp;fragmentShaderSource, NULL </strong>);<br/> glCompileShader(<strong> fragmentShader</strong> );<br/> <br/> // Check for compile time errors<br/> glGetShaderiv(<strong> fragmentShader</strong>,<strong> </strong>GL_COMPILE_STATUS, &amp;success );<br/> <br/> if ( !success )<br/> {<br/>   glGetShaderInfoLog(<strong> fragmentShader</strong>,<strong> </strong>512, NULL, infoLog );<br/>   std::cout &lt;&lt; "ERROR::SHADER::<strong>FRAGMENT</strong>::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt;    std::endl;<br/> }</pre>
<ol start="11">
<li>Then, we are going to link the shaders. For that, we'll create a variable called <kbd>shaderProgram</kbd> and reference it in <kbd>glCreateProgram();</kbd>. The <kbd>glCreateProgram()</kbd> creates an empty program object and returns a non-zero value by which it can be referenced. A <strong>program object</strong> is an object to which shader objects can be attached.</li>
<li class="mce-root">Then, we'll define <kbd>glAttachShader();</kbd> function to attach our shaders. In there we're going to pass the <kbd>shaderProgram</kbd>, which is the variable that we just created in the previous step. And then we'll pass the shaders that we're attaching to it. So, the first one we'll pass is <kbd>vertexShader</kbd> and then we'll attach the <kbd>fragmentShader</kbd>. Then, we'll define the function <kbd>glLinkProgram();</kbd>, and we'll link the <kbd>shaderProgram</kbd> to it. Take a look at the following code to understand the description:</li>
</ol>
<pre style="padding-left: 60px"> // Link shaders<br/> GLuint shaderProgram = glCreateProgram( );<br/> glAttachShader( shaderProgram, vertexShader );<br/> glAttachShader( shaderProgram, fragmentShader );<br/> glLinkProgram( shaderProgram );</pre>
<p class="mce-root"/>
<ol start="13">
<li>The next thing we're going to do is check for any linking errors, always remember to check for any errors in your code. We'll check the error as follows:</li>
</ol>
<pre style="padding-left: 60px"> // Check for linking errors<br/> glGetProgramiv( shaderProgram, GL_LINK_STATUS, &amp;success );<br/> <br/> if ( !success )<br/> {<br/> glGetProgramInfoLog( shaderProgram, 512, NULL, infoLog );<br/> std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;<br/> }<br/>glDeleteShader( vertexShader );<br/>glDeleteShader( fragmentShader );</pre>
<p style="padding-left: 90px">In the preceding line of code, we defined <kbd>glGetProgramiv();</kbd> and referenced our <kbd>shaderProgram</kbd> to it as we'll be checking whether there are any errors present in the code. Then, we'll check for the link status and assign its result to success. Next, we checked whether the linking of the shaders was successful. If the linking was not successful, we do essentially the same as we did in the previous lines of code; that is we'll generate the error log.<br/>
We define <kbd>glGetProgramInfoLog ();</kbd>function and in there we pass the parameters such as <kbd>shaderProgram</kbd>, because that's what we're checking in the errors for. Then we pass in <kbd>512</kbd> for the number of items and <kbd>NULL</kbd> array and the <kbd>infoLog</kbd>, because this is what we're going to assign any error logs to. Then we enter the error message that need to be displayed for the developer.<br/>
So, now that we've checked for any errors while linking our shader program, we can actually delete the vertex and fragment shaders because we'll no longer be using them as they're part of our shader program now. So, we typed <kbd>glDeleteShader();</kbd>function and reference the vertex and fragment shaders to it.</p>
<ol start="14">
<li>Next, what we're going to do is define the vertex data so that we can actually draw the triangle in terms of position:</li>
</ol>
<pre style="padding-left: 60px"> // Set up vertex data (and buffer(s)) and attribute pointers<br/> GLfloat vertices[] =<br/> {<br/>      -0.5f, -0.5f, 0.0f, // Left<br/>      0.5f, -0.5f, 0.0f,  // Right<br/>      0.0f, 0.5f, 0.0f    // Top<br/> };</pre>
<p class="mce-root"/>
<p>In the preceding code, if you wanted draw a quadrilateral, you would have to define four vertices.</p>
<p style="padding-left: 60px">In the preceding lines of code, we began by defining a float array, <kbd>vertices[]</kbd>, and in it we defined our left, right, and the top coordinates.</p>
<p>For the coordinates that we defined, in OpenGL by default if you don't explicitly set them, the values of your screen range between <kbd>-1</kbd> and <kbd>1</kbd>. So, that the value<kbd>0</kbd> is in the middle and <kbd>0.5</kbd> is 25% of the away from the middle, or 75% is the away from the left-hand side. In later sections, we will look at changing that system so it's actually using more of the screen.</p>
<ol start="15">
<li>Now that we've got the <kbd>vertices[]</kbd> array created, what we need to do is create the <strong>vertex buffer object</strong> (<strong>VBO</strong>) and the <strong>vertex array object</strong> (<strong>VAO</strong>). We'll begin by defining <kbd>GLuint</kbd> variables <kbd>VBO</kbd>, <kbd>VAO</kbd>. Then, we're going to generate the vertex array by simply typing <kbd>glGenVertexArrays();</kbd>, and in this function, we'll pass <kbd>1</kbd> and a reference to VAO. Next, we'll generate the buffers by defining the function <kbd>glGenBuffers();</kbd> and to that, we'll pass <kbd>1</kbd> and pass reference <kbd>VBO</kbd> to it.</li>
</ol>
<pre style="padding-left: 60px"> GLuint VBO, VAO;<br/> glGenVertexArrays( 1, &amp;VAO );<br/> glGenBuffers( 1, &amp;VBO );</pre>
<ol start="16">
<li>Then, we'll bind the vertex array object and then bind and set the vertex buffers, so let's get on with that. We'll add <kbd>glBindVertexArray();</kbd>function and pass <kbd>VAO</kbd> to it. Then, we'll add <kbd>glBindBuffer();</kbd> function and pass <kbd>GL_ARRAY_BUFFER</kbd> and <kbd>VBO</kbd> to it. Next, we'll add <kbd>glBufferData();</kbd> function and pass <kbd>GL_ARRAY_BUFFER</kbd> and <kbd>size()</kbd>. As we'll be checking the size of our vertices in a dynamic way that is the reason we passed the function <kbd>size()</kbd> and to this function we'll pass in the vertices that we are drawing, and then finally we're going pass <kbd>GL_STATIC_DRAW</kbd>. So, this is just the buffer data that we'll be using to draw our good stuff:</li>
</ol>
<pre style="padding-left: 60px">// Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).<br/> glBindVertexArray( VAO );<br/> <br/> glBindBuffer( GL_ARRAY_BUFFER, VBO );<br/> glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );</pre>
<ol start="17">
<li>Next, we'll create the vertex pointer, so we'll add the function <kbd>glVertexAttribPointer()</kbd>and to this function, we'll pass the parameters as highlighted in the following code. Then, we'll enable the vertex array by typing <kbd>glEnableVertexAttribArray()</kbd> function and we'll pass <kbd>0</kbd> to it.</li>
</ol>
<pre> glVertexAttribPointer( <strong>0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof( GLfloat ), ( GLvoid * ) 0</strong> );<br/> glEnableVertexAttribArray( 0 );</pre>
<ol start="18">
<li>Then, we'll bind the buffer, adding <kbd>glBindBuffer()</kbd>function to our code. This is going to take two values: <kbd>GL_ARRAY_BUFFER</kbd> and <kbd>0.</kbd></li>
<li>Then to the next line, we'll add <kbd>glBindVertexArray()</kbd> function and this is going to be <kbd>0</kbd>. As we are unbinding the vertex array object over here. It's always a good thing to unbind any buffers or arrays to prevent strange bugs. Take a look at the following code:</li>
</ol>
<pre style="padding-left: 60px">glBindBuffer( GL_ARRAY_BUFFER, 0 ); <br/>// Note that this is allowed, the call to glVertexAttribPointer //registered VBO as the currently bound vertex buffer object so //afterwards we can safely unbind<br/> <br/> glBindVertexArray( 0 ); <br/>// Unbind VAO (it's always a good thing to unbind any buffer/array //to prevent strange bugs)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding code to draw the shape</h1>
                
            
            
                
<p>The next thing we are going to do is add code to draw the triangle:</p>
<ol>
<li>We are going to draw the shape within our while loop. We'll want to draw it after the <kbd>glClear()</kbd> function. So, once the screen's been cleared and before the screen buffers have been swapped, we'll add function <kbd>glUseProgram()</kbd>. This will indicate what shader program we're using, and for our project, it is <kbd>shaderProgram</kbd> that we have linked our vertex and fragment shaders to.</li>
</ol>
<ol start="2">
<li>Then, we'll add <kbd>glBindVertexArray();</kbd> function and we bind the VAO to it.</li>
<li>Next, we'll want to call <kbd>glDrawArrays();</kbd> function as this will finally draw our triangle. In the first thing that we'll pass in the <kbd>glDrawArrays();</kbd> function is the mode, that is <kbd>GL_TRIANGLES</kbd> or <kbd>GL_QUAD</kbd> or <kbd>GL_LINE</kbd>. Depending on how many vertices you have and what sort of object or shape you're trying to achieve, this will vary—we'll be covering it in more depth later in this chapter. The second parameter that we'll pass to <kbd>glDrawArrays();</kbd> function is <kbd>0</kbd> and the final parameter that we pass is <kbd>3</kbd>, as we've put how many vertices are there in our shape as it's a triangle.</li>
<li>Then, add <kbd>glBindVertexArray()</kbd> function and to it we pass <kbd>0</kbd>. We are just unbinding it.</li>
<li>Now, there's literally one last thing to do: cleaning up. We'll de-allocate all the resources once we've finished using them. So, outside of the loop, add <kbd>glDeleteVertexArrays()</kbd> function and assign <kbd>1</kbd> , <kbd>&amp;VAO</kbd> and then add <kbd>glDeleteBuffers()</kbd> function to delete the buffers. Take a look at the following code to understand the preceding code description, also observe the highlighted terms in the code:</li>
</ol>
<pre style="padding-left: 60px"> // Game loop<br/> while ( !glfwWindowShouldClose( window ) )<br/> {<br/> // Check if any events have been activiated (key pressed, mouse moved //etc.) and call corresponding response functions<br/> <br/>glfwPollEvents( );<br/> <br/> // Render<br/> // Clear the colorbuffer<br/> glClearColor( 0.2f, 0.3f, 0.3f, 1.0f );<br/> glClear( GL_COLOR_BUFFER_BIT );<br/> <br/><strong> // Draw our first triangle</strong><br/><strong> glUseProgram( shaderProgram );</strong><br/><strong> glBindVertexArray( VAO );</strong><br/><strong> glDrawArrays( GL_TRIANGLES, 0, 3 );</strong><br/><strong> glBindVertexArray( 0 );</strong><br/> <br/> // Swap the screen buffers<br/> glfwSwapBuffers( window );<br/> }<br/> <br/> // Properly de-allocate all resources once they've outlived their purpose<br/><strong> glDeleteVertexArrays( 1, &amp;VAO );</strong><br/><strong> glDeleteBuffers( 1, &amp;VBO );</strong><br/> <br/> // Terminate GLFW, clearing any resources allocated by GLFW.<br/> glfwTerminate( );<br/> <br/> return EXIT_SUCCESS;<br/> }<br/><br/></pre>
<p>Now we are ready to run our code. Once it gets complied without any errors, you will get the following triangle as the output:</p>
<div><img class="aligncenter size-full wp-image-293 image-border" src="img/c9b89358-4600-4127-abaf-3c8acccaa246.png" style=""/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstracting the shaders</h1>
                
            
            
                
<p>Let's take a look at shaders in this section, even though we've looked at shaders in the previous section while creating the triangle and using a shader to color it. What we're going to do in this section is to abstract the shader code into a vertex shader file and a fragment shader file so that it's a lot neater and more reusable. And, we're also going to abstract out the loading of the shader, as once we've abstracted that out, we probably won't need to change it at all, or at least there won't be too many changes to it. Further, in our projects, we'll just use these files to load the shaders in our code, which will make it easy to use.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the shader files</h1>
                
            
            
                
<p>Follow these steps to create the files:</p>
<ol>
<li>We'll begin by creating two new empty files in our project IDE and name those two files <kbd>core.vs</kbd> and <kbd>core.frag</kbd>. Here, <kbd>vs</kbd> stands for vector shader file and <kbd>frag</kbd> stands for fragment shader file.</li>
</ol>
<p>It doesn't actually matter what you name these as long as you refer to the exact name and the extension when you refer to them.</p>
<ol start="2">
<li>Then, open your <kbd>core.vs</kbd> file and cut and paste the <kbd>VectorShaderSource</kbd> code that we had added in the previous section. Make the highlighted changes shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/><strong>layout (location = 1) in vec3 color;</strong><br/><strong>out vec3 ourColor;</strong><br/>void main()<br/>{<br/> gl_Position = vec4(<strong>position, 1.0f</strong>);<br/><strong> ourColor = color;</strong><br/>}</pre>
<p style="padding-left: 60px">Let's save this file and our vector shader file is created. Next, we're going to do essentially the same for the fragment shader file.</p>
<ol start="3">
<li>So, let's open up <kbd>core.frag</kbd> in our IDE and cut and paste <kbd>fragmentShaderSource</kbd> code from the code in the previous section. Once pasted, make changes to it as highlighted in the following code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/><strong>in vec3 ourColor;</strong><br/><strong>out vec4 color;</strong><br/>void main()<br/>{<br/> color = vec4(<strong>ourColor, 1.0f</strong>);<br/>}</pre>
<p>Save this file and we've now created the fragment shader file too. Let's move on to create the Shader.h file for abstracting the loading of shader code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Shader.h header file</h1>
                
            
            
                
<p>Now, we'll also create the shader loading file that is <kbd>Shader.h</kbd> and use that to load our shader into the code. Follow these steps to create the <kbd>Shader.h</kbd> file:</p>
<ol start="1">
<li>So, let's create an empty header file in our project and name that file <kbd>Shader.h</kbd>.</li>
<li>Once this file is created, open it and cut and paste the shader loading code from the code that we had mentioned in the previous section.</li>
<li>What we're actually going to do is cut everything just after the <kbd>glViewport( 0, 0, screenWidth, screenHeight );</kbd> code and above the vertices array <kbd>GLfloat vertices[]</kbd> code. As the code that we cut was actually loading our shaders.</li>
<li>Then, make the changes shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"> #ifndef SHADER_H<br/> #define SHADER_H<br/> #include &lt;string&gt;<br/> #include &lt;fstream&gt;<br/> #include &lt;sstream&gt;<br/> #include &lt;iostream&gt;<br/> #include &lt;GL/glew.h&gt;</pre>
<p style="padding-left: 60px">So, what we've got in the preceding lines of code is just some simple <kbd>#ifndef</kbd> and <kbd>#define</kbd> preventing it from being included multiple times. We're just including the stream and string headers because they're what we're going to be loading our files into, so we need the correct headers to load it. Then, we need GLEW obviously, which assumes you've got GLEW set up.</p>
<ol start="5">
<li>After that, we've got the <kbd>GLuint</kbd> program, and we've got some comments right there. We'll construct the shader on the fly:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">class Shader<br/> {<br/> public:<br/> GLuint Program;<br/> // Constructor generates the shader on the fly<br/> Shader( const GLchar *vertexPath, const GLchar *fragmentPath )<br/> {</pre>
<ol start="6">
<li>The following variables are used to store and load the code and the shader file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">// 1. Retrieve the vertex/fragment source code from filePath<br/> std::string vertexCode;<br/> std::string fragmentCode;<br/> std::ifstream vShaderFile;<br/> std::ifstream fShaderFile;</pre>
<ol start="7">
<li>In the following code, we're just handling some exceptions:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">// ensures ifstream objects can throw exceptions:<br/> vShaderFile.exceptions ( std::ifstream::badbit );<br/> fShaderFile.exceptions ( std::ifstream::badbit );</pre>
<ol start="8">
<li>In the following code we are using the string stream, what we're going to do is open the file so we've got the vertex and the fragment path. Using the string streams, we're reading the file into the actual stream itself. And then, because we don't need it anymore, we can just close it. Then, we'll load it into our strings and catch any errors there. It's very simple stuff if you've done C++ before, which we recommend you should be familiar with:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">try<br/> {<br/>      // Open files<br/>      vShaderFile.open( vertexPath );<br/>      fShaderFile.open( fragmentPath );<br/>      std::stringstream vShaderStream, fShaderStream;<br/>      // Read file's buffer contents into streams<br/>      vShaderStream &lt;&lt; vShaderFile.rdbuf( );<br/>      fShaderStream &lt;&lt; fShaderFile.rdbuf( );<br/>      // close file handlers<br/>      vShaderFile.close( );<br/>      fShaderFile.close( );<br/>      // Convert stream into string<br/>      vertexCode = vShaderStream.str( );<br/>      fragmentCode = fShaderStream.str( );<br/> }<br/> <br/>catch ( std::ifstream::failure e )<br/> {<br/>     std::cout &lt;&lt; "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" &lt;&lt; std::endl;<br/> }</pre>
<ol start="9">
<li>After that, we're just getting the C string. Then, we're just compiling the shaders, which we've already done. So, after those first two lines of code, we're sort of done:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"> const GLchar *vShaderCode = vertexCode.c_str( );<br/> const GLchar *fShaderCode = fragmentCode.c_str( );<br/><br/> // Compile shaders<br/><br/> GLuint vertex, fragment;<br/> GLint success;<br/> GLchar infoLog[512];<br/> <br/>// Vertex Shader<br/> vertex = glCreateShader( GL_VERTEX_SHADER );<br/> glShaderSource( vertex, 1, &amp;vShaderCode, NULL );<br/> glCompileShader( vertex );<br/> // Print compile errors if any<br/> glGetShaderiv( vertex, GL_COMPILE_STATUS, &amp;success );<br/> if ( !success )<br/> {<br/> glGetShaderInfoLog( vertex, 512, NULL, infoLog );<br/> std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;<br/> }<br/> <br/>// Fragment Shader<br/> fragment = glCreateShader( GL_FRAGMENT_SHADER );<br/> glShaderSource( fragment, 1, &amp;fShaderCode, NULL );<br/> glCompileShader( fragment );<br/> // Print compile errors if any<br/> glGetShaderiv( fragment, GL_COMPILE_STATUS, &amp;success );<br/> if ( !success )<br/> {<br/>    glGetShaderInfoLog( fragment, 512, NULL, infoLog );<br/>    std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;<br/> }<br/> <br/>// Shader Program<br/> this-&gt;Program = glCreateProgram( );<br/> glAttachShader( this-&gt;Program, vertex );<br/> glAttachShader( this-&gt;Program, fragment );<br/> glLinkProgram( this-&gt;Program );<br/> // Print linking errors if any<br/> glGetProgramiv( this-&gt;Program, GL_LINK_STATUS, &amp;success );<br/> if (!success)<br/> {<br/>    glGetProgramInfoLog( this-&gt;Program, 512, NULL, infoLog );<br/>    std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;<br/> }<br/> <br/>// Delete the shaders as they're linked into our program now and no //longer necessery<br/> glDeleteShader( vertex );<br/> glDeleteShader( fragment );<br/> <br/> }</pre>
<ol start="10">
<li>And then here's a lower line, just saying to use the program:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">// Uses the current shader<br/> void Use( )<br/> {<br/> <strong>glUseProgram( this-&gt;Program );</strong><br/> }<br/> };<br/>#endif</pre>
<p>So, what we've done in the preceding code is make our shader code a bit more dynamic. Next, we're going to go to our <kbd>main.cpp</kbd> and carry out some changes to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making changes to the draw triangle code</h1>
                
            
            
                
<p>As we created our shader files and the <kbd>Shader.h</kbd> header file in the preceding sections, we'll now load those files into our triangle code. To do this, we'll have to make certain changes to the triangle code that we wrote earlier. Check out the below mentioned steps:</p>
<ol>
<li>We'll begin by including the <kbd>Shader.h</kbd> header file, because without that we can't actually use the <kbd>Shader</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">#include "Shader.h"</pre>
<ol start="2">
<li>Then, before defining our vertices, we'll add the following line of highlighted code:</li>
</ol>
<pre style="padding-left: 60px">// Build and compile our shader program<br/> <strong>Shader ourShader( "core.vs", "core.frag" );</strong></pre>
<p>For Xcode, this highlighted code will be replaced with the following line of code:<br/>
<kbd>Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag" );</kbd><br/>
If you execute our triangle code without adding this line on Mac you will get an error and the triangle won't be generated in your output window.<br/>
The reason this happens is there are executable files in your project folder, but we don't have any resource files. So, we'll have to add those file to our project:
<ol>
<li class="mce-root">What we want to do is go to our project folder in Xcode, right-click on it, go to New Folder, and create a folder called <kbd>resources</kbd>.</li>
<li class="mce-root">Inside the <kbd>resources</kbd> folder, we'll create another folder called <kbd>shaders</kbd>. And then in there, we create a folder that's called <kbd>images</kbd>/<kbd>videos</kbd> whenever we need those particular file types. So, this is going to be good for the future as well.</li>
<li class="mce-root">Next, what we'll do is move our shader files, <kbd>core.vs</kbd> and <kbd>core.frag</kbd>, into the <kbd>shader</kbd> folder.</li>
<li class="mce-root">Then, go to your project, go to Build Phases, and then click on + and click on the New Copy Files Phase option.</li>
<li class="mce-root">Once you've clicked that, you'll have a new section, Copy Files (0 items). Open that and make sure Destination is set to Resources, and then click on the + sign below it.</li>
<li class="mce-root">Then, select the <kbd>resources</kbd> folder and click on the Add button.</li>
</ol>
</p>
<ol start="3">
<li>Furthermore, there are a few changes that we want to make to our <kbd>vertices []</kbd> array. As you may remember when we created <kbd>core.vs</kbd>, what we did was we actually created an input for the color as well. So, instead of just explicitly setting the color, we're going to allow some sort of color input. And to do that, we're going to expand out the vertices array as follows:</li>
</ol>
<pre style="padding-left: 60px">GLfloat vertices[] =<br/> {<br/>     // Positions          // Colors<br/>     0.5f, -0.5f, 0.0f,    1.0f, 0.0f, 0.0f,  // Bottom Right<br/>     -0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,  // Bottom Left<br/>     0.0f, 0.5f, 0.0f,     0.0f, 0.0f, 1.0f   // Top<br/> };</pre>
<p style="padding-left: 60px">In the preceding lines of code, what we actually did was added the color by putting the values for red, green, and blue color. This is going to be really exciting because we're assigning a color to each of the vertices, and what's going to happen is, it will blend the colors together and this will create a really amazing effect on our triangle.</p>
<ol start="4">
<li>Next, we'll go to our position attribute and color attribute code, and replace those with the following code:</li>
</ol>
<pre style="padding-left: 60px">// Position attribute<br/> glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, <strong>6</strong> * sizeof( GLfloat ), ( GLvoid * ) 0 );<br/> glEnableVertexAttribArray( 0 );<br/> // Color attribute<br/> glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE,<strong> 6</strong> * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );<br/> glEnableVertexAttribArray( 1 );</pre>
<p style="padding-left: 60px">The preceding lines of code will define the position and color attributes of the triangle. In the <kbd>vertices []</kbd> as we've six values now: 3 for position coordinates and other 3 for color coordinates. That is the reason why we've put 6 in the preceding code because we've got <kbd>6</kbd> so we've got two values for each vertex and we've added color, so we need to add <kbd>6</kbd> to our code.</p>
<ol start="5">
<li>Next, we'll get rid of:</li>
</ol>
<pre style="padding-left: 60px">glBindBuffer( GL_ARRAY_BUFFER, 0 );</pre>
<ol start="6">
<li>We'll then move on to our while loop and replace the <kbd>glUseProgram( shaderProgram )</kbd>with the following code:</li>
</ol>
<pre style="padding-left: 60px">ourShader.Use( );</pre>
<p>With this preceding last minor change to our code, we are now ready to run our program. Once it's successfully complied without any errors, you will get the following colorful triangle as output on your screen:</p>
<div><img class="aligncenter size-full wp-image-294 image-border" src="img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png" style=""/></div>
<p>As we've added a color to each one of the vertices in the code. The color in the output triangle has blended together. That's what OpenGL does: it blends the colors together. Chances are if you've Googled OpenGL before, or just in general if you're into game development, you would have come across some sort of similar triangle like this. This is almost a rite of passage in OpenGL equivalent to the Hello World code in other programming languages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading and applying textures to the shape</h1>
                
            
            
                
<p>In this section, we'll look how to load textures in our code and learn to apply these textures to our objects. Textures is an image which is used add detail to an object. Imagine object such as cube and if we apply wooden texture to it, then it will look like a wooden box in our game world.</p>
<p>For this section, our object will be a rectangle. So first we'll learn how to draw rectangle shape in OpenGL and then understand how to apply textures to it. To apply texture to the shape, we'll prefer when using SOIL library, which is the Simple OpenGL Image Library. If you wish, you can use other libraries such as libpng which, as the name suggests, just supports PNG format images. But in this section, we'll only learn about SOIL, actually about SOIL2.</p>
<p>SOIL is a cross-platform library and it's supported on Android and iOS as part of game development. GLFW doesn't have any image loading methods built in, that is the reason why we are going to use SOIL library to load our textures. Also, SOIL helps in making our code as dynamic as possible across various platforms, and it's really easy to use as well.</p>
<p>So, first let's understand how to set up our project to use the SOIL library on Windows and Mac platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a project to use SOIL on Windows</h1>
                
            
            
                
<p>In this section, we'll understand how to set up our project to use the SOIL library on a Windows platform. So, we'll begin by downloading the SOIL library and Premake. You must be wondering, what is Premake? Premake is a command line tool used to generate project files for platforms such as Visual Studio, Xcode, and so on.</p>
<p>Follow these steps to understand the set up process:</p>
<ol>
<li>Open up your web browser and go to the following link <a href="https://bitbucket.org/SpartanJ">https://bitbucket.org/SpartanJ</a>. In the Repositories section click on the SOIL2 option and open the webpage, and select the first fork under Introduction for the latest version of SOIL library.</li>
</ol>
<p>The reason we are downloading the SOIL2 library is beacuse the original SOIL library is actually very old and hasn't been updated for a very long time.</p>
<ol start="2">
<li>Once you've downloaded that, just search for Premake on Google or visit the following link: <a href="https://premake.github.io/">https://premake.github.io/</a>. Then, click on the Download option. It is recommended that you download the latest stable branch, so download the 4.4 version, which is currently stable (at the time of writing this book).</li>
<li>Next, go to the location where you've downloaded the files and extract both of the zipped folders.</li>
<li>Then, go to the <kbd>Premake</kbd> folder and copy and paste <kbd>premake4.exe</kbd> into the <kbd>SOIL</kbd> folder, which we just extracted.</li>
<li>Open up the command prompt and in here you may want to change the directory path to the location where you downloaded and extracted your <kbd>SOIL</kbd> folder. Suppose the <kbd>C:</kbd> drive is the drive where all your files get downloaded and you have downloaded and extracted your <kbd>SOIL</kbd> folder to that drive, then all you have to do is type <kbd>cd</kbd> in command prompt and then just drag and drop your <kbd>SOIL</kbd> folder into it. It will automatically enter the path where the <kbd>SOIL</kbd> folder is located.</li>
</ol>
<p>If it's any other drive that your downloads go to, then what you have to do is first tell command prompt to change it to that particular drive. To do that, just type the actual letter of the drive then type <kbd>:</kbd> and hit <em>Enter</em>, and then you can follow the previous drag-and-drop process.</p>
<ol start="6">
<li class="mce-root">Next, in Command Prompt, type in <kbd>premake4.exe</kbd>—or whatever the executable is called—followed by <kbd>vs2017</kbd> and then hit <em>Enter</em>. This will generate our Visual Studio project.</li>
</ol>
<p>If you're using an older version, such as 2010, you can use 2010 in the <kbd>vs</kbd> command. It doesn't have a command for newer versions of Visual Studio, but if you enter that, it will prompt you to upgrade some of the properties, so don't worry about that.</p>
<ol start="7">
<li class="mce-root">Now let's go to our <kbd>SOIL</kbd> folder, open the <kbd>make</kbd> folder present inside it and then open up the <kbd>Windows</kbd> folder.</li>
<li class="mce-root">Inside the <kbd>Windows</kbd> folder, you'll get a <kbd>SOIL2.sln</kbd> file. Double-click on it and once that has opened in Visual Studio, you might get an upgrade the compiler, and libraries pop window. Just click on the OK button.</li>
<li class="mce-root">Then, in the Visual Studio, on the right-hand side, you'll see a filenames. The only one that we're concerned with is <kbd>soil2-static-lib</kbd>. Right-click on that file and then click on Build option. This will build our project. You can then close Visual Studio.</li>
<li class="mce-root">Now, if you go back to the <kbd>SOIL</kbd> folder, there'll be some more folders generated. The one we're interested in is the <kbd>lib</kbd> folder.</li>
<li class="mce-root">Inside the <kbd>lib</kbd> folder, there's a <kbd>Windows</kbd> folder which consists of the <kbd>.lib</kbd> file, which is what we need.</li>
<li class="mce-root">Copy that <kbd>.lib</kbd> file and go to the location where you have your OpenGL project created. What we'll do there is, the location where <kbd>.sln</kbd> file is present, we'll make a new folder and name it as <kbd>External Libraries</kbd>.</li>
<li class="mce-root">In the <kbd>External Libraries</kbd> folder we will create a sub folder called <kbd>SOIL2</kbd>, and inside that, we'll create a folder called <kbd>lib</kbd>.</li>
</ol>
<ol start="14">
<li class="mce-root">Then, in the <kbd>lib</kbd> folder that we created just now, paste the <kbd>soil2-debug.lib</kbd> file. So, this way we're going to use relative linking to link our SOIL library. If you are aware of the absolute linking process and wants to use it, you can use that.</li>
<li>And now, what we need to do is go back to the <kbd>SOIL</kbd> folder and copy the files present within the <kbd>SOIL2</kbd> folder and paste that in the <kbd>OpenGL_VisualStudio</kbd> folder which is present inside the <kbd>OpenGL</kbd> folder</li>
<li>So, once you've got all of these steps sorted, the one last thing to do is link up the <kbd>soil2-debug.lib</kbd> to our project. To link up the <kbd>.lib</kbd> file to our Visual Studio project with the relative linking, you can refer to the <em>Linking of GLFW and GLEW libraries with relative linking</em> section in the previous chapter.</li>
</ol>
<p>With this, we have set up our project to use the SOIL library on Visual Studio.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a project to use SOIL on Mac</h1>
                
            
            
                
<p>In this section, we'll understand how to set up our project to use the SOIL library on a Mac platform. Let's take a look at the following steps:</p>
<ol>
<li>Open up your web browser and go to the following link: <a href="https://bitbucket.org/SpartanJ">https://bitbucket.org/SpartanJ</a>. </li>
<li>In the Repositories section click on the SOIL2 option and open the webpage, and select the first fork under Introduction for the latest version of SOIL library.</li>
<li>Next, go to the location where you've downloaded the files and extract them. Once extracted, go to the <kbd>src</kbd> folder and in it go to the <kbd>SOIL2</kbd> folder. Then just copy and paste that folder into your project directory in your system, which also contains your <kbd>main.cpp</kbd> and <kbd>shader</kbd> file.</li>
<li>Now, just add the library to our triangle project as you normally would. So, what we will do is right-click on the project in Xcode, go to the Add Files option, click on SOIL, and then click on the Add button.</li>
</ol>
<p>So, once we've got that included, that's it for the setup part. And now, we'll go back to our the code from the previous section and make modification to it so as to add textures to our shape.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying texture to our shape</h1>
                
            
            
                
<p>Now that we're all set up to use the SOIL library, let's go to our triangle code and make the necessary changes to load our shape and apply texture to it. Follow these steps:</p>
<ol>
<li>So, we'll first include the SOIL library into our code; for that, type in the following line at the start of your code:</li>
</ol>
<pre style="padding-left: 60px">#include SOIL2/SOIL2.h</pre>
<p style="padding-left: 60px">Here, we have typed <kbd>SOIL2/SOIL2.h</kbd> because our library is inside the <kbd>SOIL2</kbd> folder.</p>
<ol start="2">
<li>The next thing we're going to do is enable the alpha support for images with extension such as PNG. To do that, type in the following lines of code after we have defined out <kbd>glViewport()</kbd> :</li>
</ol>
<pre style="padding-left: 60px">// enable alpha support<br/> glEnable( GL_BLEND );<br/> glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );</pre>
<p style="padding-left: 60px">In the preceding lines of code, the <kbd>glEnable( GL_BLEND )</kbd> function will help in blending the image in our shape. Then we used <kbd>glBlendFunc()</kbd> and to it we passed two parameters <kbd>GL_SRC_ALPHA</kbd> and <kbd>GL_ONE_MINUS_SRC_ALPHA</kbd>. This is how we enabled the alpha support.</p>
<ol start="3">
<li>Next, we'll have to modify our vertices as we'll be using a rectangular shape to apply our texture, and also we'll have to add coordinates for our texture too. So take a look at the following vertices array and make the necessary changes to your code:</li>
</ol>
<pre style="padding-left: 60px">// Set up vertex data (and buffer(s)) and attribute pointers<br/> GLfloat vertices[] =<br/> {<br/> // Positions         // Colors             // Texture Coords<br/> 0.5f, 0.5f, 0.0f,    1.0f, 0.0f, 0.0f,     1.0f, 1.0f, // Top Right<br/> 0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,     1.0f, 0.0f, // Bottom Right<br/>-0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,     0.0f, 0.0f, // Bottom Left<br/>-0.5f, 0.5f, 0.0f,    1.0f, 1.0f, 0.0f,     0.0f, 1.0f  // Top Left<br/> }; </pre>
<p class="mce-root"/>
<p class="mce-root" style="padding-left: 60px">As we're going to draw a rectangle, we need four different vertices: bottom left, bottom right, top left, and top right. In the preceding code, the values that we've added don't actually range between -1 and 1; these values range between 0 and 1 so are know as normalized values. You might hear this term in computer graphics quite a lot. Normalized values basically means the values ranged between 0 and 1. So, for example, if you had an image that has a width of 1280 x 1280, and the normalized version was 0 to 1, if you were to set a value of 0.5, it would be at 640 because it's halfway along and halfway between 0 and 1280 is 640. This is just a very basic overview of normalization. If you want to know a bit more about it, feel free to Google it.</p>
<ol start="4">
<li>The next thing we're going to create is another array for indices. Take a look at the following code and let's try to understand it:</li>
</ol>
<pre style="padding-left: 60px">GLuint indices[] =<br/> { // Note that we start from 0!<br/> 0, 1, 3, // First Triangle<br/> 1, 2, 3 // Second Triangle<br/> };</pre>
<p style="padding-left: 60px">The reason we've defined two triangles in the preceding array is, as we're drawing a quadrilateral in this section, our rectangle shape actually requires two triangle indices to be defined. Take a look at the following image to understand the concept:</p>
<div><img class="aligncenter size-full wp-image-379 image-border" src="img/47de2a46-2347-4650-a95c-a7b8d7498a2d.png" style=""/></div>
<p style="padding-left: 60px">The preceding image shows defining of the triangle coordinates with and without indexing. So, let's have a look at the without indexing part. Without indexing, to draw a quadrilateral you'll need six different vertices, as seen in the image. Even though there are two pairs of similar coordinates that are shared between the two triangles, the vertices are not being efficiently defined. With indexing approach, however, we can share the vertices. So, as in the with indexing image, the two triangles share the same pair of vertices. So we'll reuse those and as a result, we'll be defining only four vertices. Ignore the numbering shown in the image; it's slightly different to our situation, but the principle still applies. And if you try and draw it out on paper and apply the numbers that we got in our indices array to the actual triangle or quadrilateral from the two, it will make a lot more sense. It might not be obvious why you would want to do this at the moment, and that's because we're only drawing a quadrilateral. But, imagine when you have a game and you've got thousands if not millions of triangles, and triangles forming various complex shapes. Thus this with indexing approach really becomes handy and increase the efficiency of your code.</p>
<ol start="5">
<li>Next, in our <kbd>GLuint</kbd> section below our indices, we want to create another buffer called <kbd>EBO</kbd>, so make the change to the code as highlighted in the following line:</li>
</ol>
<pre style="padding-left: 60px">GLuint VBO, VAO, <strong>EBO</strong>;</pre>
<ol start="6">
<li>We need to generate the buffers for the Element Buffer Objects (EBO), so type in the following highlighted lines of code and then we also need to bind that buffer :</li>
</ol>
<pre style="padding-left: 60px"> glGenVertexArrays(1,&amp;VAO);<br/> glGenBuffers(1,&amp;VBO );<br/>//Generating EBO<br/><strong> glGenBuffers(1,&amp;EBO );</strong><br/> <br/> glBindVertexArray( VAO );<br/> <br/> glBindBuffer( GL_ARRAY_BUFFER, VBO );<br/> glBufferData( GL_ARRAY_BUFFER, sizeof( vertices ), vertices, GL_STATIC_DRAW );<br/> //Binding the EBO<br/><strong> glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, EBO );</strong><br/><strong> glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof( indices ), indices, GL_STATIC_DRAW );</strong></pre>
<ol start="7">
<li>Next, we'll modify our position and the color attributes, and we'll add one more attribute that is the texture coordinate attribute. Let's check out the following highlighted code and try to understand the modifications done to it:</li>
</ol>
<pre style="padding-left: 60px"> // Position attribute<br/> glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, <strong>8</strong> * sizeof( GLfloat ), ( GLvoid * ) 0 );<br/> glEnableVertexAttribArray(0);<br/> // Color attribute<br/> glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, <strong>8</strong> * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );<br/> glEnableVertexAttribArray(1);<br/> // Texture Coordinate attribute<br/> <strong>glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof( GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );</strong><br/><strong> glEnableVertexAttribArray( 2 );</strong></pre>
<p style="padding-left: 60px">For the position and the color attributes in the preceding code, we have replaced <kbd>6</kbd> with <kbd>8</kbd>, as we have eight coordinates in our vertices array: three for the position, three for the colors, and two for the texture coordinates. And then, we created another vertex attribute pointer as the texture coordinate attribute.</p>
<ol start="8">
<li>Next, we're going to add the texture loading code. In our main code, after we've unbinded our vertex array and before the start of <kbd>while</kbd> loop, we'll add the texture loading code.</li>
<li>Firstly we'll need to create an <kbd>GLuint</kbd> <kbd>texture</kbd> variable as this will hold our reference to the texture.</li>
<li>Next, we'll create <kbd>int</kbd> variables as <kbd>width</kbd> and <kbd>height</kbd>. This will define the width and the height of our texture.</li>
<li>Then we'll need to add <kbd>glGenTextures()</kbd> function and for this, we specify the <kbd>size</kbd> as <kbd>1</kbd> and put a reference to our texture variable.</li>
<li>We'll then bind the texture using <kbd>glBindTexture()</kbd> funtion. Take a look at the following highlighted code:</li>
</ol>
<pre style="padding-left: 60px">glBindVertexArray( 0 ); // Unbind VAO<br/> <br/> // Load and create a texture<br/><strong> GLuint texture;</strong><br/><strong> int width, height;</strong><br/> // Texture<br/><strong> glGenTextures( 1, &amp;texture );</strong><br/><strong> glBindTexture( GL_TEXTURE_2D, texture );</strong></pre>
<ol start="13">
<li>And then, we are going to set our texture parameters. For that, we're going to add function <kbd>glTexParameteri ()</kbd> and to this function, we'll pass the following parameter:
<ul>
<li>The first parameter that we're going to set is <kbd>GL_TEXTURE_2D</kbd></li>
<li>Then for the <kbd>name</kbd> we're going to set the type of wrapping that we'll be using <kbd>GL_TEXTURE_WRAP_S</kbd>.</li>
<li>And for the wrapping, we're going to add <kbd>GL_REPEAT</kbd>.</li>
</ul>
</li>
</ol>
<p>It is recommended you have a look at different wrapping techniques. You can find more information about this in the OpenGL API guides and if you look at <a href="https://learnopengl.com/">learnopengl.com</a> and <a href="https://open.gl/">open.gl</a>, you will get to read a lot more information about all the lines of code that we have written.</p>
<ol start="14">
<li>So, what we're going to do next is duplicate the previous line of code and make the following changes as highlighted in the code:</li>
</ol>
<pre style="padding-left: 60px">// Set our texture parameters<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );<br/> glTexParameteri( GL_TEXTURE_2D, <strong>GL_TEXTURE_WRAP_T</strong>, GL_REPEAT );</pre>
<ol start="15">
<li>Next, we're going to set the texture filtering. Check out the following code for it:</li>
</ol>
<pre style="padding-left: 60px">// Set texture filtering<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<br/> glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );</pre>
<ol start="16">
<li>Now, we are going to add the actual texture loading code to the main code. For that, we're going to create unsigned char variable <kbd>*image</kbd> and this will hold the reference to the function <kbd>SOIL_load_image()</kbd>. And to this function we pass the following parameters:
<ul>
<li>First parameter will be the path of the actual image that we're going to use as texture for our object. Therefore, we'll put <kbd>res/images/image1.jpg</kbd>.</li>
<li>The second parameter will be the refrence to the width and the height of our image.</li>
<li>Then for the third parameter, we're just going to pass it as <kbd>0</kbd>.</li>
<li>For the fourth parameter we're going to set the loading method so will add <kbd>SOIL_LOAD_RGBA</kbd>. Even if it's a JPEG image, you always want to load it as an alpha image. The reason for that is, it allows the code that we're writing now to be more dynamic. So if we swap the JPEG image for a PNG image, it'll still work. If you put in a different type of alpha image, or an image without alpha, as long as that type is supported by SOIL, the code will work fine.</li>
</ul>
</li>
</ol>
<pre style="padding-left: 90px"> unsigned char *image = SOIL_load_image( "res/images/image1.jpg", &amp;width, &amp;height, 0, SOIL_LOAD_RGBA );</pre>
<ol start="17">
<li>Next, we'll specify a two-dimensional texture image adding the function <kbd>glTexImage2d()</kbd> and to this function we are going to pass the highlighted parameters in the following code:</li>
</ol>
<pre style="padding-left: 60px">// Load, create texture <br/>glTexImage2D( <strong>GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image</strong> );</pre>
<ol start="18">
<li>We'll generate the mipmaps, so we're going to put <kbd>glGenerateMipmap()</kbd> funtion. And for this function, we specify <kbd>GL_TEXTURE_2D</kbd> as it's a 2D texture that we are using.</li>
<li>Then, we're going to free our image data, as it's always good to clean up. So, we'll add <kbd>SOIL_free_image_data()</kbd> function for that we merely specify our image character array.</li>
<li>Then, we're going to unbind the texture using <kbd>glBindTexture()</kbd> function and to that function we'll pass <kbd>GL_TEXTURE_2D</kbd>, and we'll unbind the texture by passing <kbd>0</kbd>. Have a look at the following code for a clear understanding:</li>
</ol>
<pre style="padding-left: 60px">//Generate mipmaps<br/>glGenerateMipmap( GL_TEXTURE_2D );<br/>SOIL_free_image_data( image );<br/>glBindTexture( GL_TEXTURE_2D, 0 );</pre>
<p>You might be thinking what is a mipmap? A mipmap is essentially a level of detail scheme for texture image. It's a way of creating a bunch of small images by a factor of 2 of the original image, and then loading the one that is the closest to the actual texture being displayed at any given point, depending on the distance from the viewer. So if something's further away, the texture required isn't as big. Whereas if it's nearer, it requires a bigger texture. So, it just helps in loading the texture properly. It is recommended to have a quick check on the internet to understand mipmapping a bit more.</p>
<p>We're not done with our code yet. So, we'll move on to our while loop now</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying the while loop</h1>
                
            
            
                
<p>Let's follow the below mentioned steps:</p>
<ol>
<li>In the while loop we'll put some code between the point where we're using the shader and where we're binding the vertex array. What we want to do here is add <kbd>glActiveTexture()</kbd>function. This function will help us activating the texture that we specify.</li>
<li>Then, we'll add function <kbd>glBindTexture()</kbd>. And for this function, we pass <kbd>GL_TEXTURE_2D</kbd> and <kbd>texture</kbd>.</li>
<li>Next, we just add <kbd>glUniform1i()</kbd> function and pass to it the following highlighted parameters.</li>
</ol>
<pre style="padding-left: 60px">// Draw the triangle<br/> ourShader.Use( );<br/> glActiveTexture( GL_TEXTURE0 );<br/> glBindTexture( GL_TEXTURE_2D, texture );<br/> glUniform1i( <strong>glGetUniformLocation( ourShader.Program, "ourTexture" ), 0</strong> );<br/> </pre>
<ol start="4">
<li>Then we'll add the code to draw our container:</li>
</ol>
<pre style="padding-left: 60px"> // Draw container<br/> glBindVertexArray( VAO );<br/> glDrawElements( GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0 );<br/> glBindVertexArray( 0 );</pre>
<ol start="5">
<li>And the last thing that we need to do is just delete the buffer for the element buffer object. So, we'll add <kbd>glDeleteBuffers( 1, &amp;EBO );</kbd> to our code:</li>
</ol>
<pre style="padding-left: 60px">// Properly de-allocate all resources once they've outlived their purpose<br/> glDeleteVertexArrays( 1, &amp;VAO );<br/> glDeleteBuffers( 1, &amp;VBO );<br/><strong> glDeleteBuffers( 1, &amp;EBO );</strong><br/> <br/> // Terminate GLFW, clearing any resources allocated by GLFW.<br/> glfwTerminate( );</pre>
<p>And now, if we run our code. There will be some error in the compilation of the code and you will get the output similar to the following image:</p>
<div><img class="aligncenter size-full wp-image-296 image-border" src="img/0898dfef-fc48-41c6-87d2-e2a4133820bb.png" style=""/></div>
<p>This is not what we intended; this is obviously not what we wanted to load in our shape. So, let's try to understand the reason behind this. The only reason we are getting the wrong output is because we have not updated our vertex and fragment shaders for loading the texture. So let's update it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the shader files to integrate texture coordinates</h1>
                
            
            
                
<p class="mce-root">Follow these steps to carry out the modifications in your shader files:</p>
<ol>
<li>First, let's go to the vertex shader, our <kbd>core.vs</kbd> file, and make the changes highlighted in the following code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/>layout (location = 1) in vec3 color;<br/><strong>layout (location = 2) in vec2 texCoord;</strong><br/>out vec3 ourColor;<br/><strong>out vec2 TexCoord;</strong><br/>void main()<br/>{<br/> gl_Position = vec4(position, 1.0f);<br/> ourColor = color;<br/> // We swap the y-axis by substracing our coordinates from 1. This is done because most images have the top y-axis inversed with OpenGL's top y-axis.<br/> // TexCoord = texCoord;<br/><strong> TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);</strong><br/>}</pre>
<p style="padding-left: 60px">You might be wondering what are we doing here in <kbd>TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);</kbd>. Well, what we're doing is swapping the y axis by subtracting our coordinates from <kbd>1</kbd>, and this is done simply because most images have the top y-axis inverted in OpenGL.</p>
<ol start="2">
<li>Next, go to the fragment shader, <kbd>core.frag</kbd>, and make the following highlighted modifications:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>in vec3 ourColor;<br/><strong>in vec2 TexCoord;</strong><br/>out vec4 color;<br/>// Texture samplers<br/>uniform sampler2D ourTexture1;<br/>void main()<br/>{<br/> // Linearly interpolate between both textures (second texture is //only slightly combined)<br/> <strong>color = texture(ourTexture1, TexCoord);</strong><br/>}</pre>
<p>And now, if we save the updated shader file and run our program, we will get the following output:</p>
<div><img src="img/7c4c10d5-abb9-4730-93e0-6867b3ef2cd9.png" style=""/></div>
<p>Check whether your image fit are spot on with the ratio. If it looks a bit squashed, that's simply because of the coordinates that we have defined for the vertices. It's nothing to do with the texture loading. In later chapters, we'll be learning to use logical coordinates, so that any image that you load can fit in properly. So, that is it for texture loading.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to draw various shapes using shaders. We began by drawing a triangle and adding color to it. Then, we used the triangle concept to draw our quadrilateral and learned how to apply texture to it.</p>
<p>In the next chapter, we'll learn how to apply transformations such as translation and rotation to our shape, and learn to draw a cube and apply texture to it. We'll also explore the concepts of projections: Perspective and Orthographic, and how to implement those in our world.</p>


            

            
        
    </body></html>