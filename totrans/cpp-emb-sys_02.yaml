- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Debunking Common Myths about C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 澄清关于C++的常见误解
- en: Writing software for microcontrollers and embedded systems is challenging. In
    order to get the most out of resource-constrained systems, embedded developers
    need to have a good knowledge of platform architecture. They need to be aware
    of available resources, including processor capabilities, available memory, and
    peripherals. The need to have direct access to hardware through memory-mapped
    peripherals has made **C** the language of choice for embedded systems for half
    a century.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为微控制器和嵌入式系统编写软件具有挑战性。为了充分利用资源受限的系统，嵌入式开发者需要对平台架构有良好的了解。他们需要了解可用的资源，包括处理器能力、可用内存和外设。通过内存映射外设直接访问硬件的需求使得**C**成为嵌入式系统半个世纪以来的首选语言。
- en: The goal of any programming language is to carry out the process of converting
    application-specific abstractions into code that can be transformed into machine
    code. For instance, **Common Business-Oriented Language** (**COBOL**) is used
    for banking applications, and **Fortran** is used for scientific research and
    heavy mathematic calculations. C is, on the other hand, a general-purpose programming
    language commonly used in **operating systems** (**OSs**) and embedded system
    applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的目标都是将应用特定的抽象转换为可转换为机器代码的代码。例如，**面向商业的通用语言**（**COBOL**）用于银行应用，而**Fortran**用于科学研究和大型的数学计算。另一方面，C是一种通用编程语言，常用于**操作系统**（**OSs**）和嵌入式系统应用。
- en: C is a language with a simple and easy-to-learn syntax. Having a simple syntax
    means it is incapable of expressing complex ideas. C allows for complex operations
    but requires more explicit and detailed code to manage complexity, compared to
    higher-level languages that abstract these details away.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C是一种语法简单、易于学习的语言。语法简单意味着它无法表达复杂的思想。与抽象这些细节的高级语言相比，C允许进行复杂操作，但需要更明确和详细的代码来管理复杂性。
- en: 'In the late 1970s, high-level languages couldn’t meet the performance of C.
    This motivated Danish computer scientist Bjarne Stroustrup to start working on
    **C with Classes**, a predecessor to C++. Nowadays, C++ is a multiparadigm language
    designed with performance in mind. The origin of C++ is still a source of some
    myths, which often causes hesitation in adopting it for embedded systems programming.
    This chapter will introduce you to those myths and debunk them. The following
    topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代末，高级语言的性能无法达到C的水平。这促使丹麦计算机科学家Bjarne Stroustrup开始研究**带类的C**，它是C++的前身。如今，C++是一种以性能为设计目标的泛型语言。C++的起源仍然是某些神话的来源，这常常导致人们在嵌入式系统编程中对其犹豫不决。本章将向你介绍这些神话，并对其进行澄清。本章将涵盖以下主题：
- en: A short history of C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++简史
- en: C with Classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带类的C
- en: Bloat and runtime overhead
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 肥大和运行时开销
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. The
    examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter01](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter01)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议你在阅读示例时使用编译器探索器([https://godbolt.org/](https://godbolt.org/))。选择GCC作为你的编译器，并针对x86架构。这将允许你看到标准输出（stdio）结果，并更好地观察代码的行为。本章的示例可在GitHub上找到([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter01](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter01))。
- en: A short history of C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++简史
- en: In the mid-60s, the simulation programming language **SIMULA** introduced classes
    and objects to the world of software development. **Classes** are abstractions
    that allow us to represent real-world concepts in programming in a concise way,
    making the code more human-readable. In embedded development, **UART**, **SPI**,
    **TemperatureSensor**, **PidController**, and **TemperatureController** are some
    concepts that can be implemented as classes. SIMULA also introduced hierarchical
    relationships between classes. For example, `PT100` class is also a `TemperatureSensor`
    class, and `TemperatureController` class has a member instance (object) of `TemperatureSensor`
    and a `PidController`. This became known as **object-oriented programming** (**OOP**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代中期，模拟编程语言**SIMULA**将类和对象引入了软件开发的世界。**类**是一种抽象，它允许我们以简洁的方式在编程中表示现实世界概念，使代码更易于人类阅读。在嵌入式开发中，**UART**、**SPI**、**TemperatureSensor**、**PidController**和**TemperatureController**是一些可以以类形式实现的概念。SIMULA还引入了类之间的层次关系。例如，`PT100`类也是`TemperatureSensor`类，而`TemperatureController`类有一个`TemperatureSensor`成员实例（对象）和一个`PidController`。这被称为**面向对象编程**（**OOP**）。
- en: 'In reflecting on the evolution of programming languages, Bjarne Stroustrup,
    the creator of C++, shared his approach to designing C++. Stroustrup aimed to
    bridge the gap between high-level abstractions and low-level efficiency. He said
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在反思编程语言的演变时，C++的创造者Bjarne Stroustrup分享了他设计C++的方法。Stroustrup的目标是在高级抽象和低级效率之间架起桥梁。他说了以下内容：
- en: My idea was very simple. To take ideas from SIMULA for general abstractions
    for the benefits of humans representing things, so humans could get it, with low-level
    stuff, which at that time the best language for that was C, which was done at
    Bell Labs by Dennis Ritchie. And take those two ideas and bring them together
    so that you could do high-level abstraction, but efficiently enough and close
    enough to hardware, for really demanding computing tasks
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我的想法非常简单。从SIMULA中汲取一般抽象的想法，以利于人类表示事物，使人类能够理解，同时使用低级的东西，当时最好的语言是C，这是在贝尔实验室由Dennis
    Ritchie完成的。将这两个想法结合起来，以便可以进行高级抽象，同时足够高效且足够接近硬件，以处理真正要求高的计算任务。
- en: Originally started as C with Classes by Bjarne Stroustrup, C++ transformed into
    a modern programming language that still provides direct access to hardware and
    memory-mapped peripherals. Using powerful abstractions makes writing expressive
    and highly modular code possible in C++. C++ is a general-purpose, multiparadigm
    language supporting procedural, object-oriented, and, to some extent, functional
    programming paradigms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++最初是由Bjarne Stroustrup以C with Classes开始，演变成一种现代编程语言，它仍然提供了对硬件和内存映射外设的直接访问。使用强大的抽象，C++使得编写表达性和高度模块化的代码成为可能。C++是一种通用、多范式的语言，支持过程式、面向对象编程，并在一定程度上支持函数式编程范式。
- en: While C is still the language of choice for embedded development, accounting
    for up to 60% of embedded projects, the adoption of C++ has grown steadily. With
    an estimated usage of 20-30% in the embedded development field, C++ offers classes,
    improved type safety, and compile-time computation, among other features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C语言仍然是嵌入式开发的首选语言，占嵌入式项目的60%，但C++的采用率稳步增长。在嵌入式开发领域的估计使用率为20-30%，C++提供了类、改进的类型安全和编译时计算等功能。
- en: Despite the features that C++ offers, C is still dominant in embedded programming.
    There are many reasons for this, and this chapter will address some of them. C++
    is a more complex language than C, making it harder for beginner developers. C
    is easier to learn and makes it possible to involve beginner developers in a project
    faster.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++提供了许多功能，但在嵌入式编程中，C语言仍然占据主导地位。有许多原因，本章将讨论其中的一些。C++比C语言更复杂，这使得初学者开发者更难上手。C语言更容易学习，并使得初学者开发者能够更快地参与到项目中。
- en: The simplicity of C is good as it allows beginner developers to start contributing
    to projects faster, but it also makes writing complex logic too verbose. This
    usually results in a larger code base due to a lack of expressiveness. This is
    where C++ steps in with higher abstractions, which, if embraced, make code easier
    to read and comprehend.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的简洁性很好，因为它允许初学者开发者更快地开始为项目做出贡献，但它也使得编写复杂的逻辑过于冗长。这通常会导致代码库更大，因为缺乏表现力。这就是C++介入的地方，它提供了更高的抽象层次，如果得到充分利用，可以使代码更容易阅读和理解。
- en: The other reasons why C++ is not more widely adopted are related to myths about
    C++. It is still believed that C++ is just “C with classes,” that using C++ is
    absolutely unacceptable for safety-critical systems due to dynamic memory allocation
    in the standard library, or that it produces bloat code and adds space and time
    overhead. This chapter will address some of the most common myths about C++ in
    the context of embedded development. Let’s debunk these myths and shine a new
    light on C++ in embedded systems!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++未被更广泛采用的其他原因与关于C++的神话有关。人们仍然认为C++仅仅是“带有类的C”，或者由于标准库中的动态内存分配，使用C++对于安全性至关重要的系统是完全不可接受的，或者它会产生膨胀代码并增加空间和时间开销。本章将在嵌入式开发背景下解决一些关于C++最普遍的神话。让我们揭开这些神话，为嵌入式系统中的C++带来新的光芒！
- en: C with Classes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C with Classes
- en: Historically speaking, C++ started as C with Classes. The first C++ compiler,
    **Cfront**, converted C++ to C, but that was a long time ago. Over time, C and
    C++ evolved separately and are now defined by separate language standards. C has
    maintained its simplicity, while C++ has become a modern language that enables
    abstract solutions for problems without sacrificing performance levels. But C++
    is still sometimes called C with Classes, which implies that there is no added
    value in C++ except the classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史的角度来看，C++最初是C with Classes。第一个C++编译器**Cfront**将C++转换为C，但这已经是很久以前的事情了。随着时间的推移，C和C++分别发展，现在由不同的语言标准定义。C保持了其简洁性，而C++已经发展成为一门现代语言，它能够为问题提供抽象解决方案，而不牺牲性能水平。但C++有时仍然被称为C
    with Classes，这暗示C++除了类之外没有增加任何价值。
- en: The C++11 standard was released in 2011, and it is the second major version
    of C++. It is packed with features that modernize the language, such as range-based
    loops, lambdas, and `constexpr`. Subsequent releases, C++14, C++17, C++20, and
    C++23, kept modernizing the language and introducing features that make C with
    Classes merely a distant predecessor of modern C++.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准于2011年发布，是C++的第二大版本。它包含了许多使语言现代化的功能，如基于范围的循环、lambda和`constexpr`。随后的版本，C++14、C++17、C++20和C++23，继续使语言现代化并引入了使C
    with Classes仅仅成为现代C++的一个遥远前辈的功能。
- en: Modern C++
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Modern C++
- en: 'To demonstrate that C++ is not just C with Classes, let’s explore a couple
    of short C code examples and their modern C++ equivalents. Let’s start with a
    simple example of printing elements from an integer buffer:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明C++不仅仅是C with Classes，让我们探索几个简短的C代码示例及其现代C++等价物。让我们从一个简单的示例开始，即从整数缓冲区打印元素：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding C code can be translated into the following C++ code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述C代码可以转换为以下C++代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing we notice is that the C++ version is shorter. It has fewer words,
    and it’s closer to English than the C code. It is easier to read. Now, if you
    come from a C background and have not been exposed to higher-level languages,
    the first version may look easier to read, but let’s compare them. The first thing
    we notice is that the C code has defined the constant `N`, which determines the
    size of `buffer`. This constant is used to define `buffer` and as a boundary for
    the `for` loop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到的是C++版本的长度更短。它包含的单词更少，并且比C代码更接近英语。它更容易阅读。现在，如果你来自C背景并且没有接触过高级语言，第一个版本可能看起来更容易阅读，但让我们比较一下。我们首先注意到的是C代码定义了常量`N`，它决定了`buffer`的大小。这个常量用于定义`buffer`，并作为`for`循环的边界。
- en: Range-based loops, introduced in C++11, remove the cognitive burden of using
    the size of the container in the loop stop condition. The size information is
    already contained in the `std::array` container, which is utilized by the range-based
    loop to iterate through the array effortlessly. Also, there is no indexing of
    the buffer, as elements are accessed using constant reference, ensuring that the
    elements are not modified inside the loop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中引入的基于范围的循环消除了在循环停止条件中使用容器大小的认知负担。大小信息已经包含在`std::array`容器中，基于范围的循环利用这个容器轻松地遍历数组。此外，没有对缓冲区的索引，因为元素是通过常量引用访问的，确保在循环内部不会修改元素。
- en: 'Let’s look at some simple C code that copies all elements from the `array_a`
    integer to `array_b` if smaller than `10`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些简单的C代码，它将`array_a`整数中的所有元素复制到`array_b`，如果元素小于`10`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the C++ code with the same functionality:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是具有相同功能的C++代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of manually iterating through `array_a` and copying elements to `array_b`
    only if they exceed `10`, we can use the `copy_if` function from C++’s standard
    template library. The first two arguments for `std::copy_if` are iterators that
    define the range of elements to consider in `array_a`: the first iterator points
    to the beginning of the array, and the second iterator points to the position
    just beyond the last element. The third argument is the iterator pointing to the
    start of `array_b`, and the fourth is the `less_than_10` lambda expression.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动遍历`array_a`并将超过`10`的元素复制到`array_b`中，我们可以使用C++标准模板库中的`copy_if`函数。`std::copy_if`的前两个参数是迭代器，它们定义了在`array_a`中要考虑的元素范围：第一个迭代器指向数组的开始，第二个迭代器指向最后一个元素之后的位子。第三个参数是指向`array_b`起始位置的迭代器，第四个是`less_than_10`
    lambda表达式。
- en: A lambda expression is an anonymous function object that can be declared at
    a location where it’s invoked or passed as an argument to a function. Please note
    that lambdas will be covered in more detail in [*Chapter 10*](Chapter_10.xhtml).
    In the case of `std::copy_if`, the `less_than_10` lambda is used to determine
    whether elements from `array_a` are to be copied to `array_b`. We could also define
    a standalone `less_than_10` function that accepts an integer and returns a Boolean
    if it is larger than 10, but using a lambda, we can write this functionality close
    to the place where we pass it to an algorithm, which makes code more compact and
    expressive.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一个匿名函数对象，可以在调用它的位置声明，或者将其作为参数传递给函数。请注意，Lambda将在[*第10章*](Chapter_10.xhtml)中更详细地介绍。在`std::copy_if`的情况下，`less_than_10`
    lambda用于确定`array_a`中的元素是否要复制到`array_b`。我们也可以定义一个独立的`less_than_10`函数，该函数接受一个整数并返回一个布尔值，如果它大于10，但使用lambda，我们可以将此功能编写得接近我们将其传递给算法的位置，这使得代码更加紧凑和表达。
- en: Generic types
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Previous examples used the `std::array` standard library container. It is a
    class template that wraps a C-style array along with its size information. Please
    note that templates will be covered in more detail in [*Chapter 8*](Chapter_08.xhtml).
    When you use `std::array` with a specific underlying type and size, the compiler
    defines a new type in the process of **instantiation**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了`std::array`标准库容器。它是一个类模板，它包装了一个C风格数组及其大小信息。请注意，模板将在[*第8章*](Chapter_08.xhtml)中更详细地介绍。当你使用具有特定底层类型和大小的`std::array`时，编译器在实例化的过程中定义了一个新类型。
- en: '`std::array<int, 10>` creates a container type that has an underlying C-style
    array of integers with a size of `10`. The `std::array<int, 20>` is a container
    type that has an underlying C-style array of integers with a size of `20`. The
    `std::array<int, 10>` and `std::array<int, 20>` are different types. Both have
    the same underlying type, but a different size.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array<int, 10>`创建了一个容器类型，它有一个底层大小为`10`的整数C风格数组。`std::array<int, 20>`是一个容器类型，它有一个底层大小为`20`的整数C风格数组。`std::array<int,
    10>`和`std::array<int, 20>`是不同的类型。它们具有相同的底层类型，但大小不同。'
- en: '`std::array<float, 10>` would result in a third type, as it differs from `std::array<int,
    10>` by the underlying type. Using different parameters yields different types.
    Template types are generic types that become concrete only upon instantiation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array<float, 10>`会产生第三种类型，因为它与`std::array<int, 10>`在底层类型上不同。使用不同的参数会产生不同的类型。模板类型是泛型类型，只有在实例化时才会成为具体类型。'
- en: To better understand generic types and appreciate them, let’s examine the implementation
    of a ring buffer in C and compare it with a template-based solution in C++.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解泛型类型并欣赏它们，让我们检查C语言中环形缓冲区的实现，并将其与C++中基于模板的解决方案进行比较。
- en: Ring buffer in C
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C语言中的环形缓冲区
- en: 'A **ring** or **circular buffer** is a commonly used data structure in embedded
    programming. It is commonly implemented as a set of functions around an array
    with write and read indexes used to access elements of the array. The `count`
    variable is used for array space management. The interface consists of push and
    pop functions, which are explained here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**环形**或**循环缓冲区**是嵌入式编程中常用的数据结构。它通常通过一组函数实现，这些函数围绕一个数组，使用写和读索引来访问数组的元素。`count`变量用于数组空间管理。接口由push和pop函数组成，这里将进行解释：'
- en: A **push** function is used to store elements in a ring buffer. On every push,
    a data element is stored in the array, and the write index is incremented. If
    the write index becomes equal to the number of elements in the data array, it
    is reset to 0.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**函数用于将元素存储在环形缓冲区中。在每次推送时，数据元素存储在数组中，并增加写入索引。如果写入索引等于数据数组中的元素数量，则将其重置为0。'
- en: A **pop** function is used to retrieve an element from a ring buffer. On every
    pop, if the underlying array is not empty, we return an element of the array indexed
    with the read index. We increment the read index.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出**函数用于从环形缓冲区中检索一个元素。在每次弹出时，如果底层数组不为空，我们返回数组中由读取索引索引的元素。我们增加读取索引。'
- en: On every push, we increment the `count` variable and decrement it on pop. If
    the count becomes equal to the size of the data array, we need to move the read
    index forward.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次推送时，我们增加`count`变量，在弹出时减少它。如果计数等于数据数组的大小，我们需要将读取索引向前移动。
- en: 'Let us define the implementation requirements of the ring buffer we want to
    implement in our C module:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们想在C模块中实现的环形缓冲区的实现要求：
- en: It should not use dynamic memory allocation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不应该使用动态内存分配
- en: When the buffer is full, we will overwrite the oldest element
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当缓冲区满时，我们将覆盖最旧的元素
- en: Provide push and pop functions for storing data in the buffer and retrieving
    it
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为存储数据到缓冲区并检索它提供推送和弹出功能
- en: Integers will be stored in the ring buffer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数将被存储在环形缓冲区中
- en: 'Here is a simple solution for the preceding requirements in C:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是满足先前要求的C语言简单解决方案：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using a `for` loop to initialize the buffer. As the buffer size is `5`,
    values from `5` to `9` will be stored in the buffer as the ring buffer overwrites
    the existing data. Now, what if we want to store floats in our ring buffer, chars,
    or a user-defined data structure? We could implement the same logic for different
    types and create a new set of data structures and functions called `float_ring_buffer`
    or `char_ring_buffer`. Can we make a solution that could store different data
    types and use the same functions?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环来初始化缓冲区。由于缓冲区大小为`5`，值从`5`到`9`将存储在缓冲区中，因为环形缓冲区会覆盖现有数据。现在，如果我们想在环形缓冲区中存储浮点数、字符或用户定义的数据结构怎么办？我们可以为不同类型实现相同的逻辑，并创建一组新的数据结构和函数，称为`float_ring_buffer`或`char_ring_buffer`。我们能否创建一个可以存储不同数据类型并使用相同函数的解决方案？
- en: 'We could use an `unsigned char` array as storage for different data types and
    use a `void` pointer to pass different data types to push and pop functions. The
    only thing that’s missing is knowing the size of the data type, and we can address
    that by adding a `size_t elem_size` member to the `ring_buffer` structure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`unsigned char`数组作为不同数据类型的存储，并使用`void`指针将不同数据类型传递给推送和弹出函数。唯一缺少的是知道数据类型的大小，我们可以通过向`ring_buffer`结构添加`size_t
    elem_size`成员来解决：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This ring buffer solution can be used to store different data types. As we avoid
    using dynamic memory allocation and the `data` buffer size was determined at compile
    time, we are not flexible when it comes to defining the size of the memory needed
    for different instances of the ring buffer. Another problem we have is type safety.
    We can easily call `ring_buffer_push` with a pointer to a float and `ring_buffer_pop`
    with a pointer to an integer. The compiler can’t address this concern, and the
    possibility of a catastrophe is real. Also, by using a void pointer, we added
    a layer of indirection as we have to rely on memory to retrieve data from the
    data buffer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此环形缓冲区解决方案可以用于存储不同数据类型。由于我们避免了使用动态内存分配，并且`data`缓冲区大小是在编译时确定的，因此我们在定义环形缓冲区不同实例所需的内存大小时不够灵活。我们遇到的另一个问题是类型安全。我们可以轻松地用指向浮点数的指针调用`ring_buffer_push`，用指向整数的指针调用`ring_buffer_pop`。编译器无法解决这个问题，灾难的可能性是真实的。此外，通过使用`void`指针，我们增加了一层间接引用，因为我们必须依赖内存从数据缓冲区检索数据。
- en: 'Can we address type-safety concerns and make it possible to define the size
    of the ring buffer in C? We can use the token-pasting (`##`) operator to create
    a set of functions for different types and sizes using macros. Let’s quickly go
    through a simple example of using the `##` operator before jumping into ring buffer
    implementation using this technique:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否解决类型安全问题，并使在C中定义环形缓冲区的大小成为可能？我们可以使用标记粘贴（`##`）运算符为不同类型和大小创建一组函数，使用宏。在跳入使用此技术实现的环形缓冲区实现之前，让我们快速通过使用`##`运算符的简单示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`DEFINE_SUM_FUNCTION(int)` will create a `sum_int` function that accepts and
    returns integers. If we call the `DEFINE_SUM_FUNCTION` macro with `float`, it
    will result in creating `sum_float`. Now that we have a good understanding of
    the token-pasting operator, let’s continue with ring buffer implementation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFINE_SUM_FUNCTION(int)`将创建一个接受并返回整数的`sum_int`函数。如果我们用`float`调用`DEFINE_SUM_FUNCTION`宏，它将导致创建`sum_float`。现在我们已经很好地理解了标记粘贴操作符，让我们继续环形缓冲区的实现：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, this solution solves our problems of type safety and defining the size
    of a ring buffer, but it suffers from readability, both in implementation and
    when using it. We need to “call” `DECLARE_RING_BUFFER` outside of any function,
    as it is basically a macro that defines a set of functions. We also need to know
    what it does and the signature of functions it will generate. We can do this better
    with templates. Let’s see what an implementation of a ring buffer looks like in
    C++.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个解决方案解决了我们的类型安全和定义环形缓冲区大小的难题，但它在实现和使用时都存在可读性问题。我们需要在任意函数之外“调用”`DECLARE_RING_BUFFER`，因为它基本上是一个定义了一组函数的宏。我们还需要了解它所执行的操作以及它将生成的函数的签名。我们可以通过模板做得更好。让我们看看C++中环形缓冲区的实现是什么样的。
- en: Ring buffer in C++
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++中的环形缓冲区
- en: 'Let’s make a generic implementation of a ring buffer using templates. We can
    use a `std::array` class template as the underlying type and wrap our push-and-pop
    logic around it. The following is code that illustrates how the `ring_buffer`
    type could look in C++:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模板制作一个通用的环形缓冲区实现。我们可以使用`std::array`类模板作为底层类型，并将我们的推入和弹出逻辑围绕它包装。以下是在C++中`ring_buffer`类型可能看起来如何的代码示例：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The ring buffer implementation in C++ using templates is more readable and easier
    to use than the token-pasting-based solution in C. The `ring_buffer` template
    class can be used to instantiate ring buffer types with integer, float, or any
    other underlying types with different sizes. The same push-and-pop logic can be
    applied to ring buffers with different underlying types. We can apply the **Don’t
    Repeat Yourself** (**DRY**) principle to different types thanks to templates.
    **Templates** make generic types easy to implement, something that’s quite challenging
    and verbose in C.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板在C++中实现的环形缓冲区比C中基于标记粘贴的解决方案更易于阅读和使用。`ring_buffer`模板类可以用来实例化具有不同大小的整数、float或其他底层类型的环形缓冲区类型。相同的推入和弹出逻辑可以应用于具有不同底层类型的环形缓冲区。我们可以通过模板将**DRY**原则应用于不同的类型。**模板**使得泛型类型的实现变得简单，这在C中相当具有挑战性和冗长。
- en: Templates are also used for **template metaprogramming** (**TMP**), a programming
    technique in which a compiler uses templates to generate temporary source code,
    which is merged by the compiler with the rest of the source code and then compiled.
    One of the most famous examples of TMP is calculating a **factorial at compile
    time**. TMP is an advanced technique that will be covered in [*Chapter 8*](Chapter_08.xhtml).
    Modern C++ also features the `constexpr` specifier, a much more beginner-friendly
    technique for compile-time computation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也被用于**模板元编程**（**TMP**），这是一种编程技术，其中编译器使用模板生成临时源代码，然后编译器将其与源代码的其余部分合并，并最终编译。TMP最著名的例子之一是在编译时计算**阶乘**。TMP是一种高级技术，将在[*第8章*](Chapter_08.xhtml)中介绍。现代C++还引入了`constexpr`指定符，这是一种更易于初学者使用的编译时计算技术。
- en: constexpr
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`constexpr`'
- en: 'C++11 introduced the `constexpr` specifier, which declares that it is possible
    to evaluate the value of the function or a variable at compile time. The specifier
    evolved over time, extending the functionality. A `constexpr` variable must be
    immediately initialized, and its type must be a `literal` type (int, float, etc.).
    This is how we declare a `constexpr` variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了`constexpr`指定符，它声明了在编译时评估函数或变量的值是可能的。指定符随着时间的推移而演变，扩展了其功能。一个`constexpr`变量必须立即初始化，并且其类型必须是`literal`类型（int、float等）。这就是我们声明`constexpr`变量的方式：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the `constexpr` specifier is the preferred way of declaring compile-time
    constants in C++ over using a C-style approach with macros. Let’s analyze a simple
    example using C-style macros:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`constexpr`指定符是声明C++中编译时常量的首选方法，而不是使用C风格的宏方法。让我们分析一个使用C风格宏的简单示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both `VOLTAGE` and `CURRENT` are parsed as integer `literal`s, and so is the
    result of the division. Floating-point `literal`s are declared using the `f` suffix,
    which was omitted in this case. Using `constexpr` to define compile-time constants
    is safer, as it allows us to specify the type of a constant. This is how we would
    write the same example using `constexpr`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLTAGE`和`CURRENT`都被解析为整数`字面量`，除法的结果也是如此。使用`f`后缀声明浮点`字面量`，在这个例子中省略了。使用`constexpr`来定义编译时常量更安全，因为它允许我们指定常量的类型。这就是我们如何使用`constexpr`编写相同示例的方法：'
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This simple example shows that `constexpr` compile-time constants are both
    safer and easier to read than traditional C-style macro constants. The other major
    usage of the `constexpr` specifier is to hint to the compiler that a function
    can be evaluated at compile time. Some of the requirements that a `constexpr`
    function must meet are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子表明，`constexpr`编译时常量比传统的C风格宏常量更安全、更容易阅读。`constexpr`指定符的另一个主要用途是向编译器暗示一个函数可以在编译时评估。一个`constexpr`函数必须满足的一些要求如下：
- en: The return type must be a `literal` type
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型必须是一个`字面量`类型
- en: Each of the function parameters must be a `literal` type
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的每个参数必须是一个`字面量`类型
- en: If the `constexpr` function is not a constructor, it needs to have precisely
    one `return` statement
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`constexpr`函数不是一个构造函数，它需要恰好有一个`return`语句
- en: 'Let us examine a simple example utilizing `constexpr` functions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个使用`constexpr`函数的简单例子：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To better understand what is going on under the hood, we will inspect the assembly
    output of the preceding code. Assembly is quite close to the machine code, or
    the instructions that will be executed on our target, thus inspecting it gives
    us an estimate of the work (number of instructions) performed by the processor.
    The assembly output of the compilation of the preceding program for the ARM architecture
    using an ARM GCC compiler and no optimization is shown in the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解底层发生了什么，我们将检查前面代码的汇编输出。汇编代码非常接近机器代码，或者将在我们的目标上执行的指令，因此检查它给我们提供了处理器执行的工作（指令数）的估计。以下是在没有优化的情况下，使用ARM
    GCC编译器为ARM架构编译前面程序生成的汇编输出：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The resulting assembly code is doing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的汇编代码正在执行以下操作：
- en: Manipulating the stack pointer
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作栈指针
- en: Calling the square function
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`square`函数
- en: Storing value returned by `r0` to address contained into `r7` with offset `4`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`r0`返回的值存储到`r7`地址中，偏移量为`4`
- en: Loading the value from address stored in `r7` with offset `4` into `r3`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从偏移量为`4`的`r7`地址中加载值到`r3`
- en: Moving the value from `r3` to `r0`, which is the ARM calling convention’s designated
    register for storing return values
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`r3`的值移动到`r0`，这是ARM调用约定用于存储返回值的指定寄存器
- en: We can see that there are some unnecessary operations in the output binary,
    which both increase the binary size and affect the performance. This example is,
    both valid C and valid C++ code, and compiling it with both C and C++ compilers
    will yield the same assembly code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到输出二进制文件中存在一些不必要的操作，这既增加了二进制文件的大小，又影响了性能。这个例子是有效的C和有效的C++代码，使用C和C++编译器编译它将产生相同的汇编代码。
- en: 'If we use the `constexpr` specifier for the `square` function, we are instructing
    the compiler that it is possible to evaluate it at compile time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`square`函数使用`constexpr`指定符，我们是在指示编译器它在编译时可以评估它：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code results in a compile-time evaluation of the `square(2)` expression,
    making the `val` integer a `constexpr` variable, that is, a compile-time constant.
    The following is the resulting assembly code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导致`square(2)`表达式的编译时评估，使`val`整数成为一个`constexpr`变量，即编译时常量。以下是将生成的汇编代码：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the program returns the value `4`, which is the result of the
    `square(2)` compile-time computation. There is no `square` function in the generated
    assembly, just the result of the calculation that the compiler performed for us.
    This simple example demonstrates the power of compile-time computing. We can move
    heavy computation from runtime to compile time whenever we know all the computation
    parameters, which is often. This approach can be used to generate lookup tables
    or complex mathematical signals, which will be demonstrated in the following chapters
    of this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，程序返回的值是`4`，这是`square(2)`编译时计算的结果。生成的汇编代码中没有`square`函数，只有编译器为我们执行的计算结果。这个简单的例子展示了编译时计算的力量。当我们知道所有计算参数时，我们可以将重计算从运行时移到编译时，这通常是可能的。这种方法可以用来生成查找表或复杂的数学信号，这将在本书的后续章节中演示。
- en: C++ has come a long way since C with Classes. The examples in this chapter show
    what C++ can offer over C – expressive, more readable, compact code; standard
    template library containers; algorithms; user-defined generic types; and compile-time
    computation, just to start with. I hope I managed to debunk the myth that C++
    is just C with classes. The next common myth about C++ is that it makes bloated
    code and adds runtime overhead. Let’s keep debunking the myths about C++!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C with Classes以来，C++已经走了很长的路。本章中的示例展示了C++相对于C所能提供的功能——表达性强、可读性高、紧凑的代码；标准模板库容器；算法；用户定义的泛型类型；以及编译时计算，仅举几例。我希望我已经成功地打破了C++只是C带类这一神话。关于C++的下一个常见神话是它会产生臃肿的代码并增加运行时开销。让我们继续打破关于C++的神话！
- en: Bloat and runtime overhead
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 肿胀和运行时开销
- en: The term **bloatware** describes unwanted software that is preinstalled with
    an OS on a device. Unwanted software in the world of programming describes code
    inserted in a binary by a framework, a library, or a language construct itself.
    Language constructs in C++ that are blamed for causing code bloat are constructors,
    destructors, and templates. We will analyze these misconceptions by examining
    assembly output generated from C++ code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**bloatware**这个术语描述的是在设备上预装操作系统的不需要的软件。在编程世界中，不需要的软件描述的是框架、库或语言构造本身插入到二进制中的代码。在C++中，被指责为导致代码臃肿的语言构造是构造函数、析构函数和模板。我们将通过检查从C++代码生成的汇编输出来分析这些误解。'
- en: Constructors and destructors
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: The first thing that comes to mind to non-C++ developers when you mention C++
    is that it is an object-oriented language and that you are bound to instantiate
    objects. Objects are instances of classes. They are variables that occupy memory.
    Special functions, called **constructors**, are used to construct or instantiate
    objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提到C++时，非C++开发者首先想到的可能是它是一种面向对象的语言，并且你必然会实例化对象。对象是类的实例。它们是占用内存的变量。称为**构造函数**的特殊函数用于构建或实例化对象。
- en: Constructors are used to initialize objects, including the initialization of
    class members, and destructors are used to clean up resources. They are tightly
    tied to an object’s life cycle. An object is created using a constructor, and
    when the object variable goes out of scope, the **destructor** is called.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数用于初始化对象，包括类成员的初始化，而析构函数用于清理资源。它们与对象的生存周期紧密相关。对象通过构造函数创建，当对象变量超出作用域时，会调用**析构函数**。
- en: 'Constructors and destructors both increase the size of the binary and add runtime
    overhead, as their execution takes time. We will examine the impact of constructors
    and destructors on a simple example of a class with one private member, a constructor,
    a destructor, and a getter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数都会增加二进制文件的大小并增加运行时开销，因为它们的执行需要时间。我们将通过一个简单的类示例来检查构造函数和析构函数的影响，该类有一个私有成员、一个构造函数、一个析构函数和一个获取器：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`MyClass` is a very simple class that has one private member, which we set
    through the constructor. We can access it through a getter, and just for good
    measure, we declared a destructor, which is empty. The following is the assembly
    equivalent of the preceding code compiled with no optimization enabled:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass`是一个非常简单的类，它有一个私有成员，我们通过构造函数设置它。我们可以通过获取器访问它，为了保险起见，我们还声明了一个空的析构函数。以下是没有启用优化编译的上述代码的汇编等价代码：'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Don’t worry about the assembly if you don’t understand it. We can see there
    are some labels for functions and a whole lot of instructions. That’s a lot of
    instructions for a simple abstraction of a class; this is the bloat code that
    we don’t want in our binary. To be more precise, we have 59 lines of assembly
    code. If we were to enable optimization, the resulting assembly would be a couple
    of lines long, but let’s keep analyzing this problem with no optimization involved.
    The first thing we are noticing is that the destructor doesn’t do anything useful.
    If we remove it from the C++ code, the resulting assembly is 44 lines long:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂汇编，不必担心。我们可以看到有一些用于函数的标签和大量的指令。对于一个简单的类抽象来说，这有很多指令；这是我们不想在我们的二进制文件中出现的冗余代码。更精确地说，我们有
    59 行汇编代码。如果我们启用优化，生成的汇编代码将只有几行长，但让我们不进行优化来分析这个问题。我们首先注意到的是析构函数没有做任何有用的事情。如果我们从
    C++ 代码中移除它，生成的汇编代码将是 44 行长：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, there is no call to the destructor, and there is no destructor
    code in the binary. The lesson is *you don’t pay for what you don’t use*. This
    is one of the design principles of C++. By deleting the destructor, there is no
    need for the compiler to generate any code for it and to call it when the object
    variable goes out of the scope.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有调用析构函数，二进制文件中也没有析构函数代码。教训是*你不为不使用的东西付费*。这是 C++ 的设计原则之一。通过删除析构函数，编译器不需要为它生成任何代码，也不需要在对象变量超出作用域时调用它。
- en: 'The next thing we must realize is that C++ is not an OOP language. It is a
    multiparadigm language. It is procedural, object-oriented, generic, and even a
    little bit functional at the same time. If we want to have private members that
    can be set only through constructors, then we need to pay the price for that.
    Structs in C++ have public members by default, so let’s change the `MyClass` class
    to a `MyClass` struct with no constructor:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须认识到的是，C++ 不是一个面向对象的编程语言。它是一种多范式语言。它是过程性的、面向对象的、泛型的，甚至在某种程度上是函数式的。如果我们想有只能通过构造函数设置的私有成员，那么我们需要为此付出代价。C++
    中的结构体默认是公有成员，所以让我们将 `MyClass` 类改为没有构造函数的 `MyClass` 结构体：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Setter and getter functions are common in the OOP paradigm, but C++ is not
    (just) an OOP language and we are not bound to using setters and getters. When
    we remove the `getNum` getter, we have a very basic example of a struct with just
    one member. The resulting assembly is only 14 lines long:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器和获取器函数在面向对象范式中很常见，但 C++ 不是一个（仅仅是）面向对象的编程语言，我们也不必局限于使用设置器和获取器。当我们移除 `getNum`
    获取器时，我们有一个只有一个成员的非常基本的结构体示例。生成的汇编代码只有 14 行长：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As trivial as this example is, its purpose is to establish two ground truths:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但其目的是确立两个基本事实：
- en: You don’t pay for what you don’t use
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要为不使用的东西付费
- en: Using C++ doesn’t mean you are bound to an OOP paradigm
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 并不意味着你必然被绑定到面向对象（OOP）范式
- en: We need to pay the price in binary size if we want to use abstractions such
    as constructors and destructors. Using types (classes and structs) without instantiating
    objects in C++ offers significant benefits to your embedded software design beyond
    traditional object-oriented approaches. We’ll explore this through detailed examples
    in the upcoming chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用诸如构造函数和析构函数之类的抽象，我们必须为二进制大小付出代价。在 C++ 中，不实例化对象而使用类型（类和结构体）可以为嵌入式软件设计提供比传统面向对象方法更显著的好处。我们将在接下来的章节中通过详细的例子来探讨这一点。
- en: 'In this and previous examples, we compiled C++ code with disabled optimizations,
    and we were able to see the resulting assembly code results in unnecessary operations
    that can be removed. Let’s check the assembly code for the last example with the
    `O3` optimization level enabled:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个和之前的例子中，我们以禁用优化的方式编译了 C++ 代码，并能够看到生成的汇编代码结果中存在可以移除的不必要操作。让我们检查最后一个例子在启用 `O3`
    优化级别时的汇编代码：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding assembly is the output of the original example with the class,
    constructor, destructor, and getter function. The resulting program has just two
    instructions. The value of the `num` member of the `obj` variable is stored in
    the `r0` register as the return value. Assembly code is stripped of all necessary
    instructions related to stack manipulation and usage of `r3` to store a value
    in a stack pointer with an offset of `4`, reload it to `r3`, and move it to `r0`.
    The resulting assembly is just a few lines of code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述汇编是包含类、构造函数、析构函数和获取函数的原例程输出。生成的程序只有两条指令。`obj` 变量的 `num` 成员值存储在 `r0` 寄存器中作为返回值。汇编代码去除了所有与栈操作和将值存储在偏移量为
    `4` 的栈指针中的 `r3` 相关的必要指令，并将它重新加载到 `r3`，然后移动到 `r0`。生成的汇编代码只有几行。
- en: Removing unnecessary instructions is a job for the optimization process. Yet,
    optimization is often avoided in embedded projects, as some claim that it breaks
    code. But is that true?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 移除不必要的指令是优化过程的工作。然而，在嵌入式项目中，有些人声称优化会破坏代码，因此优化常常被避免。但这真的吗？
- en: Optimization
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Unoptimized code results in unnecessary instructions affecting binary size and
    performance. However, many embedded projects are still built with disabled optimization,
    as developers *do not trust the compiler* and are afraid it will *break the program*.
    There is some truth to this, but as it turns out, this happens when the program
    is not well formed. The program is not well formed if it contains undefined behavior.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 未优化的代码会导致不必要的指令影响二进制大小和性能。然而，许多嵌入式项目仍然使用禁用优化的方式构建，因为开发者 *不相信编译器*，并担心它将 *破坏程序*。这确实有一定的道理，但事实是，这种情况发生在程序结构不佳时。如果程序包含未定义的行为，则程序结构不佳。
- en: 'One of the best-known examples of undefined behavior is signed **integer overflow**.
    The standard doesn’t define what happens if you add `1` to the maximum value of
    the signed integer on your platform. The compiled program is not required to do
    anything meaningful. A program is not well formed. Let’s examine the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义行为的最佳例子之一是带符号的 **整数溢出**。标准没有定义如果你在你的平台上将 `1` 添加到带符号整数的最大值会发生什么。编译后的程序不需要执行任何有意义的操作。程序结构不佳。让我们检查以下代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compiling the code using GCC for both x86 and Arm Cortex-M4 will yield the same
    results. If the program is compiled without the optimization, the `foo` function
    returns `0`, and you can see **X is NOT larger than X + 1\. Oh nooo !** in the
    output. The compiler does the integer overflow, and if we pass the maximum integer
    value to `foo`, it will return `0`. Keep in mind that the standard does not specify
    this, and this behavior depends on the compiler.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GCC 为 x86 和 Arm Cortex-M4 编译代码将产生相同的结果。如果程序未启用优化编译，`foo` 函数返回 `0`，你可以在输出中看到
    **X 不大于 X + 1\. 哦不！**。编译器执行整数溢出，如果我们传递最大整数值给 `foo`，它将返回 `0`。请注意，标准没有指定这一点，这种行为取决于编译器。
- en: 'If we compile the program with optimization enabled, the output is **X is larger
    than X + 1**`,` which means that `foo` returns `1`. Let’s examine the assembly
    output of the program compiled with the optimization:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用优化编译程序，输出将是 **X 大于 X + 1**`,` 这意味着 `foo` 返回 `1`。让我们检查使用优化编译的程序汇编输出：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, `foo` doesn’t perform any calculations. The compiler assumes
    that the program is well formed and that there is no undefined behavior. `foo`
    will always return `1`. It is up to the developer to ensure that there is no undefined
    behavior in the program. This is exactly the reason why the myth that the optimization
    breaks the program is still alive. It is easier to blame the compiler for not
    handling the undefined behavior.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`foo` 不执行任何计算。编译器假设程序结构良好，并且没有未定义的行为。`foo` 总是返回 `1`。确保程序中没有未定义的行为是开发者的责任。这正是优化会破坏程序的神话仍然存在的原因。将未定义的行为归咎于编译器不处理它更容易。
- en: Of course, it is possible that there is a bug in a compiler that breaks the
    functionality of the program if the optimization is used, and the program works
    fine if it is disabled. This is very rare but not unheard of, and that’s why there
    are verification techniques such as unit and integration testing that ensure the
    functionality of the code, whether it is built with or without the optimization
    enabled.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果使用优化，编译器中可能存在一个错误，会破坏程序的功能，而如果禁用优化，程序则可以正常工作。这种情况非常罕见，但并非没有发生过，这就是为什么存在诸如单元和集成测试之类的验证技术，以确保代码的功能，无论是否启用优化。
- en: Optimization is reducing the binary size and improving performance by removing
    unnecessary instructions from the machine code. Undefined behavior is compiler-dependent
    and must be handled by the developer to ensure the program is well formed. Techniques
    such as unit and integration testing should be put in place to validate the functionality
    of the program, mitigating the risk of compiler malforming the program. The optimization
    process is essential for using abstractions in C++ code while keeping the binary
    footprint minimum and performance at a maximum. We will use the highest optimization
    level, `O3`, in the rest of the book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 优化通过从机器代码中删除不必要的指令来减少二进制大小并提高性能。未定义行为是编译器依赖的，必须由开发者处理以确保程序结构良好。应实施单元和集成测试等技术来验证程序的功能，以减轻编译器损坏程序的风险。优化过程对于在C++代码中使用抽象同时保持最小的二进制大小和最大性能至关重要。本书的其余部分我们将使用最高的优化级别`O3`。
- en: The next suspect for code bloat that we will examine are templates. How do they
    cause the code bloat, and what value do they bring to our embedded code bases?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的下一个代码膨胀的嫌疑者是模板。它们是如何导致代码膨胀的，它们又给我们的嵌入式代码库带来了什么价值？
- en: Templates
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Instantiating **templates** with different parameters will result in the compiler
    generating distinct types, which effectively increases the binary size. This is
    to be expected. We have the exact same situation with the generic implementation
    of a ring buffer in C using the token-pasting operator and macros. An alternative
    is type erasure, which we used in C implementation using a void pointer. It suffers
    in flexibility if we impose the restriction of static data allocation and performance
    due to pointer indirection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同参数实例化**模板**将导致编译器生成不同的类型，这实际上会增加二进制大小。这是可以预料的。我们在使用占位符操作符和宏在C中实现环形缓冲区的泛型实现时也有完全相同的情况。一个替代方案是类型擦除，我们在C实现中使用空指针。如果我们施加静态数据分配的限制，它会在灵活性上受损，并且由于指针间接引用而影响性能。
- en: 'Using generic types is a choice of design. We can use them and pay the price
    in increased binary size, but that would also happen if we were to implement ring
    buffers for different data types separately (`ring_buffer_int`, `ring_buffer_float`,
    etc.). Maintaining a single templated type is much easier than fixing the same
    bug in a few different places in the code base. The usage of generic types doesn’t
    result in a binary size any larger than the size of an equivalent implementation
    of individual types. Let’s examine the impact of templates on binary size in relation
    to separate implementations using the `ring_buffer` example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型类型是设计选择之一。我们可以使用它们，并为此付出二进制大小增加的代价，但如果我们分别实现不同数据类型的环形缓冲区（例如`ring_buffer_int`、`ring_buffer_float`等），这也会发生。维护单个模板类型比在代码库的几个不同地方修复相同的错误要容易得多。泛型类型的使用不会导致二进制大小超过等效单个类型实现的尺寸。让我们通过`ring_buffer`示例来检查模板对二进制大小的影响：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The program will use a generic `ring_buffer type` if built with `USE_TEMPLATES`
    defined, and it will use the `ring_buffer_int` and `ring_buffer_float` types otherwise.
    If we build this example with GCC with no optimization enabled, it will result
    in a slightly bigger binary size in the template version (24 bytes). This is due
    to larger symbols in the symbol table when using the templated version. If we
    strip the symbol table from the object files, they will result in the same size.
    Also, building two versions with `O3` results in the same binary size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`USE_TEMPLATES`定义构建程序，它将使用泛型`ring_buffer type`，否则将使用`ring_buffer_int`和`ring_buffer_float`类型。如果我们使用没有启用优化的GCC构建此示例，模板版本将导致稍微更大的二进制大小（24字节）。这是由于使用模板版本时符号表中的符号更大。如果我们从目标文件中删除符号表，它们将具有相同的大小。此外，使用`O3`构建两个版本将产生相同的二进制大小。
- en: Generic types do not increase the binary size more than if we wrote instantiated
    types by hand as separate types. Templates have an effect on the build time due
    to the instantiation of concrete types in different compilation units, and there
    are techniques to avoid this if needed. All functions related to the instantiated
    types with the same parameters will result in a single function in the binary,
    as the linker will remove duplicate symbols.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型不会比我们手动编写实例化类型作为单独类型时增加的二进制大小更多。模板由于在不同编译单元中实例化具体类型而影响构建时间，如果需要，有技术可以避免这种情况。所有与具有相同参数的实例化类型相关的函数都将导致二进制中只有一个函数，因为链接器将删除重复的符号。
- en: RTTI and exceptions
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTTI和异常
- en: '**Runtime type information** (**RTTI**) in C++ is a mechanism that allows the
    type of an object to be determined at runtime. Most compilers implement RTTI using
    the virtual tables. Each polymorphic class (a class with at least one virtual
    function) has a virtual table that, among other things, includes type information
    for runtime type identification. RTTI imposes both time and space costs. It increases
    binary size and affects the runtime performance if type identification is used.
    This is the reason why compilers have a way of disabling RTTI. Let’s examine a
    simple example with a base and derived class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的**运行时类型信息**（**RTTI**）是一种允许在运行时确定对象类型的机制。大多数编译器使用虚表来实现RTTI。每个具有至少一个虚函数的多态类都有一个虚表，其中包含运行时类型识别的类型信息。RTTI既增加了时间成本也增加了空间成本。如果使用类型识别，它会增加二进制文件大小并影响运行时性能。这就是为什么编译器有禁用RTTI的方法。让我们通过一个基类和派生类的简单例子来考察：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the program is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Classes with virtual functions have vtables that are used for dynamic dispatching.
    Dynamic dispatch is a process of selecting which implementation of a polymorphic
    function is used. The `printer` function accepts a reference to the `Base` class.
    Depending on the type of reference passed to `printer` (`Base` or `Derived`),
    the dynamic dispatching process will select the `print` method from either the
    `Base` or `Derived` class. Vtables are also used to store type information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 具有虚函数的类有用于动态分发的v表。动态分发是一个选择多态函数实现的过程。`printer`函数接受`Base`类的引用。根据传递给`printer`的引用类型（`Base`或`Derived`），动态分发过程将选择`Base`或`Derived`类中的`print`方法。v表也用于存储类型信息。
- en: 'By using `dynamic_cast`, as a part of the RTTI mechanism, we can find the information
    about the type using a reference or pointer to the superclass. Let’s modify the
    `printer` method from the previous example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用作为RTTI机制一部分的`dynamic_cast`，我们可以使用对超类引用或指针来找到类型信息。让我们修改前一个例子中的`printer`方法：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we already mentioned, RTTI can be disabled. In GCC, we can do this by passing
    the `-fno-rtti` flag to the compiler. If we try to compile the modified example
    using this flag, the compiler will raise `error: dynamic_cast'' not permitted
    with ''-fno-rtti''`. If we restore the `printer` method to the original implementation,
    remove the `if` statement, and build it with both RTTI enabled and then disabled,
    we can notice that the binary size is larger when RTTI is enabled. RTTI is useful
    in certain scenarios, but it adds a massive overhead to resource-constrained devices,
    so we will leave it disabled.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们之前提到的，RTTI可以被禁用。在GCC中，我们可以通过向编译器传递`-fno-rtti`标志来实现这一点。如果我们尝试使用这个标志编译修改后的示例，编译器将报错`error:
    dynamic_cast'' not permitted with ''-fno-rtti''`。如果我们将`printer`方法恢复到原始实现，删除`if`语句，并分别启用和禁用RTTI来构建它，我们可以注意到当RTTI启用时，二进制文件的大小更大。RTTI在特定场景下很有用，但它会给资源受限的设备增加巨大的开销，因此我们将它保持禁用状态。'
- en: 'Another C++ feature that is often disabled in embedded projects in C++ is exceptions.
    **Exceptions** are an error-handling mechanism based on a try-catch block. Let’s
    take a look at a simple example utilizing exceptions to understand them better:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在C++嵌入式项目中经常禁用的C++特性是异常。**异常**是一种基于try-catch块的错误处理机制。让我们通过一个简单的例子来利用异常来更好地理解它们：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the program is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this simple example, `foo` is called in the `try` block. It creates a local
    object, `a`, and calls `bar`. The `bar` function creates a local object, `b`,
    and throws an exception. In the output, we see that `A` and `B` are created, then
    `B` gets destroyed, then `A` gets destroyed, and we finally see that the `catch`
    block gets executed. This is called **stack unwinding**, and for it to happen,
    standard implementations most commonly utilize unwind tables, which store information
    about catch handlers, destructors to be called, and so on. Unwind tables can grow
    large and become complex, which increases the memory footprint of the application
    and introduces non-determinism due to the mechanism used at runtime for exception
    handling. This is why exceptions are often disabled in embedded system projects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，`foo` 在 `try` 块中被调用。它创建了一个局部对象 `a` 并调用 `bar`。`bar` 函数创建了一个局部对象 `b`
    并抛出一个异常。在输出中，我们看到 `A` 和 `B` 被创建，然后 `B` 被销毁，接着 `A` 被销毁，最后我们看到 `catch` 块被执行。这被称为**栈展开**，为了使其发生，标准实现通常最常用的是
    unwind tables，它们存储有关捕获处理程序、将被调用的析构函数等信息。unwind tables 可以变得很大且复杂，这增加了应用程序的内存占用，并由于运行时用于异常处理的机制而引入了非确定性。这就是为什么异常通常在嵌入式系统项目中被禁用。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: C++ is guided by the **zero-overhead principle**. The only two language features
    that do not follow it are RTTI and exceptions, and that’s why compilers support
    a switch for turning them off.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 遵循**零开销原则**。唯一不遵循此原则的两个语言特性是RTTI和异常，这也是为什么编译器支持一个开关来关闭它们。
- en: 'The zero-overhead principle is based on two statements that we established
    in this chapter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 零开销原则基于我们在本章中确立的两个陈述：
- en: You don’t pay for what you don’t use
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要为不使用的功能付费
- en: What you do use is just as efficient as what you could reasonably write by hand
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用的功能与你可以合理手动编写的功能一样高效
- en: RTTI and exceptions are disabled in most embedded projects, so you don’t pay
    for them. Using generic types and templates is a design choice and is no more
    expensive than writing individual types by hand (`ring_buffer_int`, `ring_buffer_float`,
    and so on), but it lets you reuse the code logic for different types, makes the
    code more readable and easier for maintenance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数嵌入式项目中，RTTI和异常都被禁用，所以你不需要为它们付费。使用泛型类型和模板是一种设计选择，并且不比手动编写单个类型（如 `ring_buffer_int`、`ring_buffer_float`
    等）更昂贵，但它允许你重用不同类型的代码逻辑，使代码更易于阅读和维护。
- en: Working on high-risk systems is not a reason to disable compiler optimization
    capabilities. Code functionality needs to be verified whether we are building
    a program with optimization disabled or enabled. The most common source of bugs
    when optimization is enabled is undefined behavior. Understanding the undefined
    behavior and preventing it is up to the developer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在高风险系统中工作不是禁用编译器优化能力的理由。无论我们是在启用或禁用优化的程序中构建，代码功能都需要经过验证。当启用优化时，最常见的错误来源是未定义行为。理解未定义行为并防止它取决于开发者。
- en: Modern C++ is a language that has a lot to offer to the embedded world. The
    mission of this book is to help you discover C++ and what it can do for your embedded
    projects, so let’s embark on the path of discovering C++ and utilizing it to solve
    problems in the embedded domain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++是一种对嵌入式世界有很多贡献的语言。本书的使命是帮助你发现C++以及它可以为你的嵌入式项目做什么，所以让我们踏上发现C++并利用它来解决嵌入式领域问题的道路。
- en: In the next chapter, we will go over challenges in embedded systems with limited
    resources and dynamic memory management in C++.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论嵌入式系统中的资源限制挑战和C++中的动态内存管理。
- en: Join our community on Discord
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Discord 二维码](img/QR_code_Discord.png)'
