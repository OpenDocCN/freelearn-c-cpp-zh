- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and
    Type Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on the three most common structural patterns. Structural
    patterns allow us to plan our code with the end usage in mind. For example, if
    we know that the end users of our system are likely to be designers with no code
    experience, we could plan to use the type object pattern to provide a system for
    easy dynamic expansion. We have already covered some of the concepts around code
    structure when we discussed using interfaces and events to achieve anonymous modular
    design in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090). The three patterns
    in this chapter (template, subclass sandbox, and type object) are a little more
    zoomed-in in terms of scope compared to what we have looked at before. The first
    two are interchangeable depending on your preference, both working as extensions
    to the standard inheritance property of the C++ programming language. The last
    is by far the most useful pattern in game design, giving designers the ability
    to define variants of classes with ease without getting in the programmers’ way
    while they make new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the **Template** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding **Subclass Sandbox**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Type** **Object** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike previous chapters, we will be starting with the project files in the
    `chapter9` branch on GitHub, which can be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09)
  prefs: []
  type: TYPE_NORMAL
- en: We have made a few small changes to the project to facilitate the following
    pattern examples. These changes are a bit too tedious to walk through in this
    chapter but if you would like to see what has changed, then download both this
    and the previous chapters’ branches and run them through a diffing program such
    as DiffMerge.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template pattern exists as an extension to standard inheritance, where we
    define a structure in an abstract parent class and the children are given the
    opportunity to override the pieces of that structure. They can change how individual
    parts function but not the order of execution. The simplest example of this within
    Unreal is the `AActor` base class. Any child of AActor gets access to the Begin
    Play, Tick, and End Play events, to name but a few. The child class can hook functionality
    onto these events, and they will fire when expected. The constraint we place on
    inheritance to make this into the template pattern is that the child has no way
    of changing the order or timing of these events. There is no way to make End Play
    fire before Begin Play as this order has been defined in the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an example of a class implementing the template pattern in the following
    code. The `ProcessGame()` function is the only one with a body, defining the order
    of the private abstract function:'
  prefs: []
  type: TYPE_NORMAL
- en: Template pattern parent pseudocode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `AActor` class has four functions with only one of them not marked
    as abstract or virtual. This function is our spine that defines the order of execution.
    From there, each of the other functions may have some form of implementation in
    the base but they are designed to be ultimately overridden. The best situation
    is for each of these extra utility functions to be abstract with no implementation
    in the base to retain the lightweight nature of the pattern, but if that means
    that a lot of the implementations will be repeated, then a virtual base with the
    common code would be better. The goal is to keep this class as light as possible
    while cutting down as much repetition as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Important caveat
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the actual structure of `AActor` doesn’t implement the Template
    pattern, as shown in the pseudocode; we collapsed the tree a little to make a
    point. In reality, that loop is dealt with by the world object and filtered down
    to all the actors and subsystems within it.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we are going to give our elite unit some weapons. In the
    GitHub branch for this chapter, the `EliteUnit` C++ class has already been augmented
    to spawn a weapon from a base class defined in the class defaults. This spawned
    weapon is an actor that we have attached to a `SceneComponent`, positioned just
    in front of the character. The code is also modified to call the fire function
    on this weapon instead of running a line trace from within the character. As it
    currently stands, this code will not run as there are no classes available for
    the character to spawn from that are not marked as abstract. Our first step is
    to build the template parent class as a child of this generic weapon in C++. We
    can then leave the creation of the functional child weapons to a Blueprint, giving
    us an excellent way to understand how the two systems work together and allowing
    programmers to do the groundwork in C++ before the technical designers and designers
    explore variations in Blueprints. This allows for quick prototyping and iteration
    of weapon designs to achieve the intended game feel without breaking any of the
    underlying systems.
  prefs: []
  type: TYPE_NORMAL
- en: Building the template (parent class)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, our first step is to make a new C++ child class of `AWeapon_Base`.
    With that made, we can set about putting the template main function in place which,
    as we can see in the code below, is called `Fire()`. The parent class has a lot
    of the data and a core system for dealing with a brief cooldown delay between
    shots. These variables have been added at the top level as they will be universal
    to all weapon types and so it makes sense to consolidate them in the common parent.
    This does mean that the `Fire()` function here is an override, whereas in a straight
    implementation of the template pattern, this would be at the top level. We are
    only doing things differently here to create a shared hierarchy with the Sandbox
    pattern that we’ll see in the next section to highlight the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other functions in the template weapon base class include a public function
    for reloading, as you may want to actively call that function even though we will
    be triggering it by default anyway. This is followed by a bunch of utility functions
    that are marked as either `BlueprintNativeEvent` if they have a default implementation
    in the base, or `BlueprintImplementableEvent` if they do not. Each of these protected
    functions exists to be overridden by the children to change the behavior of the
    weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: TemplateWeapon_Base.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The only function in the implementation of this class is the template spine
    we are calling `Fire()`. In this function, we define the execution order of all
    the other functions in a way that becomes concrete. In the following implementation,
    we check whether we can fire; if not, we use an early return to exit the function.
    Then we check whether we have the ammo to fire; if not, then we’ll reload. If
    the weapon is able to fire, then the process outlined by this function starts
    with the effects, then runs the gameplay logic for actually firing with the reduction
    in ammo calculated after that. The last thing it does is call the parent, where
    we have set up the code to deal with the firing delay (which is used to prevent
    the fire button being spammed or exploited with auto-clickers and macros):'
  prefs: []
  type: TYPE_NORMAL
- en: TemplateWeapon_Base.cpp main template function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few functions are just default implementations that make sense and
    are likely to be repeated code if not defined here. The reload function resets
    the ammo counter and calls the fire delay reset function. `CheckAmmo` is a one-line
    Boolean check that could be made pure as an extension to this. Finally, `UpdateAmmo`
    just takes the predefined `_AmmoPerFire` from our ammo counter:'
  prefs: []
  type: TYPE_NORMAL
- en: TemplateWeapon_Base.cpp utility functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That forms the C++ base for our template pattern. All that is left is to make
    an implementation or two with Blueprint child classes in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating child classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to create two child classes in a Blueprint. This task offers
    us a great opportunity to explore how C++ and Blueprints can work together to
    create efficient solutions. To do this, we need to create new child Blueprints,
    one for a pistol and a second for a shotgun. These weapons both utilize a line-trace
    approach with variation for multiple projectiles in a spread. This allows us to
    focus on creating two different solutions with a small but significant change
    to build a solid example for the template pattern. To do this, we are going to
    use the same menu from before, but instead of selecting **Actor** from the dialog,
    we need to dig a bit deeper to find the C++ parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by right-clicking in the Content Browser and clicking **Blueprint Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it isn’t already visible, expand the **ALL CLASSES** rollout by clicking
    the title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, type `template` to reduce the number of options displayed
    in the results box, as shown in *Figure 9**.1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 9.1: \uFEFFThe Blueprint creation window for a template weapon](img/Figure_09.01_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The Blueprint creation window for a template weapon'
  prefs: []
  type: TYPE_NORMAL
- en: Select **TemplateWeapon_Base** from the list, then click **Select**, which will
    only appear once you’ve made your selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new Blueprint `BP_TemplatePistol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the pistol child Blueprint created, we next need to create a child Blueprint
    for the shotgun. To do this, repeat the preceding steps but name the second blueprint
    `BP_TemplateShotgun`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the child classes have been created, we can move on to creating the
    behaviors inside them, making use of the template pattern to only modify the part
    of the class necessary to achieve the desired functionality of each child.
  prefs: []
  type: TYPE_NORMAL
- en: Template pistol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our Blueprint for the Pistol set up, we can move on to overriding
    the parts of the template that will be unique to this class. The `CheckAmmo` and
    `UpdateAmmo` functions will remain the same for our pistol class as in the parent
    template. We will be overriding `PlayEffects`, `ProcessFiring`, and `Reload`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve overridden functions before, namely in [*Chapter 8*](B18297_08.xhtml#_idTextAnchor113)
    when looking at utility blueprints. The process here is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note on overriding C++ functions
  prefs: []
  type: TYPE_NORMAL
- en: When we override functions in a Blueprint that are included within a C++ parent,
    we don’t get a choice between creating a function or an event. The result we get
    when selecting to override the C++ function will depend on whether the function
    has a return or not. If a function does not contain a return, the override in
    the Blueprint will automatically create an Event node in the main Blueprint Event
    Graph. If the function does have a return (like `CheckAmmo` does), the override
    will provide a Blueprint function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to override the `PlayEffects` function. This is where we
    would typically add a muzzle flash particle effect and play an animation and a
    sound. In the interest of keeping the repository for this exercise small, and
    the number of steps short to allow us to focus on learning, we will just add a
    sound effect. Again, in the interest of keeping the required download small, we
    will use a sound from the Engine Content as opposed to finding a purpose-selected
    sound for the gun. Let’s do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Blueprint and on the left side, hover over the **Functions** section
    of the **My Blueprint** tab. This should reveal the **Override** dropdown. From
    this, select **Play Effects**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should have added an **Event Play Effects** node to the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the pin on the `Play Sound at` `Location` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `VR_Teleport`. If nothing appears, you will need to enable **Show
    Engine Content** from the **Settings** dropdown, which can be accessed by clicking
    the cog icon in the top right of the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `Get Actor` `Location` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2: The overridden Event Play Effects function in the Blueprint](img/Figure_09.02_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: The overridden Event Play Effects function in the Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will override **ProcessFiring**. This is where we are going to put
    all of our firing logic. The precise contents of this function will differ depending
    on the type of weapon. For the pistol, we can use a simple line trace similar
    to the approach taken for attacking enemies that we created in [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057)
    when making the Behavior Tree for the Elite Unit. To begin, let’s set up the trace:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag from the pin on the `Line Trace by Channel` node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag in the `Get World Location` node and then repeat this again to add a `Get
    Forward` `Vector` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Return Value** pin on **Get World Location** node to the **Start**
    pin on the **Line Trace By** **Channel** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `Multiply` (`x`) node by typing `*` in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the lower pin on the **Multiply** node and select **Convert Pin
    | Float (single-precision)**. This will turn the yellow pin green, indicating
    that the variable expected is no longer a vector but now a float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the green pin and add a `Get Range` node. This will add the `Range`
    variable defined in the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again drag from the **Get World Location** node and create an **Add** node
    (reached by typing **+**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the lower input vector pin of the **Add** node to the output vector
    pin of the **Multiply** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of the **Add** node to the **End** pin on the **Line Trace
    By** **Channel** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to tell the line trace to ignore the character when shooting,
    or else the only character the gun will damage will be the one firing it:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the event graph and create a `Get` `Owner` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the **Return Value** output of the **Get Owner** node and add a **Make**
    **Array** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Array** output pin of the **Make Array** node to the **Actors
    to Ignore** pin on the **Line Trace By** **Channel** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The line trace is now set up and should look like the graph shown in *Figure
    9**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Line Trace node with the inputs setup](img/Figure_09.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The Line Trace node with the inputs setup'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop variables defined in the parent class
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to be able to drag the variables we defined in the parent class
    into the graph in the same way you would with a variable created in a blueprint,
    click the cog in the top right of the **My Blueprint** tab and enable **Show**
    **Inherited Variables**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to do something with the result of the trace. In this case, we
    are going to use the Apply Damage approach, just as we did in [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057):'
  prefs: []
  type: TYPE_NORMAL
- en: Drag from the `Break Hit` `Result` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `Apply` `Damage` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the graph easier to read, click the collapse arrow (**^**) on the bottom
    of the **Break Hit Result** node. This will collapse the node to only show the
    top two bool pins and any pins that have been used, hiding any unused pins. In
    this case, just the **Hit Actor** pin will remain visible along with the top two
    bool pins (**Blocking Hit** and **Initial Overlap**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag back from the `Get Damage Per Hit` node, once again grabbing a variable
    defined in the parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, drag from the `Branch` node (`If`) and connect the three nodes together
    as shown in *Figure 9**.4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4: The result of the trace used to apply damage to the enemy unit](img/Figure_09.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The result of the trace used to apply damage to the enemy unit'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do is to check the values of each of the inherited variables.
    You can do this by clicking on the variable nodes or, if you chose to show inherited
    variables, you can select them from the variables list in the **My** **Blueprint**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the `1000.0` and `20.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the firing of the weapon sorted, we can next turn our attention to the
    reload function. Unlike the previous two overrides, the reload function is not
    an abstract function. The parent template class already handles the functional
    aspect of the reload, adding the ammo back into the weapon, so we need to ensure
    we retain that in the child class. We can then add all the extra elements such
    as sounds, animations, particle effects, and so on. Once again, let’s keep this
    simple by just adding a sound. First, let’s override the Reload function and ensure
    we are maintaining the functionality from the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the **Reload** in function in the same way as we did for the previous
    two functions. This will add the **Event Reload** node to the **Event Graph**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the **Event Reload** node and select **Add call to parent function**.
    This will add a **Parent: Reload** node for you.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the **Parent: Reload** node beside the **Event Reload** node and connect
    them together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5: The Event Reload and Parent: Reload nodes](img/Figure_09.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The Event Reload and Parent: Reload nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Parent: Reload** node tells Unreal to do all the steps from the parent
    version of this function at this point in the logic chain.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the behavior from the parent included in the child, we can
    add the sound. We do this just in the same way as we did for the **PlayEffects**
    event, however this time, we will select the **Gizmo_Handle_Clicked** sound.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: The completed Event Reload function in our Blueprint](img/Figure_09.06_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The completed Event Reload function in our Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the reload function sorted, our pistol is complete. Let’s test it out
    on the character to make sure it works. The **EliteUnit** modifications included
    an automated system for spawning and attaching weapons to the character based
    on a drop-down box. Set the weapon as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **BP_EliteUnit** that is in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search in the details panel for `Weapon` `to Spawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value in the drop-down box to **BP_TemplatePistol**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see `UCLASS` block includes the `Abstract` property so that no one can
    ever spawn an instance of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: With the pistol now set up, tested, and functional, let’s look at the shotgun.
  prefs: []
  type: TYPE_NORMAL
- en: Template shotgun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of simplicity and to avoid this being a very long chapter, with
    the shotgun the only unique approach we will apply is to the **Process Firing**
    function. Because the Play Effects and Reload functions are abstract in the parent,
    we must override them, so before we get started on the Process Firing for the
    shotgun, replicate the other two functions from the pistol in the **BP_TemplateShotgun**
    Event Graph. You can do this by creating them again manually or by copying and
    pasting them between graphs.
  prefs: []
  type: TYPE_NORMAL
- en: With that done, let’s move on to sorting the firing out. Rather than going through
    this version step by step, let’s look at the differences so you can make the necessary
    changes to create a shotgun rather than a pistol. Begin by copying over the firing
    logic from the pistol before modifying it to replicate each of the changes that
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a pistol, we need to consider that when fired, a shotgun doesn’t fire
    a single projectile. Rather, shotgun shells often contain between nine and eighteen
    small pellets that are fired out of the barrel in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To replicate this, we simply increase the number of traces we perform and add
    variation to the direction, maintaining the same start point (the end of the barrel)
    but adjusting the end point of each trace to mimic the spread of the shot exiting
    the barrel
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by using multiple traces to replicate the shotgun shell’s
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a for loop to fire multiple pellets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform multiple line traces, we need to add a `For Loop` as the first node
    in the **Event Process Firing** logic chain, connecting the **Line Trace By Channel**,
    **Branch** and **Apply Damage** nodes into the **Loop Body**.
  prefs: []
  type: TYPE_NORMAL
- en: The **For Loop** node will complete each of the steps in the *Loop Body*, incrementing
    its index from the **First Index** value to the **Last** **Index** value.
  prefs: []
  type: TYPE_NORMAL
- en: For the shotgun, set `1`. Typically, we would use `0`, however we are going
    to create an integer variable called `NumberOfPellets` for the `5`. If we were
    to keep **First Index** at zero, the shotgun would fire six pellets, so instead
    of requiring a designer to remember to reduce the variable by 1 to get their desired
    number of traces, we simply start at 1 to make the system more user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: The For Loop node and Number Of Pellets variable](img/Figure_09.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: The For Loop node and Number Of Pellets variable'
  prefs: []
  type: TYPE_NORMAL
- en: With multiple traces firing, we now need to make each trace slightly different
    so that we aren’t just doing multiple identical traces. Let’s do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding spread to the pellet trajectories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add variation to the **End** vector input of the **Line Trace By Channel**
    node, we need to rotate the result of the **Get Forward Vector** node slightly
    before multiplying it by the range.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we add a `Random Unit Vector in Cone in Degrees` node. This uses
    a **Cone Dir** input (the initial direction the cone is facing) and a **Cone Half
    Angle in Degrees** input (the amount of rotation to be applied from the center
    line of the cone).
  prefs: []
  type: TYPE_NORMAL
- en: For **Cone Dir**, we connect in the **Return Value** of the **Get Forward**
    **Vector** node.
  prefs: []
  type: TYPE_NORMAL
- en: For `HalfSpreadDegrees.`
  prefs: []
  type: TYPE_NORMAL
- en: Set the `15`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: The adjusted firing trajectories](img/Figure_09.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The adjusted firing trajectories'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the **Random Unit Vector in Cone in Degrees** node, the calculations
    should be connected together as shown in *Figure 9**.8* with the vector connections
    going into the **Line Trace By** **Channel** node.
  prefs: []
  type: TYPE_NORMAL
- en: With all that now set up, you are ready to test the shotgun. Change the variable
    once more on the Elite Unit in the level and give it a go.
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s all finished and working, let’s move on to another parent-child
    structural pattern where everything is the exact opposite.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding subclass sandbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Subclass Sandbox pattern takes the idea of the template’s limited extension
    through subclasses (to provide security) and applies it the exact opposite way
    round. Here, the children define the order of execution for a set of pre-defined
    code blocks through an abstract spine function. These blocks take the form of
    functions that are defined in the parent class and can never be overridden. Each
    function deals with one thing to do with an external system in a standardized
    way. The following pseudocode makes a better visual point of how this is literally
    the opposite of the template pattern we explored previously, where everything
    previously marked as abstract gets functionality and the one function we had code
    in is now abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: Subclass sandbox pattern parent pseudocode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The workflow for this pattern starts with the programmer building black-box
    tools for the technical designer to string together in interesting ways. This
    can lead to interesting innovation as the programmer isn’t making tools to specification,
    rather just for the sake of having tools, which leaves their application open
    for the technical designer to interpret. The flip side of this is that there could
    be a lot of wastage where tools either don’t get used or they are used in ways
    they could be better designed for. Thus, this process works better as an iteration
    on both sides to ensure that the toolset is useful and efficient, as well as actually
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough speaking in the abstract: let’s look at the implementation of this for
    our weapons alongside the template pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the sandbox (parent class)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to copy what we did in the template section and make another
    C++ child of our `Weapon_Base` class, but this time call it `SandboxWeapon_Base`.
    The whole point of this pattern is that the Blueprint children will implement
    the `Fire` function in whatever way they see fit, but for that we would have to
    add `UFUNCTION(BlueprintNativeEvent)` at the very least. However, because we have
    joined our patterns together with this common parent, it means the function has
    to be marked as virtual and so cannot have a standard function specifier. This
    will never be the case in any production code. It is only a problem here due to
    us showing both patterns linked by a common parent. Our solution for this is a
    second `Fire` function called `SandboxFire`. We will pass the execution off to
    this function within `Fire` so that everything behaves as normal. No sensible
    project architecture would implement both patterns side by side like this, so
    it should not be an issue in your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing we must define are the building block functions, which we have
    chosen to keep similar to the previous example, but for which you can make as
    many as you deem necessary. The key is to keep each function short and to the
    point as their purpose is to standardize the method for interacting with external
    systems so that future changes are easily maintained. The most important aspect
    of the functions laid out in the following code are that they are protected and
    marked as `BlueprintCallable`. This means they are just for children of this class
    to use, not override, and also ensures they have no external access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets start with the base class for the sandbox weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: SandboxWeapon_Base.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the header declared, we can turn to the definitions in the following implementation.
    Our `Fire` function override simply calls `SandboxFire()` to pass the signal through
    to a function with the correct properties. As `SandboxFire` is marked as `BlueprintImplementableEvent`
    it doesn’t have a definition in this class and instead can be completely left
    to the Blueprint children to define. Our `Reload`, `CheckAmmo`, and `UpdateAmmo`
    functions are basically the same as before, but this is dependent on the systems
    that are being hooked into and where it is best to build lots of small specific
    functions. `PlaySound` is a more specific version of `PlayEffects` from before,
    where we were able to leave the implementation to the designer, but now we must
    be specific in function name and use:'
  prefs: []
  type: TYPE_NORMAL
- en: SandboxWeapon_Base.cpp simple function definitions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On the topic of being specific, we now have a `LinetraceOneShot` function in
    place of the `ProcessFiring` function from before. While the utility of this,
    specifying that it is one shot, will become apparent later, this function is one
    of many ways to handle the gameplay logic of the gun firing. It acts as a wrapper
    for the line trace function working off a direction vector the user must pass
    in. This then applies damage to whatever it has hit through the standard Unreal
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add that to the sandbox weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: SandboxWeapon_Base.cpp LinetraceOneShot function definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that our sandbox base is kitted out with a basic suite of tools; we can
    make the Blueprint child weapons equivalent to the template pattern by using the
    Sandbox_Fire function. Comparing the Blueprint implementations of each pattern
    should show a lot of the differences in approach and how each can be used for
    the same system with differing approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Creating child classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with the template pattern, we are going to create two child classes
    of the Sandbox Weapon Base in a Blueprint. To do this, we follow the same steps
    except when searching in the `sandbox` and select `BP_SandboxPistol` and `BP_SandboxShotgun`.
  prefs: []
  type: TYPE_NORMAL
- en: With those created we can move on to setting them up. Unlike with the template
    pattern, we don’t need to create the functional behaviors. Instead, we determine
    the order (and reuse) of the functions in the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox pistol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, we begin with the pistol as this is probably the simplest weapon
    type to implement. First, we do all of our checks to make sure the weapon can
    fire, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Override **Sandbox Fire Function** using the **Override** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Branch` based on the `CanFire` Boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Check Ammo` and add a second `Branch` based on the **Return Value**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9: The start of the Sandbox Fire Event](img/Figure_09.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: The start of the Sandbox Fire Event'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add the logic to the **False** output from the **Branch** node,
    calling **Reload** and playing a sound (sounds haven’t been implemented in the
    parent class as that is something that will typically be different per weapon):'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `Reload` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Play Sound` node, selecting the **Gizmo_Handle_Clicked** sound from the
    dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10: The false logic for the Sandbox Fire Event](img/Figure_09.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: The false logic for the Sandbox Fire Event'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can add the True logic, which essentially fires the weapon. As the
    functional behavior already exists in the parent, we simply need to call the functions
    and provide the required inputs. We’re going to do this in two chunks. The first
    will play a sound before performing the line trace and updating the ammo. The
    second chunk will use a timer to call the function to manage the rate of fire:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Play Sound` node, selecting the `VR_Teleport` sound once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `Linetrace One Shot` function, providing it with the `Forward Vector`
    of the **Fire** **Point** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `Update Ammo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11: The start of the true logic that fires the sandbox pistol](img/Figure_09.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: The start of the true logic that fires the sandbox pistol'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Set Timer by Function` `Name` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Handle_FireDelay` in for **Function Name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide `1` by the **RoF** float variable and connect it to the **Time** pin
    of the **Set Timer by Function** **Name** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Promote the `TimerFireDelay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12: The Hand_FireDelay timer added to the end of the chain](img/Figure_09.12_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: The Hand_FireDelay timer added to the end of the chain'
  prefs: []
  type: TYPE_NORMAL
- en: With the pistol complete, test it the same as we did with the two template weapons
    and then we can move on to implementing the shotgun using the Sandbox pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Sandbox shotgun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The shotgun follows much of the same setup as the pistol except for where we
    once again need to complete multiple line traces. The parent has a single line
    trace that requires a forward vector input. So, just like in the template example,
    we will use a **For Loop** and once again utilize the **Random Unit Vector in
    Cone in Degrees** node when providing the forward vector input to the **Linetrace
    One** **Shot** function:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by copying the logic from the pistol. This just saves us a little bit
    of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect both sides of the **Linetrace One Shot** node by holding down *Alt*
    and clicking on the pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add in a `For Each` loop just as we did in the template shotgun, connecting
    it after the `True` logic and once again using the `Number of Pellets` integer
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Direction** vector input on the **Linetrace One Shot** node, set up
    **Random Unit Vector in Cone in Degrees** in the same way we did for the template
    shotgun, as shown in *Figure 9**.13*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 9.13: The For Loop’s Loop Body logic for \uFEFFthe BP_SandboxShotgun](img/Figure_09.13_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: The For Loop’s Loop Body logic for the BP_SandboxShotgun'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the multiple line traces happening, we need to add back in the rest
    of the firing chain, that is, the Update Ammo function and Fire Delay Timer. Since
    these steps need to be done after we fire, they need to be connected to the **Completed**
    pin on the **For Loop** node, not part of the **Loop Body.**
  prefs: []
  type: TYPE_NORMAL
- en: Move the nodes from the previous steps around to make a clear path for the connection
    from the **Completed** pin and connect the other nodes back in, as shown in *Figure
    9**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: The Update Ammo and Timer connected to the Completed pin](img/Figure_09.14_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: The Update Ammo and Timer connected to the Completed pin'
  prefs: []
  type: TYPE_NORMAL
- en: As before, test this out by selecting the weapon on the Elite Unit in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Provided everything works as it should, we can then move on to exploring the
    type object pattern, which allows us to easily expand the content available in
    a game.
  prefs: []
  type: TYPE_NORMAL
- en: Type object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need a fast way of creating many variants of something in your game
    as a form of expanding the content available to players, then the type object
    pattern is for you. Type object takes the ideas of implicit and explicit data
    we covered as part of the flyweight pattern back in [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046)
    and expands it into the world of gameplay. The principle is the same: we separate
    out all data that is common across all instances of a type, but instead of just
    linking to it from everywhere, we mix it up and produce lots of variations of
    this data. The result is a connected web of objects that all have the same functionality
    but vary in which set of implicit data they use.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.15: Diagram from Chapter 3 where we discussed the \uFEFFFlyweight\
    \ pattern](img/Figure_09.15_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Diagram from [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046) where
    we discussed the Flyweight pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.15* shows the Flyweight pattern saving space by storing implicit
    data about the idea of a tree in one place in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.16: Diagram showing the expansion of the \uFEFFFlyweight pattern\
    \ provided by the \uFEFF\uFEFFtype \uFEFF\uFEFFobject pattern](img/Figure_09.16_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Diagram showing the expansion of the Flyweight pattern provided
    by the type object pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the pattern from Flyweight to type object in *Figure 9**.16*, we define
    more types as different sets of the implicit data. This diagram makes it clear
    the cost of this added expandability will be memory. Now only objects sharing
    a type can be batched together, so the number of batch calls increases but we
    are still way beyond defining every tree explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way of achieving this outcome though. We could keep our
    Flyweight pattern and make a new class for each of our types. That would work,
    so why don’t we do that? Because code takes up space. In the next chapter, we’ll
    cover the idea of data locality, it builds on the knowledge that instructions
    in code, such as values we manipulate, take up space in memory. Duplicating a
    class also duplicates the code that needs to be stored to run, not to mention
    the overhead cost of defining and storing a new class. Our aim is to make an elegant
    solution that streamlines the content creation process and increases efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: To make the type object pattern work in Unreal, we need to store a collection
    of data as an asset that can be loaded into the RAM at runtime for referencing.
    This could be achieved with writing text files or some other structured file format
    like JSON or XML. The problem there is that designers need to have the data files
    open in a separate text editor to make changes, and the process of saving and
    reloading the editor preview can become tedious when many small changes are made
    iteratively. Thankfully, Unreal Engine gives us a few options of built-in structures
    we can use. We will be looking at Variants and the Variant Manager, Data Assets,
    and Data Tables. There are undoubtedly more ways to make this work but these three
    should cover most of the general implementations of the type object pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Variant Manager** is a tool within Unreal Engine that allows us to create
    multiple swapable Variants of actors in a level. The Variants store values for
    Actor properties and can also call functions from within the actor when the Variant
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The Variants are held within the level by a **Level Variant Sets Actor**, which
    links to a **Level Variant Sets** asset where the various actors, their properties
    to change, and the functions within them to call, are all stored.
  prefs: []
  type: TYPE_NORMAL
- en: Variants are activated either via the **Variant Manager Panel** while in the
    editor (as shown in *Figure 9**.17*) or via Blueprint functions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 The Variant Manager panel](img/Figure_09.17_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 The Variant Manager panel
  prefs: []
  type: TYPE_NORMAL
- en: Variants and the Variant Manager are more commonly used in interactive experiences
    such as architectural visualization projects or product-based applications such
    as car configurators.
  prefs: []
  type: TYPE_NORMAL
- en: The Variant Manager approach could be used for a character creation screen like
    those seen in RPG-type games such as World of Warcraft or Cyberpunk 2077, or the
    modular character/vehicle setup systems in games such as Fortnite, Fall Guys,
    or Rocket League, where the player can select different parts to be added to their
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback with the Variant Manager approach for ever-expanding games such
    as Fortnite or Fall Guys is the time required to create variants and fully set
    them up. An in-game character customization system would be much more suited to
    using a data table approach, where additional data can quickly be added in a table
    editor or imported from a spreadsheet. Let’s take a look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: Data Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data Tables are an asset type created for the purpose of storing values with
    no functionality. We define them in our project with a struct, each member becoming
    a column in the table. Each row of the table then represents a set of values we
    call a type to fit in with our pattern. Data Tables are designed for large-scale
    storage of data in one place to be queried when necessary. They can store values
    pointing to other assets, but these are cumbersome to work with in this form and
    are generally avoided in favor of storing everything as primitive types. This
    soft limit of primitive data means that, although possible, working with nested
    information is advised against. This could affect systems where one customization
    affects what is available in a level below.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of this asset is its ability to import directly from a CSV
    or JSON file, making it the preferred method of balancing for designers with external
    tools. The flipside of this is because everything is stored together, even if
    you aren’t using all the types in a given scene, all the data will still be loaded
    into memory, making it less viable for high-level types and more applicable to
    utility-type patterns such as quest systems that are universal and always need
    to be loaded. There is also an argument for using Data Tables for language localization,
    as with all the types in one place, searches for specific records become way easier
    and faster.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Screenshot of an example Data Table with weapon balancing data](img/Figure_09.18_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Screenshot of an example Data Table with weapon balancing data'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.18* shows a Data Table in use for balancing the different enemy
    types in a game where the only changes are stat values as the enemy rank increases.
    This could have been imported from an external balancing tool as all the values
    are primitive types.'
  prefs: []
  type: TYPE_NORMAL
- en: Data Assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Data Asset takes the idea of Data Tables and breaks it down into individual
    rows. Each row then becomes its own asset that can be created and managed via
    the editor. When we define a Data Asset it looks very much like a struct definition
    but on instancing it, we do not get a new item in the world. Instead, we get a
    new Data Asset instance in the project, similar to the way materials and material
    instances work. Once a Data Asset instance is referenced in active code, that
    instance is loaded into memory, just like a texture or static mech asset. Due
    to the editor being responsible for the creation and management of Data Assets,
    they have easy tools for holding references to other assets. This makes them useful
    for defining type data for high-level class specialization. They also deal with
    nested information well, as if it has been serialized properly, the editor has
    space to show the drop-down menus where sub-values can be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to explain how to use Data Assets for a type object pattern is
    to make something with them. So, let’s turn our attention back to the project
    we have been working on through this chapter to implement some Data Assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a new type of Data Asset by right-clicking in the C++ folder.
    Make sure to do this from the editor as there are no templates available within
    Rider, meaning you’ll have to make a lot of unnecessary changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When selecting the base class to inherit from, choose **UDataAsset** from the
    **All** **Classes** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then give it a name. We have called ours `EnemyType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19: Class creation menu setup to make a new Data Asset](img/Figure_09.19_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: Class creation menu setup to make a new Data Asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we consider what data we need to store inside the asset. There could
    be any number of things we want to vary between different enemy types. The key
    is to make sure you only store data specifically about the enemy here, and not
    the other classes that could be different within the enemy class, such as the
    weapon fire rate. Weapons would need another parallel implementation of the type
    object pattern, which could even be nested within this one with the weapon type
    defined within the enemy type:'
  prefs: []
  type: TYPE_NORMAL
- en: Give the class the `BlueprintType` property in the `UCLASS` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are only changing the health and materials on the enemy with its type, so
    add a float for health and a couple of object pointers to the `UmaterialInstance`
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure each variable has the `EditAnywhere` and `BlueprintReadWrite` property
    specifiers, and we are all done with the C++ side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: EnemyType.h exerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define some Data Assets from the template we have just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: Build back into the editor and right-click on the **RTS/Data** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Miscellaneous** > **Data Asset**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20: The Data Asset option is in the right-click menu](img/Figure_09.20_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: The Data Asset option is in the right-click menu'
  prefs: []
  type: TYPE_NORMAL
- en: Select **EnemyType** from the list of classes to be the parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new asset a name that represents the type we are making (we have gone
    with `Enemy_Basic`) and then open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the health value to `100` and select **MI_EnemyUnit_01** and **MI_EnemyUnit_02**
    for the material slots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step is to apply these values to the unit on spawn:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **BP_EnemyUnit**, found in the **RTS/Blueprints** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new variable of type **EnemyType** and make it editable by clicking the
    eye icon, as shown in *Figure 9**.21*. Then set its default value to **Enemy_Basic**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21: The BP_EnemyUnit variables](img/Figure_09.21_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: The BP_EnemyUnit variables'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **BeginPlay** event node to the event graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the new **TypeData** variable has a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then place each value from the **TypeData** variable into its relevant place
    as shown in *Figure 9**.22*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data](img/Figure_09.22_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data
  prefs: []
  type: TYPE_NORMAL
- en: Doing all this should make nothing appear or behave differently, but it does
    now give us the flexibility to define new types of enemy with different materials
    in the Content Browser. We can then set spawned enemies to be different types
    using the editable variable. As an extension to this, see if you can define a
    new enemy type with 200 health that uses the B versions of the material instances
    we used for the basic type. These can be found in the same folder as the materials
    we were using before but are tinted blue. Another extension you could try is to
    set the type variable to expose on spawn and dynamically spawn a few enemies in
    the level. This will allow you to set the type in the code, hopefully demonstrating
    the power of this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve explored the ways in which the type object can be utilized in gameplay
    to facilitate large numbers of variants using three different approaches in Unreal
    Engine: Variants, Data Tables, and Data Assets. With the completion of our type
    object example, we have come to the end of our exploration of patterns that can
    be used to build structured solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three patterns we have covered in this chapter are the most widely used
    structural patterns. Use of the first two is a personal preference, as we saw
    they can both be used to achieve the same thing in different ways. Template and
    subclass sandbox are also being superseded by other techniques in modern code,
    such as interfaces and modular design, but understanding where they came from
    and the workflow they encourage is useful. Template and subclass Sandbox both
    highlight the need to constrain designers with limited access to ensure the maintainability
    of the codebase. The type object pattern, on the other hand, is one of the most
    useful patterns in game development with widespread application across all aspects
    of game design. Its utility in allowing artists, designers, and programmers to
    work together is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into a few patterns that we can apply once
    we have a working game to improve our performance using the concepts of object
    pooling, data locality, and dirty flags.
  prefs: []
  type: TYPE_NORMAL
