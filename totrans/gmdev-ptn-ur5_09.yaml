- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and
    Type Object
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用行为模式结构代码 – 模板、子类沙盒和类型对象
- en: This chapter focuses on the three most common structural patterns. Structural
    patterns allow us to plan our code with the end usage in mind. For example, if
    we know that the end users of our system are likely to be designers with no code
    experience, we could plan to use the type object pattern to provide a system for
    easy dynamic expansion. We have already covered some of the concepts around code
    structure when we discussed using interfaces and events to achieve anonymous modular
    design in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090). The three patterns
    in this chapter (template, subclass sandbox, and type object) are a little more
    zoomed-in in terms of scope compared to what we have looked at before. The first
    two are interchangeable depending on your preference, both working as extensions
    to the standard inheritance property of the C++ programming language. The last
    is by far the most useful pattern in game design, giving designers the ability
    to define variants of classes with ease without getting in the programmers’ way
    while they make new functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍三种最常见的结构模式。结构模式使我们能够考虑到最终用途来规划我们的代码。例如，如果我们知道我们系统的最终用户很可能是没有编程经验的设计师，我们就可以计划使用类型对象模式来提供一个易于动态扩展的系统。在我们讨论使用接口和事件来实现匿名模块化设计时，我们已经介绍了一些关于代码结构的概念，见[*第7章*](B18297_07.xhtml#_idTextAnchor090)。本章中的三种模式（模板、子类沙盒和类型对象）在范围上比我们之前看到的要具体一些。前两种模式根据您的偏好可以互换，两者都作为C++编程语言标准继承属性的扩展。最后一种是游戏设计中最有用的模式，它使设计师能够轻松定义类的变体，而不会妨碍程序员在添加新功能时的工作。
- en: 'The topics we will cover in this chapter are the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Exploring the **Template** pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**模板**模式
- en: Understanding **Subclass Sandbox**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**子类沙盒**
- en: The **Type** **Object** pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型对象**模式'
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Unlike previous chapters, we will be starting with the project files in the
    `chapter9` branch on GitHub, which can be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节不同，我们将从GitHub上的`chapter9`分支的项目文件开始，该分支可以从[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09)下载。
- en: We have made a few small changes to the project to facilitate the following
    pattern examples. These changes are a bit too tedious to walk through in this
    chapter but if you would like to see what has changed, then download both this
    and the previous chapters’ branches and run them through a diffing program such
    as DiffMerge.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对项目做了一些小的改动，以方便以下模式示例。这些改动在本章中过于繁琐，无法一一介绍，但如果您想查看发生了什么变化，请下载这两个章节的分支，并通过DiffMerge之类的比较程序运行它们。
- en: Let’s get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Exploring the template pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模板模式
- en: The template pattern exists as an extension to standard inheritance, where we
    define a structure in an abstract parent class and the children are given the
    opportunity to override the pieces of that structure. They can change how individual
    parts function but not the order of execution. The simplest example of this within
    Unreal is the `AActor` base class. Any child of AActor gets access to the Begin
    Play, Tick, and End Play events, to name but a few. The child class can hook functionality
    onto these events, and they will fire when expected. The constraint we place on
    inheritance to make this into the template pattern is that the child has no way
    of changing the order or timing of these events. There is no way to make End Play
    fire before Begin Play as this order has been defined in the parent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式作为标准继承的扩展存在，我们在抽象父类中定义一个结构，子类有机会覆盖该结构的各个部分。它们可以改变各个部分的功能，但不能改变执行顺序。在虚幻引擎中最简单的例子是`AActor`基类。AActor的任何子类都可以访问Begin
    Play、Tick和End Play事件，仅举几个例子。子类可以将功能钩子附加到这些事件上，并且它们将在预期时触发。我们将继承施加的约束使这成为模板模式是，子类没有改变这些事件顺序或时间的方式。没有方法使End
    Play在Begin Play之前触发，因为这个顺序已经在父类中定义了。
- en: 'We can see an example of a class implementing the template pattern in the following
    code. The `ProcessGame()` function is the only one with a body, defining the order
    of the private abstract function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们可以看到一个实现模板模式的类的示例。`ProcessGame()` 函数是唯一一个有主体的函数，它定义了私有抽象函数的顺序：
- en: Template pattern parent pseudocode
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式父类伪代码
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see the `AActor` class has four functions with only one of them not marked
    as abstract or virtual. This function is our spine that defines the order of execution.
    From there, each of the other functions may have some form of implementation in
    the base but they are designed to be ultimately overridden. The best situation
    is for each of these extra utility functions to be abstract with no implementation
    in the base to retain the lightweight nature of the pattern, but if that means
    that a lot of the implementations will be repeated, then a virtual base with the
    common code would be better. The goal is to keep this class as light as possible
    while cutting down as much repetition as we can.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `AActor` 类有四个函数，其中只有一个没有被标记为抽象或虚拟。这个函数是我们的脊柱，定义了执行顺序。从那里，其他每个函数可能在基类中都有某种形式的实现，但它们被设计成最终被覆盖。最佳情况是每个额外的实用函数都是抽象的，基类中没有实现，以保持模式的轻量级特性，但如果这意味着很多实现将会重复，那么使用包含公共代码的虚拟基类会更好。目标是尽可能保持这个类轻量，同时减少尽可能多的重复。
- en: Important caveat
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Strictly speaking, the actual structure of `AActor` doesn’t implement the Template
    pattern, as shown in the pseudocode; we collapsed the tree a little to make a
    point. In reality, that loop is dealt with by the world object and filtered down
    to all the actors and subsystems within it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`AActor` 的实际结构并没有实现模板模式，如伪代码所示；我们稍微折叠了树形结构以说明这一点。实际上，那个循环是由世界对象处理的，并过滤到其中的所有演员和子系统。
- en: To demonstrate this, we are going to give our elite unit some weapons. In the
    GitHub branch for this chapter, the `EliteUnit` C++ class has already been augmented
    to spawn a weapon from a base class defined in the class defaults. This spawned
    weapon is an actor that we have attached to a `SceneComponent`, positioned just
    in front of the character. The code is also modified to call the fire function
    on this weapon instead of running a line trace from within the character. As it
    currently stands, this code will not run as there are no classes available for
    the character to spawn from that are not marked as abstract. Our first step is
    to build the template parent class as a child of this generic weapon in C++. We
    can then leave the creation of the functional child weapons to a Blueprint, giving
    us an excellent way to understand how the two systems work together and allowing
    programmers to do the groundwork in C++ before the technical designers and designers
    explore variations in Blueprints. This allows for quick prototyping and iteration
    of weapon designs to achieve the intended game feel without breaking any of the
    underlying systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将给我们的精英部队一些武器。在GitHub分支的这部分内容中，`EliteUnit` C++ 类已经被增强，可以从类默认中定义的基类中生成武器。这个生成的武器是一个我们附加到
    `SceneComponent` 上的演员，位于角色前方。代码也被修改为调用这个武器的射击函数，而不是在角色内部运行射线跟踪。按照目前的状态，这段代码将无法运行，因为没有标记为非抽象的类可供角色生成。我们的第一步是构建模板父类，作为这个通用武器在C++中的子类。然后我们可以将功能性子武器的创建留给蓝图，这为我们提供了一个理解两个系统如何协同工作的绝佳方式，并允许程序员在技术设计师和设计师在蓝图中探索变化之前在C++中完成基础工作。这允许快速原型设计和迭代武器设计，以实现预期的游戏感觉，同时不破坏任何底层系统。
- en: Building the template (parent class)
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模板（父类）
- en: As mentioned earlier, our first step is to make a new C++ child class of `AWeapon_Base`.
    With that made, we can set about putting the template main function in place which,
    as we can see in the code below, is called `Fire()`. The parent class has a lot
    of the data and a core system for dealing with a brief cooldown delay between
    shots. These variables have been added at the top level as they will be universal
    to all weapon types and so it makes sense to consolidate them in the common parent.
    This does mean that the `Fire()` function here is an override, whereas in a straight
    implementation of the template pattern, this would be at the top level. We are
    only doing things differently here to create a shared hierarchy with the Sandbox
    pattern that we’ll see in the next section to highlight the differences.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的第一步是创建一个名为 `AWeapon_Base` 的新 C++ 子类。创建完成后，我们可以着手放置模板主函数，正如我们可以在下面的代码中看到的，它被调用为
    `Fire()`。父类有很多数据和核心系统，用于处理射击之间的短暂冷却延迟。这些变量被添加到顶级，因为它们将适用于所有武器类型，所以将它们在通用父类中合并是有意义的。这也意味着这里的
    `Fire()` 函数是一个重写，而在模板模式的直接实现中，这将在顶级。我们在这里做不同的事情是为了创建一个与下一节中将要看到的沙盒模式共享的层次结构，以突出差异。
- en: 'The other functions in the template weapon base class include a public function
    for reloading, as you may want to actively call that function even though we will
    be triggering it by default anyway. This is followed by a bunch of utility functions
    that are marked as either `BlueprintNativeEvent` if they have a default implementation
    in the base, or `BlueprintImplementableEvent` if they do not. Each of these protected
    functions exists to be overridden by the children to change the behavior of the
    weapon:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模板武器基类中的其他函数包括一个用于重新装填的公共函数，尽管我们无论如何都会默认触发它，但你可能仍然希望主动调用该函数。随后是一系列标记为 `BlueprintNativeEvent`
    的实用函数，如果它们在基类中有默认实现，或者标记为 `BlueprintImplementableEvent`，如果它们没有。每个这些受保护函数都存在，以便子类可以重写以改变武器的行为：
- en: TemplateWeapon_Base.h excerpt
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TemplateWeapon_Base.h 摘录
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The only function in the implementation of this class is the template spine
    we are calling `Fire()`. In this function, we define the execution order of all
    the other functions in a way that becomes concrete. In the following implementation,
    we check whether we can fire; if not, we use an early return to exit the function.
    Then we check whether we have the ammo to fire; if not, then we’ll reload. If
    the weapon is able to fire, then the process outlined by this function starts
    with the effects, then runs the gameplay logic for actually firing with the reduction
    in ammo calculated after that. The last thing it does is call the parent, where
    we have set up the code to deal with the firing delay (which is used to prevent
    the fire button being spammed or exploited with auto-clickers and macros):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现中只有一个函数，就是我们称之为 `Fire()` 的模板脊。在这个函数中，我们以具体的方式定义了所有其他函数的执行顺序。在下面的实现中，我们检查是否可以射击；如果不能，我们使用早期返回退出函数。然后我们检查是否有足够的弹药来射击；如果没有，那么我们将重新装填。如果武器能够射击，那么这个函数概述的过程从效果开始，然后运行实际射击的游戏逻辑，之后计算弹药减少。最后，它调用父类，在那里我们已经设置了处理射击延迟的代码（这用于防止通过自动点击器或宏滥用射击按钮）：
- en: TemplateWeapon_Base.cpp main template function
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TemplateWeapon_Base.cpp 主模板函数
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next few functions are just default implementations that make sense and
    are likely to be repeated code if not defined here. The reload function resets
    the ammo counter and calls the fire delay reset function. `CheckAmmo` is a one-line
    Boolean check that could be made pure as an extension to this. Finally, `UpdateAmmo`
    just takes the predefined `_AmmoPerFire` from our ammo counter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个函数只是合理的默认实现，如果没有在这里定义，很可能会是重复的代码。重新装填函数重置弹药计数器并调用射击延迟重置函数。`CheckAmmo`
    是一行布尔检查，可以作为此扩展的纯函数。最后，`UpdateAmmo` 只从我们的弹药计数器中获取预定义的 `_AmmoPerFire`：
- en: TemplateWeapon_Base.cpp utility functions
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TemplateWeapon_Base.cpp 工具函数
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That forms the C++ base for our template pattern. All that is left is to make
    an implementation or two with Blueprint child classes in the editor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这形成了我们的模板模式的 C++ 基础。剩下要做的就是通过编辑器中的蓝图子类实现一个或两个实现。
- en: Creating child classes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子类
- en: 'We are now going to create two child classes in a Blueprint. This task offers
    us a great opportunity to explore how C++ and Blueprints can work together to
    create efficient solutions. To do this, we need to create new child Blueprints,
    one for a pistol and a second for a shotgun. These weapons both utilize a line-trace
    approach with variation for multiple projectiles in a spread. This allows us to
    focus on creating two different solutions with a small but significant change
    to build a solid example for the template pattern. To do this, we are going to
    use the same menu from before, but instead of selecting **Actor** from the dialog,
    we need to dig a bit deeper to find the C++ parent class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在蓝图内创建两个子类。这项任务为我们提供了一个很好的机会来探索C++和蓝图如何协同工作以创建高效的解决方案。为此，我们需要创建新的子蓝图，一个用于手枪，另一个用于霰弹枪。这两种武器都使用线迹方法，并在扩散中具有多个弹丸的变化。这使我们能够专注于创建两个不同的解决方案，通过微小但重要的变化来构建一个坚实的模板模式的示例。为此，我们将使用之前的相同菜单，但我们需要在对话框中从**Actor**选择中深入挖掘以找到C++父类：
- en: Start by right-clicking in the Content Browser and clicking **Blueprint Class**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在内容浏览器中右键单击，然后单击**蓝图类**。
- en: If it isn’t already visible, expand the **ALL CLASSES** rollout by clicking
    the title.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有显示，通过单击标题来展开**所有类**展开栏。
- en: In the search box, type `template` to reduce the number of options displayed
    in the results box, as shown in *Figure 9**.1*.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`template`以减少结果框中显示的选项数量，如图*图9.1*所示。
- en: "![Figure 9.1: \uFEFFThe Blueprint creation window for a template weapon](img/Figure_09.01_B18297.jpg)"
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：模板武器的蓝图创建窗口](img/Figure_09.01_B18297.jpg)'
- en: 'Figure 9.1: The Blueprint creation window for a template weapon'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：模板武器的蓝图创建窗口
- en: Select **TemplateWeapon_Base** from the list, then click **Select**, which will
    only appear once you’ve made your selection.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择**TemplateWeapon_Base**，然后单击**选择**，这将只在你做出选择后出现。
- en: Name this new Blueprint `BP_TemplatePistol`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新蓝图命名为`BP_TemplatePistol`。
- en: With the pistol child Blueprint created, we next need to create a child Blueprint
    for the shotgun. To do this, repeat the preceding steps but name the second blueprint
    `BP_TemplateShotgun`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了手枪子蓝图之后，我们接下来需要为霰弹枪创建一个子蓝图。为此，重复前面的步骤，但将第二个蓝图命名为`BP_TemplateShotgun`。
- en: Now that the child classes have been created, we can move on to creating the
    behaviors inside them, making use of the template pattern to only modify the part
    of the class necessary to achieve the desired functionality of each child.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了子类，我们可以继续在它们内部创建行为，利用模板模式仅修改类中必要的部分以实现每个子类的期望功能。
- en: Template pistol
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板手枪
- en: Now that we have our Blueprint for the Pistol set up, we can move on to overriding
    the parts of the template that will be unique to this class. The `CheckAmmo` and
    `UpdateAmmo` functions will remain the same for our pistol class as in the parent
    template. We will be overriding `PlayEffects`, `ProcessFiring`, and `Reload`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了手枪的蓝图，我们可以继续到覆盖模板中独特于这个类别的部分。`CheckAmmo`和`UpdateAmmo`函数对于我们手枪类来说将与父模板中的相同。我们将覆盖`PlayEffects`、`ProcessFiring`和`Reload`。
- en: We’ve overridden functions before, namely in [*Chapter 8*](B18297_08.xhtml#_idTextAnchor113)
    when looking at utility blueprints. The process here is exactly the same.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经覆盖过函数，即在[*第8章*](B18297_08.xhtml#_idTextAnchor113)中查看实用蓝图时。这里的流程完全相同。
- en: Note on overriding C++ functions
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于覆盖C++函数的说明
- en: When we override functions in a Blueprint that are included within a C++ parent,
    we don’t get a choice between creating a function or an event. The result we get
    when selecting to override the C++ function will depend on whether the function
    has a return or not. If a function does not contain a return, the override in
    the Blueprint will automatically create an Event node in the main Blueprint Event
    Graph. If the function does have a return (like `CheckAmmo` does), the override
    will provide a Blueprint function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在包含在C++父类中的蓝图内覆盖函数时，我们不会在创建函数或事件之间做出选择。选择覆盖C++函数的结果将取决于该函数是否有返回值。如果一个函数不包含返回值，蓝图中的覆盖将自动在主蓝图事件图中创建一个事件节点。如果一个函数确实有返回值（如`CheckAmmo`），覆盖将提供一个蓝图函数。
- en: 'First, we are going to override the `PlayEffects` function. This is where we
    would typically add a muzzle flash particle effect and play an animation and a
    sound. In the interest of keeping the repository for this exercise small, and
    the number of steps short to allow us to focus on learning, we will just add a
    sound effect. Again, in the interest of keeping the required download small, we
    will use a sound from the Engine Content as opposed to finding a purpose-selected
    sound for the gun. Let’s do this as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重写`PlayEffects`函数。通常，我们会在这里添加一个枪口闪光粒子效果，播放动画和声音。为了保持这个练习的存储库小，以及步骤数量短，以便我们能够专注于学习，我们只会添加一个声音效果。再次，为了保持所需的下载量小，我们将使用来自引擎内容的声音，而不是为枪找到专门选择的声音。让我们这样做：
- en: Open the Blueprint and on the left side, hover over the **Functions** section
    of the **My Blueprint** tab. This should reveal the **Override** dropdown. From
    this, select **Play Effects**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图，在左侧，将鼠标悬停在**我的蓝图**选项卡中的**函数**部分。这应该会显示**重写**下拉菜单。从该菜单中选择**播放效果**。
- en: This should have added an **Event Play Effects** node to the Event Graph.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该在事件图中添加了一个**事件播放效果**节点。
- en: Drag from the pin on the `Play Sound at` `Location` node.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Play Sound at` `Location`节点上的销钉拖动。
- en: Expand the `VR_Teleport`. If nothing appears, you will need to enable **Show
    Engine Content** from the **Settings** dropdown, which can be accessed by clicking
    the cog icon in the top right of the dropdown.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`VR_Teleport`。如果没有出现任何内容，您需要从**设置**下拉菜单中启用**显示引擎内容**，这可以通过单击下拉菜单右上角的齿轮图标访问。
- en: Drag from the `Get Actor` `Location` node.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Get Actor` `Location`节点拖动。
- en: '![Figure 9.2: The overridden Event Play Effects function in the Blueprint](img/Figure_09.02_B18297.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：蓝图中的重写事件播放效果函数](img/Figure_09.02_B18297.jpg)'
- en: 'Figure 9.2: The overridden Event Play Effects function in the Blueprint'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：蓝图中的重写事件播放效果函数
- en: 'Next, we will override **ProcessFiring**. This is where we are going to put
    all of our firing logic. The precise contents of this function will differ depending
    on the type of weapon. For the pistol, we can use a simple line trace similar
    to the approach taken for attacking enemies that we created in [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057)
    when making the Behavior Tree for the Elite Unit. To begin, let’s set up the trace:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重写**ProcessFiring**。这是我们放置所有射击逻辑的地方。这个函数的确切内容将根据武器的类型而有所不同。对于手枪，我们可以使用一个简单的线迹，类似于我们在创建精英单位的**行为树**时为攻击敌人所采取的方法。首先，让我们设置追踪：
- en: Drag from the pin on the `Line Trace by Channel` node to the graph.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“按通道线迹”节点上的销钉拖动到图中。
- en: Drag in the `Get World Location` node and then repeat this again to add a `Get
    Forward` `Vector` node.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Get World Location`节点拖动，然后重复此操作以添加一个`Get Forward` `Vector`节点。
- en: Connect the **Return Value** pin on **Get World Location** node to the **Start**
    pin on the **Line Trace By** **Channel** node.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Get World Location**节点的**返回值**销钉连接到**线迹通过** **通道**节点的**开始**销钉。
- en: Drag from the `Multiply` (`x`) node by typing `*` in the search box.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中键入`*`从`Multiply` (`x`)节点拖动。
- en: Right-click the lower pin on the **Multiply** node and select **Convert Pin
    | Float (single-precision)**. This will turn the yellow pin green, indicating
    that the variable expected is no longer a vector but now a float.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**乘**节点下方的销钉，并选择**转换销钉 | 浮点（单精度）**。这将使黄色销钉变为绿色，表示预期的变量不再是向量，而现在是浮点数。
- en: Drag from the green pin and add a `Get Range` node. This will add the `Range`
    variable defined in the parent class.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从绿色销钉拖动并添加一个`Get Range`节点。这将添加在父类中定义的`Range`变量。
- en: Once again drag from the **Get World Location** node and create an **Add** node
    (reached by typing **+**).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从**Get World Location**节点拖动并创建一个**加**节点（通过键入**+**访问）。
- en: Connect the lower input vector pin of the **Add** node to the output vector
    pin of the **Multiply** node.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**加**节点的下输入向量销钉连接到**乘**节点的输出向量销钉。
- en: Connect the output of the **Add** node to the **End** pin on the **Line Trace
    By** **Channel** node.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**加**节点的输出连接到**线迹通过** **通道**节点的**结束**销钉。
- en: 'Next, we need to tell the line trace to ignore the character when shooting,
    or else the only character the gun will damage will be the one firing it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉线迹在射击时忽略角色，否则枪唯一能伤害的角色将是开枪的人：
- en: Right-click in the event graph and create a `Get` `Owner` node.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中右键单击并创建一个`Get` `Owner`节点。
- en: Drag from the **Return Value** output of the **Get Owner** node and add a **Make**
    **Array** node.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Get Owner**节点的**Return Value**输出拖动，并添加一个**Make Array**节点。
- en: Connect the **Array** output pin of the **Make Array** node to the **Actors
    to Ignore** pin on the **Line Trace By** **Channel** node.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Make Array**节点的**Array**输出引脚连接到**Line Trace By Channel**节点的**Actors to Ignore**引脚。
- en: The line trace is now set up and should look like the graph shown in *Figure
    9**.3*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 线迹现在已设置好，应该看起来像*图9.3*中所示的图表。
- en: '![Figure 9.3: The Line Trace node with the inputs setup](img/Figure_09.03_B18297.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：设置输入的Line Trace节点](img/Figure_09.03_B18297.jpg)'
- en: 'Figure 9.3: The Line Trace node with the inputs setup'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：设置输入的Line Trace节点
- en: Drag and drop variables defined in the parent class
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将在父类中定义的变量拖放到图中
- en: If you’d like to be able to drag the variables we defined in the parent class
    into the graph in the same way you would with a variable created in a blueprint,
    click the cog in the top right of the **My Blueprint** tab and enable **Show**
    **Inherited Variables**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望能够将我们在父类中定义的变量以与在蓝图创建的变量相同的方式拖放到图中，请点击**My Blueprint**标签右上角的齿轮并启用**Show
    Inherited Variables**。
- en: 'Next, we need to do something with the result of the trace. In this case, we
    are going to use the Apply Damage approach, just as we did in [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对追踪结果进行处理。在这种情况下，我们将使用应用伤害的方法，就像我们在[*第4章*](B18297_04.xhtml#_idTextAnchor057)中所做的那样：
- en: Drag from the `Break Hit` `Result` node.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Break Hit Result`节点拖动。
- en: Drag from the `Apply` `Damage` node.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Apply Damage`节点拖动。
- en: To make the graph easier to read, click the collapse arrow (**^**) on the bottom
    of the **Break Hit Result** node. This will collapse the node to only show the
    top two bool pins and any pins that have been used, hiding any unused pins. In
    this case, just the **Hit Actor** pin will remain visible along with the top two
    bool pins (**Blocking Hit** and **Initial Overlap**).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使图表更容易阅读，点击**Break Hit Result**节点底部的折叠箭头（**^**）。这将折叠节点，只显示顶部两个bool引脚和任何已使用的引脚，隐藏任何未使用的引脚。在这种情况下，仅**Hit
    Actor**引脚和顶部两个bool引脚（**Blocking Hit**和**Initial Overlap**）将保持可见。
- en: Drag back from the `Get Damage Per Hit` node, once again grabbing a variable
    defined in the parent.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从`Get Damage Per Hit`节点拖动，这次再次获取父类中定义的变量。
- en: Lastly, drag from the `Branch` node (`If`) and connect the three nodes together
    as shown in *Figure 9**.4*.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从`Branch`节点（`If`）拖动，并将三个节点连接起来，如图*图9.4*所示。
- en: '![Figure 9.4: The result of the trace used to apply damage to the enemy unit](img/Figure_09.04_B18297.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：用于对敌方单位造成伤害的追踪结果](img/Figure_09.04_B18297.jpg)'
- en: 'Figure 9.4: The result of the trace used to apply damage to the enemy unit'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：用于对敌方单位造成伤害的追踪结果
- en: The last thing to do is to check the values of each of the inherited variables.
    You can do this by clicking on the variable nodes or, if you chose to show inherited
    variables, you can select them from the variables list in the **My** **Blueprint**
    tab.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是检查每个继承变量的值。你可以通过点击变量节点来完成，或者如果你选择显示继承变量，你可以从**My Blueprint**标签中的变量列表中选择它们。
- en: Ensure that the `1000.0` and `20.0`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`1000.0`和`20.0`。
- en: 'With the firing of the weapon sorted, we can next turn our attention to the
    reload function. Unlike the previous two overrides, the reload function is not
    an abstract function. The parent template class already handles the functional
    aspect of the reload, adding the ammo back into the weapon, so we need to ensure
    we retain that in the child class. We can then add all the extra elements such
    as sounds, animations, particle effects, and so on. Once again, let’s keep this
    simple by just adding a sound. First, let’s override the Reload function and ensure
    we are maintaining the functionality from the parent class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决武器发射问题后，我们可以将注意力转向重新装填功能。与前面的两个覆盖不同，重新装填函数不是一个抽象函数。父模板类已经处理了重新装填的功能方面，将弹药重新添加到武器中，因此我们需要确保在子类中保留这一点。然后我们可以添加所有额外的元素，如声音、动画、粒子效果等。再次，让我们保持简单，只添加一个声音。首先，让我们覆盖重新装填函数并确保我们正在维护父类中的功能：
- en: Override the **Reload** in function in the same way as we did for the previous
    two functions. This will add the **Event Reload** node to the **Event Graph**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与前面两个函数相同的方式覆盖**Reload**函数。这将向**Event Graph**添加**Event Reload**节点。
- en: 'Right-click on the **Event Reload** node and select **Add call to parent function**.
    This will add a **Parent: Reload** node for you.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '右键单击**Event Reload**节点并选择**添加对父函数的调用**。这将为您添加一个**Parent: Reload**节点。'
- en: 'Move the **Parent: Reload** node beside the **Event Reload** node and connect
    them together.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**Parent: Reload**节点移到**Event Reload**节点旁边并将它们连接起来。'
- en: '![Figure 9.5: The Event Reload and Parent: Reload nodes](img/Figure_09.05_B18297.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：Event Reload和Parent: Reload节点](img/Figure_09.05_B18297.jpg)'
- en: 'Figure 9.5: The Event Reload and Parent: Reload nodes'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '图9.5：Event Reload和Parent: Reload节点'
- en: 'The **Parent: Reload** node tells Unreal to do all the steps from the parent
    version of this function at this point in the logic chain.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parent: Reload**节点告诉虚幻引擎在逻辑链中的这个点上执行该函数的父版本的所有步骤。'
- en: Now that we have the behavior from the parent included in the child, we can
    add the sound. We do this just in the same way as we did for the **PlayEffects**
    event, however this time, we will select the **Gizmo_Handle_Clicked** sound.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将父类的行为包含到子类中，我们可以添加声音。我们就像为**PlayEffects**事件所做的那样来做这件事，然而这次，我们将选择**Gizmo_Handle_Clicked**声音。
- en: '![Figure 9.6: The completed Event Reload function in our Blueprint](img/Figure_09.06_B18297.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6：我们蓝图中的完成后的Event Reload函数](img/Figure_09.06_B18297.jpg)'
- en: 'Figure 9.6: The completed Event Reload function in our Blueprint'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：我们蓝图中的完成后的Event Reload函数
- en: 'With the reload function sorted, our pistol is complete. Let’s test it out
    on the character to make sure it works. The **EliteUnit** modifications included
    an automated system for spawning and attaching weapons to the character based
    on a drop-down box. Set the weapon as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在整理好重新加载函数后，我们的手枪就完成了。让我们在角色上测试它以确保它工作。**EliteUnit**修改包括了一个基于下拉框自动生成和附加武器到角色的系统。按照以下设置武器：
- en: Select the **BP_EliteUnit** that is in the level.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择级别中的**BP_EliteUnit**。
- en: Search in the details panel for `Weapon` `to Spawn`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息面板中搜索`Weapon` `to Spawn`。
- en: Change the value in the drop-down box to **BP_TemplatePistol**.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下拉框中的值更改为**BP_TemplatePistol**。
- en: If you see `UCLASS` block includes the `Abstract` property so that no one can
    ever spawn an instance of the base class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`UCLASS`块包含`Abstract`属性，这样就没有人可以实例化基类。
- en: With the pistol now set up, tested, and functional, let’s look at the shotgun.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在手枪已经设置好、测试并通过，让我们看看霰弹枪。
- en: Template shotgun
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板霰弹枪
- en: For the sake of simplicity and to avoid this being a very long chapter, with
    the shotgun the only unique approach we will apply is to the **Process Firing**
    function. Because the Play Effects and Reload functions are abstract in the parent,
    we must override them, so before we get started on the Process Firing for the
    shotgun, replicate the other two functions from the pistol in the **BP_TemplateShotgun**
    Event Graph. You can do this by creating them again manually or by copying and
    pasting them between graphs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化并避免使这一章变得非常长，对于霰弹枪，我们将唯一应用的独特方法是**Process Firing**函数。因为父类中的Play Effects和Reload函数是抽象的，我们必须覆盖它们，所以在我们开始为霰弹枪编写Process
    Firing之前，需要在**BP_TemplateShotgun**事件图中复制手枪中的其他两个函数。您可以通过手动再次创建它们或通过在图表之间复制粘贴它们来完成此操作。
- en: With that done, let’s move on to sorting the firing out. Rather than going through
    this version step by step, let’s look at the differences so you can make the necessary
    changes to create a shotgun rather than a pistol. Begin by copying over the firing
    logic from the pistol before modifying it to replicate each of the changes that
    follow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们继续对射击进行排序。与其一步一步地通过这个版本，不如看看差异，这样您就可以做出必要的更改来创建霰弹枪而不是手枪。首先，复制手枪的射击逻辑，然后再修改它以复制以下每个更改。
- en: Unlike a pistol, we need to consider that when fired, a shotgun doesn’t fire
    a single projectile. Rather, shotgun shells often contain between nine and eighteen
    small pellets that are fired out of the barrel in a cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与手枪不同，我们需要考虑当霰弹枪发射时，它不会发射单个弹丸。相反，霰弹枪弹壳通常包含九到十八颗小弹丸，这些弹丸以一群的形式从枪管中发射出来。
- en: To replicate this, we simply increase the number of traces we perform and add
    variation to the direction, maintaining the same start point (the end of the barrel)
    but adjusting the end point of each trace to mimic the spread of the shot exiting
    the barrel
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制这个，我们只需增加我们执行的跟踪数量，并添加方向的变化，保持相同的起点（枪管末端）但调整每个跟踪的终点以模仿从枪管中射出的弹丸的散布。
- en: Let’s get started by using multiple traces to replicate the shotgun shell’s
    behavior.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用多个跟踪来复制霰弹枪弹壳的行为。
- en: Adding a for loop to fire multiple pellets
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加循环以发射多个弹丸
- en: To perform multiple line traces, we need to add a `For Loop` as the first node
    in the **Event Process Firing** logic chain, connecting the **Line Trace By Channel**,
    **Branch** and **Apply Damage** nodes into the **Loop Body**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行多次线迹追踪，我们需要在**事件处理发射**逻辑链中的第一个节点添加一个“循环”，将**按通道线迹追踪**、**分支**和**应用伤害**节点连接到**循环体**。
- en: The **For Loop** node will complete each of the steps in the *Loop Body*, incrementing
    its index from the **First Index** value to the **Last** **Index** value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**节点将完成*循环体*中的每个步骤，其索引从**第一个索引**值递增到**最后一个**索引值。'
- en: For the shotgun, set `1`. Typically, we would use `0`, however we are going
    to create an integer variable called `NumberOfPellets` for the `5`. If we were
    to keep **First Index** at zero, the shotgun would fire six pellets, so instead
    of requiring a designer to remember to reduce the variable by 1 to get their desired
    number of traces, we simply start at 1 to make the system more user friendly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于霰弹枪，设置为`1`。通常我们会使用`0`，但是我们将为`5`创建一个名为`NumberOfPellets`的整型变量。如果我们保持**第一个索引**为零，霰弹枪将发射六个弹丸，所以我们不需要设计师记住将变量减1以获得他们想要的追踪数量，我们只需从1开始，使系统更易于用户使用。
- en: '![Figure 9.7: The For Loop node and Number Of Pellets variable](img/Figure_09.07_B18297.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7：循环节点和NumberOfPellets变量](img/Figure_09.07_B18297.jpg)'
- en: 'Figure 9.7: The For Loop node and Number Of Pellets variable'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：循环节点和NumberOfPellets变量
- en: With multiple traces firing, we now need to make each trace slightly different
    so that we aren’t just doing multiple identical traces. Let’s do that next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在发射多个轨迹后，我们现在需要使每个轨迹略有不同，这样我们就不只是进行多次相同的轨迹。让我们接下来做那个。
- en: Adding spread to the pellet trajectories
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为弹丸轨迹添加扩散
- en: To add variation to the **End** vector input of the **Line Trace By Channel**
    node, we need to rotate the result of the **Get Forward Vector** node slightly
    before multiplying it by the range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要为**按通道线迹追踪**节点的**结束向量输入**添加变化，我们需要在将其乘以范围之前，稍微旋转**获取前向向量**节点的结果。
- en: To do this, we add a `Random Unit Vector in Cone in Degrees` node. This uses
    a **Cone Dir** input (the initial direction the cone is facing) and a **Cone Half
    Angle in Degrees** input (the amount of rotation to be applied from the center
    line of the cone).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要添加一个“圆锥内随机单位向量（以度为单位）”节点。这个节点使用一个**圆锥方向**输入（圆锥初始面对的方向）和一个**圆锥半角（以度为单位）**输入（从圆锥中心线应用旋转的量）。
- en: For **Cone Dir**, we connect in the **Return Value** of the **Get Forward**
    **Vector** node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**圆锥方向**，我们将它连接到**获取前向向量**节点的**返回值**。
- en: For `HalfSpreadDegrees.`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`HalfSpreadDegrees.`。
- en: Set the `15`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`15`。
- en: '![Figure 9.8: The adjusted firing trajectories](img/Figure_09.08_B18297.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8：调整后的发射轨迹](img/Figure_09.08_B18297.jpg)'
- en: 'Figure 9.8: The adjusted firing trajectories'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：调整后的发射轨迹
- en: Once you’ve added the **Random Unit Vector in Cone in Degrees** node, the calculations
    should be connected together as shown in *Figure 9**.8* with the vector connections
    going into the **Line Trace By** **Channel** node.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了“圆锥内随机单位向量（以度为单位）”节点，计算应该像*图 9.8*中所示那样连接在一起，向量连接进入**按通道线迹追踪**节点。
- en: With all that now set up, you are ready to test the shotgun. Change the variable
    once more on the Elite Unit in the level and give it a go.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都设置好了，你就可以测试霰弹枪了。在关卡中的精英单位上再次更改变量，然后尝试一下。
- en: Once that’s all finished and working, let’s move on to another parent-child
    structural pattern where everything is the exact opposite.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成并正常工作后，让我们继续到另一个父-子结构模式，其中一切都是完全相反的。
- en: Understanding subclass sandbox
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解子类沙盒
- en: 'The Subclass Sandbox pattern takes the idea of the template’s limited extension
    through subclasses (to provide security) and applies it the exact opposite way
    round. Here, the children define the order of execution for a set of pre-defined
    code blocks through an abstract spine function. These blocks take the form of
    functions that are defined in the parent class and can never be overridden. Each
    function deals with one thing to do with an external system in a standardized
    way. The following pseudocode makes a better visual point of how this is literally
    the opposite of the template pattern we explored previously, where everything
    previously marked as abstract gets functionality and the one function we had code
    in is now abstract:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 子类沙盒模式借鉴了模板通过子类（为了提供安全性）进行有限扩展的想法，并将其完全相反地应用。在这里，子类通过一个抽象的脊函数定义了一组预定义代码块的执行顺序。这些块的形式是定义在父类中的函数，并且永远不能被覆盖。每个函数都以标准化的方式处理与外部系统相关的一件事。以下伪代码更好地说明了这实际上是之前我们探索的模板模式的相反，其中之前标记为抽象的每一件事都获得了功能，而我们之前有代码的函数现在变成了抽象的：
- en: Subclass sandbox pattern parent pseudocode
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 子类沙盒模式父类伪代码
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The workflow for this pattern starts with the programmer building black-box
    tools for the technical designer to string together in interesting ways. This
    can lead to interesting innovation as the programmer isn’t making tools to specification,
    rather just for the sake of having tools, which leaves their application open
    for the technical designer to interpret. The flip side of this is that there could
    be a lot of wastage where tools either don’t get used or they are used in ways
    they could be better designed for. Thus, this process works better as an iteration
    on both sides to ensure that the toolset is useful and efficient, as well as actually
    being used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的流程从程序员为技术设计师构建黑盒工具开始，技术设计师可以将这些工具以有趣的方式连接起来。这可能导致有趣的创新，因为程序员并不是根据规格制作工具，而是仅仅为了拥有工具，这留下了它们的应用由技术设计师解释的空间。另一方面，可能会有很多浪费，因为工具要么没有被使用，要么是以它们本可以设计得更好的方式被使用的。因此，这个过程作为双方的迭代工作会更好，以确保工具集是有用且高效的，并且实际上被使用。
- en: 'Enough speaking in the abstract: let’s look at the implementation of this for
    our weapons alongside the template pattern.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 足够在抽象层面讨论了：让我们看看我们武器与模板模式一起的实现。
- en: Building the sandbox (parent class)
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建沙盒（父类）
- en: The first step is to copy what we did in the template section and make another
    C++ child of our `Weapon_Base` class, but this time call it `SandboxWeapon_Base`.
    The whole point of this pattern is that the Blueprint children will implement
    the `Fire` function in whatever way they see fit, but for that we would have to
    add `UFUNCTION(BlueprintNativeEvent)` at the very least. However, because we have
    joined our patterns together with this common parent, it means the function has
    to be marked as virtual and so cannot have a standard function specifier. This
    will never be the case in any production code. It is only a problem here due to
    us showing both patterns linked by a common parent. Our solution for this is a
    second `Fire` function called `SandboxFire`. We will pass the execution off to
    this function within `Fire` so that everything behaves as normal. No sensible
    project architecture would implement both patterns side by side like this, so
    it should not be an issue in your future projects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是复制模板部分中我们所做的操作，并为我们的 `Weapon_Base` 类创建另一个 C++ 子类，但这次将其命名为 `SandboxWeapon_Base`。这种模式的整个目的在于，蓝图子类将以他们认为合适的方式实现
    `Fire` 函数，但为了做到这一点，我们至少需要在其中添加 `UFUNCTION(BlueprintNativeEvent)`。然而，因为我们已经通过这个共同的父类将我们的模式组合在一起，这意味着函数必须被标记为虚拟的，因此不能有标准函数指定符。这种情况在任何生产代码中都不会发生。这仅仅是因为我们展示了通过共同父类链接的两个模式。我们为此提出的解决方案是第二个
    `Fire` 函数，称为 `SandboxFire`。我们将在 `Fire` 函数内部将执行权传递给这个函数，以便一切行为都保持正常。任何合理的项目架构都不会像这样并排实现两种模式，所以这不应该成为你未来项目中的问题。
- en: The other thing we must define are the building block functions, which we have
    chosen to keep similar to the previous example, but for which you can make as
    many as you deem necessary. The key is to keep each function short and to the
    point as their purpose is to standardize the method for interacting with external
    systems so that future changes are easily maintained. The most important aspect
    of the functions laid out in the following code are that they are protected and
    marked as `BlueprintCallable`. This means they are just for children of this class
    to use, not override, and also ensures they have no external access.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义的另一件事是构建块函数，我们选择将其与之前的示例保持相似，但你可以根据需要创建尽可能多的函数。关键是保持每个函数简短且直接，因为它们的目的在于标准化与外部系统交互的方法，以便未来的更改易于维护。以下代码中函数最重要的方面是它们被保护并标记为`BlueprintCallable`。这意味着它们仅供此类子类使用，不能被覆盖，同时也确保它们没有外部访问权限。
- en: 'Lets start with the base class for the sandbox weapon:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从沙盒武器的基类开始：
- en: SandboxWeapon_Base.h excerpt
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SandboxWeapon_Base.h摘录
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the header declared, we can turn to the definitions in the following implementation.
    Our `Fire` function override simply calls `SandboxFire()` to pass the signal through
    to a function with the correct properties. As `SandboxFire` is marked as `BlueprintImplementableEvent`
    it doesn’t have a definition in this class and instead can be completely left
    to the Blueprint children to define. Our `Reload`, `CheckAmmo`, and `UpdateAmmo`
    functions are basically the same as before, but this is dependent on the systems
    that are being hooked into and where it is best to build lots of small specific
    functions. `PlaySound` is a more specific version of `PlayEffects` from before,
    where we were able to leave the implementation to the designer, but now we must
    be specific in function name and use:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了头文件后，我们可以转向以下实现中的定义。我们的`Fire`函数覆盖只是调用`SandboxFire()`将信号传递到具有正确属性的函数。由于`SandboxFire`被标记为`BlueprintImplementableEvent`，它在此类中没有定义，而是完全由蓝图子类来定义。我们的`Reload`、`CheckAmmo`和`UpdateAmmo`函数基本上与之前相同，但这取决于被连接的系统以及在哪里构建大量的小特定函数。`PlaySound`是之前`PlayEffects`的一个更具体版本，当时我们可以将实现留给设计师，但现在我们必须在函数名称和使用上具体指定：
- en: SandboxWeapon_Base.cpp simple function definitions
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SandboxWeapon_Base.cpp简单函数定义
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the topic of being specific, we now have a `LinetraceOneShot` function in
    place of the `ProcessFiring` function from before. While the utility of this,
    specifying that it is one shot, will become apparent later, this function is one
    of many ways to handle the gameplay logic of the gun firing. It acts as a wrapper
    for the line trace function working off a direction vector the user must pass
    in. This then applies damage to whatever it has hit through the standard Unreal
    method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体性的话题上，我们现在有一个`LinetraceOneShot`函数替代了之前的`ProcessFiring`函数。虽然这种实用性的，指定它是一次性射击，将在以后变得明显，但这个函数是处理枪支射击游戏逻辑的多种方式之一。它作为一个包装器，使用用户必须传入的方向向量调用线迹函数。然后通过标准的Unreal方法对它击中的任何东西施加伤害：
- en: 'We can now add that to the sandbox weapon:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将此添加到沙盒武器中：
- en: SandboxWeapon_Base.cpp LinetraceOneShot function definition
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SandboxWeapon_Base.cpp LinetraceOneShot函数定义
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that our sandbox base is kitted out with a basic suite of tools; we can
    make the Blueprint child weapons equivalent to the template pattern by using the
    Sandbox_Fire function. Comparing the Blueprint implementations of each pattern
    should show a lot of the differences in approach and how each can be used for
    the same system with differing approaches.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为沙盒基类配备了基本工具套件；我们可以通过使用Sandbox_Fire函数使蓝图子武器与模板模式等效。比较每个模式的蓝图实现应该会显示出很多方法上的差异以及它们如何以不同的方法用于同一系统。
- en: Creating child classes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子类
- en: Just like with the template pattern, we are going to create two child classes
    of the Sandbox Weapon Base in a Blueprint. To do this, we follow the same steps
    except when searching in the `sandbox` and select `BP_SandboxPistol` and `BP_SandboxShotgun`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像与模板模式一样，我们将在蓝图中创建沙盒武器基类的两个子类。为此，我们遵循相同的步骤，只是在搜索`sandbox`时选择`BP_SandboxPistol`和`BP_SandboxShotgun`。
- en: With those created we can move on to setting them up. Unlike with the template
    pattern, we don’t need to create the functional behaviors. Instead, we determine
    the order (and reuse) of the functions in the parent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，我们可以继续设置它们。与模板模式不同，我们不需要创建功能行为。相反，我们确定父类中函数的顺序（和重用）。
- en: Sandbox pistol
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sandbox手枪
- en: 'Once again, we begin with the pistol as this is probably the simplest weapon
    type to implement. First, we do all of our checks to make sure the weapon can
    fire, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从手枪开始，因为这可能是最简单的武器类型来实现。首先，我们进行所有检查以确保武器可以射击，如下所示：
- en: Override **Sandbox Fire Function** using the **Override** list.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**覆盖**列表覆盖**Sandbox射击函数**。
- en: Add a `Branch` based on the `CanFire` Boolean.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据布尔值`CanFire`添加一个**分支**。
- en: From the `Check Ammo` and add a second `Branch` based on the **Return Value**
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“检查弹药”中添加一个基于**返回值**的第二个**分支**。
- en: '![Figure 9.9: The start of the Sandbox Fire Event](img/Figure_09.09_B18297.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9：Sandbox射击事件的开始](img/Figure_09.09_B18297.jpg)'
- en: 'Figure 9.9: The start of the Sandbox Fire Event'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：Sandbox射击事件的开始
- en: 'Next, we’ll add the logic to the **False** output from the **Branch** node,
    calling **Reload** and playing a sound (sounds haven’t been implemented in the
    parent class as that is something that will typically be different per weapon):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向**分支**节点的**False**输出添加逻辑，调用**重新装填**并播放声音（声音尚未在父类中实现，因为这通常是针对每种武器都不同的）：
- en: Call the `Reload` function.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Reload`函数。
- en: Add a `Play Sound` node, selecting the **Gizmo_Handle_Clicked** sound from the
    dropdown.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“播放声音”节点，从下拉菜单中选择**Gizmo_Handle_Clicked**声音。
- en: '![Figure 9.10: The false logic for the Sandbox Fire Event](img/Figure_09.10_B18297.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10：Sandbox射击事件的False逻辑](img/Figure_09.10_B18297.jpg)'
- en: 'Figure 9.10: The false logic for the Sandbox Fire Event'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：Sandbox射击事件的False逻辑
- en: 'Lastly, we can add the True logic, which essentially fires the weapon. As the
    functional behavior already exists in the parent, we simply need to call the functions
    and provide the required inputs. We’re going to do this in two chunks. The first
    will play a sound before performing the line trace and updating the ammo. The
    second chunk will use a timer to call the function to manage the rate of fire:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加True逻辑，这实际上会发射武器。由于功能行为已经在父类中存在，我们只需调用函数并提供所需的输入。我们将分两步进行。第一步将在执行线迹和更新弹药之前播放声音。第二步将使用计时器来调用管理射速的函数：
- en: Add a `Play Sound` node, selecting the `VR_Teleport` sound once again.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“播放声音”节点，再次选择`VR_Teleport`声音。
- en: Call the `Linetrace One Shot` function, providing it with the `Forward Vector`
    of the **Fire** **Point** component.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Linetrace One Shot`函数，向其提供**射击点**组件的**前进向量**。
- en: Call `Update Ammo`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Update Ammo`。
- en: '![Figure 9.11: The start of the true logic that fires the sandbox pistol](img/Figure_09.11_B18297.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11：Sandbox手枪射击逻辑的开始](img/Figure_09.11_B18297.jpg)'
- en: 'Figure 9.11: The start of the true logic that fires the sandbox pistol'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：Sandbox手枪射击逻辑的开始
- en: Add a `Set Timer by Function` `Name` node.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“通过函数设置计时器”的节点。
- en: Type `Handle_FireDelay` in for **Function Name**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**函数名称**中输入`Handle_FireDelay`。
- en: Divide `1` by the **RoF** float variable and connect it to the **Time** pin
    of the **Set Timer by Function** **Name** node.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`1`除以**RoF**浮点变量，并将其连接到**设置计时器通过函数名称**节点的**时间**引脚。
- en: Promote the `TimerFireDelay`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提升`TimerFireDelay`。
- en: '![Figure 9.12: The Hand_FireDelay timer added to the end of the chain](img/Figure_09.12_B18297.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12：将Hand_FireDelay计时器添加到链的末尾](img/Figure_09.12_B18297.jpg)'
- en: 'Figure 9.12: The Hand_FireDelay timer added to the end of the chain'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：将Hand_FireDelay计时器添加到链的末尾
- en: With the pistol complete, test it the same as we did with the two template weapons
    and then we can move on to implementing the shotgun using the Sandbox pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完成手枪后，像我们处理两个模板武器一样测试它，然后我们可以继续使用Sandbox模式实现霰弹枪。
- en: Sandbox shotgun
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sandbox霰弹枪
- en: 'The shotgun follows much of the same setup as the pistol except for where we
    once again need to complete multiple line traces. The parent has a single line
    trace that requires a forward vector input. So, just like in the template example,
    we will use a **For Loop** and once again utilize the **Random Unit Vector in
    Cone in Degrees** node when providing the forward vector input to the **Linetrace
    One** **Shot** function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 霰弹枪的设置与手枪类似，除了我们再次需要完成多个线迹的地方。父类有一个需要前进向量输入的单个线迹。所以，就像在模板示例中一样，我们将使用**循环**，并再次在向**Linetrace
    One Shot**函数提供前进向量输入时使用**在圆锥内随机单位向量（以度为单位**）节点：
- en: Start by copying the logic from the pistol. This just saves us a little bit
    of time.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从手枪复制逻辑。这可以为我们节省一点时间。
- en: Disconnect both sides of the **Linetrace One Shot** node by holding down *Alt*
    and clicking on the pins.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Alt*并点击引脚来断开**Linetrace One Shot**节点的两侧。
- en: Add in a `For Each` loop just as we did in the template shotgun, connecting
    it after the `True` logic and once again using the `Number of Pellets` integer
    variable.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`For Each`循环，就像我们在模板霰弹枪中做的那样，连接在`True`逻辑之后，并再次使用`Number of Pellets`整数变量。
- en: For the **Direction** vector input on the **Linetrace One Shot** node, set up
    **Random Unit Vector in Cone in Degrees** in the same way we did for the template
    shotgun, as shown in *Figure 9**.13*
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Linetrace One Shot**节点上的**方向**向量输入，以与模板霰弹枪相同的方式设置**锥形内的随机单位向量（以度为单位**），如图*图9.13*所示。
- en: "![Figure 9.13: The For Loop’s Loop Body logic for \uFEFFthe BP_SandboxShotgun](img/Figure_09.13_B18297.jpg)"
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13：BP_SandboxShotgun的For循环循环体逻辑](img/Figure_09.13_B18297.jpg)'
- en: 'Figure 9.13: The For Loop’s Loop Body logic for the BP_SandboxShotgun'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：BP_SandboxShotgun的For循环循环体逻辑
- en: Now we have the multiple line traces happening, we need to add back in the rest
    of the firing chain, that is, the Update Ammo function and Fire Delay Timer. Since
    these steps need to be done after we fire, they need to be connected to the **Completed**
    pin on the **For Loop** node, not part of the **Loop Body.**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了多行跟踪发生，我们需要添加回剩余的射击链，即更新弹药函数和射击延迟计时器。由于这些步骤需要在射击后完成，因此它们需要连接到**For循环**节点上的**完成**引脚，而不是**循环体**的一部分。
- en: Move the nodes from the previous steps around to make a clear path for the connection
    from the **Completed** pin and connect the other nodes back in, as shown in *Figure
    9**.14*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一步骤中的节点移动，为从**完成**引脚的连接创建一个清晰的路径，并将其他节点重新连接，如图*图9.14*所示。
- en: '![Figure 9.14: The Update Ammo and Timer connected to the Completed pin](img/Figure_09.14_B18297.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14：更新弹药和计时器连接到完成引脚](img/Figure_09.14_B18297.jpg)'
- en: 'Figure 9.14: The Update Ammo and Timer connected to the Completed pin'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：更新弹药和计时器连接到完成引脚
- en: As before, test this out by selecting the weapon on the Elite Unit in the level.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，通过在关卡中选择精英单位的武器来测试这一点。
- en: Provided everything works as it should, we can then move on to exploring the
    type object pattern, which allows us to easily expand the content available in
    a game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，我们就可以继续探索类型对象模式，它允许我们轻松扩展游戏中的内容。
- en: Type object pattern
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型对象模式
- en: 'If you need a fast way of creating many variants of something in your game
    as a form of expanding the content available to players, then the type object
    pattern is for you. Type object takes the ideas of implicit and explicit data
    we covered as part of the flyweight pattern back in [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046)
    and expands it into the world of gameplay. The principle is the same: we separate
    out all data that is common across all instances of a type, but instead of just
    linking to it from everywhere, we mix it up and produce lots of variations of
    this data. The result is a connected web of objects that all have the same functionality
    but vary in which set of implicit data they use.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一种快速创建游戏中的许多变体以扩展玩家可用的内容的方式，那么类型对象模式就是为你准备的。类型对象模式将我们在第3章中作为享元模式的一部分所讨论的隐式和显式数据的思想带回到游戏世界中。原则是相同的：我们将所有类型的实例中通用的所有数据分离出来，但不是仅仅从每个地方链接到它，而是混合它并产生大量这种数据的变体。结果是，一个相互连接的对象网络，所有对象都具有相同的功能，但在它们使用的隐式数据集方面有所不同。
- en: "![Figure 9.15: Diagram from Chapter 3 where we discussed the \uFEFFFlyweight\
    \ pattern](img/Figure_09.15_B18297.jpg)"
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15：第3章中的图，我们讨论了享元模式](img/Figure_09.15_B18297.jpg)'
- en: 'Figure 9.15: Diagram from [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046) where
    we discussed the Flyweight pattern'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：第3章中讨论的享元模式的图，[第3章](B18297_03.xhtml#_idTextAnchor046)
- en: '*Figure 9**.15* shows the Flyweight pattern saving space by storing implicit
    data about the idea of a tree in one place in memory.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.15*显示了享元模式通过在内存中的一个地方存储关于树的概念的隐式数据来节省空间。'
- en: "![Figure 9.16: Diagram showing the expansion of the \uFEFFFlyweight pattern\
    \ provided by the \uFEFF\uFEFFtype \uFEFF\uFEFFobject pattern](img/Figure_09.16_B18297.jpg)"
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16：显示享元模式扩展的图，该扩展由类型对象模式提供](img/Figure_09.16_B18297.jpg)'
- en: 'Figure 9.16: Diagram showing the expansion of the Flyweight pattern provided
    by the type object pattern'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：显示类型对象模式提供的享元模式扩展的图
- en: Expanding the pattern from Flyweight to type object in *Figure 9**.16*, we define
    more types as different sets of the implicit data. This diagram makes it clear
    the cost of this added expandability will be memory. Now only objects sharing
    a type can be batched together, so the number of batch calls increases but we
    are still way beyond defining every tree explicitly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在图9.16中，从Flyweight模式扩展到类型对象，我们定义了更多类型作为隐式数据的不同集合。这个图表清楚地表明，这种增加的可扩展性将带来内存成本。现在只有共享相同类型的对象才能一起批量处理，因此批量调用次数增加，但我们仍然远远超出了显式定义每个树的需求。
- en: This is not the only way of achieving this outcome though. We could keep our
    Flyweight pattern and make a new class for each of our types. That would work,
    so why don’t we do that? Because code takes up space. In the next chapter, we’ll
    cover the idea of data locality, it builds on the knowledge that instructions
    in code, such as values we manipulate, take up space in memory. Duplicating a
    class also duplicates the code that needs to be stored to run, not to mention
    the overhead cost of defining and storing a new class. Our aim is to make an elegant
    solution that streamlines the content creation process and increases efficiency.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是实现这一结果的唯一方法。我们本可以保持我们的Flyweight模式，并为每种类型创建一个新的类。这也可以工作，那么我们为什么不这样做呢？因为代码占用空间。在下一章中，我们将介绍数据局部性的概念，它建立在代码中的指令（如我们操作的价值）在内存中占用的知识之上。复制一个类也会复制需要存储以运行代码，更不用说定义和存储新类所带来的开销。我们的目标是提供一个优雅的解决方案，简化内容创作过程并提高效率。
- en: To make the type object pattern work in Unreal, we need to store a collection
    of data as an asset that can be loaded into the RAM at runtime for referencing.
    This could be achieved with writing text files or some other structured file format
    like JSON or XML. The problem there is that designers need to have the data files
    open in a separate text editor to make changes, and the process of saving and
    reloading the editor preview can become tedious when many small changes are made
    iteratively. Thankfully, Unreal Engine gives us a few options of built-in structures
    we can use. We will be looking at Variants and the Variant Manager, Data Assets,
    and Data Tables. There are undoubtedly more ways to make this work but these three
    should cover most of the general implementations of the type object pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚幻引擎中实现类型对象模式，我们需要将数据集合存储为一个资产，以便在运行时将其加载到RAM中进行引用。这可以通过编写文本文件或一些其他结构化文件格式如JSON或XML来实现。问题在于设计师需要在一个单独的文本编辑器中打开数据文件来做出更改，当进行多次迭代的小改动时，保存和重新加载编辑器预览的过程可能会变得繁琐。幸运的是，虚幻引擎为我们提供了一些内置结构的选择。我们将探讨变体和变体管理器、数据资产和数据表。毫无疑问，还有更多实现这一功能的方法，但这三个应该涵盖了类型对象模式的大多数通用实现。
- en: Variants
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变体
- en: The **Variant Manager** is a tool within Unreal Engine that allows us to create
    multiple swapable Variants of actors in a level. The Variants store values for
    Actor properties and can also call functions from within the actor when the Variant
    is selected.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**变体管理器**是虚幻引擎中的一个工具，允许我们在级别中创建多个可交换的变体。变体存储了演员属性值，并且在选择变体时还可以从演员内部调用函数。'
- en: The Variants are held within the level by a **Level Variant Sets Actor**, which
    links to a **Level Variant Sets** asset where the various actors, their properties
    to change, and the functions within them to call, are all stored.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 变体由**级别变体集演员**在级别中持有，该演员链接到一个**级别变体集**资产，其中存储了各种演员、它们要更改的属性以及它们内部要调用的函数。
- en: Variants are activated either via the **Variant Manager Panel** while in the
    editor (as shown in *Figure 9**.17*) or via Blueprint functions at runtime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 变体可以通过在编辑器中通过**变体管理器面板**（如图9.17所示）或在运行时通过蓝图函数激活。
- en: '![Figure 9.17 The Variant Manager panel](img/Figure_09.17_B18297.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 变体管理器面板](img/Figure_09.17_B18297.jpg)'
- en: Figure 9.17 The Variant Manager panel
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 变体管理器面板
- en: Variants and the Variant Manager are more commonly used in interactive experiences
    such as architectural visualization projects or product-based applications such
    as car configurators.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 变体和变体管理器在交互式体验中更为常用，例如建筑可视化项目或基于产品的应用程序，如汽车配置器。
- en: The Variant Manager approach could be used for a character creation screen like
    those seen in RPG-type games such as World of Warcraft or Cyberpunk 2077, or the
    modular character/vehicle setup systems in games such as Fortnite, Fall Guys,
    or Rocket League, where the player can select different parts to be added to their
    character.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 变体管理器方法可以用于角色创建屏幕，就像在《魔兽世界》或《赛博朋克2077》这样的RPG游戏中看到的，或者像《堡垒之夜》、《疯狂原始人》或《火箭联盟》这样的游戏中的模块化角色/车辆设置系统，玩家可以选择添加到角色中的不同部件。
- en: The drawback with the Variant Manager approach for ever-expanding games such
    as Fortnite or Fall Guys is the time required to create variants and fully set
    them up. An in-game character customization system would be much more suited to
    using a data table approach, where additional data can quickly be added in a table
    editor or imported from a spreadsheet. Let’s take a look at this next.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像《堡垒之夜》或《疯狂原始人》这样不断扩展的游戏，使用变体管理器方法的一个缺点是需要花费大量时间来创建变体并完全设置它们。一个游戏内的角色定制系统更适合使用数据表方法，其中可以通过表格编辑器快速添加额外数据，或者从电子表格中导入。让我们看看下一个例子。
- en: Data Tables
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据表
- en: Data Tables are an asset type created for the purpose of storing values with
    no functionality. We define them in our project with a struct, each member becoming
    a column in the table. Each row of the table then represents a set of values we
    call a type to fit in with our pattern. Data Tables are designed for large-scale
    storage of data in one place to be queried when necessary. They can store values
    pointing to other assets, but these are cumbersome to work with in this form and
    are generally avoided in favor of storing everything as primitive types. This
    soft limit of primitive data means that, although possible, working with nested
    information is advised against. This could affect systems where one customization
    affects what is available in a level below.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表是为了存储没有功能性的值而创建的资产类型。我们在项目中使用结构体定义它们，每个成员成为表中的一列。表中的每一行代表一组我们称为类型的值，以适应我们的模式。数据表旨在在一个地方存储大量数据，以便在需要时查询。它们可以存储指向其他资产的值，但以这种形式工作起来很麻烦，通常避免使用，而是将所有内容存储为原始类型。这种原始数据的软限制意味着，尽管可能，建议不要使用嵌套信息。这可能会影响一个定制影响下一级可用的系统。
- en: The main benefit of this asset is its ability to import directly from a CSV
    or JSON file, making it the preferred method of balancing for designers with external
    tools. The flipside of this is because everything is stored together, even if
    you aren’t using all the types in a given scene, all the data will still be loaded
    into memory, making it less viable for high-level types and more applicable to
    utility-type patterns such as quest systems that are universal and always need
    to be loaded. There is also an argument for using Data Tables for language localization,
    as with all the types in one place, searches for specific records become way easier
    and faster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此资产的主要优点是能够直接从CSV或JSON文件导入，这使得它成为具有外部工具的设计师首选的平衡方法。另一方面，由于所有内容都存储在一起，即使你不在给定场景中使用所有类型，所有数据仍然会被加载到内存中，这使得它对于高级类型不太可行，更适用于通用型模式，如需要始终加载的寻宝系统等。还有人认为，使用数据表进行语言本地化也是有道理的，因为所有类型都在一个地方，搜索特定记录变得更容易、更快。
- en: '![Figure 9.18: Screenshot of an example Data Table with weapon balancing data](img/Figure_09.18_B18297.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18：示例数据表截图，包含武器平衡数据](img/Figure_09.18_B18297.jpg)'
- en: 'Figure 9.18: Screenshot of an example Data Table with weapon balancing data'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：示例数据表截图，包含武器平衡数据
- en: '*Figure 9**.18* shows a Data Table in use for balancing the different enemy
    types in a game where the only changes are stat values as the enemy rank increases.
    This could have been imported from an external balancing tool as all the values
    are primitive types.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.18* 展示了一个数据表的使用情况，用于平衡游戏中不同敌人的类型，唯一的变化是随着敌人等级的提升，统计数据值的变化。这些值可能已从外部平衡工具导入，因为所有值都是原始类型。'
- en: Data Assets
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据资产
- en: A Data Asset takes the idea of Data Tables and breaks it down into individual
    rows. Each row then becomes its own asset that can be created and managed via
    the editor. When we define a Data Asset it looks very much like a struct definition
    but on instancing it, we do not get a new item in the world. Instead, we get a
    new Data Asset instance in the project, similar to the way materials and material
    instances work. Once a Data Asset instance is referenced in active code, that
    instance is loaded into memory, just like a texture or static mech asset. Due
    to the editor being responsible for the creation and management of Data Assets,
    they have easy tools for holding references to other assets. This makes them useful
    for defining type data for high-level class specialization. They also deal with
    nested information well, as if it has been serialized properly, the editor has
    space to show the drop-down menus where sub-values can be manipulated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 数据资产将数据表的概念分解成单独的行。然后，每一行都成为它自己的资产，可以通过编辑器创建和管理。当我们定义数据资产时，它看起来非常像结构定义，但在实例化时，我们不会在世界上获得一个新的项目。相反，我们在项目中获得一个新的数据资产实例，这与材料和材料实例的工作方式类似。一旦数据资产实例在活动代码中被引用，该实例就会被加载到内存中，就像纹理或静态机械资产一样。由于编辑器负责数据资产的创作和管理，它们有易于使用其他资产引用的工具。这使得它们对于定义高级类特殊化的类型数据非常有用。它们还很好地处理嵌套信息，如果它们被正确序列化，编辑器就有空间显示下拉菜单，以便可以操作子值。
- en: 'The best way to explain how to use Data Assets for a type object pattern is
    to make something with them. So, let’s turn our attention back to the project
    we have been working on through this chapter to implement some Data Assets:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何使用数据资产为类型对象模式的最佳方式是利用它们制作一些东西。所以，让我们把注意力转回到我们通过本章一直在工作的项目上，以实现一些数据资产：
- en: Start by defining a new type of Data Asset by right-clicking in the C++ folder.
    Make sure to do this from the editor as there are no templates available within
    Rider, meaning you’ll have to make a lot of unnecessary changes.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在C++文件夹中右键单击来定义一个新的数据资产类型。确保从编辑器中这样做，因为在Rider中没有模板可用，这意味着你将不得不进行很多不必要的更改。
- en: When selecting the base class to inherit from, choose **UDataAsset** from the
    **All** **Classes** menu.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择要继承的基类时，从**所有****类**菜单中选择**UDataAsset**。
- en: Then give it a name. We have called ours `EnemyType`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后给它起个名字。我们把它叫做`EnemyType`。
- en: '![Figure 9.19: Class creation menu setup to make a new Data Asset](img/Figure_09.19_B18297.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19：创建新数据资产的类创建菜单设置](img/Figure_09.19_B18297.jpg)'
- en: 'Figure 9.19: Class creation menu setup to make a new Data Asset'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：创建新数据资产的类创建菜单设置
- en: 'Next, we consider what data we need to store inside the asset. There could
    be any number of things we want to vary between different enemy types. The key
    is to make sure you only store data specifically about the enemy here, and not
    the other classes that could be different within the enemy class, such as the
    weapon fire rate. Weapons would need another parallel implementation of the type
    object pattern, which could even be nested within this one with the weapon type
    defined within the enemy type:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑需要在资产内部存储哪些数据。我们可能想要在不同敌人类型之间变化的东西有很多。关键是确保你只在这里存储关于敌人的特定数据，而不是敌人类中可能不同的其他类，例如武器射速。武器将需要另一个并行实现类型对象模式，这甚至可以嵌套在这个模式中，武器类型在敌人类型中定义：
- en: Give the class the `BlueprintType` property in the `UCLASS` block.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UCLASS`块中给这个类添加`BlueprintType`属性。
- en: We are only changing the health and materials on the enemy with its type, so
    add a float for health and a couple of object pointers to the `UmaterialInstance`
    variables.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只更改敌人的类型和材料，所以添加一个用于健康的浮点数和几个指向`UmaterialInstance`变量的对象指针。
- en: 'Make sure each variable has the `EditAnywhere` and `BlueprintReadWrite` property
    specifiers, and we are all done with the C++ side:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保每个变量都有`EditAnywhere`和`BlueprintReadWrite`属性指定符，这样我们就完成了C++方面的所有工作：
- en: EnemyType.h exerpt
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: EnemyType.h 摘录
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to define some Data Assets from the template we have just
    created:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从我们刚刚创建的模板中定义一些数据资产：
- en: Build back into the editor and right-click on the **RTS/Data** folder.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建回编辑器，并在**RTS/Data**文件夹上右键单击。
- en: Select **Miscellaneous** > **Data Asset**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**杂项**>**数据资产**。
- en: '![Figure 9.20: The Data Asset option is in the right-click menu](img/Figure_09.20_B18297.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20：数据资产选项在右键菜单中](img/Figure_09.20_B18297.jpg)'
- en: 'Figure 9.20: The Data Asset option is in the right-click menu'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：数据资产选项在右键菜单中
- en: Select **EnemyType** from the list of classes to be the parent.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从待选类列表中选择 **EnemyType** 作为父类。
- en: Give the new asset a name that represents the type we are making (we have gone
    with `Enemy_Basic`) and then open it up.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新资产起一个代表我们正在制作的类型的名字（我们选择了 `Enemy_Basic`），然后打开它。
- en: Set the health value to `100` and select **MI_EnemyUnit_01** and **MI_EnemyUnit_02**
    for the material slots.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将健康值设置为 `100` 并选择用于材质槽的 **MI_EnemyUnit_01** 和 **MI_EnemyUnit_02**。
- en: 'The last step is to apply these values to the unit on spawn:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在单位生成时应用这些值：
- en: Open **BP_EnemyUnit**, found in the **RTS/Blueprints** folder.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 **RTS/Blueprints** 文件夹中的 **BP_EnemyUnit**。
- en: Add a new variable of type **EnemyType** and make it editable by clicking the
    eye icon, as shown in *Figure 9**.21*. Then set its default value to **Enemy_Basic**.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 **EnemyType** 类型的变量，并通过点击眼睛图标使其可编辑，如图 *图 9.21* 所示。然后将其默认值设置为 **Enemy_Basic**。
- en: '![Figure 9.21: The BP_EnemyUnit variables](img/Figure_09.21_B18297.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21：BP_EnemyUnit 变量](img/Figure_09.21_B18297.jpg)'
- en: 'Figure 9.21: The BP_EnemyUnit variables'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21：BP_EnemyUnit 变量
- en: Add a **BeginPlay** event node to the event graph.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中添加一个 **BeginPlay** 事件节点。
- en: Check whether the new **TypeData** variable has a value.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新的 **TypeData** 变量是否有值。
- en: Then place each value from the **TypeData** variable into its relevant place
    as shown in *Figure 9**.22*.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将 **TypeData** 变量中的每个值放入如图 *图 9.22* 所示的相关位置。
- en: '![Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data](img/Figure_09.22_B18297.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 展示 BP_EnemyUnit 事件图应用类型数据截图](img/Figure_09.22_B18297.jpg)'
- en: Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 展示 BP_EnemyUnit 事件图应用类型数据截图
- en: Doing all this should make nothing appear or behave differently, but it does
    now give us the flexibility to define new types of enemy with different materials
    in the Content Browser. We can then set spawned enemies to be different types
    using the editable variable. As an extension to this, see if you can define a
    new enemy type with 200 health that uses the B versions of the material instances
    we used for the basic type. These can be found in the same folder as the materials
    we were using before but are tinted blue. Another extension you could try is to
    set the type variable to expose on spawn and dynamically spawn a few enemies in
    the level. This will allow you to set the type in the code, hopefully demonstrating
    the power of this system.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 做所有这些应该不会让任何东西出现或表现不同，但它现在让我们能够定义具有不同材质的新类型敌人，在内容浏览器中定义。然后我们可以使用可编辑的变量设置生成的敌人类型。作为这个的扩展，尝试定义一个新的敌人类型，其健康值为
    200，并使用我们为基本类型使用的材质实例的 B 版本。这些可以在与之前使用的材质相同的文件夹中找到，但被染成蓝色。另一个你可以尝试的扩展是设置类型变量在生成时暴露，并在级别中动态生成几个敌人。这将允许你在代码中设置类型，希望这能展示这个系统的强大功能。
- en: 'We’ve explored the ways in which the type object can be utilized in gameplay
    to facilitate large numbers of variants using three different approaches in Unreal
    Engine: Variants, Data Tables, and Data Assets. With the completion of our type
    object example, we have come to the end of our exploration of patterns that can
    be used to build structured solutions.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在 Unreal Engine 中利用类型对象在游戏玩法中的不同方法，以使用三种不同的方法来方便地实现大量变体：变体、数据表和数据资产。随着我们类型对象示例的完成，我们结束了对构建结构化解决方案可用模式的探索。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The three patterns we have covered in this chapter are the most widely used
    structural patterns. Use of the first two is a personal preference, as we saw
    they can both be used to achieve the same thing in different ways. Template and
    subclass sandbox are also being superseded by other techniques in modern code,
    such as interfaces and modular design, but understanding where they came from
    and the workflow they encourage is useful. Template and subclass Sandbox both
    highlight the need to constrain designers with limited access to ensure the maintainability
    of the codebase. The type object pattern, on the other hand, is one of the most
    useful patterns in game development with widespread application across all aspects
    of game design. Its utility in allowing artists, designers, and programmers to
    work together is invaluable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的三个模式是最广泛使用的结构模式。前两种模式的使用是个人偏好，正如我们所见，它们都可以以不同的方式实现相同的目标。模板和子类沙盒也被现代代码中的其他技术所取代，例如接口和模块化设计，但了解它们的起源和它们所鼓励的工作流程是有用的。模板和子类沙盒都强调了限制设计师访问权限以确保代码库的可维护性的必要性。另一方面，类型对象模式是游戏开发中最有用的模式之一，它在游戏设计的各个方面都有广泛的应用。它允许艺术家、设计师和程序员共同工作，其价值无可估量。
- en: In the next chapter, we will dive into a few patterns that we can apply once
    we have a working game to improve our performance using the concepts of object
    pooling, data locality, and dirty flags.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨一些模式，一旦我们有一个可工作的游戏，就可以通过对象池、数据局部性和脏标志等概念来提高我们的性能。
