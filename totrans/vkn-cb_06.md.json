["```cpp\nstd::vector<VkAttachmentDescription> attachments_descriptions = { \n  { \n    0, \n    VK_FORMAT_R8G8B8A8_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n  }, \n  { \n    0, \n    VK_FORMAT_D16_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, \n  } \n};\n\n```", "```cpp\nstruct SubpassParameters { \n  VkPipelineBindPoint                  PipelineType; \n  std::vector<VkAttachmentReference>   InputAttachments; \n  std::vector<VkAttachmentReference>   ColorAttachments; \n  std::vector<VkAttachmentReference>   ResolveAttachments; \n  VkAttachmentReference const        * DepthStencilAttachment; \n  std::vector<uint32_t>                PreserveAttachments; \n};\n\n```", "```cpp\nsubpass_descriptions.clear(); \n\nfor( auto & subpass_description : subpass_parameters ) { \n  subpass_descriptions.push_back( { \n    0, \n    subpass_description.PipelineType, \nstatic_cast<uint32_t>(subpass_description.InputAttachments.size()), \n    subpass_description.InputAttachments.data(), \n    static_cast<uint32_t>(subpass_description.ColorAttachments.size()), \n    subpass_description.ColorAttachments.data(), \n    subpass_description.ResolveAttachments.data(), \n    subpass_description.DepthStencilAttachment, \n    static_cast<uint32_t>(subpass_description.PreserveAttachments.size()), \n    subpass_description.PreserveAttachments.data() \n  } ); \n}\n\n```", "```cpp\nVkAttachmentReference depth_stencil_attachment = { \n  1, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, \n}; \n\nstd::vector<SubpassParameters> subpass_parameters = { \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL \n      } \n    }, \n    {}, \n    &depth_stencil_attachment, \n    {} \n  } \n};\n\n```", "```cpp\nstd::vector<VkSubpassDependency> subpass_dependencies = { \n  { \n    0, \n    1, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  } \n};\n\n```", "```cpp\nSpecifyAttachmentsDescriptions( attachments_descriptions ); \n\nstd::vector<VkSubpassDescription> subpass_descriptions; \nSpecifySubpassDescriptions( subpass_parameters, subpass_descriptions ); \n\nSpecifyDependenciesBetweenSubpasses( subpass_dependencies );\n\n```", "```cpp\nVkRenderPassCreateInfo render_pass_create_info = { \n  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(attachments_descriptions.size()), \n  attachments_descriptions.data(), \n  static_cast<uint32_t>(subpass_descriptions.size()), \n  subpass_descriptions.data(), \n  static_cast<uint32_t>(subpass_dependencies.size()), \n  subpass_dependencies.data() \n}; \n\nVkResult result = vkCreateRenderPass( logical_device, &render_pass_create_info, nullptr, &render_pass ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a render pass.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkFramebufferCreateInfo framebuffer_create_info = { \n  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, \n  nullptr, \n  0, \n  render_pass, \n  static_cast<uint32_t>(attachments.size()), \n  attachments.data(), \n  width, \n  height, \n  layers \n}; \n\nVkResult result = vkCreateFramebuffer( logical_device, &framebuffer_create_info, nullptr, &framebuffer ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a framebuffer.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstd::vector<VkAttachmentDescription> attachments_descriptions = { \n  { \n    0, \n    VK_FORMAT_R8G8B8A8_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, \n  }, \n  { \n    0, \n    VK_FORMAT_D16_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, \n  }, \n  { \n    0, \n    VK_FORMAT_R8G8B8A8_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n  }, \n};\n\n```", "```cpp\nVkAttachmentReference depth_stencil_attachment = { \n  1, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, \n}; \n\nstd::vector<SubpassParameters> subpass_parameters = { \n  // #0 subpass \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL \n      } \n    }, \n    {}, \n    &depth_stencil_attachment, \n    {} \n  }, \n  // #1 subpass \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n      } \n    }, \n    { \n      { \n        2, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL \n      } \n    }, \n    {}, \n    nullptr, \n    {} \n  } \n};\n\n```", "```cpp\nstd::vector<VkSubpassDependency> subpass_dependencies = { \n  { \n    0, \n    1, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  } \n}; \n\nif( !CreateRenderPass( logical_device, attachments_descriptions, subpass_parameters, subpass_dependencies, render_pass ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nif( !Create2DImageAndView( physical_device, logical_device, VK_FORMAT_R8G8B8A8_UNORM, { width, height }, 1, 1, VK_SAMPLE_COUNT_1_BIT, \n\n  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_ASPECT_COLOR_BIT, color_image, color_image_memory_object, color_image_view ) ) { \n\n  return false; \n} \n\nif( !Create2DImageAndView( physical_device, logical_device, VK_FORMAT_D16_UNORM, { width, height }, 1, 1, VK_SAMPLE_COUNT_1_BIT, \n\n  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_ASPECT_DEPTH_BIT, depth_image, depth_image_memory_object, depth_image_view ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkAttachmentDescription> attachments_descriptions = { \n  { \n    0, \n    VK_FORMAT_R8G8B8A8_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, \n  }, \n  { \n    0, \n    VK_FORMAT_D16_UNORM, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, \n  } \n};\n\n```", "```cpp\nVkAttachmentReference depth_stencil_attachment = { \n  1, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, \n}; \n\nstd::vector<SubpassParameters> subpass_parameters = { \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL \n      } \n    }, \n    {}, \n    &depth_stencil_attachment, \n    {} \n  } \n};\n\n```", "```cpp\nstd::vector<VkSubpassDependency> subpass_dependencies = { \n  { \n    0, \n    VK_SUBPASS_EXTERNAL, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_SHADER_READ_BIT, \n    0 \n  } \n}; \n\nif( !CreateRenderPass( logical_device, attachments_descriptions, subpasses_parameters, subpasses_dependencies, render_pass ) ) { \n  return false; \n} \n\nif( !CreateFramebuffer( logical_device, render_pass, { color_image_view, depth_image_view }, width, height, 1, framebuffer ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkRenderPassBeginInfo render_pass_begin_info = { \n  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, \n  nullptr, \n  render_pass, \n  framebuffer, \n  render_area, \n  static_cast<uint32_t>(clear_values.size()), \n  clear_values.data() \n};\n\n```", "```cpp\nvkCmdBeginRenderPass( command_buffer, &render_pass_begin_info, subpass_contents );\n\n```", "```cpp\nvkCmdNextSubpass( command_buffer, subpass_contents );\n\n```", "```cpp\nvkCmdEndRenderPass( command_buffer );\n\n```", "```cpp\nif( VK_NULL_HANDLE != framebuffer ) { \n  vkDestroyFramebuffer( logical_device, framebuffer, nullptr ); \n  framebuffer = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != render_pass ) { \n  vkDestroyRenderPass( logical_device, render_pass, nullptr ); \n  render_pass = VK_NULL_HANDLE; \n}\n\n```"]