["```cpp\ntemplate <class T>\nstruct small_allocator {\n   using value_type = T;\n   using pointer = T*;\n   using const_pointer = const T*;\n   using reference = T&;\n   using const_reference = const T&;\n   using size_type = std::size_t;\n   using difference_type = std::ptrdiff_t;\n   // ...\n```", "```cpp\n   // ...\n   constexpr size_type max_size() const {\n      return std::numeric_limits<size_type>::max(); // bah\n   }\n   // ...\n```", "```cpp\n   // ...\n   constexpr pointer address(reference r) const {\n      return std::addressof(r);\n   }\n   constexpr\n      const_pointer address(const_reference r) const {\n      return std::addressof(r);\n   }\n   // ...\n```", "```cpp\n   // ...\n   pointer allocate(size_type n) {\n      auto p = static_cast<pointer>(\n         malloc(n * sizeof(value_type))\n      );\n      if (!p) throw std::bad_alloc{};\n      return p;\n   }\n   void deallocate(pointer p, size_type) {\n      free(p);\n   }\n   // ...\n```", "```cpp\n   // ...\n   void construct(pointer p, const_reference r) {\n      new (static_cast<void*>(p)) value_type(r);\n   }\n   void destroy(const_pointer p) {\n      if(p) p->~value_type();\n   }\n   // ...\n   template <class U>\n   struct rebind {\n      using other = small_allocator<U>;\n   };\n};\n```", "```cpp\n// ...\ntemplate <class T, class U>\nconstexpr bool operator==(const small_allocator<T>&,\n                          const small_allocator<U>&) {\n   return true;\n}\ntemplate <class T, class U>\nconstexpr bool operator!=(const small_allocator<T>&,\n                          const small_allocator<U>&) {\n   return false;\n}\n```", "```cpp\ntemplate <class A, class IIt, class T>\nvoid uninitialized_fill_with_allocator(\n   A& alloc, IIt bd, IIt ed, T init\n) {\n   // bd: beginning of destination¸\n   // ed: end of destination\n   auto p = bd;\n   try {\n      for (; p != ed; ++p)\n         alloc.construct(p, init);\n   } catch (...) {\n      for (auto q = bd; q != p; ++q)\n         alloc.destroy(q);\n      throw;\n   }\n}\n```", "```cpp\ntemplate <class A, class IIt, class OIt>\nvoid uninitialized_copy_with_allocator(\n   A& alloc, IIt bs, IIt es, OIt bd\n) {\n   // bs: beginning of source\n   // es: end of source\n   // bd: beginning of destination¸\n   auto p = bd;\n   try {\n      for (auto q = bs; q != es; ++q) {\n         alloc.construct(p, *q);\n         ++p;\n      }\n   } catch (...) {\n      for (auto q = bd; q != p; ++q)\n         alloc.destroy(q);\n      throw;\n   }\n}\n```", "```cpp\ntemplate <class A, class IIt, class OIt>\nvoid uninitialized_move_with_allocator(\n   A& alloc, IIt bs, IIt es, OIt bd\n) {\n   // bs: beginning of source\n   // es: end of source\n   // bd: beginning of destination¸\n   auto p = bd;\n   try {\n      for (auto q = bs; q != es; ++q) {\n         alloc.construct(p, std::move(*q));\n         ++p;\n      }\n   } catch (...) {\n      for (auto q = bd; q != p; ++q)\n         alloc.destroy(q);\n      throw;\n   }\n}\n```", "```cpp\ntemplate <class A, class It>\n   void destroy_with_allocator(A &alloc, It b, It e) {\n      for (; b != e; ++b)\n         alloc.destroy(b);\n   }\n```", "```cpp\ntemplate<class T, class U>\n   constexpr bool cmp_less(T a, U b) noexcept {\n      if constexpr (std::is_signed_v<T> ==\n                    std::is_signed_v<U>)\n         return a < b;\n      else if constexpr (std::is_signed_v<T>)\n         return a < 0 || std::make_unsigned_t<T>(a) < b;\n      else\n         return b >= 0 && a < std::make_unsigned_t<U>(b);\n   }\n```", "```cpp\ntemplate <class T, class A = std::allocator<T>>\nclass Vector : A { // note: private inheritance\npublic:\n   using value_type = typename A::value_type;\n   using size_type = typename A::size_type;\n   using pointer = typename A::pointer;\n   using const_pointer = typename A::const_pointer;\n   using reference = typename A::reference;\n   using const_reference = typename A::const_reference;\nprivate:\n   // deliberately self-exposing selected members\n   // of the private base class as our own\n   using A::allocate;\n   using A::deallocate;\n   using A::construct;\n   using A::destroy;\n   // ...\n```", "```cpp\n   // ...\n   Vector(A &alloc) : A{ alloc } {\n   }\n   // ...\n```", "```cpp\n   // ...\n   Vector(size_type n, const_reference init)\n      : A{},elems{ allocate(n) },\n        nelems{ n }, cap{ n } {\n      try {\n         uninitialized_fill_with_allocator(\n            *static_cast<A*>(this), begin(), end(), init\n         );\n      } catch (...) {\n         deallocate(elems, capacity());\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   ~Vector() {\n      destroy_with_allocator(\n         *static_cast<A*>(this), begin(), end()\n      );\n      deallocate(elems, capacity());\n   }\n   // ...\n```", "```cpp\n   // ...\n   void push_back(const_reference val) {\n      if (full()) grow();\n      construct(end(), val);\n      ++nelems;\n   }\n   void push_back(T&& val) {\n      if (full()) grow();\n      construct(end(), std::move(val));\n      ++nelems;\n   }\n   template <class ... Args>\n   reference emplace_back(Args &&...args) {\n      if (full()) grow();\n      construct(end(), std::forward<Args>(args)...);\n      ++nelems;\n      return back();\n   }\n   // ...\n```", "```cpp\n   // ...\n   void reserve(size_type new_cap) {\n      if (new_cap <= capacity()) return;\n      auto p = allocate(new_cap);\n      if constexpr (std::is_nothrow_move_assignable_v<T>) {\n         uninitialized_move_with_allocator(\n            *static_cast<A*>(this), begin(), end(), p\n         );\n      } else {\n         auto src_p = begin();\n         auto b = p, e = p + size();\n         try {\n            uninitialized_copy_with_allocator(\n               *static_cast<A*>(this), begin(), end(), p\n            );\n         } catch (...) {\n            deallocate(p, new_cap);\n            throw;\n         }\n      }\n      deallocate(elems, capacity());\n      elems = p;\n      cap = new_cap;\n   }\n   // ...\n```", "```cpp\n   // ...\n   void resize(size_type new_cap) {\n      if (new_cap <= capacity()) return;\n      auto p = allocate(new_cap);\n      if constexpr (std::is_nothrow_move_assignable_v<T>) {\n         uninitialized_move_with_allocator(\n            *static_cast<A*>(this), begin(), end(), p\n         );\n      } else {\n         uninitialized_copy_with_allocator(\n            *static_cast<A*>(this), begin(), end(), p\n         );\n      }\n      try {\n         uninitialized_fill_with_allocator(\n            *static_cast<A*>(this),\n            p + size(), p + new_cap, value_type{}\n         );\n         destroy_with_allocator(\n            *static_cast<A*>(this), begin(), end()\n         );\n         deallocate(elems, capacity());\n         elems = p;\n         nelems = cap = new_cap;\n      } catch(...) {\n         destroy_with_allocator(\n            *static_cast<A*>(this), p, p + size()\n         );\n         deallocate(p, new_cap);\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   template <class It>\n   iterator insert(const_iterator pos, It first, It last) {\n      iterator pos_ = const_cast<iterator>(pos);\n      const auto remaining = capacity() - size();\n      const auto n = std::distance(first, last);\n//      if (std::cmp_less(remaining, n)) { // needs C++20\n      if(cmp_less(remaining, n)) {\n         auto index = std::distance(begin(), pos_);\n         reserve(capacity() + n - remaining);\n         pos_ = std::next(begin(), index);\n      }\n      const auto nb_to_uninit_displace =\n         std::min<std::ptrdiff_t>(n, end() - pos_);\n      auto where_to_uninit_displace =\n         end() + n - nb_to_uninit_displace;\n      if constexpr (\n         std::is_nothrow_move_constructible_v<T>\n      )\n         uninitialized_move_with_allocator(\n            *static_cast<A*>(this),\n            end() - nb_to_uninit_displace, end(),\n            where_to_uninit_displace\n         );\n      else\n         uninitialized_copy_with_allocator(\n            *static_cast<A*>(this),\n            end() - nb_to_uninit_displace, end(),\n            where_to_uninit_displace\n         );\n      // note : might be zero\n      const auto nb_to_uninit_insert =\n         std::max<std::ptrdiff_t>(\n            0, n - nb_to_uninit_displace\n         );\n      auto where_to_uninit_insert = end();\n      uninitialized_copy_with_allocator(\n         *static_cast<A*>(this),\n         last - nb_to_uninit_insert, last,\n         where_to_uninit_insert\n      );\n      // note : might be zero\n      const auto nb_to_backward_displace =\n         std::max<std::ptrdiff_t>(\n            0, end() - pos_ - nb_to_uninit_displace\n         );\n      auto where_to_backward_displace = end();\n      if constexpr (std::is_nothrow_move_assignable_v<T>)\n         std::move_backward(\n            pos_, pos_ + nb_to_backward_displace,\n            where_to_backward_displace\n         );\n      else\n         std::copy_backward(\n            pos_, pos_ + nb_to_backward_displace,\n            where_to_backward_displace\n         );\n      std::copy(\n         first, first + n - nb_to_uninit_insert, pos_\n      );\n      nelems += n;\n      return pos_;\n   }\n   // ...\n```", "```cpp\n   // ...\n   iterator erase(const_iterator pos) {\n      iterator pos_ = const_cast<iterator>(pos);\n      if (pos_ == end()) return pos_;\n      std::copy(std::next(pos_), end(), pos_);\n      destroy(std::prev(end()));\n      --nelems;\n      return pos_;\n   }\n};\n```", "```cpp\ntemplate <class T, class A = std::allocator<T>>\nclass ForwardList {\npublic:\n   using value_type = typename A::value_type;\n   // likewise for the other aliases\nprivate:\n   struct Node {\n      value_type value;\n      Node *next = nullptr;\n      Node(const_reference value) : value { value } {\n      }\n      Node(value_type &&value)\n         : value { std::move(value) } {\n      }\n   };\n   Node *head {};\n   size_type nelems {};\n   // ...\n```", "```cpp\ntemplate <class T>\n   class small_allocator { // for example\n   // ...\n   template <class U>\n      struct rebind {\n         using other = small_allocator<U>;\n      };\n   // ...\n};\n```", "```cpp\n   // ...\n   using Alloc = typename A::rebind<Node>::other;\n   Alloc alloc;\n   // ...\n```", "```cpp\n   // ...\n   template <class U> class Iterator {\n      // ...\n   private:\n      Node *cur {};\n      friend class ForwardList<T,A>;\n      // ...\n   };\n   // ...\n```", "```cpp\n   // ...\n   void clear() noexcept {\n      for(auto p = head; p; ) {\n         auto q = p->next;\n         alloc.destroy(p);\n         alloc.deallocate(p, 1);\n         p = q;\n      }\n      nelems = 0;\n   }\n   // ...\n```", "```cpp\n   // ...\n   template <class It> // <std::forward_iterator It>\n      ForwardList(It b, It e) {\n         if(b == e) return;\n         try {\n            head = alloc.allocate(1);\n            alloc.construct(head, *b);\n            auto q = head;\n            ++nelems;\n            for(++b; b != e; ++b) {\n               auto ptr = alloc.allocate(1);\n               alloc.construct(ptr, *b);\n               q->next = ptr;\n               q = q->next;\n               ++nelems;\n            }\n         } catch (...) {\n            clear();\n            throw;\n         }\n      }\n   // ...\n```", "```cpp\n   // ...\n   void push_front(const_reference val) {\n      auto p = alloc.allocate(1);\n      alloc.construct(p, val);\n      p->next = head;\n      head = p;\n      ++nelems;\n   }\n   void push_front(T&& val) {\n      auto p = alloc.allocate(1);\n      alloc.construct(p, std::move(val));\n      p->next = head;\n      head = p;\n      ++nelems;\n   }\n   // ...\n```", "```cpp\n   // ...\n   iterator\n      insert_after(iterator pos, const_reference value) {\n      auto p = alloc.allocate(1);\n      alloc.construct(p, value);\n      p->next = pos.cur->next;\n      pos.cur->next = p;\n      ++nelems;\n      return { p };\n   }\n   template <class It> // <std::input_iterator It>\n      iterator insert_after(iterator pos, It b, It e) {\n         for(; b != e; ++b)\n            pos = insert_after(pos, *b);\n         return pos;\n      }\n   // ...\n```", "```cpp\n   // ...\n   iterator erase_after(iterator pos) {\n      if (pos == end() || std::next(pos) == end())\n         return end();\n      auto p = pos.cur->next->next;\n      alloc.destroy(pos.cur->next);\n      alloc.deallocate(pos.cur->next, 1);\n      --nelems;\n      pos.cur->next = p;\n      return { p->next };\n   }\n};\n```", "```cpp\n#include <cstdint>\ntemplate <class T>\nstruct seq_buf_allocator {\n   using value_type = T;\n   // pointer, reference and other aliases are as\n   // usual, and so is max_size()\nprivate:\n   char *buf;\n   pointer cur;\n   size_type cap;\npublic:\n   seq_buf_allocator(char *buf, size_type cap) noexcept\n      : buf{ buf }, cap{ cap } {\n      cur = reinterpret_cast<pointer>(buf);\n   }\n   // ...\n```", "```cpp\n   // ...\n   // rebind, address(), construct() and destroy()\n   // are all as usual\n   pointer allocate(size_type n) {\n      auto\n         request = reinterpret_cast<\n            std::intptr_t\n         >(cur + n),\n         limit = reinterpret_cast<\n            std::intptr_t\n         >(buf + cap);\n      if(request >= limit)\n         throw std::bad_alloc{};\n      auto q = cur;\n      cur += n;\n      return q;\n   }\n   void deallocate(pointer, size_type) {\n   }\n};\n// ...\n```", "```cpp\ntemplate <class T, class U>\n  constexpr bool operator==(const seq_buf_allocator<T> &a,\n                            const seq_buf_allocator<U> &b){\n     return a.cur == b.cur; // maybe?\n  }\ntemplate <class T, class U>\n  constexpr bool operator!=(const seq_buf_allocator<T> &a,\n                            const seq_buf_allocator<U> &b){\n     return !(a == b);\n  }\n```", "```cpp\n#include <chrono>\n#include <utility>\ntemplate <class F, class ... Args>\n   auto test(F f, Args &&... args) {\n      using namespace std;\n      using namespace std::chrono;\n      auto pre = high_resolution_clock::now();\n      auto res = f(std::forward<Args>(args)...);\n      auto post = high_resolution_clock::now();\n      return pair{ res, post - pre };\n   }\n#include <iostream>\n#include <vector>\nstruct Data { int n; };\nint main() {\n   using namespace std::chrono;\n   enum { N = 500'000 };\n   {\n      std::vector<Data> v;\n      auto [r, dt] = test([](auto & v) {\n         v.reserve(N);\n         for(int i = 0; i != N; ++i)\n            v.push_back({ i + 1 });\n         return v.back();\n      }, v);\n      std::cout << \"vector<Data>:\\n\\t\"\n                << v.size()\n                << \" insertions in \"\n                << duration_cast<microseconds>(dt).count()\n                << \" us\\n\";\n   }\n   {\n      alignas(Data) char buf[N * sizeof(Data)];\n      seq_buf_allocator<Data> alloc{ buf, sizeof buf };\n      std::vector<Data, seq_buf_allocator<Data>> v(alloc);\n      auto [r, dt] = test([](auto & v) {\n         v.reserve(N);\n         for(int i = 0; i != N; ++i)\n            v.push_back({ i + 1 });\n         return v.back();\n      }, v);\n      std::cout\n         << \"vector<Data, seq_buf_allocator<Data>>:\\n\\t\"\n         << v.size()\n         << \" insertions in \"\n         << duration_cast<microseconds>(dt).count()\n         << \" us\\n\";\n   }\n   // do the same replacing std::vector with Vector\n}\n```", "```cpp\ntemplate <class T>\nstruct small_allocator {\n   using value_type = T;\n   T* allocate(std::size_t n) {\n      auto p = static_cast<T*>(\n         malloc(n * sizeof(value_type))\n      );\n      if (!p) throw std::bad_alloc{};\n      return p;\n   }\n   void deallocate(T *p, std::size_t) {\n      free(p);\n   }\n};\n// ... insert the equality operators here\n```", "```cpp\ntemplate <class T>\nstruct seq_buf_allocator {\n   using value_type = T;\n   using pointer = T*;\n   using size_type = std::size_t;\n   char* buf;\n   pointer cur;\n   size_type cap;\n   seq_buf_allocator(char* buf, size_type cap) noexcept\n      : buf{ buf }, cap{ cap } {\n      cur = reinterpret_cast<pointer>(buf);\n   }\n   pointer allocate(size_type n) {\n      auto request =\n         reinterpret_cast<std::intptr_t>(cur + n),\n           limit =\n         reinterpret_cast<std::intptr_t>(buf + cap);\n      if (request > limit) {\n         throw std::bad_alloc{};\n      }\n      auto q = cur;\n      cur += n;\n      return q;\n   }\n   void deallocate(pointer, size_type) {\n   }\n};\n// ... insert equality operators here\n```", "```cpp\n// ...\n   typename std::allocator_traits<\n      A\n   >::template rebind_alloc<Node>;\n// ...\n```", "```cpp\ntemplate <class A, class IIt, class OIt>\nvoid uninitialized_copy_with_allocator\n   (A &a, IIt bs, IIt es, OIt bd) {\n   auto p = bd;\n   try {\n      for (auto q = bs; q != es; ++q) {\n         std::allocator_traits<A>::construct(a, p, *q);\n         ++p;\n      }\n   } catch (...) {\n      for (auto q = bd; q != p; ++q)\n         std::allocator_traits<A>::destroy(a, q);\n      throw;\n   }\n}\n```", "```cpp\ntemplate <class T, class A = std::allocator<T>>\nclass Vector : A { // note: private inheritance\npublic:\n   using value_type =\n      typename std::allocator_traits<A>::value_type;\n   using size_type =\n      typename std::allocator_traits<A>::size_type;\n   using pointer =\n      typename std::allocator_traits<A>::pointer;\n   using const_pointer =\n      typename std::allocator_traits<A>::const_pointer;\n   using reference = value_type&;\n   using const_reference = const value_type&;\n   // ...\n```", "```cpp\n   Vector(size_type n, const_reference init)\n      : A{},\n        elems{ std::allocator_traits<A>::allocate(\n           static_cast<A&>(*this), n)\n        },\n        nelems{ n }, cap{ n } {\n      try {\n         uninitialized_fill_with_allocator(\n            static_cast<A&>(*this), begin(), end(), init\n         );\n      } catch (...) {\n         std::allocator_traits<A>::deallocate(\n            static_cast<A&>(*this), elems, capacity()\n         );\n         throw;\n      }\n   }\n```", "```cpp\ntemplate <class T, class A = std::allocator<T>>\nclass ForwardList {\npublic:\n   // note: these are the forward-facing types, expressed\n   // in terms where T is the value_type\n   using value_type = T;\n   using size_type =\n      typename std::allocator_traits<A>::size_type;\n   using pointer = value_type*;\n   using const_pointer = const value_type*;\n   using reference = value_type&;\n   using const_reference = const value_type&;\n   // ...\n```", "```cpp\n   // ...\nprivate:\n   struct Node {\n      value_type value;\n      Node *next = nullptr;\n      Node(const_reference value) : value { value } {\n      }\n      Node(value_type &&value) : value{ std::move(value) }{\n      }\n   };\n   using Alloc = typename std::allocator_traits<\n      A\n   >::template rebind_alloc<Node>;\n   Alloc alloc;\n   // ...\n```", "```cpp\n   // ...\n   void clear() noexcept {\n      for(auto p = head; p; ) {\n         auto q = p->next;\nstd::allocator_traits<Alloc>::destroy(alloc, p); \n         std::allocator_traits<Alloc>::deallocate(\n            alloc, p, 1\n         );\n         p = q;\n      }\n      nelems = 0;\n   }\n   template <std::forward_iterator It>\n      ForwardList(It b, It e) {\n         if(b == e) return;\n         try {\n            head = std::allocator_traits<\n               Alloc\n            >::allocate(alloc, 1);\n            std::allocator_traits<Alloc>::construct(\n               alloc, head, *b\n            );\n            auto q = head;\n            ++nelems;\n            for(++b; b != e; ++b) {\n               auto ptr = std::allocator_traits<\n                  Alloc\n               >::allocate(alloc, 1);\n               std::allocator_traits<\n                  Alloc\n               >::construct(alloc, ptr, *b);\n               q->next = ptr;\n               q = q->next;\n               ++nelems;\n            }\n         } catch (...) {\n            clear();\n            throw;\n         }\n      }\n   // ...\n```", "```cpp\n#include <print>\n#include <vector>\n#include <string>\n#include <memory_resource>\nint main() {\n   enum { N = 10'000 };\n   alignas(int) char buf[N * sizeof(int)]{};\n   std::pmr::monotonic_buffer_resource\n      res{ std::begin(buf), std::size(buf) };\n   std::pmr::vector<int> v{ &res };\n   v.reserve(N);\n   for (int i = 0; i != N; ++i)\n      v.emplace_back(i + 1);\n   for (auto n : v)\n      std::print(\"{} \", n);\n   std::print(\"\\n {}\\n\", std::string(70, '-'));\n   for (char * p = buf; p != buf + std::size(buf);\n        p += sizeof(int))\n      std::print(\"{} \", *reinterpret_cast<int*>(p));\n}\n```", "```cpp\n#include <print>\n#include <vector>\n#include <string>\n#include <memory_resource>\nint main() {\n   auto make_str = [](const char *p, int n) ->\n      std::pmr::string {\n      auto s = std::string{ p } + std::to_string(n);\n      return { std::begin(s), std::end(s) };\n   };\n   enum { N = 2'000 };\n   alignas(std::pmr::string) char buf[N]{};\n   std::pmr::monotonic_buffer_resource\n      res{ std::begin(buf), std::size(buf) };\n   std::pmr::vector<std::pmr::string> v{ &res };\n   for (int i = 0; i != 10; ++i)\n      v.emplace_back(make_str(\"I love my instructor \", i));\n   for (const auto &s : v)\n      std::print(\"{} \", s);\n   std::print(\"\\n {}\\n\", std::string(70, '-'));\n   for (char c : buf)\n      std::print(\"{} \", c);\n}\n```", "```cpp\n#include <print>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <memory_resource>\nclass tracing_resource : public std::pmr::memory_resource {\n   void* do_allocate(\n      std::size_t bytes, std::size_t alignment\n   ) override {\n       std::print (\"do_allocate of {} bytes\\n\", bytes);\n       return upstream->allocate(bytes, alignment);\n   }\n   void do_deallocate(\n      void* p, std::size_t bytes, std::size_t alignment\n   ) override {\n       std::print (\"do_deallocate of {} bytes\\n\", bytes);\n       return upstream->deallocate(p, bytes, alignment);\n   }\n   bool do_is_equal(\n      const std::pmr::memory_resource& other\n   ) const noexcept override {\n       return upstream->is_equal(other);\n   }\n   std::pmr::memory_resource *upstream;\npublic:\n   tracing_resource(std::pmr::memory_resource *upstream)\n      noexcept : upstream{ upstream } {\n   }\n};\nint main() {\n   enum { N = 100 };\n   tracing_resource tracer{\n      std::pmr::new_delete_resource()\n   };\n   std::pmr::vector<int> v{ &tracer };\n   for (int i = 0; i != N; ++i)\n      v.emplace_back(i + 1);\n   for (auto s : v)\n      std::print(\"{} \", s);\n}\n```"]