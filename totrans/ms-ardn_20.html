<html><head></head><body>
        

                            
                    <h1 class="header-title">Bluetooth LE</h1>
                
            
            
                
<p>In this book so far, all external communication with our Arduino projects has been in a closed environment. By closed environment, we mean that our project simply received information or direction from a remote control and no information was transmitted out from the project. There are numerous use cases where we need to transmit information from our Arduino project to an external device such as a smartphone or other IoT device. When there is a need such as this, one of the first technologies that is brought up is <strong>Bluetooth Low Energy</strong>, also known as <strong>Bluetooth LE</strong> or Bluetooth Smart.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>What Bluetooth LE is</li>
<li>How the Bluetooth LE radio works</li>
<li>What the GAP profile is</li>
<li>What the GATT profile is</li>
<li>How to use the HM-10 Bluetooth LE radio module with the Arduino</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>One of the most common misunderstandings of Bluetooth LE by people that are not familiar with the technology is that Bluetooth LE is a lightweight subset of <strong>Bluetooth Classic</strong>. This is not true, as Bluetooth Classic and Bluetooth LE are two fundamentally different protocols with different design goals.</p>
<p>Most wireless technologies, such as Wi-Fi and Bluetooth Classic, were designed to satisfy a wide range of use cases; however, the design of Bluetooth LE is a bit different. Originally created by Nokia and known as <strong>Wibree</strong>, the primary design focus of Bluetooth LE was to create a radio standard with the lowest possible power consumption and optimized for low cost, low complexity, and low bandwidth.</p>
<p>Bluetooth LE specifications were released as part of the Bluetooth 4.0 Core specifications in June of 2010. The Bluetooth Core Specifications are overseen and updated by the Bluetooth <strong>Special Interest Group</strong> (<strong>SIG</strong>).</p>
<p>You can find information about Bluetooth and download the specifications from their site at <a href="https://www.bluetooth.com">https://www.bluetooth.com</a>; however, at over 2500 pages, I would recommend that you read this chapter instead of the Bluetooth specifications unless you are looking for help with insomnia.</p>
<p>The adoption rate of Bluetooth LE has been much faster than most other wireless technologies. The reason for this is the adoption of the Bluetooth LE standard in the mobile industry where Apple and Google have put significant effort into including reliable Bluetooth LE stacks with the iOS and Android operating systems and developing easy-to-use-and-understand Bluetooth LE APIs for developers. This makes it very easy for developers to create and interact with devices that have Bluetooth LE radios.</p>
<p>The reason that the mobile industry has been pushing for the adoption of Bluetooth LE is that devices that connect using Bluetooth LE consume far less power, hence the name Bluetooth Low Energy, as compared to other wireless technologies such as Bluetooth Classic and Wi-Fi. This leads to longer battery life for their phones, which leads to happier customers.</p>
<p>Bluetooth devices come in three types, where each type supports either Bluetooth Classic, Bluetooth LE or both. The following chart shows what each type supports:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Device Type</strong></p>
</td>
<td>
<p><strong>Bluetooth Classic Support</strong></p>
</td>
<td>
<p><strong>Bluetooth LE Support</strong></p>
</td>
</tr>
<tr>
<td>
<p>Pre-4.0 Bluetooth</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p>Single-Mode</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<p>Dual-Mode</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>While the Bluetooth 5.0 specifications were released in June of 2016, at the time this book is being written, there are very few Bluetooth modules for the Arduino that support this new specification. In fact, at this time, there is very little support for the Bluetooth 4.1 or 4.2 specifications either; therefore, in this book, we are going to focus on the Bluetooth 4.0 specifications, knowing that Bluetooth 5.0, 4.2 and 4.1 are all backward compatible with this standard.</p>
<p>In order to design IoT devices that use Bluetooth LE we really need to understand the technology so we know when actually to use it. Therefore, we will delve into this technology a lot further than we have with other technologies in this book. We will start off by looking at the radio specifications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth LE radio</h1>
                
            
            
                
<p>Since we will be using Bluetooth LE 4.0 for all the projects in this book, the following specifications are for this standard:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Range</strong></p>
</td>
<td>
<p><strong>Up to 100 meters</strong></p>
</td>
</tr>
<tr>
<td>
<p>Radio Frequency</p>
</td>
<td>
<p>2.402 - 2.481 GHz</p>
</td>
</tr>
<tr>
<td>
<p>Radio Channels</p>
</td>
<td>
<p>40 (37 data and 3 advertising)</p>
</td>
</tr>
<tr>
<td>
<p>Maximum OTA Data Rate</p>
</td>
<td>
<p>1 Mbit/s</p>
</td>
</tr>
<tr>
<td>
<p>Application Data Throughput</p>
</td>
<td>
<p>0.125 Mbit/s</p>
</td>
</tr>
<tr>
<td>
<p>Network Topologies</p>
</td>
<td>
<p>Point-to-Point</p>
</td>
</tr>
<tr>
<td>
<p>Network Standard</p>
</td>
<td>
<p>IEEE 802.15.1</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Bluetooth LE has a maximum range of 100 meters, but this is very dependent on the surroundings. When the connected devices are indoors, the range will be dramatically reduced due to walls and other obstacles that the radio signal needs to go through. Generally, we will not see a range close to 100 meters unless we are outside in an open field. Even then it is rare to get a range of 100 meters.</p>
<p>The Bluetooth LE radio operates on over 40 channels, ranging from 2.402 GHz to 2.481 GHz. Of these channels, 37 are reserved for data and three are reserved for advertising. The reason for the multiple channels is Bluetooth LE uses frequency hopping to mitigate interference. The three advertising channels are used for discovery of devices. Once a device is discovered, the same channel is used to exchange initial connection parameters. Once the connection parameters have been exchanged, the regular data channels are used for communication.</p>
<p>The following figure shows the channels used by Bluetooth LE:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a566589f-731c-4553-9f8d-d2390854732c.png" style="width:31.08em;height:14.50em;"/></p>
<p>Bluetooth LE is designed to operate at low power, and the best way to avoid using power is to turn the radio off as often as possible and for as long as possible. For Bluetooth LE, this is achieved by sending short bursts of packets at a certain frequency, and in between those radio bursts, the radio is powered off. This is often referred to as <strong>Racing to Idle</strong>, since the radio is essentially sending out information as fast as it can and then shutting down for a short period of time.</p>
<p>The biggest sacrifice that we make for the low power usage of Bluetooth LE is the application data throughput. In the previous chart, we saw that the Bluetooth LE radio has a maximum over-the-air data rate of 1 Mbit/s. However, we also listed the application data throughput as only 0.125 Mbit/s. This means that the radio can theoretically transfer 1 Mbit per second; however, with the limitations put on the radio to conserve power, we only have a maximum transfer rate of 0.125 Mbit per second. In a real-world application, we will actually never see anything close to this data transfer rate.</p>
<p>Let's examine the race to idle and the limitations put on by the Bluetooth LE standards to understand why the data throughput is so low. To start off with, the Bluetooth LE specifications define that the connection interval, which is the time interval between two consecutive connection events (when the two devices exchange data), to be between 7.5 ms and 4 s. This means that if we set the connection interval to the shortest time possible (7.5 ms), we will have a maximum of 133 connection events per second.</p>
<p>The radio can transmit up to six data packets per connection event, where each data packet can contain a maximum of 20 bytes of user data. This gives up a maximum of 120 bytes for each connection event.</p>
<p>If we put all of the information together, we get the following formula:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e19b98a-53db-46dd-8890-ffbed9cc5a77.png" style="width:53.17em;height:5.92em;"/></p>
<p>This shows that the maximum data throughput would be 0.125 Mbit/second; however, as we mentioned earlier, even that number will never be reached because we generally will never max out the bytes per packet or have 133 connection events in one second. Devices themselves can add further limitations to the connection interval and data packets per connection. In the best case, we will generally see around 5-10 KB per second for the data throughput. This means that we generally only want to use Bluetooth LE technology when we are exchanging short bursts of data and avoid it when we wish to exchange large amounts or even stream data.</p>
<p>Now let's look at the network topology for Bluetooth LE connections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Network topology</h1>
                
            
            
                
<p>Bluetooth LE devices can communicate with other Bluetooth LE devices through broadcasting or an established connection. Each of these methods have their own advantages and disadvantages. We will begin by looking at the network topology when the devices communicate by broadcasting. For the projects in this chapter, we will focus on exchanging data over established connections, but it is good to have a knowledge of how data can be exchanged by broadcasting. Therefore, we will cover it in this introduction section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth LE broadcasting</h1>
                
            
            
                
<p>The following diagram shows the network topology for a broadcast network:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e2d70c18-31f7-4ee3-81a6-61f5c89613ad.png" style="width:28.17em;height:14.75em;"/></p>
<p>There are two roles defined when broadcasting:</p>
<ul>
<li><strong>Broadcaster</strong>: This device sends non-connectable advertising packets at set time intervals to any other device that is listening</li>
<li><strong>Observer</strong>: This device scans the advertising frequencies to receive the non-connectable advertising packets that the broadcaster is sending out</li>
</ul>
<p>Broadcasting data is the only way that a device can send data to multiple devices. The standard broadcasting packet can have a payload of 31 bytes of data, which is usually used to describe the broadcaster and its capabilities. However, it can also include any custom information that we wish to broadcast to other devices. Bluetooth LE also supports an optional second advertising payload called the <strong>scan response</strong>, which can include an additional 31 bytes of data.</p>
<p>Broadcasting is fast and easy if we wish to transmit small amounts of data to multiple devices; however, there is no security or privacy on the data. The security is usually the biggest reason to avoid using broadcast packets. However, another big reason to avoid using broadcast packets is the observer does not have the ability to send any data back to the broadcaster.</p>
<p>Now let's look at Bluetooth LE connections</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth LE connections</h1>
                
            
            
                
<p>The following diagram shows how Bluetooth connections work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b6af8d1f-587e-4b46-acd1-fdee12f701af.png" style="width:30.00em;height:15.58em;"/></p>
<p>As with the Bluetooth LE broadcasting topology, the connection topology also defines two roles:</p>
<ul>
<li><strong>Central</strong>: The central is usually a device such as, a laptop, tablet or phone. These devices will scan the advertising channels and listen for connectable advertising packets. When a device is found, the central may attempt to establish a connection to the device. After the connection is established the central manages the timing and initiates the data exchanges. The central device can connect to more than one peripheral.</li>
<li><strong>Peripheral</strong>: The peripheral is usually a device such as a smartwatch, a weather station or medical device. These devices send out periodic connectable advertising packets and accept incoming connections. Once a connection is established, the peripheral will generally follow the central's timing and exchange data when the central requests it. A peripheral can connect to only one central device.</li>
</ul>
<p>A peripheral will generally advertise until a central device discovers it and requests a connection. Once the connection is established, the peripheral will stop advertising and then the two devices can exchange data. The data exchange in this topology can go both ways, where the peripheral and central can both send and receive data.</p>
<p>When a central and a peripheral establish a connection, the data that is transmitted and received is organized in units called <strong>services and characteristics</strong>. We will look at this more when we look at the <strong>Generic Attribute Profile</strong> (<strong>GATT</strong>) a little later in this chapter. The thing to understand now is that a Bluetooth LE peripheral can have multiple characteristics, which are used to send and receive data. These characteristics are organized or grouped into services.</p>
<p>The biggest advantage with establishing a Bluetooth LE connection is you can have multiple characteristics to organize your data, and each of these characteristics may have their own access rights and descriptive metadata. Another advantage is the ability to establish secure encrypted connections.</p>
<p>With Bluetooth 4.0, a device can act as a central or a peripheral but not both. Starting with Bluetooth 4.1, this restriction was removed and with newer versions of Bluetooth LE, a device can act as a peripheral, a central or both.</p>
<p>Now let's look at the Bluetooth LE profiles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth LE profiles</h1>
                
            
            
                
<p>Bluetooth LE defines two types of profiles. These are profiles that define the basic mode of operations required by all Bluetooth LE devices to ensure interoperability (Generic Access Profile and GATT) or profiles that are used for specific use cases (health device profile and proximity profile). In this chapter, we will not go into the specific use cases of these profiles; however, we do want to look at both the <strong>Generic Access Profile</strong> (<strong>GAP</strong>) and the Generic Attribute Profile (GATT). We will start off by looking at the GAP.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic access profile (GAP)</h1>
                
            
            
                
<p>The GAP defines how devices interact with each other to ensure device interoperability. It defines how Bluetooth LE devices discover each other, establish secure connections, terminate connections, broadcast data and device configuration. This is the lowest level of the Bluetooth LE stack that we will cover in this chapter.</p>
<p>Earlier in this chapter, we saw that a Bluetooth LE device could be in one of two states. In the broadcasting topology, a device can be either the broadcaster (slave) or observer (master). If a connection between the two devices is established, then the devices become either a central (master) or peripheral (slave). We introduced the terms master and slave here to illustrate the states that the devices can be in. The following diagram shows the different states:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c8b6d92a-69ad-48d0-9c56-fe1e34bb3b89.png" style="width:19.33em;height:18.42em;"/></p>
<p>Both types of devices start in an idle or standby state. This is the initial state when the device is reset. A slave device will then become an advertiser, where it is advertising specific data, letting any master device know that it is a connectable device and what services it offers. After the idle state, a master device will begin scanning for slaves that are advertising. When a master receives an advertisement, it will send a scan request to the advertiser, and the slave will respond back with a scan response. This is the device discovery process.</p>
<p>After the device discovery process, if the master wishes to connect to the advertising device, it will initiate a connection. When initiating the connection, the master will specify the connection parameters. Once the connection is made the devices will assume their roles as master and slave. With Bluetooth LE 4.0, the slave device can have only one master. Also, with Bluetooth LE 4.0, the devices can act as either a master or a slave but not both. With later revisions of the Bluetooth specifications, these limitations have been removed. I know we have mentioned that a couple of times so far in this book, but it is important to keep in mind when developing your devices.</p>
<p>We mentioned that the master specifies the number of connection parameters when initiating the connection. Some of these parameters are:</p>
<ul>
<li><strong>Connection Interval</strong>: With Bluetooth LE uses a frequency hopping scheme the two devices that are communicating most know which channel to transmit/receive on, when to switch channels and when to make the connection. The time interval between the connection attempts is known as the connection interval.</li>
<li><strong>Slave Latency</strong>: The slave latency gives the slave device the option to skip a certain number of connection events. The slave device must not skip more than the number of connection events defined by this parameter.</li>
<li><strong>Supervision Time-out</strong>: The supervision time-out is the maximum amount of time between two successful connection events. If this time is exceeded, the device will terminate the connection, and the slave device will go back to an unconnected state.</li>
</ul>
<p>There are a number of considerations when deciding what to set these parameters to. The main consideration is power consumption and data throughput. As the throughput increases, the device will use more power. For example, if we lower the connection interval, thereby increasing the number of connection attempts per second, the power consumption of the device will increase because the radio will be on more of the time. By reducing the slave latency, once again the radio will be on more. Therefore, it will also increase the power consumption. When working with a Bluetooth LE radio, you need to balance the power consumption with the data throughput needs for your project. There is no magic ratio that will work for all types of devices; it is something you will need to look at on a project-by-project basis.</p>
<p>In the example projects for this chapter, we will show how to AT commands to adjust the various settings for the Bluetooth LE module. Now let's look at the GATT profile.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic attribute (GATT) profile</h1>
                
            
            
                
<p>While the GAP profile defines the low-level (advertising and connection) interactions of Bluetooth LE devices, the GATT profile defines the details on how the devices exchange data. The GATT is also the reference framework for all attribute-based profiles that define specific use cases, such as heart rate and blood pressure profiles.</p>
<p>As with the GAP profile, the GATT profile defines two roles. These roles are the client and the server. When you look at the diagram on how this works, the roles may seem a little odd at first; however, once we see how Bluetooth LE devices exchange data it will make more sense. The client role in the GATT profile corresponds to the master role in the GAP profile and the server role in the GATT profile corresponds to the slave role. The following diagram illustrates this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d2a0966f-94dd-45a6-8571-63a78db5595c.png" style="width:24.33em;height:12.58em;"/></p>
<p>In this diagram, we can see that one client can have multiple servers; however, each server can have only one client. In the GATT profile, the client (central role in the GAP) requests information from the server (peripheral in the GAP). While we are showing the relationship between the GATT and GAP roles, it is worth noting that the GATT and GAP roles are actually independent of each other, and in later versions of the Bluetooth LE specifications, a device can act as both a central and a peripheral.</p>
<p>The smallest data entity defined by the GATT profile is the attribute. An attribute is an addressable piece of information that is located on the server, which can be accessed and potentially modified by the client. Each attribute is uniquely identified by a <strong>UUID</strong> (<strong>universally unique identifier</strong>), which can be either a 16-bit or 128-bit number. This identifier is known as the handle.</p>
<p>The GATT profile defines a set of permissions that are associated with all attributes. Permissions specify which operations can be performed on each attribute. These permissions are:</p>
<ul>
<li><strong>Access Permissions</strong>: Access permissions specify which actions can be performed on the attribute. Each attribute will have one of the following permissions:
<ul>
<li><strong>None</strong>: The attribute cannot be read or written by the client</li>
<li><strong>Readable</strong>: The attribute can be read by the client</li>
<li><strong>Writable</strong>: The attribute can be written to by the client</li>
<li><strong>Readable and Writable</strong>: The attribute can be read and written to by the client</li>
</ul>
</li>
<li><strong>Encryption</strong>: Encryption permission determines the level of encryption that is required for a client to access the attribute
<ul>
<li><strong>No Encryption</strong> (Security Mode 1, Level 1): No encryption is required</li>
<li><strong>Unauthenticated Encryption</strong> (Security Mode 1, Level 2): The connection must be encrypted; however, the encryption keys do not need to be authenticated</li>
<li><strong>Authenticated Encryption</strong> (Security Mode 2, Level 2): The connection must be encrypted, and the encryption keys must be authenticated</li>
</ul>
</li>
<li><strong>Authorization</strong>: Authorization permission determines whether the user needs to be authorized to access the attribute
<ul>
<li><strong>No Authorization</strong>: No authorization is required to access the attribute</li>
<li><strong>Authorization Required</strong>: Authorization is required to access the attribute</li>
</ul>
</li>
</ul>
<p>The GATT defines a strict hierarchy, which organizes the attributes. The attributes are grouped into services, where each service may contain zero or more characteristics. These characteristics can include zero or more descriptors. Services, characteristics and descriptors are all attributes within the GATT server.</p>
<p>The following diagram shows the hierarchy:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0b365ec6-1983-4b72-bce7-1e23f75ffc3b.png" style="width:22.83em;height:23.33em;"/></p>
<p>Services are used to group related attributes into a common entity. Each service is identified by a unique UUID, which can be either 16-bit for officially adopted service types or 128-bit for custom service types.</p>
<p>You can see a list of officially adopted services on the Bluetooth SIG site here: <a href="https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices">https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices</a>.</p>
<p>If you look at the Heart Rate service, you can see that this service contains three characteristics.</p>
<p>Characteristics are containers for the data, where each characteristic encapsulates a single data point. As with the services, a characteristic is identified by either a 16-bit or 128-bit UUID. Characteristics are the main entry point that a Bluetooth LE client interacts with a server.</p>
<p>You can find a list of officially adopted characteristics on the Bluetooth SIG site here: <a href="https://www.bluetooth.com/specifications/gatt/characteristics">https://www.bluetooth.com/specifications/gatt/characteristics</a>.</p>
<p>Access permissions for each characteristic should be either read-only or write-only. It is very rare to have a characteristic that has both read and write permission. As an example, if we wanted to create a simple serial interface for our Bluetooth LE device, we would create a TX characteristic to transmit data with read-only permission for the client and an RX characteristic to receive data with write-only permission for the client. We would not want to create a single characteristic that had both read and write permission because as the client writes data to it, the server could overwrite it.</p>
<p>The descriptors are used to provide the client devices with additional information about the characteristics and their values.</p>
<p>You can find a list of officially adopted descriptors on the Bluetooth SIG site here: <a href="https://www.bluetooth.com/specifications/gatt/descriptors">https://www.bluetooth.com/specifications/gatt/descriptors</a>.</p>
<p>Generally, the server simply responds to a client's request for data from a characteristic; however, it is possible for a server to initiate the communication by using server-initiated updates. There are two types of server initiated updates, which are:</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><strong>Notification</strong>: Characteristic value change notifications are used when the server is configured to notify the client that the value of the characteristic has changed but does not expect the client to acknowledge the notification. Notification is turned on for all projects in this chapter; however, it is only used in the first and third projects.</li>
<li><strong>Indication</strong>: Characteristic value change indications are used when the server is configured to indicate to the client that the value of the characteristic has changed and expects the client to acknowledge that it has received the indication.</li>
</ul>
<p>Now that we have a very basic understanding of Bluetooth LE and how it works, let's look at the HM-10 Bluetooth module that we will be using in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">HM-10 Bluetooth module</h1>
                
            
            
                
<p>The HM-10 is a Bluetooth 4.0 module that is based on the TI CC2530 or CC2541 Bluetooth <strong>SOC</strong> (<strong>System-on-Chip</strong>). The HM-10 is a very popular Bluetooth 4 module for the Arduino, mostly due to its cheap cost and ease of use. The HM-10 provides a standard serial connection to the Bluetooth layer. This allows for a very straightforward interface; however, it does hide the actual Bluetooth LE layer.</p>
<p>In <a href="7abdb5af-1851-4623-b6a9-996fc6b69694.xhtml" target="_blank">Chapter 21</a>, <em>Bluetooth Classic</em>, when we look at the HC-05 Bluetooth module, you will notice that the interface between the HC-05 and HM-10 use the same serial interface; however, understanding the difference between Bluetooth LE and Bluetooth Classic technologies will help you decide which to use in your project.</p>
<p>We can control the module using AT commands, and we will look at how to do that in the project section of this chapter. The following photograph shows what the HM-10 Bluetooth module looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/25551851-e2eb-476c-b508-0b0296e5ac31.png" style="width:41.00em;height:14.42em;"/></p>
<p>The HM-10 has six pins. However, we are only interested in the middle four, which are:</p>
<ul>
<li><strong>VCC</strong>: Connected to the 3.3V power out on the Arduino</li>
<li><strong>GND</strong>: Connected to the ground on the Arduino</li>
<li><strong>TX</strong>: Transmit pin, connected to one of the digital pins on the Arduino</li>
<li><strong>RX</strong>: Receive pin, connected to one of the digital pins on the Arduino</li>
</ul>
<p>Now let's look at all of the components that we will need for the projects that we will be doing in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components needed</h1>
                
            
            
                
<p>For these, projects you will need the following items:</p>
<ul>
<li>One Arduino Uno or compatible board</li>
<li>One HM-10 Bluetooth 4.0 module</li>
<li>One DHT-11 temperature sensor</li>
<li>One LED</li>
<li>One 4.7K resistor</li>
<li>One 3.3K resistor</li>
<li>One 1.1K resistor</li>
<li>One 330k resistor</li>
<li>Jumper wires</li>
<li>Breadboard</li>
</ul>
<p>You will need a Bluetooth LE app for your phone/tablet or computer. I use the <em>BTCommander – Serial port HM10</em> (<a href="https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8">https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8</a>) app on my phone. There are plenty of other apps, such as the <em>nRF connect</em> app for Android (<a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=en_US">https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=en_US</a>) and iOS (<a href="https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8">https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Circuit diagrams</h1>
                
            
            
                
<p>In this chapter, we will be doing three projects. The first project will be a simple serial communication project that will send a text to and from the Arduino through the Bluetooth radio. We will also show how to configure the Bluetooth radio in the first project. For the second project, we will show how to toggle a LED on and off remotely. For the final project, we will build a mini weather station, which will enable us to read the temperature remotely through the Bluetooth radio. Each project will have its own wiring diagram included with it; however, if you wish to connect all of the hardware at once, the following diagram shows how everything is connected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/efc48632-99e5-4183-aded-76be6a036f9f.png" style="width:23.17em;height:18.83em;"/></p>
<p>This diagram may initially look complex compared to earlier diagrams; however, if we break it down into three parts, it really is not that complex. The first part is the DHT-11 temperature sensor, which is located on the right-hand side of the breadboard. The second part is the LED, which is in the center of the breadboard. The third and final part is the HM-10 Bluetooth module, which is located on the left-hand side of the breadboard.</p>
<p>We have already covered wiring the DHT-11 temperature sensor in <a href="4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml" target="_blank">Chapter 9</a>, <em>Environment Sensors</em>, and the LED in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank">Chapter 4</a>, <em>Basic Prototyping</em>. Therefore, we will repeat the explanation here.</p>
<p>To connect the HM-10 Bluetooth module to the Arduino, the <strong>VCC</strong> pin is connected to the power rail on the breadboard, which is connected to the 5V power out on the Arduino. The <strong>GND</strong> pin on the Bluetooth module is connected to the ground rail on the breadboard, which is connected to the ground pin on the Arduino. The <strong>RX</strong> pin on the Bluetooth module is connected directly to the digital <strong>pin 10</strong> on the Arduino.</p>
<p>Connecting the <strong>TX</strong> pin on the Bluetooth module to the Arduino is a little different. For this, we want to ensure that the voltage does not exceed 3.3V. Therefore, we use a simple voltage divider. A voltage divider is a simple circuit that will turn a larger voltage into a smaller one. For this, we use two resistors, a 1.1K and a 3.3K. These two resistors are connected in series, where one end of the 3.3K resistor is connected to ground, and one end of the 1.1K resistor is connected to digital <strong>pin 11</strong> on the Arduino. The <strong>TX</strong> pin is connected between the two resistors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 1 – serial communication</h1>
                
            
            
                
<p>For this first project, we are only going to use the HM-10 Bluetooth module and the Arduino. You will need to connect the Bluetooth module to the Arduino as shown in the previous circuit diagram. The following diagram shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/21db66c9-e40a-4f30-9da4-44189de605a8.png" style="width:30.75em;height:25.25em;"/></p>
<p>Now we need to write the code to access the Bluetooth module. We will be using the <kbd>SoftwareSerial</kbd> library to interface with the HM-10 Bluetooth LE module. This library was developed to allow serial communication on digital pins other than pins 0 and 1. There may be limitations to this library if you are using a board other than the Uno. You can reference the documentation (<a href="https://www.arduino.cc/en/Reference/softwareSerial">https://www.arduino.cc/en/Reference/softwareSerial</a>) to see if your board has any limitations.</p>
<p>The code will need to start off by including the <kbd>SoftwareSerial</kbd> header file and then initiate an instance of the <kbd>SoftwareSerial</kbd> type. We also want to add a new line whenever a new command is issued from the serial monitor. Therefore, we will also define a Boolean variable that will be set to true whenever a new command comes in (this will make it easier to read the responses within the serial monitor). The following code will do this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;
SoftwareSerial HM10(10, 11); // RX | TX
bool addNewLine = false;</pre>
<p>When creating the instance of the <kbd>SoftwareSerial</kbd> type, you need to define what pins to use for receiving (<strong>RX</strong>) and transmitting (<strong>TX</strong>) data. The first value is the <kbd>RX</kbd> pin and the second value is the <kbd>TX</kbd> pin.</p>
<p>Next, we need to initialize both the serial monitor and the <kbd>SoftwareSerial</kbd> instance. We will do that within the <kbd>setup()</kbd> function. We also want to let the user know when the application is ready to accept commands or connections. The following code shows the code for the <kbd>setup()</kbd> function:</p>
<pre>void setup()
{
  Serial.begin(9600);
  HM10.begin(9600);
  Serial.println("Connected to HM-10.  Try connecting from any device or <br/>  issue AT commands");
}</pre>
<p>When we initiate the serial monitor and the <kbd>SoftwareSerial</kbd> interface, we need to define what the baud rate will be. Both the HM-10 Bluetooth module and the serial monitor communicate at a baud rate of 9600. Once everything is initiated, a message is displayed to the serial monitor letting the user know that everything is good to go.</p>
<p>In the <kbd>loop()</kbd> function, we will need to write anything that the user types into the serial monitor to the Bluetooth module and write anything that comes in from the Bluetooth module to the serial monitor. The following code shows the <kbd>loop()</kbd> function:</p>
<pre>void loop() 
{ 
  if (Serial.available()) { 
    HM10.write(Serial.read()); 
    addNewLine = true; 
  } 
 
  if (HM10.available()) { 
    if (addNewLine) { 
      Serial.write("\r\n"); 
      addNewLine = false; 
    } 
    Serial.write(HM10.read()); 
  }  
}</pre>
<p>In this function, we use the <kbd>available()</kbd> function on both the serial monitor and the instance of the <kbd>SoftwareSerial</kbd> type to check whether either device has data to read. If so, we read the data and write it to the other device. In the section that reads the serial monitor and writes to the <kbd>SoftwareSerial</kbd> instance, we set the <kbd>addNewLine</kbd> Boolean variable to true so the next time we write to the serial monitor, we will write a carriage return and new line. In the section that reads from the Bluetooth module and writes to the serial monitor, we check to see whether the <kbd>addNewLine</kbd> Boolean variable is <kbd>true</kbd>, and if so, we write a carriage return and new line to the serial monitor before setting the <kbd>addNewLine</kbd> variable to <kbd>false</kbd>.</p>
<p>There are two ways that we can use this application. The first is to enter <strong>AT</strong> (<strong>ATtention</strong>) commands into the serial monitor, which enables you to get/set configuration settings on the Bluetooth module and also control the module. The second is to use the Bluetooth LE app on your phone to read and write values to the Bluetooth modules. Let's look at the AT commands first.</p>
<p>To send an AT command to the Bluetooth LE module, run the preceding code blocks and then open the serial monitor, which is part of the Arduino IDE. Once everything is initiated, you will see the <kbd>Connected to HM-10. Try connecting from any device or issue AT commands</kbd> message displayed in the monitor. This indicates that the module is ready, and everything is initiated. Once you see the message, type <kbd>at</kbd> in the input box and either click the Send button or hit <em>Enter</em>. You should see an <kbd>OK</kbd> response from the Bluetooth module. The output should look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8712490a-c504-4717-807f-d2a8d13e8dd2.png" style="width:33.50em;height:15.58em;"/></p>
<p>To send an AT command, you would use the following format:</p>
<pre><strong>Set item: AT+{command}{new setting}</strong>
<strong>Query item: AT+{command}?</strong></pre>
<p>To set an item, you type in the letters <kbd>AT</kbd> followed by the plus sign (<kbd>+</kbd>), the command and the new setting without any spaces. For example, to set the name that the Bluetooth module will advertise to "Buddy," we would issue the following command:</p>
<pre><strong>at+nameBuddy</strong></pre>
<div><strong>Note</strong>: AT commands are case insensitive.</div>
<p>To query the item, we would type in the letters <kbd>AT</kbd> followed by the plus sign (<kbd>+</kbd>), the command and then a question mark (<kbd>?</kbd>). For example, to query the name that the Bluetooth module is advertising, we would use the following command:</p>
<pre><strong>at+name?</strong></pre>
<p>We can use the application that we just wrote to set the configuration manually from the serial monitor or we can set the configurations from within the application by using the <kbd>print()</kbd> function from the <kbd>SoftwareSerial</kbd> library like this:</p>
<pre><strong>HM10.print("AT+Name?\r\n");</strong></pre>
<p>Let's look at some of the commonly used commands. Any of these can be used from the serial monitor or within the code as we just showed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test command</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT</kbd></p>
<p> </p>
</td>
<td>
<p>OK</p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>This is a test command that can be used to test the</p>
<p>connection to the Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query software version</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+VERR</kbd></p>
<p> </p>
</td>
<td>
<p>Version number</p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>This command will return the version</p>
<p>number of the firmware for the module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Restore factory default</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+RENEW</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK+RENEW</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>Restore the factory defaults.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Restart module</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+RESET</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+RESET</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">Restarts Bluetooth module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query MAC (Media Access Control) address</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>AT+ADDR?</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>OK+ADDR:{MAC Address}</kbd></p>
<p> </p>
</td>
<td>
<p>None</p>
<p> </p>
</td>
<td>
<p>This command can be used to query the</p>
<p>MAC address of the Bluetooth radio.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set name</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+NAME{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will set the name for the module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query name</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+NAME?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+NAME{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return the name of the module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set the advertising interval</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+ADVI{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+Set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd>: 100ms</p>
<p><kbd>1</kbd>: 152.5 ms</p>
<p><kbd>2</kbd>: 211.25 ms</p>
<p><kbd>3</kbd>: 318.75 ms</p>
<p><kbd>4</kbd>: 417.5 ms</p>
<p><kbd>5</kbd>: 546.25 ms</p>
<p><kbd>6</kbd>: 760 ms</p>
<p><kbd>7</kbd>: 852.5 ms</p>
<p><kbd>8</kbd>: 1022.5 ms</p>
<p><kbd>9</kbd>: 1285 ms</p>
<p><kbd>A</kbd>: 2000 ms</p>
<p><kbd>B</kbd>: 3000 ms</p>
<p><kbd>C</kbd>: 4000 ms</p>
<p><kbd>D</kbd>: 5000 ms</p>
<p><kbd>E</kbd>: 6000 ms</p>
<p><kbd>F</kbd>: 7000 ms</p>
</td>
<td>
<p class="mce-root">This command will set the advertising interval</p>
<p class="mce-root">for the Bluetooth LE module. The parameter</p>
<p class="mce-root">should be 0-F.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query the advertising interval</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+ADVI?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will retrieve the current advertising</p>
<p class="mce-root">interval and will return a parameter of 0-f.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set advertising type</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+ADTY{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>0</kbd>: Advertising Scan Response, Connectable</p>
<p class="mce-root"><kbd>1</kbd>: Only allow the last device connect in 1.28 seconds</p>
<p class="mce-root"><kbd>2</kbd>: Only allow Advertising and Scan Response</p>
<p class="mce-root"><kbd>3</kbd>: Only allow Advertising</p>
</td>
<td>
<p class="mce-root">This command<br/>
will set the<br/>
advertising type.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query advertising type</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+ADTY?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will retrieve the current advertising</p>
<p class="mce-root">type and will return a parameter of 0-3.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set baud rate</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+BAUD{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd>: 9600</p>
<p><kbd>1</kbd>: 19200</p>
<p><kbd>2</kbd>: 38400</p>
<p><kbd>3</kbd>: 57600</p>
<p><kbd>4</kbd>: 115200</p>
<p><kbd>5</kbd>: 4800</p>
<p><kbd>6</kbd>: 2400</p>
<p><kbd>7</kbd>: 1200</p>
<p><kbd>8</kbd>: 230400</p>
</td>
<td>
<p class="mce-root">This command will set the baud rate for the serial</p>
<p class="mce-root">interface of the Bluetooth module.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Query baud rate</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+BAUD?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will retrieve the current baud rate and</p>
<p class="mce-root">will return a parameter of 0-8.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set characteristic id</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+CHAR{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>0x0001</kbd> -&gt; <kbd>0xFFFe</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will set the ID for the</p>
<p class="mce-root">characteristic.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set service id</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+UUID{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>0x0001</kbd> -&gt; <kbd>0xFFFe</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will set the ID for the service.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query service id</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+UUID?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will retrieve the current service ID.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set role</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td><kbd>AT+ROLE{parameter}</kbd></td>
<td><kbd>OK+set:{parameter}</kbd></td>
<td>
<p><kbd>0</kbd>: Peripheral</p>
<p><kbd>1</kbd>: Central</p>
</td>
<td>This command will set the role of the Bluetooth module.</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query role</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+ROLE?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return the role of the Bluetooth</p>
<p class="mce-root">module.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Clear last connected device</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+CLEAR</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+CLEAR</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">Clears the address of the last connected device.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>
<div><strong>NOTE</strong>: The <kbd>at+clear</kbd> command is only used when the device is in central mode.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Try to connect to last connected device</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+CONNL</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+CONN{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>L</kbd>: Connecting</p>
<p><kbd>E</kbd>: Connect Error</p>
<p><kbd>F</kbd>: Connect Fail</p>
<p><kbd>N</kbd>: No Address</p>
</td>
<td>
<p class="mce-root">This command will attempt to connect to the device</p>
<p class="mce-root">that last successfully connected to it.</p>
</td>
</tr>
</tbody>
</table>
<div><strong>NOTE</strong>: The <kbd>at+connl</kbd> command is only used when the device is in central mode.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Try to connect to an address</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+CON{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+CONN{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>A</kbd>: Connecting</p>
<p><kbd>E</kbd>: Connect Error</p>
<p><kbd>F</kbd>: Connect Fail</p>
</td>
<td>
<p class="mce-root">This command will attempt to connect to a device</p>
<p class="mce-root">with the specified address.</p>
</td>
</tr>
</tbody>
</table>
<div><strong>NOTE</strong>: The <kbd>at+con</kbd> command is only used when the device is in central mode.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Set pin code</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+PASS{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>000000</kbd> -&gt; <kbd>999999</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">Sets the pin code for connection.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query pin code</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+PASS?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return the current pin code.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set module power</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+POWE{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd>: -23db</p>
<p><kbd>1</kbd>: -6db</p>
<p><kbd>2</kbd>: 0db</p>
<p><kbd>3</kbd>: 6db</p>
</td>
<td>
<p class="mce-root">Sets the power for the module.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query module power</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+POWE?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return the current module power.</p>
<p> </p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set bond mode</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+TYPE{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd>: PIN code not needed</p>
<p><kbd>1</kbd>: Auth without PIN code</p>
<p><kbd>2</kbd>: Auth and PIN</p>
<p><kbd>3</kbd>: Auth and bond</p>
</td>
<td>
<p class="mce-root">This command sets the authentication needed</p>
<p class="mce-root">when connecting to this device.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query bond mode</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+TYPE?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return the current authentication</p>
<p class="mce-root">needed to connect to this device.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Set notify information</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+NOTI{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+set:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p><kbd>0</kbd>: Don't Notify</p>
<p><kbd>1</kbd>: Notify</p>
</td>
<td>
<p class="mce-root">This command enables or disables the notification</p>
<p class="mce-root">when a device connects are disconnects.</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Query notify information</h1>
                
            
            
                
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Response</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p class="mce-root"><kbd>AT+NOTI?</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root"><kbd>OK+get:{parameter}</kbd></p>
<p> </p>
</td>
<td>
<p class="mce-root">None</p>
<p> </p>
</td>
<td>
<p class="mce-root">This command will return if the device will send a</p>
<p class="mce-root">notification when a device connects or disconnects.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can only issue AT commands to the Bluetooth module when another device is not connected to it. Once a device is connected to the application code that we wrote takes over, and the data that is typed into the serial console is sent to the connected device. Let's see what happens when we connect to the Bluetooth module from another device. I will be using the <em>BTCommander – Serial Port HM10</em> app to show how this works.</p>
<p>With the application running on the Arduino, start up the Bluetooth application on your phone/tablet or computer. The <em>BTCommander</em> app will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06a970b0-493e-4f7f-90ac-eb58809a24df.png" style="width:19.25em;height:41.67em;"/></p>
<p>To connect to a device, press the blue connection button, which looks like an outlet plug, located at the upper right side of the application. Once you press the button, you should see a list of devices that the application can connect to. This screen looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2f0fc2a-0414-42cb-8461-e5584fab6a62.png" style="width:19.58em;height:42.50em;"/></p>
<p>This screen shows all devices that are advertising and are close enough to connect. Earlier in this chapter, when we ran the <kbd>AT+nameBuddy</kbd> command, we renamed our device to <kbd>Buddy</kbd>. Therefore, we know that is the device that we want to connect to. If we tap that device and then tap on the Connect button at the upper right side of the application, the application will attempt to connect. If the connection attempt is successful and the <kbd>AT+NOTI</kbd> setting on the Bluetooth module has the notifications enabled, we should see <kbd>OK+CONN</kbd> on the serial console as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d17d039f-2ac0-4a3c-a5c5-81b59055c6be.png" style="width:50.58em;height:23.33em;"/></p>
<p>When the connection is successful, the application will go back to the main screen. Now let's type a message in the input box at the bottom of the screen. For example, here we will type a simple <kbd>hello</kbd> message as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/684f46ed-eb2b-41f8-8e81-9cd6f13490b1.png" style="width:21.25em;height:46.00em;"/></p>
<p>Once the message is entered, press the button next to the input box that looks like a paper airplane to send the message. If the message was successfully sent, we will see it in the serial console as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ecb0e61e-18bf-4aa0-846e-c8dabdddb33a.png" style="width:47.58em;height:22.08em;"/></p>
<p>What is happening here is the message that is entered in the application is being passed from the phone application to the chrematistic on the HM-10 Bluetooth module, so our application can read it. The message is sent one character at a time.</p>
<p>To send a message back, type the message in the input box of the serial console and press the send button. If the message was sent successfully, we should see it in the application as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8511eb14-e1d8-44f2-8055-9e28f76788f5.jpg" style="width:17.25em;height:37.42em;"/></p>
<p>In this screenshot, we can see that the <kbd>hello</kbd> message was sent from the application and the <kbd>Hello from Arduino</kbd> was received from the connected device. When a message is sent from the HM-10 Bluetooth module back to the phone application, the application writes the message to the characteristic (one character at a time) and the Bluetooth module uses a notification to notify the client (the phone application) that there is new data.</p>
<p>If we press the connection button again in the <em>BTCommander</em> application to disconnect, and the <kbd>AT+NOTI</kbd> configuration is set to notify, we will see an <kbd>OK+LOST</kbd> message in the serial console as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3908f18b-285c-47dc-962f-b2d72076f22a.png" style="width:29.75em;height:14.17em;"/></p>
<p>Now let's see how we can use the Bluetooth module to control an LED from our phone.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 2 – controlling LED</h1>
                
            
            
                
<p>In this project, we will turn an LED that is connected to the Arduino on or off depending on the input from the phone. The first thing we will need to do is to add the LED to our circuit. The following diagram shows the new circuit:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3379c415-722f-4de3-b44a-0e0a287bff3c.png" style="width:26.08em;height:21.00em;"/></p>
<p>The LED is connected to the digital 5 pin on the Arduino through a 330-ohm resistor. Now we need to write the code to control the LED. We will start by setting up the <kbd>SoftwareSerial</kbd> library for the Bluetooth module and defining the pin that the LED is connected to. The following code will do this:</p>
<pre>#include &lt;SoftwareSerial.h&gt;
#define LED_PIN 5
SoftwareSerial HM10(10, 11);</pre>
<p>We can see that the Bluetooth module is connected to the same pins as the previous example, and the LED is connected to digital pin 5 on the Arduino. In the <kbd>setup()</kbd> function, we will need to configure the <kbd>SoftwareSerial</kbd> instance and the mode of the pin that the LED is connected to. The following code shows the <kbd>setup()</kbd> function for this example:</p>
<pre>void setup()
{
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  Serial.begin(9600);
  HM10.begin(9600);
  Serial.println("Connected to HM-10");
}</pre>
<p>This code starts off by defining the mode of the pin that the LED is connected to. It then configures the serial port for the serial monitor and the <kbd>SoftweareSerial</kbd> instance. We finally print a message to the serial console letting the user know that everything is configured and ready to go.</p>
<p>In our <kbd>loop()</kbd> function, we will need to check the <kbd>SoftwareSerial</kbd> instance, and if a <kbd>1</kbd> is received from the connected device, it will turn the LED on, and if a <kbd>0</kbd> is received, it will turn the LED off. If neither a <kbd>1</kbd> or a <kbd>0</kbd> is received, then it will ignore the input. Here is the code for the <kbd>loop()</kbd> function:</p>
<pre>void loop()
{
  if (HM10.available()) {
    char val = HM10.read();
    if(val == '1') {
      digitalWrite(LED_PIN, HIGH);
    } else if(val == '0') {
      digitalWrite(LED_PIN, LOW);
    }
  }
}</pre>
<p>In this code, we check to see whether a value is available from the Bluetooth module, and if so, we read the device to get the character that was received. If the character is equal to <kbd>1</kbd> (the character 1 and not the number 1), we pull the pin that the LED is connected to <kbd>HIGH</kbd> to turn the LED on. If the character is equal to <kbd>0</kbd> (the character 0 and not the number 0), we pull the pin that the LED is connected to <kbd>LOW</kbd> to turn the LED off.</p>
<p>Now let's run this application and use the <em>BTCommander</em> application to connect to it. From the <em>BTCommander</em> application, if we send a <kbd>1</kbd>, the LED will light up, or if we send a <kbd>0</kbd>, the LED will go off. This type of example can be used when we wish to have a phone application to control something that is connected to the Arduino such as an LED, DC Motor or some sensor.</p>
<p>Now let's see how we can retrieve temperature and humidity data from the DHT-11 sensor via Bluetooth LE.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Project 3 – environmental sensor</h1>
                
            
            
                
<p>In this project, we will request, from the phone, that the Arduino send temperature or humidity information depending on the character sent. We will need to add the DHT-11 sensor to our circuit. The following diagram shows how to do this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f841810b-72b2-45c7-a6d1-8c9a758b929b.png" style="width:32.75em;height:26.42em;"/></p>
<p>The DHT-11 temperature sensor is connected to the Arduino exactly as we did in <a href="03634c50-cc88-4b10-8a3a-4054b67f0691.xhtml" target="_blank">Chapter 9</a>, <em>Environment Sensors</em>. If you are unsure how to connect this sensor to the Arduino, please refer back to that chapter. Now we will need to write the code, so we can access the data from the sensor with Bluetooth LE service. We will start by setting up the <kbd>SoftwareSerial</kbd> library for the Bluetooth module and the DHT-11 temperature sensor. The following code will do this:</p>
<pre>#include &lt;DHT.h&gt;
#include &lt;SoftwareSerial.h&gt;

#define DHT_PIN 3
#define DHT_TYPE DHT11
DHT dht(DHT_PIN, DHT_TYPE);

SoftwareSerial HM10(10, 11); // RX | TX</pre>
<p>This code includes the libraries for the DHT temperature sensor and also the <kbd>SoftwareSerial</kbd> device. It then defines the pin that the temperature sensor is connected to and the type of sensor. Finally, it creates instances of the <kbd>DHT</kbd> and the <kbd>SoftwareSerial</kbd> types.</p>
<p>In the <kbd>setup()</kbd> function, we will need to configure the <kbd>SoftwareSerial</kbd> instance and the mode of the pin that the LED is connected to. The following code shows the <kbd>setup()</kbd> function for our example:</p>
<pre>void setup()
{
  Serial.begin(9600);
  HM10.begin(9600);
  Serial.println("Connected to HM-10");
}</pre>
<p>This function configures the <kbd>SoftwareSerial</kbd> instance and prints a message to the serial console when everything is initiated and ready to go. In the <kbd>loop()</kbd> function, we will want to read the input from the device that is connected to the service and then respond back with the appropriate information.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following chart shows the input and what should be returned:</p>
<p class="mce-root"/>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 81px">
<p><strong>Input</strong></p>
</td>
<td style="width: 215px">
<p><strong>Property Returned</strong></p>
</td>
</tr>
<tr>
<td style="width: 81px">
<p><kbd>f</kbd></p>
</td>
<td style="width: 215px">
<p>Temperature in Fahrenheit</p>
</td>
</tr>
<tr>
<td style="width: 81px">
<p><kbd>c</kbd></p>
</td>
<td style="width: 215px">
<p>Temperature in Celsius</p>
</td>
</tr>
<tr>
<td style="width: 81px">
<p><kbd>h</kbd></p>
</td>
<td style="width: 215px">
<p>Humidity</p>
</td>
</tr>
<tr>
<td style="width: 81px">
<p><kbd>F</kbd></p>
</td>
<td style="width: 215px">
<p>Heat Index Fahrenheit</p>
</td>
</tr>
<tr>
<td style="width: 81px">
<p><kbd>C</kbd></p>
</td>
<td style="width: 215px">
<p>Heat Index in Celsius</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>From the chart, we can see that we will have five inputs and each one will return different information back to the remote device. Let's look at the code that will read the input and return the information requested:</p>
<pre>void loop()
{
  if (HM10.available()) {
    char val = HM10.read();
    if(val == 'f') {
      float fahreheit = dht.readTemperature(true);
      HM10.println(fahreheit);
    } else if(val == 'c') {
      float celsius = dht.readTemperature();
      HM10.println(celsius);
    } else if(val == 'h') {
      float humidity = dht.readHumidity();
      HM10.println(humidity);
    } else if(val == 'F') {
      float fahreheit = dht.readTemperature(true);
      float humidity = dht.readHumidity();
      float hif = dht.computeHeatIndex(fahreheit, humidity);
      HM10.println(hif);
    } else if(val == 'C') {
      float celsius = dht.readTemperature();
      float humidity = dht.readHumidity();
      float hic = dht.computeHeatIndex(celsius, humidity, false);
      HM10.println(hic);
    }
  }
}</pre>
<p>This code starts by checking the Bluetooth adapter to see whether there is any input available, and if so, it reads the character. If the input character is one of the characters listed in the previous chart, the code retrieves the appropriate value from the DHT-11 sensor and returns the value back to the connected device.</p>
<p class="mce-root"/>
<p>The output from the code in the <em>BTCommander</em> iOS app would look similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/547ecbdc-4537-47ac-97d8-85f51efd77da.jpg" style="width:14.75em;height:32.00em;"/></p>
<p>Everything we have shown here is compatible with Bluetooth LE 4.0 and above. As of the time of writing this book, there really are not that many low-cost Bluetooth LE modules for the Arduino that are compatible with the new Bluetooth LE 4.2 and 5.0 standards, which is why we stuck with 4.0 here. The good news is all of the newer standards are backward compatible with the 4.0 standard, so everything we talked about in this chapter will work as newer Bluetooth modules are released that are compatible with the newer standards. Let's look at what features are available with the newer Bluetooth standards.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is new with Bluetooth 4.1, 4.2 and 5.0?</h1>
                
            
            
                
<p>In this section, we will look at what is new with Bluetooth 4.1, 4.2, and 5.0. While these features are not compatible with the Bluetooth LE 4.0 module that we used in this chapter, eventually Bluetooth modules for the Arduino that are compatible with these standards will be released; therefore, it is good to know what features they offer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth 4.1</h1>
                
            
            
                
<p>Bluetooth 4.1 mainly offers usability updates. One of the most important updates is to allow Bluetooth LE and LTE radios to coexist better. This update allows the radios to coordinate transmissions to decrease the chance of interference. It also makes the data transfer more efficient and allows for better reconnections after connection loss.</p>
<p>The big non-usability change with Bluetooth 4.1 allowed a device to be both a peripheral and a central at the same time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth 4.2</h1>
                
            
            
                
<p>Bluetooth 4.2 offered numerous new features for IoT, security, faster speed and more capacity.</p>
<p>For IoT, Bluetooth 4.2 added <strong>Bluetooth Smart Internet gateways</strong>, which enables Bluetooth 4.2 devices a bridge to the internet. With the internet gateways, Bluetooth 4.2 also added IPv6/6LoWPAN, which enables IPv6 support over a Bluetooth connection.</p>
<p>Bluetooth 4.2 also added extra security with LE Privacy 1.2. The encryption standards with Bluetooth 4.2 comply with the <strong>Federal Information Processing Standards</strong> (<strong>FIPS</strong>), which is a US Government computer security standard.</p>
<p>The transmission packet size was increased by ten times as well. This allows for faster and more reliable data transmissions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth 5.0</h1>
                
            
            
                
<p>Bluetooth offers a number of enhancements,quadrupling the range and doubling the speed. The catch with this is that if a device manufacturer increases the range of their device, the speed will go down; and likewise, if the speed increases, the range will go down.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Bluetooth mesh</h1>
                
            
            
                
<p>One of the latest, and in my opinion, the most exciting, Bluetooth technologies is Bluetooth mesh. All previous Bluetooth technologies relied on a one-to-one or a one-to-many connection where there was always one master/central device. Mesh technology allows Bluetooth devices to establish many-to-many connections, which enables large-scale device networks that do not rely on a central controller. The Bluetooth mesh technology is still in its infancy at the time we are writing this book. However, I believe it is the future of Bluetooth and is a technology worth keeping an eye on.</p>
<p>One thing to note with Bluetooth standards higher than 4.0 is most of the new features are optional and not required to be fully implemented. For example, a manufacturer may say that their device meets the Bluetooth 4.2 standard. However, IPv6/6LoWPAN may not be implemented in the device. A good example of this is the iPhone. My iPhone X is Bluetooth 5.0 compatible; however, it is not capable of running Bluetooth mesh or IPv6/6LoWPAN.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenge</h1>
                
            
            
                
<p>For the challenge, take the Nokia 5110 LCD display that we used in <a href="5daf3c48-d927-436f-81ec-0b04d23d764f.xhtml" target="_blank">Chapter 13</a>, <em>Using LCD Displays</em>, and the serial communication code that we used in the first project of this chapter and print any message sent from the phone app to the LCD display. This will require some modification to the code in this chapter to use the LCD screen rather than the serial console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned a lot about Bluetooth LE, starting with a brief introduction on how the radio works and the network topology for Bluetooth LE connections. We learned how the GAP is used by Bluetooth LE devices to discover and connect to other devices. We also saw how the GATT uses attributes (services, characteristics and descriptors) to enable two Bluetooth LE devices to communicate with each other. We finally demonstrated how Bluetooth LE works with three projects at the end of this chapter.</p>
<p>Bluetooth LE is the technology best suited when we wish to use an external device, such as a phone, to control the device that we are building, because almost all smartphones have Bluetooth LE built in and the technology is easy to use. It is also a good technology to use when we wish to send short bursts of data from one device to another. If you wish to build a separate device, such as a remote control, to control your main device or stream a lot of data, then I would recommend a different Bluetooth technology that is known as Bluetooth Classic or Legacy, which we will see in the next chapter.</p>


            

            
        
    </body></html>