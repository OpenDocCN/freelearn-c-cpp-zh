- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a World of Your Own in Godot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 1* of this book, you learned the basics of programming! No small feat
    if you ask me. So, congrats on that milestone! Now, it’s time to tie it all together
    and start working on our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of game development, everything happened through code. A computer
    wizard had to program everything, from systems and features to levels and asset
    placement. In recent times, the tooling for creating games has gotten way better,
    is free, and is very user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Godot, like most modern game engines (Unity, Unreal Engine, Construct, and others),
    has a graphical interface that makes it easy to drag and drop elements of our
    game into levels or other scenes. In this chapter, we’ll learn how to use this
    graphical interface by creating a rudimentary player character and a little world
    for them to inhabit.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also learn some tricks to tie the code and graphical editor together with
    node references and variable exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The node-based system of Godot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a player character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing nodes in scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making rudimentary shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we will create a game from scratch, I took the liberty of providing
    you with the base of a project. You can find this base project in the folder for
    this chapter under `/start`. This project supplies some assets, such as pictures
    and sounds. Creating these assets is outside the scope of this book. The resulting
    project files for this chapter can be found under `/result` of this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapters, you’ll find the resulting project in the `root`
    folder of that chapter. It’s assumed that you use the results from the previous
    chapter as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, get the starting project, and let’s dive in: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start).'
  prefs: []
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before mindlessly creating a game, let’s plan out what kind of game we want
    to make. This will structure our thoughts and make sure we work toward the game
    we want to make without taking unnecessary detours. The best way to do this is
    through a **game design document** (**GDD**). Though there is no set format for
    this kind of document, it should eventually answer some basic questions about
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Which genre is the game?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What mechanics will be in the game?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the story?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some game design documents are hundreds of pages long. But as this is not a
    game design book, let’s define our game regarding these three questions and then
    work out the details as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Genre
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, we have witnessed the birth of a new genre known as **vampire survivor-likes**,
    also known as a **VS** game. In this type of game, you control a character in
    a 2D top-down world. The character has to defeat waves of monsters coming after
    them by shooting them. The player can control the character by moving them around,
    but shooting happens automatically. It does not require input.
  prefs: []
  type: TYPE_NORMAL
- en: This genre has a huge player base, and the base game is relatively simple to
    implement and yet satisfying to play. Therefore, it would be the ideal type of
    game to recreate throughout the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The survivor-like genre has some staple mechanics that are very important to
    get right:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2D world**: The playing field is a 2D plane on which we have a top-down view.
    Some of them are indeed in 3D, but the mechanics still shine in 2D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movement of the character**: We need to be able to move the character around
    in the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waves of enemies**: We need enemies that threaten to kill the player and
    we need to spawn them so that they pose a proper challenge .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic shooting**: The player character will automatically shoot projectiles
    aimed at the enemies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have sorted out the genre and staple mechanics, let’s work out the
    story our game will be based on.
  prefs: []
  type: TYPE_NORMAL
- en: Story
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s not burden ourselves too much with writing the whole story. In games,
    the story can also be told through how the game looks and feels. So, we can specify
    a general setting that binds the whole experience together.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about this as our setting: You are a medieval knight fighting in the king’s
    tournament to find the strongest soldier in the whole land. You’ll have to battle
    multiple enemies, such as orcs and trolls, in multiple rounds, each harder than
    the last. The only weapon you are given is a bow, with which you can shoot arrows
    at your adversaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of the kind of game we are creating, let’s get into
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll start by creating a rudimentary player character for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `main.tscn` file I provided in the project base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `root` node, called `Main`, and press the **Add Child** **Node**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The button to add a new child node to the selected node in the
    tree](img/B19358_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The button to add a new child node to the selected node in the
    tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, find and add a **Node2D** node. You can use the search bar at the top
    to make searching for the node easier. This is a node that has a position in 2D
    space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Finding and selecting the Node2D node](img/B19358_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Finding and selecting the Node2D node
  prefs: []
  type: TYPE_NORMAL
- en: Next, rename this Node2D as `Player` by right clicking the node and choosing
    **Rename**, just like we did in [*Chapter 2*](B19358_02.xhtml#_idTextAnchor044).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Player` will be the base node for our player character. From here, we will
    add all the other nodes that comprise the `Player` node. The first of these nodes
    will be a sprite.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we can do to flesh out our player character is to give it a
    visual, something that the player can relate to as the main character. Follow
    *Steps 1* to *3* in the *Creating a player character* section again to add a node
    called `Sprite2D` to the `Player` node so that the scene tree looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The scene tree so far](img/B19358_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The scene tree so far
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sprite2D` node is a node that can display an image, also called a `Sprite2D`,
    you’ll see that the **Inspector** view on the right-hand side gets populated with
    information about that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The Inspector view of a Sprite2D node](img/B19358_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The Inspector view of a Sprite2D node
  prefs: []
  type: TYPE_NORMAL
- en: There are settings for **Texture**, **Offset**, **Animation**, **Region**, and
    more. You can look through them to get an idea of all the available settings.
    The different tabs are **Property Groups**, while the settings themselves are
    called **Properties**.
  prefs: []
  type: TYPE_NORMAL
- en: We are only interested in the **Texture** property because this is where we
    can set the image this node displays. So, let’s add a sprite for our character!
  prefs: []
  type: TYPE_NORMAL
- en: In the `assets/sprites/character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you’ll find a bunch of premade character sprites.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kenney assets
  prefs: []
  type: TYPE_NORMAL
- en: The assets we are using in this book all come from Kenney and are free to use
    in any project you want. You can find more of his great assets at [https://kenney.nl/](https://kenney.nl/).
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop any of them onto the `Sprite2D` node. I’m using the `character01.png`
    texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Sprite2D` node should now look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Adding a texture to a sprite node](img/B19358_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Adding a texture to a sprite node
  prefs: []
  type: TYPE_NORMAL
- en: 'The sprite should also turn up in the 2D view of the editor. However, it seems
    to be very small. That’s because the image is only `16` × `16` pixels in size.
    Let’s scale it up a little. Under the `3`. You can set the scale for the X and
    Y axes separately, but we want them both to be equal so that the sprite scales
    without stretching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The Transform properties of a sprite node](img/B19358_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The Transform properties of a sprite node
  prefs: []
  type: TYPE_NORMAL
- en: Oh no – what’s this?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – A blurry pixel art sprite](img/B19358_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – A blurry pixel art sprite
  prefs: []
  type: TYPE_NORMAL
- en: 'The sprite looks blurry! This happened because we’re using **pixel art** assets,
    a style well known for its blocky pixels. When upscaling, Godot Engine uses an
    algorithm that blurs out these pixels. This is great for other art styles, such
    as hand-drawn or vector art, but not for pixel art. Luckily, there is a solution.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Project** | **Project Settings...**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Going to Project Settings...](img/B19358_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Going to Project Settings...
  prefs: []
  type: TYPE_NORMAL
- en: 'Under **Rendering** | **Textures**, set **Default Texture Filter** to **Nearest**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Setting Default Texture Filter to Nearest](img/B19358_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Setting Default Texture Filter to Nearest
  prefs: []
  type: TYPE_NORMAL
- en: These settings will scale the image in a way that is better suited for pixel
    art. Now, our sprite looks way better!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – A crisp pixel art sprite](img/B19358_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – A crisp pixel art sprite
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can see our player, let’s look into displaying a health UI.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying health
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s add something to display the player’s health above the character.
    Sure, we haven’t created a script for the player yet that tracks health, but we
    can put the visuals in place. We will use a `Label` node, which can display text
    in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Find and add a `Label` node to the `Player` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the node `HealthLabel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 - The scene tree with the HealthLabel node added](img/B19358_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 - The scene tree with the HealthLabel node added
  prefs: []
  type: TYPE_NORMAL
- en: 'When selecting the `Label` node, the `10/10` into it as if the player has 10
    out of their 10 lives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The Inspector view of a Label node with the text set to 10/10](img/B19358_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The Inspector view of a Label node with the text set to 10/10
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, drag the label on top of the player so that it’s out of the way of the
    sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Repositioning the HealthLabel node above the player character](img/B19358_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Repositioning the HealthLabel node above the player character
  prefs: []
  type: TYPE_NORMAL
- en: Great! With the `HealthLabel` label in place, we can update it through a script
    later on (see the *Creating the player script* section). This is all we need to
    set up the nodes in the scene tree.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can manipulate the nodes we’ve added.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating nodes in the editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a small scene tree in place, let’s look at what tools we have
    available to manipulate the nodes. If you look at the top right of the 2D editor,
    you’ll see some of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The toolbar in the 2D editor view](img/B19358_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The toolbar in the 2D editor view
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many interesting tools in this toolbar, but the first four are the
    most important ones for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select mode**: This is the default mode and is a multitool. You can select
    nodes within the scene and drag them around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move mode**: In this mode, you can move the selected node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotate mode**: In this mode, you can rotate the selected node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale mode**: In this mode, you can scale the selected node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try these modes by selecting the `Player` node and messing around a bit. This
    could lead you to a result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – The Player node after multiple transform manipulations](img/B19358_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – The Player node after multiple transform manipulations
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice that when you move, rotate, or scale a node, its child nodes
    will be manipulated in the same way. This inheritance of transformation is the
    strength of the hierarchical node system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `Player` node, you’ll see the exact modifications you made
    to it. If you change any of these values, you’ll see them reflected in the 2D
    editor too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The Transform parameters after multiple transform manipulations](img/B19358_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The Transform parameters after multiple transform manipulations
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, try changing the value for `Skew` from the **Inspector** view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you continue with the following sections, don’t forget to reset all
    these manipulations in the `Player` node. You can do this simply by pressing the
    ↺ symbol next to each property. This button will set the property back to its
    default value. Let’s also set the position of the `Player` node so that the player
    character is roughly centered on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Positioning the player character in the middle of the screen](img/B19358_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Positioning the player character in the middle of the screen
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve finished creating the base for our player character and learned
    how we can manipulate nodes within the editor. Next, we’ll focus on the player
    character’s script and learn how we can manipulate nodes through code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the player script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the moment we have been training for. We already know how to do this!
    So, start by creating a new script that is attached to the `Player` node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the `Player` node and select **Attach Script**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Attaching a script to the Player node](img/B19358_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Attaching a script to the Player node
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dialogue that pops up, call the script `player.gd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Calling the script player.gd](img/B19358_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Calling the script player.gd
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll keep it simple for now and just add some code to manage the health of
    the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `clamp()` function we use in the `add_health_points()` function takes a
    numeric value as the first argument and keeps it in between the second two numeric
    parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This way, the health is always between `0` and `MAX_HEALTH`, which is `10` at
    the max.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can *Ctrl* and click on Windows and Linux or *Option* and
    click on Mac on any function to go to the documentation and have a look at what
    it does.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we can change the player’s health. Now, let’s look at how
    we can update the `HealthLabel` node we created earlier to reflect this value.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing nodes in a script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to update the `HealthLabel` node of our player character according to
    the amount of health the player still has left. To change nodes in our scene from
    within the script, we need to be able to reference them. Luckily, this is pretty
    easy in Godot 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to get a node’s reference, but the easiest is the dollar
    notation. This notation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The notation starts with a dollar sign (`$`), followed by the path through the
    scene tree to the node we want. Here, we reference the health label we created
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this path is relative to the node with the script where this path
    is mentioned. So if the main node has a script and we want to reference the player’s
    health label, the notation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now that we know how to get the reference to a node, let’s create a small
    function that updates the player’s health label and call it in the `add_health_points()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'func add_health_points(difference: int):'
  prefs: []
  type: TYPE_NORMAL
- en: health += difference
  prefs: []
  type: TYPE_NORMAL
- en: health = clamp(health, 0, MAX_HEALTH)
  prefs: []
  type: TYPE_NORMAL
- en: 'HealthLabel node is displaying. But there is a better way of accessing or referencing
    nodes within the scene tree: by caching them. We’ll take a look at that next.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching node references
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Though the dollar notation is very convenient, sometimes, you will need to access
    a certain node often. In such cases, using the dollar notation will be slow because
    the engine will have to keep searching for the node within the tree and accessing
    it every time.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In computer lingo, caching means storing a certain piece of data for later so
    that you don’t have to load it every time it is needed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To stop searching the node each time, we can save a reference to the node in
    a variable. For example, we can change the player script like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: add_health_points(-2)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '@export var health: int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: update_health_label()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: print(health)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '@export var health: int = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'get:'
  prefs: []
  type: TYPE_NORMAL
- en: return health
  prefs: []
  type: TYPE_NORMAL
- en: 'set(new_value):'
  prefs: []
  type: TYPE_NORMAL
- en: health = clamp(new_value, 0, MAX_HEALTH)
  prefs: []
  type: TYPE_NORMAL
- en: update_health_label()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'print(health) # Execute the getter'
  prefs: []
  type: TYPE_NORMAL
- en: 'health = 100 # Execute the setter'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'func add_health_points(difference: int):'
  prefs: []
  type: TYPE_NORMAL
- en: health += difference
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'func update_health_label():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not is_instance_valid(_health_label):'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: extends Node2D
  prefs: []
  type: TYPE_NORMAL
- en: 'const MAX_HEALTH: int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '@onready var _health_label: Label = $HealthLabel'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var health: int = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: 'get:'
  prefs: []
  type: TYPE_NORMAL
- en: return health
  prefs: []
  type: TYPE_NORMAL
- en: 'set(new_value):'
  prefs: []
  type: TYPE_NORMAL
- en: health = clamp(new_value, 0, MAX_HEALTH)
  prefs: []
  type: TYPE_NORMAL
- en: update_health_label()
  prefs: []
  type: TYPE_NORMAL
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: update_health_label()
  prefs: []
  type: TYPE_NORMAL
- en: 'func update_health_label():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not is_instance_valid(_health_label):'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: _health_label.text = str(health) + "/" + str(MAX_HEALTH)
  prefs: []
  type: TYPE_NORMAL
- en: 'func add_health_points(difference: int):'
  prefs: []
  type: TYPE_NORMAL
- en: health += difference
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '@export var health: int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var damage: float = 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var player_name: String = "Erika"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '@export_range(0, 10) health: int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '@export_range(0, MAX_HEALTH) health: int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
