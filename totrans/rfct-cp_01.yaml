- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding Standards in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the world of clean code and examine its
    crucial role in successful software projects. We will discuss the concept of technical
    debt and how poor-quality code can contribute to its accumulation. Additionally,
    we will explore the often undervalued practices of code formatting and documentation,
    which are crucial for maintaining a manageable and effective code base. Through
    this chapter, we will understand that clean code is not just nice to have but
    a necessity for any project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the importance of coding standards and introduce common conventions
    and best practices used in the C++ community. By the end of this chapter, you
    will better understand what clean code is, why it is essential, and why documenting
    code is crucial.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The difference between good code and bad code
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no strict definition of good or clean code. Moreover, no automatic
    tool can measure the quality of code. There are linters, code checkers, and other
    analyzers that can help to make code better. These tools are very valuable and
    highly recommended, but not sufficient. Artificial Intelligence may take over
    and develop code for us, but in the end, its measurement of code quality will
    be based on our human ideas of good code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming languages were initially developed to provide an interface between
    machines and developers; however, with the growth of software products’ complexity,
    it becomes clear that nowadays, it is mostly a way of communicating ideas and
    intentions between developers. It is a well-known fact that developers spend ten
    times more time reading the code than writing it. It means that to be efficient,
    we must do our best to make the reading easier. The most successful way to make
    this process efficient is to make the code predictable or, even better, boring.
    By boring, I mean code that the reader looks at and knows what to expect from
    it regarding functionality, performance, and side effects. The following example
    illustrates an interface for a class retrieving objects from a database:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It supports two lookup modes, by `id` and by `name`; it is not supposed to change
    the internal state of the `Database` object because of the `const` modifier; and
    it can only do read operations against the database instance. It is boring, but
    it meets basic expectations. Imagine how surprising it can be to find out during
    critical bug investigation that on each read operation, it does an update operation
    and sometimes a delete operation?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: As readers can see, a few key factors can distinguish good code and bad code.
    Good code is typically well written, easy to read, and efficient. It follows the
    conventions and standards of the C++ language and is organized in a logical and
    consistent manner. Good code is also well documented, often with clear comments
    explaining the purpose and function of things that are not obvious from reading
    only the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Why coding standards are important
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding standards are important for several reasons. First and foremost, they
    help to minimize *technical debt*. Technical debt, also known as “code debt,”
    is a metaphor that describes the cost of maintaining and modifying code that is
    not well designed or well written. Just as financial debt incurs interest and
    requires ongoing payments, technical debt incurs additional costs in the form
    of the time and effort needed to maintain and modify poorly designed code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准的重要性有多个原因。首先，它们有助于最小化技术债务。技术债务，也称为“代码债务”，是一个隐喻，描述了维护和修改设计不佳或编写不佳的代码的成本。正如财务债务会产生利息并需要持续支付一样，技术债务会以维护和修改设计不佳的代码所需的时间和精力为形式产生额外的成本。
- en: Technical debt can accumulate in many ways, such as through hacky or quick-fix
    solutions to problems or by ignoring best practices or coding standards. As technical
    debt accumulates, it can become increasingly difficult and time-consuming to modify
    and maintain the code, which can negatively impact the efficiency and effectiveness
    of a development team.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务可以通过多种方式积累，例如通过解决问题的快速修复或忽略最佳实践或编码标准。随着技术债务的积累，修改和维护代码变得越来越困难和耗时，这可能会对开发团队的效率和效果产生负面影响。
- en: In order to manage technical debt carefully, it is essential to try to avoid
    accumulating too much of it, as it can become a significant burden on a development
    team. Strategies for managing technical debt include regularly refactoring code
    to improve its design and maintainability, following best practices and coding
    standards, and actively seeking out opportunities to improve the quality of the
    code. Overall, managing technical debt is an important aspect of good code design
    and development and can help to ensure that code is efficient, reliable, and easy
    to work with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了谨慎管理技术债务，避免积累过多的债务至关重要，因为它可能会成为开发团队的沉重负担。管理技术债务的策略包括定期重构代码以改进其设计和可维护性，遵循最佳实践和编码标准，以及积极寻求提高代码质量的机会。总的来说，管理技术债务是良好代码设计和开发的重要方面，有助于确保代码高效、可靠且易于工作。
- en: Coding standards help to ensure the quality and consistency of code. By establishing
    a set of guidelines and conventions for writing code, coding standards help to
    ensure that code is well written, easy to read, and easy to understand. This makes
    it easier for others to maintain and update the code and helps to prevent errors
    and bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准有助于确保代码的质量和一致性。通过建立编写代码的指南和惯例，编码标准有助于确保代码编写良好、易于阅读和理解。这使得其他人更容易维护和更新代码，并有助于防止错误和缺陷。
- en: In addition, they help to improve the efficiency of code. By following established
    conventions and best practices, programmers can write code that is more efficient
    and performs better. This can save time and resources and help ensure that code
    is scalable and can handle large amounts of data and traffic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们有助于提高代码的效率。通过遵循既定惯例和最佳实践，程序员可以编写更高效且性能更好的代码。这可以节省时间和资源，并有助于确保代码可扩展并能处理大量数据和流量。
- en: Furthermore, coding standards promote collaboration and teamwork among programmers.
    By establishing a common set of guidelines and conventions, coding standards make
    it easier for teams of programmers to work together on a project. This allows
    better communication and coordination and helps to ensure that everyone is on
    the same page and working towards the same goals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编码标准促进了程序员之间的协作和团队合作。通过建立一套共同的指南和惯例，编码标准使得程序员团队更容易在项目上合作。这促进了更好的沟通和协调，并有助于确保每个人都处于同一页面上，朝着相同的目标努力。
- en: Coding standards often promote the interoperability and portability of code.
    By following a standardized set of conventions, code written by one programmer
    can be easily understood and used by another programmer. This allows code to be
    more easily integrated into larger projects and helps to ensure that it can be
    used on a variety of different platforms and operating systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准通常促进代码的互操作性和可移植性。通过遵循标准化的惯例集，一位程序员编写的代码可以很容易地被另一位程序员理解和使用。这使得代码更容易集成到更大的项目中，并有助于确保它可以在各种不同的平台和操作系统上使用。
- en: The C++ programming language is probably one of the richest languages in terms
    of features. It started as *C with classes*, providing object-oriented support
    with high performance and almost complete compatibility with C; later on, template
    metaprogramming was introduced, and Stepanov and Lee developed the Standard Template
    Library, nowadays known as the C++ Standard Library. Modern C++ (C++11 and newer
    versions) provides extensive support for multiple programming paradigms, including
    procedural, object-oriented, generic, and functional programming. It offers features
    such as lambda expressions, range-based `for` loops, smart pointers, and type
    inference that enable functional programming techniques. Additionally, C++ provides
    support for object-oriented programming concepts such as inheritance, encapsulation,
    and polymorphism. It also offers template metaprogramming, which enables generic
    programming and allows compile-time optimizations. Furthermore, C++ provides concurrency
    support with features such as threads, atomic types, and futures, making it easier
    to write concurrent and parallel code. This flexibility is key to the strength
    of the language but often leads to problems with maintainability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A developer has to understand the concepts of the paradigms we’ve mentioned,
    how to use them together, and how they eventually affect the performance of the
    code. This is when coding standards can help to explain the complexity of the
    code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: All these factors make coding guidelines the bare minimum that a modern C++
    project should have to attain a quality standard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Code convention
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to languages such as Python, Go, Java, and many others, C++ does not
    have a common code convention.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several popular coding conventions for the C++ programming language.
    Here are some common conventions that are widely followed:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`total_cost` or `customer_name`. Class variables often have prefixes or suffixes
    to distinguish them from other variables, such as `m_user_count` or `user_count_`.
    Functions may be named using *camelCase*, with the first letter of each word (apart
    from the first word) capitalized, such as `calculateTotalCost` or `getCustomerName`.
    Classes may be named using *PascalCase*, with the first letter of each word capitalized,
    such as `Customer` or `Invoice`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commenting**: Commenting conventions specify how to write and format comments
    in code. Comments are used to provide explanations and documentation for code
    and should be clear and concise. It is often recommended to use inline comments
    to explain specific lines of code, as well as block comments to provide an overview
    of a code block or function.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loop or `if` statement, to visually indicate the structure of the code.
    Formatting policy often covers asterisk (`*`) and ampersand (`&`) alignment in
    pointers and references (e.g., `int* ptr` versus `int *ptr` or `Socket &socket`
    versus `Socket& socket`), curly braces position (same line, next line, or context
    dependent). This book covers aspects of automated formatting in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto` operators.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that there may be variations in coding conventions between
    different organizations and teams. It is important to follow the conventions that
    your team or organization establishes or to define your own conventions if none
    are specified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: It can be tedious to develop a coding convention; some companies prefer to use
    an existing one and adapt it to their needs. In the C++ programming language,
    there are several popular code standards that are widely followed by developers.
    These standards aim to improve the readability, maintainability, and overall quality
    of C++ code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: One common code standard for C++ is the C++ Core Guidelines ([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)),
    which were developed by Bjarne Stroustrup, the creator of C++, and a group of
    experts from industry and academia. The guidelines cover a wide range of topics,
    including naming conventions, commenting, formatting, and coding style.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Another popular code standard for C++ is the Google C++ Style Guide ([https://google.github.io/styleguide/cppguide.html](https://google.github.io/styleguide/cppguide.html)),
    which is used by many software companies, including Google. The guide provides
    guidelines for naming conventions, commenting, formatting, and coding style, as
    well as recommendations for using specific C++ features and libraries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these widely followed standards, there are also many other code
    standards that have been developed by individual organizations and teams, for
    example, LLVM Coding Standards, WebKit, and Mozilla’s style guides.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'If a project conforms with a specific code convention, it is easier to read
    it, and as a bonus, the code base becomes more *grepable*. Consider needing to
    find the places where a variable called `request_id` is assigned. It can be easily
    achieved via the `grep` utility:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code reviewers used to spend hours catching and commenting on inconsistencies
    with code format during peer review. Luckily, today we have tools such as Clang-Tidy
    and Clang-Format that allow us to ensure the consistency of the code format automatically
    via code editors and **continuous integration** (**CI**). We will dive deeper
    into their configuration later in this book in [*Chapter 10*](B19606_10.xhtml#_idTextAnchor184).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Language features limitations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is a powerful language; as we know, great power comes with great responsibility.
    It is not easy for engineers, especially those who have not spent decades writing
    C++ code, to grasp the complexity of the language. As a result, some companies
    decide to limit the features used in their projects. The limitations may include
    a ban for multiple inheritance, usage of exceptions, and minimal usage of macros,
    templates, and specific third-party libraries. Additionally, the regulations may
    come from the use of legacy libraries. For example, if most of the code does not
    support C++ exceptions, it might be a bad idea to add them to new pieces of code
    without a prior understanding of the outcome.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种强大的语言；正如我们所知，强大的力量伴随着巨大的责任。对于工程师来说，尤其是那些没有花费几十年时间编写C++代码的人来说，掌握这种语言的复杂性并不容易。因此，一些公司决定限制他们在项目中使用的功能。这些限制可能包括禁止多重继承、使用异常以及最小化使用宏、模板和特定的第三方库。此外，这些规定可能来自对遗留库的使用。例如，如果大部分代码不支持C++异常，那么在没有事先了解结果的情况下，将它们添加到新的代码片段中可能不是一个好主意。
- en: General guidelines
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用指南
- en: 'It is always a good idea to have general guidelines for a project. The guidelines
    often cover the preferred way of working on the project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个项目来说，拥有一些通用指南总是好的。这些指南通常涵盖了在项目中工作的首选方式：
- en: Usage of raw pointers, if allowed
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果允许，原始指针的使用
- en: How values are returned from getters and provided to setters (by value or reference)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器如何返回值以及如何提供给设置器（按值或引用）
- en: 'Use of code comments:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码注释的使用：
- en: Are comments allowed in general?
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否允许一般性地使用注释？
- en: Usage of strategic and tactical comments
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略性和战术性注释的使用
- en: 'Comment style: free, Doxygen, and so on'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释风格：自由、Doxygen等
- en: Coding standards are necessary to help ensure code quality, consistency, interoperability,
    portability, efficiency, and collaboration. By following coding standards, programmers
    can write better code that is easier to understand, maintain, and use and works
    better and more efficiently.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准是必要的，以确保代码质量、一致性、互操作性、可移植性、效率和协作。通过遵循编码标准，程序员可以编写更好的代码，这些代码更容易理解、维护和使用，并且工作得更好、更高效。
- en: Readability, efficiency, maintainability, and usability
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性、效率、可维护性和可用性
- en: Readability, efficiency, maintainability, and usability are all critical factors
    to consider when writing code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性、效率、可维护性和可用性都是在编写代码时需要考虑的关键因素。
- en: Readability
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性
- en: Readability refers to the ease with which a human reader can understand a piece
    of code. Well-written code is easy to read, with clear and concise statements
    that are organized in a logical and consistent manner. This becomes very important
    if we consider that developers spend ten times more time reading code than writing
    it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性指的是人类读者理解一段代码的容易程度。编写良好的代码易于阅读，具有清晰、简洁的语句，这些语句以逻辑和一致的方式组织。如果我们考虑到开发者阅读代码的时间是编写代码时间的十倍，这一点就变得非常重要。
- en: 'Let’s take a look at the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下这段代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example is an exaggerated example of code not following any code convention.
    A developer using the `Employee` class can understand that all three methods are
    getters. However, the differences in the names make the user spend more time understanding
    the code or trying to understand the reasoning behind the names. Do the methods
    have different names because programmers did not care about the uniformity of
    the class? Or because, for example, methods without the `get` prefix are simple
    getters, and ones that contain the `get` prefix fetch the data from a file or
    a database?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个夸张的例子，展示了代码没有遵循任何编码约定。使用`Employee`类的开发者可以理解这三个方法都是获取器。然而，名称上的差异使得用户花费更多的时间来理解代码或试图理解名称背后的原因。这些方法名称不同是因为程序员没有关心类的统一性吗？还是因为，例如，没有`get`前缀的方法是简单的获取器，而包含`get`前缀的方法是从文件或数据库中获取数据？
- en: Additionally, do the methods without `const` change the object’s state (via
    caching, for example), or is it a mistake? Do you see how many questions can be
    raised? They can be answered only when a developer jumps into the corresponding
    implementation, which means time is wasted. Making the code look uniform across
    the code base helps developers to understand the meanings and complications of
    classes, methods, and functions by looking at their declarations in the header
    files or even via autocompletion in modern code editors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有`const`的方法是否会改变对象的状态（例如通过缓存），或者这是一个错误？你看到有多少问题可以提出吗？这些问题只有在开发者跳入相应的实现时才能回答，这意味着浪费了时间。使代码在代码库中看起来一致有助于开发者通过查看头文件中的声明或甚至通过现代代码编辑器的自动完成来理解类、方法和函数的含义和复杂性。
- en: Efficiency
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效率
- en: Efficiency refers to the ability of a piece of code to perform its intended
    tasks in an efficient manner. Efficient code uses few resources, such as time
    and memory, to accomplish a task, and is able to handle large amounts of data
    and traffic without slowing down or crashing. By improving the efficiency of code,
    programmers can save time and resources and can ensure that their code is scalable
    and can handle the demands of a growing user base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 效率指的是一段代码以高效的方式执行其预期任务的能力。高效的代码使用很少的资源，例如时间和内存，来完成一项任务，并且能够处理大量数据和流量而不会减慢或崩溃。通过提高代码的效率，程序员可以节省时间和资源，并确保他们的代码可扩展并能处理不断增长的用户群体的需求。
- en: 'There are surefire ways to optimize C++ code, such as passing read-only parameters
    by constant reference to avoid unnecessary copying, or using the character-overloaded
    version of `std::string::find` when looking for a single character to avoid string
    a creation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 优化C++代码有可靠的方法，例如通过常量引用传递只读参数以避免不必要的复制，或者在查找单个字符时使用`std::string::find`的字符重载版本以避免创建字符串：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, the more systematic way to achieve and maintain code efficiency is
    to follow the Pareto principle. This principle, when applied to software engineering,
    says that roughly 20% of the code does 80% of the work. For example, usually,
    there is no need to optimize the code parsing config files on startup of a background
    daemon because it happens only once during the program’s lifetime. However, it
    might be important to avoid copying large data structures in the main flow. The
    optimal way to improve the efficiency includes picking this 20% of performance-critical
    code and adding benchmarks for it. The benchmarks are expected to run as part
    of the CI process to make sure that no degradation is introduced.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现并维持代码效率的更系统的方法是遵循帕累托原则。当应用于软件工程时，这个原则表明大约20%的代码完成了80%的工作。例如，通常在后台守护进程启动时优化代码解析配置文件是没有必要的，因为这仅在程序的生命周期中发生一次。然而，避免在主流程中复制大型数据结构可能很重要。提高效率的最佳方式包括选择这20%的性能关键代码并为它添加基准测试。这些基准测试预计将作为CI过程的一部分运行，以确保没有引入退化。
- en: Additionally, end-to-end testing can measure the overall performance of the
    application. This book discusses the best practices of writing unit tests and
    end-to-end tests in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260). It is important
    to note that the automated tools cannot replace an engineer doing code reviews
    for the new code, mainly because there is no tool that can find the 20% of the
    code that does 80% of the work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，端到端测试可以衡量应用程序的整体性能。本书在[*第13章*](B19606_13.xhtml#_idTextAnchor260)中讨论了编写单元测试和端到端测试的最佳实践。需要注意的是，自动化工具不能取代工程师对新代码进行代码审查，主要是因为没有工具能够找到那20%的代码，而这20%的代码完成了80%的工作。
- en: Maintainability
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: 'Maintainability refers to the ease with which a piece of code can be updated
    and modified over time. Well-written code is easy to maintain, with clear and
    well-documented code that is organized in a logical and consistent manner. By
    improving the maintainability of code, programmers can make it easier for others
    to update and modify their code and can ensure that their code remains relevant
    and useful over time. Ideally, while developing new components, developers should
    think about the current problems the code is solving and the future usage and
    extension of the code. For example, while developing support for a data provider,
    it might be useful to ask whether the provider is going to be the only one supported.
    If not, it might be helpful to think about the standard features of data providers
    and extract them in an abstract base class. Here’s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `DataProvider` class is an abstract base class that defines
    the interface for providing data. The `NetworkDataProvider` and `FileDataProvider`
    classes are derived from `DataProvider` and override the `getData` virtual function
    to provide the specific implementation for reading data from a file or a network
    endpoint, respectively. This design makes it easy to add new data sources by simply
    creating a new class derived from `DataProvider` and providing the appropriate
    implementation for the `getData` virtual function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'It is clear from the example that the base interface may include not only the
    functionality but also the copy-move policy of the object. Later, the user code
    can receive the data provider(s) with reference to the base class and be agnostic
    to the type of provider, as shown in the following snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Additionally, this inheritance can be used for mocking data providers while
    creating unit tests for `DataParser`. Unit tests are covered in detail in [*Chapter
    13*](B19606_13.xhtml#_idTextAnchor260).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'On a side note, it is crucial not to make code overcomplicated, or to be ready
    for any change. Otherwise, the need to make everything extendable may lead to
    monsters such as the following snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class hierarchy is unnecessarily complicated because it uses almost every
    C++ feature: inheritance, templates, and macros. While using inheritance with
    templates is a common practice, macros are seen as an anti-pattern nowadays. In
    this example, the `Derived` class adds very little additional functionality compared
    to the `Base` class, and it would be more straightforward to simply add the `getValue`
    method directly to the `Base` class. Using inheritance and templates can be useful
    in certain situations, but it’s important to use them appropriately and not overuse
    them. Macros can be particularly difficult to understand and maintain because
    they are expanded by the preprocessor before the code is compiled, so it can be
    hard to see what the actual code looks like. It’s generally better to use functions
    or template functions instead of macros whenever possible.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: If the probability of extension is low, keeping its structure simple and close
    to basic needs is better. How do you decide what approach to take? Well, calm
    consideration and code review is the way to find out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展的可能性较低，保持其结构简单且接近基本需求是更好的选择。你如何决定采取哪种方法？嗯，冷静的考虑和代码审查是找到答案的方法。
- en: Usability
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Usability refers to the ease with which a piece of code can be used by others.
    Well-written code is easy to use, with clear and intuitive interfaces and documentation
    that make it easy for others to understand and use the code. By improving the
    usability of code, programmers can make their code more accessible and useful
    to others and can ensure that their code is widely adopted and used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性指的是其他人使用一段代码的容易程度。编写良好的代码易于使用，具有清晰直观的界面和文档，使其他人容易理解和使用代码。通过提高代码的可用性，程序员可以使他们的代码更容易被他人访问和使用，并确保他们的代码被广泛采用和使用。
- en: Overall, readability, efficiency, maintainability, and usability are all important
    factors to consider when writing code. By improving these factors, programmers
    can write better code that is easier to understand, maintain, and use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，可读性、效率、可维护性和可用性都是在编写代码时需要考虑的重要因素。通过提高这些因素，程序员可以编写出更容易理解、维护和使用的优质代码。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the concept of good and bad code. Good code
    is well written, efficient, and easy to understand and maintain. It follows coding
    standards and best practices and is less prone to errors. On the other hand, bad
    code is poorly written, inefficient, and difficult to understand and maintain.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了良好和糟糕代码的概念。良好的代码编写得很好，效率高，易于理解和维护。它遵循编码标准和最佳实践，并且不太容易出现错误。另一方面，糟糕的代码编写得不好，效率低下，难以理解和维护。
- en: The chapter also introduced the concept of technical debt, which refers to the
    accumulation of poor-quality code that needs to be refactored or rewritten. Technical
    debt can be costly and time-consuming to fix and can hinder the development of
    new features or functionality.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了技术债务的概念，它指的是需要重构或重写的低质量代码的积累。技术债务可能代价高昂且耗时，可能会阻碍新功能或功能的发展。
- en: The importance of code standards was also emphasized in the chapter. Code standards
    are guidelines or rules that dictate how code should be written, formatted, and
    structured. Adhering to code standards helps to ensure that code is consistent,
    easy to understand, and maintainable. It also makes it easier for multiple developers
    to work on the same code base and helps to prevent errors and bugs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也强调了代码标准的重要性。代码标准是指导或规则，规定了代码应该如何编写、格式化和结构化。遵守代码标准有助于确保代码的一致性、易于理解和维护。它还使多个开发者能够更容易地在同一代码库上工作，并有助于防止错误和缺陷。
- en: Overall, the chapter emphasized the importance of writing good quality code
    and adhering to code standards in order to avoid technical debt and ensure the
    long-term success and maintainability of a software project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章强调了编写高质量代码和遵守代码标准的重要性，以避免技术债务并确保软件项目的长期成功和可维护性。
- en: In the next chapter, we will dive into the world of software design principles.
    Specifically, we will focus on the SOLID principles, a set of guidelines that
    aim to improve the design of software systems by making them more maintainable,
    flexible, and scalable. Each of the principles will be explained in detail in
    the next chapter, along with examples of how they can be applied to real-world
    software development scenarios.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入软件设计原则的世界。具体来说，我们将关注SOLID原则，这是一组旨在通过使软件系统更易于维护、灵活和可扩展来改进软件设计的指导方针。下一章将详细解释每个原则，并附带它们如何应用于现实世界软件开发场景的示例。
