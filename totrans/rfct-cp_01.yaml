- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding Standards in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the world of clean code and examine its
    crucial role in successful software projects. We will discuss the concept of technical
    debt and how poor-quality code can contribute to its accumulation. Additionally,
    we will explore the often undervalued practices of code formatting and documentation,
    which are crucial for maintaining a manageable and effective code base. Through
    this chapter, we will understand that clean code is not just nice to have but
    a necessity for any project.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the importance of coding standards and introduce common conventions
    and best practices used in the C++ community. By the end of this chapter, you
    will better understand what clean code is, why it is essential, and why documenting
    code is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between good code and bad code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no strict definition of good or clean code. Moreover, no automatic
    tool can measure the quality of code. There are linters, code checkers, and other
    analyzers that can help to make code better. These tools are very valuable and
    highly recommended, but not sufficient. Artificial Intelligence may take over
    and develop code for us, but in the end, its measurement of code quality will
    be based on our human ideas of good code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming languages were initially developed to provide an interface between
    machines and developers; however, with the growth of software products’ complexity,
    it becomes clear that nowadays, it is mostly a way of communicating ideas and
    intentions between developers. It is a well-known fact that developers spend ten
    times more time reading the code than writing it. It means that to be efficient,
    we must do our best to make the reading easier. The most successful way to make
    this process efficient is to make the code predictable or, even better, boring.
    By boring, I mean code that the reader looks at and knows what to expect from
    it regarding functionality, performance, and side effects. The following example
    illustrates an interface for a class retrieving objects from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It supports two lookup modes, by `id` and by `name`; it is not supposed to change
    the internal state of the `Database` object because of the `const` modifier; and
    it can only do read operations against the database instance. It is boring, but
    it meets basic expectations. Imagine how surprising it can be to find out during
    critical bug investigation that on each read operation, it does an update operation
    and sometimes a delete operation?
  prefs: []
  type: TYPE_NORMAL
- en: As readers can see, a few key factors can distinguish good code and bad code.
    Good code is typically well written, easy to read, and efficient. It follows the
    conventions and standards of the C++ language and is organized in a logical and
    consistent manner. Good code is also well documented, often with clear comments
    explaining the purpose and function of things that are not obvious from reading
    only the code.
  prefs: []
  type: TYPE_NORMAL
- en: Why coding standards are important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding standards are important for several reasons. First and foremost, they
    help to minimize *technical debt*. Technical debt, also known as “code debt,”
    is a metaphor that describes the cost of maintaining and modifying code that is
    not well designed or well written. Just as financial debt incurs interest and
    requires ongoing payments, technical debt incurs additional costs in the form
    of the time and effort needed to maintain and modify poorly designed code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt can accumulate in many ways, such as through hacky or quick-fix
    solutions to problems or by ignoring best practices or coding standards. As technical
    debt accumulates, it can become increasingly difficult and time-consuming to modify
    and maintain the code, which can negatively impact the efficiency and effectiveness
    of a development team.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage technical debt carefully, it is essential to try to avoid
    accumulating too much of it, as it can become a significant burden on a development
    team. Strategies for managing technical debt include regularly refactoring code
    to improve its design and maintainability, following best practices and coding
    standards, and actively seeking out opportunities to improve the quality of the
    code. Overall, managing technical debt is an important aspect of good code design
    and development and can help to ensure that code is efficient, reliable, and easy
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards help to ensure the quality and consistency of code. By establishing
    a set of guidelines and conventions for writing code, coding standards help to
    ensure that code is well written, easy to read, and easy to understand. This makes
    it easier for others to maintain and update the code and helps to prevent errors
    and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, they help to improve the efficiency of code. By following established
    conventions and best practices, programmers can write code that is more efficient
    and performs better. This can save time and resources and help ensure that code
    is scalable and can handle large amounts of data and traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, coding standards promote collaboration and teamwork among programmers.
    By establishing a common set of guidelines and conventions, coding standards make
    it easier for teams of programmers to work together on a project. This allows
    better communication and coordination and helps to ensure that everyone is on
    the same page and working towards the same goals.
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards often promote the interoperability and portability of code.
    By following a standardized set of conventions, code written by one programmer
    can be easily understood and used by another programmer. This allows code to be
    more easily integrated into larger projects and helps to ensure that it can be
    used on a variety of different platforms and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ programming language is probably one of the richest languages in terms
    of features. It started as *C with classes*, providing object-oriented support
    with high performance and almost complete compatibility with C; later on, template
    metaprogramming was introduced, and Stepanov and Lee developed the Standard Template
    Library, nowadays known as the C++ Standard Library. Modern C++ (C++11 and newer
    versions) provides extensive support for multiple programming paradigms, including
    procedural, object-oriented, generic, and functional programming. It offers features
    such as lambda expressions, range-based `for` loops, smart pointers, and type
    inference that enable functional programming techniques. Additionally, C++ provides
    support for object-oriented programming concepts such as inheritance, encapsulation,
    and polymorphism. It also offers template metaprogramming, which enables generic
    programming and allows compile-time optimizations. Furthermore, C++ provides concurrency
    support with features such as threads, atomic types, and futures, making it easier
    to write concurrent and parallel code. This flexibility is key to the strength
    of the language but often leads to problems with maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: A developer has to understand the concepts of the paradigms we’ve mentioned,
    how to use them together, and how they eventually affect the performance of the
    code. This is when coding standards can help to explain the complexity of the
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: All these factors make coding guidelines the bare minimum that a modern C++
    project should have to attain a quality standard.
  prefs: []
  type: TYPE_NORMAL
- en: Code convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to languages such as Python, Go, Java, and many others, C++ does not
    have a common code convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several popular coding conventions for the C++ programming language.
    Here are some common conventions that are widely followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`total_cost` or `customer_name`. Class variables often have prefixes or suffixes
    to distinguish them from other variables, such as `m_user_count` or `user_count_`.
    Functions may be named using *camelCase*, with the first letter of each word (apart
    from the first word) capitalized, such as `calculateTotalCost` or `getCustomerName`.
    Classes may be named using *PascalCase*, with the first letter of each word capitalized,
    such as `Customer` or `Invoice`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commenting**: Commenting conventions specify how to write and format comments
    in code. Comments are used to provide explanations and documentation for code
    and should be clear and concise. It is often recommended to use inline comments
    to explain specific lines of code, as well as block comments to provide an overview
    of a code block or function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loop or `if` statement, to visually indicate the structure of the code.
    Formatting policy often covers asterisk (`*`) and ampersand (`&`) alignment in
    pointers and references (e.g., `int* ptr` versus `int *ptr` or `Socket &socket`
    versus `Socket& socket`), curly braces position (same line, next line, or context
    dependent). This book covers aspects of automated formatting in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto` operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that there may be variations in coding conventions between
    different organizations and teams. It is important to follow the conventions that
    your team or organization establishes or to define your own conventions if none
    are specified.
  prefs: []
  type: TYPE_NORMAL
- en: It can be tedious to develop a coding convention; some companies prefer to use
    an existing one and adapt it to their needs. In the C++ programming language,
    there are several popular code standards that are widely followed by developers.
    These standards aim to improve the readability, maintainability, and overall quality
    of C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: One common code standard for C++ is the C++ Core Guidelines ([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)),
    which were developed by Bjarne Stroustrup, the creator of C++, and a group of
    experts from industry and academia. The guidelines cover a wide range of topics,
    including naming conventions, commenting, formatting, and coding style.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular code standard for C++ is the Google C++ Style Guide ([https://google.github.io/styleguide/cppguide.html](https://google.github.io/styleguide/cppguide.html)),
    which is used by many software companies, including Google. The guide provides
    guidelines for naming conventions, commenting, formatting, and coding style, as
    well as recommendations for using specific C++ features and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these widely followed standards, there are also many other code
    standards that have been developed by individual organizations and teams, for
    example, LLVM Coding Standards, WebKit, and Mozilla’s style guides.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a project conforms with a specific code convention, it is easier to read
    it, and as a bonus, the code base becomes more *grepable*. Consider needing to
    find the places where a variable called `request_id` is assigned. It can be easily
    achieved via the `grep` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code reviewers used to spend hours catching and commenting on inconsistencies
    with code format during peer review. Luckily, today we have tools such as Clang-Tidy
    and Clang-Format that allow us to ensure the consistency of the code format automatically
    via code editors and **continuous integration** (**CI**). We will dive deeper
    into their configuration later in this book in [*Chapter 10*](B19606_10.xhtml#_idTextAnchor184).
  prefs: []
  type: TYPE_NORMAL
- en: Language features limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is a powerful language; as we know, great power comes with great responsibility.
    It is not easy for engineers, especially those who have not spent decades writing
    C++ code, to grasp the complexity of the language. As a result, some companies
    decide to limit the features used in their projects. The limitations may include
    a ban for multiple inheritance, usage of exceptions, and minimal usage of macros,
    templates, and specific third-party libraries. Additionally, the regulations may
    come from the use of legacy libraries. For example, if most of the code does not
    support C++ exceptions, it might be a bad idea to add them to new pieces of code
    without a prior understanding of the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: General guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is always a good idea to have general guidelines for a project. The guidelines
    often cover the preferred way of working on the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Usage of raw pointers, if allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How values are returned from getters and provided to setters (by value or reference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use of code comments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are comments allowed in general?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of strategic and tactical comments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comment style: free, Doxygen, and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding standards are necessary to help ensure code quality, consistency, interoperability,
    portability, efficiency, and collaboration. By following coding standards, programmers
    can write better code that is easier to understand, maintain, and use and works
    better and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Readability, efficiency, maintainability, and usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readability, efficiency, maintainability, and usability are all critical factors
    to consider when writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readability refers to the ease with which a human reader can understand a piece
    of code. Well-written code is easy to read, with clear and concise statements
    that are organized in a logical and consistent manner. This becomes very important
    if we consider that developers spend ten times more time reading code than writing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example is an exaggerated example of code not following any code convention.
    A developer using the `Employee` class can understand that all three methods are
    getters. However, the differences in the names make the user spend more time understanding
    the code or trying to understand the reasoning behind the names. Do the methods
    have different names because programmers did not care about the uniformity of
    the class? Or because, for example, methods without the `get` prefix are simple
    getters, and ones that contain the `get` prefix fetch the data from a file or
    a database?
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, do the methods without `const` change the object’s state (via
    caching, for example), or is it a mistake? Do you see how many questions can be
    raised? They can be answered only when a developer jumps into the corresponding
    implementation, which means time is wasted. Making the code look uniform across
    the code base helps developers to understand the meanings and complications of
    classes, methods, and functions by looking at their declarations in the header
    files or even via autocompletion in modern code editors.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Efficiency refers to the ability of a piece of code to perform its intended
    tasks in an efficient manner. Efficient code uses few resources, such as time
    and memory, to accomplish a task, and is able to handle large amounts of data
    and traffic without slowing down or crashing. By improving the efficiency of code,
    programmers can save time and resources and can ensure that their code is scalable
    and can handle the demands of a growing user base.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are surefire ways to optimize C++ code, such as passing read-only parameters
    by constant reference to avoid unnecessary copying, or using the character-overloaded
    version of `std::string::find` when looking for a single character to avoid string
    a creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, the more systematic way to achieve and maintain code efficiency is
    to follow the Pareto principle. This principle, when applied to software engineering,
    says that roughly 20% of the code does 80% of the work. For example, usually,
    there is no need to optimize the code parsing config files on startup of a background
    daemon because it happens only once during the program’s lifetime. However, it
    might be important to avoid copying large data structures in the main flow. The
    optimal way to improve the efficiency includes picking this 20% of performance-critical
    code and adding benchmarks for it. The benchmarks are expected to run as part
    of the CI process to make sure that no degradation is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, end-to-end testing can measure the overall performance of the
    application. This book discusses the best practices of writing unit tests and
    end-to-end tests in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260). It is important
    to note that the automated tools cannot replace an engineer doing code reviews
    for the new code, mainly because there is no tool that can find the 20% of the
    code that does 80% of the work.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maintainability refers to the ease with which a piece of code can be updated
    and modified over time. Well-written code is easy to maintain, with clear and
    well-documented code that is organized in a logical and consistent manner. By
    improving the maintainability of code, programmers can make it easier for others
    to update and modify their code and can ensure that their code remains relevant
    and useful over time. Ideally, while developing new components, developers should
    think about the current problems the code is solving and the future usage and
    extension of the code. For example, while developing support for a data provider,
    it might be useful to ask whether the provider is going to be the only one supported.
    If not, it might be helpful to think about the standard features of data providers
    and extract them in an abstract base class. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `DataProvider` class is an abstract base class that defines
    the interface for providing data. The `NetworkDataProvider` and `FileDataProvider`
    classes are derived from `DataProvider` and override the `getData` virtual function
    to provide the specific implementation for reading data from a file or a network
    endpoint, respectively. This design makes it easy to add new data sources by simply
    creating a new class derived from `DataProvider` and providing the appropriate
    implementation for the `getData` virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is clear from the example that the base interface may include not only the
    functionality but also the copy-move policy of the object. Later, the user code
    can receive the data provider(s) with reference to the base class and be agnostic
    to the type of provider, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, this inheritance can be used for mocking data providers while
    creating unit tests for `DataParser`. Unit tests are covered in detail in [*Chapter
    13*](B19606_13.xhtml#_idTextAnchor260).
  prefs: []
  type: TYPE_NORMAL
- en: 'On a side note, it is crucial not to make code overcomplicated, or to be ready
    for any change. Otherwise, the need to make everything extendable may lead to
    monsters such as the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This class hierarchy is unnecessarily complicated because it uses almost every
    C++ feature: inheritance, templates, and macros. While using inheritance with
    templates is a common practice, macros are seen as an anti-pattern nowadays. In
    this example, the `Derived` class adds very little additional functionality compared
    to the `Base` class, and it would be more straightforward to simply add the `getValue`
    method directly to the `Base` class. Using inheritance and templates can be useful
    in certain situations, but it’s important to use them appropriately and not overuse
    them. Macros can be particularly difficult to understand and maintain because
    they are expanded by the preprocessor before the code is compiled, so it can be
    hard to see what the actual code looks like. It’s generally better to use functions
    or template functions instead of macros whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: If the probability of extension is low, keeping its structure simple and close
    to basic needs is better. How do you decide what approach to take? Well, calm
    consideration and code review is the way to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usability refers to the ease with which a piece of code can be used by others.
    Well-written code is easy to use, with clear and intuitive interfaces and documentation
    that make it easy for others to understand and use the code. By improving the
    usability of code, programmers can make their code more accessible and useful
    to others and can ensure that their code is widely adopted and used.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, readability, efficiency, maintainability, and usability are all important
    factors to consider when writing code. By improving these factors, programmers
    can write better code that is easier to understand, maintain, and use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the concept of good and bad code. Good code
    is well written, efficient, and easy to understand and maintain. It follows coding
    standards and best practices and is less prone to errors. On the other hand, bad
    code is poorly written, inefficient, and difficult to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also introduced the concept of technical debt, which refers to the
    accumulation of poor-quality code that needs to be refactored or rewritten. Technical
    debt can be costly and time-consuming to fix and can hinder the development of
    new features or functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of code standards was also emphasized in the chapter. Code standards
    are guidelines or rules that dictate how code should be written, formatted, and
    structured. Adhering to code standards helps to ensure that code is consistent,
    easy to understand, and maintainable. It also makes it easier for multiple developers
    to work on the same code base and helps to prevent errors and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the chapter emphasized the importance of writing good quality code
    and adhering to code standards in order to avoid technical debt and ensure the
    long-term success and maintainability of a software project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into the world of software design principles.
    Specifically, we will focus on the SOLID principles, a set of guidelines that
    aim to improve the design of software systems by making them more maintainable,
    flexible, and scalable. Each of the principles will be explained in detail in
    the next chapter, along with examples of how they can be applied to real-world
    software development scenarios.
  prefs: []
  type: TYPE_NORMAL
