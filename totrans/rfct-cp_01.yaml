- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Coding Standards in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 编程规范
- en: In this chapter, we will delve into the world of clean code and examine its
    crucial role in successful software projects. We will discuss the concept of technical
    debt and how poor-quality code can contribute to its accumulation. Additionally,
    we will explore the often undervalued practices of code formatting and documentation,
    which are crucial for maintaining a manageable and effective code base. Through
    this chapter, we will understand that clean code is not just nice to have but
    a necessity for any project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨干净代码的世界，并检查它在成功软件项目中的关键作用。我们将讨论技术债务的概念以及低质量代码如何导致其积累。此外，我们还将探讨通常被低估的代码格式化和文档化实践，这些对于维护可管理和有效的代码库至关重要。通过本章，我们将理解干净的代码不仅仅是锦上添花，而是任何项目的必需品。
- en: We will discuss the importance of coding standards and introduce common conventions
    and best practices used in the C++ community. By the end of this chapter, you
    will better understand what clean code is, why it is essential, and why documenting
    code is crucial.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论编程规范的重要性，并介绍在 C++ 社区中使用的常见约定和最佳实践。到本章结束时，你将更好地理解什么是干净的代码，为什么它至关重要，以及为什么记录代码是至关重要的。
- en: The difference between good code and bad code
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好的代码和坏的代码之间的区别
- en: There is no strict definition of good or clean code. Moreover, no automatic
    tool can measure the quality of code. There are linters, code checkers, and other
    analyzers that can help to make code better. These tools are very valuable and
    highly recommended, but not sufficient. Artificial Intelligence may take over
    and develop code for us, but in the end, its measurement of code quality will
    be based on our human ideas of good code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好的或干净的代码没有严格的定义。此外，没有自动工具可以衡量代码的质量。有代码检查器、代码检查工具和其他分析器可以帮助使代码更好。这些工具非常有价值，并且强烈推荐，但并不足够。人工智能可能会接管并为我们编写代码，但最终，它对代码质量的衡量将基于我们对好代码的人类想法。
- en: 'Programming languages were initially developed to provide an interface between
    machines and developers; however, with the growth of software products’ complexity,
    it becomes clear that nowadays, it is mostly a way of communicating ideas and
    intentions between developers. It is a well-known fact that developers spend ten
    times more time reading the code than writing it. It means that to be efficient,
    we must do our best to make the reading easier. The most successful way to make
    this process efficient is to make the code predictable or, even better, boring.
    By boring, I mean code that the reader looks at and knows what to expect from
    it regarding functionality, performance, and side effects. The following example
    illustrates an interface for a class retrieving objects from a database:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言最初是为了在机器和开发者之间提供一个接口而开发的；然而，随着软件产品复杂性的增长，现在很明显，它主要是开发者之间沟通想法和意图的一种方式。众所周知，开发者花在阅读代码上的时间是编写代码的十倍。这意味着为了提高效率，我们必须尽力使阅读变得更容易。使这个过程高效的最成功的方式是使代码可预测，甚至更好，是无聊的。这里的“无聊”是指读者看到代码时就能知道它将如何从功能、性能和副作用方面进行预期。以下是一个从数据库中检索对象的类的接口示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It supports two lookup modes, by `id` and by `name`; it is not supposed to change
    the internal state of the `Database` object because of the `const` modifier; and
    it can only do read operations against the database instance. It is boring, but
    it meets basic expectations. Imagine how surprising it can be to find out during
    critical bug investigation that on each read operation, it does an update operation
    and sometimes a delete operation?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持两种查找模式，通过 `id` 和通过 `name`；它不应该因为 `const` 修饰符而改变 `Database` 对象的内部状态；并且它只能对数据库实例执行读取操作。它是无聊的，但符合基本预期。想象一下，在关键错误调查期间发现，在每次读取操作中，它都执行更新操作，有时甚至执行删除操作，这会有多令人惊讶？
- en: As readers can see, a few key factors can distinguish good code and bad code.
    Good code is typically well written, easy to read, and efficient. It follows the
    conventions and standards of the C++ language and is organized in a logical and
    consistent manner. Good code is also well documented, often with clear comments
    explaining the purpose and function of things that are not obvious from reading
    only the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如读者所看到的，几个关键因素可以区分好的代码和坏的代码。好的代码通常是写得很好、易于阅读且高效的。它遵循 C++ 语言的约定和标准，并以逻辑和一致的方式组织。好的代码也具有良好的文档，通常包含清晰的注释，解释那些仅从代码阅读中不明显的内容的目的和功能。
- en: Why coding standards are important
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么编程规范很重要
- en: Coding standards are important for several reasons. First and foremost, they
    help to minimize *technical debt*. Technical debt, also known as “code debt,”
    is a metaphor that describes the cost of maintaining and modifying code that is
    not well designed or well written. Just as financial debt incurs interest and
    requires ongoing payments, technical debt incurs additional costs in the form
    of the time and effort needed to maintain and modify poorly designed code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准的重要性有多个原因。首先，它们有助于最小化技术债务。技术债务，也称为“代码债务”，是一个隐喻，描述了维护和修改设计不佳或编写不佳的代码的成本。正如财务债务会产生利息并需要持续支付一样，技术债务会以维护和修改设计不佳的代码所需的时间和精力为形式产生额外的成本。
- en: Technical debt can accumulate in many ways, such as through hacky or quick-fix
    solutions to problems or by ignoring best practices or coding standards. As technical
    debt accumulates, it can become increasingly difficult and time-consuming to modify
    and maintain the code, which can negatively impact the efficiency and effectiveness
    of a development team.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务可以通过多种方式积累，例如通过解决问题的快速修复或忽略最佳实践或编码标准。随着技术债务的积累，修改和维护代码变得越来越困难和耗时，这可能会对开发团队的效率和效果产生负面影响。
- en: In order to manage technical debt carefully, it is essential to try to avoid
    accumulating too much of it, as it can become a significant burden on a development
    team. Strategies for managing technical debt include regularly refactoring code
    to improve its design and maintainability, following best practices and coding
    standards, and actively seeking out opportunities to improve the quality of the
    code. Overall, managing technical debt is an important aspect of good code design
    and development and can help to ensure that code is efficient, reliable, and easy
    to work with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了谨慎管理技术债务，避免积累过多的债务至关重要，因为它可能会成为开发团队的沉重负担。管理技术债务的策略包括定期重构代码以改进其设计和可维护性，遵循最佳实践和编码标准，以及积极寻求提高代码质量的机会。总的来说，管理技术债务是良好代码设计和开发的重要方面，有助于确保代码高效、可靠且易于工作。
- en: Coding standards help to ensure the quality and consistency of code. By establishing
    a set of guidelines and conventions for writing code, coding standards help to
    ensure that code is well written, easy to read, and easy to understand. This makes
    it easier for others to maintain and update the code and helps to prevent errors
    and bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准有助于确保代码的质量和一致性。通过建立编写代码的指南和惯例，编码标准有助于确保代码编写良好、易于阅读和理解。这使得其他人更容易维护和更新代码，并有助于防止错误和缺陷。
- en: In addition, they help to improve the efficiency of code. By following established
    conventions and best practices, programmers can write code that is more efficient
    and performs better. This can save time and resources and help ensure that code
    is scalable and can handle large amounts of data and traffic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们有助于提高代码的效率。通过遵循既定惯例和最佳实践，程序员可以编写更高效且性能更好的代码。这可以节省时间和资源，并有助于确保代码可扩展并能处理大量数据和流量。
- en: Furthermore, coding standards promote collaboration and teamwork among programmers.
    By establishing a common set of guidelines and conventions, coding standards make
    it easier for teams of programmers to work together on a project. This allows
    better communication and coordination and helps to ensure that everyone is on
    the same page and working towards the same goals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编码标准促进了程序员之间的协作和团队合作。通过建立一套共同的指南和惯例，编码标准使得程序员团队更容易在项目上合作。这促进了更好的沟通和协调，并有助于确保每个人都处于同一页面上，朝着相同的目标努力。
- en: Coding standards often promote the interoperability and portability of code.
    By following a standardized set of conventions, code written by one programmer
    can be easily understood and used by another programmer. This allows code to be
    more easily integrated into larger projects and helps to ensure that it can be
    used on a variety of different platforms and operating systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准通常促进代码的互操作性和可移植性。通过遵循标准化的惯例集，一位程序员编写的代码可以很容易地被另一位程序员理解和使用。这使得代码更容易集成到更大的项目中，并有助于确保它可以在各种不同的平台和操作系统上使用。
- en: The C++ programming language is probably one of the richest languages in terms
    of features. It started as *C with classes*, providing object-oriented support
    with high performance and almost complete compatibility with C; later on, template
    metaprogramming was introduced, and Stepanov and Lee developed the Standard Template
    Library, nowadays known as the C++ Standard Library. Modern C++ (C++11 and newer
    versions) provides extensive support for multiple programming paradigms, including
    procedural, object-oriented, generic, and functional programming. It offers features
    such as lambda expressions, range-based `for` loops, smart pointers, and type
    inference that enable functional programming techniques. Additionally, C++ provides
    support for object-oriented programming concepts such as inheritance, encapsulation,
    and polymorphism. It also offers template metaprogramming, which enables generic
    programming and allows compile-time optimizations. Furthermore, C++ provides concurrency
    support with features such as threads, atomic types, and futures, making it easier
    to write concurrent and parallel code. This flexibility is key to the strength
    of the language but often leads to problems with maintainability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++编程语言可能是功能最丰富的编程语言之一。它起源于“带有类的C语言”，提供了高性能和几乎与C语言完全兼容的对象支持；后来引入了模板元编程，斯蒂潘诺夫和李共同开发了现在被称为C++标准库的C++标准模板库。现代C++（C++11及更高版本）为多种编程范式提供了广泛的支持，包括过程式、面向对象、泛型和函数式编程。它提供了诸如lambda表达式、基于范围的`for`循环、智能指针和类型推断等特性，这些特性使得函数式编程技术得以实现。此外，C++还提供了面向对象编程概念的支持，如继承、封装和多态。它还提供了模板元编程，这使泛型编程成为可能，并允许编译时优化。此外，C++还提供了线程、原子类型和未来等并发支持特性，使得编写并发和并行代码变得更加容易。这种灵活性是语言强大之所在，但往往会导致可维护性问题。
- en: A developer has to understand the concepts of the paradigms we’ve mentioned,
    how to use them together, and how they eventually affect the performance of the
    code. This is when coding standards can help to explain the complexity of the
    code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须理解我们提到的范式概念，如何将它们结合使用，以及它们最终如何影响代码的性能。这时，编码标准可以帮助解释代码库的复杂性。
- en: All these factors make coding guidelines the bare minimum that a modern C++
    project should have to attain a quality standard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素使得编码规范成为现代C++项目达到质量标准所必须具备的最低要求。
- en: Code convention
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码规范
- en: Contrary to languages such as Python, Go, Java, and many others, C++ does not
    have a common code convention.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python、Go、Java和其他许多语言不同，C++没有统一的代码规范。
- en: 'There are several popular coding conventions for the C++ programming language.
    Here are some common conventions that are widely followed:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++编程语言，存在几种流行的编码规范。以下是一些广泛遵循的常见规范：
- en: '`total_cost` or `customer_name`. Class variables often have prefixes or suffixes
    to distinguish them from other variables, such as `m_user_count` or `user_count_`.
    Functions may be named using *camelCase*, with the first letter of each word (apart
    from the first word) capitalized, such as `calculateTotalCost` or `getCustomerName`.
    Classes may be named using *PascalCase*, with the first letter of each word capitalized,
    such as `Customer` or `Invoice`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total_cost`或`customer_name`。类变量通常会有前缀或后缀以区分它们与其他变量，例如`m_user_count`或`user_count_`。函数的命名可以使用*camelCase*，每个单词的首字母（除了第一个单词）大写，例如`calculateTotalCost`或`getCustomerName`。类的命名可以使用*PascalCase*，每个单词的首字母大写，例如`Customer`或`Invoice`。'
- en: '**Commenting**: Commenting conventions specify how to write and format comments
    in code. Comments are used to provide explanations and documentation for code
    and should be clear and concise. It is often recommended to use inline comments
    to explain specific lines of code, as well as block comments to provide an overview
    of a code block or function.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释**：注释规范规定了如何编写和格式化代码中的注释。注释用于提供代码的解释和文档，应清晰简洁。通常建议使用内联注释来解释特定的代码行，以及使用块注释来提供代码块或函数的概述。'
- en: '`for` loop or `if` statement, to visually indicate the structure of the code.
    Formatting policy often covers asterisk (`*`) and ampersand (`&`) alignment in
    pointers and references (e.g., `int* ptr` versus `int *ptr` or `Socket &socket`
    versus `Socket& socket`), curly braces position (same line, next line, or context
    dependent). This book covers aspects of automated formatting in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环或`if`语句，以视觉上表示代码的结构。格式化策略通常包括指针和引用中的星号（`*`）和和号（`&`）对齐（例如，`int* ptr`与`int
    *ptr`或`Socket &socket`与`Socket& socket`），大括号的位置（同一行、下一行或上下文相关）。本书将在[第13章](B19606_13.xhtml#_idTextAnchor260)中涵盖自动化格式化的方面。'
- en: '`goto` operators.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto`运算符。'
- en: It is important to note that there may be variations in coding conventions between
    different organizations and teams. It is important to follow the conventions that
    your team or organization establishes or to define your own conventions if none
    are specified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，不同组织和团队之间的编码规范可能会有所不同。重要的是要遵循你的团队或组织建立的规范，或者如果没有指定，则定义你自己的规范。
- en: It can be tedious to develop a coding convention; some companies prefer to use
    an existing one and adapt it to their needs. In the C++ programming language,
    there are several popular code standards that are widely followed by developers.
    These standards aim to improve the readability, maintainability, and overall quality
    of C++ code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 制定编码规范可能会很繁琐；一些公司更愿意使用现有的规范并将其适应他们的需求。在C++编程语言中，有几个流行的代码规范被开发者广泛遵循。这些标准旨在提高C++代码的可读性、可维护性和整体质量。
- en: One common code standard for C++ is the C++ Core Guidelines ([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)),
    which were developed by Bjarne Stroustrup, the creator of C++, and a group of
    experts from industry and academia. The guidelines cover a wide range of topics,
    including naming conventions, commenting, formatting, and coding style.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C++的一个常见代码规范是C++核心指南([https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines))，它是由C++的创造者Bjarne
    Stroustrup以及来自工业和学术界的一组专家开发的。这些指南涵盖了广泛的主题，包括命名约定、注释、格式化和编码风格。
- en: Another popular code standard for C++ is the Google C++ Style Guide ([https://google.github.io/styleguide/cppguide.html](https://google.github.io/styleguide/cppguide.html)),
    which is used by many software companies, including Google. The guide provides
    guidelines for naming conventions, commenting, formatting, and coding style, as
    well as recommendations for using specific C++ features and libraries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的C++代码规范是Google C++风格指南([https://google.github.io/styleguide/cppguide.html](https://google.github.io/styleguide/cppguide.html))，它被许多软件公司，包括谷歌，所采用。该指南提供了关于命名约定、注释、格式化和编码风格的指南，以及使用特定C++功能和库的建议。
- en: In addition to these widely followed standards, there are also many other code
    standards that have been developed by individual organizations and teams, for
    example, LLVM Coding Standards, WebKit, and Mozilla’s style guides.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些广泛遵循的标准之外，还有许多其他由个人组织或团队开发的代码规范，例如LLVM编码规范、WebKit和Mozilla的风格指南。
- en: 'If a project conforms with a specific code convention, it is easier to read
    it, and as a bonus, the code base becomes more *grepable*. Consider needing to
    find the places where a variable called `request_id` is assigned. It can be easily
    achieved via the `grep` utility:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目符合特定的代码规范，阅读起来会更加容易，而且作为额外的好处，代码库会变得更加*可grep*。考虑需要找到名为`request_id`的变量被赋值的地方。这可以通过`grep`实用程序轻松实现：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code reviewers used to spend hours catching and commenting on inconsistencies
    with code format during peer review. Luckily, today we have tools such as Clang-Tidy
    and Clang-Format that allow us to ensure the consistency of the code format automatically
    via code editors and **continuous integration** (**CI**). We will dive deeper
    into their configuration later in this book in [*Chapter 10*](B19606_10.xhtml#_idTextAnchor184).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查员过去常常花费数小时在同行评审期间捕捉和评论代码格式的不一致性。幸运的是，今天我们有Clang-Tidy和Clang-Format这样的工具，允许我们通过代码编辑器和**持续集成**（**CI**）自动确保代码格式的统一性。我们将在本书的[第10章](B19606_10.xhtml#_idTextAnchor184)中更深入地探讨它们的配置。
- en: Language features limitations
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言特性限制
- en: C++ is a powerful language; as we know, great power comes with great responsibility.
    It is not easy for engineers, especially those who have not spent decades writing
    C++ code, to grasp the complexity of the language. As a result, some companies
    decide to limit the features used in their projects. The limitations may include
    a ban for multiple inheritance, usage of exceptions, and minimal usage of macros,
    templates, and specific third-party libraries. Additionally, the regulations may
    come from the use of legacy libraries. For example, if most of the code does not
    support C++ exceptions, it might be a bad idea to add them to new pieces of code
    without a prior understanding of the outcome.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种强大的语言；正如我们所知，强大的力量伴随着巨大的责任。对于工程师来说，尤其是那些没有花费几十年时间编写C++代码的人来说，掌握这种语言的复杂性并不容易。因此，一些公司决定限制他们在项目中使用的功能。这些限制可能包括禁止多重继承、使用异常以及最小化使用宏、模板和特定的第三方库。此外，这些规定可能来自对遗留库的使用。例如，如果大部分代码不支持C++异常，那么在没有事先了解结果的情况下，将它们添加到新的代码片段中可能不是一个好主意。
- en: General guidelines
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用指南
- en: 'It is always a good idea to have general guidelines for a project. The guidelines
    often cover the preferred way of working on the project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个项目来说，拥有一些通用指南总是好的。这些指南通常涵盖了在项目中工作的首选方式：
- en: Usage of raw pointers, if allowed
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果允许，原始指针的使用
- en: How values are returned from getters and provided to setters (by value or reference)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器如何返回值以及如何提供给设置器（按值或引用）
- en: 'Use of code comments:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码注释的使用：
- en: Are comments allowed in general?
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否允许一般性地使用注释？
- en: Usage of strategic and tactical comments
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略性和战术性注释的使用
- en: 'Comment style: free, Doxygen, and so on'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释风格：自由、Doxygen等
- en: Coding standards are necessary to help ensure code quality, consistency, interoperability,
    portability, efficiency, and collaboration. By following coding standards, programmers
    can write better code that is easier to understand, maintain, and use and works
    better and more efficiently.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准是必要的，以确保代码质量、一致性、互操作性、可移植性、效率和协作。通过遵循编码标准，程序员可以编写更好的代码，这些代码更容易理解、维护和使用，并且工作得更好、更高效。
- en: Readability, efficiency, maintainability, and usability
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性、效率、可维护性和可用性
- en: Readability, efficiency, maintainability, and usability are all critical factors
    to consider when writing code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性、效率、可维护性和可用性都是在编写代码时需要考虑的关键因素。
- en: Readability
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性
- en: Readability refers to the ease with which a human reader can understand a piece
    of code. Well-written code is easy to read, with clear and concise statements
    that are organized in a logical and consistent manner. This becomes very important
    if we consider that developers spend ten times more time reading code than writing
    it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性指的是人类读者理解一段代码的容易程度。编写良好的代码易于阅读，具有清晰、简洁的语句，这些语句以逻辑和一致的方式组织。如果我们考虑到开发者阅读代码的时间是编写代码时间的十倍，这一点就变得非常重要。
- en: 'Let’s take a look at the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下这段代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example is an exaggerated example of code not following any code convention.
    A developer using the `Employee` class can understand that all three methods are
    getters. However, the differences in the names make the user spend more time understanding
    the code or trying to understand the reasoning behind the names. Do the methods
    have different names because programmers did not care about the uniformity of
    the class? Or because, for example, methods without the `get` prefix are simple
    getters, and ones that contain the `get` prefix fetch the data from a file or
    a database?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个夸张的例子，展示了代码没有遵循任何编码约定。使用`Employee`类的开发者可以理解这三个方法都是获取器。然而，名称上的差异使得用户花费更多的时间来理解代码或试图理解名称背后的原因。这些方法名称不同是因为程序员没有关心类的统一性吗？还是因为，例如，没有`get`前缀的方法是简单的获取器，而包含`get`前缀的方法是从文件或数据库中获取数据？
- en: Additionally, do the methods without `const` change the object’s state (via
    caching, for example), or is it a mistake? Do you see how many questions can be
    raised? They can be answered only when a developer jumps into the corresponding
    implementation, which means time is wasted. Making the code look uniform across
    the code base helps developers to understand the meanings and complications of
    classes, methods, and functions by looking at their declarations in the header
    files or even via autocompletion in modern code editors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有`const`的方法是否会改变对象的状态（例如通过缓存），或者这是一个错误？你看到有多少问题可以提出吗？这些问题只有在开发者跳入相应的实现时才能回答，这意味着浪费了时间。使代码在代码库中看起来一致有助于开发者通过查看头文件中的声明或甚至通过现代代码编辑器的自动完成来理解类、方法和函数的含义和复杂性。
- en: Efficiency
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效率
- en: Efficiency refers to the ability of a piece of code to perform its intended
    tasks in an efficient manner. Efficient code uses few resources, such as time
    and memory, to accomplish a task, and is able to handle large amounts of data
    and traffic without slowing down or crashing. By improving the efficiency of code,
    programmers can save time and resources and can ensure that their code is scalable
    and can handle the demands of a growing user base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 效率指的是一段代码以高效的方式执行其预期任务的能力。高效的代码使用很少的资源，例如时间和内存，来完成一项任务，并且能够处理大量数据和流量而不会减慢或崩溃。通过提高代码的效率，程序员可以节省时间和资源，并确保他们的代码可扩展并能处理不断增长的用户群体的需求。
- en: 'There are surefire ways to optimize C++ code, such as passing read-only parameters
    by constant reference to avoid unnecessary copying, or using the character-overloaded
    version of `std::string::find` when looking for a single character to avoid string
    a creation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 优化C++代码有可靠的方法，例如通过常量引用传递只读参数以避免不必要的复制，或者在查找单个字符时使用`std::string::find`的字符重载版本以避免创建字符串：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, the more systematic way to achieve and maintain code efficiency is
    to follow the Pareto principle. This principle, when applied to software engineering,
    says that roughly 20% of the code does 80% of the work. For example, usually,
    there is no need to optimize the code parsing config files on startup of a background
    daemon because it happens only once during the program’s lifetime. However, it
    might be important to avoid copying large data structures in the main flow. The
    optimal way to improve the efficiency includes picking this 20% of performance-critical
    code and adding benchmarks for it. The benchmarks are expected to run as part
    of the CI process to make sure that no degradation is introduced.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现并维持代码效率的更系统的方法是遵循帕累托原则。当应用于软件工程时，这个原则表明大约20%的代码完成了80%的工作。例如，通常在后台守护进程启动时优化代码解析配置文件是没有必要的，因为这仅在程序的生命周期中发生一次。然而，避免在主流程中复制大型数据结构可能很重要。提高效率的最佳方式包括选择这20%的性能关键代码并为它添加基准测试。这些基准测试预计将作为CI过程的一部分运行，以确保没有引入退化。
- en: Additionally, end-to-end testing can measure the overall performance of the
    application. This book discusses the best practices of writing unit tests and
    end-to-end tests in [*Chapter 13*](B19606_13.xhtml#_idTextAnchor260). It is important
    to note that the automated tools cannot replace an engineer doing code reviews
    for the new code, mainly because there is no tool that can find the 20% of the
    code that does 80% of the work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，端到端测试可以衡量应用程序的整体性能。本书在[*第13章*](B19606_13.xhtml#_idTextAnchor260)中讨论了编写单元测试和端到端测试的最佳实践。需要注意的是，自动化工具不能取代工程师对新代码进行代码审查，主要是因为没有工具能够找到那20%的代码，而这20%的代码完成了80%的工作。
- en: Maintainability
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: 'Maintainability refers to the ease with which a piece of code can be updated
    and modified over time. Well-written code is easy to maintain, with clear and
    well-documented code that is organized in a logical and consistent manner. By
    improving the maintainability of code, programmers can make it easier for others
    to update and modify their code and can ensure that their code remains relevant
    and useful over time. Ideally, while developing new components, developers should
    think about the current problems the code is solving and the future usage and
    extension of the code. For example, while developing support for a data provider,
    it might be useful to ask whether the provider is going to be the only one supported.
    If not, it might be helpful to think about the standard features of data providers
    and extract them in an abstract base class. Here’s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性指的是代码随时间推移进行更新和修改的容易程度。编写良好的代码易于维护，具有清晰且文档齐全的代码，这些代码以逻辑和一致的方式组织。通过提高代码的可维护性，程序员可以使他人更容易更新和修改他们的代码，并确保代码在长时间内保持相关性和实用性。理想情况下，在开发新组件时，开发者应该考虑代码当前解决的问题以及代码的未来使用和扩展。例如，在开发数据提供者支持时，考虑该提供者是否将是唯一支持的对象可能是有用的。如果不是，考虑数据提供者的标准特性并将它们提取到抽象基类中可能是有帮助的。以下是一个示例：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `DataProvider` class is an abstract base class that defines
    the interface for providing data. The `NetworkDataProvider` and `FileDataProvider`
    classes are derived from `DataProvider` and override the `getData` virtual function
    to provide the specific implementation for reading data from a file or a network
    endpoint, respectively. This design makes it easy to add new data sources by simply
    creating a new class derived from `DataProvider` and providing the appropriate
    implementation for the `getData` virtual function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DataProvider` 类是一个抽象基类，它定义了提供数据时的接口。`NetworkDataProvider` 和 `FileDataProvider`
    类从 `DataProvider` 派生出来，并覆盖了 `getData` 虚拟函数，分别提供从文件或网络端点读取数据的特定实现。这种设计使得通过简单地创建一个从
    `DataProvider` 派生的新的类并提供 `getData` 虚拟函数的适当实现，可以轻松地添加新的数据源。
- en: 'It is clear from the example that the base interface may include not only the
    functionality but also the copy-move policy of the object. Later, the user code
    can receive the data provider(s) with reference to the base class and be agnostic
    to the type of provider, as shown in the following snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，基接口可能不仅包括功能，还包括对象的复制-移动策略。随后，用户代码可以通过基类引用接收数据提供者，并对提供者的类型一无所知，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Additionally, this inheritance can be used for mocking data providers while
    creating unit tests for `DataParser`. Unit tests are covered in detail in [*Chapter
    13*](B19606_13.xhtml#_idTextAnchor260).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种继承可以在为 `DataParser` 创建单元测试时模拟数据提供者。单元测试在[*第13章*](B19606_13.xhtml#_idTextAnchor260)中详细讨论。
- en: 'On a side note, it is crucial not to make code overcomplicated, or to be ready
    for any change. Otherwise, the need to make everything extendable may lead to
    monsters such as the following snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，不要使代码过于复杂，或准备好应对任何变化，这一点至关重要。否则，需要使一切可扩展的需求可能会导致如下所示的怪物：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This class hierarchy is unnecessarily complicated because it uses almost every
    C++ feature: inheritance, templates, and macros. While using inheritance with
    templates is a common practice, macros are seen as an anti-pattern nowadays. In
    this example, the `Derived` class adds very little additional functionality compared
    to the `Base` class, and it would be more straightforward to simply add the `getValue`
    method directly to the `Base` class. Using inheritance and templates can be useful
    in certain situations, but it’s important to use them appropriately and not overuse
    them. Macros can be particularly difficult to understand and maintain because
    they are expanded by the preprocessor before the code is compiled, so it can be
    hard to see what the actual code looks like. It’s generally better to use functions
    or template functions instead of macros whenever possible.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类层次结构不必要地复杂，因为它几乎使用了所有的 C++ 特性：继承、模板和宏。虽然使用模板与继承是常见的做法，但宏现在被视为一种反模式。在这个例子中，`Derived`
    类与 `Base` 类相比，添加的功能非常少，直接将 `getValue` 方法添加到 `Base` 类中会更直接。在某些情况下，使用继承和模板可能是有用的，但重要的是要适当地使用它们，不要过度使用。宏可能特别难以理解和维护，因为它们在代码编译之前由预处理器展开，因此很难看到实际的代码样子。在可能的情况下，通常最好使用函数或模板函数而不是宏。
- en: If the probability of extension is low, keeping its structure simple and close
    to basic needs is better. How do you decide what approach to take? Well, calm
    consideration and code review is the way to find out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果扩展的可能性较低，保持其结构简单且接近基本需求是更好的选择。你如何决定采取哪种方法？嗯，冷静的考虑和代码审查是找到答案的方法。
- en: Usability
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用性
- en: Usability refers to the ease with which a piece of code can be used by others.
    Well-written code is easy to use, with clear and intuitive interfaces and documentation
    that make it easy for others to understand and use the code. By improving the
    usability of code, programmers can make their code more accessible and useful
    to others and can ensure that their code is widely adopted and used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性指的是其他人使用一段代码的容易程度。编写良好的代码易于使用，具有清晰直观的界面和文档，使其他人容易理解和使用代码。通过提高代码的可用性，程序员可以使他们的代码更容易被他人访问和使用，并确保他们的代码被广泛采用和使用。
- en: Overall, readability, efficiency, maintainability, and usability are all important
    factors to consider when writing code. By improving these factors, programmers
    can write better code that is easier to understand, maintain, and use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，可读性、效率、可维护性和可用性都是在编写代码时需要考虑的重要因素。通过提高这些因素，程序员可以编写出更容易理解、维护和使用的优质代码。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the concept of good and bad code. Good code
    is well written, efficient, and easy to understand and maintain. It follows coding
    standards and best practices and is less prone to errors. On the other hand, bad
    code is poorly written, inefficient, and difficult to understand and maintain.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了良好和糟糕代码的概念。良好的代码编写得很好，效率高，易于理解和维护。它遵循编码标准和最佳实践，并且不太容易出现错误。另一方面，糟糕的代码编写得不好，效率低下，难以理解和维护。
- en: The chapter also introduced the concept of technical debt, which refers to the
    accumulation of poor-quality code that needs to be refactored or rewritten. Technical
    debt can be costly and time-consuming to fix and can hinder the development of
    new features or functionality.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了技术债务的概念，它指的是需要重构或重写的低质量代码的积累。技术债务可能代价高昂且耗时，可能会阻碍新功能或功能的发展。
- en: The importance of code standards was also emphasized in the chapter. Code standards
    are guidelines or rules that dictate how code should be written, formatted, and
    structured. Adhering to code standards helps to ensure that code is consistent,
    easy to understand, and maintainable. It also makes it easier for multiple developers
    to work on the same code base and helps to prevent errors and bugs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也强调了代码标准的重要性。代码标准是指导或规则，规定了代码应该如何编写、格式化和结构化。遵守代码标准有助于确保代码的一致性、易于理解和维护。它还使多个开发者能够更容易地在同一代码库上工作，并有助于防止错误和缺陷。
- en: Overall, the chapter emphasized the importance of writing good quality code
    and adhering to code standards in order to avoid technical debt and ensure the
    long-term success and maintainability of a software project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章强调了编写高质量代码和遵守代码标准的重要性，以避免技术债务并确保软件项目的长期成功和可维护性。
- en: In the next chapter, we will dive into the world of software design principles.
    Specifically, we will focus on the SOLID principles, a set of guidelines that
    aim to improve the design of software systems by making them more maintainable,
    flexible, and scalable. Each of the principles will be explained in detail in
    the next chapter, along with examples of how they can be applied to real-world
    software development scenarios.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入软件设计原则的世界。具体来说，我们将关注SOLID原则，这是一组旨在通过使软件系统更易于维护、灵活和可扩展来改进软件设计的指导方针。下一章将详细解释每个原则，并附带它们如何应用于现实世界软件开发场景的示例。
