- en: 1 Establishing a Build Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to set up a 3D graphics development environment
    on your computer for Windows and Linux operating systems. You will learn which
    software tools are needed to run the demos from this book’s source code bundle:
    [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition).
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment on Microsoft Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our development environment on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Vulkan SDK for Microsoft Windows and Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the demo data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating utilities for CMake projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GLFW library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading with Taskflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our development environment on Microsoft Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will get started by setting up our development environment
    on Windows. We will go through the installation of each of the required tools
    individually and in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to start working with the examples from this book in a Microsoft Windows
    environment, you will need some essential tools to be installed in your system.
  prefs: []
  type: TYPE_NORMAL
- en: The most important one is Microsoft Visual Studio 2022\. Additional tools include
    the **Git** version control system, the **CMake** build tool, and the **Python**
    programming language. Throughout this book, we use these tools on the command
    line only, so no GUI add-ons will be required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s install each of the required tools individually.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio 2022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Follow the given steps to install Microsoft Visual Studio 2022:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://visualstudio.microsoft.com](https://visualstudio.microsoft.com)
    and download the Visual Studio 2022 Community Edition installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the installer and follow the on-screen instructions. For the purposes
    of this book, you need to have a native C++ compiler for the 64-bit Intel platform.
    Other components of the Visual Studio development environment are not required
    to run this book’s bundled sample code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Follow the given steps to install Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest Git installer from [https://git-scm.com/downloads](https://git-scm.com/downloads),
    run it, and follow the on-screen instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We assume that Git is added to the system `PATH` variable. Enable the option
    shown in the following image during installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Git from the command line and also from third-party software](img/file1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 1.1 – Git from the command line and also from third-party software
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Use Windows’ default console window**, as shown in the next screenshot.
    This option will allow you to build the scripts in this book from any directory
    on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Use Windows’ default console window](img/file2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Use Windows’ default console window
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is complex software and a huge topic in itself. We recommend the book *Mastering
    Git* written by Jakub Narębski and published by Packt Publishing, [https://www.packtpub.com/application-development/mastering-git](https://www.packtpub.com/application-development/mastering-git),
    along with *Git Essentials: Developer’s Guide to Git* by François Dupire and the
    downloadable ebook *ProGit*, Second Edition, by Scott Chacon and Ben Straub, [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install CMake, please follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest 64-bit CMake installer from [https://cmake.org/download/](https://cmake.org/download/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it and follow the on-screen instructions. If you already have an earlier
    version of CMake installed, it is recommended to uninstall it first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Add CMake to the system PATH for all users** option, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3: Add CMake to the system PATH for all users](img/file3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Add CMake to the system PATH for all users'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install Python, please follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest Python 3 installer for 64-bit systems from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it and follow the on-screen instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the installation, you also need to install the `pip` feature. Choose
    **Custom Installation** and make sure that the **pip** checkbox is checked, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Custom installation](img/file4.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 1.4 – Custom installation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the installation has completed, make sure to add the folder containing
    `python.exe` to the PATH environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides Git, there are other popular version control systems, like SVN and Mercurial.
    While developing large software systems, you will inevitably face the need to
    download some libraries from a non-Git repository. We recommend getting familiar
    with Mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: While working in the command-line environment, it is useful to have some tools
    from the Unix environment, like `wget`, `grep`, `find`, etc. The **GnuWin32**
    project provides precompiled binaries of these tools, which can be downloaded
    from [http://gnuwin32.sourceforge.net](http://gnuwin32.sourceforge.net).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, in the Windows environment, orthodox file managers make file manipulation
    a lot easier. We definitely recommend giving the open-source Far Manager a try.
    You can download it from [https://farmanager.com](https://farmanager.com). It
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The look and feel of Far Manager](img/file5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The look and feel of Far Manager
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux is becoming more and more attractive for 3D graphics development, including
    gaming technology. Let’s go through a list of tools necessary to start working
    with this book on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume you have a desktop computer with a Debian-based GNU/Linux operating
    system installed. We also assume you are familiar with the `apt` package manager.
  prefs: []
  type: TYPE_NORMAL
- en: To start developing modern graphics programs on Linux, you need to have up-to-date
    video card drivers installed that support Vulkan 1.3\. To build examples from
    this book, a C++ compiler with C++20 support is required. We tested our code with
    Clang and the GNU Compiler Collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a Debian-based system, the installation process is straightforward; however,
    before installing any of the required packages, we recommend running the following
    command to ensure your system is up to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let us go through the list of essential software and install whatever is missing.
  prefs: []
  type: TYPE_NORMAL
- en: GCC Compiler
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming you have a properly configured `apt` package manager, run the following
    command to install the GCC compiler and related tools. We tested GCC 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: CMake
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The CMake build tool is also available in the standard repositories. To install
    CMake, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: CMake 3.19 or above is sufficient for the code samples in this book.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install the Git version control system, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Python 3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install the Python 3 package, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The exact version of Python may vary between Linux distributions. Any version
    of Python 3 will suffice for the scripts in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are done with the basic packages and can install graphics-related software.
    Let us move on to the next recipe to learn how to set up the Vulkan SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Vulkan SDK for Windows and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to get started with the Vulkan SDK. We will
    describe the requirements and procedure for installing the LunarG Vulkan SDK for
    Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, it is possible to write Vulkan applications without the Vulkan
    SDK, using only C/C++ header files provided by Khronos. You can get these header
    files by cloning the Git repository: [https://github.com/KhronosGroup/Vulkan-Headers](https://github.com/KhronosGroup/Vulkan-Headers).
    However, it is advised to install the complete Vulkan SDK to be able to use Vulkan
    validation layers and a standalone GLSL compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure you have the latest up-to-date video card drivers for your operating
    system. On Windows, you can download video drivers from your GPU vendor’s website.
    For Ubuntu, refer to the documentation: [https://ubuntu.com/server/docs/nvidia-drivers-installation](https://ubuntu.com/server/docs/nvidia-drivers-installation).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Vulkan 1.3 on Linux, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the [https://www.lunarg.com/vulkan-sdk/](https://www.lunarg.com/vulkan-sdk/)
    page in a browser and download the latest Vulkan SDK for Windows or Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the download has finished, run the Windows installer file and follow
    the on-screen instructions. If you have Ubuntu 22.04 installed, use the following
    commands provided on LunarG’s website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For other Linux distributions, you may need to download the `.tar.gz` SDK archive
    from [https://vulkan.lunarg.com/sdk/home#linux](https://vulkan.lunarg.com/sdk/home#linux)
    and unpack it manually. You need to set environment variables to locate the Vulkan
    SDK components. Use the `source` command to run a config script that will do it
    for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing cross-platform applications, it is good to use similar tools
    for each platform. Since Linux supports GCC and Clang compilers, using GCC or
    Clang on Windows ensures that you avoid the most common portability issues. A
    complete package of C and C++ compilers can be downloaded from [http://www.equation.com/servlet/equation.cmd?fa=fortran](http://www.equation.com/servlet/equation.cmd?fa=fortran).
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to use GCC on Windows is to install the MSYS2 environment
    from [https://www.msys2.org](https://www.msys2.org). It features the package management
    system used in Arch Linux, **Pacman**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book’s examples use multiple open-source libraries. To manage these dependencies,
    we use a free and open-source tool called **Bootstrap**. The tool is similar to
    Google’s repo tool and works on both Windows and Linux, as well as on macOS for
    that matter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use Bootstrap to download libraries using
    the Vulkan Headers repository as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure you have Git and Python installed as described in the previous recipes.
    After that, clone the Bootstrap repository from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look into the source code bundle and run the `bootstrap.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The script will start downloading all the third-party libraries required to
    compile and run the source code bundle for this book. On Windows, the tail of
    the output should look as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once the download process is complete, we are ready to build the project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bootstrap** takes a JSON file as input, opening `bootstrap.json` from the
    current directory by default. It contains metadata of libraries we want to download;
    for example, their names, where to retrieve them from, a specific version to download,
    and so on. Besides that, each used library can have some additional instructions
    on how to build it. Those can be patches applied to the original library, unpacking
    instructions, SHA hashes to check archive integrity, and many others.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for each library can be represented by either a URL of a version
    control system repository or by an archive file with the library source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical JSON file entry corresponding to one library looks like this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The field `type` can have one of these values: `archive`, `git`, `hg`, or `svn`.
    The first value corresponds to an archive file, such as `.zip`, `.tar.gz`, or
    `.tar.bz2`, while the last three types describe different version control system
    repositories. The `url` field contains a URL of the archive file to be downloaded
    or a URL of the repository. The `revision` field can specify a particular revision,
    tag, or branch to check out.'
  prefs: []
  type: TYPE_NORMAL
- en: The complete JSON file is a comma-separated list of such entries. For this recipe,
    we have only one library to download. We will add more libraries in the next chapters.
    The accompanying source code bundle contains a JSON file with all the libraries
    used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is comprehensive documentation for this tool that describes other command-line
    options and JSON fields in great detail. It can be downloaded from [https://github.com/corporateshark/bootstrapping](https://github.com/corporateshark/bootstrapping).
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap tool does not differentiate between source code and binary assets.
    All the textures, 3D models, and other resources for your application can also
    be downloaded and kept up to date and organized in an automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the demo data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book makes use of free 3D graphics datasets as much as possible. The comprehensive
    list of large 3D datasets is maintained by Morgan McGuire – Computer Graphics
    Archive, July 2017 ([https://casual-effects.com/data](https://casual-effects.com/data)).
    We will use some large 3D models from his archive for demonstration purposes in
    this book. Let us download and patch one of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The bundled source code contains a Python script, `deploy_deps.py`, which will
    download all the required 3D models automatically. To download the entire Bistro
    dataset manually, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the [https://casual-effects.com/data/](https://casual-effects.com/data/)
    page in a browser and find the **Amazon Lumberyard Bistro** dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Download** link and allow the browser to download all the data
    files. Below is a screenshot of Morgan McGuire’s site with the download link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Amazon Lumberyard Bistro as pictured on casualeffects.com as
    a 2.4 GB download](img/file6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Amazon Lumberyard Bistro as pictured on casualeffects.com as a
    2.4 GB download
  prefs: []
  type: TYPE_NORMAL
- en: Create utilities for CMake projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will see how CMake is used to configure all the code examples
    in this book and learn some small tricks along the way.
  prefs: []
  type: TYPE_NORMAL
- en: For those who are just starting with CMake, we recommend reading the books *CMake
    Cookbook* (Radovan Bast and Roberto Di Remigio) by Packt Publishing and *Mastering
    CMake* (Ken Martin and Bill Hoffman) by Kitware.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a start, let’s create a minimalistic C++ application with a trivial `main()`
    function and build it using CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s introduce two helper macros for CMake. You can find them in the `CMake/CommonMacros.txt`
    file of our source code bundle at [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: The `SETUP_GROUPS` macro iterates over a space-delimited list of C and C++ files,
    whether it is a header or a source file, and assigns each of them to a separate
    group. The group name is constructed based on the path of each individual file.
    This way, we end up with a nice structure similar to a filesystem within a directory
    in the Visual Studio Solution Explorer window, as we can see on the right in the
    following figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Without groups (left) and with groups (right)](img/file7.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 1.7 – Without groups (left) and with groups (right)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The macro starts by iterating over a list of files passed in the `src_files`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the parent directory name as a default group name. For any OS, replace
    all the backslash characters with forward slashes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can tell CMake to assign the current file to a source group with this
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second macro, `SETUP_APP`, is used as a shortcut to create a new CMake project
    with all the standard properties we want it to have. It is very convenient when
    having to deal with a number of very similar subprojects, for example, like in
    this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After setting the project name, this macro uses the `GLOB_RECURSE` function
    to collect all source and header files into the `SRC_FILES` and `HEADER_FILES`
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In all our code samples, we use the directory `src` containing the source files
    as an `include` directory, too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All enumerated source and header files are added to an executable inside the
    current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use the `SETUP_GROUP` macro from *Step 1* to place each source and header
    file into an appropriate group inside the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The next three properties set different executable file names for each supported
    build configuration. These lines are optional, yet they are really useful when
    using CMake with the Visual Studio IDE. The reason is that Visual Studio can change
    build configurations (or “build types”, as they are called in CMake) dynamically
    directly from the IDE, and each build configuration can have its own output file
    name. We add suffixes to these file names so that they can co-exist in a single
    output folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since we use C++20 throughout this book, we require CMake to enable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To ease the debugging with Visual Studio, we enable console output by changing
    the application type to `Console`. We also set the local debugger working directory
    to `CMAKE_SOURCE_DIR`, which will make finding assets a lot more straightforward
    and consistent. There are some Apple-specific properties to allow building the
    source code on Mac machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the top-level `CMakeLists.txt` file of our first project will look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the line `project(Chapter01)` above is overridden by a call
    to `project()` inside the `SETUP_APP` macro. This is due to the following CMake
    warning, which will be emitted if we do not declare a new project right from the
    get-go.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To build and test the executable, create the `build` subfolder, change the
    working directory to `build`, and run CMake as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Windows and Visual Studio 2022, run the following command to configure our
    project for the 64-bit target platform architecture.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For Linux, we can use the `Unix Makefiles` CMake generator as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To build an executable for the `release` build type, you can use the following
    command on any platform. To build a debug version, use `--config Debug` or skip
    that parameter entirely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All the demo applications from the source code bundle should be run from the
    folder where the `data/` subfolder is located.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can use the cross-platform build system Ninja along with
    CMake. It is possible to do so simply by changing the CMake project generator
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Invoke Ninja from the command line to compile the project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how fast everything gets built now, compared to the classic `cmake --build`
    command. See [https://ninja-build.org](https://ninja-build.org) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at how to work with some basic open source libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GLFW library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GLFW library hides all the complexity of creating windows, graphics contexts,
    and surfaces and getting input events from the operating system. In this recipe,
    we build a minimalistic application with GLFW and Vulkan to get some basic 3D
    graphics onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We build our examples with GLFW 3.4\. Here is a JSON snippet for the Bootstrap
    script so that you can download the proper library version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code for this recipe can be found in the source code bundle
    under the name of `Chapter01/02_GLFW`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a minimalistic application that creates a window and waits for
    an `exit` command from the user – pressing the Esc key. This functionality will
    be used in all of our subsequent demos, so we have wrapped it into a helper function
    `initWindow()` declared in `shared/HelpersGLFW.h`. Let’s take a look at how to
    use it to create an empty GLFW window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include all necessary headers and decide on the initial window dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Invoke the `initWindow()` function to create a window. The `width` and `height`
    parameters are passed by reference and, after the call, will contain the actual
    working area of the created window. If we pass the initial values of `0`, the
    window will be created to span the entire desktop working area without an overlapping
    taskbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For this application, the main loop and cleanup are trivial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we will take a look at the internals of `initWindow()` for some interesting
    details.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use this library to create an application that opens an empty window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set the GLFW error callback via a lambda to catch potential errors
    and then initialize GLFW:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let’s decide if we want to make a desktop full-screen window. Set the resizable
    flag for windows that aren’t full-screen and retrieve the desired window dimensions.
    We are going to initialize Vulkan manually, so no graphics API initialization
    is required to be done by GLFW. The flag `wantsWholeArea` determines if we want
    a true full-screen window or a window that does not overlap the system taskbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a window and retrieve the actual window dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Set a default keyboard callback to handle the Esc key. A simple lambda will
    do this job for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this tiny application, it will create an empty window, as in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Our first application](img/file8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Our first application
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further details about how to use GLFW can be found at [https://www.glfw.org/documentation.xhtml](https://www.glfw.org/documentation.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading with Taskflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern graphical applications require us to harness the power of multiple CPUs
    to be performant. **Taskflow** is a fast C++ header-only library that can help
    you write parallel programs with complex task dependencies quickly. This library
    is extremely useful as it allows you to jump into the development of multithreaded
    graphical applications that make use of advanced rendering concepts, such as frame
    graphs and multithreaded command buffer generation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we use Taskflow version 3.7.0\. You can download it using the following
    Bootstrap snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To debug dependency graphs produced by Taskflow, it is recommended that you
    install the **GraphViz** tool from [https://www.graphviz.org](https://www.graphviz.org).
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this recipe can be found in `Chapter01/03_Taskflow`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create and run a set of concurrent dependent tasks via the `for_each_index()`
    algorithm. Each task will print a single value from an array in a concurrent fashion.
    The processing order can vary between different runs of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `taskflow.hpp` header file. The `tf::Taskflow` class is the main
    place to create a task dependency graph. Declare an instance and a data vector
    to process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for_each_index()` member function returns a task that implements a parallel
    for loop algorithm. We specify the range `0..items.size()` and the step `1`. The
    returned `task` can be used for synchronization purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s attach some work before and after the parallel for task so that we can
    view `Start` and `End` messages in the output. Let’s call the new `S` and `T`
    tasks accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the generated tasks dependency graph in `.dot` format so that we can process
    it later with the GraphViz `dot` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a `tf::executor` object and run the constructed Taskflow
    graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: One important part to mention here is that the dependency graph can only be
    constructed once. Then, it can be reused in every frame to run concurrent tasks
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the preceding program should look similar to the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see our `S` and `T` tasks. Between them, there are multiple threads
    with different IDs processing different elements of the `items[]` vector in parallel.
    Your output may vary due to concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The application saved the dependency graph inside the `taskflow.dot` file.
    It can be converted into a visual representation by GraphViz, [https://graphviz.org](https://graphviz.org),
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `.png` image should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – The Taskflow dependency graph for for_each_index()](img/file9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – The Taskflow dependency graph for for_each_index()
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is extremely useful when you are debugging complex dependency
    graphs (and producing complex-looking images for your books and papers).
  prefs: []
  type: TYPE_NORMAL
- en: The Taskflow library functionality is vast and provides implementations for
    numerous parallel algorithms and profiling capabilities. Please refer to the official
    documentation for in-depth coverage at [https://taskflow.github.io/taskflow/index.xhtml](https://taskflow.github.io/taskflow/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next chapter and learn how to start working with Vulkan.
  prefs: []
  type: TYPE_NORMAL
