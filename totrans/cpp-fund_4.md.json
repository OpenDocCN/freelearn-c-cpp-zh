["```cpp\nint max(int a, int b) {\n  if ( a > b) return a;\n  else return b;\n}\ndouble max(double a, double b) {\n  if ( a> b) return a;\n  else return b;\n}\n```", "```cpp\ntemplate<typename T>\nT max(T a, T b) {\n  if(a>b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```", "```cpp\nmax<int>(10, 15);\n```", "```cpp\nint max(int a, int b) {\n  if(a>b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```", "```cpp\n    #include <string>\n    struct EUBankAccount {\n       std::string IBAN;\n       int amount;\n    };\n    struct UKBankAccount {\n       std::string sortNumber;\n       std::string accountNumber;\n       int amount;\n    };\n    ```", "```cpp\n    template<typename BankAccount>\n    int getMaxAmount(const BankAccount& acc1, const BankAccount& acc2) {\n        // All bank accounts have an 'amount' field, so we can access it safely\n        if (acc1.amount > acc2.amount) {\n            return acc1.amount;\n        } else {\n            return acc2.amount;\n        }\n    }\n    ```", "```cpp\n    int main() {\n        EUBankAccount euAccount1{\"IBAN1\", 1000};\n        EUBankAccount euAccount2{\"IBAN2\", 2000};\n        std::cout << \"The greater amount between EU accounts is \" << getMaxAmount(euAccount1, euAccount2) << std::endl;\n        UKBankAccount ukAccount1{\"SORT1\", \"ACCOUNT_NUM1\", 2500};\n        UKBankAccount ukAccount2{\"SORT2\", \"ACCOUNT_NUM2\", 1500};\n        std::cout << \"The greater amount between UK accounts is \" << getMaxAmount(ukAccount1, ukAccount2) << std::endl;\n    }\n    ```", "```cpp\n    The greater amount between EU accounts is 2000\n    The greater amount between UK accounts is 2500\n    ```", "```cpp\ntemplate<typename T>\nT createFrom(const T& other) {\n    return T(other);\n}\n```", "```cpp\ntemplate<typename A, typename B>\nA transform(const B& b) {\n    return A(b);\n}\ntemplate<typename A, typename B>\nA createFrom() {\n  B factory;\n  return factory.getA();\n}\n```", "```cpp\ntemplate<typename Container, typename User>\nvoid populateAccountCollection (Container& container, const User& user) {\n  container.push_back(user.getAccount());\n}\n```", "```cpp\nint main() {\n  // do nothing\n}\n```", "```cpp\nint main() {\n  std::string accounts;\n  int user;\n  populateAccountCollection(accounts, user);\n}\n```", "```cpp\nerror: request for member 'getAccount' in 'user', which is of non-class type 'const int'\n```", "```cpp\nstruct Account {\n  // Some fields\n};\nclass User {\npublic:\n  Account getAccount() const{ \n    return Account();\n }\n};\n```", "```cpp\nint main() {\n  std::string accounts;\n  User user;\n  populateAccountCollection(accounts, user);\n}\n```", "```cpp\nerror: no matching function for call to 'std::__cxx11::basic_string<char>::push_back(Account)'\n```", "```cpp\n#include <vector>\nint main(){\n   std::vector<Account> accounts;\n   User user;\n   populateAccountCollection(accounts, user);\n}\n```", "```cpp\nint x;\ndecltype(x) y;\n```", "```cpp\nUser user;\ndecltype(user.getAccount()) account;\n```", "```cpp\nint max(int a, int b);\n```", "```cpp\nauto max(int a, int b) -> int;\n```", "```cpp\ntemplate<typename User>\nauto getAccount(User user) -> decltype(user.getAccount());\n```", "```cpp\nauto max(int a, int b)\n```", "```cpp\ntemplate<typename T>\nvoid sort(std::array<T, 5> array, bool (*function)(const T&, const T&));\n```", "```cpp\ntemplate<typename T>\nbool less(const T& a, const T& b) {\n  return a < b;\n}\n```", "```cpp\nint main() {\n  std::array<int, 5> array = {4,3,5,1,2};\n  sort(array, &less<int>);\n}\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  // As usual\n};\n```", "```cpp\nMyArray<int> array;\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  // There is no need to use MyArray<T> to refer to the class, MyArray automatically refers to the current template instantiation\n  MyArray();\n  // Define the constructor for the current template T\n  MyArray<T>();\n  // This is not a valid constructor.\n};\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  T[] internal_array;\n};\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  void push_back(const T& element);\n};\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  template<typename Comparator>\n  void sort (const Comparator & element);\n};\n```", "```cpp\nMyArray<int> array;\nMyComparator comparator;\narray.sort<MyComparator>(comparator);\n```", "```cpp\ntemplate<typename T> // template of the class\ntemplate<typename Comparator> // template of the method\nMyArray<T>::sort(const Comparator& element) {\n  // implementation\n}\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\n  const Static int element_size = sizeof(T);\n};\nMyArray<int> int_array1;\nMyArray<int> int_array2;\nMyArray<std::string> string_array;\n```", "```cpp\ntemplate<typename T>\nclass MyArray {\npublic:\n  using value_type = T;\n};\n```", "```cpp\nvoid createOneAndAppend(std::vector<int>& container) {\n  int new_element{}; // We know the vector contains int\n  container.push_back(new_element);\n}\n```", "```cpp\ntemplate<typename Container>\nvoid createOneAndAppend(Container& container) {\n  // what type should new_element be?\n  container.push_back(new_element);\n}\n```", "```cpp\ntemplate<typename Container>\nvoid createOneAndAppend(Container& container) {\n  Container::value_type new_element;\n  container.push_back(new_element);\n}\n```", "```cpp\ntemplate<typename Container>\nvoid createOneAndAppend(Container& container) {\n  typename Container::value_type new_element{};\n  container.push_back(new_element);\n}\n```", "```cpp\n    class UserAccount {\n    public:\n        static std::array<char, 100> serialize(const UserAccount& account) {\n            std::cout << \"the user account has been serialized\" << std::endl;\n            return std::array<char, 100>();\n        }\n        static UserAccount deserialize(const std::array<char, 100>& blob) {\n            std::cout << \"the user account has been deserialized\" << std::endl;\n            return UserAccount();\n        }\n    };\n    class TcpConnection {\n    public:\n        std::array<char, 100> readNext() {\n            std::cout << \"the data has been read\" << std::endl;\n            return std::array<char, 100>{};\n        }\n        void writeNext(const std::array<char, 100>& blob) {\n            std::cout << \"the data has been written\" << std::endl;\n        }\n    };\n    ```", "```cpp\n    template<typename Object, typename Connection>\n    Object readObjectFromConnection(Connection& con) {\n      std::array<char, 100> data = con.readNext();\n      return Object::deserialize(data);\n    }\n    ```", "```cpp\n    TcpConnection connection;\n    UserAccount userAccount = readObjectFromConnection<UserAccount>(connection);\n    ```", "```cpp\n    struct Currency {\n        static const int conversionRate = CurrencyConversion;\n        int d_value;\n        Currency(int value): d_value(value) {}\n    };\n    template<typename OtherCurrency, typename SourceCurrency>\n    OtherCurrency to(const SourceCurrency& source) {\n        float baseValue = source.d_value / float(source.conversionRate);\n        int otherCurrencyValue = int(baseValue * OtherCurrency::conversionRate);\n        return OtherCurrency(otherCurrencyValue);\n    }\n    using USD = Currency<100>;\n    using EUR = Currency<87>;\n    using GBP = Currency<78>;\n    template<typename Currency>\n    class UserAccount {\n    public:\n      Currency balance;\n    };\n    ```", "```cpp\n    template<typename OtherCurrency>\n      void addToBalance(OtherCurrency& other) {\n        balance.value += to<Currency>(other).value;\n      }\n    ```", "```cpp\ntemplate<typename T, unsigned int size>\nArray {\n  // Implementation\n};\n```", "```cpp\n    template<typename T, int R, int C>\n    class Matrix {\n        // We store row_1, row_2, ..., row_C\n        std::array<T, R*C> data;\n        public:\n            Matrix() : data({}) {}\n    };\n    ```", "```cpp\n    T& get(int row, int col) {\n      if (row >= R || col >= C) {\n        std::abort();\n      }\n      return data[row*C + col];\n    }\n    ```", "```cpp\n    Initial matrix:\n    1 2 \n    3 4 \n    5 6 \n    ```", "```cpp\nstd::array<T, R> multiply(const std::array<T, C>& vector){\n    std::array<T, R> result = {};\n    for(int r = 0; r < R; r++) {\n      for(int c = 0; c < C; c++) {\n        result[r] += get(r, c) * vector[c];\n      }\n    }  \n    return result;\n  }\n```", "```cpp\ntemplate<typename MyType = int>\nvoid foo();\n```", "```cpp\ntemplate<typename T = void, typename A>\nvoid foo();\n```", "```cpp\n    template<typename T = A, typename A = void>\n    void foo();\n    ```", "```cpp\n    template<typename T, typename A = T >\n    void foo();\n    ```", "```cpp\ntemplate<typename T>\nstruct Less {\n  bool operator()(const T& a, const T& b) {\n    return a < b;\n  }\n};\ntemplate<typename T, typename Comparator= Less<T>>\nclass SortedArray;\n```", "```cpp\nSortedArray<int> sortedArray1;\nSortedArrat<int, Greater<int>> sortedArray2;\n```", "```cpp\ntemplate<size_t Size = 512>\nstruct MemoryBuffer;\n```", "```cpp\nMemoryBuffer<> buffer1;\nMemoryBuffer<1024> buffer2;\n```", "```cpp\ntemplate<typename T>\nvoid foo(T parameter);\n```", "```cpp\nfoo(argument);\n```", "```cpp\ntemplate<typename A, typename B, typename C>\nC foo(A, B);\n```", "```cpp\ntemplate< typename C, typename A, typename B>\nC foo(A, B);\n```", "```cpp\n    std::array<T, R> multiply(const std::array<T, C>& vector) {\n        std::array<T, R> result = {};\n        for(int r = 0; r < R; r++) {\n            for(int c = 0; c < C; c++) {\n                result[r] += multiplier(get(r, c), vector[c]);\n            }\n        }\n        return result;\n    }\n    ```", "```cpp\n    // Create a matrix of int, with the 'plus' operation by default\n    Matrix<3, 2, int, std::plus<int>> matrixAdd;\n    matrixAdd.setRow(0, {1,2});\n    matrixAdd.setRow(1, {3,4});\n    matrixAdd.setRow(2, {5,6});\n    std::array<int, 2> vector = {8, 9};\n    // This will call std::plus when doing the multiplication\n    std::array<int, 3> result = matrixAdd.multiply(vector);\n    ```", "```cpp\n    Initial matrix:\n    1 2 \n    3 4 \n    5 6 \n    Result of multiplication (with plus instead of multiply): [20, 24, 28]\n    ```", "```cpp\nvoid do_action(int, float, double);\ndouble d = 1.5;\nstd::invoke(do_action, 1, 1.2f, d);\n```", "```cpp\nstruct PrintOnCopyOrMove {\n  PrintOnCopyOrMove(std::string name) : _name(name) {}\n  PrintOnCopyOrMove(const PrintOnCopyOrMove& other) : _name(other._name) { std::cout << \"Copy: \" << _name << std::endl; }\n  PrintOnCopyOrMove(PrintOnCopyOrMove&& other) : _name(other._name) { std::cout << \"Move: \" << _name << std::endl; }\n\n  std::string _name;\n};\nvoid use_printoncopyormove_obj(PrintOnCopyOrMove obj) {}\n```", "```cpp\nPrintOnCopyOrMove local{\"l-value\"};\nstd::invoke(use_printoncopyormove_obj, local);\nstd::invoke(use_printoncopyormove_obj, PrintOnCopyOrMove(\"r-value\"));\n```", "```cpp\nCopy: l-value\nMove: r-value\n```", "```cpp\nvoid do_action(PrintOnCopyOrMove&&)\n// not deduced: r-value reference\ntemplate<typename T>\nvoid do_action(T&&) // deduced by the compiler: forwarding reference\n```", "```cpp\ntemplate<typename T>\nvoid do_action(T&& obj) { /* forwarding reference, but we can access obj as if it was a normal l-value reference */\n  obj.some_method();\n  some_function(obj);\n}\n```", "```cpp\ntemplate<typename T>\nvoid do_action(T&& obj) {\n  do_something_with_obj(???); \n// We are not using obj after this call.\n}\n```", "```cpp\ntemplate<typename T>\nvoid do_action(T&& obj) {\n  use_printoncopyormove_obj(std::forward<T>(obj)); \n}\n```", "```cpp\nPrintOnCopyOrMove local{\"l-value\"};\ndo_action(local);\ndo_action(PrintOnCopyOrMove(\"r-value\"));\ndo_action(std::move(local));\n// We can move because we do not use local anymore\n```", "```cpp\nCopy: l-val\nMove: r-val\nMove: l-val\n```", "```cpp\n    struct UserIdentifier {\n        int userId = 0;\n    };\n    struct Cart {\n        std::vector<Item> items;\n    };\n    ```", "```cpp\n    bool isLoggedIn(const UserIdentifier& user) {\n        return user.userId % 2 == 0;\n    }\n    Cart getUserCart(const UserIdentifier& user) {\n        return Cart();\n    }\n    ```", "```cpp\n    template<typename Action, typename Parameter>\n    void execute_on_user_cart(UserIdentifier user, Action action, Parameter&& parameter) {\n        if(isLoggedIn(user)) {\n            Cart cart = getUserCart(user);\n            action(cart, std::forward<Parameter>(parameter));\n        } else {\n            std::cout << \"The user is not logged in\" << std::endl;\n        }\n    }\n    ```", "```cpp\n    void removeItem(Cart& cart, Item cartItem) {\n        auto location = std::find(cart.items.begin(), cart.items.end(), cartItem);\n        if (location != cart.items.end()) {\n            cart.items.erase(location);\n        }\n        std::cout << \"Item removed\" << std::endl;\n    }\n    void addItems(Cart& cart, std::vector<Item> items) {\n        cart.items.insert(cart.items.end(), items.begin(), items.end());\n        std::cout << \"Items added\" << std::endl;\n    }\n    ```", "```cpp\n    template<typename Action, typename Parameter>\n    void execute_on_user_cart(UserIdentifier user, Action action, Parameter&& parameter) {\n        if(isLoggedIn(user)) {\n            Cart cart = getUserCart(user);\n            action(std::move(cart), std::forward<Parameter>(parameter));\n        }\n    }\n    ```", "```cpp\n    UserIdentifier user{/* initialize */};\n    execute_on_user_cart(user, remove_item, CartItem{});\n    std::vector<CartItem> items = {{\"Item1\"}, {\"Item2\"}, {\"Item3\"}}; // might be very long\n    execute_on_user_cart(user, add_items, std::move(items));\n    ```", "```cpp\ntemplate<typename… Types>\nvoid do_action();\ntemplate<typename… Types>\nstruct MyStruct;\n```", "```cpp\ndo_action<int, std:string, float>();\ndo_action<>();\nMyStruct<> myStruct0;\nMyStruct<float, int> myStruct2;\n```", "```cpp\ntemplate<typename… MyTypes>\nvoid do_action(MyTypes… my_types);\ndo_action();\ndo_action(1, 2, 4.5, 3.5f);\n```", "```cpp\ntemplate<typename… Ts>\nstruct Variadic {\n  Variadic(Ts… arguments);\n};\n```", "```cpp\ntemplate<typename… Ts>\nVariadic<Ts…> make_variadic(Ts… args) {\n  return Variadic<Ts…>(args…);\n}\n```", "```cpp\ntemplate<typename… Containers>\nstd::tuple<typename Containers::value_type…> get_front(Containers… containers) {\n  return std::tuple<typename Containers::value_type…>(containers.front()…);\n}\n```", "```cpp\nstd::vector<int> int_vector = {1};\nstd::vector<double> double_vector = {2.0};\nstd::vector<float> float_vector = {3.0f};\nget_front(int_vector, double_vector, float_vector) // Returns a tuple<int, double, float> containing {1, 2.0, 3.0}\n```", "```cpp\ntemplate<typename… Ts>\nvoid modify_and_call (Ts… args) {\n  do_things(modify (args)…));\n}\n```", "```cpp\n    template<typename Action, typename... Parameters>\n    void execute_on_user_cart(UserIdentifier user, Action action, Parameters&&... parameters) {\n        if(isLoggedIn(user)) {\n            Cart cart = getUserCart(user);\n            action(std::move(cart), std::forward<Parameters>(parameters)...);\n        }\n    }\n    ```", "```cpp\ntemplate<typename T, typename Comparison = Less<T>, typename Equality = Equal<T>>\nclass SortedContainer;\n```", "```cpp\nSortedContainer<UserAccount, UserAccountBalanceCompare, UserAccountBalanceEqual> highScoreBoard;\n```", "```cpp\nusing HighScoreBoard = SortedContainer<UserAccount, UserAccountBalanceCompare, UserAccountBalanceEqual>;\n```", "```cpp\nHighScoreBoard highScoreBoard;\n```", "```cpp\ntemplate<typename T>\nclass SortedContainer {\npublic:\n  T& front() const;\n};\ntemplate<typename T>\nclass ReversedContainer {\npublic:\n  T& front() const;\n}\n```", "```cpp\ntemplate<typename Container>\n??? get_front(const Container& container);\n```", "```cpp\ntemplate<typename T>\nclass SortedContainer {\n  using value_type = T; // type alias\n  T& front() const;\n};\n```", "```cpp\ntemplate<typename Container>\ntypename Container::value_type& get_front(const Container& container);\n```", "```cpp\ntemplate<typename Container>\nclass ContainerWrapper {\n  using value_type = typename Container::value_type;\n}\n```", "```cpp\ntemplate<typename T>\nclass MyObjectWrapper {\n  using special_type = MyObject<typename T::value_type>;\n};\n```", "```cpp\ntemplate<typename Container>\nusing ValueType = typename Container::value_type;\n```"]