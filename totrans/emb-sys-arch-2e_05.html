<html><head></head><body>
<div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-107"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.2.1">Memory Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Handling memory is one of the most important tasks for an embedded system programmer, and surely the most important to take into account in every phase of the development of a system. </span><span class="koboSpan" id="kobo.3.2">This chapter is about the models commonly used to manage memory in an embedded system, the geometry and the mapping of the memory, and how to prevent issues that could compromise the stability and safety of the software running on </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter is divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">four parts:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Memory mapping</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">execution stack</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Heap management</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The memory </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">protection unit</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will have an in-depth knowledge of how to manage the memory in an </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">embedded system.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">at </span></span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter5/memory</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.20.1">Memory mapping</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Application software usually benefits from a number of abstractions available in the environment for </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.22.1">the handling of memory. </span><span class="koboSpan" id="kobo.22.2">In modern operating systems on personal computers, each process can access its own memory space, which can also be relocated by remapping memory blocks to virtual memory addresses. </span><span class="koboSpan" id="kobo.22.3">Moreover, dynamic memory allocations are possible through virtual memory pools provided by the kernel. </span><span class="koboSpan" id="kobo.22.4">Embedded devices do not rely on these mechanisms, as there is no way to assign virtual addresses to physical memory locations. </span><span class="koboSpan" id="kobo.22.5">In all contexts and running modes, all the symbols can be accessed only by pointing at </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">physical addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">As we have seen in the previous chapter, booting a bare-metal embedded application requires defining the </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.25.1">sections at compile time within the assigned regions in the available address space, using the linker script. </span><span class="koboSpan" id="kobo.25.2">In order to properly configure the memory sections in our embedded software, it is important to analyze the properties of the various regions and the techniques that we can use to organize and manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">memory areas</span><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.28.1">Memory model and address space</span></h2>
<p><span class="koboSpan" id="kobo.29.1">The total amount of </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.30.1">available addresses depends on the size </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.31.1">of memory pointers. </span><span class="koboSpan" id="kobo.31.2">32-bit machines can reference a contiguous memory space of 4 GB, which is segmented to host all the memory-mapped devices in a system. </span><span class="koboSpan" id="kobo.31.3">This may include </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Internal RAM</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Flash memory</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">System </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">control registers</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Components internal to </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the microcontroller</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">An external </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">peripheral bus</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Additional </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">external RAM</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.43.1">Every region has a fixed physical address that may depend on the characteristics of the platform. </span><span class="koboSpan" id="kobo.43.2">All the locations are hardcoded, and some of them </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">are platform-specific.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In the ARM Cortex-M, the total addressable space is divided into six macro-regions. </span><span class="koboSpan" id="kobo.45.2">Depending on their purpose, the </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.46.1">regions have different permissions so that there are areas of memory that can only be accessible for read operations at runtime, or that are not allowed to execute in place. </span><span class="koboSpan" id="kobo.46.2">These constraints are implemented in hardware but might be configurable at runtime on microcontrollers that include </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">an MPU:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.48.1"><img alt="Figure 5.1 – The ARM Cortex-M address space" src="image/B18730_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.49.1">Figure 5.1 – The ARM Cortex-M address space</span></p>
<p><span class="koboSpan" id="kobo.50.1">In general, only small sections (that are the same size as physical components) are mapped within these </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.51.1">regions. </span><span class="koboSpan" id="kobo.51.2">Trying to access memory that is </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.52.1">not mapped to any hardware triggers an </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.53.1">exception in the CPU. </span><span class="koboSpan" id="kobo.53.2">When approaching a target platform, it is important to know the locations and the sizes of the memory sections corresponding to the hardware on board, in order to properly describe the geometry of the available address space in the linker script and in the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">source</span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.55.1"> code.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.56.1">The code region</span></h2>
<p><span class="koboSpan" id="kobo.57.1">The lowest 512 MB of the addressing space in a Cortex-M microcontroller is reserved for executable code. </span><span class="koboSpan" id="kobo.57.2">Targets that support XIP always map the flash memory within this area, and the memory is </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.58.1">generally not writable at runtime. </span><span class="koboSpan" id="kobo.58.2">In our previous examples, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">.text</span></strong><span class="koboSpan" id="kobo.60.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">.rodata</span></strong><span class="koboSpan" id="kobo.62.1"> sections are mapped within this region, as they remain constant during the execution of the software. </span><span class="koboSpan" id="kobo.62.2">Additionally, the initial values of all non-zero defined symbols are placed in this area and need to be explicitly copied and re-mapped to a writable segment in order to modify their value at runtime. </span><span class="koboSpan" id="kobo.62.3">As we already know, the </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">interrupt vector table</span></strong><span class="koboSpan" id="kobo.64.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">IVT</span></strong><span class="koboSpan" id="kobo.66.1">) is usually located at the beginning </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.67.1">of the mapped section. </span><span class="koboSpan" id="kobo.67.2">Multiple flash memory banks may be mapped into the code region. </span><span class="koboSpan" id="kobo.67.3">The regions associated with physical devices must be known in advance and are dependent on the hardware design. </span><span class="koboSpan" id="kobo.67.4">Many microcontrollers map the code region at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">0x00000000</span></strong><span class="koboSpan" id="kobo.69.1">, while others choose a different starting address (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">0x10000000</span></strong><span class="koboSpan" id="kobo.71.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">0x08000000</span></strong><span class="koboSpan" id="kobo.73.1">). </span><span class="koboSpan" id="kobo.73.2">STM32F4 FLASH memory is mapped at </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">0x08000000</span></strong><span class="koboSpan" id="kobo.75.1"> and provides an alias so that the same memory can be accessed at runtime, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">0x00000000</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.77.1">as well.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.78.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.79.1">When the flash memory address starts at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">0</span></strong><span class="koboSpan" id="kobo.81.1">, NULL pointers can be de-referenced and will point to the beginning of the code region, which is normally accessible for reading. </span><span class="koboSpan" id="kobo.81.2">While this technically violates the C standard, it is a common practice within embedded C code to read from address </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">0x00000000</span></strong><span class="koboSpan" id="kobo.83.1">in these cases – for example, to read the initial stack pointer in the IVT</span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.84.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the ARM.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.86.1">The RAM regions</span></h2>
<p><span class="koboSpan" id="kobo.87.1">Internal RAM banks are mapped </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.88.1">to addresses in the second 512 MB block, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">0x20000000</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">External memory banks may be mapped anywhere in the 1 GB region, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">0x60000000</span></strong><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">Depending on the geometry of the internal SRAM inside the Cortex-M microcontroller, or the displacement of external memory banks, actually accessible memory areas can be mapped in non-contiguous, different parts of the memory within the allowed range. </span><span class="koboSpan" id="kobo.92.3">Memory management must take into account discontinuity in the physical mapping and refer to each section separately. </span><span class="koboSpan" id="kobo.92.4">The STM32F407 MPU, for example, has two non-contiguously mapped blocks of </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">internal SRAM:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.94.1">128 KB of SRAM at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">0x20000000</span></strong><span class="koboSpan" id="kobo.96.1"> (in two contiguous blocks of 112 KB and </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">16 KB)</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">A separate </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.99.1">bank of 64 KB </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Core-Coupled Memory</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">CCM</span></strong><span class="koboSpan" id="kobo.103.1">), mapped at </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">0x10000000</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.106.1">This second memory is tightly coupled to the CPU and optimized for time-critical operations, which allows for zero wait state access from the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">CPU itself.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">In this case, we may reference the two blocks as two separate areas in the </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">linker script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
flash (rx) : ORIGIN = 0x08000000, LENGTH = 256K
SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
CCMSRAM(rwx) : ORIGIN = 0x10000000, LENGTH = 64K</span></pre>
<p><span class="koboSpan" id="kobo.111.1">While the RAM region is designed for data, it generally keeps execution permissions, so sections of code can be loaded into RAM and executed at runtime. </span><span class="koboSpan" id="kobo.111.2">Executing code in RAM expands the flexibility </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.112.1">of the system, allowing us to process code sections before loading them to memory. </span><span class="koboSpan" id="kobo.112.2">Binaries that are not meant to be executed in place can be stored on any device in other formats too, even using compression or encryption algorithms. </span><span class="koboSpan" id="kobo.112.3">While sometimes handy, the possibility of using sections in RAM to store executable code takes away precious runtime memory from a system. </span><span class="koboSpan" id="kobo.112.4">The benefits must be carefully taken into account beforehand when designing the system, especially from the point of view of actual runtime memory demands coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">the a</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.114.1">pplication.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.115.1">Peripheral-access regions</span></h2>
<p><span class="koboSpan" id="kobo.116.1">The 512 MB area </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.117.1">following the internal RAM region, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">0x40000000</span></strong><span class="koboSpan" id="kobo.119.1">, is reserved for peripherals that are normally built into a microcontroller. </span><span class="koboSpan" id="kobo.119.2">The 1 GB area starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">0xA0000000</span></strong><span class="koboSpan" id="kobo.121.1"> is instead used to map external memory chips and other devices that can be memory-mapped in the MCU addressing space but are not part of the original chip package. </span><span class="koboSpan" id="kobo.121.2">In order to correctly access the peripherals, the configuration of the internal components within the MCU packaging and the addresses of the memory-mapped devices must be known in advance. </span><span class="koboSpan" id="kobo.121.3">Code execution is never allowed in </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">th</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.123.1">ese regions.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.124.1">The system region</span></h2>
<p><span class="koboSpan" id="kobo.125.1">The highest 512 MB of the Cortex-M memory mapping is reserved for accessing system configuration and </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.126.1">private control blocks. </span><span class="koboSpan" id="kobo.126.2">This region contains the system control registers, which are the registers used to program the processor, and the peripheral control registers, used to configure devices and peripherals. </span><span class="koboSpan" id="kobo.126.3">Code execution is not allowed, and the region is uniquely accessible when the processor is running at </span><em class="italic"><span class="koboSpan" id="kobo.127.1">privileged level</span></em><span class="koboSpan" id="kobo.128.1">, as explained in more detail in </span><a href="B18730_10.xhtml#_idTextAnchor357"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.130.1">, </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Parallel Tasks </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.132.1">and Scheduling</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Accessing hardware registers by de-referencing their well-known addresses is useful to set and get their values at runtime. </span><span class="koboSpan" id="kobo.134.2">However, there is no way for the compiler to tell the difference between an assignment of a variable mapped in RAM and a configuration register in the system control block. </span><span class="koboSpan" id="kobo.134.3">For this reason, the compiler often thinks that it is a good idea to optimize code by altering the order of the memory transactions, which might in fact result in unpredictable effects when the next operation depends on the correct conclusion of all the memory transfer from the previous ones. </span><span class="koboSpan" id="kobo.134.4">For this reason, extra care is needed when accessing configuration registers to ensure that the memory transfer operation is concluded before the next one</span><a id="_idTextAnchor163"/> <span class="No-Break"><span class="koboSpan" id="kobo.135.1">is executed.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.136.1">Order of memory transactions</span></h2>
<p><span class="koboSpan" id="kobo.137.1">On ARM CPUs, the memory system does not guarantee that the memory transactions are executed in the </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.138.1">same order as the instructions that generate them. </span><span class="koboSpan" id="kobo.138.2">The order of memory transactions can be altered to adjust to the characteristics of the hardware, such as the wait states required to access underlying physical memory, or by the speculative branch prediction mechanisms implemented at the microcode level. </span><span class="koboSpan" id="kobo.138.3">While Cortex-M microcontrollers guarantee a strict ordering of the transactions involving the peripherals and the system regions, in all other cases code must be instrumented accordingly, by placing adequate memory barriers to ensure that the previous memory transactions have been executed before executing the </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.139.1">next instruction. </span><span class="koboSpan" id="kobo.139.2">The Cortex-M instruction set includes three kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">of barriers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.141.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">data memory </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.143.1">barrier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.144.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.145.1">DMB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">data synchronization </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.149.1">barrier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.151.1">DSB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.153.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">instruction synchronization </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.155.1">barrier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.157.1">ISB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.159.1">The DSB is a </span><em class="italic"><span class="koboSpan" id="kobo.160.1">soft</span></em><span class="koboSpan" id="kobo.161.1"> barrier, invoked </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.162.1">to ensure that all the pending </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.163.1">transactions are executed before the next memory transaction occurs. </span><span class="koboSpan" id="kobo.163.2">The DSB is used to actually suspend the execution </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.164.1">until all the pending transactions have been executed. </span><span class="koboSpan" id="kobo.164.2">The ISB, in addition, also flushes the CPU pipeline and ensures that all the </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.165.1">new instructions are fetched again after </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.166.1">the memory transactions, thus preventing any side effects caused by the outdated memory content. </span><span class="koboSpan" id="kobo.166.2">There are a number of cases where using a barrier </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">is required:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.168.1">After updating the VTOR to change the address of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the IV</span></span></li>
<li><span class="koboSpan" id="kobo.170.1">After updating the </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">memory mapping</span></span></li>
<li><span class="koboSpan" id="kobo.172.1">During the execution of code </span><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.173.1">that </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">modifies itself</span></span></li>
</ul>
<h1 id="_idParaDest-116"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.175.1">The execution stack</span></h1>
<p><span class="koboSpan" id="kobo.176.1">As seen in the previous </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.177.1">chapter, a bare-metal application starts executing with an empty stack area. </span><span class="koboSpan" id="kobo.177.2">The execution stack grows backward, from the high address provided at boot to lower addresses every time a new item is stored. </span><span class="koboSpan" id="kobo.177.3">The stack keeps track of the chain of function calls at all times by storing the branching point at each function call, but it also serves as temporary storage during function executions. </span><span class="koboSpan" id="kobo.177.4">Variables within the local scope of each function are stored inside the stack while the function is executing. </span><span class="koboSpan" id="kobo.177.5">For this reason, keeping stack usage under control is one of the most critical tasks while developing an </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">embedded system.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Embedded programming requires us to be aware at all times of stack usage while coding. </span><span class="koboSpan" id="kobo.179.2">Placing big objects in the stack, such as communication buffers or long strings, is in general not a good idea, considering that the space for the stack is always very limited. </span><span class="koboSpan" id="kobo.179.3">The compiler can be instructed to produce a warning every time the stack space required by a single function exceeds a certain threshold, as, for example, in </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
void function(void)
{
   char buffer[200];
   read_serial_buffer(buffer);
}</span></pre>
<p><span class="koboSpan" id="kobo.182.1">If compiled with the GCC option, </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">-Wstack-usage=100</span></strong><span class="koboSpan" id="kobo.184.1">, it will produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">following warning:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
main.c: In function 'function':
main.c:15:6: warning: stack usage is 208 bytes [-Wstack-usage=]</span></pre>
<p><span class="koboSpan" id="kobo.187.1">This can be intercepted at </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">compile time.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">While this mechanism is useful to identify local stack overuses, it is not effective to identify all the potential stack overflows in the code, as the function calls may be nested and their stack usage added up. </span><span class="koboSpan" id="kobo.189.2">Our function uses 208 bytes of the stack whenever it is invoked, 200 to host the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">buffer</span></strong><span class="koboSpan" id="kobo.191.1"> local variable in the stack, and 8 additional bytes to store two pointers: the origin of the call in the code section, which is stored as a return point, and the frame pointer, which contains the old location of the stack pointer before </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the call.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">By design, the stack grows every time a function is called and shrinks again when functions return. </span><span class="koboSpan" id="kobo.193.2">In a given </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.194.1">case, it is particularly difficult to make estimations about the runtime stack usage, which is the purpose of recursive functions. </span><span class="koboSpan" id="kobo.194.2">For this reason, the use of recursion in the code should be avoided whenever possible, or reduced to the minimum and kept under strict control otherwise, knowing that the memory area reserved for the stack in the target </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">is small:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.196.1"><img alt="Figure 5.2 – The stack pointer moves down when a function is called to store frame pointer﻿s and local variables" src="image/B18730_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">Figure 5.2 – The stack pointer moves down when a function is called to store frame pointer</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.198.1">s and local variables</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.199.1">Stack placement</span></h2>
<p><span class="koboSpan" id="kobo.200.1">The initial pointer to the </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.201.1">stack area can be selected at boot by setting the desired memory address in the first word of the IV table, which corresponds to the beginning of the binary image loaded </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">in flash.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">This pointer may be set at compile time, in different ways. </span><span class="koboSpan" id="kobo.203.2">The simple example from </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.205.1">, </span><em class="italic"><span class="koboSpan" id="kobo.206.1">The Boot-Up Procedure</span></em><span class="koboSpan" id="kobo.207.1">, shows how it is possible to assign a specific area for the stack or use symbols exported from the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">linker script.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">Using the linker script as a central point to describe memory regions and segments makes the code more portable across </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">similar platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Since our STM32F407 provides an additional, tightly coupled 64-KB memory bank at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">0x10000000</span></strong><span class="koboSpan" id="kobo.213.1">, we may want to reserve its lower 16 KB for the execution stack and keep the rest in a separate section for later use. </span><span class="koboSpan" id="kobo.213.2">The linker script must define the region on top, in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">MEMORY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
MEMORY
{
  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 1M
  SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
  CCRAM(rwx) : ORIGIN = 0x10000000, LENGTH = 64K
}</span></pre>
<p><span class="koboSpan" id="kobo.217.1">Two symbols may now be exported at the end of the file, by assigning constant, </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">pre-defined values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
_stack_size = 16 * 1024;
_stack_end = ORIGIN(CCRAM) + _stack_size;</span></pre>
<p><span class="koboSpan" id="kobo.220.1">The values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">_stack_size</span></strong><span class="koboSpan" id="kobo.222.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">_stack_end</span></strong><span class="koboSpan" id="kobo.224.1"> can be accessed by the application as ordinary C symbols. </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">_stack_end</span></strong><span class="koboSpan" id="kobo.226.1"> is placed at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">0</span></strong><span class="koboSpan" id="kobo.228.1"> when the vector table is initialized to indicate the highest </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">stack address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
__attribute__ ((section(".isr_vector")))
void (* const IV[])(void) =
{
  (void (*)(void))(&amp;_end_stack),
  isr_reset, // Reset
  isr_fault, // NMI
  isr_fault, // HardFault
  /* more interrupt routines follow */</span></pre>
<p><span class="koboSpan" id="kobo.231.1">Whenever possible, it is a good idea to delegate a separate memory region to the stack area, as in this case. </span><span class="koboSpan" id="kobo.231.2">Unfortunately, this is not possible on </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">all platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Most embedded devices with physical memory mapping offer a single continuous mapping region for the entire RAM. </span><span class="koboSpan" id="kobo.233.2">A common strategy used to organize the memory in these cases is to place the </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.234.1">initial stack pointer at the highest available address at the end of the mappable memory. </span><span class="koboSpan" id="kobo.234.2">This way, the stack is free to grow from the top of the memory down, while the application can still use the memory to allocate dynamic objects from the lowest address that is not used by any other section. </span><span class="koboSpan" id="kobo.234.3">While this mechanism is considered the most efficient, giving the illusion that it is possible to use up  every last byte of RAM available, it is dangerous because the two areas growing in opposite directions may collide, leading to</span><a id="_idTextAnchor169"/> <span class="No-Break"><span class="koboSpan" id="kobo.235.1">unpredictable results.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.236.1">Stack overflows</span></h2>
<p><span class="koboSpan" id="kobo.237.1">The main problem with stack sizing and placement is that it is very difficult, if not impossible, to </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.238.1">recover from a situation of stack overflow in a single-thread, bare-metal application. </span><span class="koboSpan" id="kobo.238.2">When the stack is self-contained in its own physical region, such as a separate memory bank, if its lower bound is a region not mapped to any device, a stack overflow will cause a hard fault exception, which can be trapped to halt </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">In other cases, such as when adjacent memory is used for other purposes, the stack pointer might overflow into other segments, with a concrete risk of corrupting other memory areas, with catastrophic consequences including even opening the door to malicious code injections and arbitrary code execution attacks on the target. </span><span class="koboSpan" id="kobo.240.2">The best strategy usually consists of assigning adequate stack space at boot, isolating the stack as much as possible from the other memory sections, and checking the stack usage at runtime. </span><span class="koboSpan" id="kobo.240.3">Configuring the stack to use the lowest available addresses in RAM ensures that a stack overflow will result in a hard fault, rather than accessing valid pointers in adjacent areas in memory. </span><span class="koboSpan" id="kobo.240.4">The most classic approach for a bare-metal system with a single contiguous region of memory-mapped RAM is putting the initial stack pointer at the highest address available and having it grow backward toward lower addresses. </span><span class="koboSpan" id="kobo.240.5">The linker script exports the highest address mapped as the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">stack pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
_end_stack = ORIGIN(RAM) + LENGTH(RAM);</span></pre>
<p><span class="koboSpan" id="kobo.243.1">The available memory between the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">.bss</span></strong><span class="koboSpan" id="kobo.245.1"> section and the lowest address in the stack may be used for dynamic allocations by the application, and at the same time, the stack is allowed to </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.246.1">grow in the opposite direction. </span><span class="koboSpan" id="kobo.246.2">This is an efficient way to utilize all the available memory because the stack does not require a lower boundary, but it is safe only as long as the total amount of memory used from both sides fits inside the designated areas. </span><span class="koboSpan" id="kobo.246.3">If the sections are allowed to dynamically grow toward higher addresses, there is always a possibility of collisions if there is overlap from </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">both sides:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.248.1"><img alt="Figure 5.3 – Heap allocations and the execution stack growing in opposite directions" src="image/B18730_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.249.1">Figure 5.3 – Heap allocations and the execution stack growing in opposite directions</span></p>
<p><span class="koboSpan" id="kobo.250.1">Collisions between two contiguous memory areas are very common and dangerous events in embedded </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.251.1">systems with one single continuous region of memory. </span><span class="koboSpan" id="kobo.251.2">A solution proposed later in this chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.252.1">Memory protection unit</span></em><span class="koboSpan" id="kobo.253.1"> section, can be used to separate memory into two logical blocks by inserting a third inaccessible block in the middle and to help identify a</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.254.1">nd intercept </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">these cases.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.256.1">Stack painting</span></h2>
<p><span class="koboSpan" id="kobo.257.1">An effective way to measure the amount of stack space needed at runtime consists of filling the estimated </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.258.1">stack space with a well-known pattern. </span><span class="koboSpan" id="kobo.258.2">This mechanism, informally referred to as stack painting, reveals the maximum expansion of the execution stack at any time. </span><span class="koboSpan" id="kobo.258.3">By running the software with a painted stack, it is in fact possible to measure the amount of stack used by looking for the last recognizable pattern, and assuming that the stack pointer has moved during the execution, but never crossing  </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">that point.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">We can perform stack painting manually in the reset handler, during memory initialization. </span><span class="koboSpan" id="kobo.260.2">To do so, we need to assign an area to paint. </span><span class="koboSpan" id="kobo.260.3">In this case, it would be the last 8 KB of memory up until </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">_end_stack</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">Once again, while manipulating the stack in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">reset_handler</span></strong><span class="koboSpan" id="kobo.264.1"> function, local variables should not be used. </span><span class="koboSpan" id="kobo.264.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">reset_handler</span></strong><span class="koboSpan" id="kobo.266.1"> function will store the value of the current stack pointer in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">sp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.268.1">global variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
static unsigned int sp;</span></pre>
<p><span class="koboSpan" id="kobo.270.1">Within the handler, the following section can be added before </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">invoking </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
asm volatile("mrs %0, msp" : "=r"(sp));
dst = ((unsigned int *)(&amp;_end_stack)) – (8192 / sizeof(unsigned int)); ;
while (dst &lt; sp) {
   *dst = 0xDEADC0DE;
   dst++;
}</span></pre>
<p><span class="koboSpan" id="kobo.275.1">The first assembly instruction is used to store the current value of the stack pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">sp</span></strong><span class="koboSpan" id="kobo.277.1"> variable, ensuring that the painting stops after the area is painted but only up until the last unused address in </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the stack:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 5.4 – Painting the stack area with a recognizable pattern helps to estimate the stack memory used in the prototype" src="image/B18730_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 5.4 – Painting the stack area with a recognizable pattern helps to estimate the stack memory used in the prototype</span></p>
<p><span class="koboSpan" id="kobo.281.1">The current stack usage can be checked periodically at runtime – for instance, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">main</span></strong><span class="koboSpan" id="kobo.283.1"> loop – to detect the area painted with the recognizable pattern. </span><span class="koboSpan" id="kobo.283.2">The areas that are still painted have never been used by the execution stack so far and indicate the amount of stack </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">still available.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">This mechanism may be used to verify the amount of stack space required by the application to run </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.286.1">comfortably. </span><span class="koboSpan" id="kobo.286.2">According to the design, this information can be used later on to set a safe lower limit on the segment that can be used for the stack. </span><span class="koboSpan" id="kobo.286.3">Stack painting, however, is not always effective, as it gives a measurement of the stack used during the execution, but it might overlook corner cases where the stack usage may be bigger. </span><span class="koboSpan" id="kobo.286.4">Increasing test coverage while keeping an eye on the stack painting at the end of each test may help to allocate the appropriate amount of stack space dur</span><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.287.1">ing the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">development phase.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.289.1">Heap management</span></h1>
<p><span class="koboSpan" id="kobo.290.1">Safety-critical embedded </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.291.1">systems are often designed not to implement any dynamic memory allocation. </span><span class="koboSpan" id="kobo.291.2">While this may sound extreme, it minimizes the impact of the most common programming mistakes in the application code, which might lead to catastrophic consequences for the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">running system.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">On the other hand, dynamic allocation is a powerful tool because it gives complete control over the lifetime and the size of the memory blocks. </span><span class="koboSpan" id="kobo.293.2">Many third-party libraries designed for embedded devices expect an existing implementation of dynamic memory allocation. </span><span class="koboSpan" id="kobo.293.3">Dynamic memory is managed through a heap structure in memory, by keeping track of the status and the size for each allocation, incrementing the pointer to the next area of free memory, and reusing blocks that have been freed if new allocation requests </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">are processed.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">A standard programming interface for heap allocation consists of two </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">basic functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
void *malloc(size_t size);
void free(void *ptr);</span></pre>
<p><span class="koboSpan" id="kobo.298.1">These function signatures are defined by the ANSI-C standard and are commonly found in operating systems. </span><span class="koboSpan" id="kobo.298.2">They allow us to request a new memory area of a given size and free up the previously </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.299.1">allocated area referred to by the specified pointer respectively. </span><span class="koboSpan" id="kobo.299.2">More complete heap management has support for an additional call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">realloc</span></strong><span class="koboSpan" id="kobo.301.1">, that allows us to resize a memory area previously allocated, either in place or by relocating it to a new segment that is large enough to contain an object of the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">given size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
void *realloc(void *ptr, size_t size);</span></pre>
<p><span class="koboSpan" id="kobo.304.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">realloc</span></strong><span class="koboSpan" id="kobo.306.1"> is generally left out from most of the embedded system implementations, it may be useful in some cases to resize objects </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">in memory.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Depending on the implementation, memory management could be more or less efficient in joining together contiguous blocks that had been freed, in order to create larger available segments without having to allocate new space. </span><span class="koboSpan" id="kobo.308.2">Real-time operating systems usually offer allocators with different heap management. </span><span class="koboSpan" id="kobo.308.3">To mention one, FreeRTOS provides five different portable heap managers to </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">choose from.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">If we opt for a solution that allows for dynamic allocations, it is important to design it while taking into account a few </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">important factors:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.312.1">The geometry of the regions where the heap </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">is placed</span></span></li>
<li><span class="koboSpan" id="kobo.314.1">The higher boundary of the section dedicated to the heap, if it is shared with the stack, to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">heap-stack collisions</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">The policy to adopt if there is not enough memory to satisfy requests for </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">new allocations</span></span></li>
<li><span class="koboSpan" id="kobo.318.1">How to deal with memory fragmentation and keep the overhead of unused blocks as small </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">as possible</span></span></li>
<li><span class="koboSpan" id="kobo.320.1">Using separate pools to separate the memory used by specific objects </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">and modules</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">Spreading a single pool of memory across </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">non-contiguous regions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.324.1">When no allocator is available on the target – for example, if we are developing a bare-metal application from scratch – we might be required to implement an allocator that responds to the characteristics of the design. </span><span class="koboSpan" id="kobo.324.2">This can be done either from scratch by providing a custom </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.325.1">implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">malloc</span></strong><span class="koboSpan" id="kobo.327.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">free</span></strong><span class="koboSpan" id="kobo.329.1"> functions or using implementations provided by the C library in use. </span><span class="koboSpan" id="kobo.329.2">The first approach gives complete control over the fragmentation, memory areas, and pools to be used to implement the heap, while the latter hides most of the handling while still allowing customization of the (contiguous) memory area and boundaries. </span><span class="koboSpan" id="kobo.329.3">In the next two sections, we will explore the two possib</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.330.1">le strategies in </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">more detail.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.332.1">Custom implementation</span></h2>
<p><span class="koboSpan" id="kobo.333.1">Unlike servers and personal computers, where memory allocations are handled using pages of a specific size, in bare-metal embedded systems, the heap is usually one or more contiguous </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.334.1">areas of physical memory that can be divided internally using any alignment. </span><span class="koboSpan" id="kobo.334.2">Building heap-based memory allocation based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">malloc</span></strong><span class="koboSpan" id="kobo.336.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">free</span></strong><span class="koboSpan" id="kobo.338.1"> interface consists of keeping track of the requested allocations in memory. </span><span class="koboSpan" id="kobo.338.2">This is usually done by attaching a small header in front of each allocation to track the state and the size of the allocated section, which can be used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">free</span></strong><span class="koboSpan" id="kobo.340.1"> function to validate the allocated block and make it available for the next allocation. </span><span class="koboSpan" id="kobo.340.2">A basic implementation, providing dynamic memory starting from the first available address after the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">.bss</span></strong><span class="koboSpan" id="kobo.342.1"> section, might represent each block in memory using a preamble, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
struct malloc_block {
  unsigned int signature;
  unsigned int size;
};</span></pre>
<p><span class="koboSpan" id="kobo.345.1">Two different signatures can be assigned to identify valid blocks and differentiate blocks still in use versus blocks that have already </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">been freed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
#define SIGNATURE_IN_USE (0xAAC0FFEE)
#define SIGNATURE_FREED (0xFEEDFACE)
#define NULL (((void *)0))</span></pre>
<p><span class="koboSpan" id="kobo.348.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">malloc</span></strong><span class="koboSpan" id="kobo.350.1"> function should keep track of the highest address in the heap. </span><span class="koboSpan" id="kobo.350.2">In this example, a static variable is used to mark the current end of the heap. </span><span class="koboSpan" id="kobo.350.3">This is set to the start address at the beginning and will grow every time a new block </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">is allocated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
void *malloc(unsigned int size)
{
  static unsigned int *end_heap = 0;
  struct malloc_block *blk;
  char *ret = NULL;
  if (!end_heap) {
    end_heap = &amp;_start_heap;
  }</span></pre>
<p><span class="koboSpan" id="kobo.353.1">The next two lines </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.354.1">ensure that the block requested is 32-bit-aligned to optimize the access </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">malloc_block</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
 if (((size &gt;&gt;2) &lt;&lt; 2) != size)
   size = ((size &gt;&gt; 2) + 1) &lt;&lt; 2;</span></pre>
<p><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">malloc</span></strong><span class="koboSpan" id="kobo.361.1"> function then first looks in the heap for a memory section that has been </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">previously freed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
 blk = (struct malloc_block *)&amp;_start_heap;
 while (blk &lt; end_heap) {
   if ((blk-&gt;signature == SIGNATURE_FREED) &amp;&amp;
        (blk-&gt;size &gt;= size)) {
     blk-&gt;signature = SIGNATURE_IN_USE;
     ret = ((char *)blk) + sizeof(struct malloc_block);
     return ret;
   }
   blk = ((char *)blk) + sizeof(struct malloc_block) +
       blk-&gt;size;
   }</span></pre>
<p><span class="koboSpan" id="kobo.364.1">If no available slot is found, or if none of them is large enough to satisfy the size required for the allocation, the memory is allocated at the end of the stack and the pointer is </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">updated accordingly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
   blk = (struct malloc_block *)end_heap;
   blk-&gt;signature = SIGNATURE_IN_USE;
   blk-&gt;size = size;
   ret = ((char *)end_heap) + sizeof(struct malloc_block);
   end_heap = ret + size;
   return ret;
 }</span></pre>
<p><span class="koboSpan" id="kobo.367.1">In both cases, the address returned hides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">malloc_block</span></strong><span class="koboSpan" id="kobo.369.1"> control structure that precedes it. </span><span class="koboSpan" id="kobo.369.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">end_heap</span></strong><span class="koboSpan" id="kobo.371.1"> variable always points to the end of the last block allocated in the heap, but it is </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.372.1">not an indication of the memory used, as intermediate blocks may have been freed in the meanwhile. </span><span class="koboSpan" id="kobo.372.2">This example </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">free</span></strong><span class="koboSpan" id="kobo.374.1"> function, demonstrating a very simple case, is only performing basic checks on the block that needs to be freed and setting the signature to indicate that the block is no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">being used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
void free(void *ptr)
{
  struct malloc_block *blk = (struct malloc_block *)
        (((char *)ptr)-sizeof(struct malloc_block));
  if (!ptr)
    return;
  if (blk-&gt;signature != SIGNATURE_IN_USE)
    return;
  blk-&gt;signature = SIGNATURE_FREED;
}</span></pre>
<p><span class="koboSpan" id="kobo.377.1">Although this example is very simplistic, it aims at explaining the basic functionality of heap allocation without taking into account all real-life constraints and limitations. </span><span class="koboSpan" id="kobo.377.2">In fact, allocating and freeing objects of different sizes may cause fragmentation. </span><span class="koboSpan" id="kobo.377.3">To minimize the impact of this phenomenon in terms of memory usage and wasted space between active allocations, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">free</span></strong><span class="koboSpan" id="kobo.379.1"> function should at least implement some kind of mechanism to join together adjacent areas that are no longer in play. </span><span class="koboSpan" id="kobo.379.2">Furthermore, the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">malloc</span></strong><span class="koboSpan" id="kobo.381.1">, assumes that the heap section does not have an upper boundary, does not perform any check on the new location of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">end_heap</span></strong><span class="koboSpan" id="kobo.383.1"> pointer, and does not define a strategy when there is no memory available </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">to allocate.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Although toolchains and libraries often provide a default implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">malloc</span></strong><span class="koboSpan" id="kobo.387.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">free</span></strong><span class="koboSpan" id="kobo.389.1">, implementing </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.390.1">custom heap-based allocation mechanisms still makes sense in cases where the implementations available do not meet the requirements – for example, if we want to manage separate memory pools or merge separate physical memory sections to use them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">same pool.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">Fragmentation issues cannot be completely resolved on systems with physical memory mapping because it is impossible to move around previously allocated blocks to optimize the space available. </span><span class="koboSpan" id="kobo.392.2">The issue can, however, be mitigated by keeping the number of allocations under control, reusing allocated blocks as much as possible, and avoiding frequent calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">malloc</span></strong><span class="koboSpan" id="kobo.394.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">free</span></strong><span class="koboSpan" id="kobo.396.1">, especially to request blocks with </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">different sizes.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">The use of dynamic memory, regardless of the implementation, introduces a number of safety concerns and should be avoided in all life-critical systems, and in general wherever it is not required. </span><span class="koboSpan" id="kobo.398.2">Simpler, single-purpose embedded systems can be designed to avoid the use of dynamic memory allocations altogether. </span><span class="koboSpan" id="kobo.398.3">In these cases, a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">malloc</span></strong><span class="koboSpan" id="kobo.400.1"> interface can be provided to allow perm</span><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.401.1">anent allocations </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">during startup.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.403.1">Using newlib</span></h2>
<p><span class="koboSpan" id="kobo.404.1">Toolchains may provide a set of utilities, which often include dynamic memory allocation </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.405.1">mechanisms. </span><span class="koboSpan" id="kobo.405.2">GCC-based toolchains for microcontrollers include a reduced set of standard C calls, usually in the built-in standard C library. </span><span class="koboSpan" id="kobo.405.3">A popular choice, often included in the ARM-GCC embedded toolchain, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">newlib</span></strong><span class="koboSpan" id="kobo.407.1">. </span><span class="koboSpan" id="kobo.407.2">While providing the implementation of many standard calls, </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">newlib</span></strong><span class="koboSpan" id="kobo.409.1"> remains as flexible as possible by allowing customization of the operations involving the hardware. </span><span class="koboSpan" id="kobo.409.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">newlib</span></strong><span class="koboSpan" id="kobo.411.1"> library can be integrated into both single-thread, bare-metal applications and in a real-time operating system, provided that the required system calls </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">are implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">malloc</span></strong><span class="koboSpan" id="kobo.415.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">newlib</span></strong><span class="koboSpan" id="kobo.417.1"> requires an existing implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">sbrk</span></strong><span class="koboSpan" id="kobo.419.1"> function. </span><span class="koboSpan" id="kobo.419.2">This function is expected to move the heap pointer forward every time a new allocation requires an extension of the heap space and return the old value of the heap to </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">malloc</span></strong><span class="koboSpan" id="kobo.421.1">, in order to complete allocations every time an existing, previously freed, and reusable block is not found in </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">the pool:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.423.1"><img alt="Figure 5.5 – newlib implements malloc and free and relies on an existing implementation of _sbrk" src="image/B18730_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.424.1">Figure 5.5 – newlib implements malloc and free and relies on an existing implementation of _sbrk</span></p>
<p><span class="koboSpan" id="kobo.425.1">A possible implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">_sbrk</span></strong><span class="koboSpan" id="kobo.427.1"> function may be </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
void * _sbrk(unsigned int incr)
{
  static unsigned char *heap = NULL;
  void *old_heap = heap;
  if (((incr &amp; 0x03) != incr)
    incr = ((incr &gt;&gt; 2) + 1) &lt;&lt; 2;
  if (old_heap == NULL)
    old_heap = heap = (unsigned char *)&amp;_start_heap;
  heap += incr;
  return old_heap;
}</span></pre>
<p><span class="koboSpan" id="kobo.430.1">If the code is linked without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">-nostdlib</span></strong><span class="koboSpan" id="kobo.432.1"> flag, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">malloc</span></strong><span class="koboSpan" id="kobo.434.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">free</span></strong><span class="koboSpan" id="kobo.436.1"> functions, if invoked anywhere in </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.437.1">the code, will be automatically found within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">newlib</span></strong><span class="koboSpan" id="kobo.439.1"> library built in the toolchain and included in the final binary. </span><span class="koboSpan" id="kobo.439.2">Failing to define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">_sbrk</span></strong><span class="koboSpan" id="kobo.441.1"> symbol, in this cas</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.442.1">e, will result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">linking error.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.444.1">Limiting the heap</span></h2>
<p><span class="koboSpan" id="kobo.445.1">In all the allocation functions seen so far, there is no limit imposed by the software on the amount of </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.446.1">memory reserved for the heap. </span><span class="koboSpan" id="kobo.446.2">While overflowing the stack is often hard to prevent, and extremely difficult to recover from, running out of available heap memory can more often be gracefully handled by the application – for example, by canceling or postponing the operation that required the allocation. </span><span class="koboSpan" id="kobo.446.3">In more complex multithreaded systems, an operating system could actively react to the memory shortage by terminating non-vital processes to free up memory for new allocations. </span><span class="koboSpan" id="kobo.446.4">Some advanced systems using page-swapping mechanisms, such as Linux, may implement overcommit on the available memory. </span><span class="koboSpan" id="kobo.446.5">This mechanism guarantees that memory allocations never fail, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">malloc</span></strong><span class="koboSpan" id="kobo.448.1"> will never return </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">NULL</span></strong><span class="koboSpan" id="kobo.450.1"> to indicate </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">a failure.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Memory-consuming processes in a system may be instead terminated at any time by a kernel thread, the out-of-memory killer, to make space for new allocations from other less resource-consuming processes. </span><span class="koboSpan" id="kobo.452.2">On an embedded system, especially if there is no multithreading, the best choice is to have the allocator return </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">NULL</span></strong><span class="koboSpan" id="kobo.454.1"> when there is no physical space left on the heap so that the system can keep running and the application can possibly recover by recognizing the out-of-memory episode. </span><span class="koboSpan" id="kobo.454.2">The section in memory dedicated to the heap can be limited by exporting the address for its upper boundary in the linker script, as </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
_heap_end = ORIGIN(RAM) + LENGTH(RAM);</span></pre>
<p><span class="koboSpan" id="kobo.457.1">The backend for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">newlib</span></strong><span class="koboSpan" id="kobo.459.1"> library </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">malloc</span></strong><span class="koboSpan" id="kobo.461.1"> implementation can account for the newly introduced upper bound in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">_sbrk()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.463.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
void * _sbrk(unsigned int incr) {
  static unsigned char *heap = NULL;
  void *old_heap = heap;
  if (((incr &amp; 0x03) != incr)
    incr = ((incr &gt;&gt; 2) + 1) &lt;&lt; 2;
  if (old_heap == NULL)
    old_heap = heap = (unsigned char *)&amp;_start_heap;
  if ((heap + incr) &gt;= &amp;_end_heap)
    return (void *)(-1);
  else
    heap += incr;
  return old_heap;
}</span></pre>
<p><span class="koboSpan" id="kobo.465.1">The special </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">(void *)(-1)</span></strong><span class="koboSpan" id="kobo.467.1"> value that is returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">sbrk</span></strong><span class="koboSpan" id="kobo.469.1"> in case of memory shortage for heap allocation </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.470.1">indicates to the calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">malloc</span></strong><span class="koboSpan" id="kobo.472.1"> that there is not enough space to perform the requested allocation. </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">malloc</span></strong><span class="koboSpan" id="kobo.474.1"> will then return </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">NULL</span></strong><span class="koboSpan" id="kobo.476.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">It is very important in this case that the caller always checks the return value at each invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">malloc()</span></strong><span class="koboSpan" id="kobo.480.1"> and that the application logic is able to correctly detect that the system is out of memory, and rea</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.481.1">ct in an attempt to recover </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">from it.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.483.1">Multiple memory pools</span></h2>
<p><span class="koboSpan" id="kobo.484.1">In some systems, it is useful to keep separate sections as dynamic memory heaps, each dedicated to a </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.485.1">specific function in the system. </span><span class="koboSpan" id="kobo.485.2">Heap allocation mechanisms using separate pools may be implemented for different reasons, such as ensuring that specific modules or subsystems do not use more memory than the amount that is assigned to them at compile time, or ensuring that allocations with the same size can reuse the same physical space in memory, reducing the impact of fragmentation, or even assigning a pre-defined, fixed area in memory for DMA operations with peripherals or network devices. </span><span class="koboSpan" id="kobo.485.3">It is possible to delimit the sections for the different pools by, as usual, exporting symbols in the linker script. </span><span class="koboSpan" id="kobo.485.4">The following example pre-allocates the space in memory for two pools, of 8 KB and 4 KB respectively, located at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">.bss</span></strong><span class="koboSpan" id="kobo.487.1"> section </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">in RAM:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
PROVIDE(_start_pool0 = _end_bss);
PROVIDE(_end_pool0 = _start_pool0 + 8KB);
PROVIDE(_start_pool1 = _end_pool0);
PROVIDE(_end_pool1 = _start_pool1 + 4KB);</span></pre>
<p><span class="koboSpan" id="kobo.490.1">A custom allocation function must be defined, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">malloc</span></strong><span class="koboSpan" id="kobo.492.1"> interface does not support the selector of the pool, but the functions can be made generic for both pools. </span><span class="koboSpan" id="kobo.492.2">A global structure can be populated with the values exported by </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the linker:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
struct memory_pool {
  void *start;
  void *end;
  void *cur;
};
static struct memory_pool mem_pool[2] = {
  {
    .start = &amp;_start_pool0;
    .end = &amp;_end_pool0;
  },
  {
    .start = &amp;_start_pool1;
    .end = &amp;_end_pool1;
  },
};</span></pre>
<p><span class="koboSpan" id="kobo.495.1">The function must take an extra argument to specify the pool. </span><span class="koboSpan" id="kobo.495.2">Then, the allocation is performed with the same algorithm, only changing the current pointer and the boundaries of the </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.496.1">selected pool. </span><span class="koboSpan" id="kobo.496.2">In this version, the out-of-memory errors are detected before moving the current heap value forward, returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">NULL</span></strong><span class="koboSpan" id="kobo.498.1"> to notify </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the caller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
void *mempool_alloc(int pool, unsigned int size)
{
  struct malloc_block *blk;
  struct memory_pool *mp;
  char *ret = NULL;
  if (pool != 0 &amp;&amp; pool != 1)
    return NULL;
  mp = mem_pool[pool];
  if (!mp-&gt;cur)
    mp-&gt;cur = mp-&gt;start;
  if (((size &gt;&gt;2) &lt;&lt; 2) != size)
    size = ((size &gt;&gt; 2) + 1) &lt;&lt; 2;
  blk = (struct malloc_block *)mp-&gt;start;
  while (blk &lt; mp-&gt;cur) {
    if ((blk-&gt;signature == SIGNATURE_FREED) &amp;&amp;
          (blk-&gt;size &gt;= size)) {
      blk-&gt;signature = SIGNATURE_IN_USE;
      ret = ((char *)blk) + sizeof(struct malloc_block);
      return ret;
    }
    blk = ((char *)blk) + sizeof(struct malloc_block) +
           blk-&gt;size;
  }
  blk = (struct malloc_block *)mp-&gt;cur;
  if (mp-&gt;cur + size &gt;= mp-&gt;end)
    return NULL;
  blk-&gt;signature = SIGNATURE_IN_USE;
  blk-&gt;size = size;
  ret = ((char *)mp-&gt;cur) + sizeof(struct malloc_block);
  mp-&gt;cur = ret + size;
  return ret;
}</span></pre>
<p><span class="koboSpan" id="kobo.501.1">Once again, this mechanism does not account for memory fragmentation, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">mempool_free</span></strong><span class="koboSpan" id="kobo.503.1"> function can have the same implementation as </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">free</span></strong><span class="koboSpan" id="kobo.505.1"> for the simplified </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">malloc</span></strong><span class="koboSpan" id="kobo.507.1">, as the only necessary thing to do is to mark the blocks being freed </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">as unused.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">In more complete cases, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">free</span></strong><span class="koboSpan" id="kobo.511.1"> or a separate garbage collector routine takes care of merging </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.512.1">contiguous freed blocks, it might be required to keep track of the freed blocks in each pool, in a list, or in another data structure that can be visite</span><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.513.1">d to check whether merging </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">is possible.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.515.1">Common heap usage errors</span></h2>
<p><span class="koboSpan" id="kobo.516.1">The use of dynamic </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.517.1">memory allocation is considered unsafe in some environments, as it is widely known to be the source of nasty bugs, which are in general both critical and very hard to identify and fix. </span><span class="koboSpan" id="kobo.517.2">Dynamic allocations may be difficult to track, especially when code grows in size and complexity and there are many dynamically allocated data structures. </span><span class="koboSpan" id="kobo.517.3">This is already very serious in multithreaded environments, where it is still possible to implement fallback mechanisms, such as terminating a misbehaving application, but it becomes critical on single-threaded embedded systems, where these kinds of errors are often fatal for the system. </span><span class="koboSpan" id="kobo.517.4">The most common types of errors when programming with heap allocations are </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">NULL</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.520.1">pointer de-reference</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.521.1">Double </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">free</span></strong></span></li>
<li><span class="koboSpan" id="kobo.523.1">Use </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">free</span></strong></span></li>
<li><span class="koboSpan" id="kobo.526.1">Failure to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">free</span></strong><span class="koboSpan" id="kobo.528.1">, resulting in </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">memory leaks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.530.1">Some of these can be avoided by following a few simple rules. </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">malloc</span></strong><span class="koboSpan" id="kobo.532.1"> returns the value that should always be checked before using the pointer. </span><span class="koboSpan" id="kobo.532.2">This is particularly important in environments where resources are limited, and the allocator can return </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">NULL</span></strong><span class="koboSpan" id="kobo.534.1"> pointers to indicate that there is no memory available for the allocation. </span><span class="koboSpan" id="kobo.534.2">The preferred approach is ensuring that there is a defined strategy to follow when the required memory is not available. </span><span class="koboSpan" id="kobo.534.3">In any case, all dynamic pointers must be checked to ensure that they do not point to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">NULL</span></strong><span class="koboSpan" id="kobo.536.1"> value before attempting </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">to de-reference.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Freeing </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">NULL</span></strong><span class="koboSpan" id="kobo.540.1"> pointers is a legal operation that must be identified when </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">free</span></strong><span class="koboSpan" id="kobo.542.1"> is called. </span><span class="koboSpan" id="kobo.542.2">By including a check </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.543.1">at the beginning of the function, if the pointer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">NULL</span></strong><span class="koboSpan" id="kobo.545.1">, no action is performed and the call </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">is ignored.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Immediately after, we can also check that the memory has not been freed before. </span><span class="koboSpan" id="kobo.547.2">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">free</span></strong><span class="koboSpan" id="kobo.549.1"> function, we implement a simple check against the signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">malloc_block</span></strong><span class="koboSpan" id="kobo.551.1"> structure in memory. </span><span class="koboSpan" id="kobo.551.2">It would be possible to add a log message, or even a breakpoint, to debug the origin of the second </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">free</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
if (blk-&gt;signature != SIGNATURE_IN_USE) {
  /* Double free detected! </span><span class="koboSpan" id="kobo.554.2">*/
  asm("BKPT #0") ;
  return;
}</span></pre>
<p><span class="koboSpan" id="kobo.555.1">Unfortunately, this mechanism may only work in some cases. </span><span class="koboSpan" id="kobo.555.2">In fact, if the block that was previously freed is assigned again by the allocator, it would be impossible to detect further uses of its original reference, and a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">free</span></strong><span class="koboSpan" id="kobo.557.1"> would cause the second reference to be lost as well. </span><span class="koboSpan" id="kobo.557.2">For the same reason, use-after-</span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">free</span></strong><span class="koboSpan" id="kobo.559.1"> errors are hard to diagnose, as there is no way to tell that a freed memory block has been accessed again. </span><span class="koboSpan" id="kobo.559.2">It is possible to paint freed blocks with a recognizable pattern so that if the content of the block is altered after </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">free</span></strong><span class="koboSpan" id="kobo.561.1"> has been called, the next invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">malloc</span></strong><span class="koboSpan" id="kobo.563.1"> on that block can detect the alteration. </span><span class="koboSpan" id="kobo.563.2">However, this again does not guarantee detection of all the cases and only works for write accesses to a freed pointer; additionally, this would not be able to identify all the cases where freed memory is accessed </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">for reading.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Memory leaks are easy to diagnose but sometimes difficult to locate. </span><span class="koboSpan" id="kobo.565.2">With limited resources, it is often the case that forgetting to free allocated memory uses up all the available heap very quickly. </span><span class="koboSpan" id="kobo.565.3">While there are techniques used to track down allocations, it is often sufficient to break into the software with the debugger and look for repeated allocations of the same size to track down the </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">buggy caller.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">In conclusion, due to their catastrophic and hideous nature, dynamic memory bugs may be one of the biggest </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.568.1">challenges on embedded systems. </span><span class="koboSpan" id="kobo.568.2">Therefore, writing safer application code is often less expensive in terms of resources than hunting for memory bugs at the system level – for example, instrumenting the allocator. </span><span class="koboSpan" id="kobo.568.3">Analyzing the lifetime of each allocated object thoroughly, and making the logic as clear and readable as possible, can prevent most of the problems related to pointer handling and save a lot of tim</span><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.569.1">e that would otherwise be </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">spent debugging.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.571.1">The memory protection unit</span></h1>
<p><span class="koboSpan" id="kobo.572.1">In a system without virtual address mapping, it is harder to create a separation between sections that can </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.573.1">be accessed by the software at runtime. </span><span class="koboSpan" id="kobo.573.2">The memory protection unit, often referred to as the MPU, is an optional component present in many ARM-based microcontrollers. </span><span class="koboSpan" id="kobo.573.3">The MPU is used to separate sections in memory by setting local permissions and attributes. </span><span class="koboSpan" id="kobo.573.4">This mechanism has several uses in real-life scenarios, such as preventing access to memory when the CPU is running in user mode, or preventing fetching code from being executed from writable locations in RAM. </span><span class="koboSpan" id="kobo.573.5">When the MPU is enabled, it enforces the rules by triggering a memory exception interrupt when those rules </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">are violated.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">While commonly used by operating systems to create process stack separation and enforce privileged </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.576.1">access to system memory, the MPU can be useful in a number of oth</span><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.577.1">er cases, including </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">bare-metal applications.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.579.1">MPU configuration registers</span></h2>
<p><span class="koboSpan" id="kobo.580.1">In the Cortex-M, the control block region related to MPU configuration is located in the system control </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.581.1">block, starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">0xE000ED90</span></strong><span class="koboSpan" id="kobo.583.1">. </span><span class="koboSpan" id="kobo.583.2">Five registers are used to access </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">the MPU:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.585.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">MPU Type Register</span></strong><span class="koboSpan" id="kobo.587.1"> (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">0x00</span></strong><span class="koboSpan" id="kobo.589.1">) contains information about the availability of </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.590.1">the MPU system and the number of regions supported. </span><span class="koboSpan" id="kobo.590.2">This register is also available on systems without an MPU to indicate that the functionality is </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">not supported.</span></span></li>
<li><span class="koboSpan" id="kobo.592.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">MPU Control Register</span></strong><span class="koboSpan" id="kobo.594.1"> (offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">0x04</span></strong><span class="koboSpan" id="kobo.596.1">) is used to activate the MPU system and enable the </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.597.1">default background mapping for all the regions that are not explicitly mapped in the MPU. </span><span class="koboSpan" id="kobo.597.2">If background mapping is not enabled, accessing non-mapped regions is </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">not allowed.</span></span></li>
<li><span class="koboSpan" id="kobo.599.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">MPU Region Number Register</span></strong><span class="koboSpan" id="kobo.601.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">RNR</span></strong><span class="koboSpan" id="kobo.603.1"> offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">0x08</span></strong><span class="koboSpan" id="kobo.605.1">) is used to select the region </span><a id="_idIndexMarker359"/><span class="No-Break"><span class="koboSpan" id="kobo.606.1">to configure.</span></span></li>
<li><span class="koboSpan" id="kobo.607.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">MPU Region Base Address Register</span></strong><span class="koboSpan" id="kobo.609.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">RBAR</span></strong><span class="koboSpan" id="kobo.611.1"> offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">0x0C</span></strong><span class="koboSpan" id="kobo.613.1">) can be accessed to change the base address of the </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">selected region.</span></span></li>
<li><span class="koboSpan" id="kobo.615.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">MPU Region Attribute and Size Register</span></strong><span class="koboSpan" id="kobo.617.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">RASR</span></strong><span class="koboSpan" id="kobo.619.1"> offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">0x10</span></strong><span class="koboSpan" id="kobo.621.1">) defines the </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.622.1">permissi</span><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.623.1">ons, attributes, and size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">selected region.</span></span></li>
</ul>
<h2 id="_idParaDest-128"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.625.1">Programming the MPU</span></h2>
<p><span class="koboSpan" id="kobo.626.1">The MPU of Cortex-M microcontrollers supports up to eight different programmable regions. </span><span class="koboSpan" id="kobo.626.2">A function </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.627.1">that enables the MPU and sets up all the regions can be implemented and invoked at the beginning of program. </span><span class="koboSpan" id="kobo.627.2">The MPU registers are mapped in HAL libraries, but in this case, we are going to define our own version and access </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">them directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
#define MPU_BASE 0xE000ED90
#define MPU_TYPE (*(volatile uint32_t *)(MPU_BASE + 0x00))
#define MPU_CTRL (*(volatile uint32_t *)(MPU_BASE + 0x04))
#define MPU_RNR (*(volatile uint32_t *)(MPU_BASE + 0x08))
#define MPU_RBAR (*(volatile uint32_t *)(MPU_BASE + 0x0c))
#define MPU_RASR (*(volatile uint32_t *)(MPU_BASE + 0x10))</span></pre>
<p><span class="koboSpan" id="kobo.630.1">In our example, we used the following defined bit-field value definitions to set the right attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">RASR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
#define RASR_ENABLED (1)
#define RASR_RW (1 &lt;&lt; 24)
#define RASR_RDONLY (5 &lt;&lt; 24)
#define RASR_NOACCESS (0 &lt;&lt; 24)
#define RASR_SCB (7 &lt;&lt; 16)
#define RASR_SB (5 &lt;&lt; 16)
#define RASR_NOEXEC (1 &lt;&lt; 28)</span></pre>
<p><span class="koboSpan" id="kobo.635.1">The possible sizes, which </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.636.1">should end up in the size field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">RASR</span></strong><span class="koboSpan" id="kobo.638.1"> in bits 1:5, are coded </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.640.1">
#define MPUSIZE_1K (0x09 &lt;&lt; 1)
#define MPUSIZE_2K (0x0a &lt;&lt; 1)
#define MPUSIZE_4K (0x0b &lt;&lt; 1)
#define MPUSIZE_8K (0x0c &lt;&lt; 1)
#define MPUSIZE_16K (0x0d &lt;&lt; 1)
#define MPUSIZE_32K (0x0e &lt;&lt; 1)
#define MPUSIZE_64K (0x0f &lt;&lt; 1)
#define MPUSIZE_128K (0x10 &lt;&lt; 1)
#define MPUSIZE_256K (0x11 &lt;&lt; 1)
#define MPUSIZE_512K (0x12 &lt;&lt; 1)
#define MPUSIZE_1M (0x13 &lt;&lt; 1)
#define MPUSIZE_2M (0x14 &lt;&lt; 1)
#define MPUSIZE_4M (0x15 &lt;&lt; 1)
#define MPUSIZE_8M (0x16 &lt;&lt; 1)
#define MPUSIZE_16M (0x17 &lt;&lt; 1)
#define MPUSIZE_32M (0x18 &lt;&lt; 1)
#define MPUSIZE_64M (0x19 &lt;&lt; 1)
#define MPUSIZE_128M (0x1a &lt;&lt; 1)
#define MPUSIZE_256M (0x1b &lt;&lt; 1)
#define MPUSIZE_512M (0x1c &lt;&lt; 1)
#define MPUSIZE_1G (0x1d &lt;&lt; 1)
#define MPUSIZE_2G (0x1e &lt;&lt; 1)
#define MPUSIZE_4G (0x1f &lt;&lt; 1)</span></pre>
<p><span class="koboSpan" id="kobo.641.1">The first thing </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.642.1">to do when we enter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">mpu_enable</span></strong><span class="koboSpan" id="kobo.644.1"> function is to ensure that the feature is available on our target, by checking the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">MPU_TYPE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
int mpu_enable(void)
{
  volatile uint32_t type;
  volatile uint32_t start;
  volatile uint32_t attr;
  type = MPU_TYPE;
  if (type == 0) {
    /* MPU not present! </span><span class="koboSpan" id="kobo.647.2">*/
    return -1;
  }</span></pre>
<p><span class="koboSpan" id="kobo.648.1">In order to configure the MPU, we must ensure that it is disabled while we change the base addresses and the attributes of </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">each region:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
  MPU_CTRL = 0;</span></pre>
<p><span class="koboSpan" id="kobo.651.1">The flash region that contains the executable code can be marked as read-only region </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">0</span></strong><span class="koboSpan" id="kobo.653.1">. </span><span class="koboSpan" id="kobo.653.2">The values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">RASR</span></strong><span class="koboSpan" id="kobo.655.1"> attributes are </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
  start = 0;
  attr = RASR_ENABLED | MPUSIZE_256K | RASR_SCB |
       RASR_RDONLY;
  mpu_set_region(0, start, attr);</span></pre>
<p><span class="koboSpan" id="kobo.658.1">The whole RAM region can be mapped as read-write. </span><span class="koboSpan" id="kobo.658.2">If we do not need to execute code from RAM, we can set the </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">execute-never</span></strong><span class="koboSpan" id="kobo.660.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.661.1">XN</span></strong><span class="koboSpan" id="kobo.662.1">) bit in the region attributes. </span><span class="koboSpan" id="kobo.662.2">RAM is mapped as region </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">1</span></strong><span class="koboSpan" id="kobo.664.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">this case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
  start = 0x20000000;
  attr = RASR_ENABLED | MPUSIZE_64K | RASR_SCB | RASR_RW 
      | RASR_NOEXEC;
  mpu_set_region(1, start, attr);</span></pre>
<p><span class="koboSpan" id="kobo.667.1">Since memory mapping is processed in the same order as memory region numbers, we can use region </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">2</span></strong><span class="koboSpan" id="kobo.669.1"> to create an </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.670.1">exception within region </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">1</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">Regions with higher numbers have priority over regions with lower numbers, so exceptions can be created within an existing mapping with a </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">lower number.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">Region </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">2</span></strong><span class="koboSpan" id="kobo.676.1"> is used to define a guard region as a lower boundary for the stack growing backward, the purpose of which is to intercept stack overflows. </span><span class="koboSpan" id="kobo.676.2">In fact, if at any moment the program tries to access the guard region, it triggers an exception and the operation fails. </span><span class="koboSpan" id="kobo.676.3">In this case, the guard region occupies 1 KB at the bottom of the stack. </span><span class="koboSpan" id="kobo.676.4">It has no access permissions configured in its attributes. </span><span class="koboSpan" id="kobo.676.5">The MPU ensures that the region is not accessible </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">at runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
  start = (uint32_t)(&amp;_end_stack) - (STACK_SIZE + 1024);
  attr = RASR_ENABLED | MPUSIZE_1K | RASR_SCB |
  RASR_NOACCESS | RASR_NOEXEC;
  mpu_set_region(2, start, attr);</span></pre>
<p><span class="koboSpan" id="kobo.679.1">Finally, we describe the system area as a read-write, non-executable, and non-cacheable area so that the program will still be able to access the system registers after the MPU has been activated again. </span><span class="koboSpan" id="kobo.679.2">We use region </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">3</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.681.1">for this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
  start = 0xE0000000;
  attr = RASR_ENABLED | MPUSIZE_256M | RASR_SB
  RASR_RW | RASR_NOEXEC;
  mpu_set_region(3, start, attr);</span></pre>
<p><span class="koboSpan" id="kobo.683.1">As a final step, we enable the MPU again. </span><span class="koboSpan" id="kobo.683.2">The MPU will allow us to define a </span><em class="italic"><span class="koboSpan" id="kobo.684.1">background region</span></em><span class="koboSpan" id="kobo.685.1">, setting the default permissions for those areas that are not covered in the active </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.686.1">region configurations. </span><span class="koboSpan" id="kobo.686.2">In this case, the absence of a definition for a background policy results in prohibited access to all the areas that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">explicitly mapped:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
  MPU_CTRL = 1;
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.689.1">The helping function that sets the starting address and the attributes for the memory regions looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.691.1">
static void mpu_set_region(int region, uint32_t start, uint32_t attr)
{
  MPU_RNR = region;
  MPU_RBAR = start;
  MPU_RNR = region;
  MPU_RASR = attr;
}</span></pre>
<p><span class="koboSpan" id="kobo.692.1">The value used to set attributes and sizes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">MPU_RASR</span></strong><span class="koboSpan" id="kobo.694.1"> in this example is defined according to the structure of the register itself. </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">MPU_RASR</span></strong><span class="koboSpan" id="kobo.696.1"> is a bit-field register, containing the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">following fields:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.698.1">Bit 0</span></strong><span class="koboSpan" id="kobo.699.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">enable/disable region.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.701.1">Bits 1:5</span></strong><span class="koboSpan" id="kobo.702.1">: The size of the partition (see the special values to assign to </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">this field).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.704.1">Bits 16:18</span></strong><span class="koboSpan" id="kobo.705.1">: Indicate whether the memory is bufferable, cacheable, and shared, respectively. </span><span class="koboSpan" id="kobo.705.2">Devices and system registers should be marked as non-cacheable at all times to guarantee the strict order of the transaction, as explained at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">this chapter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.707.1">Bits 24:26</span></strong><span class="koboSpan" id="kobo.708.1">: Access permissions (read/write), separated for user and </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">supervisor mode.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.710.1">Bit 28</span></strong><span class="koboSpan" id="kobo.711.1">: Disable execution (the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">XN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.713.1"> flag).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.714.1">It is now possible to write a program that overflows the stack and see the difference in the debugger </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.715.1">when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">mpu_enable</span></strong><span class="koboSpan" id="kobo.717.1"> function is called and when it is not. </span><span class="koboSpan" id="kobo.717.2">If the MPU is available on the target, it is now able to intercept stack overflows, triggering an exception in </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">the CPU:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.719.1"><img alt="Figure 5.6 – The guard region is marked as inaccessible in the MPU to prevent stack overflows" src="image/B18730_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.720.1">Figure 5.6 – The guard region is marked as inaccessible in the MPU to prevent stack overflows</span></p>
<p><span class="koboSpan" id="kobo.721.1">The configuration we used in this case for the MPU is very strict, not allowing access to any memory, except for the regions mapping flash and RAM. </span><span class="koboSpan" id="kobo.721.2">The extra 1-KB guard region ensures that we can detect stack overflows at runtime. </span><span class="koboSpan" id="kobo.721.3">This configuration in fact introduces an artificial separation between the two regions allocated for heap and stack areas, in a physically continuous space, by introducing a block that replicates inaccessible blocks in between. </span><span class="koboSpan" id="kobo.721.4">Although allocations in the heap exceeding the heap limit will </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.722.1">not directly trigger an overflow, any memory access in the guard region will cause a </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">memory fault.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">In real applications, the MPU configuration may be more complex and even change its values at runtime. </span><span class="koboSpan" id="kobo.724.2">In </span><a href="B18730_10.xhtml#_idTextAnchor357"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.726.1">, </span><em class="italic"><span class="koboSpan" id="kobo.727.1">Parallel Tasks and Scheduling</span></em><span class="koboSpan" id="kobo.728.1">, for example, we will explain how the MPU can be used to isolate</span><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.729.1"> thread address spaces in a real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">operating system.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.731.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.732.1">Memory management in an embedded system is the source of the most critical bugs, and for this reason, particular attention must be dedicated to designing and implementing the correct solutions for the platform in use and application purposes. </span><span class="koboSpan" id="kobo.732.2">The execution stack should be carefully placed, sized, and delimited </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">when possible.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">Systems not providing dynamic allocations are safer, but embedded systems with higher complexity benefit from dynamic allocation techniques. </span><span class="koboSpan" id="kobo.734.2">Programmers must be aware that errors in memory handling can be critical for a system and very difficult to spot, so extra care is required when code handles dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">allocated pointers.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">The MPU can be a vital tool to enforce access permissions and attributes on memory regions, and it can be used for several purposes. </span><span class="koboSpan" id="kobo.736.2">In the example shown, we implemented an MPU-based mechanism to enforce a physical boundary for the </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">stack pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">In the next chapter, we will examine other common components included in modern microcontrollers. </span><span class="koboSpan" id="kobo.738.2">We will learn how to handle clock settings, interrupt priorities, general-purpose I/O communication, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">optional features.</span></span></p>
</div>


<div class="Content" id="_idContainer034">
<h1 id="_idParaDest-130"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.1.1">Part 3 – </span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2.1">Device Drivers and Communication Interfaces</span></span></h1>
<p><span class="koboSpan" id="kobo.3.1">This part explains how to program interface and device drivers typical of an embedded system. </span><span class="koboSpan" id="kobo.3.2">All the system communication from and to the outside world, up to distributed systems communicating via TCP/IP, will be covered in this part, with particular attention paid to increasing the security of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">IoT solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following chapters:</span></span></p>
<ul>
<li><a href="B18730_06.xhtml#_idTextAnchor194"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">General-Purpose Peripherals</span></em></li>
<li><a href="B18730_07.xhtml#_idTextAnchor230"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Local Bus Interfaces</span></em></li>
<li><a href="B18730_08.xhtml#_idTextAnchor275"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Power Management and Energy Saving</span></em></li>
<li><a href="B18730_09.xhtml#_idTextAnchor311"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Distributed Systems and IoT Architecture</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer035">
</div>
</div>
</body></html>