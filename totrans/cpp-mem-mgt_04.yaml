- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journey to a better and deeper understanding of memory management in C++
    now emerges into the world of clean code and contemporary practices. In previous
    chapters we have explored fundamental concepts of in-memory representation (what
    are objects, references, pointers, and so on), what pitfalls await us if we stray
    from sound programming practices in inappropriate ways, and how we can lie to
    the type system in a controlled and disciplined manner, all of which will be helpful
    in the rest of this book. We will now discuss fundamental aspects of resource
    management in our language; memory being a special kind of resource, the ideas
    and techniques found in this chapter will help us write clean and robust code,
    including code that performs memory management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ is a programming language that supports (among other paradigms) object-oriented
    programming, but with actual objects. This sounds like a jest of sorts, but it’s
    actually a true statement: many languages only provide indirect access to objects
    (through pointers or references), which means that in these languages the semantics
    of assignment are usually sharing the referred object (*the pointee*). There are
    upsides to this, of course: for example, copying a reference typically cannot
    fail whereas copying an object can fail if the copy constructor or copy assignment
    (depending on the situation) throws an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, by default, programs use objects, copy objects, assign to objects, and
    so on, and indirect access is opt-in, requiring additional syntax both for pointers
    and references. This requires C++ programmers to think about object lifetimes,
    what it means to copy an object, what it means to move from an object… These can
    be deep topics depending on the types involved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) for more information on
    objects and object lifetime, including the role of constructors and destructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if having actual objects in your source code requires adjusting your mindset
    when programming, it also provides a significant advantage: automatic objects
    are destroyed when they reach the end of the scope in which they were declared
    (when they reach the closing brace of that scope) and when an object gets destroyed
    a special function, the type’s `}`, the closing brace.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at what destructors do, what they should not do,
    when they should be written (and when we should stick to what the compiler does
    by default), as well as how our code can use destructors effectively to manage
    resources in general… and memory more specifically. Then, we will take a quick
    look at some key types from the standard library that use destructors to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, in his chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a general overview of how resources can be managed safely in C++;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a close look at the RAII idiom, a well-known idiomatic practice that uses
    an object’s lifetime to ensure that resources managed by that object are properly
    released;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine some pitfalls associated with automated resource management;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give a quick overview of some automated resource management tools provided by
    the standard library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will understand the most common ideas and practices
    one associates with resource management in C++. This will allow us to build more
    powerful abstractions throughout the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On destructors: a short recap'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter aims to discuss the use of destructors to manage resources, in
    particular memory, but since we discussed destructors a while ago (in [*Chapter
    1*](B21071_01.xhtml#_idTextAnchor016)) we will allow ourselves a quick recap of
    the basic idea behind this powerful idea:'
  prefs: []
  type: TYPE_NORMAL
- en: When an object reaches the end of its lifetime, a special member function called
    the destructor is called. For some class `X`, that member function is named `X::~X()`.
    This function is an occasion for type `X` to perform a few “last-minute” actions
    before concluding its lifetime. As we will discuss in this chapter, one idiomatic
    use of the destructor is to release resources held by the object being destroyed;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a class hierarchy, when an object reaches the end of its lifetime, what happens
    is (a) the destructor for that object gets called, then the same goes for (b)
    the destructor of each of its non-`static` data member in order of declaration
    followed by (c) the destructor of each of its base class sub-objects (its “parents”,
    informally) in order of declaration;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When explicitly destroying an object through the application of `operator delete`
    on a pointer, the resulting process involves the destruction of the pointee followed
    by the deallocation of the memory block where the object was located. Unsurprisingly,
    there are caveats to this as we will see [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some situations, notably when some class `X` exposes at least one `virtual`
    member function, this sends the message that an `X*` might in practice point to
    an object of a class `Y` directly or indirectly derived from `X`. To ensure that
    the destructor of `Y` is actually called, not the destructor of `X`, it is customary
    to also qualify `X::~X()` as `virtual`. Not doing so risks not calling the correct
    destructor, leading to resource leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a small example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run that code, you will see one destructor called for `base` and two
    called for `derivedA`: the derived class’ destructor followed by the base class’
    destructor. This is as expected, and this part of the code is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problematic case is `pBase`, a pointer of type `Base*` which points to
    an object of a class derived from `Base`, as the destructor of `Base` is not `virtual`
    which indicates that trying to `delete` the derived object through a pointer to
    the base class is probably a breach of intent: `delete pBase` only calls `Base::~Base()`,
    never calling `DerivedA::~DerivedA()`. With `pVirtBase` this problem is avoided
    as `VirtBase::~VirtBase()` is `virtual`.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in C++, we have options because there are always surprising use-cases
    that come up, and we will see one in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116)
    where we will delete a pointer-to-derived from a pointer-to-base without the mediation
    of a `virtual` destructor for good (if specialized) reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `virtual` member functions are useful, but they have costs: a typical
    implementation will make a table of function pointers per type with at least one
    `virtual` member function and store a pointer to that table in each such object,
    which makes objects slightly bigger. As such, use `virtual` destructors when you
    expect to use a pointer to a derived object from a pointer to one of its bases,
    particularly when you expect the destructor to be called through a pointer to
    said base class.'
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, let’s examine how all this relates to resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Managing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you are writing a function that opens a file, reads from it, and closes
    it afterward. You are developing on a procedural platform (like most operating
    system APIs are) offering a set of functions to perform these tasks. Note that
    all “operating system” functions in this example are deliberately fictional but
    resemble their real-world counterparts. The functions interesting to us in that
    API are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose your code needs to process the data read from the file, but that this
    processing can throw an exception. The reason for that exception is unimportant
    here: it can be corrupt data, failure to allocate memory, calling some auxiliary
    function that throws, and so on. The key point is that there is a risk that the
    function will throw.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to write code for that function naïvely, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That code works, and in the absence of exceptions does pretty much what we want.
    Now, suppose `process(v)` throws an exception… What happens?
  prefs: []
  type: TYPE_NORMAL
- en: In this case, function `f()` exits, failing to meet its postconditions. The
    call to `process(v)` never concludes… and `close_file(file);` never gets called.
    We have a leak. Not necessarily a *memory* leak, but a leak nonetheless as `file`
    never gets closed, since an exception thrown from `process()` but not caught in
    calling code `f()` will conclude `f()` and let the exception flow through to `f()`’s
    caller (and so on, until caught or until the program crashes, whichever comes
    first).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways around this situation. One is to proceed “manually” and add
    a `try` … `catch` block around the code that could throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I agree this is a bit “clunky”, with two occurrences of `close_file(file)`,
    one at the end of the `try` block to close the file under normal occurrences,
    and another at the end of the `catch` block to avoid leaking the file’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manual approach can be made to work, but that is a brittle approach to
    the problem: in C++, any function that is neither `noexcept` nor `noexcept(true)`
    could throw; this means that in practice, almost any expression could throw.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching anything
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, there’s no single, mandated base class for all exception types as one
    could see in some other languages. Indeed, `throw 3;` is totally legal C++ code.
    On top of this, C++ has extremely powerful generic programming mechanisms which
    makes generic code prevalent in our language. Consequently, we often find ourselves
    calling functions that could throw but for which we cannot really know what could
    be thrown. Know that `catch(...)` will catch any C++ object used to represent
    an exception: you will not know *what* you caught, but you *will* have caught
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, we will typically want to intercept exceptions, probably to do
    some cleanup, then let that exception continue on its way unchanged in order to
    let client code deal with it as needed. The cleanup part is because we want our
    function to be `catch(...)` block, simply use `throw;` which is said to be the
    “re-throw”.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling… or not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This leads to another question: in a function such as `f()` where we only aim
    to consume data and process it for our purposes, should we really seek to handle
    exceptions? Think about it: the requirements for throwing an exception are significantly
    different from those for *handling* an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we throw an exception from a function to signal that our function cannot
    achieve its postconditions (it cannot do the task it was meant to do): maybe memory
    is insufficient, maybe the file to read from does not exist, maybe performing
    that integral division you asked for would lead to dividing by zero, therefore
    destroying the universe (and we don’t want that to happen), maybe one of the functions
    called by our function cannot satisfy its own postconditions in ways we did not
    foresee or did not want to handle… There are plenty of reasons for a function
    to fail. Many are the situations where a function might find itself in a position
    where to proceed further would lead to severe problems, and in some cases (constructors
    and overloaded operators come to mind) exceptions really are the only sensible
    way to signal a problem to client code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling an exception per se is a much rarer occurrence: to throw an exception,
    one has to recognize a problem, but to handle an exception one needs an understanding
    of context. Indeed, the actions one would perform in reaction to an exception
    in an interactive console application are different from those performed for an
    audio application when people are moving on the dance floor, or from those required
    when facing a nuclear code meltdown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most functions need to be exception-safe to some extent (there are flavors
    to this) more than they need to handle the problem. In our example, the difficulties
    stem from the manual closing of `file` in the advent of an exception. The easiest
    way to avoid this manual resource handling is to automate it, and what happens
    at the end of a function whether that function completes normally (reaching the
    function’s closing brace, hitting a `return` statement, seeing an exception “fly
    by”) is better modelled by a destructor. This practice has become so well ingrained
    in C++ programmers’ practices that it is considered idiomatic and has been given
    a name: the *RAII idiom*.'
  prefs: []
  type: TYPE_NORMAL
- en: The RAII idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ programmers tend to use destructors to automate the releasing of resources,
    and this can truly be said to be an idiomatic programming technique in our language,
    so much that we have given it a name. Probably not the best of names, but a well-known
    name nonetheless: **RAII**, which stands for **Resource acquisition is initialization**
    (some have also suggested **Responsibility acquisition is initialization**, which
    also works and carries a similar meaning). The general idea is that objects tend
    to acquire resources at construction time (or later), but (and more importantly!)
    that releasing resources held by an object is something that usually should be
    done at the end of that object’s lifetime. Thus, RAII has more to do with destructors
    than with constructors, but as I said, we tend to be bad with names and acronyms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting our file reading and processing example from the Managing resources
    section, earlier in this chapter, we can build an RAII resource handler to facilitate
    file closing regardless of how the function concludes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: template <class F> class scoped_finalizer { // simplified
  prefs: []
  type: TYPE_NORMAL
- en: F f;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'scoped_finalizer(F f) : f{ f } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ~scoped_finalizer() {
  prefs: []
  type: TYPE_NORMAL
- en: f();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: void f(const char *name) {
  prefs: []
  type: TYPE_NORMAL
- en: FILE *file = open_file(name);
  prefs: []
  type: TYPE_NORMAL
- en: if(!file) return; // failure
  prefs: []
  type: TYPE_NORMAL
- en: auto sf = scoped_finalizer{ [&file] {
  prefs: []
  type: TYPE_NORMAL
- en: close_file(file);
  prefs: []
  type: TYPE_NORMAL
- en: '} }; // <-- sf manages file now'
  prefs: []
  type: TYPE_NORMAL
- en: vector<char> v;
  prefs: []
  type: TYPE_NORMAL
- en: char buf[N]; // N is a positive integral constant
  prefs: []
  type: TYPE_NORMAL
- en: for(int n = read_from(file, buf, N); n != 0;
  prefs: []
  type: TYPE_NORMAL
- en: n = read_from(file, buf, N))
  prefs: []
  type: TYPE_NORMAL
- en: v.insert(end(v), buf + 0, buf + n);
  prefs: []
  type: TYPE_NORMAL
- en: process(v); // our processing function
  prefs: []
  type: TYPE_NORMAL
- en: '} using blocks, Java has try-with blocks, Go has a defer keyword, etc., but
    in C++ the possibility to use scope in order to automate actions, often related
    to resource management, flows directly from the type system and makes objects,
    not user code, the ones that idiomatically manage resources.'
  prefs: []
  type: TYPE_NORMAL
- en: RAII and C++’s special member functions
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) described the six special member
    functions (default constructor, destructor, copy constructor, copy assignment,
    move constructor, and move assignment). When one implements these functions in
    a class, it usually means that class is responsible for some resource. As mentioned
    in [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016), when a class does not explicitly
    manage resources, we can often leave those functions to the compiler and the resulting
    default behavior will usually lead to simpler and more efficient code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider now that the RAII idiom is mostly about resource management, as we
    associate the moment of destruction for an object with the act of releasing previously
    acquired resources. Numerous RAII objects (including classes `FileCloser` and
    `scoped_finalizer` in the preceding examples) can be said to be responsible for
    the resources we provide them with, which means that copying these objects could
    induce bugs (who would be responsible for the resources, the original or the copy?).
    Thus, consider deleting the copy operations for your RAII types unless you have
    a good reason to implement them explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Like most idioms, RAII is a generally accepted good programming practice, but
    it’s not a panacea and the same goes for the use of destructors in general. We
    will look at some risks involved with destructors, and how we can avoid getting
    in such trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Some pitfalls
  prefs: []
  type: TYPE_NORMAL
- en: Destructors are wonderful. They allow us to automate tasks, they simplify code
    and they make it safer in general. Still, there are some caveats, some aspects
    of using destructors that require particular attention.
  prefs: []
  type: TYPE_NORMAL
- en: Destructors should not throw
  prefs: []
  type: TYPE_NORMAL
- en: 'The title of this section says it quite simply: destructors should not throw.
    They *can* throw, but it’s a bad idea to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That might seem surprising at first. After all, constructors can (and do!)
    throw exceptions. When a constructor throws, it means that the constructor cannot
    satisfy its postconditions: the object under construction was not constructed
    (the constructor did not complete!) so that object does not exist. That’s a simple,
    working model.'
  prefs: []
  type: TYPE_NORMAL
- en: If a destructor throws… well, it’s probably the end of your program. Indeed,
    destructors are implicitly `noexcept`, which means that throwing from a destructor
    will call `std::terminate()` and that will be the end of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, you might think, what if I explicitly mark my destructor as `noexcept(false)`
    then, thus overriding the default behavior? Well, this can work, but be careful
    as if a destructor throws during stack unwinding, such as what happens when an
    exception is already in flight, then this still calls `std::terminate()` and since
    you’ve been bad and have broken the rules, the compiler can optimize some of your
    code away. For example, in the following program it’s quite possible that neither
    `"A\n"` nor `"B\n"` will be printed even though the destructor of `Evil` has not
    been called at that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A probable result from this code can simply be that the program will display
    nothing at all, and some information to the effect that throwing `Darn` has led
    to calling `std::terminate()` will be output. Why is some of the code (notably
    the messages we tried to output) visibly removed by the compiler? The answer is
    that an exception thrown but never caught enters implementation-defined behavior,
    and the throwing of `Darn` in this case cannot be caught (it directly calls `std::terminate()`
    as it happens during stack unwinding) which lets the compiler optimize our code
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarizing: don’t throw from a destructor unless you really know what you’re
    doing, control the context where it will be called, and have discussed it with
    others to make sure it’s reasonable even though all evidence points to the contrary.
    Even then, it’s probably better to look for alternative approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Know thy destruction order
  prefs: []
  type: TYPE_NORMAL
- en: 'The title of this section might seem like a funny admonition. Why is it important
    to know about the order in which our objects will be destroyed? After all, the
    basic rule is simple: construction and destruction of objects are symmetrical,
    thus objects are destroyed in reverse order of construction… right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that is the case for local, automatic objects. If you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '… then the order of construction and destruction will be as noted in the comments:
    automatic objects in scope are destroyed in reverse order of construction, and
    nested scopes behave as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation gets more complex if you add non-automatic objects to the mix.
    C++ lets one have `static` objects declared within a function: these are constructed
    when the function is called for the first time and stay alive from that point
    on until the end of the program’s execution. C++ lets one have global variables
    (there are many nuances here with linkage specifications such as `static` or `extern`)
    C++ lets one have `static` data members in a class: these are essentially global
    variables too. I won’t even get to `thread_local` variables here as they are out
    of scope for this book but if you use them, know that they can be lazily initialized
    which adds to the complexity of the overall picture. Global objects are destroyed
    in reverse order of construction, but that order of construction is not always
    trivial to predict from our human perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, which uses `Verbose` objects that inform us
    of their moment of construction as well as of their moment of destruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment to let this example sink in and try to figure out what will be
    displayed. We have a global object, a `static` and `inline` data member in a class,
    two `static` objects local to functions as well as some local automatic objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what will be displayed if we run this program? If you try it, you should
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first one to be constructed (and the last one to be destroyed) is `v0`,
    the `static` `inline` data member. It also happens to be our first global object,
    followed by `v2` (our second global object). We then enter `main()` and create
    `v6` which will be destroyed at the end of `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look at the output for that program, you’ll see that symmetry breaks
    down at this point since after the construction of `v6`, we construct `v7` (in
    an inner, narrower scope; `v7` will be destructed soon after) and then call `f()`
    for the first time which constructs `v3`, but `v3` is a global object and will
    for that reason be destroyed *after* `v6` and `v7`.
  prefs: []
  type: TYPE_NORMAL
- en: The overall process is mechanical and deterministic, but understanding it requires
    some thought and analysis. If we use our objects’ destructors to release resources,
    failure to understand what happens and when it happens can lead to our code trying
    to use resources that have already been freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a concrete example involving a mix of automated and manual resource management,
    let’s look at something the C++ standard knows nothing about: dynamically linked
    libraries (`.dll` files). I’m not going to get into details here, so know that
    if you are on a Linux machine (using shared objects, `.so` files) or on a Mac
    (`.dylib` files), the general idea’s the same but the function names will differ.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program will (a) load a dynamically linked library, (b) get the address
    of a function, (c) call this function and (d) unload the library. Suppose the
    library is named `Lib` and the function we want to call is named `factory` which
    returns a `X*` from which we want to call member function `f()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed the manual memory management in there: we acquire a
    resource (a `X*` pointing to something that’s at least an `X`) calling `factory()`
    through `factory_ptr`, then we use (call `f()` on) and manually dispose of the
    *pointee*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you’re probably telling yourself that manual resource management’s
    not the best of ideas (here: what happens to the resource if `p->f()` throws?),
    so you look through the standard and find that an object of type `std::unique_ptr`
    will take responsibility over the *pointee* and destroy it when its destructor
    is reached. Beautiful, isn’t it? And indeed it probably is, but consider the following
    excerpt, rewritten to use a `std::unique_ptr` and automate the resource management
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#include "Lib.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <memory> // std::unique_ptr'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Windows.h> // LoadLibrary, GetProcAddress'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: using namespace std;
  prefs: []
  type: TYPE_NORMAL
- en: HMODULE hMod = LoadLibrary(L"Lib.dll");
  prefs: []
  type: TYPE_NORMAL
- en: // suppose the signature of factory is in Lib.h
  prefs: []
  type: TYPE_NORMAL
- en: auto factory_ptr = reinterpret_cast<
  prefs: []
  type: TYPE_NORMAL
- en: decltype(&factory)
  prefs: []
  type: TYPE_NORMAL
- en: '>(GetProcAddress(hMod, "factory"));'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: std::unique_ptr<X> p { factory_ptr() };
  prefs: []
  type: TYPE_NORMAL
- en: p->f();
  prefs: []
  type: TYPE_NORMAL
- en: '} // p is destroyed here'
  prefs: []
  type: TYPE_NORMAL
- en: FreeLibrary(hMod);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#include <thread>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <mutex>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string_view>'
  prefs: []
  type: TYPE_NORMAL
- en: class string_mutator {
  prefs: []
  type: TYPE_NORMAL
- en: std::string text;
  prefs: []
  type: TYPE_NORMAL
- en: mutable std::mutex m;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: '// note: m in uncopiable so string_mutator'
  prefs: []
  type: TYPE_NORMAL
- en: // also is uncopiable
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator(std::string_view src)
  prefs: []
  type: TYPE_NORMAL
- en: ': text{ src.begin(), src.end() } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: template <class F> void operator()(F f) {
  prefs: []
  type: TYPE_NORMAL
- en: m.lock();
  prefs: []
  type: TYPE_NORMAL
- en: std::transform(text.begin(), text.end(),
  prefs: []
  type: TYPE_NORMAL
- en: text.begin(), f);
  prefs: []
  type: TYPE_NORMAL
- en: m.unlock();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: std::string grab_snapshot() const {
  prefs: []
  type: TYPE_NORMAL
- en: m.lock();
  prefs: []
  type: TYPE_NORMAL
- en: std::string s = text;
  prefs: []
  type: TYPE_NORMAL
- en: m.unlock();
  prefs: []
  type: TYPE_NORMAL
- en: return s;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator sm{ "I love my instructor" };
  prefs: []
  type: TYPE_NORMAL
- en: sm([](char c) {
  prefs: []
  type: TYPE_NORMAL
- en: return static_cast<char>(std::toupper(c));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << sm.grab_snaphot();
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: template <class M>
  prefs: []
  type: TYPE_NORMAL
- en: class lock_guard { // simplified version
  prefs: []
  type: TYPE_NORMAL
- en: M &m;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lock_guard(M &m) : m { m } { m.lock(); }'
  prefs: []
  type: TYPE_NORMAL
- en: ~lock_guard() { m.unlock(); }
  prefs: []
  type: TYPE_NORMAL
- en: lock_guard(const lock_guard&) = delete;
  prefs: []
  type: TYPE_NORMAL
- en: lock_guard& operator=(const lock_guard&) = delete;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#include <thread>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <mutex>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string_view>'
  prefs: []
  type: TYPE_NORMAL
- en: class string_mutator {
  prefs: []
  type: TYPE_NORMAL
- en: std::string text;
  prefs: []
  type: TYPE_NORMAL
- en: mutable std::mutex m;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: '// note: m in uncopiable so string_mutator'
  prefs: []
  type: TYPE_NORMAL
- en: // also is uncopiable
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator(std::string_view src)
  prefs: []
  type: TYPE_NORMAL
- en: ': text{ src.begin(), src.end() } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: template <class F> void operator()(F f) {
  prefs: []
  type: TYPE_NORMAL
- en: std::lock_guard lck{ m };
  prefs: []
  type: TYPE_NORMAL
- en: std::transform(text.begin(), text.end(),
  prefs: []
  type: TYPE_NORMAL
- en: text.begin(), f);
  prefs: []
  type: TYPE_NORMAL
- en: '} // implicit m.unlock'
  prefs: []
  type: TYPE_NORMAL
- en: std::string grab_snapshot() const {
  prefs: []
  type: TYPE_NORMAL
- en: std::lock_guard lck{ m };
  prefs: []
  type: TYPE_NORMAL
- en: return text;
  prefs: []
  type: TYPE_NORMAL
- en: '} // implicit m.unlock'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#include <fstream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: std::ifstream in{ "in.txt" };
  prefs: []
  type: TYPE_NORMAL
- en: for(char c; in.get(c); )
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << c;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
