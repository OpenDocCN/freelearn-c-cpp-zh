- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using Destructors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用析构函数
- en: Our journey to a better and deeper understanding of memory management in C++
    now emerges into the world of clean code and contemporary practices. In previous
    chapters we have explored fundamental concepts of in-memory representation (what
    are objects, references, pointers, and so on), what pitfalls await us if we stray
    from sound programming practices in inappropriate ways, and how we can lie to
    the type system in a controlled and disciplined manner, all of which will be helpful
    in the rest of this book. We will now discuss fundamental aspects of resource
    management in our language; memory being a special kind of resource, the ideas
    and techniques found in this chapter will help us write clean and robust code,
    including code that performs memory management tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对C++内存管理的更好和更深入的理解之旅现在进入了干净代码和当代实践的领域。在前面的章节中，我们探讨了内存表示的基本概念（什么是对象、引用、指针等等），如果我们以不适当的方式偏离良好的编程实践，会面临哪些陷阱，以及我们如何以受控和有纪律的方式欺骗类型系统，所有这些都将有助于本书的其余部分。现在，我们将讨论我们语言中资源管理的根本方面；内存作为一种特殊的资源，本章中找到的思想和技术将帮助我们编写干净和健壮的代码，包括执行内存管理任务的代码。
- en: 'C++ is a programming language that supports (among other paradigms) object-oriented
    programming, but with actual objects. This sounds like a jest of sorts, but it’s
    actually a true statement: many languages only provide indirect access to objects
    (through pointers or references), which means that in these languages the semantics
    of assignment are usually sharing the referred object (*the pointee*). There are
    upsides to this, of course: for example, copying a reference typically cannot
    fail whereas copying an object can fail if the copy constructor or copy assignment
    (depending on the situation) throws an exception.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种支持（包括其他范例）面向对象编程的编程语言，但使用实际的对象。这听起来像是一种玩笑，但实际上这是一个正确的陈述：许多语言只提供对对象的间接访问（通过指针或引用），这意味着在这些语言中，赋值的语义通常是共享所引用的对象（*目标*）。当然，这也有其优点：例如，复制一个引用通常不会失败，而复制一个对象可能会失败，如果复制构造函数或复制赋值（根据情况而定）抛出异常。
- en: In C++, by default, programs use objects, copy objects, assign to objects, and
    so on, and indirect access is opt-in, requiring additional syntax both for pointers
    and references. This requires C++ programmers to think about object lifetimes,
    what it means to copy an object, what it means to move from an object… These can
    be deep topics depending on the types involved.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，默认情况下，程序使用对象、复制对象、赋值给对象等，间接访问是可选的，需要为指针和引用提供额外的语法。这要求C++程序员考虑对象的生命周期，复制对象意味着什么，从对象移动意味着什么……这些话题可能很深，取决于涉及的类型。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) for more information on
    objects and object lifetime, including the role of constructors and destructors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[*第1章*](B21071_01.xhtml#_idTextAnchor016)了解更多关于对象和对象生命周期的信息，包括构造函数和析构函数的作用。
- en: 'Even if having actual objects in your source code requires adjusting your mindset
    when programming, it also provides a significant advantage: automatic objects
    are destroyed when they reach the end of the scope in which they were declared
    (when they reach the closing brace of that scope) and when an object gets destroyed
    a special function, the type’s `}`, the closing brace.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在源代码中实际使用对象需要调整编程时的思维方式，但它也提供了一个显著的优势：当自动对象达到它们声明的范围结束时（当它们达到该范围的闭合花括号时）以及当一个对象被销毁时，会调用一个特殊函数，即类型的`}`，闭合花括号。
- en: In this chapter, we will look at what destructors do, what they should not do,
    when they should be written (and when we should stick to what the compiler does
    by default), as well as how our code can use destructors effectively to manage
    resources in general… and memory more specifically. Then, we will take a quick
    look at some key types from the standard library that use destructors to our advantage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨析构函数的作用，它们不应该做什么，何时应该编写（以及何时我们应该坚持编译器默认的行为），以及我们的代码如何有效地使用析构函数来管理资源，一般而言……以及更具体地是内存。然后，我们将快速查看一些标准库中的关键类型，这些类型利用析构函数为我们带来便利。
- en: 'In more detail, in his chapter, we will:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，在他的章节中，我们将：
- en: Provide a general overview of how resources can be managed safely in C++;
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个概述，说明如何在C++中安全地管理资源；
- en: Take a close look at the RAII idiom, a well-known idiomatic practice that uses
    an object’s lifetime to ensure that resources managed by that object are properly
    released;
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细研究 RAII 习语，这是一种众所周知的惯用实践，它使用对象的生存期来确保该对象管理的资源得到适当释放；
- en: Examine some pitfalls associated with automated resource management;
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查与自动化资源管理相关的一些陷阱；
- en: Give a quick overview of some automated resource management tools provided by
    the standard library.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速概述标准库提供的某些自动化资源管理工具。
- en: By the end of this chapter, we will understand the most common ideas and practices
    one associates with resource management in C++. This will allow us to build more
    powerful abstractions throughout the remainder of the book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解与 C++ 资源管理相关的一些最常见思想和实践。这将使我们能够在本书的剩余部分构建更强大的抽象。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4)。
- en: 'On destructors: a short recap'
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于析构函数：简要回顾
- en: 'This chapter aims to discuss the use of destructors to manage resources, in
    particular memory, but since we discussed destructors a while ago (in [*Chapter
    1*](B21071_01.xhtml#_idTextAnchor016)) we will allow ourselves a quick recap of
    the basic idea behind this powerful idea:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在讨论使用析构函数来管理资源，特别是内存，但由于我们之前已经讨论过析构函数（在第[第 1 章](B21071_01.xhtml#_idTextAnchor016)中），我们将快速回顾一下这个强大想法背后的基本概念：
- en: When an object reaches the end of its lifetime, a special member function called
    the destructor is called. For some class `X`, that member function is named `X::~X()`.
    This function is an occasion for type `X` to perform a few “last-minute” actions
    before concluding its lifetime. As we will discuss in this chapter, one idiomatic
    use of the destructor is to release resources held by the object being destroyed;
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象到达其生命周期的末尾时，会调用一个特殊的成员函数，称为析构函数。对于某些类 `X`，该成员函数的名称为 `X::~X()`。这个函数是类型 `X`
    在结束其生命周期之前执行一些“最后时刻”行动的机会。正如我们将在本章中讨论的，析构函数的一种惯用用法是释放正在销毁的对象所持有的资源；
- en: In a class hierarchy, when an object reaches the end of its lifetime, what happens
    is (a) the destructor for that object gets called, then the same goes for (b)
    the destructor of each of its non-`static` data member in order of declaration
    followed by (c) the destructor of each of its base class sub-objects (its “parents”,
    informally) in order of declaration;
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类层次结构中，当一个对象到达其生命周期的末尾时，发生的情况是（a）调用该对象的析构函数，然后（b）按照声明顺序调用每个非 `static` 数据成员的析构函数，最后（c）按照声明顺序调用每个基类子对象（其“父类”，非正式地）的析构函数；
- en: When explicitly destroying an object through the application of `operator delete`
    on a pointer, the resulting process involves the destruction of the pointee followed
    by the deallocation of the memory block where the object was located. Unsurprisingly,
    there are caveats to this as we will see [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116);
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过在指针上应用 `operator delete` 来显式销毁对象时，涉及的过程是先销毁指针指向的对象，然后释放对象所在内存块的分配。不出所料，这里有一些注意事项，我们将在[第
    7 章](B21071_07.xhtml#_idTextAnchor116)中看到；
- en: In some situations, notably when some class `X` exposes at least one `virtual`
    member function, this sends the message that an `X*` might in practice point to
    an object of a class `Y` directly or indirectly derived from `X`. To ensure that
    the destructor of `Y` is actually called, not the destructor of `X`, it is customary
    to also qualify `X::~X()` as `virtual`. Not doing so risks not calling the correct
    destructor, leading to resource leaks.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是当某个类 `X` 至少公开一个 `virtual` 成员函数时，这表明 `X*` 实际上可能指向一个从 `X` 直接或间接派生的类
    `Y` 的对象。为了确保调用 `Y` 的析构函数而不是 `X` 的析构函数，通常也将 `X::~X()` 标记为 `virtual`。如果不这样做，可能会不调用正确的析构函数，从而导致资源泄露。
- en: 'For a small example, consider the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个小例子为例，考虑以下内容：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run that code, you will see one destructor called for `base` and two
    called for `derivedA`: the derived class’ destructor followed by the base class’
    destructor. This is as expected, and this part of the code is correct.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这段代码，您将看到为 `base` 调用一个析构函数，为 `derivedA` 调用两个析构函数：派生类的析构函数后跟基类的析构函数。这是预期的，并且这段代码是正确的。
- en: 'The problematic case is `pBase`, a pointer of type `Base*` which points to
    an object of a class derived from `Base`, as the destructor of `Base` is not `virtual`
    which indicates that trying to `delete` the derived object through a pointer to
    the base class is probably a breach of intent: `delete pBase` only calls `Base::~Base()`,
    never calling `DerivedA::~DerivedA()`. With `pVirtBase` this problem is avoided
    as `VirtBase::~VirtBase()` is `virtual`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题的案例是`pBase`，一个指向`Base*`类型的指针，它指向一个从`Base`派生出来的类的对象，因为`Base`的析构函数不是`virtual`，这表明尝试通过基类指针删除派生对象可能是意图的违规：`delete
    pBase`只调用`Base::~Base()`，永远不会调用`DerivedA::~DerivedA()`。通过`pVirtBase`这个问题可以避免，因为`VirtBase::~VirtBase()`是`virtual`。
- en: Of course, in C++, we have options because there are always surprising use-cases
    that come up, and we will see one in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116)
    where we will delete a pointer-to-derived from a pointer-to-base without the mediation
    of a `virtual` destructor for good (if specialized) reasons.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在C++中，我们有选择，因为总会有一些令人惊讶的使用场景出现，我们将在[*第7章*](B21071_07.xhtml#_idTextAnchor116)中看到其中一个，我们将删除一个指向派生类的指针，而无需通过`virtual`析构函数进行中介，这是出于（如果专门化）的良好（如果专门化）原因。
- en: 'Note that `virtual` member functions are useful, but they have costs: a typical
    implementation will make a table of function pointers per type with at least one
    `virtual` member function and store a pointer to that table in each such object,
    which makes objects slightly bigger. As such, use `virtual` destructors when you
    expect to use a pointer to a derived object from a pointer to one of its bases,
    particularly when you expect the destructor to be called through a pointer to
    said base class.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`virtual`成员函数是有用的，但它们也有成本：一个典型的实现将为每个类型创建一个包含至少一个`virtual`成员函数的函数指针表，并将该表的指针存储在每个这样的对象中，这使得对象稍微大一些。因此，当你期望从一个基类的指针使用派生类的指针时，尤其是在你期望通过基类指针调用析构函数时，应该使用`virtual`析构函数。
- en: With that being said, let’s examine how all this relates to resource management.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来探讨一下这一切与资源管理之间的关系。
- en: Managing resources
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理
- en: 'Suppose you are writing a function that opens a file, reads from it, and closes
    it afterward. You are developing on a procedural platform (like most operating
    system APIs are) offering a set of functions to perform these tasks. Note that
    all “operating system” functions in this example are deliberately fictional but
    resemble their real-world counterparts. The functions interesting to us in that
    API are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个函数，该函数打开一个文件，从中读取数据，然后关闭它。你在一个过程式平台上进行开发（就像大多数操作系统API一样），该平台提供了一组执行这些任务的函数。请注意，在这个例子中，所有的“操作系统”函数都是故意虚构的，但与现实世界的对应物相似。在这个API中，对我们来说有趣的函数是：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Suppose your code needs to process the data read from the file, but that this
    processing can throw an exception. The reason for that exception is unimportant
    here: it can be corrupt data, failure to allocate memory, calling some auxiliary
    function that throws, and so on. The key point is that there is a risk that the
    function will throw.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的代码需要处理从文件中读取的数据，但这种处理可能会抛出一个异常。这里异常的原因并不重要：可能是数据损坏、内存分配失败、调用某个会抛出异常的辅助函数，等等。关键点是，函数可能会抛出异常的风险。
- en: 'If we try to write code for that function naïvely, it might look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试为该函数天真地编写代码，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That code works, and in the absence of exceptions does pretty much what we want.
    Now, suppose `process(v)` throws an exception… What happens?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码是可行的，在没有异常的情况下，基本上能完成我们想要的功能。现在，假设`process(v)`抛出了一个异常…会发生什么？
- en: In this case, function `f()` exits, failing to meet its postconditions. The
    call to `process(v)` never concludes… and `close_file(file);` never gets called.
    We have a leak. Not necessarily a *memory* leak, but a leak nonetheless as `file`
    never gets closed, since an exception thrown from `process()` but not caught in
    calling code `f()` will conclude `f()` and let the exception flow through to `f()`’s
    caller (and so on, until caught or until the program crashes, whichever comes
    first).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数`f()`退出，未能满足其后置条件。对`process(v)`的调用从未结束…并且`close_file(file);`也从未被调用。我们有一个泄漏。不一定是*内存*泄漏，但确实是泄漏，因为`file`从未被关闭，因为从`process()`抛出的异常在调用代码`f()`中没有被捕获，这将结束`f()`并让异常流经`f()`的调用者（等等，直到被捕获或程序崩溃，哪个先到来）。
- en: 'There are ways around this situation. One is to proceed “manually” and add
    a `try` … `catch` block around the code that could throw:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以绕过这种情况。一种方法是“手动”进行，并在可能抛出异常的代码周围添加一个`try` … `catch`块：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I agree this is a bit “clunky”, with two occurrences of `close_file(file)`,
    one at the end of the `try` block to close the file under normal occurrences,
    and another at the end of the `catch` block to avoid leaking the file’s resources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意这有点“笨拙”，有两个`close_file(file)`的调用，一个在`try`块的末尾，以在正常情况下关闭文件，另一个在`catch`块的末尾，以避免文件资源的泄露。
- en: 'The manual approach can be made to work, but that is a brittle approach to
    the problem: in C++, any function that is neither `noexcept` nor `noexcept(true)`
    could throw; this means that in practice, almost any expression could throw.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 手动方法可以使其工作，但这是一种脆弱的解决问题的方法：在C++中，任何既不是`noexcept`也不是`noexcept(true)`的函数都可能抛出异常；这意味着在实践中，几乎任何表达式都可能抛出异常。
- en: Catching anything
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获任何东西
- en: 'In C++, there’s no single, mandated base class for all exception types as one
    could see in some other languages. Indeed, `throw 3;` is totally legal C++ code.
    On top of this, C++ has extremely powerful generic programming mechanisms which
    makes generic code prevalent in our language. Consequently, we often find ourselves
    calling functions that could throw but for which we cannot really know what could
    be thrown. Know that `catch(...)` will catch any C++ object used to represent
    an exception: you will not know *what* you caught, but you *will* have caught
    it.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，与某些其他语言中可以看到的相比，没有为所有异常类型指定一个单一的基类。确实，`throw 3;`是完全合法的C++代码。除此之外，C++拥有极其强大的泛型编程机制，这使得泛型代码在我们的语言中很普遍。因此，我们经常发现自己调用可能会抛出异常但无法真正知道会抛出什么的函数。要知道`catch(...)`会捕获任何用于表示异常的C++对象：你不知道你捕获了什么，但你确实捕获了它。
- en: In such cases, we will typically want to intercept exceptions, probably to do
    some cleanup, then let that exception continue on its way unchanged in order to
    let client code deal with it as needed. The cleanup part is because we want our
    function to be `catch(...)` block, simply use `throw;` which is said to be the
    “re-throw”.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通常会想要拦截异常，可能为了做一些清理工作，然后让那个异常保持不变地继续其路径，以便让客户端代码按需处理它。清理部分是因为我们希望我们的函数能够成为`catch(...)`块，简单地使用`throw;`，这被称为“重新抛出”。
- en: Exception handling… or not?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理…还是不处理？
- en: 'This leads to another question: in a function such as `f()` where we only aim
    to consume data and process it for our purposes, should we really seek to handle
    exceptions? Think about it: the requirements for throwing an exception are significantly
    different from those for *handling* an exception.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个问题：在一个像`f()`这样的函数中，我们只旨在消费数据并为我们自己的目的处理它，我们真的应该寻求处理异常吗？想想看：抛出异常的要求与处理异常的要求显著不同。
- en: 'Indeed, we throw an exception from a function to signal that our function cannot
    achieve its postconditions (it cannot do the task it was meant to do): maybe memory
    is insufficient, maybe the file to read from does not exist, maybe performing
    that integral division you asked for would lead to dividing by zero, therefore
    destroying the universe (and we don’t want that to happen), maybe one of the functions
    called by our function cannot satisfy its own postconditions in ways we did not
    foresee or did not want to handle… There are plenty of reasons for a function
    to fail. Many are the situations where a function might find itself in a position
    where to proceed further would lead to severe problems, and in some cases (constructors
    and overloaded operators come to mind) exceptions really are the only sensible
    way to signal a problem to client code.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们从函数中抛出异常是为了表示我们的函数无法满足其后置条件（它无法完成其预期要做的任务）：可能是内存不足，可能是要读取的文件不存在，可能是执行你要求的那个积分除法会导致除以零，从而摧毁宇宙（我们不想发生这种情况），可能是我们调用的某个函数无法以我们没有预见或不想处理的方式满足其自己的后置条件……函数失败有很多原因。许多情况下，函数可能会发现自己处于进一步执行会导致严重问题的位置，在某些情况下（构造函数和重载运算符就是例子），异常确实是向客户端代码发出问题的唯一合理方式。
- en: 'Handling an exception per se is a much rarer occurrence: to throw an exception,
    one has to recognize a problem, but to handle an exception one needs an understanding
    of context. Indeed, the actions one would perform in reaction to an exception
    in an interactive console application are different from those performed for an
    audio application when people are moving on the dance floor, or from those required
    when facing a nuclear code meltdown.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常本身是一种较为罕见的情况：抛出异常需要识别问题，但处理异常则需要理解上下文。确实，在交互式控制台应用程序中针对异常采取的行动与在人们跳舞时针对音频应用程序采取的行动不同，或者与面对核反应堆熔毁时所需的行动也不同。
- en: 'Most functions need to be exception-safe to some extent (there are flavors
    to this) more than they need to handle the problem. In our example, the difficulties
    stem from the manual closing of `file` in the advent of an exception. The easiest
    way to avoid this manual resource handling is to automate it, and what happens
    at the end of a function whether that function completes normally (reaching the
    function’s closing brace, hitting a `return` statement, seeing an exception “fly
    by”) is better modelled by a destructor. This practice has become so well ingrained
    in C++ programmers’ practices that it is considered idiomatic and has been given
    a name: the *RAII idiom*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数在某种程度上需要异常安全性（这一点有多种形式），而不仅仅是处理问题。在我们的例子中，困难源于在异常发生时手动关闭 `file`。避免这种手动资源处理的最简单方法就是自动化它，而函数结束时发生的事情，无论该函数是否正常完成（到达函数的结束括号，遇到
    `return` 语句，看到异常“飞过”），最好用析构函数来模拟。这种做法已经深深植根于 C++ 程序员的实践中，以至于被认为是惯用法，并被赋予了一个名称：*RAII
    习语*。
- en: The RAII idiom
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAII 习语
- en: 'C++ programmers tend to use destructors to automate the releasing of resources,
    and this can truly be said to be an idiomatic programming technique in our language,
    so much that we have given it a name. Probably not the best of names, but a well-known
    name nonetheless: **RAII**, which stands for **Resource acquisition is initialization**
    (some have also suggested **Responsibility acquisition is initialization**, which
    also works and carries a similar meaning). The general idea is that objects tend
    to acquire resources at construction time (or later), but (and more importantly!)
    that releasing resources held by an object is something that usually should be
    done at the end of that object’s lifetime. Thus, RAII has more to do with destructors
    than with constructors, but as I said, we tend to be bad with names and acronyms.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 程序员倾向于使用析构函数来自动释放资源，这确实可以称得上是我们语言中的惯用编程技术，以至于我们给它起了一个名字。可能不是最好的名字，但无论如何是一个众所周知的名字：**RAII**，代表**资源获取即初始化**（有些人也建议**责任获取即初始化**，这也适用，并且有相似的含义）。一般想法是，对象倾向于在构造时间（或之后）获取资源，但（更重要的是！）释放对象持有的资源通常应该在对象生命周期的末尾完成。因此，RAII
    更多地与析构函数有关，而不是与构造函数有关，但正如我所说的，我们往往在名称和缩写上做得不好。
- en: 'Revisiting our file reading and processing example from the Managing resources
    section, earlier in this chapter, we can build an RAII resource handler to facilitate
    file closing regardless of how the function concludes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章早期“管理资源”部分中的文件读取和处理示例，我们可以构建一个 RAII 资源处理器，以便无论函数如何结束都能方便地关闭文件：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: template <class F> class scoped_finalizer { // simplified
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: template <class F> class scoped_finalizer { // 简化版
- en: F f;
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: F f;
- en: 'public:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: 'scoped_finalizer(F f) : f{ f } {'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'scoped_finalizer(F f) : f{ f } {'
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~scoped_finalizer() {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ~scoped_finalizer() {
- en: f();
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: f();
- en: '}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: void f(const char *name) {
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: void f(const char *name) {
- en: FILE *file = open_file(name);
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: FILE *file = open_file(name);
- en: if(!file) return; // failure
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: if(!file) return; // 失败
- en: auto sf = scoped_finalizer{ [&file] {
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: auto sf = scoped_finalizer{ [&file] {
- en: close_file(file);
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: close_file(file);
- en: '} }; // <-- sf manages file now'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '} }; // <-- 文件现在由 sf 管理'
- en: vector<char> v;
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: vector<char> v;
- en: char buf[N]; // N is a positive integral constant
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: char buf[N]; // N 是一个正整数常量
- en: for(int n = read_from(file, buf, N); n != 0;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: for(int n = read_from(file, buf, N); n != 0;
- en: n = read_from(file, buf, N))
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: n = read_from(file, buf, N))
- en: v.insert(end(v), buf + 0, buf + n);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: v.insert(end(v), buf + 0, buf + n);
- en: process(v); // our processing function
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: process(v); // 我们的处理函数
- en: '} using blocks, Java has try-with blocks, Go has a defer keyword, etc., but
    in C++ the possibility to use scope in order to automate actions, often related
    to resource management, flows directly from the type system and makes objects,
    not user code, the ones that idiomatically manage resources.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '} 使用代码块，Java有try-with语句，Go有defer关键字等，但在C++中，使用作用域来自动化与资源管理相关的操作的可能性直接来自类型系统，使得对象而不是用户代码成为习惯性地管理资源的一方。'
- en: RAII and C++’s special member functions
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: RAII和C++的特殊成员函数
- en: '[*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) described the six special member
    functions (default constructor, destructor, copy constructor, copy assignment,
    move constructor, and move assignment). When one implements these functions in
    a class, it usually means that class is responsible for some resource. As mentioned
    in [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016), when a class does not explicitly
    manage resources, we can often leave those functions to the compiler and the resulting
    default behavior will usually lead to simpler and more efficient code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第一章*](B21071_01.xhtml#_idTextAnchor016)描述了六个特殊成员函数（默认构造函数、析构函数、复制构造函数、复制赋值运算符、移动构造函数和移动赋值运算符）。当一个类实现这些函数时，通常意味着该类负责某些资源。如[*第一章*](B21071_01.xhtml#_idTextAnchor016)中所述，当一个类没有明确管理资源时，我们通常可以将这些函数留给编译器，并且结果的行为通常会导致更简单、更高效的代码。'
- en: 'Consider now that the RAII idiom is mostly about resource management, as we
    associate the moment of destruction for an object with the act of releasing previously
    acquired resources. Numerous RAII objects (including classes `FileCloser` and
    `scoped_finalizer` in the preceding examples) can be said to be responsible for
    the resources we provide them with, which means that copying these objects could
    induce bugs (who would be responsible for the resources, the original or the copy?).
    Thus, consider deleting the copy operations for your RAII types unless you have
    a good reason to implement them explicitly:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下，RAII习语主要关于资源管理，因为我们把对象的销毁时刻与释放之前获取的资源的行为联系起来。许多RAII对象（包括前面示例中的`FileCloser`和`scoped_finalizer`类）可以说对它们提供的资源负责，这意味着复制这些对象可能会引入错误（谁将负责资源，原始对象还是副本？）。因此，除非你有充分的理由明确实现它们，否则请考虑删除你的RAII类型的复制操作：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like most idioms, RAII is a generally accepted good programming practice, but
    it’s not a panacea and the same goes for the use of destructors in general. We
    will look at some risks involved with destructors, and how we can avoid getting
    in such trouble.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数习语一样，RAII是一种普遍接受的优秀编程实践，但它并非万能良药，析构函数的使用也是如此。我们将探讨与析构函数相关的风险，以及如何避免陷入这样的困境。
- en: Some pitfalls
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些陷阱
- en: Destructors are wonderful. They allow us to automate tasks, they simplify code
    and they make it safer in general. Still, there are some caveats, some aspects
    of using destructors that require particular attention.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数很棒。它们使我们能够自动化任务，简化代码，并在一般情况下使代码更安全。尽管如此，还有一些注意事项，使用析构函数的一些方面需要特别注意。
- en: Destructors should not throw
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数不应该抛出异常
- en: 'The title of this section says it quite simply: destructors should not throw.
    They *can* throw, but it’s a bad idea to do so.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题简单明了：析构函数不应该抛出异常。它们*可以*抛出异常，但这样做是个坏主意。
- en: 'That might seem surprising at first. After all, constructors can (and do!)
    throw exceptions. When a constructor throws, it means that the constructor cannot
    satisfy its postconditions: the object under construction was not constructed
    (the constructor did not complete!) so that object does not exist. That’s a simple,
    working model.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来有些令人惊讶。毕竟，构造函数可以（并且确实！）抛出异常。当构造函数抛出异常时，这意味着构造函数无法满足其后置条件：正在构建的对象没有被构建（构造函数没有完成！）因此，该对象不存在。这是一个简单、有效的模型。
- en: If a destructor throws… well, it’s probably the end of your program. Indeed,
    destructors are implicitly `noexcept`, which means that throwing from a destructor
    will call `std::terminate()` and that will be the end of your program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果析构函数抛出异常……嗯，这可能是你程序的终结。确实，析构函数是隐式`noexcept`的，这意味着从析构函数中抛出异常将调用`std::terminate()`，这将导致你的程序结束。
- en: 'Well, you might think, what if I explicitly mark my destructor as `noexcept(false)`
    then, thus overriding the default behavior? Well, this can work, but be careful
    as if a destructor throws during stack unwinding, such as what happens when an
    exception is already in flight, then this still calls `std::terminate()` and since
    you’ve been bad and have broken the rules, the compiler can optimize some of your
    code away. For example, in the following program it’s quite possible that neither
    `"A\n"` nor `"B\n"` will be printed even though the destructor of `Evil` has not
    been called at that point:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可能想，如果我明确地将我的析构函数标记为`noexcept(false)`，从而覆盖默认行为呢？好吧，这可以工作，但要注意，如果析构函数在栈回溯期间抛出异常，比如当异常已经在飞行中时，这仍然会调用`std::terminate()`，因为你已经做错了事，违反了规则，编译器可以优化掉你的一些代码。例如，在以下程序中，即使此时`Evil`的析构函数尚未被调用，也有可能既不会打印`"A\n"`也不会打印`"B\n"`：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A probable result from this code can simply be that the program will display
    nothing at all, and some information to the effect that throwing `Darn` has led
    to calling `std::terminate()` will be output. Why is some of the code (notably
    the messages we tried to output) visibly removed by the compiler? The answer is
    that an exception thrown but never caught enters implementation-defined behavior,
    and the throwing of `Darn` in this case cannot be caught (it directly calls `std::terminate()`
    as it happens during stack unwinding) which lets the compiler optimize our code
    significantly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可能得到的一个结果是，程序将什么也不显示，并且会输出一些类似“抛出`Darn`导致调用`std::terminate()`”的信息。为什么一些代码（特别是我们试图输出的消息）会被编译器明显地移除呢？答案是，未捕获的异常会进入实现定义的行为，而在这个例子中，抛出`Darn`无法被捕获（因为它在栈回溯期间直接调用`std::terminate()`），这使得编译器可以显著优化我们的代码。
- en: 'Summarizing: don’t throw from a destructor unless you really know what you’re
    doing, control the context where it will be called, and have discussed it with
    others to make sure it’s reasonable even though all evidence points to the contrary.
    Even then, it’s probably better to look for alternative approaches.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：除非你真的知道自己在做什么，否则不要从析构函数中抛出异常，控制它将被调用的上下文，并且与其他人讨论以确保即使所有证据都指向相反的方向，这也是合理的。即便如此，寻找替代方案可能更好。
- en: Know thy destruction order
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的析构顺序
- en: 'The title of this section might seem like a funny admonition. Why is it important
    to know about the order in which our objects will be destroyed? After all, the
    basic rule is simple: construction and destruction of objects are symmetrical,
    thus objects are destroyed in reverse order of construction… right?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节的标题可能看起来像是一个有趣的告诫。为什么了解我们的对象将被销毁的顺序很重要呢？毕竟，基本规则很简单：对象的构造和析构是对称的，因此对象将以构造的相反顺序被销毁…对吗？
- en: 'Well, that is the case for local, automatic objects. If you write the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是局部、自动对象的情况。如果你编写以下代码：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '… then the order of construction and destruction will be as noted in the comments:
    automatic objects in scope are destroyed in reverse order of construction, and
    nested scopes behave as expected.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: …然后构造和析构的顺序将如注释中所述：作用域内的自动对象将以构造的相反顺序被销毁，嵌套的作用域会按预期行为工作。
- en: 'The situation gets more complex if you add non-automatic objects to the mix.
    C++ lets one have `static` objects declared within a function: these are constructed
    when the function is called for the first time and stay alive from that point
    on until the end of the program’s execution. C++ lets one have global variables
    (there are many nuances here with linkage specifications such as `static` or `extern`)
    C++ lets one have `static` data members in a class: these are essentially global
    variables too. I won’t even get to `thread_local` variables here as they are out
    of scope for this book but if you use them, know that they can be lazily initialized
    which adds to the complexity of the overall picture. Global objects are destroyed
    in reverse order of construction, but that order of construction is not always
    trivial to predict from our human perspective.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果混合使用非自动对象，情况会变得更加复杂。C++ 允许在函数内声明`static`对象：这些对象在函数第一次被调用时构造，并从那时起一直存活到程序执行结束。C++
    允许声明全局变量（这里有很多细微差别，例如`static`或`extern`链接说明），C++ 允许在类中有`static`数据成员：这些本质上也是全局变量。我不会在这里提到`thread_local`变量，因为它们超出了这本书的范围，但如果你使用它们，要知道它们可以被延迟初始化，这增加了整体图景的复杂性。全局对象将以构造的相反顺序被销毁，但这个构造顺序并不总是可以从我们的角度来看轻易预测。
- en: 'Consider the following example, which uses `Verbose` objects that inform us
    of their moment of construction as well as of their moment of destruction:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它使用`Verbose`对象，这些对象会告诉我们它们的构造时刻以及销毁时刻：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Take a moment to let this example sink in and try to figure out what will be
    displayed. We have a global object, a `static` and `inline` data member in a class,
    two `static` objects local to functions as well as some local automatic objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考这个示例，并试图弄清楚将会显示什么。我们有一个全局对象，一个类中的`static`和`inline`数据成员，两个局部于函数的`static`对象，以及一些局部自动对象。
- en: 'So, what will be displayed if we run this program? If you try it, you should
    see:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们运行这个程序，将会显示什么？如果你尝试运行它，你应该会看到：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first one to be constructed (and the last one to be destroyed) is `v0`,
    the `static` `inline` data member. It also happens to be our first global object,
    followed by `v2` (our second global object). We then enter `main()` and create
    `v6` which will be destroyed at the end of `main()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先被构造（也是最后被销毁）的是`v0`，即`static`的`inline`数据成员。它也恰好是我们的第一个全局对象，接着是`v2`（我们的第二个全局对象）。然后我们进入`main()`并创建`v6`，它将在`main()`结束时被销毁。
- en: Now, if you look at the output for that program, you’ll see that symmetry breaks
    down at this point since after the construction of `v6`, we construct `v7` (in
    an inner, narrower scope; `v7` will be destructed soon after) and then call `f()`
    for the first time which constructs `v3`, but `v3` is a global object and will
    for that reason be destroyed *after* `v6` and `v7`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看该程序的输出，你会看到在这一点上对称性被打破了，因为`v6`构造之后，我们构造了`v7`（在一个内部更窄的作用域中；`v7`将在之后很快被销毁），然后第一次调用`f()`，这构造了`v3`，但`v3`是一个全局对象，因此它将在`v6`和`v7`之后被销毁。
- en: The overall process is mechanical and deterministic, but understanding it requires
    some thought and analysis. If we use our objects’ destructors to release resources,
    failure to understand what happens and when it happens can lead to our code trying
    to use resources that have already been freed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程是机械的和确定的，但理解它需要一些思考和解析。如果我们使用对象的析构函数来释放资源，如果未能理解发生了什么以及何时发生，可能会导致我们的代码尝试使用已经释放的资源。
- en: 'For a concrete example involving a mix of automated and manual resource management,
    let’s look at something the C++ standard knows nothing about: dynamically linked
    libraries (`.dll` files). I’m not going to get into details here, so know that
    if you are on a Linux machine (using shared objects, `.so` files) or on a Mac
    (`.dylib` files), the general idea’s the same but the function names will differ.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个涉及自动和手动资源管理的具体示例，让我们看看C++标准一无所知的东西：动态链接库（`.dll`文件）。这里我不会深入细节，所以知道如果你在Linux机器上（使用共享对象，`.so`文件）或在Mac上（`.dylib`文件），总体思路是相同的，但函数名称将不同。
- en: 'Our program will (a) load a dynamically linked library, (b) get the address
    of a function, (c) call this function and (d) unload the library. Suppose the
    library is named `Lib` and the function we want to call is named `factory` which
    returns a `X*` from which we want to call member function `f()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序将（a）加载一个动态链接库，（b）获取一个函数的地址，（c）调用这个函数，然后（d）卸载库。假设库的名称为`Lib`，我们想要调用的函数名为`factory`，它返回一个`X*`，我们想要调用其成员函数`f()`：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You might have noticed the manual memory management in there: we acquire a
    resource (a `X*` pointing to something that’s at least an `X`) calling `factory()`
    through `factory_ptr`, then we use (call `f()` on) and manually dispose of the
    *pointee*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了其中的手动内存管理：我们通过`factory_ptr`调用`factory()`来获取一个资源（一个指向至少是`X`的`X*`），然后我们使用（在`pointee`上调用`f()`）并手动释放该*指针*。
- en: 'At this point, you’re probably telling yourself that manual resource management’s
    not the best of ideas (here: what happens to the resource if `p->f()` throws?),
    so you look through the standard and find that an object of type `std::unique_ptr`
    will take responsibility over the *pointee* and destroy it when its destructor
    is reached. Beautiful, isn’t it? And indeed it probably is, but consider the following
    excerpt, rewritten to use a `std::unique_ptr` and automate the resource management
    process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在告诉自己手动资源管理并不是一个好主意（这里：如果`p->f()`抛出异常，资源会发生什么？），所以你查阅了标准，发现`std::unique_ptr`类型的对象将负责*指针*，并在其析构函数被调用时销毁它。这很美，不是吗？事实上，它可能确实如此，但考虑以下摘录，重新编写以使用`std::unique_ptr`并自动化资源管理过程：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#include "Lib.h"'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "Lib.h"'
- en: '#include <memory> // std::unique_ptr'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory> // std::unique_ptr'
- en: '#include <Windows.h> // LoadLibrary, GetProcAddress'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <Windows.h> // LoadLibrary, GetProcAddress'
- en: int main() {
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: using namespace std;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: HMODULE hMod = LoadLibrary(L"Lib.dll");
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: // suppose the signature of factory is in Lib.h
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: auto factory_ptr = reinterpret_cast<
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: decltype(&factory)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '>(GetProcAddress(hMod, "factory"));'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: std::unique_ptr<X> p { factory_ptr() };
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: p->f();
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '} // p is destroyed here'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: FreeLibrary(hMod);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#include <thread>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '#include <mutex>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string_view>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: class string_mutator {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: std::string text;
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: mutable std::mutex m;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '// note: m in uncopiable so string_mutator'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: // also is uncopiable
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator(std::string_view src)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: ': text{ src.begin(), src.end() } {'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: template <class F> void operator()(F f) {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: m.lock();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: std::transform(text.begin(), text.end(),
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: text.begin(), f);
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: m.unlock();
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: std::string grab_snapshot() const {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: m.lock();
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: std::string s = text;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: m.unlock();
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: return s;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: // ...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator sm{ "I love my instructor" };
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: sm([](char c) {
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: return static_cast<char>(std::toupper(c));
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << sm.grab_snaphot();
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: template <class M>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: class lock_guard { // simplified version
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: M &m;
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'lock_guard(M &m) : m { m } { m.lock(); }'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: ~lock_guard() { m.unlock(); }
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: lock_guard(const lock_guard&) = delete;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: lock_guard& operator=(const lock_guard&) = delete;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#include <thread>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '#include <mutex>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string_view>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: class string_mutator {
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: std::string text;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: mutable std::mutex m;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '// note: m in uncopiable so string_mutator'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: // also is uncopiable
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: string_mutator(std::string_view src)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: ': text{ src.begin(), src.end() } {'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: template <class F> void operator()(F f) {
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: std::lock_guard lck{ m };
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: std::transform(text.begin(), text.end(),
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: text.begin(), f);
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '} // implicit m.unlock'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: std::string grab_snapshot() const {
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: std::lock_guard lck{ m };
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: return text;
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '} // implicit m.unlock'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#include <fstream>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: std::ifstream in{ "in.txt" };
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: for(char c; in.get(c); )
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << c;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
