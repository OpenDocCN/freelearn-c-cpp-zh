# 资源受限的嵌入式系统

使用较小的嵌入式系统，如微控制器（MCU），意味着拥有少量的 RAM、CPU 性能和存储。本章讨论了在考虑目前可用的广泛 MCU 和**片上系统**（**SoC**）解决方案时，如何规划和高效利用有限的资源。我们将考虑以下方面

+   为项目选择合适的 MCU

+   并发性和内存管理

+   添加传感器、执行器和网络访问

+   硬件开发与实时操作系统

# 小型系统的整体图景

当首次面对一个需要至少一种类型 MCU 的新项目时，这可能看起来像是一项艰巨的任务。正如我们在第一章，“什么是嵌入式系统？”中看到的，即使我们只限制在最近发布的那些 MCU 中，可供选择的 MCU 数量也非常庞大。

似乎很明显，首先应该询问需要多少位，比如在 8 位、16 位和 32 位 MCU 之间进行选择，或者像时钟速度这样容易量化的指标，但这些指标有时具有误导性，并且通常不利于缩小产品选择范围。实际上，父类别包括足够的 I/O 和集成外围设备，以实现硬件的精简和可靠运行，以及针对设计时面临的和要求在整个产品生命周期内预测出现的处理能力。

因此，我们需要更详细地回答如下问题：

+   **外围设备**: 需要哪些外围设备来与系统其他部分交互？

+   **CPU**: 运行应用程序代码需要多少 CPU 性能？

+   **浮点数**: 我们需要硬件浮点数支持吗？

+   **ROM**: 我们需要多少 ROM 来存储代码？

+   **RAM**: 运行代码需要多少 RAM？

+   **电源和热管理**: 电力和热限制是什么？

每个 MCU 系列都有其自身的优点和缺点，尽管选择一个 MCU 系列而不是另一个最重要的因素是其开发工具的质量。对于爱好者和其他非商业项目，人们主要会考虑社区的力量和可用的免费开发工具，而在商业项目的背景下，人们还会考虑从 MCU 制造商和可能的第三方那里可以期望得到的支持。

嵌入式开发的一个关键方面是在系统编程和调试。由于编程和调试是相互交织的，我们将在稍后查看相应的接口选项，以便能够确定哪些满足我们的需求和限制。

一个流行且强大的调试接口已经成为底层联合测试行动小组（Joint Test Action Group，JTAG）IEEE 标准 1149.1 的同义词，并且可以通过经常标记为 TDI、TDO、TCK、TMS 和 TRST 的信号轻松识别，这些信号定义了恰如其分的测试行动端口（TAP）。该更大的标准已经扩展到 1149.8，但并非所有版本都适用于数字逻辑，因此我们将我们的范围限制在 1149.1 和 1149.7 下描述的减少引脚数量的版本。目前，我们只需要至少支持一个全功能的 JTAG、SWD 和 UPDI 接口。

在第七章中，我们将深入探讨基于 MCU 的系统调试以及片上调试，使用命令行工具和 IDE 进行调试。

最后，如果我们打算在接下来的几年内生产包含所选 MCU 的产品，确保 MCU（或兼容替代品）至少在此期间可用是至关重要的。信誉良好的制造商将产品生命周期信息作为其供应链管理的一部分提供，提前 1 到 2 年发送停产通知，并推荐终身购买。

对于许多应用来说，很难忽视那些价格低廉、功能强大且易于使用的 Arduino 兼容板的广泛可用性，尤其是围绕 AVR 系列 MCU 设计的流行板。在这些板中，ATmega MCU——包括 mega168/328，尤其是 mega1280/2560 变体——为高级功能以及处理输入、控制和遥测数据提供了大量的处理能力、ROM 和 RAM，以及一套丰富且差异化的外设和 GPIO。

所有这些方面都使得在承诺使用更低规格且（希望）更好的 BOM 成本更确定的变体之前进行原型制作变得极其简单。例如，ATmega2560 "MEGA"板如下所示，我们将在本章后面更详细地探讨其他板，当我们处理 AVR 平台上的多个示例时。

![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)

通常，人们会选择一些可能适用于项目的 MCU，获取开发板，将它们连接到项目系统的其他组件（通常是在它们自己的开发或分线板上），然后开始为 MCU 开发软件，使其协同工作。

随着系统越来越多的部分最终确定，开发板和面包板组件的数量将逐渐减少，直到达到开始工作于最终**印刷电路板**（**PCB**）布局的点。这一过程也将经历多次迭代，因为问题得到解决，最后时刻的功能被添加，整个系统被测试和优化。

在此类系统中，微控制器（MCUs）在物理层面上与硬件协同工作，因此通常需要同时指定硬件和软件，至少因为软件如此依赖于硬件功能。在行业中遇到的一个常见主题是硬件模块化，无论是作为具有最小附加复杂性的小型附加 PCB，向温度控制器和变频驱动器等设备添加传感器或通信接口，还是作为连接到公共串行总线的完整 DIN 轨道模块。

# 示例 - 激光切割机控制器

使用高功率激光是切割各种材料最快、最准确的方法之一。随着近年来二氧化碳（CO2）价格的急剧下降，这导致了经济实惠（便宜）的激光切割器被广泛使用，如下面的图片所示：

![图片](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)

虽然完全可以用一个基本的机罩和移动头部跨越机床的步进运动控制板来操作激光切割机，但从可用性和安全性的角度来看，这并不理想。然而，许多在网上可以购买的廉价激光切割机，然而，没有任何安全或可用性功能。

# 功能规范

为了完成产品，我们需要添加一个控制系统，该系统使用传感器和执行器来监控和控制机器的状态，确保它始终处于安全状态，并在必要时关闭激光束。这意味着要保护以下三个部分的访问：

![图片](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)

切割光束通常由二氧化碳（CO2）激光器产生，这是一种在 1964 年发明的气体激光器。高压的应用导致电流流动，从而激发构成增益介质的腔体中的气体分子，最终形成波长为 9.4 或 10.6 微米的**长波红外**（LWIR）或 IR-C 光的有序光束。

LWIR 的一个特点是它被大量材料强烈吸收，因此它可以用于雕刻、切割，甚至在组织上进行手术，因为生物组织中的水有效地吸收了激光束。这也清楚地说明了为什么人体皮肤对二氧化碳激光束的短暂暴露是极其危险的。

为了实现安全操作，必须在正常操作期间锁定机罩，关闭激光电源，并在任何联锁打开或任何其他安全条件不再满足时关闭光束快门或最好是这些措施的组合。

例如，必须遵守温度限制：大多数二氧化碳激光器由水冷气体放电管组成，如果出现冷却故障，可能会迅速开裂或弯曲。更重要的是，切割过程会产生令人烦恼或有毒的烟雾，需要不断从封闭空间中移除，以免在打开盖子时污染光学器件并排放到环境中。

这些要求需要我们监控冷却水的流量和温度、排气空气流量以及排气过滤器上的空气流量阻力（质量流量压降）。

最后，我们还想使激光切割机易于使用，避免需要“自带设备”以特定方式处理设计，然后将其转换并上传到步进运动控制器板。相反，我们希望从 SD 卡或 USB 棒加载设计项目，并使用简单的 LCD 和按钮设置选项。

# 设计要求

考虑到早期要求，我们可以制定出控制系统所需的功能列表：

+   操作员安全：

    +   存取面板上的互锁开关（面板关闭时关闭）

    +   锁定机制（机械锁定存取面板；冗余）

    +   紧急停止

+   激光冷却：

    +   泵继电器

    +   水箱中的温度传感器（冷却能力，进口温度）

    +   阀门冷却排气中的温度传感器（套管温度）

    +   流量传感器（水流速度；冗余）

+   空气排气：

    +   风扇继电器

    +   空气过滤器状态（差压传感器）

    +   风扇速度（RPM）

+   激光模块：

    +   激光功率继电器

    +   光束快门（冗余）

+   用户界面

    +   警报指示器：

        +   面板互锁

        +   空气过滤器状况

        +   风扇状态

        +   泵状态

        +   水温

    +   指示 LED 灯：

        +   等待

        +   启动

        +   操作

        +   紧急停止

        +   冷却

+   通信：

    +   与步进板进行 USB 通信（UART）

    +   运动控制：生成步进电机指令

    +   从 SD 卡/USB 棒读取文件

    +   通过以太网/Wi-Fi 接受文件

    +   NFC 读卡器以识别用户

# 与实现相关的选择

如本章开头所指出的，中端微控制器目前能够提供满足我们大部分，如果不是全部设计要求所需的资源。因此，一个棘手的问题是我们将把钱花在哪里：硬件组件还是软件开发？抛开这些难以确定的因素，我们现在将更详细地研究三个候选解决方案：

+   一块单的中端 AVR 微控制器板（ATmega2560）

+   一块高端 Cortex-M3 微控制器板（SAM3X8E）

+   一套中端微控制器板和带有操作系统的单板计算机

仅使用 Arduino Mega（ATmega2560）就几乎能满足设计要求，因为前五个部分对 CPU 速度的要求不高，只需要一些数字输入和输出引脚，以及一些模拟引脚，具体取决于我们将使用或最多使用的外围接口（例如，用于 MEMS 压力传感器）。

挑战始于上一个功能列表中的通信功能下的运动控制功能，我们突然需要将**矢量图形文件**（**.svg**）转换为一系列步进器命令。这是一个数据传输、文件解析、路径生成和机器人世界中所称的反向运动学问题的复合问题。USB 通信也可能对我们 8 位 MCU 造成问题，主要是因为峰值处理器负载与 USB 端点通信超时或 UART RX 缓冲寄存器处理超时同时发生。

关键在于知道何时换挡。运动控制是时间敏感的，因为它与物理世界的惯性相关联。此外，我们受限于控制器的处理和带宽资源，以进行控制和数据传输、缓冲以及最终的处理和输出生成。作为一个一般模式，更强大的内部或外部外围设备可以通过处理事件和内存事务来放宽时序要求，减少上下文切换和处理开销。以下是一个此类考虑的不完整列表：

+   简单的 UART 需要在 RX Complete（RXC）时收集每个字节。未能这样做会导致数据丢失，如 DOR 标志所示。一些控制器，如 ATmega8u2 到 ATmega32u4，通过 RTS/CTS 线路提供本机硬件流控制，这可以防止 PL2303 和 FT232 等 USB-UART 转换器发送数据，迫使它们在 UDR 方便地再次清空之前进行缓冲。

+   专用 USB 主机外围设备，如 MAX3421，通过 SPI 连接，有效地消除了大规模存储集成对 USB 时序的要求。

+   除了 UART 之外，网络通信外围设备由于层堆栈的复杂性，在软件中固有地进行了缓冲。对于以太网，W5500 是一个有吸引力的解决方案。

+   有时候，在实现我们选择的接口（例如串行或并行）的同时添加另一个较小的 MCU，独立处理 I/O 和模式生成是有意义的。这已经在一些具有 ATmega16u2 的 Arduino 板上成为现实，用于 USB 串行转换。

NFC 读卡器功能需求要求使用**近场通信**（**NFC**，RFID 的一个子集）来防止激光切割机的未经授权使用，这将带来最大的负担。并非因为与 NFC 读卡器的通信本身，而是由于代码大小和 CPU 要求的增加，以处理依赖于所选安全级别的证书的加密。我们还需要一个安全的地方来存储证书，这通常会增加 MCU 的规格。

现在我们已经到了考虑更高级选项的阶段。简单的 ATmega2560 仍然是一个很好的选择，因为它有大量的 GPIO，可以通过 SPI 读取 SD 卡，并与外部集成以太网芯片通信。然而，在运动控制和 NFC 读取器功能列表中的计算密集型或内存密集型任务可能会过载 MCU，或者如果尝试优化，可能会导致复杂且维护性差的解决方案。

将 MCU 升级到 Arduino Due 开发板上找到的 ARM Cortex-M3，可能会解决所有这些瓶颈。它将保留我们在 ATmega2560 上习惯的大量 GPIO，同时显著提高 CPU 性能。步进驱动模式可以在 MCU 上生成，它还提供了本地的 USB 支持，以及其他高级外设（USART、SPI 和 I2C 以及 HSMCI，这些也有 DMA）。

一个基本的 NFC 标签读取器可以通过 UART、SPI 或 I2C 连接，这个设计选择将导致一个如下的系统：

![图片](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)

第三种涉及 SBC 的方案将再次使用 ATmega2560，并添加一个低功耗的 SBC 运行操作系统。这个 SBC 将处理任何 CPU 密集型任务、以太网和 Wi-Fi 连接、USB（主机）任务等。它将通过 UART 与 ATmega 侧通信，可能需要在板之间添加数字隔离器或电平转换器，以适应 3.3V（SBC）和 5V TTL（Atmega）逻辑电平。

选择 SBC + MCU 解决方案将极大地改变软件挑战，但在硬件方面只会稍微重新组织我们的系统。这看起来如下：

![图片](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)

与大多数开发过程一样，只有少数绝对答案，许多解决方案在权衡功耗、复杂性和影响最终设计选择的维护要求后，将功能需求视为“足够好”。

在这个特定的例子中，可以选择高端的单板或双板解决方案，并且很可能会需要相同数量的努力来满足要求。主要区别之一是，基于操作系统的解决方案需要频繁更新操作系统，因为它是一个运行完整操作系统的网络连接系统，而具有卸载的硬编码 TCP/IP 堆栈和内存的嵌入式以太网控制器则通常更稳健且经过验证。

基于 Cortex-M3 的选项（或更快的 Cortex-M4）将仅包含我们自己的代码，因此不太可能存在任何容易被攻击的常见安全问题。我们不会摆脱维护的责任，但我们的代码足够小，可以完全验证和阅读，唯一的遗憾是 Arduino Due 的设计未能将引脚断开以连接外部以太网 PHY，这阻碍了其内部以太网 MAC 的使用。

检查我们在本章开头制定的清单，但这次考虑到 ATmega2560 + SBC 和应用，我们得到以下任务分配：

+   **外围设备**: MCU 端将主要需要 GPIO、一些模拟（ADC）输入、以太网、USB，以及 SPI 和/或 I2C。

+   **CPU**: 所需的 MCU 性能是时间敏感的但微不足道的，除了当我们需要将矢量路径元素转换为步进指令时。只要可以为 MCU 端执行排队足够的命令，并且避免时间敏感的交互，SBC 端可以很复杂。

+   **浮点数**: 如果我们有硬件浮点支持，MCU 上的步进指令转换算法将执行得更快。涉及的长度和时间尺度可能使得定点运算可行，从而放宽这一要求。

+   **ROM**: 整个 MCU 代码可能只需几 KB，因为它并不复杂。SBC 代码会因为调用高级库以提供所需功能而大得多，但这将被类似规模的大容量存储和处理能力所超过。

+   **RAM**: MCU 上只需要几 KB 的 SRAM 就足够了。步进指令转换算法可能需要修改以适应 SRAM 的限制，包括缓冲和处理数据的要求。在最坏的情况下，缓冲区可以缩小。

+   **电源和散热**: 考虑到激光切割系统的功率需求和冷却系统，我们没有明显的电源或散热限制。包含控制系统的部分还包含主电源，并且已经配备了适当尺寸的冷却风扇。

在这一点上，重要的是要注意，尽管我们已经充分认识到手头任务的复杂性和要求，足以得出结论，引导我们选择硬件组件，但如何详细实现这些方面仍然留给软件开发者。

例如，我们可以定义自己的数据结构和格式，并自行实现针对特定机器的路径生成和运动控制，或者采用（RS-274）G 代码中间格式，该格式已在数控应用中确立了几十年，非常适合生成运动控制命令。G 代码在 DIY 硬件社区也得到了广泛接受，尤其是在 FDM 3D 打印方面。

一个值得注意的成熟开源 G 代码运动控制实现是 GRBL，介绍如下：

Grbl 是一个免费、开源、高性能的软件，用于控制移动机器的运动，制造物品或使物品移动，并且可以在 Arduino 上运行。如果创客运动是一个行业，Grbl 将是行业标准。

--https://github.com/gnea/grbl

很可能我们需要为我们的安全检查的不同违规行为添加停止和紧急停止功能。虽然温度异常或堵塞的过滤器可能只是停止激光切割机，并允许在问题解决后继续工作，但由打开外壳触发的互锁必须导致激光立即关闭，即使没有完成路径段和运动的最后一条命令。

将运动控制任务模块化并为其生成 G-code 的选择，除了提供经过验证的实现之外，还有其他好处，使我们能够轻松添加诸如手动控制设置和校准以及使用在机器侧预先生成、可读的代码进行测试等可用性功能，就像检查我们的文件解释和路径生成算法的输出一样。

在完成需求列表、初步设计和对如何实现目标的深入理解之后，下一步将是获取带有所选 MCU 和/或 SoC 以及任何外围设备的发展板（或多个板），以便开始开发固件和集成系统。

尽管本例中描述的机器控制系统的完整实现超出了本书的范围，但本章剩余部分以及第六章、“基于操作系统的应用程序测试”，第八章、“示例 - 基于 Linux 的信息娱乐系统”，以及第十一章、“为混合 SoC/FPGA 系统开发”，将努力深入理解针对微控制器和 SBC 目标类型的开发。

# 嵌入式 IDE 和框架

虽然 SoC 的应用程序开发通常与桌面和服务器环境相似，正如我们在上一章中看到的，但 MCU 开发需要对所开发硬件的深入了解，有时甚至需要知道在特定寄存器中设置的确切位。

存在一些框架试图为特定 MCU 系列抽象出这些细节，以便可以在不担心如何在特定 MCU 上实现的情况下为通用 API 开发。在这些框架中，Arduino 框架在工业应用之外最为知名，尽管也有许多经过认证可用于生产使用的商业框架。

对于 AVR 和 SAM MCU，可以使用各种 IDE，例如 Atmel Studio、Keil µVision 和 IAR 嵌入式工作台的高级软件框架（**ASF**）。

以下是一些流行的嵌入式 IDE 的非详尽列表：

| **名称** | **公司** | **许可** | **平台** | **备注** |
| --- | --- | --- | --- | --- |
| Atmel Studio | Microchip | 专有 | AVR, SAM (ARM Cortex-M)。 | 原先由 Atmel 开发，后被 Microchip 收购。 |
| µVision | Keil (ARM) | 专有 | ARM Cortex-M, 166, 8051, 251. | **微控制器开发工具包**（**MDK**）的一部分。 |
| Embedded Workbench | IAR | 专有 | ARM Cortex-M, 8051, MSP430, AVR, Coldfire, STM8, H8, SuperH 等。 | 每个 MCU 架构都有独立的 IDE。 |
| MPLAB X | Microchip | 专有 | PIC, AVR。 | 以基于 Java 的 NetBeans IDE 为基础。 |
| Arduino | Arduino | GPLv2 | 一些 AVR 和 SAM MCU（可扩展）。 | 基于 Java 的 IDE。仅支持其自己的 C 方言语言。 |

IDE 的主要目标是整合整个工作流程到一个单一的应用程序中，从编写初始代码到使用编译后的代码编程 MCU 内存，并在平台上运行时调试应用程序。

是否使用完整的 IDE 是一个个人喜好问题，然而。当使用基本编辑器和命令行工具时，所有基本功能仍然存在，尽管像 ASF 这样的框架是为了与 IDE 深度集成而编写的。

流行 Arduino 框架的主要优势之一是它或多或少地标准化了各种 MCU 外设和其他功能的应用程序编程接口（API），这些功能支持越来越多的 MCU 架构。结合框架的开源特性，它成为新项目的吸引目标。这在原型设计方面尤其吸引人，得益于为该 API 编写的众多库和驱动程序。

不幸的是，Arduino IDE 不幸地专注于 C 编程语言的简化版本，尽管其核心库广泛使用 C++。尽管如此，这使我们能够将库集成到我们自己的嵌入式 C++项目中，正如我们将在本章后面看到的那样。

# 编程 MCU

在我们为目标 MCU 编译代码之后，需要在执行和调试之前将二进制映像写入控制器内存。在本节中，我们将探讨实现这一目标的多种方式。如今，只有通过测试插座进行工厂侧编程，或者在已知良好的晶圆上将其粘接到引线框架并封装之前，才在晶圆级别进行编程。表面贴装组件已经排除了（重复）编程时轻松移除 MCU 的可能性。

存在许多（通常是供应商特定的）在电路编程选项，这些选项根据它们使用的外设和影响的内存来区分。

因此，一个原始的 MCU 通常需要使用外部编程适配器进行编程。这些适配器通常通过设置 MCU 的引脚，使其进入编程模式，然后 MCU 接受包含新 ROM 映像的数据流。

另一个常用的选项是在 ROM 的第一部分添加引导加载程序，这允许微控制器自行编程。这是通过引导加载程序在启动时检查是否应该切换到编程模式或继续加载实际程序来实现的，该程序位于引导加载程序部分之后。

# 内存编程和设备调试

外部编程适配器通常使用专用接口和相关协议，这些协议允许对目标设备进行编程和调试。可以用于编程 MCU 的协议包括以下几种：

| **名称** | **引脚** | **特性** | **描述** |
| --- | --- | --- | --- |
| **SPI (ISP)** | **4** | 编程 | **串行外围设备接口** (**SPI**), 与较老的 AVR 微控制器一起使用以访问其串行编程器模式 (**在电路串行编程** (**ISP**)). |

| **JTAG** | **5** | 编程调试

边界 | 专用、行业标准片上编程和调试支持接口。支持 AVR ATxmega 设备。 |

| **UPDI** | **1** | 编程调试 | 与较新的 AVR 微控制器（包括 ATtiny 设备）一起使用的 **统一编程和调试接口** (**UDPI**)。它是一个单线接口，是 ATxmega 设备上发现的二线 PDI 的后继者。 |
| --- | --- | --- | --- |
| **HVPP/HVSP** | **17/5** | 编程 | 高压并行编程 / 高压串行编程。AVR 编程模式使用复位引脚上的 12V 并直接访问 8+ 个引脚。忽略任何内部熔丝设置或其他配置选项。主要用于工厂编程和恢复。 |
| **TPI** | **3** | 编程 | 小型编程接口，用于一些 ATtiny AVR 设备。这些设备也缺少 HVPP 或 HVSP 所需的引脚数量。 |

| **SWD** | **3** | 编程调试

边界 | 串行线调试。类似于具有两条线的简化 JTAG，但使用 ARM 调试接口功能，允许连接的调试器成为总线主控，并访问微控制器的内存和外设。 |

ARM 微控制器通常提供 JTAG 作为其主要的编程和调试手段。在 8 位微控制器上，JTAG 的使用频率远低于其他类型，这主要归因于其要求的复杂性。

AVR 微控制器除了高压编程模式外，通常还提供通过 SPI 的在系统编程 (ISP)。进入编程模式需要在编程和验证期间保持复位引脚低电平，并在编程周期结束时释放并触发。

ISP 的一个要求是在 MCU 中设置相关的 (SPIEN 熔丝位) 以启用在系统编程接口。如果没有设置此位，设备将不会在 SPI 线上响应。如果没有通过 JTAGEN 熔丝位启用 JTAG，则只能使用 HVPP 或 HVSP 来恢复和重新编程芯片。在后一种情况下，不寻常的引脚集和 12V 供电电压不一定很好地集成到电路板上。

对于大多数串行编程接口所需的物理连接相当简单，即使 MCU 已经如图所示集成到电路中：

![图片](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)

这里，如果存在内部振荡器，外部振荡器是可选的。**PDI**、**PDO** 和 **SCK** 线对应于它们各自的 SPI 线。复位线在编程期间保持激活（低电平）。以这种方式连接到 MCU 后，我们可以自由地向其闪存、EEPROM 和配置熔丝写入。

在较新的 AVR 设备上，我们发现 **统一编程和调试接口**（**UPDI**），它仅使用一根线（除了电源和地线）连接到目标 MCU，以提供编程和调试支持。

此接口简化了之前的连接图到以下：

![图片](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)

这与 ATxmega 上的 JTAG（IEEE 1149.1）相比是有利的：

![图片](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)

在 ATxmega 上实现的简化引脚计数 JTAG 标准（IEEE 1149）只需要一个时钟 TCKC，一根数据线 TMSC，因此被称为紧凑型 JTAG。在这些接口中，UPDI 仍然需要与目标设备的最少连接。除此之外，两者都支持类似的功能，用于 AVR MCU。

对于使用 JTAG 进行编程和调试的其他系统，没有标准连接。每个制造商都使用他们自己的首选连接器，从 2 x 5 引脚（Altera, AVR）到 2 x 10 引脚（ARM），或者一个单独的 8 引脚连接器（Lattice）。

由于 JTAG 更像是一个协议标准而不是物理规范，因此应查阅目标平台的文档以获取具体细节。

# 引导加载程序

引导加载程序被引入作为一个小的额外应用程序，它使用现有的接口（例如 UART 或 Ethernet）来提供自我编程能力。在 AVR 上，可以在其闪存中保留 256 字节到 4 KB 的引导加载程序部分。此代码可以执行任何数量的用户定义的任务，从设置与远程系统的串行连接，到通过 PXE 在以太网上从远程图像引导。

在本质上，AVR 引导加载程序与任何其他 AVR 应用程序没有不同，只是在编译时添加了一个额外的链接器标志来设置引导加载程序的起始字节地址：

```cpp
--section-start=.text=0x1800 
```

将此地址替换为您所使用的特定 MCU 的类似地址（对于 AVR，根据设置的 BOOTSZ 标志和控制器，请参阅有关引导大小配置的数据表表格：引导重置地址，例如，引导重置地址为 0xC00，以字为单位，而节起始地址以字节为单位）。这确保引导加载程序代码将被写入 MCU ROM 的正确位置。将引导加载程序代码写入 ROM 几乎总是通过 ISP 完成。

AVR MCU 将闪存 ROM 分为两个部分：**不可读/写**（**NRWW**）（对于大多数，如果不是所有应用内存空间）和**可读/写**（**RWW**）部分。简而言之，这意味着 RWW 部分可以安全地擦除和重写，而不会影响 CPU 的操作。这就是为什么引导加载程序位于 NRWW 部分，也是为什么引导加载程序不容易自我更新的原因。

另一个重要的细节是，引导加载程序也不能更新设置 MCU 中各种标志的熔丝。要更改这些，必须外部编程设备。

在使用引导加载程序编程 MCU 后，通常会设置 MCU 中的标志，让处理器知道已安装了引导加载程序。在 AVR 的情况下，这些标志是 BOOTSZ 和 BOOTRST。

# 内存管理

微控制器的存储和内存系统由多个组件组成。其中有一个**只读存储器**（**ROM**）部分，在芯片编程时只写入一次，但通常不能由 MCU 本身修改，正如我们在上一节中看到的。

MCU 还可能有一小块持久存储，形式为 EEPROM 或等效设备。最后，有 CPU 寄存器和**随机存取存储器**（**RAM**）。这导致了以下示例内存布局：

![图片](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)

在 MCU 中，使用修改后的哈佛架构（在某些架构级别上分割程序和数据内存，通常使用数据总线）是常见的。例如，在 AVR 架构中，程序内存位于 ROM 中，对于 ATmega2560 来说，它使用自己的总线与 CPU 核心连接，这可以在我们之前在第一章“什么是嵌入式系统？”中看到的该 MCU 的框图中看到。

为这些内存空间拥有单独的总线的主要优点是，可以分别对它们进行寻址，这可以更好地利用 8 位处理器（1 和 2 字节宽的地址）可用的有限寻址空间。这也允许在 CPU 忙于处理其他内存空间时进行并发访问，从而进一步优化可用资源。

对于 SRAM 中的数据内存，我们可以自由地按需使用它。在这里，我们至少需要一个堆栈才能运行程序。根据 MCU 中剩余的 SRAM 量，我们还可以添加堆。使用堆栈和静态分配的内存可以实现中等复杂度的应用程序，而不涉及产生堆分配代码的高级语言功能。

# 堆栈和堆

是否需要初始化正在编程的 MCU 的堆栈取决于你希望达到多低级别。当使用 C 运行时（在 AVR 中：`avr-libc`）时，运行时会通过让链接器将裸代码放入初始化部分来处理堆栈和其他细节，例如以下指定的：

```cpp
__attribute__ ((naked, used, section (".init3")))
```

在执行我们自己的应用程序代码之前。

在 AVR 上的标准 RAM 布局是从 RAM 的起始位置开始`.data`变量，然后是`.bss`。堆栈从 RAM 的相反端开始，向起始方向增长。在`.bss`部分的末尾和堆栈的末尾之间将留有空间，如下所示：

![图片](img/c84909aa-7715-46f6-9538-5760568e9748.png)

由于堆栈的大小取决于正在运行的应用程序中函数调用的深度，因此很难确定有多少空间可用。一些 MCU 允许使用外部 RAM，这将是堆的一个可能位置，如下所示：

![图片](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)

AVR Libc 库实现了一个`malloc()`内存分配器例程，针对 AVR 架构进行了优化。使用它，可以实现自己的`new`和`delete`功能——如果需要的话——因为 AVR 工具链没有实现这两个功能。

为了使用 AVR MCU 的外部内存作为堆存储，必须确保外部内存已初始化，之后地址空间才对`malloc()`可用。堆空间的起始和结束由以下全局变量定义：

```cpp
char * __malloc_heap_start 
char * __malloc_heap_end 
```

AVR 文档关于调整堆的建议如下：

如果要将堆移动到外部 RAM，必须相应地调整`__malloc_heap_end`。这可以通过在运行时直接写入此变量来完成，或者可以在链接时自动完成，通过调整符号`__heap_end`的值。

# 中断，ESP8266 IRAM_ATTR

在台式 PC 或服务器上，整个应用程序的二进制文件会被加载到 RAM 中。然而，在微控制器（MCUs）中，通常会将尽可能多的程序指令保留在 ROM 中，直到需要时才使用。这意味着我们应用程序的大多数指令不能立即执行，而必须首先从 ROM 中检索，然后才能通过我们的 MCU 的指令总线由 CPU 获取并执行。

在 AVR 中，每个可能的中断都在一个向量表中定义，该表存储在 ROM 中。这提供了为每种中断类型提供默认处理程序或用户定义版本的功能。要标记中断例程，可以使用`__attribute__((signal))`属性，或者使用`ISR()`宏：

```cpp
#include <avr/interrupt.h> 

ISR(ADC_vect) { 
         // user code 
} 
```

此宏处理注册中断的细节。只需指定名称并定义中断处理函数即可。然后它将通过中断向量表被调用。

在 ESP8266（及其继任者 ESP32）中，我们可以使用特殊的属性`IRAM_ATTR`标记中断处理函数。与 AVR 不同，ESP8266 MCU 没有内置的 ROM，必须使用其 SPI 外设将任何指令加载到 RAM 中，这显然相当慢。

使用此属性与中断处理程序一起的示例如下：

```cpp
void IRAM_ATTR MotionModule::interruptHandler() {
          int val = digitalRead(pin);
          if (val == HIGH) { motion = true; }
          else { motion = false; }
 }
```

在这里，我们有一个与运动检测器信号连接的中断处理程序，该信号连接到一个输入引脚。与任何编写良好的中断处理程序一样，它相当简单，并且旨在在返回到应用程序的正常流程之前快速执行。

如果将此处理程序放在 ROM 中，这意味着该例程不会对运动传感器输出变化的响应接近即时。更糟糕的是，它会导致处理程序完成所需的时间更长，从而延迟应用程序代码的其余部分的执行。

通过将其标记为`IRAM_ATTR`，我们可以避免这个问题，因为当需要时，整个处理程序已经在 RAM 中，而不是整个系统停滞，等待 SPI 总线返回所需数据才能继续。

注意，尽管这种属性可能很有吸引力，但它应该被谨慎使用，因为大多数微控制器（MCU）的只读存储器（ROM）比随机存取存储器（RAM）多得多。在 ESP8266 的情况下，有 64KB 的 RAM 用于代码执行，可能还有数兆字节的外部闪存 ROM。

在编译我们的代码时，编译器会将带有此属性的指令放入一个特殊部分，这样 MCU 就知道将其加载到 RAM 中。

# 并发

除了少数例外，MCU 通常是单核系统。多任务处理通常不执行；相反，有一个单一的执行线程，定时器和中断提供了异步操作方法。

原子操作通常由编译器支持，AVR 也不例外。在以下情况下可以看到需要原子指令块的需求。请记住，尽管存在一些例外（如 MOVW 用于复制寄存器对和通过 X、Y、Z 指针进行间接寻址），在 8 位架构上的指令通常只影响 8 位值。

+   一个 16 位变量在主函数中以字节为单位读取，并在 ISR 中更新。

+   读取一个 32 位变量，修改后将其存储回主函数或 ISR 中，而其他例程可能会尝试访问它。

+   代码块的执行是时间敏感的（位带 I/O，禁用 JTAG）。

对于第一种情况，AVR libc 文档中给出了一个基本示例：

```cpp
#include <cinttypes> 
#include <avr/interrupt.h> 
#include <avr/io.h> 
#include <util/atomic.h> 

volatile uint16_t ctr; 

ISR(TIMER1_OVF_vect) { 
   ctr--; 
} 

int main() { 
         ctr = 0x200; 
         start_timer(); 
         sei(); 
         uint16_t ctr_copy; 
         do { 
               ATOMIC_BLOCK(ATOMIC_FORCEON) 
               { 
                     ctr_copy = ctr; 
               } 
         } 
         while (ctr_copy != 0); 

         return 0; 
} 
```

在此代码中，一个 16 位整数在中断处理程序中被更改，而主例程正在将其值复制到一个局部变量中。我们调用`sei()`（设置全局中断标志）以确保中断寄存器处于已知状态。`volatile`关键字提示编译器，这个变量及其访问方式不应以任何方式进行优化。

由于我们包含了 AVR 原子头文件，我们可以使用`ATOMIC_BLOCK`宏以及`ATOMIC_FORCEON`宏。这样做会创建一个保证原子执行的代码段，没有任何中断处理程序等干扰。传递给`ATOMIC_BLOCK`的参数将全局中断状态标志强制设置为启用状态。

由于我们在开始原子块之前将此标志设置为相同状态，因此我们不需要保存此标志的先前值，这节省了资源。

如前所述，微控制器（MCU）往往是单核系统，具有有限的并行处理和多线程能力。为了进行适当的并行处理和多线程，需要执行上下文切换，这不仅仅涉及保存正在运行的任务的栈指针，还包括所有寄存器和相关状态。

这意味着虽然理论上可以在单个 MCU 上运行多个线程和任务，但在 AVR 和 PIC 等 8 位 MCU（8 位范围）的情况下，这样做可能不值得，并且需要大量的劳动。

在更强大的 MCU（如 ESP8255 和 ARM Cortex-M）上，可以运行**实时操作系统**（RTOS），它正好实现了这种上下文切换，无需进行所有繁重的工作。我们将在本章后面讨论 RTOS。

# 使用 Nodate 进行 AVR 开发

Microchip 为 AVR 开发提供了 GCC 工具链的二进制版本。在撰写本文时，AVR-GCC 的最新版本是 3.6.1，包含 GCC 版本 5.4.0。这意味着完全支持 C++14，并有限支持 C++17。

使用此工具链相当简单。可以从 Microchip 网站下载它，将其提取到合适的文件夹中，并将包含 GCC 可执行文件的文件夹添加到系统路径中。之后，它可以用来编译 AVR 应用程序。某些平台将通过包管理器提供 AVR 工具链，这使得过程更加简单。

安装此 GCC 工具链后，可能会注意到没有提供 C++ STL。因此，只能使用 GCC 支持的 C++语言功能。正如 Microchip AVR 常见问题解答所述：

+   显然，没有提供与 C++相关的标准函数、类和模板类。

+   新建和删除操作符未实现；尝试使用它们会导致链接器抱怨未定义的外部引用。（这或许可以修复。）

+   一些提供的包含文件不是 C++安全的，也就是说，它们需要被包裹在`extern"C" { . . . }`中。（这当然也可以修复。）

+   异常不受支持。由于 C++前端默认启用异常，因此需要通过编译器选项中的`-fno-exceptions`显式关闭它们。否则，链接器将抱怨对`__gxx_personality_sj0`的未定义外部引用。

由于缺乏包含 STL 功能的 Libstdc++实现，我们只能通过使用第三方实现来添加此类功能。这些包括提供基本完整 STL 的版本，以及不遵循标准 STL API 的轻量级重新实现。后者的一个例子是 Arduino AVR 核心，它提供了 String 和 Vector 等类，这些类与它们的 STL 等效项类似，尽管有一些限制和差异。

作为 Microchip AVR GCC 工具链的替代品，即将推出的 LLVM 是一个编译器框架，最近已添加了对 AVR 的实验性支持，并在未来的某个时刻应该能够为 AVR 微控制器（MCU）生成二进制文件，同时通过其 Clang 前端（C/C++支持）提供完整的 STL 功能。

![图片](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)

这可以被视为 LLVM 开发的抽象快照——同时说明了 LLVM 的一般概念及其对中间表示的重视。

不幸的是，尽管 PIC 系列 MCU 也由 Microchip 拥有，并且在许多方面与 AVR 相似，但在这个阶段，Microchip 并没有为其提供 C++编译器，直到升级到基于 MIPS 的 PIC32 系列 MCU。

# 输入 Nodate

在此阶段，你可以选择使用本章之前讨论的其中一个 IDE，但这对于 AVR 开发本身的教育意义并不大。因此，我们将查看为 ATmega2560 板开发的一个简单应用程序，该程序使用 Arduino AVR 核心的修改版，称为 Nodate ([`github.com/MayaPosch/Nodate`](https://github.com/MayaPosch/Nodate))。这个框架重构了原始核心，使其能够作为一个常规的 C++库使用，而不仅仅是与 Arduino C 方言解析器和前端一起使用。

安装 Nodate 相当简单：只需将其下载到系统的一个合适位置，并让`NODATE_HOME`系统变量指向 Nodate 安装的根文件夹。之后，我们可以以其中一个示例应用程序为基础来创建一个新项目。

# 示例 - CMOS 集成电路测试仪

在这里，我们将查看一个功能更全面的示例项目，该项目实现了一个 5V 逻辑芯片的集成电路（IC）测试仪。除了用其 GPIO 引脚探测芯片外，该项目还通过 SPI 从 SD 卡读取芯片描述和测试程序（以逻辑表的形式）。用户控制通过基于串行的命令行界面实现。

首先，我们查看这个 Nodate 项目的`Makefile`，它位于项目的根目录中：

```cpp
ARCH ?= avr

 # Board preset.
 BOARD ?= arduino_mega_2560

 # Set the name of the output (ELF & Hex) file.
 OUTPUT := sdinfo

 # Add files to include for compilation to these variables.
 APP_CPP_FILES = $(wildcard src/*.cpp)
 APP_C_FILES = $(wildcard src/*.c)

 #
 # --- End of user-editable variables --- #
 #

 # Nodate includes. Requires that the NODATE_HOME environment variable has been set.
 APPFOLDER=$(CURDIR)
 export

 all:
    $(MAKE) -C $(NODATE_HOME)

 flash:
    $(MAKE) -C $(NODATE_HOME) flash

 clean:
    $(MAKE) -C $(NODATE_HOME) clean
```

我们首先指定我们针对的架构，因为 Nodate 也可以用于其他 MCU 类型。在这里，我们指定 AVR 作为架构。

接下来，我们使用 Arduino Mega 2560 开发板的预设。在 Nodate 内部，我们有多个这样的预设，它们定义了有关板子的许多细节。对于 Arduino Mega 2560，我们得到以下预设：

```cpp
MCU := atmega2560 
PROGRAMMER := wiring 
VARIANT := mega # "Arduino Mega" board type
```

如果没有定义板预设，必须在项目的 Makefile 中定义这些变量，并为每个变量选择一个现有值，每个变量都在 Nodate AVR 子文件夹中的自己的 Makefile 中定义。或者，可以在 Nodate 中添加自己的 MCU、编程器和（引脚）变体文件，以及一个新的板预设，并使用它。

当 makefile 完成后，是时候实现主函数了：

```cpp
#include <wiring.h>
 #include <SPI.h>
 #include <SD.h>

 #include "serialcomm.h"
```

wiring 标题提供了访问所有 GPIO 相关功能的方法。此外，我们还包含了 SPI 总线、SD 卡读取设备以及一个封装串行接口的自定义类的标题，我们将在稍后更详细地看到：

```cpp
int main () {
    init();
    initVariant();

    Serial.begin(9600);

    SPI.begin();
```

进入主函数后，我们通过调用 `init()` 初始化 GPIO 功能。接下来的调用加载了我们针对的特定板的引脚配置（顶部的 `VARIANT` 变量或在板的预设 Makefile 中）。

在此之后，我们以 9,600 波特率启动第一个串行端口，然后是 SPI 总线，最后是输出欢迎信息，如下所示：

```cpp
   Serial.println("Initializing SD card...");

    if (!SD.begin(53)) {
          Serial.println("Initialization failed!");
          while (1);
    }

    Serial.println("initialization done.");

    Serial.println("Commands: index, chip");
    Serial.print("> ");
```

预期此时 SD 卡已连接到 Mega 板上，其中包含我们可以测试的可用芯片列表。在这里，53 号引脚是位于板上其他 SPI 引脚旁边的硬件 SPI 芯片选择引脚。

假设板连接正确且卡可以无问题读取，我们将在控制台屏幕上看到一个命令行提示符：

```cpp
          while (1) {
                String cmd;
                while (!SerialComm::readLine(cmd)) { }

                if (cmd == "index") { readIndex(); }
                else if (cmd == "chip") { readChipConfig(); }
                else { Serial.println("Unknown command.");      }

                Serial.print("> ");
          }

          return 0;
 }
```

此循环简单地等待串行输入上的输入到达，之后它将尝试执行接收到的命令。我们用于从串行输入读取的函数是阻塞的，只有在它已经接收到了换行符（用户按下了 *Enter*）或其内部缓冲区大小超出且未收到换行符时才会返回。在后一种情况下，我们简单地忽略输入，并再次尝试从串行输入读取。这完成了 `main()` 的实现。

现在我们来看看 `SerialComm` 类的标题：

```cpp
#include <HardwareSerial.h>      // UART.

 static const int CHARBUFFERSIZE 64

 class SerialComm {
          static char charbuff[CHARBUFFERSIZE];

 public:
          static bool readLine(String &str);
 };
```

我们包含了硬件串行连接支持的标题。这使我们能够访问底层的 UART 外设。该类本身是纯静态的，定义了字符缓冲区的最大大小，以及从串行输入读取一行数据的函数。

接下来是其实现：

```cpp
#include "serialcomm.h"

 char SerialComm::charbuff[CHARBUFFERSIZE];

 bool SerialComm::readLine(String &str) {
          int index = 0;

          while (1) {
                while (Serial.available() == 0) { }

                char rc = Serial.read();
                Serial.print(rc);

                if (rc == '\n') {
                      charbuff[index] = 0;
                      str = charbuff;
                      return true;
                }

                if (rc >= 0x20 || rc == ' ') {
                      charbuff[index++] = rc;
                      if (index > CHARBUFFERSIZE) {
                            return false;
                      }
                }
          }

          return false;
 }
```

在 `while` 循环中，我们首先进入一个循环，该循环在串行输入缓冲区中没有要读取的字符时运行。这使得它成为一个阻塞读取。

由于我们希望能够看到我们输入的内容，在下一节中，我们将回显我们读取的任何字符。之后，我们检查是否收到了换行符。如果收到了，我们在本地缓冲区中添加一个终止的空字节，并将其读入我们提供的 String 实例中，然后返回 true。

可以在此处实现的一个可能的改进是回退功能，用户可以通过使用退格键删除读取缓冲区中的字符。为此，必须添加一个用于退格控制字符（ASCII 0x8）的情况，这将删除缓冲区中的最后一个字符，并且可选地远程终端也会删除其最后一个可见字符。

由于尚未找到换行符，我们继续到下一部分。在这里，我们检查是否收到了被认为是 ASCII 0x20 的有效字符，即空格。如果是，我们继续将新字符添加到缓冲区，并最终检查是否已达到读取缓冲区的末尾。如果没有，我们返回 false 以指示缓冲区已满但尚未找到换行符。

接下来是处理函数 `readIndex()` 和 `readChipConfig()`，分别用于 `index` 和 `chip` 命令：

```cpp
void readIndex() {
          File sdFile = SD.open("chips.idx");
          if (!sdFile) {
                Serial.println("Failed to open IC index file.");
                Serial.println("Please check SD card and try again.");
                while(1);
          }

          Serial.println("Available chips:");
          while (sdFile.available()) {
                Serial.write(sdFile.read());
          }

          sdFile.close();
 }
```

此函数大量使用了 Arduino SD 卡库中的 `SD` 和相关 `File` 类。本质上，我们在 SD 卡上打开芯片索引文件，确保我们得到了有效的文件句柄，然后继续读取并打印文件中的每一行。此文件是一个简单的基于行的文本文件，每行一个芯片名称。

在处理程序代码的末尾，我们从 SD 卡读取完成，可以使用 `sdFile.close()` 关闭文件句柄。同样适用于即将到来的 `readChipHandler()` 实现的稍长版本。

# 用法

例如，当我们使用简单的 HEF4001 IC（4000 CMOS 系列四输入或门）进行测试时，我们必须在 SD 卡上添加一个包含此 IC 测试描述和控制数据的文件。`4001.ic` 测试文件在此处显示，因为它有助于跟随解析它的代码并执行相应的测试。

```cpp
HEF4001B
Quad 2-input NOR gate.
A1-A2: 22-27, Vss: GND, 3A-4B: 28-33, Vdd: 5V
22:0,23:0=24:1
22:0,23:1=24:0
22:1,23:0=24:0
22:1,23:1=24:0
26:0,27:0=25:1
26:0,27:1=25:0
26:1,27:0=25:0
26:1,27:1=25:0
28:0,29:0=30:1
28:0,29:1=30:0
28:1,29:0=30:0
28:1,29:1=30:0
33:0,32:0=31:1
33:0,32:1=31:0
33:1,32:0=31:0
33:1,32:1=31:0
```

前三条行按我们之前看到的方式打印，其余行指定了单独的测试场景。这些测试是行，并使用以下格式：

```cpp
<pin>:<value>,[..,]<pin>:<value>=<pin>:<value>
```

我们将此文件以 `4001.ic` 的形式，以及更新的 `index.idx` 文件（包含新行上的 '4001' 条目）写入 SD 卡。为了支持更多的 IC，我们只需重复此模式，使用它们各自的测试序列，并在索引文件中列出它们。最后是芯片配置的处理程序，它还启动了测试过程：

```cpp
 void readChipConfig() {
          Serial.println("Chip name?");
          Serial.print("> ");
          String chip;
          while (!SerialComm::readLine(chip)) { }
```

我们首先询问用户 IC 的名称，这是之前由 `index` 命令打印出来的：

```cpp
          File sdFile = SD.open(chip + ".ic");      
          if (!sdFile) {
                Serial.println("Failed to open IC file.");
                Serial.println("Please check SD card and try again.");
                return;
          }

          String name = sdFile.readStringUntil('\n');
          String desc = sdFile.readStringUntil('\n');
```

我们尝试打开包含 IC 详细信息的文件，继续读取文件内容，从我们要测试的 IC 的名称和描述开始：

```cpp
          Serial.println("Found IC:");
          Serial.println("Name: " + name);
          Serial.println("Description: " + desc);   

          String pins = sdFile.readStringUntil('\n');
          Serial.println(pins);
```

在显示此 IC 的名称和描述后，我们读取包含如何将 IC 连接到 Mega 板头部的指令的行：

```cpp

          Serial.println("Type 'start' and press <enter> to start test.");
          Serial.print("> ");
          String conf;
          while (!SerialComm::readLine(conf)) { }
          if (conf != "start") {
                Serial.println("Aborting test.");
                return;
          }
```

在这里，我们询问用户是否要开始测试 IC。任何超出 `start` 命令的命令都将终止测试并返回到中央命令循环。

在接收到 `start` 作为命令后，测试开始：

```cpp
          int result_pin, result_val;
          while (sdFile.available()) {
                // Read line, format:
                // <pin>:<value>, [..,]<pin>:<value>=<pin>:<value>
                pins = sdFile.readStringUntil('=');
                result_pin = sdFile.readStringUntil(':').toInt();
                result_val = sdFile.readStringUntil('\n').toInt();
                Serial.print("Result pin: ");
                Serial.print(result_pin);
                Serial.print(", expecting: ");
                Serial.println(result_val);
                Serial.print("\n");

                pinMode(result_pin, INPUT);
```

作为第一步，我们读取 IC 文件中的下一行，它应该包含第一次测试。第一部分包含输入引脚设置，等于号后面的部分包含 IC 的输出引脚和本次测试的预期值。

我们打印出结果引脚连接到的板头编号和预期值。接下来，我们将结果引脚设置为输入引脚，以便测试完成后读取它：

```cpp
                int pin;
                bool val;
                int idx = 0;
                unsigned int pos = 0;
                while ((idx = pins.indexOf(':', pos)) > 0) {
                      int pin = pins.substring(pos, idx).toInt();
                      pos = idx + 1; // Move to character beyond the double colon.

                      bool val = false
                      if ((idx = pins.indexOf(",", pos)) > 0) {
                            val = pins.substring(pos, idx).toInt();
                            pos = idx + 1;
                      }
                      else {
                            val = pins.substring(pos).toInt();
                      }

                      Serial.print("Setting pin ");
                      Serial.print(pin);
                      Serial.print(" to ");
                      Serial.println(val);
                      Serial.print("\n");
                      pinMode(pin, OUTPUT);
                      digitalWrite(pin, val);
                }
```

对于实际测试，我们使用从文件中读取的第一个字符串，解析它以获取输入引脚的值。对于每个引脚，我们首先获取其编号，然后获取其值（`0`或`1`）。

我们将这些引脚编号和值回显到串行输出，然后设置这些引脚的模式为输出模式，并将测试值写入每个引脚，如下所示：

```cpp

                delay(10);

                int res_val = digitalRead(result_pin);
                if (res_val != result_val) {
                      Serial.print("Error: got value ");
                      Serial.print(res_val);
                      Serial.println(" on the output.");
                      Serial.print("\n");
                }
                else {
                      Serial.println("Pass.");
                }
          }     

          sdFile.close();
 }
```

离开内层循环后，所有输入值都将被设置。我们只需稍等片刻，确保 IC 有足够的时间稳定在新输出值上，然后我们尝试读取其输出引脚上的结果值。

IC 验证是对结果引脚的简单读取，之后我们将收到的值与预期值进行比较。然后，将比较结果打印到串行输出。

测试完成后，我们关闭 IC 文件，返回到中央命令循环，等待下一指令。

在将程序烧录到 Mega 板并连接到其串行端口后，我们得到以下结果：

```cpp
    Initializing SD card...
    initialization done.
    Commands: index, chip
    > index  
```

启动后，我们收到消息，SD 卡已找到并成功初始化。我们现在可以读取 SD 卡。我们还看到了可用的命令。

接下来，我们指定`index`命令以获取可测试的 IC 的概览：

```cpp
    Available chips:
    4001
    > chip
    Chip name?
    > 4001
    Found IC:
    Name: HEF4001B
    Description: Quad 2-input NOR gate.
    A1-A2: 22-27, Vss: GND, 3A-4B: 28-33, Vdd: 5V
    Type 'start' and press <enter> to start test.
    > start  
```

由于只有一个 IC 可用于测试，我们指定`chip`命令进入 IC 入口菜单，然后输入 IC 的指定器。

这加载我们放在 SD 卡上的文件，并打印前三行。然后它等待给我们时间连接芯片，根据 Mega 板上的头编号和 IC 的数据表提供的引脚标识进行连接。

在确认我们没有交叉任何线后，我们输入`start`并确认。这开始测试：

```cpp
    Result pin: 24, expecting: 1
    Setting pin 22 to 0
    Setting pin 23 to 0
    Pass.
    Result pin: 24, expecting: 0
    Setting pin 22 to 0
    Setting pin 23 to 1
    Pass.
    Result pin: 24, expecting: 0
    Setting pin 22 to 1
    Setting pin 23 to 0
    [...]
    Result pin: 31, expecting: 0
    Setting pin 33 to 1
    Setting pin 32 to 0
    Pass.
    Result pin: 31, expecting: 0
    Setting pin 33 to 1
    Setting pin 32 to 1
    Pass.
    >  
```

对于芯片中的四个相同的或门，我们逐一通过相同的真值表，测试每个输入组合。这个特定的集成电路顺利通过测试，可以安全地用于项目。

这种测试设备对于测试任何 5V 级别的 IC 都很有用，包括 74 和 4000 逻辑芯片。还可以将设计修改为使用 PWM、ADC 和其他引脚来测试输入和输出不是严格数字的 IC。

# 使用 Sming 进行 ESP8266 开发

对于基于 ESP8266 的开发，其创造者（Espressif）除了提供基于裸机和 RTOS 的 SDK 之外，没有官方的开发工具。包括 Arduino 在内的开源项目为开发者提供了一个更友好的框架来开发应用程序。ESP8266 上 Arduino 的 C++替代方案是 Sming ([`github.com/SmingHub/Sming`](https://github.com/SmingHub/Sming))，这是一个与 Arduino 兼容的框架，类似于我们在上一节中查看的 AVR 的 Nodate。

在下一章（第五章，*示例 - 基于 Wi-Fi 的土壤湿度监测器*）中，我们将深入探讨在 ESP8266 上使用此框架进行开发。

# ARM MCU 开发

为 ARM MCU 平台开发与为 AVR MCU 开发没有显著不同，除了 C++支持得更好，并且有广泛的工具链可供选择，正如我们在本章开头所看到的，仅是流行的 IDE 列表。可用于 Cortex-M 的 RTOS 列表也比 AVR 或 ESP8266 更长。

使用包括 GCC 和 LLVM 在内的免费开源编译器，针对广泛的 ARM MCU 架构（基于 Cortex-M 和类似架构）进行开发，这是为 ARM MCU 开发提供很多自由度的原因之一，同时也能轻松访问完整的 C++ STL（尽管可能需要推迟使用异常）。

在为 Cortex-M MCU 进行裸机开发时，可能需要添加此链接器标志来提供由操作系统通常提供的某些功能的基本存根：

```cpp
-specs=nosys.specs 
```

使 ARM MCU 不太吸引人的一个因素是，标准板和 MCU 的数量远少于 AVR，例如 Arduino 板的形式。尽管 Arduino 基金会在某个时候基于 SAM3X8E Cortex-M3 MCU 制作了 Arduino Due 板，但该板使用与基于 ATmega2560 的 Arduino Mega 板相同的形态和大约相同的引脚布局（只是基于 3.3V I/O 而不是 5V）。

由于这个设计选择，许多 MCU 的功能都没有被分离出来，除非非常擅长使用烙铁和细线，否则无法访问。这些功能包括以太网连接、数十个 GPIO（数字）引脚等。这种所有引脚都没有分离的情况在 Arduino Mega（ATmega2560）板上也存在，但在这种 Cortex-M MCU 上变得更加明显。

因此，作为一个开发和原型板，没有明显的通用选择。有人可能会倾向于使用相对便宜且丰富的原型板，例如 STMicroelectronics 为其 Cortex-M 系列 MCU 提供的那些。

# RTOS 使用

由于平均 MCU 上可用的资源有限，以及在其上运行的应用程序中通常相当直接的流程循环，很难为在这些 MCU 上使用 RTOS 提出合理的论据。只有在必须进行复杂资源和管理任务时，使用 RTOS 以节省开发时间才变得有吸引力。

因此，使用 RTOS 的好处主要在于避免重复造轮子。然而，这必须根据具体情况来决定。对于大多数项目来说，将 RTOS 集成到开发工具链中可能比一个不切实际的想法更可能，后者可能会增加工作量而不是减轻它。

对于那些需要在不同的通信和存储接口之间，以及用户界面之间平衡 CPU 时间和系统资源的项目，例如，使用 RTOS 可能非常有意义。

正如我们在本章中看到的，许多嵌入式开发都使用一个简单的循环（超级循环）以及多个中断来处理实时任务。当在中断函数和超级循环之间共享数据时，确保其安全性的责任在于开发者。

在这里，RTOS 将提供调度器，甚至能够运行彼此隔离的任务（进程）（特别是在具有内存管理单元（MMU）的 MCU 上）。在多核 MCU 上，RTOS 可以轻松地允许用户有效地使用所有核心，而无需进行自己的调度。

就像所有事物一样，使用 RTOS 不仅仅是一系列优势的集合。即使忽略添加 RTOS 到项目中可能导致的只读存储器（ROM）和随机存取存储器（RAM）空间需求增加，它也会从根本上改变一些系统交互，并且可能（矛盾的是）导致中断延迟增加。

这就是为什么，尽管其名称中包含“实时”，但要获得比使用简单的执行循环和少量中断更实时的情况是非常困难的。因此，RTOS 的好处绝对不是可以一概而论的，尤其是在已经可以提供支持裸机编程的库或框架（如本章中提到的 Arduino 兼容框架）以简化原型设计和生产开发的情况下。

# 总结

在本章中，我们探讨了如何为新项目选择合适的微控制器（MCU），以及如何在项目中添加外设并处理以太网和串行接口的要求。我们考虑了不同 MCU 中内存的布局以及如何处理堆栈和堆。最后，我们查看了一个 AVR 项目示例，如何为其他 MCU 架构进行开发，以及是否使用实时操作系统（RTOS）。

在这一点上，读者应该能够根据一系列项目需求，论证为什么选择一个 MCU 而不是另一个。他们应该能够使用 UART 和其他外设实现简单的项目，并且理解适当的内存管理以及中断的使用。

在下一章中，我们将详细探讨如何为 ESP8266 开发，形式为一个嵌入式项目，该项目将跟踪土壤湿度水平，并在需要时控制浇水泵。
