- en: What is WebAssembly?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 WebAssembly？
- en: '**WebAssembly** (**Wasm**) represents an important stepping stone for the web
    platform. Enabling a developer to run compiled code on the web without a plugin
    or browser lock-in presents many new opportunities. Some confusion exists about
    what WebAssembly is, as does some skepticism about its staying power.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebAssembly**（**Wasm**）是 Web 平台的一个重要里程碑。它使开发者能够在无需插件或浏览器锁定的情况下在网络上运行编译后的代码，这带来了许多新的机会。关于
    WebAssembly 是什么，存在一些混淆，对其持久性的怀疑也存在。'
- en: In this chapter, we will discuss how WebAssembly came to be, what WebAssembly
    is with regard to the official definition, and the technologies it encompasses. The
    potential use cases, supported languages, and limitations will be covered, as
    well as where to find additional information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 WebAssembly 如何产生，官方定义下的 WebAssembly 是什么，以及它所包含的技术。还将涵盖潜在用途案例、支持的语言和限制，以及如何找到更多信息。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是理解以下内容：
- en: The technologies that led the way for WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 WebAssembly 开辟道路的技术
- en: What WebAssembly is and some of its potential use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 是什么以及它的一些潜在用途案例
- en: Which programming languages can be used with WebAssembly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些编程语言可以与 WebAssembly 一起使用
- en: The current limitations of WebAssembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 的当前限制
- en: How WebAssembly relates to Emscripten and asm.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 如何与 Emscripten 和 asm.js 相关
- en: The road to WebAssembly
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 的道路
- en: Web development has had an interesting history, to say the least. Several (failed)
    attempts have been made to expand the platform to support different languages. Clunky
    solutions such as plugins failed to stand the test of time, and limiting a user
    to a single browser is a recipe for disaster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以说，Web 开发有着有趣的历史。已经尝试过几次（失败的）扩展平台以支持不同的语言。像插件这样的笨拙解决方案未能经受时间的考验，将用户限制在单个浏览器中是灾难的预兆。
- en: 'WebAssembly was developed as an elegant solution to a problem that has existed
    since browsers were first able to execute code: *If you want to develop for the
    web, you have to use JavaScript*. Fortunately, using JavaScript doesn''t have
    the same negative connotations it had back in the early 2000s, but it continues
    to have certain limitations as a programming language. In this section, we''re
    going to discuss the technologies that led to WebAssembly to get a better grasp
    of why this new technology is needed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 是作为一个优雅的解决方案来应对自浏览器首次能够执行代码以来就存在的问题：*如果你想要为 Web 开发，你必须使用 JavaScript*。幸运的是，使用
    JavaScript 并没有像 2000 年初那样有负面含义，但它作为编程语言仍然存在某些限制。在本节中，我们将讨论导致 WebAssembly 的技术，以便更好地理解为什么需要这项新技术。
- en: The evolution of JavaScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的演变
- en: JavaScript was created by Brendan Eich in just 10 days back in 1995\. Originally
    seen as a *toy* language by programmers, it was used primarily to make buttons
    flash or banners appear on a web page. The last decade has seen JavaScript evolve
    from a toy to a platform with profound capabilities and a massive following.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是由布兰登·艾奇在 1995 年仅用 10 天创造的。最初被程序员视为一种 *玩具* 语言，主要用于在网页上使按钮闪烁或显示横幅。在过去的十年里，JavaScript
    从一种玩具语言演变成为一个具有深远能力和庞大追随者的平台。
- en: 'In 2008 heavy competition in the browser market resulted in the addition of
    **just-in-time** (**JIT**) compilers, which increased the execution speed of JavaScript
    by a factor of 10\. Node.js debuted in 2009 and represented a paradigm shift in
    web development. Ryan Dahl combined Google''s V8 JavaScript engine, an event loop,
    and a low-level I/O API to build a platform that allowed for the use of JavaScript
    across the server and client side. Node.js led to `npm`, a package manager that
    allowed for the development of libraries to be used within the Node.js ecosystem.
    As of the time of writing, there are over 600,000 packages available with hundreds
    being added every day:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2008 年浏览器市场的激烈竞争导致了 **即时**（**JIT**）编译器的添加，这使得 JavaScript 的执行速度提高了 10 倍。Node.js
    在 2009 年推出，代表了 Web 开发的一个范式转变。瑞安·达尔结合了谷歌的 V8 JavaScript 引擎、事件循环和低级 I/O API，构建了一个允许在服务器和客户端使用
    JavaScript 的平台。Node.js 导致了 `npm` 的出现，这是一个包管理器，允许在 Node.js 生态系统中开发库。截至写作时，有超过 600,000
    个包可用，每天都有数百个新包被添加：
- en: '![](img/d473abb9-dda2-4db0-acfb-0a63607c8190.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d473abb9-dda2-4db0-acfb-0a63607c8190.png)'
- en: Package count growth on npm since 2012, taken from Modulecounts
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Modulecounts 获取的 npm 包数量增长情况，自 2012 年以来
- en: It's not just the Node.js ecosystem that is growing; JavaScript itself is being
    actively developed. The ECMA **Technical Committee 39** (**TC39**), which dictates
    the standards for JavaScript and oversees the addition of new language features,
    releases *yearly* updates to JavaScript with a community-driven proposal process.
    Between its wealth of libraries and tooling, constant improvements to the language,
    and possessing one of the largest communities of programmers, JavaScript has become
    a force to be reckoned with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅 Node.js 生态系统在增长；JavaScript 本身也在积极开发中。负责制定 JavaScript 标准并监督新语言特性添加的 ECMA **技术委员会
    39**（**TC39**），通过社区驱动的提案流程，每年都会发布 JavaScript 的更新。凭借其丰富的库和工具、语言的持续改进以及庞大的程序员社区，JavaScript
    已经成为不可忽视的力量。
- en: 'But the language does have some shortcomings:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种语言确实存在一些不足：
- en: Up until recently, JavaScript only included 64-bit floating point numbers. This
    can cause issues with very large or very small numbers. `BigInt`, a new numeric
    primitive that can alleviate some of these issues, is in the the process of being
    added to the ECMAScript specification, but it may take some time until it's fully
    supported in browsers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到最近，JavaScript 只包含 64 位浮点数。这可能导致处理非常大或非常小的数字时出现问题。`BigInt`，一种新的数值原语，可以缓解一些这些问题，目前正在被添加到
    ECMAScript 规范中，但可能需要一些时间才能在浏览器中得到全面支持。
- en: JavaScript is weakly typed, which adds to its flexibility, but can cause confusion
    and bugs. It essentially gives you enough rope to hang yourself.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 是弱类型语言，这增加了其灵活性，但可能导致混淆和错误。它实际上给你提供了足够的绳子来自挂。
- en: JavaScript isn't as performant as compiled languages despite the best efforts
    of the browser vendors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管浏览器供应商做出了最大努力，JavaScript 的性能仍然不如编译型语言。
- en: If a developer wants to create a web application, they need to learn JavaScript—whether
    they like it or not.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发者想要创建一个网络应用程序，他们需要学习 JavaScript——无论他们是否喜欢。
- en: To avoid having to write more than a few lines of JavaScript, some developers
    built **transpilers** to convert other languages to JavaScript. Transpilers (or
    source-to-source compilers) are types of compilers that convert source code in
    one programming language to equivalent source code in another programming language.
    TypeScript, which is a popular tool for frontend JavaScript development, transpiles
    TypeScript to valid JavaScript targeted for browsers or Node.js. Pick any programming
    language and there's a good chance that someone created a JavaScript transpiler
    for it. For example, if you prefer to write Python, you have about 15 different
    tools that you can use to generate JavaScript. In the end, though, it's still
    JavaScript, so you're still subject to the idiosyncrasies of the language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写超过几行 JavaScript，一些开发者构建了 **转换器**（transpilers）来将其他语言转换为 JavaScript。转换器（或源到源编译器）是一种编译器，它将一种编程语言的源代码转换为另一种编程语言的等效源代码。TypeScript，这是一种流行的前端
    JavaScript 开发工具，可以将 TypeScript 转换为目标浏览器或 Node.js 的有效 JavaScript。选择任何编程语言，都有很大可能性有人为它创建了
    JavaScript 转换器。例如，如果你喜欢编写 Python，你大约有 15 种不同的工具可以使用来生成 JavaScript。然而，最终，它仍然是 JavaScript，所以你仍然会受到语言特性的影响。
- en: As the web evolved into a valid platform for building and distributing applications,
    more and more complex and resource-intensive applications were created. In order
    to meet the demands of these applications, browser vendors began working on new
    technologies to integrate into their software without disrupting the normal course
    of web development. Google and Mozilla, creators of Chrome and Firefox, respectively,
    took two different paths to achieve this goal, culminating in the creation of
    WebAssembly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络逐渐成为构建和分发应用程序的有效平台，越来越多的复杂和资源密集型应用程序被创建。为了满足这些应用程序的需求，浏览器供应商开始开发新技术，以将其集成到他们的软件中，而不会干扰网络开发的正常进程。Chrome
    和 Firefox 的创造者 Google 和 Mozilla 分别采取了不同的路径来实现这一目标，最终导致了 WebAssembly 的诞生。
- en: Google and Native Client
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google 和 Native Client
- en: Google developed **Native Client** (**NaCl**) with the intent to safely run
    native code within a web browser. The executable code would run in a **sandbox**
    and offered the performance advantages of native code execution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Google 开发了 **原生客户端**（**NaCl**），旨在在网页浏览器中安全地运行原生代码。可执行代码将在 **沙盒**中运行，并提供了原生代码执行的性能优势。
- en: In the context of software development, a sandbox is an environment that prevents
    executable code from interacting with other parts of your system. It is intended
    to prevent the spread of malicious code and place restrictions on what software
    can do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发背景下，沙盒是一个防止可执行代码与系统其他部分交互的环境。它的目的是防止恶意代码的传播并对软件的功能施加限制。
- en: 'NaCl was tied to a specific architecture, while **Portable Native Client**
    (**PNaCl**) was an architecture-independent version of NaCl developed to run on
    any platform. The technology consisted of two elements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl 与特定架构绑定，而 **可移植本地客户端** (**PNaCl**) 是一个架构无关的 NaCl 版本，旨在在任何平台上运行。该技术由两个元素组成：
- en: Toolchains which could transform C/C++ code to NaCl modules
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将 C/C++ 代码转换为 NaCl 模块的工具链
- en: 'Runtime components which were components embedded in the browser that allowed
    execution of NaCl modules:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时组件，这些是嵌入浏览器中允许执行 NaCl 模块的组件：
- en: '![](img/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png)'
- en: The Native Client toolchains and their outputs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本地客户端工具链及其输出
- en: 'NaCl''s architecture-specific executable (`nexe`) was limited to applications
    and extensions that were installed from Google''s Chrome Web Store, but PNaCl
    executables (`pexe`) can be freely distributed on the web and embedded in web
    applications. Portability was made possible with Pepper, an open source API for
    creating NaCl modules, and its corresponding plugin API (PPAPI). Pepper enabled
    communication between NaCl modules and the hosting browser, and allowed for access
    to system-level functions in a safe and portable way. Applications could be easily
    distributed by including a manifest file and a compiled module (`pexe`) with the
    corresponding HTML, CSS, and JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl 的架构特定可执行文件 (`nexe`) 仅限于从 Google 的 Chrome Web Store 安装的程序和扩展，但 PNaCl 可执行文件
    (`pexe`) 可以在网络上自由分发并嵌入到 Web 应用程序中。通过 Pepper，一个用于创建 NaCl 模块的开源 API 以及其相应的插件 API
    (PPAPI)，实现了可移植性。Pepper 允许 NaCl 模块与宿主浏览器之间的通信，并以安全且可移植的方式访问系统级功能。应用程序可以通过包含清单文件和编译模块
    (`pexe`) 以及相应的 HTML、CSS 和 JavaScript 来轻松分发：
- en: '![](img/0a230248-b946-4f66-b811-ff2530fc48d1.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a230248-b946-4f66-b811-ff2530fc48d1.png)'
- en: Pepper's role in a Native Client application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Pepper 在本地客户端应用程序中的作用
- en: NaCl offered promising opportunities to overcome the performance limitations
    of the web, but it had some drawbacks. Although Chrome had built-in support for
    PNaCl executables and Pepper, other major browser did not. Detractors of the technology
    took issue with the black-box nature of the applications as well as the potential
    security risks and complexity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl 为克服网络性能限制提供了有希望的机会，但它也有一些缺点。尽管 Chrome 内置了对 PNaCl 可执行文件和 Pepper 的支持，但其他主要浏览器并没有。该技术的批评者对应用程序的黑盒性质以及潜在的安全风险和复杂性提出了问题。
- en: Mozilla focused its efforts on improving the performance of JavaScript with
    `asm.js`. They wouldn't add support for Pepper to Firefox due to the incompleteness
    of its API specification and limited documentation. In the end, NaCl was deprecated
    in May, 2017, in favor of WebAssembly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 将其努力集中在通过 `asm.js` 提高 JavaScript 的性能上。由于 Pepper 的 API 规范不完整和有限的文档，他们不会在
    Firefox 中添加对 Pepper 的支持。最终，NaCl 于 2017 年 5 月被弃用，转而使用 WebAssembly。
- en: Mozilla and asm.js
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mozilla 和 asm.js
- en: Mozilla debuted `asm.js` in 2013 and provided a way for developers to translate
    their C and C++ source code to JavaScript. The official specification for `asm.js`
    defines it as a strict subset of JavaScript that can be used as a low-level, efficient
    target language for compilers. It's still valid JavaScript, but the language features
    are limited to those that are amenable to **ahead-of-time** (**AOT**) optimization. AOT is
    a technique that the browser's JavaScript engine uses to execute code more efficiently
    by compiling it down to native machine code. `asm.js` achieves these performance
    gains by having 100% type consistency and manual memory management.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 于 2013 年推出了 `asm.js`，并为开发者提供了一种将他们的 C 和 C++ 源代码转换为 JavaScript 的方法。`asm.js`
    的官方规范将其定义为 JavaScript 的一个严格子集，可以作为编译器的低级、高效目标语言使用。它仍然是有效的 JavaScript，但语言特性仅限于那些适合
    **编译时优化** (**AOT**) 的特性。AOT 是浏览器 JavaScript 引擎使用的一种技术，通过将代码编译成原生机器代码来提高代码的执行效率。`asm.js`
    通过实现 100% 的类型一致性和手动内存管理来实现这些性能提升。
- en: Using a tool such as Emscripten, C/C++ code can be transpiled down to `asm.js`
    and easily distributed using the same means as normal JavaScript. Accessing the
    functions in an `asm.js` module requires **linking**, which involves calling its
    function to obtain an object with the module's exports.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Emscripten 这样的工具，可以将 C/C++ 代码转换为 `asm.js` 并通过与正常 JavaScript 相同的方式轻松分发。访问
    `asm.js` 模块中的函数需要 **链接**，这涉及到调用其函数以获取包含模块导出的对象。
- en: '`asm.js` is incredibly flexible, however, certain interactions with the module
    can cause a loss of performance. For example, if an `asm.js` module is given access
    to a custom JavaScript function that fails dynamic or static validation, the code
    can''t take advantage of AOT and falls back to the interpreter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm.js` 非常灵活，然而，与模块的某些交互可能会导致性能损失。例如，如果 `asm.js` 模块被赋予了访问一个失败动态或静态验证的自定义 JavaScript
    函数的权限，代码就无法利用 AOT 并回退到解释器：'
- en: '![](img/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png)'
- en: The asm.js AOT compilation workflow
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: asm.js AOT 编译工作流程
- en: '`asm.js` isn''t just a stepping stone. It forms the basis for WebAssembly''s
    **Minimum Viable Product** (**MVP**). The official WebAssembly site explicitly
    mentions `asm.js` in the section entitled *WebAssembly High-Level Goals*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm.js` 不仅仅是一个垫脚石。它是 WebAssembly 的 **最小可行产品** (**MVP**) 的基础。官方 WebAssembly
    网站在标题为 *WebAssembly 高级目标* 的部分中明确提到了 `asm.js`。'
- en: So why create WebAssembly when you could use `asm.js`? Aside from the potential
    performance loss, an `asm.js` module is a text file that must be transferred over
    the network before any compilation can take place. A WebAssembly module is in
    a binary format, which makes it much more efficient to transfer due to its smaller
    size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么要在可以使用 `asm.js` 的情况下创建 WebAssembly 呢？除了可能出现的性能损失外，一个 `asm.js` 模块是一个必须在任何编译发生之前通过网络传输的文本文件。而
    WebAssembly 模块是二进制格式，由于其尺寸更小，这使得传输效率更高。
- en: WebAssembly modules use a promise-based approach to instantiation, which takes
    advantage of modern JavaScript and eliminates the need for any *is this loaded*
    *yet?* code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模块使用基于承诺的实例化方法，这利用了现代 JavaScript 并消除了任何 *是否已加载* *了？* 代码的需求。
- en: WebAssembly is born
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 诞生
- en: The **World Wide Web Consortium** (**W3C**), an international community built
    to develop web standards, formed the WebAssembly Working Group in April, 2015,
    to standardize WebAssembly and oversee the specification and proposal process. Since
    then, the *Core Specification* and corresponding *JavaScript API* and *Web API*
    have been released. The initial implementation of WebAssembly support in browsers
    was based on the feature set of `asm.js`. WebAssembly's binary format and corresponding
    `.wasm` file combined facets of `asm.js` output with PNaCl's concept of a distributed
    executable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网联盟** (**W3C**)，一个旨在开发 Web 标准的国际社区，于 2015 年 4 月成立了 WebAssembly 工作组，以标准化
    WebAssembly 并监督规范和提案流程。从那时起，已经发布了 *核心规范* 以及相应的 *JavaScript API* 和 *Web API*。浏览器对
    WebAssembly 的初始支持基于 `asm.js` 的功能集。WebAssembly 的二进制格式和相应的 `.wasm` 文件结合了 `asm.js`
    输出与 PNaCl 的分布式可执行概念。'
- en: 'So how will WebAssembly succeed where NaCl failed? According to Dr. Axel Rauschmayer,
    there are three reasons detailed at [http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time](http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 WebAssembly 将如何成功而 NaCl 失败呢？根据 Dr. Axel Rauschmayer 的说法，有三个原因，详细内容请见 [http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time](http://2ality.com/2015/06/web-assembly.html#what-is-different-this.time)：
- en: '"First, this is a collaborative effort, no single company goes it alone. At
    the moment, the following projects are involved: Firefox, Chromium, Edge and WebKit.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '"首先，这是一个协作努力，没有哪家公司是独自行动的。目前，以下项目参与了其中：Firefox、Chromium、Edge 和 WebKit。'
- en: Second, the interoperability with the web platform and JavaScript is excellent.
    Using WebAssembly code from JavaScript will be as simple as importing a module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，与 Web 平台和 JavaScript 的互操作性非常好。从 JavaScript 中使用 WebAssembly 代码将像导入一个模块一样简单。
- en: Third, this is not about replacing JavaScript engines, it is more about adding
    a new feature to them. That greatly reduces the amount of work to implement WebAssembly
    and should help with getting the support of the web development community."
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，这并不是要取代 JavaScript 引擎，更多的是要为它们添加一个新特性。这大大减少了实现 WebAssembly 的工作量，并有助于获得 Web
    开发社区的认可。
- en: - Dr. Axel Rauschmayer
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '- Dr. Axel Rauschmayer'
- en: What exactly is WebAssembly and where can I use it?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么 WebAssembly 究竟是什么，我可以在哪里使用它？
- en: WebAssembly has a succinct and descriptive definition on the official site,
    but it's only a piece of the puzzle. There are several other components that fall
    under the umbrella of WebAssembly. Understanding the role each component plays
    will give you a better understanding of the technology as a whole. In this section,
    we will provide a detailed breakdown of WebAssembly's definition and describe
    potential use cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 在官方网站上有简洁且描述性的定义，但它只是拼图的一部分。还有其他几个组件属于 WebAssembly 的范畴。了解每个组件所扮演的角色将使你对这项技术有一个更全面的了解。在本节中，我们将详细分解
    WebAssembly 的定义并描述潜在的应用场景。
- en: Official definition
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方定义
- en: 'The official WebAssembly website ([https://webassembly.org](https://webassembly.org))
    offers this definition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 WebAssembly 网站 ([https://webassembly.org](https://webassembly.org)) 提供了以下定义：
- en: Wasm is a binary instruction format for a stack-based virtual machine. Wasm
    is designed as a portable target for compilation of high-level languages like
    C/C++/Rust, enabling deployment on the web for client and server applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm 是一种基于栈的虚拟机的二进制指令格式。Wasm 被设计为编译高级语言（如 C/C++/Rust）的可移植目标，使得客户端和服务器应用程序能够在网页上部署。
- en: Let's break that definition down into parts to add some clarification.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个定义分解成几个部分以增加一些解释。
- en: Binary instruction format
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制指令格式
- en: WebAssembly actually encompasses several elements—a binary format and text format,
    which are documented in the *Core Specification*, the corresponding APIs (JavaScript
    and web), and a compilation target. The binary and text format both map to a common
    structure in the form of an **abstract syntax**. To better understand abstract
    syntax, it can be explained in the context of an **abstract syntax tree** (**AST**). An
    AST is a tree representation of the structure of source code for a programming
    language. Tools such as ESLint use JavaScript's AST to find linting errors. The
    following example contains a function and the corresponding AST for JavaScript
    (taken from [https://astexplorer.net](https://astexplorer.net)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 实际上包含几个元素——一个二进制格式和一个文本格式，这些都在 *核心规范* 中进行了文档化，相应的 API（JavaScript
    和网页），以及一个编译目标。二进制和文本格式都映射到一个以 **抽象语法** 形式的公共结构。为了更好地理解抽象语法，它可以在 **抽象语法树**（**AST**）的上下文中进行解释。AST
    是编程语言源代码结构的树形表示。例如，ESLint 这样的工具使用 JavaScript 的 AST 来查找代码风格错误。以下示例包含一个函数及其对应的 JavaScript（来自
    [https://astexplorer.net](https://astexplorer.net)）AST。
- en: 'A simple JavaScript function follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的 JavaScript 函数：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding AST is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的 AST 如下所示：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An AST may be verbose, but it does an excellent job at describing the components
    of a program. Representing source code in an AST makes verification and compilation
    simple and efficient. WebAssembly code in text format is serialized into an AST
    and compiled to the binary format (as a `.wasm` file), which is fetched, loaded,
    and utilized by a web page. When the module is loaded, the browser's JavaScript
    engine utilizes a **decoding stack** to decode the `.wasm` file into an AST, perform
    type checking, and interpret it to execute functions. WebAssembly started as a
    binary instruction format for an AST. Due to the performance implications of verifying
    Wasm expressions that return `void`, the binary instruction format was updated
    to target a **stack machine**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: AST 可能比较冗长，但它出色地描述了程序组件。以 AST 的形式表示源代码使得验证和编译变得简单高效。WebAssembly 的文本格式代码被序列化为
    AST 并编译成二进制格式（作为 `.wasm` 文件），然后由网页获取、加载和使用。当模块加载时，浏览器的 JavaScript 引擎使用一个 **解码栈**
    将 `.wasm` 文件解码为 AST，执行类型检查，并对其进行解释以执行函数。WebAssembly 最初是一种用于 AST 的二进制指令格式。由于验证返回
    `void` 的 Wasm 表达式的性能影响，二进制指令格式被更新以针对 **栈机器**。
- en: 'A stack machine consists of two elements: a stack and instructions. A stack
    is a data structure with two operations: *push* and *pop*. Items are pushed onto
    the stack and subsequently popped from the stack in **last in, first out** (**LIFO**)
    order. A stack also includes a **pointer**, which points to the item at the top
    of the stack. Instructions represent actions to perform on the items in the stack.
    For example, an `ADD` instruction might pop the top two items from the stack (the
    values `100` and `10`), and push a single item with the sum back onto the stack
    (the value `110`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 栈机器由两个元素组成：栈和指令。栈是一种具有两种操作的数据结构：*push* 和 *pop*。项目被推入栈中，随后以 **后进先出**（**LIFO**）的顺序从栈中弹出。栈还包括一个
    **指针**，它指向栈顶的项目。指令代表对栈中的项目执行的操作。例如，一个 `ADD` 指令可能会从栈中弹出顶部两个项目（值 `100` 和 `10`），并将一个包含总和的单个项目推回栈中（值
    `110`）：
- en: '![](img/1e2d75b9-2021-4486-8049-726f6134410d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e2d75b9-2021-4486-8049-726f6134410d.png)'
- en: A simple stack machine
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的栈机器
- en: WebAssembly's stack machine operates in the same way. A program counter (pointer)
    maintains the execution position within the code and a virtual control stack keeps
    track of `blocks` and `if` constructs as they are entered (pushed) and exited
    (popped). The instructions are executed with no reference to an AST. Thus, the
    **binary instruction format** portion of the definition refers to a binary representation
    of instructions that are in a format readable by the decoding stack in the browser.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的栈机器以相同的方式运行。一个程序计数器（指针）维护代码中的执行位置，一个虚拟控制栈跟踪 `blocks` 和 `if` 构造在进入（推入）和退出（弹出）时的状态。指令在没有引用抽象语法树（AST）的情况下执行。因此，定义中的
    **二进制指令格式** 部分指的是指令的二元表示，这些指令的格式可以被浏览器中的解码栈读取。
- en: Portable target for compilation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植的编译目标
- en: WebAssembly was designed from the beginning with portability in mind. Portability
    in this context means that WebAssembly's binary format can be executed efficiently
    on a variety of operating systems and instruction set architectures, on and off
    the web. The specification for WebAssembly defines portability in the context
    of an execution environment. WebAssembly was designed to run efficiently in environments
    that meet certain characteristics, most of which are related to memory. WebAssembly's
    portability can also be attributed to the absence of a specific API around the
    core technologies. Instead, it defines an `import` mechanism where the set of
    available imports is defined by the host environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 从一开始就被设计成具有可移植性。在这个上下文中，可移植性意味着 WebAssembly 的二进制格式可以在各种操作系统和指令集架构上高效执行，无论是在网络上还是在网络之外。WebAssembly
    的规范定义了在执行环境中的可移植性。WebAssembly 被设计成在满足某些特定特性的环境中高效运行，其中大部分与内存相关。WebAssembly 的可移植性也可以归因于核心技术的周围没有特定的
    API。相反，它定义了一个 `import` 机制，其中可用的导入集由宿主环境定义。
- en: In a nutshell, this means that WebAssembly isn't tied to a specific environment,
    such as the web or desktop. The WebAssembly Working Group has defined a *Web API*,
    but that's separate from the *Core Specification*. The *Web API* caters to WebAssembly,
    not the other way around.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着 WebAssembly 并不绑定到特定的环境，例如网络或桌面。WebAssembly 工作组定义了一个 *Web API*，但这与
    *核心规范* 是分开的。*Web API* 旨在满足 WebAssembly，而不是相反。
- en: The **compilation** aspect of the definition indicates that WebAssembly will
    be simple to compile down to its binary format from source code written in high-level
    languages. The MVP focuses on two languages, C and C++, but Rust can also be used
    given its similarities to C++. Compilation will be achieved through the use of
    a Clang/LLVM backend, although we'll be using Emscripten in this book to generate
    our Wasm modules. The plan is to eventually add support for other languages and
    compilers (such as GCC), but the MVP is focused on LLVM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的 **编译** 方面表明，WebAssembly 将很容易从用高级语言编写的源代码编译为其二进制格式。MVP 专注于两种语言，C 和 C++，但鉴于其与
    C++ 的相似性，也可以使用 Rust。编译将通过使用 Clang/LLVM 后端来实现，尽管在这本书中我们将使用 Emscripten 生成我们的 Wasm
    模块。计划最终添加对其他语言和编译器（如 GCC）的支持，但 MVP 专注于 LLVM。
- en: The core specification
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心规范
- en: 'The official definition gives some high-level insight into the overall technology,
    but for the sake of completeness, it''s worth digging a little deeper. WebAssembly''s
    *Core Specification* is the official document to reference if you want to understand
    WebAssembly at a very granular level. If you''re interested in learning about
    the characteristics of the runtime structure with regard to the execution environment,
    check out section 4: *Execution*. We won''t cover that here, but understanding
    where the *Core Specification* fits in will help in establishing a complete definition
    of WebAssembly.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 官方定义对整体技术提供了一些高级见解，但为了完整性，值得深入挖掘。WebAssembly的**核心规范**是如果您想非常细致地了解WebAssembly，则应参考的官方文件。如果您对了解执行环境的运行时结构特性感兴趣，请查看第4节：*执行*。我们在这里不会涵盖这一点，但了解**核心规范**的位置将有助于建立WebAssembly的完整定义。
- en: Language concepts
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言概念
- en: 'The *Core Specification* states WebAssembly encodes a low-level, assembly-like
    programming language. The specification defines the structure, execution, and
    validation of this language as well as the details of the binary and text formats.
    The language itself is structured around the following concepts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**核心规范**指出WebAssembly编码了一种低级、类似汇编的编程语言。该规范定义了这种语言的结构、执行和验证，以及二进制和文本格式的细节。该语言本身围绕以下概念构建：'
- en: '**Values**, or rather value types that WebAssembly provides'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**，或者说WebAssembly提供的值类型'
- en: '**Instructions** that are executed within the stack machine'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈机器中执行的**指令**
- en: '**Traps** produced under error conditions and abort execution'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在错误条件下产生的**陷阱**和终止执行
- en: '**Functions **into which code is organized, each of which takes a sequence
    of values as parameters and returns a sequence of values as a result'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**，代码组织到其中，每个函数都接受一系列值作为参数，并返回一系列值作为结果'
- en: '**Tables**, which are arrays of values of a particular element type (such as
    function references) that are selectable by the executing program'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表**，这是特定元素类型（如函数引用）的值数组，可以被执行程序选择'
- en: '**Linear Memory**, which is an array of raw bytes that can be used to store
    and load values'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性内存**，这是一个可以用来存储和加载值的原始字节数组'
- en: '**Modules**, WebAssembly binary (`.wasm` file) that contains function, tables,
    and linear memories'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**，包含函数、表和线性内存的WebAssembly二进制文件（`.wasm`文件）'
- en: '**Embedder**, the mechanism by which WebAssembly can be executed in a host
    environment, such as a web browser'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入器**，WebAssembly可以在宿主环境（如网页浏览器）中执行的方式'
- en: 'Functions, tables, memory, and modules have direct correlations with the *JavaScript
    API* and are important to be aware of. These concepts describe the underlying
    structure of the language itself and how to write or encode WebAssembly. With
    regard to usage, understanding the corresponding semantic phases of WebAssembly
    provides a complete definition of the technology:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、表、内存和模块与**JavaScript API**有直接关联，并且需要了解。这些概念描述了语言本身的底层结构以及如何编写或编码WebAssembly。关于使用方面，理解WebAssembly的相应语义阶段提供了该技术的完整定义：
- en: '![](img/52382cbb-fa93-4206-adde-c38848bf1429.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52382cbb-fa93-4206-adde-c38848bf1429.png)'
- en: Language concepts and their relationship
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 语言概念及其关系
- en: Semantic phases
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义阶段
- en: 'The *Core Specification* describes the different phases an encoded module (`.wasm`
    file) undergoes when it is being utilized in a host environment (such as a web
    browser). This aspect of the specification represents how the output is handled
    and executed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**核心规范**描述了编码的模块（`.wasm`文件）在宿主环境（如网页浏览器）中利用时经历的各个阶段。该规范的这一方面代表了如何处理和执行输出：'
- en: '**Decoding**: The binary format is converted into a module'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解码**：将二进制格式转换为模块'
- en: '**Validation**: The decoded module undergoes validation checks (such as type
    checking) to ensure the module is well formed and safe'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：解码的模块经过验证检查（如类型检查），以确保模块结构良好且安全'
- en: '**Execution, Part 1: Instantiation**: A module instance, which is the dynamic
    representation of the module, is instantiated by initializing the **Globals**,
    **Memories**, and **Tables**, and invokes the module''s `start()` function'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行，第一部分：实例化**：通过初始化**全局变量**、**内存**和**表**来实例化模块实例，这是模块的动态表示，并调用模块的`start()`函数'
- en: '**Execution, Part 2: Invocation**: Exported functions are called from the module
    instance:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行，第二部分：调用**：从模块实例中调用导出的函数：'
- en: 'The following diagram provides a visual representation of the semantic phases:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了语义阶段的视觉表示：
- en: '![](img/51755ca6-f4c7-43b3-93d3-81575523ae30.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51755ca6-f4c7-43b3-93d3-81575523ae30.png)'
- en: Semantic phases of module use
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模块使用的语义阶段
- en: The JavaScript and Web APIs
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和Web API
- en: The WebAssembly Working Group also released API specifications for interacting
    with JavaScript and the web, which qualifies them for inclusion in the WebAssembly
    technology space. The *JavaScript API* is scoped to the JavaScript language itself,
    without being specifically tied to an environment (for example, web browsers or
    Node.js). It defines classes, methods, and objects for interacting with WebAssembly
    and managing the compilation and instantiation processes. The *Web API* is an
    extension of the *JavaScript API* that defines functionality specific to web browsers.
    The *Web API* specification currently only defines two methods, `compileStreaming`
    and `instantiateStreaming`, which are convenience methods that simplify the use
    of Wasm modules in the browser. These will be covered in greater detail in [Chapter
    2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly - Wat,
    Wasm, and the JavaScript API*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly工作组还发布了与JavaScript和网页交互的API规范，这使得它们有资格被纳入WebAssembly技术空间。*JavaScript
    API*的范围限定在JavaScript语言本身，而不特定于某个环境（例如，网络浏览器或Node.js）。它定义了与WebAssembly交互以及管理编译和实例化过程的类、方法和对象。*Web
    API*是*JavaScript API*的扩展，它定义了特定于网络浏览器的功能。*Web API*规范目前仅定义了两个方法，`compileStreaming`和`instantiateStreaming`，这些是简化浏览器中Wasm模块使用的便利方法。这些内容将在[第2章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml)，*WebAssembly元素
    - Wat, Wasm和JavaScript API*中更详细地介绍。
- en: So will it replace JavaScript?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那它是否会取代JavaScript？
- en: WebAssembly's ultimate goal is not to replace JavaScript, but rather to complement
    it. JavaScript's rich ecosystem and flexibility still makes it the ideal language
    for the web. WebAssembly's JavaScript API makes interoperability between the two
    technologies relatively simple. So will you be able to build a web application
    using just WebAssembly? One of the explicit goals of WebAssembly is portability,
    and replicating all of JavaScript's functionality could inhibit that goal. However,
    the official site includes a goal to execute and integrate well with the existing
    web platform, so only time will tell. It may not be practical to write the entire
    code base in a language that compiles down to WebAssembly, but moving some of
    the application logic to Wasm modules could be beneficial in terms of performance
    and load times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的最终目标不是取代JavaScript，而是与之互补。JavaScript丰富的生态系统和灵活性仍然使其成为网络的最佳语言。WebAssembly的JavaScript
    API使得两种技术之间的互操作性相对简单。那么，你能否仅使用WebAssembly构建一个Web应用？WebAssembly的一个明确目标是可移植性，复制JavaScript的所有功能可能会阻碍这一目标。然而，官方网站包括一个目标，即与现有Web平台良好执行和集成，所以只有时间才能揭晓。可能不实用将整个代码库用编译成WebAssembly的语言编写，但将一些应用程序逻辑移动到Wasm模块中可能在性能和加载时间方面有益。
- en: Where can I use it?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我在哪里可以使用它？
- en: 'WebAssembly''s official site has an extensive list of potential use cases.
    I''m not going to cover them all here, but there are several that represent significant
    enhancements to the capabilities of the web platform:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的官方网站列出了大量的潜在用例。我不会在这里全部介绍，但有几个用例代表了Web平台能力的重大提升：
- en: Image/video editing
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像/视频编辑
- en: Games
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏
- en: Music applications (streaming, caching)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐应用（流媒体，缓存）
- en: Image recognition
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别
- en: Live video augmentation
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时视频增强
- en: VR and augmented reality
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟现实和增强现实
- en: Although some of these use cases are technically feasible with JavaScript, HTML,
    and CSS, using WebAssembly can offer significant performance gains. Serving up
    a binary file (instead of a single JavaScript file) can greatly reduce the bundle
    size, and instantiating the Wasm module on page load speeds up code execution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些用例在技术上可以使用JavaScript、HTML和CSS实现，但使用WebAssembly可以提供显著的性能提升。提供二进制文件（而不是单个JavaScript文件）可以大大减少包的大小，在页面加载时实例化Wasm模块可以加快代码执行速度。
- en: WebAssembly isn't just limited to the browser. Outside the browser, you could
    use it to build hybrid native apps on mobile devices or perform server-side computations
    of untrusted code. Using Wasm modules for phone apps could be incredibly beneficial
    in terms of power usage and performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly不仅限于浏览器。在浏览器之外，你可以用它来在移动设备上构建混合原生应用或执行不受信任代码的服务器端计算。使用Wasm模块为手机应用提供的服务在功耗和性能方面可能非常有益。
- en: WebAssembly also offers flexibility with regard to how it can be used. You can
    write your entire code base in WebAssembly, although this may not be practical
    in its current form or in the context of a web application. Given WebAssembly's
    robust JavaScript API, you could write the UI in JavaScript/HTML and use Wasm
    modules for functionality that doesn't directly access the DOM. Once additional
    languages are supported, objects can be easily passed between the Wasm module
    and JavaScript code, which will greatly simplify integration and increase developer
    adoption.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 还提供了关于其使用方式的灵活性。你可以用 WebAssembly 编写整个代码库，尽管在当前形式或 Web 应用程序的环境中这可能并不实用。鉴于
    WebAssembly 强大的 JavaScript API，你可以用 JavaScript/HTML 编写 UI，并使用 Wasm 模块来实现不直接访问
    DOM 的功能。一旦支持更多语言，对象可以轻松地在 Wasm 模块和 JavaScript 代码之间传递，这将极大地简化集成并增加开发者的采用率。
- en: What languages are supported?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持哪些语言？
- en: WebAssembly's high-level goals for their MVP was to provide roughly the same
    functionality as `asm.js`. The two technologies are very closely related. C, C++,
    and Rust are very popular languages that support manual memory allocation, which
    made them ideal candidates for the initial implementation. In this section, we're
    going to provide a brief overview of each programming language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的 MVP 的高级目标是为 `asm.js` 提供大致相同的功能。这两种技术非常相似。C、C++ 和 Rust 是支持手动内存分配的非常流行的语言，这使得它们成为初始实现的理想候选。在本节中，我们将简要概述每种编程语言。
- en: C and C++
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 和 C++
- en: C and C++ are low-level programming languages that have been around for over
    30 years. C is procedural and doesn't inherently support object-oriented programming
    concepts such as classes and inheritance, but it's fast, portable, and widely
    used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 是存在了超过 30 年的低级编程语言。C 是过程式编程语言，本身不支持类和继承等面向对象编程概念，但它速度快、可移植且广泛使用。
- en: 'C++ was built to fill the gaps in C by adding features such as operator overloading
    and improved type checking. Both languages consistently rank in the top 10 most
    popular programming languages, which make them ideally suited for the MVP:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是为了填补 C 的不足而构建的，它通过添加如运算符重载和改进的类型检查等特性来增强 C 的功能。这两种语言一直位居最受欢迎的编程语言前十名，这使得它们非常适合
    MVP：
- en: '![](img/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png)'
- en: TIOBE Very Long Term History of the top 10 programming languages
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TIOBE 编程语言长期趋势排名前十
- en: C and C++ support is also baked into Emscripten, so in addition to simplifying
    the compilation process, it allows you to take advantage of WebAssembly's full
    capabilities. It is also possible to compile C/C++ code down to a `.wasm` file
    using LLVM. LLVM is a collection of modular and reusable compiler and toolchain
    technologies. In a nutshell, it's a framework that simplifies the configuration
    of a compilation process from source code to machine code. If you made your own
    programming language and would like to build a compiler, LLVM has tools to simplify
    the process. I'll cover how to compile C/C++ into `.wasm` files using LLVM in
    [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 的支持也集成到了 Emscripten 中，因此除了简化编译过程外，它还允许你利用 WebAssembly 的全部功能。使用 LLVM
    也可以将 C/C++ 代码编译成 `.wasm` 文件。LLVM 是一组模块化和可重用的编译器和工具链技术。简而言之，它是一个简化从源代码到机器代码配置过程的框架。如果你自己开发了一种编程语言并希望构建编译器，LLVM
    提供了简化该过程的工具。我将在第 10 章“高级工具和即将推出的功能”中介绍如何使用 LLVM 将 C/C++ 编译成 `.wasm` 文件。
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using C++:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用 C++ 将 `Hello World!` 打印到控制台：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rust
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust
- en: C and C++ were intended to be the primary languages used for WebAssembly, but
    Rust is a perfectly suitable substitute. Rust is a systems programming language
    that is syntactically similar to C++. It was designed with memory safety in mind,
    but still retains the performance advantages of C and C++. The current nightly
    build of Rust's compiler can generate `.wasm` files from Rust source code, so
    if you prefer Rust and are familiar with C++, you should be able to use Rust for
    most of the examples in this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 被设计为 WebAssembly 的主要使用语言，但 Rust 是一个完全合适的替代品。Rust 是一种与 C++ 语法相似的系统编程语言，它以内存安全为设计理念，同时仍保留了
    C 的性能优势。Rust 编译器的当前夜间构建可以从 Rust 源代码生成 `.wasm` 文件，因此如果你喜欢 Rust 并且熟悉 C++，你应该能够使用
    Rust 来完成本书中的大多数示例。
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using Rust:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用Rust将`Hello World!`打印到控制台：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other languages
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他语言
- en: 'Various tooling exists to enable the use of WebAssembly with some of the other
    popular programming languages, although they are mostly experimental:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些工具可以启用WebAssembly与其他一些流行编程语言的结合使用，尽管它们大多是实验性的：
- en: C# via Blazor
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Blazor的C#
- en: Haxe via WebIDL
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebIDL的Haxe
- en: Java via TeaVM or Bytecoder
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TeaVM或Bytecoder的Java
- en: Kotlin via TeaVM
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TeaVM的Kotlin
- en: TypeScript via AssemblyScript
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过AssemblyScript的TypeScript
- en: It is also technically possible to transpile a language to C and consequently
    compile that to a Wasm module, but the success of compilation is contingent on
    the output of the transpiler. More than likely, you'd have to make significant
    changes to the code to get it to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上也可以将一种语言转换为C，然后将其编译为Wasm模块，但编译的成功取决于转换器的输出。很可能会需要对代码进行重大修改才能使其工作。
- en: What are the limitations?
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制是什么？
- en: Admittedly, WebAssembly is not without its limitations. New features are being
    actively developed and the technology is constantly evolving, but the MVP functionality
    represents only a portion of WebAssembly's capabilities. In this section, we'll
    cover some of these limitations and how they impact the development process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，WebAssembly并非没有局限性。新功能正在积极开发中，该技术也在不断进化，但MVP功能仅代表了WebAssembly能力的一部分。在本节中，我们将介绍一些这些局限性以及它们如何影响开发过程。
- en: No garbage collection
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有垃圾回收
- en: WebAssembly supports a flat linear memory, which isn't a limitation per se,
    but requires some understanding of how to explicitly allocate memory to execute
    code. C and C++ were logical choices for the MVP because memory management is
    built into the language. The reason why some of the more popular high-level languages
    such as Java weren't included initially is due to something called **garbage collection**
    (**GC**).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly支持扁平线性内存，这本身并不是一个限制，但需要了解如何显式地分配内存以执行代码。C和C++是MVP的合理选择，因为内存管理是语言本身的一部分。一些更受欢迎的高级语言，如Java最初未包括在内，是因为存在一种称为**垃圾回收**（**GC**）的东西。
- en: GC is a form of automated memory management wherein memory occupied by objects
    that are no longer in use by the program is reclaimed automatically. GC is analogous
    to an automatic transmission on a car. It has been heavily optimized by skilled
    engineers to operate as efficiently as possible, but limits the amount of control
    the driver has. Manually allocating memory is like driving a car with a manual
    transmission. It affords greater control over speed and torque, but misuse or
    lack of experience can leave you stranded with a severely damaged car. Part of
    C and C++'s excellent performance and speed can be attributed to the manual allocation
    of memory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: GC是一种自动内存管理形式，其中不再被程序使用的对象占用的内存会自动回收。GC类似于汽车上的自动变速器。它已被熟练的工程师高度优化，以尽可能高效地运行，但限制了驾驶员的控制范围。手动分配内存就像驾驶一辆手动变速的汽车。它提供了对速度和扭矩的更大控制，但误用或缺乏经验可能导致汽车严重损坏。C和C++出色的性能和速度部分归因于内存的手动分配。
- en: GC languages allow you to program without having to worry about memory availability
    or allocation. JavaScript is an example of a GC language. The browser engine employs
    something called a mark-and-sweep algorithm to collect unreachable objects and
    free up the corresponding memory. Support for GC languages is currently being
    worked on in WebAssembly, but it's hard to say exactly when it will be completed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GC语言允许你编程时无需担心内存可用性或分配。JavaScript是GC语言的一个例子。浏览器引擎使用一种称为标记-清除算法的东西来收集不可达的对象并释放相应的内存。WebAssembly目前正在努力支持GC语言，但很难说具体何时会完成。
- en: No direct DOM access
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有直接DOM访问
- en: WebAssembly is unable to access the DOM, so any DOM manipulation needs to be
    done indirectly through JavaScript or using a tool such as Emscripten. There are
    plans to add the ability to reference DOM and other Web API objects directly,
    but that's still in the proposal phase. DOM manipulation will likely go hand in
    hand with GC languages, since it will allow the seamless passing of objects between
    WebAssembly and JavaScript code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly无法直接访问DOM，因此任何DOM操作都需要通过JavaScript或使用Emscripten等工具间接完成。目前有计划添加直接引用DOM和其他Web
    API对象的能力，但这仍处于提案阶段。DOM操作很可能会与GC语言相结合，因为它将允许WebAssembly和JavaScript代码之间无缝传递对象。
- en: No support in older browsers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在旧浏览器中没有支持
- en: Older browsers don't have the global `WebAssembly` object available to instantiate
    and load Wasm modules. There are experimental polyfills that utilize `asm.js`
    if the object isn't found, but the WebAssembly Working Group currently has no
    plans to create one. Since `asm.js` and WebAssembly are closely related, simply
    serving up an `asm.js` file if the `WebAssembly` object is unavailable will still
    offer performance gains while accommodating for backward compatibility. You can
    see which browsers currently support WebAssembly at [https://caniuse.com/#feat=wasm](https://caniuse.com/#feat=wasm).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的浏览器没有全局的 `WebAssembly` 对象可供实例化和加载 Wasm 模块。如果找不到该对象，有实验性的 polyfills 会使用 `asm.js`，但
    WebAssembly 工作组目前没有计划创建一个。由于 `asm.js` 和 WebAssembly 密切相关，如果 `WebAssembly` 对象不可用，仅提供
    `asm.js` 文件仍将提供性能提升，同时兼顾向后兼容性。您可以在 [https://caniuse.com/#feat=wasm](https://caniuse.com/#feat=wasm)
    查看当前支持 WebAssembly 的浏览器。
- en: How does it relate to Emscripten?
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它与 Emscripten 有何关联？
- en: Emscripten is the source-to-source compiler that can generate `asm.js` from
    C and C++ source code. We'll use it as a build tool to generate the Wasm modules.
    In this section, we'll quickly review how Emscripten relates to WebAssembly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 是一种源到源编译器，可以从 C 和 C++ 源代码生成 `asm.js`。我们将将其用作构建工具以生成 Wasm 模块。在本节中，我们将快速回顾
    Emscripten 与 WebAssembly 的关系。
- en: Emscripten's role
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten 的作用
- en: 'Emscripten is an LLVM-to-JavaScript compiler, which means it takes LLVM bitcode
    output of a compiler such as Clang (for C and C++), and converts that to JavaScript.
    It isn''t one specific technology, but rather a combination of technologies that
    work together to build, compile, and run `asm.js`. To generate Wasm modules, we''ll
    use the **Emscripten SDK** (**EMSDK**)  Manager:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 是一个 LLVM 到 JavaScript 的编译器，这意味着它将 Clang（用于 C 和 C++）等编译器的 LLVM 位码输出转换为
    JavaScript。它不是一个特定的技术，而是一系列协同工作以构建、编译和运行 `asm.js` 的技术组合。为了生成 Wasm 模块，我们将使用 **Emscripten
    SDK**（**EMSDK**）管理器：
- en: '![](img/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png)'
- en: Wasm module generation with the EMSDK
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EMSDK 生成 Wasm 模块
- en: The EMSDK and Binaryen
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMSDK 和 Binaryen
- en: In [Chapter 4](d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml), *Installing the
    Required Dependencies*, we'll install the EMSDK and use it to manage the dependencies
    required to compile C and C++ to Wasm modules. Emscripten uses Binaryen's `asm2wasm`
    tool to compile the `asm.js` output by Emscripten to a `.wasm` file. Binaryen
    is a compiler and toolchain infrastructure library that includes tools to compile
    various formats to WebAssembly modules and vice versa. Understanding the inner
    workings of Binaryen isn't required to use WebAssembly, but it is important to
    be aware of the underlying technologies and how they work together. By passing
    certain flags into the compile command for Emscripten (`emcc`), we can pipe the
    resultant `asm.js` code to Binaryen to output our `.wasm` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml) *安装所需依赖项* 中，我们将安装 EMSDK
    并使用它来管理编译 C 和 C++ 到 Wasm 模块所需的依赖项。Emscripten 使用 Binaryen 的 `asm2wasm` 工具将 Emscripten
    生成的 `asm.js` 输出编译为 `.wasm` 文件。Binaryen 是一个编译器和工具链基础设施库，包括将各种格式编译到 WebAssembly
    模块以及反向转换的工具。了解 Binaryen 的内部工作原理不是使用 WebAssembly 所必需的，但了解底层技术和它们如何协同工作是很重要的。通过将某些标志传递给
    Emscripten 的编译命令（`emcc`），我们可以将生成的 `asm.js` 代码管道传输到 Binaryen，以输出我们的 `.wasm` 文件。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the history of WebAssembly with regard to the
    technologies that led to its creation. A detailed overview of the definition of
    WebAssembly was provided to allow for a greater understanding of the underlying
    technologies involved.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 WebAssembly 的历史，以及导致其创建的技术。提供了 WebAssembly 定义的详细概述，以便更好地理解涉及到的底层技术。
- en: The *Core Specificati*on, *JavaScript API*, and *Web API* were presented as
    important elements of WebAssembly and demonstrate how the technology will evolve.
    We also reviewed potentials use cases, currently supported languages, and tools
    that enable the use of non-supported languages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范*、*JavaScript API* 和 *Web API* 被视为 WebAssembly 的重要元素，并展示了这项技术将如何发展。我们还回顾了潜在的使用案例、目前支持的语言以及使非支持语言得以使用的工具。'
- en: The limitations of WebAssembly are the absence of GC, the inability to communicate
    directly with the DOM, and the lack of support for older browsers. These were
    discussed to convey the newness of the technology and shed light on some of its
    shortcomings. Finally, we discussed Emscripten's role in the development process
    and where it fits into the WebAssembly development workflow.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的限制包括没有GC、无法直接与DOM通信以及不支持旧版浏览器。这些限制被讨论是为了传达这项技术的创新性并揭示其一些不足之处。最后，我们讨论了Emscripten在开发过程中的作用以及它在WebAssembly开发工作流程中的位置。
- en: 'In [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly
    - Wat, Wasm*, and *the JavaScript API*, we''ll be diving deeper into the elements
    that make up WebAssembly: the **WebAssembly text format** (**Wat**), binary format
    (Wasm), JavaScript, and Web APIs.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml)，《WebAssembly元素 - Wat, Wasm和JavaScript
    API》，我们将更深入地探讨构成WebAssembly的元素：WebAssembly文本格式（**Wat**）、二进制格式（Wasm）、JavaScript和Web
    API。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which two technologies influenced the creation of WebAssembly?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪两种技术影响了WebAssembly的创建？
- en: What is a stack machine and how does it relate to WebAssembly?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是栈式机器，它与WebAssembly有何关联？
- en: In what ways does WebAssembly complement JavaScript?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebAssembly如何补充JavaScript？
- en: Which three programming languages can be compiled to Wasm modules?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪三种编程语言可以编译成Wasm模块？
- en: What role does LLVM play with regard to WebAssembly?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM在WebAssembly中扮演什么角色？
- en: What are three potential use cases for WebAssembly?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebAssembly有哪些潜在的应用场景？
- en: How are DOM access and GC related?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM访问和垃圾回收（GC）有何关联？
- en: What tool does Emscripten use to generate Wasm modules?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emscripten使用什么工具生成Wasm模块？
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Official WebAssembly site: [https://webassembly.org](https://webassembly.org)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方WebAssembly网站：[https://webassembly.org](https://webassembly.org)
- en: 'Native Client technical overview: [https://developer.chrome.com/native-client/overview](https://developer.chrome.com/native-client/overview)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生客户端技术概述：[https://developer.chrome.com/native-client/overview](https://developer.chrome.com/native-client/overview)
- en: 'The LLVM Compiler Infrastructure Project: [https://llvm.org](https://llvm.org)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM编译器基础设施项目：[https://llvm.org](https://llvm.org)
- en: 'About Emscripten: [http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html](http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Emscripten：[http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html](http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html)
- en: 'asm.js specification: [http://asmjs.org/spec/latest](http://asmjs.org/spec/latest)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: asm.js规范：[http://asmjs.org/spec/latest](http://asmjs.org/spec/latest)
