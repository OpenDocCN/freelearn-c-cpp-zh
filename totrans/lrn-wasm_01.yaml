- en: What is WebAssembly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebAssembly** (**Wasm**) represents an important stepping stone for the web
    platform. Enabling a developer to run compiled code on the web without a plugin
    or browser lock-in presents many new opportunities. Some confusion exists about
    what WebAssembly is, as does some skepticism about its staying power.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how WebAssembly came to be, what WebAssembly
    is with regard to the official definition, and the technologies it encompasses. The
    potential use cases, supported languages, and limitations will be covered, as
    well as where to find additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal for this chapter is to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The technologies that led the way for WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What WebAssembly is and some of its potential use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which programming languages can be used with WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current limitations of WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How WebAssembly relates to Emscripten and asm.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The road to WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web development has had an interesting history, to say the least. Several (failed)
    attempts have been made to expand the platform to support different languages. Clunky
    solutions such as plugins failed to stand the test of time, and limiting a user
    to a single browser is a recipe for disaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly was developed as an elegant solution to a problem that has existed
    since browsers were first able to execute code: *If you want to develop for the
    web, you have to use JavaScript*. Fortunately, using JavaScript doesn''t have
    the same negative connotations it had back in the early 2000s, but it continues
    to have certain limitations as a programming language. In this section, we''re
    going to discuss the technologies that led to WebAssembly to get a better grasp
    of why this new technology is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript was created by Brendan Eich in just 10 days back in 1995\. Originally
    seen as a *toy* language by programmers, it was used primarily to make buttons
    flash or banners appear on a web page. The last decade has seen JavaScript evolve
    from a toy to a platform with profound capabilities and a massive following.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2008 heavy competition in the browser market resulted in the addition of
    **just-in-time** (**JIT**) compilers, which increased the execution speed of JavaScript
    by a factor of 10\. Node.js debuted in 2009 and represented a paradigm shift in
    web development. Ryan Dahl combined Google''s V8 JavaScript engine, an event loop,
    and a low-level I/O API to build a platform that allowed for the use of JavaScript
    across the server and client side. Node.js led to `npm`, a package manager that
    allowed for the development of libraries to be used within the Node.js ecosystem.
    As of the time of writing, there are over 600,000 packages available with hundreds
    being added every day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d473abb9-dda2-4db0-acfb-0a63607c8190.png)'
  prefs: []
  type: TYPE_IMG
- en: Package count growth on npm since 2012, taken from Modulecounts
  prefs: []
  type: TYPE_NORMAL
- en: It's not just the Node.js ecosystem that is growing; JavaScript itself is being
    actively developed. The ECMA **Technical Committee 39** (**TC39**), which dictates
    the standards for JavaScript and oversees the addition of new language features,
    releases *yearly* updates to JavaScript with a community-driven proposal process.
    Between its wealth of libraries and tooling, constant improvements to the language,
    and possessing one of the largest communities of programmers, JavaScript has become
    a force to be reckoned with.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the language does have some shortcomings:'
  prefs: []
  type: TYPE_NORMAL
- en: Up until recently, JavaScript only included 64-bit floating point numbers. This
    can cause issues with very large or very small numbers. `BigInt`, a new numeric
    primitive that can alleviate some of these issues, is in the the process of being
    added to the ECMAScript specification, but it may take some time until it's fully
    supported in browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript is weakly typed, which adds to its flexibility, but can cause confusion
    and bugs. It essentially gives you enough rope to hang yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript isn't as performant as compiled languages despite the best efforts
    of the browser vendors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a developer wants to create a web application, they need to learn JavaScript—whether
    they like it or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid having to write more than a few lines of JavaScript, some developers
    built **transpilers** to convert other languages to JavaScript. Transpilers (or
    source-to-source compilers) are types of compilers that convert source code in
    one programming language to equivalent source code in another programming language.
    TypeScript, which is a popular tool for frontend JavaScript development, transpiles
    TypeScript to valid JavaScript targeted for browsers or Node.js. Pick any programming
    language and there's a good chance that someone created a JavaScript transpiler
    for it. For example, if you prefer to write Python, you have about 15 different
    tools that you can use to generate JavaScript. In the end, though, it's still
    JavaScript, so you're still subject to the idiosyncrasies of the language.
  prefs: []
  type: TYPE_NORMAL
- en: As the web evolved into a valid platform for building and distributing applications,
    more and more complex and resource-intensive applications were created. In order
    to meet the demands of these applications, browser vendors began working on new
    technologies to integrate into their software without disrupting the normal course
    of web development. Google and Mozilla, creators of Chrome and Firefox, respectively,
    took two different paths to achieve this goal, culminating in the creation of
    WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Google and Native Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google developed **Native Client** (**NaCl**) with the intent to safely run
    native code within a web browser. The executable code would run in a **sandbox**
    and offered the performance advantages of native code execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of software development, a sandbox is an environment that prevents
    executable code from interacting with other parts of your system. It is intended
    to prevent the spread of malicious code and place restrictions on what software
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'NaCl was tied to a specific architecture, while **Portable Native Client**
    (**PNaCl**) was an architecture-independent version of NaCl developed to run on
    any platform. The technology consisted of two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Toolchains which could transform C/C++ code to NaCl modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runtime components which were components embedded in the browser that allowed
    execution of NaCl modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png)'
  prefs: []
  type: TYPE_IMG
- en: The Native Client toolchains and their outputs
  prefs: []
  type: TYPE_NORMAL
- en: 'NaCl''s architecture-specific executable (`nexe`) was limited to applications
    and extensions that were installed from Google''s Chrome Web Store, but PNaCl
    executables (`pexe`) can be freely distributed on the web and embedded in web
    applications. Portability was made possible with Pepper, an open source API for
    creating NaCl modules, and its corresponding plugin API (PPAPI). Pepper enabled
    communication between NaCl modules and the hosting browser, and allowed for access
    to system-level functions in a safe and portable way. Applications could be easily
    distributed by including a manifest file and a compiled module (`pexe`) with the
    corresponding HTML, CSS, and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a230248-b946-4f66-b811-ff2530fc48d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Pepper's role in a Native Client application
  prefs: []
  type: TYPE_NORMAL
- en: NaCl offered promising opportunities to overcome the performance limitations
    of the web, but it had some drawbacks. Although Chrome had built-in support for
    PNaCl executables and Pepper, other major browser did not. Detractors of the technology
    took issue with the black-box nature of the applications as well as the potential
    security risks and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla focused its efforts on improving the performance of JavaScript with
    `asm.js`. They wouldn't add support for Pepper to Firefox due to the incompleteness
    of its API specification and limited documentation. In the end, NaCl was deprecated
    in May, 2017, in favor of WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla and asm.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mozilla debuted `asm.js` in 2013 and provided a way for developers to translate
    their C and C++ source code to JavaScript. The official specification for `asm.js`
    defines it as a strict subset of JavaScript that can be used as a low-level, efficient
    target language for compilers. It's still valid JavaScript, but the language features
    are limited to those that are amenable to **ahead-of-time** (**AOT**) optimization. AOT is
    a technique that the browser's JavaScript engine uses to execute code more efficiently
    by compiling it down to native machine code. `asm.js` achieves these performance
    gains by having 100% type consistency and manual memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Using a tool such as Emscripten, C/C++ code can be transpiled down to `asm.js`
    and easily distributed using the same means as normal JavaScript. Accessing the
    functions in an `asm.js` module requires **linking**, which involves calling its
    function to obtain an object with the module's exports.
  prefs: []
  type: TYPE_NORMAL
- en: '`asm.js` is incredibly flexible, however, certain interactions with the module
    can cause a loss of performance. For example, if an `asm.js` module is given access
    to a custom JavaScript function that fails dynamic or static validation, the code
    can''t take advantage of AOT and falls back to the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png)'
  prefs: []
  type: TYPE_IMG
- en: The asm.js AOT compilation workflow
  prefs: []
  type: TYPE_NORMAL
- en: '`asm.js` isn''t just a stepping stone. It forms the basis for WebAssembly''s
    **Minimum Viable Product** (**MVP**). The official WebAssembly site explicitly
    mentions `asm.js` in the section entitled *WebAssembly High-Level Goals*.'
  prefs: []
  type: TYPE_NORMAL
- en: So why create WebAssembly when you could use `asm.js`? Aside from the potential
    performance loss, an `asm.js` module is a text file that must be transferred over
    the network before any compilation can take place. A WebAssembly module is in
    a binary format, which makes it much more efficient to transfer due to its smaller
    size.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly modules use a promise-based approach to instantiation, which takes
    advantage of modern JavaScript and eliminates the need for any *is this loaded*
    *yet?* code.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is born
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **World Wide Web Consortium** (**W3C**), an international community built
    to develop web standards, formed the WebAssembly Working Group in April, 2015,
    to standardize WebAssembly and oversee the specification and proposal process. Since
    then, the *Core Specification* and corresponding *JavaScript API* and *Web API*
    have been released. The initial implementation of WebAssembly support in browsers
    was based on the feature set of `asm.js`. WebAssembly's binary format and corresponding
    `.wasm` file combined facets of `asm.js` output with PNaCl's concept of a distributed
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how will WebAssembly succeed where NaCl failed? According to Dr. Axel Rauschmayer,
    there are three reasons detailed at [http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time](http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time):'
  prefs: []
  type: TYPE_NORMAL
- en: '"First, this is a collaborative effort, no single company goes it alone. At
    the moment, the following projects are involved: Firefox, Chromium, Edge and WebKit.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, the interoperability with the web platform and JavaScript is excellent.
    Using WebAssembly code from JavaScript will be as simple as importing a module.
  prefs: []
  type: TYPE_NORMAL
- en: Third, this is not about replacing JavaScript engines, it is more about adding
    a new feature to them. That greatly reduces the amount of work to implement WebAssembly
    and should help with getting the support of the web development community."
  prefs: []
  type: TYPE_NORMAL
- en: - Dr. Axel Rauschmayer
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is WebAssembly and where can I use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly has a succinct and descriptive definition on the official site,
    but it's only a piece of the puzzle. There are several other components that fall
    under the umbrella of WebAssembly. Understanding the role each component plays
    will give you a better understanding of the technology as a whole. In this section,
    we will provide a detailed breakdown of WebAssembly's definition and describe
    potential use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Official definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official WebAssembly website ([https://webassembly.org](https://webassembly.org))
    offers this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Wasm is a binary instruction format for a stack-based virtual machine. Wasm
    is designed as a portable target for compilation of high-level languages like
    C/C++/Rust, enabling deployment on the web for client and server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's break that definition down into parts to add some clarification.
  prefs: []
  type: TYPE_NORMAL
- en: Binary instruction format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly actually encompasses several elements—a binary format and text format,
    which are documented in the *Core Specification*, the corresponding APIs (JavaScript
    and web), and a compilation target. The binary and text format both map to a common
    structure in the form of an **abstract syntax**. To better understand abstract
    syntax, it can be explained in the context of an **abstract syntax tree** (**AST**). An
    AST is a tree representation of the structure of source code for a programming
    language. Tools such as ESLint use JavaScript's AST to find linting errors. The
    following example contains a function and the corresponding AST for JavaScript
    (taken from [https://astexplorer.net](https://astexplorer.net)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JavaScript function follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding AST is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An AST may be verbose, but it does an excellent job at describing the components
    of a program. Representing source code in an AST makes verification and compilation
    simple and efficient. WebAssembly code in text format is serialized into an AST
    and compiled to the binary format (as a `.wasm` file), which is fetched, loaded,
    and utilized by a web page. When the module is loaded, the browser's JavaScript
    engine utilizes a **decoding stack** to decode the `.wasm` file into an AST, perform
    type checking, and interpret it to execute functions. WebAssembly started as a
    binary instruction format for an AST. Due to the performance implications of verifying
    Wasm expressions that return `void`, the binary instruction format was updated
    to target a **stack machine**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stack machine consists of two elements: a stack and instructions. A stack
    is a data structure with two operations: *push* and *pop*. Items are pushed onto
    the stack and subsequently popped from the stack in **last in, first out** (**LIFO**)
    order. A stack also includes a **pointer**, which points to the item at the top
    of the stack. Instructions represent actions to perform on the items in the stack.
    For example, an `ADD` instruction might pop the top two items from the stack (the
    values `100` and `10`), and push a single item with the sum back onto the stack
    (the value `110`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e2d75b9-2021-4486-8049-726f6134410d.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple stack machine
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly's stack machine operates in the same way. A program counter (pointer)
    maintains the execution position within the code and a virtual control stack keeps
    track of `blocks` and `if` constructs as they are entered (pushed) and exited
    (popped). The instructions are executed with no reference to an AST. Thus, the
    **binary instruction format** portion of the definition refers to a binary representation
    of instructions that are in a format readable by the decoding stack in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Portable target for compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly was designed from the beginning with portability in mind. Portability
    in this context means that WebAssembly's binary format can be executed efficiently
    on a variety of operating systems and instruction set architectures, on and off
    the web. The specification for WebAssembly defines portability in the context
    of an execution environment. WebAssembly was designed to run efficiently in environments
    that meet certain characteristics, most of which are related to memory. WebAssembly's
    portability can also be attributed to the absence of a specific API around the
    core technologies. Instead, it defines an `import` mechanism where the set of
    available imports is defined by the host environment.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, this means that WebAssembly isn't tied to a specific environment,
    such as the web or desktop. The WebAssembly Working Group has defined a *Web API*,
    but that's separate from the *Core Specification*. The *Web API* caters to WebAssembly,
    not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: The **compilation** aspect of the definition indicates that WebAssembly will
    be simple to compile down to its binary format from source code written in high-level
    languages. The MVP focuses on two languages, C and C++, but Rust can also be used
    given its similarities to C++. Compilation will be achieved through the use of
    a Clang/LLVM backend, although we'll be using Emscripten in this book to generate
    our Wasm modules. The plan is to eventually add support for other languages and
    compilers (such as GCC), but the MVP is focused on LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: The core specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official definition gives some high-level insight into the overall technology,
    but for the sake of completeness, it''s worth digging a little deeper. WebAssembly''s
    *Core Specification* is the official document to reference if you want to understand
    WebAssembly at a very granular level. If you''re interested in learning about
    the characteristics of the runtime structure with regard to the execution environment,
    check out section 4: *Execution*. We won''t cover that here, but understanding
    where the *Core Specification* fits in will help in establishing a complete definition
    of WebAssembly.'
  prefs: []
  type: TYPE_NORMAL
- en: Language concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Core Specification* states WebAssembly encodes a low-level, assembly-like
    programming language. The specification defines the structure, execution, and
    validation of this language as well as the details of the binary and text formats.
    The language itself is structured around the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Values**, or rather value types that WebAssembly provides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instructions** that are executed within the stack machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traps** produced under error conditions and abort execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions **into which code is organized, each of which takes a sequence
    of values as parameters and returns a sequence of values as a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tables**, which are arrays of values of a particular element type (such as
    function references) that are selectable by the executing program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Memory**, which is an array of raw bytes that can be used to store
    and load values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**, WebAssembly binary (`.wasm` file) that contains function, tables,
    and linear memories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedder**, the mechanism by which WebAssembly can be executed in a host
    environment, such as a web browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions, tables, memory, and modules have direct correlations with the *JavaScript
    API* and are important to be aware of. These concepts describe the underlying
    structure of the language itself and how to write or encode WebAssembly. With
    regard to usage, understanding the corresponding semantic phases of WebAssembly
    provides a complete definition of the technology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52382cbb-fa93-4206-adde-c38848bf1429.png)'
  prefs: []
  type: TYPE_IMG
- en: Language concepts and their relationship
  prefs: []
  type: TYPE_NORMAL
- en: Semantic phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Core Specification* describes the different phases an encoded module (`.wasm`
    file) undergoes when it is being utilized in a host environment (such as a web
    browser). This aspect of the specification represents how the output is handled
    and executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoding**: The binary format is converted into a module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation**: The decoded module undergoes validation checks (such as type
    checking) to ensure the module is well formed and safe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution, Part 1: Instantiation**: A module instance, which is the dynamic
    representation of the module, is instantiated by initializing the **Globals**,
    **Memories**, and **Tables**, and invokes the module''s `start()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution, Part 2: Invocation**: Exported functions are called from the module
    instance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram provides a visual representation of the semantic phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51755ca6-f4c7-43b3-93d3-81575523ae30.png)'
  prefs: []
  type: TYPE_IMG
- en: Semantic phases of module use
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript and Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WebAssembly Working Group also released API specifications for interacting
    with JavaScript and the web, which qualifies them for inclusion in the WebAssembly
    technology space. The *JavaScript API* is scoped to the JavaScript language itself,
    without being specifically tied to an environment (for example, web browsers or
    Node.js). It defines classes, methods, and objects for interacting with WebAssembly
    and managing the compilation and instantiation processes. The *Web API* is an
    extension of the *JavaScript API* that defines functionality specific to web browsers.
    The *Web API* specification currently only defines two methods, `compileStreaming`
    and `instantiateStreaming`, which are convenience methods that simplify the use
    of Wasm modules in the browser. These will be covered in greater detail in [Chapter
    2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly - Wat,
    Wasm, and the JavaScript API*.
  prefs: []
  type: TYPE_NORMAL
- en: So will it replace JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly's ultimate goal is not to replace JavaScript, but rather to complement
    it. JavaScript's rich ecosystem and flexibility still makes it the ideal language
    for the web. WebAssembly's JavaScript API makes interoperability between the two
    technologies relatively simple. So will you be able to build a web application
    using just WebAssembly? One of the explicit goals of WebAssembly is portability,
    and replicating all of JavaScript's functionality could inhibit that goal. However,
    the official site includes a goal to execute and integrate well with the existing
    web platform, so only time will tell. It may not be practical to write the entire
    code base in a language that compiles down to WebAssembly, but moving some of
    the application logic to Wasm modules could be beneficial in terms of performance
    and load times.
  prefs: []
  type: TYPE_NORMAL
- en: Where can I use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebAssembly''s official site has an extensive list of potential use cases.
    I''m not going to cover them all here, but there are several that represent significant
    enhancements to the capabilities of the web platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Image/video editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Music applications (streaming, caching)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live video augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VR and augmented reality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although some of these use cases are technically feasible with JavaScript, HTML,
    and CSS, using WebAssembly can offer significant performance gains. Serving up
    a binary file (instead of a single JavaScript file) can greatly reduce the bundle
    size, and instantiating the Wasm module on page load speeds up code execution.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly isn't just limited to the browser. Outside the browser, you could
    use it to build hybrid native apps on mobile devices or perform server-side computations
    of untrusted code. Using Wasm modules for phone apps could be incredibly beneficial
    in terms of power usage and performance.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly also offers flexibility with regard to how it can be used. You can
    write your entire code base in WebAssembly, although this may not be practical
    in its current form or in the context of a web application. Given WebAssembly's
    robust JavaScript API, you could write the UI in JavaScript/HTML and use Wasm
    modules for functionality that doesn't directly access the DOM. Once additional
    languages are supported, objects can be easily passed between the Wasm module
    and JavaScript code, which will greatly simplify integration and increase developer
    adoption.
  prefs: []
  type: TYPE_NORMAL
- en: What languages are supported?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly's high-level goals for their MVP was to provide roughly the same
    functionality as `asm.js`. The two technologies are very closely related. C, C++,
    and Rust are very popular languages that support manual memory allocation, which
    made them ideal candidates for the initial implementation. In this section, we're
    going to provide a brief overview of each programming language.
  prefs: []
  type: TYPE_NORMAL
- en: C and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and C++ are low-level programming languages that have been around for over
    30 years. C is procedural and doesn't inherently support object-oriented programming
    concepts such as classes and inheritance, but it's fast, portable, and widely
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ was built to fill the gaps in C by adding features such as operator overloading
    and improved type checking. Both languages consistently rank in the top 10 most
    popular programming languages, which make them ideally suited for the MVP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png)'
  prefs: []
  type: TYPE_IMG
- en: TIOBE Very Long Term History of the top 10 programming languages
  prefs: []
  type: TYPE_NORMAL
- en: C and C++ support is also baked into Emscripten, so in addition to simplifying
    the compilation process, it allows you to take advantage of WebAssembly's full
    capabilities. It is also possible to compile C/C++ code down to a `.wasm` file
    using LLVM. LLVM is a collection of modular and reusable compiler and toolchain
    technologies. In a nutshell, it's a framework that simplifies the configuration
    of a compilation process from source code to machine code. If you made your own
    programming language and would like to build a compiler, LLVM has tools to simplify
    the process. I'll cover how to compile C/C++ into `.wasm` files using LLVM in
    [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and C++ were intended to be the primary languages used for WebAssembly, but
    Rust is a perfectly suitable substitute. Rust is a systems programming language
    that is syntactically similar to C++. It was designed with memory safety in mind,
    but still retains the performance advantages of C and C++. The current nightly
    build of Rust's compiler can generate `.wasm` files from Rust source code, so
    if you prefer Rust and are familiar with C++, you should be able to use Rust for
    most of the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Various tooling exists to enable the use of WebAssembly with some of the other
    popular programming languages, although they are mostly experimental:'
  prefs: []
  type: TYPE_NORMAL
- en: C# via Blazor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haxe via WebIDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java via TeaVM or Bytecoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin via TeaVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript via AssemblyScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also technically possible to transpile a language to C and consequently
    compile that to a Wasm module, but the success of compilation is contingent on
    the output of the transpiler. More than likely, you'd have to make significant
    changes to the code to get it to work.
  prefs: []
  type: TYPE_NORMAL
- en: What are the limitations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admittedly, WebAssembly is not without its limitations. New features are being
    actively developed and the technology is constantly evolving, but the MVP functionality
    represents only a portion of WebAssembly's capabilities. In this section, we'll
    cover some of these limitations and how they impact the development process.
  prefs: []
  type: TYPE_NORMAL
- en: No garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly supports a flat linear memory, which isn't a limitation per se,
    but requires some understanding of how to explicitly allocate memory to execute
    code. C and C++ were logical choices for the MVP because memory management is
    built into the language. The reason why some of the more popular high-level languages
    such as Java weren't included initially is due to something called **garbage collection**
    (**GC**).
  prefs: []
  type: TYPE_NORMAL
- en: GC is a form of automated memory management wherein memory occupied by objects
    that are no longer in use by the program is reclaimed automatically. GC is analogous
    to an automatic transmission on a car. It has been heavily optimized by skilled
    engineers to operate as efficiently as possible, but limits the amount of control
    the driver has. Manually allocating memory is like driving a car with a manual
    transmission. It affords greater control over speed and torque, but misuse or
    lack of experience can leave you stranded with a severely damaged car. Part of
    C and C++'s excellent performance and speed can be attributed to the manual allocation
    of memory.
  prefs: []
  type: TYPE_NORMAL
- en: GC languages allow you to program without having to worry about memory availability
    or allocation. JavaScript is an example of a GC language. The browser engine employs
    something called a mark-and-sweep algorithm to collect unreachable objects and
    free up the corresponding memory. Support for GC languages is currently being
    worked on in WebAssembly, but it's hard to say exactly when it will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: No direct DOM access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly is unable to access the DOM, so any DOM manipulation needs to be
    done indirectly through JavaScript or using a tool such as Emscripten. There are
    plans to add the ability to reference DOM and other Web API objects directly,
    but that's still in the proposal phase. DOM manipulation will likely go hand in
    hand with GC languages, since it will allow the seamless passing of objects between
    WebAssembly and JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: No support in older browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Older browsers don't have the global `WebAssembly` object available to instantiate
    and load Wasm modules. There are experimental polyfills that utilize `asm.js`
    if the object isn't found, but the WebAssembly Working Group currently has no
    plans to create one. Since `asm.js` and WebAssembly are closely related, simply
    serving up an `asm.js` file if the `WebAssembly` object is unavailable will still
    offer performance gains while accommodating for backward compatibility. You can
    see which browsers currently support WebAssembly at [https://caniuse.com/#feat=wasm](https://caniuse.com/#feat=wasm).
  prefs: []
  type: TYPE_NORMAL
- en: How does it relate to Emscripten?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten is the source-to-source compiler that can generate `asm.js` from
    C and C++ source code. We'll use it as a build tool to generate the Wasm modules.
    In this section, we'll quickly review how Emscripten relates to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten's role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emscripten is an LLVM-to-JavaScript compiler, which means it takes LLVM bitcode
    output of a compiler such as Clang (for C and C++), and converts that to JavaScript.
    It isn''t one specific technology, but rather a combination of technologies that
    work together to build, compile, and run `asm.js`. To generate Wasm modules, we''ll
    use the **Emscripten SDK** (**EMSDK**)  Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Wasm module generation with the EMSDK
  prefs: []
  type: TYPE_NORMAL
- en: The EMSDK and Binaryen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml), *Installing the
    Required Dependencies*, we'll install the EMSDK and use it to manage the dependencies
    required to compile C and C++ to Wasm modules. Emscripten uses Binaryen's `asm2wasm`
    tool to compile the `asm.js` output by Emscripten to a `.wasm` file. Binaryen
    is a compiler and toolchain infrastructure library that includes tools to compile
    various formats to WebAssembly modules and vice versa. Understanding the inner
    workings of Binaryen isn't required to use WebAssembly, but it is important to
    be aware of the underlying technologies and how they work together. By passing
    certain flags into the compile command for Emscripten (`emcc`), we can pipe the
    resultant `asm.js` code to Binaryen to output our `.wasm` file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the history of WebAssembly with regard to the
    technologies that led to its creation. A detailed overview of the definition of
    WebAssembly was provided to allow for a greater understanding of the underlying
    technologies involved.
  prefs: []
  type: TYPE_NORMAL
- en: The *Core Specificati*on, *JavaScript API*, and *Web API* were presented as
    important elements of WebAssembly and demonstrate how the technology will evolve.
    We also reviewed potentials use cases, currently supported languages, and tools
    that enable the use of non-supported languages.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of WebAssembly are the absence of GC, the inability to communicate
    directly with the DOM, and the lack of support for older browsers. These were
    discussed to convey the newness of the technology and shed light on some of its
    shortcomings. Finally, we discussed Emscripten's role in the development process
    and where it fits into the WebAssembly development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly
    - Wat, Wasm*, and *the JavaScript API*, we''ll be diving deeper into the elements
    that make up WebAssembly: the **WebAssembly text format** (**Wat**), binary format
    (Wasm), JavaScript, and Web APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which two technologies influenced the creation of WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a stack machine and how does it relate to WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what ways does WebAssembly complement JavaScript?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which three programming languages can be compiled to Wasm modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What role does LLVM play with regard to WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are three potential use cases for WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are DOM access and GC related?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tool does Emscripten use to generate Wasm modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Official WebAssembly site: [https://webassembly.org](https://webassembly.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Native Client technical overview: [https://developer.chrome.com/native-client/overview](https://developer.chrome.com/native-client/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The LLVM Compiler Infrastructure Project: [https://llvm.org](https://llvm.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About Emscripten: [http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html](http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'asm.js specification: [http://asmjs.org/spec/latest](http://asmjs.org/spec/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
