- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: States and Animations with Qt and QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt provides an easy way to animate widgets or any other objects that inherit
    the `QObject` class through its powerful animation framework. The animation can
    be used either on its own or together with the **state machine framework**, which
    allows different animations to be played based on the current active state of
    the widget. Qt’s animation framework also supports grouped animation, which allows
    you to move more than one graphics item simultaneously or move them in sequence,
    one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Property animation in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using easing curves to control property animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an animation group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a nested animation group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State machines in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: States, transitions, and animations in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating widget properties using animators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**,
    **Qt Creator 12.0.2**, and Windows 11\. All the code used in this chapter can
    be downloaded from the following GitHub repository at [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Property animation in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to animate our `property animation` class,
    a part of its powerful animation framework that allows us to create fluid-looking
    animations with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we will create a new widget project and animate the
    push button by changing its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new `mainwindow.ui` with Qt Designer and place a button on the
    main window, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Dragging and dropping a push button to the UI canvas](img/B20976_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Dragging and dropping a push button to the UI canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `mainwindow.cpp` and add the following line of code at the beginning
    of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and add the following code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the more common methods of animating a GUI element is through the property
    animation class provided by Qt, known as the `QPropertyAnimation` class. This
    class is part of the animation framework and it makes use of the timer system
    in Qt to change the properties of a GUI element over a given duration.
  prefs: []
  type: TYPE_NORMAL
- en: What we are trying to accomplish here is animating the button from one position
    to another while, at the same time, enlarging the button size along the way. By
    including the `QPropertyAnimation` header in our source code in *step 2*, we will
    be able to access the `QPropertyAnimation` class provided by Qt and make use of
    its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The code in *step 3* basically creates a new *property animation* and applies
    it to the `property animation` class changes the geometry properties of the *push
    button* and sets its duration to 3,000 milliseconds (3 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the start value of the animation is set to the initial geometry of the
    *push button* because, obviously, we want it to start from where we initially
    placed the button in Qt Designer. The `end` value is then set to what we want
    it to become; in this case, we will move the button to a new position at `x: 200`
    and `y: 200` while changing its size to `width: 100` and `height: 50` along the
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, call `animation` | `start()` to start the animation. Compile and
    run the project. You should see the button start to move slowly across the main
    window while expanding in size a bit at a time until it reaches its destination.
    You can change the animation duration and the target position and scale by altering
    the values in the preceding code. It is really that simple to animate a GUI element
    using Qt’s property animation system!
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt provides us with several different sub-systems to create animations for
    our GUI, including the timer, timeline, animation framework, state machine framework,
    and graphics view framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event callback` function will be triggered through Qt’s *signal-and-slot*
    mechanism. You can make use of a timer to change the properties (color, position,
    scale, and so on) of your GUI element within a given interval to create an animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: The *Timeline* calls a slot periodically to animate a GUI element.
    It is quite similar to a *repetitive timer*, but instead of doing the same thing
    all of the time when the slot is triggered, the timeline provides a value to the
    slot to indicate its current frame index so that you can do different things (such
    as offset to a different space of the sprite sheet) based on the given value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation framework**: The *animation framework* makes animating a GUI element
    easy by allowing its properties to be animated. The animations are controlled
    by using *easing curves*. Easing curves describe a function that controls what
    the speed of the animation should be, resulting in different acceleration and
    deceleration patterns. The types of easing curves supported by Qt include linear,
    quadratic, cubic, quartic, sine, exponential, circular, and elastic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State machine framework**: Qt provides us with classes for creating and executing
    state graphs, which allow each GUI element to move from one state to another when
    triggered by signals. The *state graph* in the *state machine framework* is hierarchical,
    which means every state can also be nested inside of other states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics view framework**: The *graphics view framework* is a powerful graphics
    engine for visualizing and interacting with a large number of custom-made 2D graphical
    items. You can use the graphics view framework to draw your GUI and have them
    animated in a totally manual way if you are an experienced programmer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By making use of all of the powerful features we’ve mentioned here, we’re able
    to create an intuitive and modern GUI with ease. In this chapter, we will look
    into the practical approaches to animating GUI elements using Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Using easing curves to control property animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to make our animation more interesting by
    utilizing *easing curves*. We will still use the previous source code, which uses
    the property animation to animate a push button.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we will learn how to add an *easing curve* to our
    animation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an easing curve and add it to the property animation before calling
    the `start()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `setLoopCount()` function to set how many loops you want it to repeat
    for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `setAmplitude()`, `setOvershoot()`, and `setPeriod()` before applying
    the easing curve to the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s really that easy to animate a widget or any object in Qt 6 using the built-in
    easing curves.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To let an easing curve control the animation, all you need to do is define
    an easing curve and add it to the property animation before calling the `start()`
    function. You can also try several other types of easing curves and see which
    one suits you best. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the animation to loop after it has finished playing, you can call
    the `setLoopCount()` function to set how many loops you want it to repeat for
    or set the value to `-1` for an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several parameters that you can set to refine the easing curve before
    applying it to the property animation. These parameters include **amplitude**,
    **overshoot**, and **period**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amplitude**: The higher the *amplitude*, the higher the bounce or elastic
    spring effect that will be applied to the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overshoot**: Some curve functions will produce an *overshoot* (exceeding
    its final value) curve due to a damping effect. By adjusting the overshoot value,
    we are able to increase or decrease this effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Period**: Setting a small period value will give a high frequency to the
    curve. A large *period* will give it a small frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters, however, are not applicable to all curve types. Please refer
    to the Qt documentation to see which parameter is applicable to which curve type.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the property animation works perfectly fine, sometimes it feels a little
    boring to look at a GUI element being animated at a constant speed. We can make
    the animation look more interesting by adding an **easing curve** to control the
    motion. There are many types of easing curves that you can use in Qt, and here
    are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Different types of easing curves supported by Qt 6](img/B20976_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Different types of easing curves supported by Qt 6
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding diagram, each easing curve produces a different
    *ease-in and* *ease-out* effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the full list of easing curves available in Qt, please refer to the Qt documentation
    at [http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum](http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animation group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to use an *animation group* to manage the
    states of the animations contained in the group.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create an *animation group* by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the previous example but, this time, we will add two more push
    buttons to the main window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Adding three push buttons to the main window](img/B20976_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Adding three push buttons to the main window
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the *animation* for each of the push buttons in the main window’s constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an *easing curve* and apply the same curve to all three animations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have applied the easing curve to all three animations, we will then
    create an *animation group* and add all three animations to the group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `start()` function from the animation group we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt allows us to create multiple animations and group them into an animation
    group. A group is usually responsible for managing the state of its animations
    (that is, it decides when to start, stop, resume, and pause them). Currently,
    Qt provides two types of classes for animation groups: `QParallelAnimationGroup`
    and `QSequentialAnimationGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QParallelAnimationGroup`: As its name implies, a *parallel animation group*
    runs all of the animations in its group at the same time. The group is deemed
    finished when the longest-lasting animation has finished running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSequentialAnimationGroup`: A *sequential animation group* runs its animations
    in sequence, meaning it will only run a single animation at a time and only play
    the next animation when the current one has finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are using an animation group now, we no longer call the `start()`
    function from the individual animation. Instead, we will be calling the `start()`
    function from the animation group we just created. If you compile and run the
    example now, you will see all three buttons being played at the same time. This
    is because we are using the **parallel** **animation group**. You can replace
    it with a **sequential animation group** and run the example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, only a single button will play its animation at a time, while the
    other buttons will wait patiently for their turn to come. The priority is set
    based on which animation is added to the animation group first. You can change
    the animation sequence by simply rearranging the sequence of an animation that’s
    being added to the group. For example, if we want button `3` to start the animation
    first, followed by button `2`, and then button `1`, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since property animations and animation groups are both inherited from the `QAbstractAnimator`
    class, it means that you can also add an animation group to another animation
    group to form a more complex, nested animation group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a nested animation group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One good example of using a **nested animation group** is when you have several
    **parallel** animation groups and you want to play the groups in sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s follow these steps to create a **nested animation group** to play different
    animation groups in a sequential order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the UI from the previous example and add a few more buttons to
    the main window, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – We need even more buttons this time around](img/B20976_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – We need even more buttons this time around
  prefs: []
  type: TYPE_NORMAL
- en: 'Create all of the animations for the buttons and then create an easing curve
    and apply it to all of the animations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, apply the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, apply the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two **animation groups**, one for the buttons in the upper column and
    another one for the lower column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create yet another **animation group**, which will be used to store
    the two animation groups we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A Nested animation group allows you to set up a more complex widget animation
    by combining different types of animations and executing them at your desired
    orders.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are trying to do here is play the animation of the buttons in the upper
    column first, followed by the buttons in the lower column. Since both of the animation
    groups are `start()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: This time, however, the group is a **sequential animation group**, which means
    only a single parallel animation group will be played at a time, followed by the
    other when the first one is finished. Animation groups are a very handy system
    that allows us to create very complex GUI animations with simple coding. Qt will
    handle the difficult part for us so that we don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: State machines in Qt 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **state machine** can be used for many purposes but, in this chapter, we will
    only cover topics related to animation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **State machine** is not that hard to achieve in Qt at all. Let’s get started
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up a new user interface for our example program, which looks like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Setting up the GUI for our state machine experiment](img/B20976_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Setting up the GUI for our state machine experiment
  prefs: []
  type: TYPE_NORMAL
- en: 'We will include some headers in our source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our main window’s constructor, add the following code to create a *new state
    machine* and two *states*, which we will be using later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will define what we should do within each state, which, in this case, will
    be to change the label’s *text* and the button’s *position* and *size*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, let’s proceed by adding `event transition` classes
    to our source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add all of the states we have just created to the state machine and define
    state 1 as the `machine->start()` to run the state machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the example program now, you will notice that everything works fine,
    except the button is not going through a smooth transition and it simply jumps
    instantly to the position and size we set previously. This is because we have
    not used a **property animation** to create a smooth transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the event transition step and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also add an easing curve to the animation to make it look more interesting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two push buttons and a label on the main window layout. The button
    in the top-left corner will trigger the state change when pressed, while the label
    in the top-right corner will change its text to show which state we are currently
    in. the button below will animate according to the current state. The `QEventTransition`
    classes define what will trigger the transition between one state and another.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we want the state to change from state 1 to state 2 when the `assignProperty()`
    function, which has automatically assigned the end value.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **state machine framework** in Qt provides classes for creating and executing
    state graphs. Qt’s event system is used to drive the state machines, where transitions
    between states can be triggered by using *signals*, and then the *slots* on the
    other end will be invoked by the signals to perform an action, such as playing
    an animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand the basics of state machines, you can use them to do other
    things as well. The state graph in the state machine framework is hierarchical.
    Just like the animation group in the previous section, states can also be nested
    inside of other states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Nested state machines explained visually](img/B20976_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Nested state machines explained visually
  prefs: []
  type: TYPE_NORMAL
- en: You can combine nested state machines and animations to create a very sophisticated
    GUI for your application.
  prefs: []
  type: TYPE_NORMAL
- en: States, transitions, and animations in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you prefer to work with QML instead of C++, Qt also provides similar features
    in Qt Quick that allow you to easily animate a GUI element with minimal lines
    of code. In this example, we will learn how to achieve this with QML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps to create a window that continuously
    changes its background color:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new **Qt Quick Application** project and set up our user interface,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – A joyful application that constantly changes its background
    color](img/B20976_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – A joyful application that constantly changes its background color
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what my `main.qml` file looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the *color animation* to the `Rectangle` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a *number animation* to the `text` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another *number animation* to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define two *states*, one called the `PRESSED` state and another called the
    `RELEASED` state. Then, set the default state to `RELEASED`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, create a mouse area within the `Rectangle` object so that we can
    click on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some transitions to the `Rectangle` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main window consists of a blue rectangle and static text that says `Rectangle`
    object, then creating three different *color animations* within the group, which
    will change the color of the object every 1,000 milliseconds (1 second). We also
    set the animations to loop infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we want to use the *number animation* to animate the alpha value
    of the static text. We created another *sequential animation group* within the
    `Text` object and created two *number animations* to animate the alpha value from
    `0` to `1` and back. Then, we set the animations to loop infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 5*, we rotate the `Hello World` text by adding another `Rectangle`
    object change from one color to another when we clicked on it. When the mouse
    is released, the `Rectangle` object will change back to its initial color. To
    achieve that, we first need to define the two states, one called the `PRESSED`
    state and another called the `RELEASED` state. Then, we set the default state
    to `RELEASED`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you compile and run the example, the background will instantly change
    color to blue when pressed and change back to red when the mouse is released.
    That works great, and we can further enhance it by giving it a little transition
    when switching color. This can be easily achieved by adding transitions to the
    `Rectangle` object.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In QML, there are eight different types of property animation you can use,
    and these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anchor animation**: Animates changes in anchor values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color animation**: Animates changes in color values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number animation**: Animates changes in qreal-type values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent animation**: Animates changes in parent values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path animation**: Animates an item along a path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property animation**: Animates changes in property values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation animation**: Animates changes in rotation values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector3d animation**: Animates changes in QVector3D values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the C++ version, these animations can also be grouped together in
    an animation group to play the animations in sequence or parallel. You can also
    control the animations using easing curves and determine when to play these animations
    using state machines, just like we did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Animating widget properties using animators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to animate the properties of our GUI widgets
    using the animator feature that’s provided by QML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Animating QML objects is really easy if you perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Rectangle` object and add a *scale animator* to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a *rotation animator* and set the `running` value in the parallel animation
    group, but not in any of the individual animators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an *easing curve* to the *scale animator*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *animator* type can be used just like any other *animation* type. We want
    to scale a rectangle from a size of `5` to a size of `1` within 2,000 milliseconds
    (2 seconds). We created a blue `Rectangle` object and added a *scale animator*
    to it. We set the `initial` value to `5` and the `final` value to `1`. Then, we
    set the animation `duration` to `2000` and set the `running` value to `true` so
    that it will be played when the program starts.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the animation types, animators can also be put into groups (that is,
    **parallel** **animation groups** or **sequential animation groups**). An animation
    group will also be treated as an animator by QtQuick and be run on the scene graph’s
    rendering thread whenever possible. In step 2, we want to group two different
    animators into a **parallel animation group** so that they run together at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: We will keep the `running` value in the parallel animation group, but not in
    any of the individual animators.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the C++ version, QML also supports **easing curves**, and they can
    be easily applied to any of the animations or animator types.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is something called an *animator* in QML, which is different from the
    usual *animation* type, even though there is some similarity between them. Unlike
    regular animation types, animator types are directly operated on Qt Quick’s **scene
    graph**, rather than the QML objects and their properties. The value of the QML
    property will not be changed while the animation is running, as it will only change
    once the animation is finished. The benefit of using the animator type is that
    it operates directly on the scene graph’s rendering thread, which means its performance
    will be slightly better than running on the **UI thread**.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to create a **sprite animation** in QML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s make a horse run across our application window by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to add our sprite sheet to Qt’s *resource system* so that it can
    be used in the program. Open up `qml.qrc` and click the **Add** | **Add Files**
    buttons. Select your sprite sheet image and save the resource file by pressing
    *Ctrl* + *S*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new empty window in `main.qml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, we will start creating an `AnimatedSprite` object
    in QML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, set the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a *mouse area* to the window and check for the `onClicked` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you compile and run the example program now, you will see a little pony
    running in the middle of the window. How fun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A horse running across the application window](img/B20976_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – A horse running across the application window
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to try and do something cool. We will make the horse run across
    the window and loop infinitely while playing its running animation! First, we
    need to remove `anchors.centerIn: parent` from QML and replace it with `x` and
    `y` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a *number animation* to the sprite object and set its properties, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you compile and run the example program now, you will see the pony go crazy
    and start running across the window!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we place the animated sprite object in the middle of the window
    and set its image source to the sprite sheet that we have just added to the project
    resource. Then, we count how many frames there are in the sprite sheet that belong
    to the running animation, which in this case is 11 frames. We also inform Qt of
    the dimensions of each frame of the animation, which in this case are `128 x 128`.
    After that, we set the frame rate to `25` to get a decent speed and then set it
    to loop infinitely. We then set the `running` value to `true` so that the animation
    will play by default when the program starts running.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *step 4*, we want to be able to pause the animation and resume it by
    clicking on the window. We simply check whether the sprite is currently paused
    when clicking on the mouse area. If the sprite animation is paused, then the animation
    resumes; otherwise, the animation is paused.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we replace `anchors.centerIn` with `x` and `y` values so that the
    animated sprite object is not anchored to the center of the window, which would
    make it impossible to move around. Then, we create a *number animation* within
    the animated sprite to animate its `x` property. We set the `start` value to somewhere
    outside the window on the left side, and we set the `end` value to somewhere outside
    the window on the right side. After that, we set the `duration` to 3,000 milliseconds
    (3 seconds) and make it loop infinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we also set the `running` value to `true` so that it plays the animation
    by default when the program starts running.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sprite animation is used extensively, especially in game development. Sprites
    are used for character animation, particle animation, and even GUI animation.
    A sprite sheet consists of many images combined into one, which can then be chopped
    down and displayed on the screen, one at a time. The transitions between different
    images (or sprites) from the sprite sheet creates the illusion of animation, which
    we usually refer to as a sprite animation. A Sprite animation can be easily achieved
    in QML using the `AnimatedSprite` type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this example program, I am using a free and open source image that was created
    by **bluecarrot16** under the *CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0* license.
    The image can be obtained legally at [http://opengameart.org/content/lpc-horse](http://opengameart.org/content/lpc-horse).
  prefs: []
  type: TYPE_NORMAL
