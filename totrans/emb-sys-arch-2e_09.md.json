["```cpp\nstruct *netif netif_add(struct netif *mynetif,\n    struct ip_addr *ipaddr,\n    struct ip_addr *netmask,\n    struct ip_addr *gw, void *state,\n    err_t (* init)(struct netif *netif),\n    err_t (* input)(struct pbuf *p, struct netif *netif));\n```", "```cpp\nint pico_device_init(struct pico_device *dev, const char *name, const uint8_t *mac);\n```", "```cpp\nint32_t pico_stack_recv(struct pico_device *dev, uint8_t *buffer, uint32_t len);\n```", "```cpp\nvoid main(void)\n{\n  struct netif netif;\n  struct ip_addr ipaddr, gateway, netmask;\n  IP4_ADDR(&ipaddr, 192,168,0,2);\n  IP4_ADDR(&gw, 192,168,0,1);\n  IP4_ADDR(&netmask, 255,255,255,0);\n  lwip_init();\n  netif_add(&netif, &ipaddr, &netmask, &gw, NULL,\n  driver_netdev_create, ethernet_input);\n  netif_set_default(&netif);\n```", "```cpp\n  netif_set_up(&netif);\n```", "```cpp\n  application_init_sockets();\n```", "```cpp\n  while (1) {\n   /* poll netif, pass packet to lwIP */\n   driver_netdev_poll(&netif);\n   sys_check_timeouts();\n   WFI();\n  }\n}\n```", "```cpp\nvoid main(void)\n{\n  struct driver_device dev;\n  struct ip4 addr, netmask, gw, zero, any;\n  pico_string_to_ipv4(\"192.168.0.2\", &ipaddr.addr);\n  pico_string_to_ipv4(\"255.255.255.0\", &netmask.addr);\n  pico_string_to_ipv4(\"192.168.0.1\", &gw.addr);\n  any.addr = 0;\n  pico_stack_init();\n  driver_netdev_create(&dev);\n```", "```cpp\n  pico_ipv4_link_add(&dev, ipaddr, netmask);\n```", "```cpp\n  pico_ipv4_route_add(any, any, gw, 1, NULL);\n```", "```cpp\n  application_init_sockets();\n```", "```cpp\n  while (1)\n  pico_stack_tick();\n  WFI();\n}\n```", "```cpp\nstruct tcp_pcb *tcp_new(void);\n```", "```cpp\nerr_t tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr,\n    u16_t port);\nerr_t tcp_listen(struct tcp_pcb *pcb);\n```", "```cpp\nvoid tcp_accept(struct tcp_pcb *pcb,\n    err_t (* accept)(void *arg, struct tcp_pcb *newpcb,\n    err_t err)\n);\n```", "```cpp\nvoid tcp_recv(struct tcp_pcb *pcb,\n    err_t (* recv)(void *arg, struct tcp_pcb *tpcb,\n    struct pbuf *p, err_t err)\n);\n```", "```cpp\nstruct pico_socket *pico_socket_open(uint16_t net,\n    uint16_t proto,\nvoid (*wakeup)(uint16_t ev, \n    struct pico_socket *s));\n```", "```cpp\nint pico_socket_bind(struct pico_socket *s,\n    void *local_addr,\n    uint16_t *port);\nint pico_socket_listen(struct pico_socket *s, int backlog);\n```", "```cpp\nstruct pico_socket *pico_socket_accept(\n    struct pico_socket *s,\n    void *orig,\n    uint16_t *local_port);\n```", "```cpp\npico_olsr_add(struct pico_device *dev);\n```", "```cpp\npico_aodv_add(struct pico_devices *dev);\n```", "```cpp\nwolfSSL_Init();\nwolfSSL_CTX *ctx;\nctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method());\nwolfSSL_SetIORecv(ctx, wolfssl_recv_cb);\nwolfSSL_SetIOSend(ctx, wolfssl_send_cb);\n```", "```cpp\nint wolfssl_send_cb(WOLFSSL* ssl, char *buf, int sz, void *sk_ctx)\n{\n tcp_ip_socket *sk = (tcp_ip_socket *)sk_ctx;\n int ret = tcp_socket_write(sk, buf, sz);\n if (ret > 0)\n   return ret;\n else\n   return WOLFSSL_CBIO_ERR_WANT_WRITE;\n}\n```", "```cpp\nint wolfssl_recv_cb(WOLFSSL *ssl, char *buf, int sz, void *sk_ctx)\n{\n  tcp_ip_socket *sk = (tcp_ip_socket *)sk_ctx;\n  int ret = tcp_socket_read(sk, buf, sz);\n  if (ret > 0)\n    return ret;\n  else\n    return WOLFSSL_CBIO_ERR_WANT_READ;\n}\n```", "```cpp\nwolfSSL_CTX_use_certificate_buffer(ctx, certificate, len, SSL_FILETYPE_ASN1);\nwolfSSL_CTX_use_PrivateKey_buffer(ctx, key, len,SSL_FILETYPE_ASN1 );\n```", "```cpp\ntcp_ip_socket new_sk = accept(listen_sk, origin);\nWOLFSSL ssl = wolfSSL_new(ctx);\nif (new_sk) {\n  wolfSSL_SetIOReadCtx(ssl, new_sk);\n  wolfSSL_SetIOWriteCtx(ssl, new_sk);\n```", "```cpp\n int ret = wolfSSL_accept(ssl);\n```", "```cpp\n  wolfSSL_set_using_nonblock(ssl, 1);\n```"]