<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer043">
<h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor454"/>10</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor455"/>Implementing Association, Aggregation, and Composition</h1>
<p>This chapter will continue advancing our knowledge of object-oriented programming in C++. We will augment our understanding of object relationships by exploring the object-oriented concepts of association, aggregation, and composition. None of these OO concepts have direct language support in C++; we will instead learn multiple programming techniques to implement these ideas. We will also understand which implementation techniques are preferred for various concepts, as well as the advantages and pitfalls of various practices. </p>
<p>Association, aggregation, and composition occur copiously in OO designs. It is crucial to understand how to implement these important object relationships. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the OO concepts of aggregation and composition, and various implementations</li>
<li>Understanding the OO concept of association and its implementation, including the importance of backlink maintenance and the utility of reference counting</li>
</ul>
<p>By the end of this chapter, you will understand the OO concepts of association, aggregation, and composition, and how to implement these relationships in C++. You will also understand many housekeeping approaches necessary to keep these relationships up to date, such as reference counting and backlink maintenance. Though the concepts are relatively straightforward, you will see why there is a substantial amount of bookkeeping required to maintain accuracy for these types of object relationships. </p>
<p>Let’s broaden our understanding of C++ as an OOP language by exploring these core object relationships.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor456"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter10</strong> in a file named <strong class="source-inline">Chp10-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3clgvGe">https://bit.ly/3clgvGe</a>.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/>Understanding aggregation and composition</h1>
<p>The object-oriented concept of aggregation<a id="_idIndexMarker726"/> arises in many OO designs. It comes up as frequently as inheritance does to specify object relationships. <strong class="bold">Aggregation</strong> is used to specify Has-A, whole-part, and in some cases, containment relationships. A class may contain aggregates of other objects. Aggregation can be broken into two categories – <em class="italic">composition</em> as well as a less strict and <em class="italic">generalized</em> form of aggregation. </p>
<p>Both <strong class="bold">generalized aggregation</strong> and <strong class="bold">composition</strong> imply a Has-A or whole-part relationship. However, the<a id="_idIndexMarker727"/> two differ in the existence requirements between the<a id="_idIndexMarker728"/> two related objects. With generalized aggregation, the objects can exist independently from one another, yet with composition, the objects cannot exist without one another.</p>
<p>Let’s take a look at each variety of aggregation, starting with compositio<a id="_idTextAnchor459"/>n.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor460"/>Defining and implementing composition</h2>
<p><strong class="bold">Composition</strong> is the <a id="_idIndexMarker729"/>most specialized form of aggregation and is often what most OO designers and programmers think of when they consider aggregation. Composition implies containment, and is most often synonymous with a whole-part relationship – that is, the whole entity is composed of one or more parts. The whole <em class="italic">contains</em> the parts. The Has-A relationship will also apply to composition.</p>
<p>The outer object, or <em class="italic">whole</em>, can be made up of <em class="italic">parts</em>. With composition, parts do not exist without the whole. Implementation is usually an embedded object – that is, a data member of the contained object type. On rare occasions, the outer object will contain a pointer or reference to the contained object type; however, when this occurs, the outer object will be responsible for the creation and destruction of the inner object. The contained object has no<a id="_idIndexMarker730"/> purpose without its outer layer. Likewise, the outer layer is not <em class="italic">ideally</em> complete without its inner, contained pieces.</p>
<p>Let’s take a<a id="_idIndexMarker731"/> look at a composition as typically implemented. The example will illustrate containment – a <strong class="source-inline">Student</strong> <em class="italic">Has-A(n)</em> <strong class="source-inline">Id</strong>. More so, we will imply that an <strong class="source-inline">Id</strong> is a necessary part of a <strong class="source-inline">Student</strong> and will not exist without a <strong class="source-inline">Student</strong>. <strong class="source-inline">Id</strong> objects on their own serve no purpose. <strong class="source-inline">Id</strong> objects simply do not need to exist if they are not a part of a primary object that gives them purpose. Likewise, you might argue that a <strong class="source-inline">Student</strong> is incomplete without an <strong class="source-inline">Id</strong>, though this is a bit subjective! We will implement the <em class="italic">part</em> using an embedded object within the <em class="italic">whole</em>. </p>
<p>The composition example will be broken into many segments. Though only portions of the example are shown, the full program can be found in the following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
class Id final  <strong class="bold">// the cont<a id="_idTextAnchor461"/>ained 'part'</strong>
{        // this class is not intended to be extended 
private:
    string idNumber;
public:
    Id() = default;
    Id(const string &amp;id): idNumber(id) { }
    // We get default copy constructor, destructor
    // without including without including prototype
    // Id(const Id &amp;id) = default;
    // ~Id() = default;
    const string &amp;GetId() const { return idNumber; }
};</pre>
<p>In the <a id="_idIndexMarker732"/>previous code fragment, we have defined an <strong class="source-inline">Id</strong> class. An <strong class="source-inline">Id</strong> will be a class that can be contained by other classes needing a fully functional <strong class="source-inline">Id</strong> capability. The <strong class="source-inline">Id</strong> will become a <em class="italic">part</em> of any <em class="italic">whole</em> object that may choose to contain it. </p>
<p>Let’s move onward to build a set of classes that will ultimately contain this <strong class="source-inline">Id</strong>. We will start with a class we are familiar with, <strong class="source-inline">Person</strong>:</p>
<pre class="source-code">
class Person
{
private:
    string firstName;
    string lastName;
    char middleInitial = '\0';   // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
protected:
    void ModifyTitle(const string &amp;);
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    // We get default copy constructor w/o prototype 
    // Person(const Person &amp;) = default;  // copy ctor.
    // But, we need prototype destructor to add 'virtual' 
    virtual ~Person() = default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    // virtual functions
    virtual void Print() const;   
    virtual void IsA() const;
    virtual void Greeting(const string &amp;) const;
};
//  Assume the member functions for Person exist here
//  (they are the same as in previous chapters)</pre>
<p>In the <a id="_idIndexMarker733"/>previous segment of code, we have defined the <strong class="source-inline">Person</strong> class, as we are accustomed to describing it. To abbreviate this example, let us assume that the accompanying member functions exist as prototyped in the aforementioned class definition. You can reference these member functions in the earlier provided GitHub link for online<a id="_idTextAnchor462"/> code. </p>
<p>Now, let’s define our <strong class="source-inline">Student</strong> class. Though it will contain elements that we are accustomed to seeing, <strong class="source-inline">Student</strong> will also contain an <strong class="source-inline">Id</strong> as an embedded object:</p>
<pre class="source-code">
class Student: public Person  <strong class="bold">// 'whole' object</strong>
{
private:
    float gpa = 0.0;    // in-class initialization
    string currentCourse;
    static int numStudents;  
    <strong class="bold">Id studentId;  // is composed of a 'part'</strong>
public:    
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    // various member functions (many are inline)
    void EarnPhD() { ModifyTitle("Dr."); } 
    float GetGpa() const { return gpa; }         
    const string &amp;GetCurrentCourse() const
        { return currentCourse; }
    void SetCurrentCourse(const str<a id="_idTextAnchor463"/>ing &amp;); // proto. only
    void Print() const override;
    void IsA() const override 
        { cout &lt;&lt; "Student" &lt;&lt; endl; }
    static int GetNumberStudents() { return numStud<a id="_idTextAnchor464"/>ents; }
    // Access function for embedded Id object
    <strong class="bold">const string &amp;GetStudentId() const;</strong>   // prototype only
};
int Student::numStudents = 0;  // static data member
inline void Student::SetCurrentCourse(const string &amp;c)
{
    currentCourse = c;
}</pre>
<p>In the <a id="_idIndexMarker734"/>preceding <strong class="source-inline">Student</strong> class, we routinely notice that <strong class="source-inline">Student</strong> is derived from <strong class="source-inline">Person</strong>. As we already know, this means that a <strong class="source-inline">Student</strong> instance will include the memory layout of a <strong class="source-inline">Person</strong>, as a <strong class="source-inline">Person</strong> subobject. </p>
<p>However, notice the data member, <strong class="source-inline">Id studentId;</strong>, in the <strong class="source-inline">Student</strong> class definition. Here, <strong class="source-inline">studentId</strong> is of type <strong class="source-inline">Id</strong>. It is not a pointer, nor is it a reference to an <strong class="source-inline">Id</strong>. Data member <strong class="source-inline">studentId</strong> is an embedded (that is, an aggregate or member) object. This means that when a <strong class="source-inline">Student</strong> class is instantiated, not only will the memory from inherited classes be included but also the memory for any embedded objects. We will need to provide a means to initialize the embedded object, <strong class="source-inline">studentId</strong>. Note, we have seen member objects before, such as data members of type <strong class="source-inline">string</strong>; that is, data members that are of another class type.</p>
<p>Let’s move forward with the <strong class="source-inline">Student</strong> member functions to understand how we may initialize, manipulate, and access the embedded object:</p>
<pre class="source-code">
Student::Student(): <strong class="bold">studentId(to_string(numStudents + 100)</strong> 
                                         <strong class="bold">+ "Id")</strong> 
{
    numStudents++;   // increment static counter
}
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;t, float avg, 
                 const string &amp;course, const string &amp;id)<strong class="bold">:</strong>  
                 Person(fn, ln, mi, t), gpa(avg),
                 currentCourse(course), <strong class="bold">studentId(id)</strong>
{
    numStudents++;
}
Student::Student(const Student &amp;s)<strong class="bold">:</strong> Person(s),
                gpa(s.gpa), currentCourse(s.currentCourse),
     <a id="_idTextAnchor465"/>           <strong class="bold">studentId(s.studentId)</strong>
{
    numStudents++;
}
Student::~Student()   // destructor definition
{
    numStudents--;    // decrement static counter
    <strong class="bold">// embedded object studentId will also be destructed</strong>
}
void Student::Print() const
{
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with <a id="_idTextAnchor466"/>id: " &lt;&lt; <strong class="bold">studentId.Ge<a id="_idTextAnchor467"/>tId()</strong> &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}    
const string &amp;GetStudentId() const 
{   
    return <strong class="bold">studentId.GetId();</strong>   
} </pre>
<p>In the previously listed member functions of <strong class="source-inline">Student</strong>, let’s begin with our constructors. Notice in the default constructor, we utilize the member initialization list (<strong class="source-inline">:</strong>) to specify <strong class="source-inline">studentId(to_string(numStudents + 100) + "Id")</strong>. Because <strong class="source-inline">studentId</strong> is a member object, we have the opportunity to select (via the member initialization list) which constructor should be used for its initialization. Here, we merely select the one with the <strong class="source-inline">Id(const string &amp;)</strong> signature. In the absence of a specific value to use to initialize <strong class="source-inline">Id</strong>, we manufacture a string value to serve as the needed ID.</p>
<p>Similarly, in <a id="_idIndexMarker735"/>the alternate constructor for <strong class="source-inline">Student</strong>, we use the member initialization list to specify <strong class="source-inline">studentId(id)</strong>, which will also select the <strong class="source-inline">Id(const string &amp;)</strong> constructor, passing the parameter <strong class="source-inline">id</strong> to this constructor. </p>
<p>The copy constructor for <strong class="source-inline">Student</strong> additionally specifies how to initialize the <strong class="source-inline">studentId</strong> member object with the <strong class="source-inline">studentId(s.studentId)</strong> specification in the member initialization list. Here, we simply call the copy constructor for <strong class="source-inline">Id</strong>.</p>
<p>In our destructor for <strong class="source-inline">Student</strong>, we do not need to deallocate <strong class="source-inline">studentId</strong>. As this data member is an embedded (aggregate) object, its memory will go away when the memory for the outer object goes away. Of course, because <strong class="source-inline">studentId</strong> is an object itself, its own destructor will first be called before its memory is released. Under the hood, the compiler will (covertly) patch in a call to the <strong class="source-inline">Id</strong> destructor for <strong class="source-inline">studentId</strong> as the last line of code in the <strong class="source-inline">Student</strong> destructor. Actually, this will be the penultimate (next to last) implicit line in the destructor – the last line that will be covertly patched in will be a call to the <strong class="source-inline">Person</strong> destructor (to continue the destruction sequence).</p>
<p>Lastly, in the previous segment of code, let’s notice the call to <strong class="source-inline">studentId.GetId()</strong>, which occurs in both <strong class="source-inline">Student::Print()</strong> and <strong class="source-inline">Student::GetStudentId()</strong>. Here, the embedded object <strong class="source-inline">studentId</strong> calls its own public function <strong class="source-inline">Id::GetId()</strong> to retrieve its private data member in the scope of the <strong class="source-inline">Student</strong> class. Because <strong class="source-inline">studentId</strong> is private in <strong class="source-inline">Student</strong>, this embedded object may only be accessed within the scope of <strong class="source-inline">Student</strong> (that is, member functions of <strong class="source-inline">Student</strong>). However, the addition of <strong class="source-inline">Student::GetStudentId()</strong> provides a public wrapper for <strong class="source-inline">Student</strong> instances in other scopes to retrieve this information.</p>
<p>Finally, let’s take<a id="_idIndexMarker736"/> a look at our <strong class="source-inline">main()</strong> function:</p>
<pre class="source-code">
int main()
{
    Student s1("Cyrus", "Bond", 'I', "Mr.", 3.65, "C++",
               "6996CU");
    Student s2("Anne", "Brennan", 'M', "Ms.", 3.95, "C++",
               "909EU");
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " has id #: " &lt;&lt; <strong class="bold">s1.GetStudentId()</strong> &lt;&lt; endl;
    cout &lt;&lt; s2.GetFirstName() &lt;&lt; " " &lt;&lt; s2.GetLastName();
    cout &lt;&lt; " has id #: " &lt;&lt; <strong class="bold">s2.GetStudentId()</strong> &lt;&lt; endl;
    return 0;
}</pre>
<p>In the aforementioned <strong class="source-inline">main()</strong> function, we instantiate two <strong class="source-inline">Student</strong> instances: <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>. When the memory is created (in this case, on the stack) for each <strong class="source-inline">Student</strong>, memory for any inherited classes will also be included as subobjects. Additionally, memory for any embedded objects, such as <strong class="source-inline">Id</strong>, will also be laid out as a subobject within <strong class="source-inline">Student</strong>. The memory for the contained object, or <em class="italic">part</em>, will be allocated along with the allocation for the outer object, or <em class="italic">whole</em>.</p>
<p>Next, let’s notice the access to the contained piece, the embedded <strong class="source-inline">Id</strong> object. We start with a call to <strong class="source-inline">s1.GetStudentId()</strong>; <strong class="source-inline">s1</strong> accesses a <strong class="source-inline">Student</strong> member function, <strong class="source-inline">GetStudentId()</strong>. That student member function will utilize the member object of <strong class="source-inline">studentId</strong> to call <strong class="source-inline">Id::GetId()</strong> on this inner object of type <strong class="source-inline">Id</strong>. The member function <strong class="source-inline">Student::GetStudentId()</strong> can implement this desired public access by simply returning the value that <strong class="source-inline">Id::GetId()</strong> returns on the embedd<a id="_idTextAnchor468"/>ed object.</p>
<p>Let’s look at the output for the aforementioned program: </p>
<p class="source-code">Cyrus Bond has id #: 6996CU</p>
<p class="source-code">Anne Brennan has id<a id="_idTextAnchor469"/> #: 909EU </p>
<p>This example <a id="_idIndexMarker737"/>details composition with its typical implementation, an embedded object. Let’s now take a look at a much less used, alternate implementation – that of inheritance.</p>
<h3>Considering an alternate implementation for composition</h3>
<p>It is useful to<a id="_idIndexMarker738"/> understand that composition can alternatively be implemented using inheritance, however, this is extremely controversial. Remember, inheritance is most often used to implement <em class="italic">Is-A</em> and not <em class="italic">Has-A</em> relationships. We briefly described using inheritance to implement Has-A relationships in <a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em>.</p>
<p>To recap, you would simply inherit from the <em class="italic">part</em>, rather than embed the part as a data member. When doing so, you no longer need to provide <em class="italic">wrapper</em> functions to the <em class="italic">part</em>, such as we saw in the previous program, with the <strong class="source-inline">Student::GetStudentId()</strong> method calling <strong class="source-inline">studentId.GetId()</strong> to provide access to its embedded part. The wrapper function was necessary with the embedded object example, as the part (<strong class="source-inline">Id</strong>) was private in the whole (<strong class="source-inline">Student</strong>). Programmers could not have accessed the private <strong class="source-inline">studentId</strong> data member of <strong class="source-inline">Student</strong> outside the scope of <strong class="source-inline">Student</strong>. Of course, member functions of <strong class="source-inline">Student</strong> (such as <strong class="source-inline">GetStudentId()</strong>) can access their own class’ private data members and in doing so, can implement the <strong class="source-inline">Student::GetStudentId()</strong> wrapper function to provide such (safe) access. </p>
<p>Had inheritance been used, the public interface of <strong class="source-inline">Id::GetId()</strong> would have been simply inherited as a public interface in <strong class="source-inline">Student</strong>, providing simple access without the need to first go through the embedded object explicitly. </p>
<p>Nonetheless, though inheriting a <em class="italic">part</em> is simple in some ways, it vastly compounds multiple inheritance. We know multiple inheritance can provide many potential complications. Also, using inheritance, the <em class="italic">whole</em> can only contain one of each <em class="italic">part</em> – not multiples of a <em class="italic">part</em>. </p>
<p>Additionally, implementing <a id="_idIndexMarker739"/>a whole-part relationship with inheritance may be confusing when you compare the implementation to the OO design. Remember, inheritance usually means <em class="italic">Is-A</em> and not <em class="italic">Has-A</em>. For these reasons, the most typical and appreciated implementation of an aggregate is through an embedded object. </p>
<p>Next, let’s move onward by looking at a more general form of aggregation.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor470"/>Defining and implementing a generalized aggregation</h2>
<p>We have looked at the most commonly used form of aggregation in OO designs, that of composition. Most notably, with composition, we have seen that the part does not have a reason to exist without the whole. Nonetheless, a more generalized (but less common) form of aggregation exists and is sometimes specified in OO designs. We will now consider this less common form of aggregation.</p>
<p>In a <strong class="bold">generalized aggregation</strong>, a <em class="italic">part</em> may <a id="_idIndexMarker740"/>exist without the <em class="italic">whole</em>. A part will be created separately and then attached to the whole at a later point in time. When the <em class="italic">whole</em> goes away, a <em class="italic">part</em> may then remain to be salvaged for use with another outer or <em class="italic">whole</em> object. </p>
<p>In a generalized aggregation, the Has-A relationship certainly applies, as does the whole-part designation. The difference is that the <em class="italic">whole</em> object will not create nor destroy a <em class="italic">part</em> subobject. Consider the straightforward example that a <strong class="source-inline">Car</strong> <em class="italic">Has-A(n)</em> <strong class="source-inline">Engine</strong>. A <strong class="source-inline">Car</strong> object also <em class="italic">Has-A</em> set of four <strong class="source-inline">Tire</strong> objects. The <strong class="source-inline">Engine</strong> or <strong class="source-inline">Tire</strong> objects can be manufactured separately and then passed to the constructor of the <strong class="source-inline">Car</strong> to provide these parts to the whole. Yet should an <strong class="source-inline">Engine</strong> be destroyed, a new <strong class="source-inline">Engine</strong> can easily be swapped out (using a member function), without requiring the entire <strong class="source-inline">Car</strong> to be destroyed and then reconstructed. </p>
<p>A generalized aggregation is equivalent to a Has-A relationship, yet we think of this with more flexibility and permanence of the individual parts as we did with composition. We consider this relationship as an aggregation simply because we wish to equate the objects with a Has-A meaning. The Has-A relationship in the <strong class="source-inline">Car</strong>, <strong class="source-inline">Engine</strong>, and <strong class="source-inline">Tire</strong> example is strong; the <strong class="source-inline">Engine</strong> and <strong class="source-inline">Tire</strong>s are necessary parts, required to make the whole <strong class="source-inline">Car</strong>.</p>
<p>Here, implementation typically is with the <em class="italic">whole</em> containing a pointer (or set of pointers) to the <em class="italic">part(s)</em>. It is important to note that the parts will be passed into a constructor (or another member function) of the outer object to establish the relationship. The<a id="_idIndexMarker741"/> critical marker is that the whole will not create (nor destroy) the parts, and the parts will never destroy the whole.</p>
<p>Incidentally, the longevity of the individual pieces (and the basic implementation) of a generalized aggregation will be similar to our next topic – association. Let’s move forward to our next section to understand the similarities, as well as the OO conceptual differences (sometimes subtle) between generalized aggregation a<a id="_idTextAnchor471"/><a id="_idTextAnchor472"/>nd association.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor473"/>Understanding association</h1>
<p>An <strong class="bold">association</strong> models a<a id="_idIndexMarker742"/> relationship that exists between otherwise unrelated class types. An association can provide ways for objects to interact to fulfill these relationships. Associations are not used for Has-A relationships, however, in some cases, there are shades of gray as to whether we’re describing a bonafide Has-A relationship, or whether we are merely using the phrase Has-A because it sounds appropriate linguistically. </p>
<p>Multiplicity<a id="_idIndexMarker743"/> for associations exists: one-to-one, one-to-many, many-to-one, or many-to-many. For example, a <strong class="source-inline">Student</strong> may be associated with a single <strong class="source-inline">University</strong>, and that <strong class="source-inline">University</strong> may be associated with many <strong class="source-inline">Student</strong> instances; this is a one-to-many association.</p>
<p>Associated objects have an independent existence. That is, two or more objects may be instantiated and exist independently for a portion of the application. At some point, one object may wish to assert a dependency or relationship with the other object. Later in the application, the associated objects may part ways and continue on their own unrelated paths.</p>
<p>For example, consider <a id="_idIndexMarker744"/>the relationship between a <strong class="source-inline">Course</strong> and an <strong class="source-inline">Instructor</strong>. A <strong class="source-inline">Course</strong> is associated with an <strong class="source-inline">Instructor</strong>. A <strong class="source-inline">Course</strong> requires an <strong class="source-inline">Instructor</strong>; an <strong class="source-inline">Instructor</strong> is integral to the <strong class="source-inline">Course</strong>. An <strong class="source-inline">Instructor</strong> may be associated with many <strong class="source-inline">Course</strong>(s). Yet each part exists independently – one will not create nor destroy the other. Instructors may also exist independently without courses; perhaps an instructor is taking time to write a book, is taking a sabbatical, or is a professor conducting research.</p>
<p>In this example, the<a id="_idIndexMarker745"/> association is very similar to a generalized aggregation. In both cases, the related objects also exist independently. In this case, whether one says that <strong class="source-inline">Course</strong> Has-A(n) <strong class="source-inline">Instructor</strong> or that a <strong class="source-inline">Course</strong> has a dependency on an <strong class="source-inline">Instructor</strong>, can be a shade of gray. You may ask yourself – is it just spoken language that makes me choose the wording of Has-A? Do I instead mean that there is a necessary link between the two? Perhaps the relationship is an association, and its descriptive adornment (to further describe the nature of the association) is <em class="italic">teaches</em>. You may have arguments supporting either choice. For this reason, generalized aggregations can be considered specialized types of associations; we will see that their implementations are the same using independently existing objects. Nonetheless, we will distinguish a typical association as being a relationship between objects that decisively do not support a true Has-A relationship.</p>
<p>For example, consider the relationship between <strong class="source-inline">University</strong> and <strong class="source-inline">Instructor</strong>. Rather than thinking of this as a Has-A relationship, we may instead consider the relationship between the two as that of association; we can think of the adornment describing this relationship as <em class="italic">employs</em>. Likewise, <strong class="source-inline">University</strong> ascertains a relationship with many <strong class="source-inline">Student</strong> objects. The association here may be described by the adornment <em class="italic">educates</em>. The distinction can be made that <strong class="source-inline">University</strong> is made up of <strong class="source-inline">Department</strong> objects, <strong class="source-inline">Building</strong> objects, and components of this nature to support any of its Has-A relationships through containment, yet its relationships with <strong class="source-inline">Instructor</strong> objects, <strong class="source-inline">Student</strong> objects, and so on are made using associations.</p>
<p>Now that we have distinguished typical associations from generalized aggregations, let’s take a look at how we can implement associations and some of the complexities involved.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor474"/>Implementing association</h2>
<p>Typically, an association <a id="_idIndexMarker746"/>between two or more objects is implemented using pointers or sets of pointers. The <em class="italic">one</em> side is implemented using a pointer to the associated object, whereas the <em class="italic">many</em> side of the relationship is implemented as a set of pointers to the associated objects. A set of pointers may be an array of pointers, a linked list of pointers, or truly any collection of pointers. Each type of collection will have its own set of advantages and drawbacks. For example, arrays of pointers are easy to use, have direct access to specific members, yet have a fixed number of items. Linked lists of pointers can accommodate any quantity of items, yet accessing a specific element requires traversing past others to find the desired item.</p>
<p>Occasionally, a reference may be used to implement the <em class="italic">one</em> side of an association. Recall that a reference must be initialized and cannot at a later date be reset to reference another object. Using a reference to model an association implies that one instance will be associated with a precise other instance for the duration of the primary object’s existence. This is extremely restrictive, so references are used very infrequently to implement associations. </p>
<p>Regardless of the implementation, when the primary object goes away, it will not interfere with (that is, delete) the associated object. </p>
<p>Let’s see a<a id="_idIndexMarker747"/> typical example illustrating the preferred implementation of a one-to-many association, utilizing a pointer on the <em class="italic">one</em> side, and a set of pointers on the <em class="italic">many</em> side. In this example, a <strong class="source-inline">University</strong> will be associated with many <strong class="source-inline">Student</strong> instances. And, for simplicity, a <strong class="source-inline">Student</strong> will be associated with a single <strong class="source-inline">University</strong>. </p>
<p>To save space, some portions of this program that are the same as in our last example will not be shown; however, the program in its entirety can be found in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Ch<span id="_idTextAnchor475"/>apter10/Chp10-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
// classes Id and Person are omitted here to save space.
// They will be as shown in previous example: Chp10-Ex1.cpp
<strong class="bold">class Student; // forward declaration</strong>
class University
{
private:
    string name;
    static constexpr int MAX = 25; // max students allowed
    // Notice: each studentBody element is set to a nullptr 
    // using in-class initialization 
    <strong class="bold">Student *studentBody[MAX] = { };</strong> // Association to
                                     // many students
    int currentNumStudents = 0;  // in-class initialization
public:
    University();
    University(const string &amp;);
    University(const University &amp;) = delete; // no copies
    ~University();
    void EnrollStudent(<strong class="bold">Student *</strong>);
    const string &amp;GetName() const { return name; }
    void PrintStudents() const;
};</pre>
<p>In the preceding<a id="_idIndexMarker748"/> segment, let’s first notice the forward declaration of <strong class="source-inline">class Student;</strong>. This declaration will allow our code to reference the <strong class="source-inline">Student</strong> type prior to the <strong class="source-inline">Student</strong> class definition. In the <strong class="source-inline">University</strong> class definition, we see that there is an array of pointers to <strong class="source-inline">Student</strong>. We also see that the <strong class="source-inline">EnrollStudent()</strong> method takes a <strong class="source-inline">Student *</strong> as an argument. The forward declaration enables such usage of <strong class="source-inline">Student</strong> prior to its definition.</p>
<p>We also <a id="_idIndexMarker749"/>notice that the <strong class="source-inline">University</strong> has a simple interface with constructors, a destructor, and a few member functions.</p>
<p>Next, let’s take a look at the <strong class="source-inline">University</strong> member function definitions:</p>
<pre class="source-code">
// Remember, currentNumStudents will be set w in-class init
// and name, as a string member object, will be init to 
// empty. And studentBody (array of ptrs) will also set w
// in-class initialization.
University::University()
{
    // in-lieu of in-class init, we could alternatively set
    // studentBody[i] to nullptr iteratively in a loop:
    // (the student body will start out empty)   
    // for (int i = 0; i &lt; MAX; i++) 
    //    <strong class="bold">studentBody[i] = nullptr;</strong> 
}
University::University(const string &amp;n): name(n)
{   
    // see default constructor for alt init of studentBody
}
University::~University()
{
    <strong class="bold">// The University will not delete the students</strong>
    for (int i = 0; i &lt; MAX; i++)   // only null out 
       <strong class="bold">studentBody[i] = nullptr;</strong>    // their link
}                      
void University::EnrollStudent(Student *s)
{
    // set an open slot in the studentBody to point to the
    // Student passed in as an input parameter
    <strong class="bold">studentBody[curren<a id="_idTextAnchor476"/>tNumStudents++] = s;</strong>
}
void University::PrintStudents()const
{
    cout &lt;&lt; name &lt;&lt; " has the following students:" &lt;&lt; endl;
    // Simple loop to process set of students, however we
    // will soon see safer, more modern ways to iterate 
    // over partial arrays w/o writing explicit 'for' loops
    for (int i = 0; i &lt; currentNumStudents; i++)
    {
       cout &lt;&lt; "\t" &lt;&lt; <strong class="bold">studentBody[i]-&gt;GetFirstName()</strong>;
       cout &lt;&lt; " " &lt;&lt; <strong class="bold">studentBody[i]-&gt;GetLastName()</strong>;
       cout &lt;&lt; endl;
    }
}</pre>
<p>Taking a <a id="_idIndexMarker750"/>closer look at the aforementioned <strong class="source-inline">University</strong> methods, we can see that in both constructors for <strong class="source-inline">University</strong>, we could alternatively null out the pointers to the elements comprising our <strong class="source-inline">studentBody</strong> using <strong class="source-inline">nullptr</strong> (versus our choice of using in-class initialization, which similarly initializes each element). Likewise, in the destructor, we similarly null out our links to the associated <strong class="source-inline">Student</strong> instances. Shortly in this section, we will see that there will be some additional backlink maintenance required, but for now, the point is that we will not delete the associated <strong class="source-inline">Student</strong> objects.</p>
<p>Since <strong class="source-inline">University</strong> objects and <strong class="source-inline">Student</strong> objects will exist independently, neither will create nor destroy instances of the other type. </p>
<p>We also <a id="_idIndexMarker751"/>come across an interesting member function, <strong class="source-inline">EnrollStudent(Student *)</strong>. In this method, a pointer to a specific <strong class="source-inline">Student</strong> will be passed in as an input parameter. We merely index into our array of pointers to <strong class="source-inline">Student</strong> objects, namely <strong class="source-inline">studentBody</strong>, and set an unused array element point to the newly enrolled <strong class="source-inline">Student</strong>. We keep track of how many current <strong class="source-inline">Student</strong> objects exist using a <strong class="source-inline">currentNumStudents</strong> counter, which is incremented with a post increment after the pointer assignment to the array is made.</p>
<p>We also notice that the <strong class="source-inline">University</strong> class has a <strong class="source-inline">Print()</strong> method that prints the university’s name, followed by its current student body. It does so by simply accessing each associated <strong class="source-inline">Student</strong> object in <strong class="source-inline">studentBody</strong> and asking each <strong class="source-inline">Student</strong> instance to invoke the <strong class="source-inline">Student::GetFirstName()</strong> and <strong class="source-inline">Student::GetLastName()</strong> methods.</p>
<p>Next, let’s now take a look at our <strong class="source-inline">Student</strong> class definition, along with its inline functions. Recall that we’re assuming that the <strong class="source-inline">Person</strong> class is the same as seen earlier in this chapter:</p>
<pre class="source-code">
class Student: public Person  
{
private:
    // data members
    float gpa = 0.0;  // in-class initialization
    string currentCourse;
    static int numStudents;
    Id studentId;  // part, Student Has-A studentId
    <strong class="bold">University *univ = nullptr;</strong>  // Assoc. to Univ object
public:                          
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;, University *);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    void EarnPhD() { ModifyTitle("Dr."); }
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
        { return currentCourse; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    void IsA() const override 
        { cout &lt;&lt; "Student" &lt;&lt; endl; }
    static int GetNumberStudents() { return numStudents; }
    // Access functions for aggregate/associated objects
    const string &amp;GetStudentId() const 
        { return studentId.GetId(); }
    <strong class="bold">const string &amp;GetUniversity() const </strong>
        <strong class="bold">{ return univ-&gt;GetName(); }</strong>
};
int Student::numStudents = 0;  // def. of static data mbr.
inline void Student::SetCurrentCo<a id="_idTextAnchor477"/>urse(const string &amp;c)
{
    currentCourse = c;
}</pre>
<p>Here, in the <a id="_idIndexMarker752"/>previous code segment, we see the <strong class="source-inline">Student</strong> class definition. Notice that we have an association with a University with the pointer data member <strong class="source-inline">University *univ = nullptr;</strong> and that this member is initialized to <strong class="source-inline">nullptr</strong> using in-class initialization. </p>
<p>In the class definition for <strong class="source-inline">Student</strong>, we can also see there is a wrapper function to encapsulate access to the student’s university’s name with <strong class="source-inline">Student::GetUniversity()</strong>. Here, we allow the associated object, <strong class="source-inline">univ</strong>, to call its public method <strong class="source-inline">University::GetName()</strong> and return that value as the result of <strong class="source-inline">Student::GetUniversity()</strong>.</p>
<p>Now, let’s take a look at the non-inline member functions of <strong class="source-inline">Student</strong>:</p>
<pre class="source-code">
Student::Student(): studentId(to_string(numStudents + 100) 
                                        + "Id")
{
    // no current University association (set to nullptr 
    // with in-class initializat<a id="_idTextAnchor478"/>ion)
    numStudents++;
}
Student::Student(const string &amp;fn, const string &amp;ln, 
          char mi, const string &amp;t, float avg, 
          const string &amp;course, const string &amp;id, 
          University *univ): Person(fn, ln, mi, t), 
          gpa(avg), currentCourse(course), studentId(id)
{
    // establish link to University, then back link
    // note: forward link could also be set in the
    // member initialization list
    <strong class="bold">this-&gt;univ = univ;</strong>  // required use of ‹this›
    <strong class="bold">univ-&gt;EnrollStudent(this);</strong>  // another required 'this'
    numStudents++;
}
Student::Student(const Student &amp;s): Person(s), 
          gpa(s.gpa), currentCourse(s.currentCourse),
          studentId(s.studentId)
{
    // Notice, these three lines of code are the same as 
    // in the alternate constructor – we could instead make
    // a private helper method with this otherwise 
    // duplicative code as a means to simplify code 
    // maintenance. 
    <strong class="bold">this-&gt;univ = s.univ;    </strong>
    <strong class="bold">univ-&gt;EnrollStudent(this);</strong>
    numStudents++;
}
Student::~Student()  // destructor
{
    numStudents--;
    <strong class="bold">univ = nullptr;</strong>  // a Student does not delete its Univ
    // embedded object studentId will also be destructed
}
void Student::Print() const
{
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with id: " &lt;&lt; studentId.GetId() &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}</pre>
<p>In the preceding<a id="_idIndexMarker753"/> code segment, notice that the default <strong class="source-inline">Student</strong> constructor and the destructor both only null out their link to the <strong class="source-inline">University</strong> object (using <strong class="source-inline">nullptr</strong>). The default constructor has no way to set this link to an existing object, and should certainly not create a <strong class="source-inline">University</strong> instance to do so. Likewise, the <strong class="source-inline">Student</strong> destructor should not delete the <strong class="source-inline">University</strong> merely because the <strong class="source-inline">Student</strong> object’s life expectancy is complete.</p>
<p>The most interesting part of the preceding code happens in both the alternate constructor and copy constructor of <strong class="source-inline">Student</strong>. Let’s examine the alternate constructor. Here, we establish the link to the associated <strong class="source-inline">University</strong> as well as the backlink from the <strong class="source-inline">University</strong> back to the <strong class="source-inline">Student</strong>.</p>
<p>In the <strong class="source-inline">this-&gt;univ = univ;</strong> line of code, we are assigning the data member, <strong class="source-inline">univ</strong> (as pointed to by the <strong class="source-inline">this</strong> pointer) by setting it to point to where the input parameter, <strong class="source-inline">univ</strong>, points. Look closely at the previous class definition – the identifier for the <strong class="source-inline">University *</strong> is named <strong class="source-inline">univ</strong>. Additionally, the input parameter for the <strong class="source-inline">University *</strong> in the alternate constructor is named <strong class="source-inline">univ</strong>. We cannot simply assign <strong class="source-inline">univ = univ;</strong> in the body of this constructor (or in the member initialization list). The <strong class="source-inline">univ</strong> identifier that is in the most local scope is the input parameter, <strong class="source-inline">univ</strong>. Assigning <strong class="source-inline">univ = univ;</strong> would set this parameter to itself. Instead, we disambiguate the <strong class="source-inline">univ</strong> on the left-hand side of this assignment using the <strong class="source-inline">this</strong> pointer. The statement <strong class="source-inline">this-&gt;univ = univ;</strong> sets the data member <strong class="source-inline">univ</strong> to the input parameter <strong class="source-inline">univ</strong>. Could we merely have renamed the input parameter something different, such as <strong class="source-inline">u</strong>? Sure, but it is important to understand how to disambiguate an input parameter and data member with the same identifier when the need arises to do so.</p>
<p>Now, let’s examine the next line of code, <strong class="source-inline">univ-&gt;EnrollStudent(this);</strong>. Now that <strong class="source-inline">univ</strong> and <strong class="source-inline">this-&gt;univ</strong> point to the same object, it does not matter which is used to set the backlink. Here, <strong class="source-inline">univ</strong> calls <strong class="source-inline">EnrollStudent()</strong>, which is a public member function in the <strong class="source-inline">University</strong> class. No problem, <strong class="source-inline">univ</strong> is of type <strong class="source-inline">University</strong>. <strong class="source-inline">University::EnrollStudent(Student *)</strong> expects to be passed a pointer to a <strong class="source-inline">Student</strong> to complete the linkage on the <strong class="source-inline">University</strong> side. Luckily, the <strong class="source-inline">this</strong> pointer in our <strong class="source-inline">Student</strong> alternate constructor (the scope of the calling function) is a <strong class="source-inline">Student *</strong>. The <strong class="source-inline">this</strong> pointer (in the alternate constructor) is literally the <strong class="source-inline">Student *</strong> that we need to <a id="_idIndexMarker754"/>create the backlink. Here is another example where the explicit use of the <strong class="source-inline">this</strong> pointer is required to complete the task at hand.</p>
<p>Let’s move forward to our <strong class="source-inline">main()</strong> function:</p>
<pre class="source-code">
int main()
{
    University u1("The George Washington University");
    Student s1("Gabby", "Doone", 'A', "Miss", 3.85, "C++",
               "4225GWU", &amp;u1);
    Student s2("Giselle", "LeBrun", 'A', "Ms.", 3.45,
               "C++", "1227GWU", &amp;u1);
    Student s3("Eve", "Kendall", 'B', "Ms.", 3.71, "C++",
               "5542GWU", &amp;u1);
    cout &lt;&lt; s1.GetFirstName() &lt;<a id="_idTextAnchor479"/>&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s1.GetUniversity()</strong> &lt;&lt; endl;
    cout &lt;&lt; s2.GetFirstName() &lt;<a id="_idTextAnchor480"/>&lt; " " &lt;&lt; s2.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s2.GetUniversity()</strong> &lt;&lt; endl;
    cout &lt;&lt; s3.GetFirstName() &lt;&lt; " " &lt;&lt; s3.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s3.GetUniversity()</strong> &lt;&lt; endl;
    <strong class="bold">u1.PrintStudents();</strong>
    return 0;
}</pre>
<p>Finally, in the previous code fragment in our <strong class="source-inline">main()</strong> function, we can create several independently existing objects, create an association between them, and then view that relationship in action.</p>
<p>First, we<a id="_idIndexMarker755"/> instantiate a <strong class="source-inline">University</strong>, namely <strong class="source-inline">u1</strong>. Next, we instantiate three <strong class="source-inline">Student</strong> objects, <strong class="source-inline">s1</strong>, <strong class="source-inline">s2</strong>, and <strong class="source-inline">s3</strong>, and associate each to <strong class="source-inline">University u1</strong>. Note that this association can be set when we instantiate a <strong class="source-inline">Student</strong>, or later on, for example, if the <strong class="source-inline">Student</strong> class supported a <strong class="source-inline">SelectUniveristy(University *)</strong> interface to do so.</p>
<p>We then print out each <strong class="source-inline">Student</strong>, along with the name of the <strong class="source-inline">University</strong> each <strong class="source-inline">Student</strong> attends. Then, we print out the student body for our <strong class="source-inline">University</strong>, <strong class="source-inline">u1</strong>. We notice that the link built between the associated objects is complete in both directions. </p>
<p>Let’s look at the output for the aforementioned program: </p>
<p class="source-code">Gabby Doone attends The George Washington University</p>
<p class="source-code">Giselle LeBrun attends The George Washington University</p>
<p class="source-code">Eve Kendall attends The George Washington University</p>
<p class="source-code">The George Washington University has the following students:</p>
<p class="source-code">        Gabby Doone</p>
<p class="source-code">        Giselle LeBrun</p>
<p class="source-code">        Eve Kendall</p>
<p>We’ve seen how easily associations can be set up and utilized between related objects. However, a <a id="_idIndexMarker756"/>lot of housekeeping will arise from implementing associations. Let’s move forward to understanding the necessary and related issues of reference counting and backlink maintenance, which will help with these housekeeping endeavors.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor481"/>Utilizing backlink maintenance and reference counting</h2>
<p>In the previous <a id="_idIndexMarker757"/>subsection, we have seen how to implement associations using pointers. We’ve seen how to link an object with a pointer to an object in an associated instance. And we’ve seen how to complete the circular, two-sided relationship by establishing a backlink.</p>
<p>However, as is typical for associated objects, the relationships are fluid and change over time. For example, the given <strong class="source-inline">Student</strong> body will change quite often for a given <strong class="source-inline">University</strong>, or the various <strong class="source-inline">Course</strong> set an <strong class="source-inline">Instructor</strong> will teach will change each semester. It will be typical, then, to remove a particular object’s association to another object, and perhaps associate, instead, to a different instance of that class. But, that also means that the associated object must know to remove its link to the first mentioned object. This becomes complicated.</p>
<p>For example, consider the <strong class="source-inline">Student</strong> and <strong class="source-inline">Course</strong> relationship. A <strong class="source-inline">Student</strong> is enrolled in many <strong class="source-inline">Course</strong> instances. A <strong class="source-inline">Course</strong> contains an association to many <strong class="source-inline">Student</strong> instances. This is a many-to-many association. Let’s imagine that the <strong class="source-inline">Student</strong> wishes to drop a <strong class="source-inline">Course</strong>. It is not enough for a specific <strong class="source-inline">Student</strong> instance to remove a pointer to a specific <strong class="source-inline">Course</strong> instance. Additionally, the <strong class="source-inline">Student</strong> must let the particular <strong class="source-inline">Course</strong> instance know that the <strong class="source-inline">Student</strong> in question should be removed from that <strong class="source-inline">Course</strong>’s roster. This is known as backlink maintenance. </p>
<p>Consider what would happen in the above scenario if a <strong class="source-inline">Student</strong> were to simply null out its link to the <strong class="source-inline">Course</strong> it was dropping, and do nothing further. The <strong class="source-inline">Student</strong> instance in question would be fine. However, the formerly associated <strong class="source-inline">Course</strong> instance would still contain a pointer to the <strong class="source-inline">Student</strong> in question. Perhaps this would equate to the <strong class="source-inline">Student</strong> receiving a failing grade in the <strong class="source-inline">Course</strong> as the <strong class="source-inline">Instructor</strong> still thinks the <strong class="source-inline">Student</strong> in question is enrolled, yet hasn’t been turning in their homework. In the end, the <strong class="source-inline">Student</strong> has been affected after all, with the failing grade.</p>
<p>Remember, with associated objects, one object will not delete the other when it is done with the other object. For example, when a <strong class="source-inline">Student</strong> drops a <strong class="source-inline">Course</strong>, they will not delete that <strong class="source-inline">Course</strong> – only remove their pointer to the <strong class="source-inline">Course</strong> in question (and definitely also handle the required backlink maintenance).</p>
<p>One idea to help us with overall link maintenance<a id="_idIndexMarker758"/> is to consider <strong class="bold">reference counting</strong>. The purpose of reference counting is to keep track of how many pointers may be pointing to a given instance. For example, if other objects point to a given instance, that instance should not be deleted. Otherwise, the pointers in the other object will point to deallocated memory, which will lead to numerous runtime errors. </p>
<p>Let’s consider an association with multiplicity, such as the relationship between a <strong class="source-inline">Student</strong> and a <strong class="source-inline">Course</strong>. A <strong class="source-inline">Student</strong> should keep track of how many <strong class="source-inline">Course</strong> pointers are pointing to the <strong class="source-inline">Student</strong>, that is, how many <strong class="source-inline">Courses</strong> the <strong class="source-inline">Student</strong> is taking. A <strong class="source-inline">Student</strong> should not be deleted while various <strong class="source-inline">Courses</strong> point to that <strong class="source-inline">Student</strong>. Otherwise, <strong class="source-inline">Courses</strong> will point to deleted memory. One way to handle this situation is to check within the <strong class="source-inline">Student</strong> destructor whether the object (<strong class="source-inline">this</strong>) contains any non-null pointers to <strong class="source-inline">Course</strong> instances. If the object does, it then needs to call a method through each of the active <strong class="source-inline">Course</strong> instances to request links to the <strong class="source-inline">Student</strong> be removed from each such <strong class="source-inline">Course</strong>. After each link is removed, the reference counter corresponding to the set of <strong class="source-inline">Course</strong> instances can be decremented. </p>
<p>Likewise, link maintenance should occur in the <strong class="source-inline">Course</strong> class in favor of <strong class="source-inline">Student</strong> instances. <strong class="source-inline">Course</strong> instances should not be deleted until all <strong class="source-inline">Student</strong> instances enrolled in that <strong class="source-inline">Course</strong> have been notified. Keeping a counter of how many <strong class="source-inline">Student</strong> instances point to a particular instance of a <strong class="source-inline">Course</strong> through reference counting is helpful. In this example, it is as simple as maintaining a variable to reflect the current number of <strong class="source-inline">Student</strong> instances enrolled in the <strong class="source-inline">Course</strong>. </p>
<p>We can meticulously conduct link maintenance ourselves, or we may choose to use smart pointers to manage the lifetime of an associated object. <strong class="bold">Smart pointers</strong> can be found in the C++ Standard Library. They <a id="_idIndexMarker759"/>encapsulate a pointer (that is, wrap a pointer within a class) to add smart features, including reference counting and memory management. Because smart pointers utilize templates, which we will not cover until <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, we will just mention their potential utility here. </p>
<p>We have now seen the importance of backlink maintenance and the utility of reference coun<a id="_idTextAnchor482"/>ting to fully support associations and their successful implementation. Let’s now briefly recap the OO concepts we’ve covered in this chapter – association, aggregation, and composition – before moving onward to our next chapter.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor483"/>Summary</h1>
<p>In this chapter, we have pressed forward with our pursuit of object-oriented programming by exploring various object relationships – association, aggregation, and composition. We have understood the various OO design concepts representing these relationships and have seen that C++ does not offer direct language support through keywords or specific language features to implement these concepts.</p>
<p>Nonetheless, we have learned several techniques for implementing these core OO relationships, such as embedded objects for composition and generalized aggregation, or using pointers to implement association. We have looked at the typical longevity of object existence with these relationships; for example, with aggregation, by creating and destroying its inner part (through an embedded object, or more rarely, by allocating and deallocating a pointer member). Or through the independent existence of associated objects that neither create nor destroy one another. We have also looked under the hood at the housekeeping required to implement association, particularly associations with multiplicity, by examining backlink maintenance and reference counting.</p>
<p>We have added key features to our OOP skills through understanding how to implement association, aggregation, and composition. We have seen examples of how these relationships may even be more prolific in OO designs than inheritance. By mastering these skills, we have completed our core skillset of implementing essential OO concepts in C++.</p>
<p>We are now ready to continue to <a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em>, which will begin our quest to expand our C++ programming repertoire.<a id="_idTextAnchor484"/> Let’s continue forward!</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor485"/>Questions</h1>
<ol>
<li>Add an additional <strong class="source-inline">Student</strong> constructor to the <strong class="source-inline">University</strong>/<strong class="source-inline">Student</strong> example in this chapter to accept the <strong class="source-inline">University</strong> constructor argument by reference, rather than by pointer. For example, in addition to the constructor with the signature <strong class="source-inline">Student::Student(const string &amp;fn, const string &amp;ln, char mi, const string &amp;t, float avg, const string &amp;course, const string &amp;id, University *univ);</strong>, overload this function with a similar one, but with <strong class="source-inline">University &amp;univ</strong> as the last parameter. How does this change the implicit call to this constructor? </li>
</ol>
<p>Hint: within your overloaded constructor, you will now need to take the address-of (<strong class="source-inline">&amp;</strong>) the <strong class="source-inline">University</strong> reference parameter to set the association (which is stored as a pointer). You may need to switch to object notation (<strong class="source-inline">.</strong>) to set the backlink (if you use parameter <strong class="source-inline">univ</strong>, versus data member <strong class="source-inline">this-&gt;univ</strong>).</p>
<ol>
<li value="2">Write a C++ program to implement a many-to-many association between objects of type <strong class="source-inline">Course</strong> and of type <strong class="source-inline">Student</strong>. You may choose to build on your previous programs that encapsulate <strong class="source-inline">Student</strong>. The many-to-many relationship should work as follows:<ol><li>A given <strong class="source-inline">Student</strong> may take zero to many <strong class="source-inline">Course</strong>s, and a given <strong class="source-inline">Course</strong> will associate to many <strong class="source-inline">Student</strong> instances. Encapsulate the <strong class="source-inline">Course</strong> class to minimally contain a course name, a set of pointers to associated <strong class="source-inline">Student</strong> instances, and a reference count to keep track of the number of <strong class="source-inline">Student</strong> instances that are in the <strong class="source-inline">Course</strong> (this will equate to how many <strong class="source-inline">Student</strong> instances point to a given instance of a <strong class="source-inline">Course</strong>). Add the appropriate interface to reasonably encapsulate this class.</li><li>Add to your <strong class="source-inline">Student</strong> class a set of pointers to the <strong class="source-inline">Course</strong> instances in which that <strong class="source-inline">Student</strong> is enrolled. Additionally, keep track of how many <strong class="source-inline">Course</strong> instances a given <strong class="source-inline">Student</strong> is currently enrolled. Add appropriate member functions to support this new functionality.</li><li>Model your many-sided associations using either a linked list of pointers (that is, the data part is a pointer to the associated object) or as an array of pointers to the associated objects. Note that an array will enforce a limit on the number of associated objects you can have, however, this may be reasonable because a given <strong class="source-inline">Course</strong> can only accommodate a maximum number of <strong class="source-inline">Student</strong>s and a <strong class="source-inline">Student</strong> may only enroll up to a maximum number of <strong class="source-inline">Course</strong>s per semester. If you choose the array of pointers approach, make sure your implementation includes error checking to accommodate exceeding the maximum number of associated objects in each array.</li><li>Be sure to check for simple errors, such as trying to add <strong class="source-inline">Student</strong>s to a <strong class="source-inline">Course</strong> that is full, or adding too many <strong class="source-inline">Course</strong>s to a <strong class="source-inline">Student</strong>’s schedule (assume there is an upper bound to five courses per semester).</li><li>Make sure your destructors do not delete the associated instances.</li><li>Introduce at least three <strong class="source-inline">Student</strong> objects, each of which takes two or more <strong class="source-inline">Course</strong>s. Additionally, make sure each <strong class="source-inline">Course</strong> has multiple <strong class="source-inline">Student</strong>s enrolled. Print each <strong class="source-inline">Student</strong>, including each <strong class="source-inline">Course</strong> in which they are enrolled. Likewise, print each <strong class="source-inline">Course</strong>, showing eac<a id="_idTextAnchor486"/>h <strong class="source-inline">Student</strong> enrolled in the <strong class="source-inline">Course</strong>.</li></ol></li>
<li>(Optional) Enhance your program in <em class="italic">Exercise 2</em> to gain experience with backlink maintenance and reference counting as follows:<ol><li>Implement a <strong class="source-inline">DropCourse()</strong> interface for <strong class="source-inline">Student</strong>. That is, create a <strong class="source-inline">Student:: DropCourse(Course *)</strong> method in <strong class="source-inline">Student</strong>. Here, find the <strong class="source-inline">Course</strong> the <strong class="source-inline">Student</strong> wishes to drop in their course list, but before removing the <strong class="source-inline">Course</strong>, call a method on that <strong class="source-inline">Course</strong> to remove the aforementioned <strong class="source-inline">Student</strong> (that is, <strong class="source-inline">this</strong>) from the <strong class="source-inline">Course</strong>. Hint: you can make a <strong class="source-inline">Course::RemoveStudent(Student *)</strong>) method to help with backlink removal.</li><li>Now, fully implement proper destructors. When a <strong class="source-inline">Course</strong> is destructed, have the <strong class="source-inline">Course</strong> destructor first tell each remaining associated <strong class="source-inline">Student</strong> to remove their link to that <strong class="source-inline">Course</strong>. Likewise, when a <strong class="source-inline">Student</strong> is destructed, loop through the <strong class="source-inline">Student</strong>’s course list to ask those <strong class="source-inline">Courses</strong> to remove the aforementioned <strong class="source-inline">Student</strong> (that is, <strong class="source-inline">this</strong>) from their student list. You may find reference counting in each class (that is, by checking <strong class="source-inline">numStudents</strong> or <strong class="source-inline">numCourses</strong>) helpful to see whether these tasks must be engaged.</li></ol></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer044">
<h1 id="_idParaDest-190"><a id="_idTextAnchor487"/>Part 3: Expanding Your C++ Programming Repertoire</h1>
<p>The goal of this part is to expand your C++ programming skills, beyond the OOP skills, to encompass other critical features of C++. </p>
<p>The initial chapter in this section explores exception handling in C++ through understanding the mechanisms of <strong class="source-inline">try</strong>, <strong class="source-inline">throw</strong>, and <strong class="source-inline">catch</strong>, and through examining many examples to explore exception mechanics by delving into various exception handling scenarios. Additionally, this chapter expands exception class hierarchies with new exception classes. </p>
<p>The next chapter digs into the topics of the proper usage of friend functions and friend classes, as well as operator overloading (which may sometimes require friends), to make operations polymorphic between built-in and user defined types. </p>
<p>The subsequent chapter explores using C++ templates to help make code generic and usable for a variety of data types using template functions and template classes. Additionally, this chapter explains how operator overloading will assist in making template code extensible for virtually any data type.</p>
<p>In the next chapter, the Standard Template Library in C++ is introduced, and core STL containers such as <strong class="source-inline">list</strong>, <strong class="source-inline">iterator</strong>, <strong class="source-inline">deque</strong>, <strong class="source-inline">stack</strong>, <strong class="source-inline">queue</strong>, <strong class="source-inline">priority_queue</strong>, and <strong class="source-inline">map</strong> (including one using a functor) are examined. Additionally, STL algorithms and functors are introduced.</p>
<p>The final chapter in this section surveys testing OO programs and components by exploring canonical class form, creating drivers for component testing, testing classes related through inheritance, association, aggregation, and testing exception-handling mechanisms. </p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em></li>
<li><a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em></li>
<li><a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em></li>
<li><a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em></li>
<li><a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em></li>
</ul>
</div>
<div>
<div id="_idContainer045">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer046">
</div>
</div>
<div class="Content" id="_idContainer047">
</div>
<div class="Basic-Text-Frame" id="_idContainer048">
<p class="hidden">Part 3: Expanding Your C++ Programming Repertoire</p>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer049">
</div>
</div>
</div></body></html>