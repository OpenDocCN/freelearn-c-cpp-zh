<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor454"/>10</h1>
<h1 id="_idParaDest-180"><a id="_idTextAnchor455"/>Implementing Association, Aggregation, and Composition</h1>
<p>This chapter will continue advancing our knowledge of object-oriented programming in C++. We will augment our understanding of object relationships by exploring the object-oriented concepts of association, aggregation, and composition. None of these OO concepts have direct language support in C++; we will instead learn multiple programming techniques to implement these ideas. We will also understand which implementation techniques are preferred for various concepts, as well as the advantages and pitfalls of various practices. </p>
<p>Association, aggregation, and composition occur copiously in OO designs. It is crucial to understand how to implement these important object relationships. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the OO concepts of aggregation and composition, and various implementations</li>
<li>Understanding the OO concept of association and its implementation, including the importance of backlink maintenance and the utility of reference counting</li>
</ul>
<p>By the end of this chapter, you will understand the OO concepts of association, aggregation, and composition, and how to implement these relationships in C++. You will also understand many housekeeping approaches necessary to keep these relationships up to date, such as reference counting and backlink maintenance. Though the concepts are relatively straightforward, you will see why there is a substantial amount of bookkeeping required to maintain accuracy for these types of object relationships. </p>
<p>Let’s broaden our understanding of C++ as an OOP language by exploring these core object relationships.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor456"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter10</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter10</code> in a file named <code>Chp10-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3clgvGe">https://bit.ly/3clgvGe</a>.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor457"/><a id="_idTextAnchor458"/>Understanding aggregation and composition</h1>
<p>The object-oriented concept of aggregation<a id="_idIndexMarker726"/> arises in many OO designs. It comes up as frequently as inheritance does to specify object relationships. <strong class="bold">Aggregation</strong> is used to specify Has-A, whole-part, and in some cases, containment relationships. A class may contain aggregates of other objects. Aggregation can be broken into two categories – <em class="italic">composition</em> as well as a less strict and <em class="italic">generalized</em> form of aggregation. </p>
<p>Both <strong class="bold">generalized aggregation</strong> and <strong class="bold">composition</strong> imply a Has-A or whole-part relationship. However, the<a id="_idIndexMarker727"/> two differ in the existence requirements between the<a id="_idIndexMarker728"/> two related objects. With generalized aggregation, the objects can exist independently from one another, yet with composition, the objects cannot exist without one another.</p>
<p>Let’s take a look at each variety of aggregation, starting with compositio<a id="_idTextAnchor459"/>n.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor460"/>Defining and implementing composition</h2>
<p><strong class="bold">Composition</strong> is the <a id="_idIndexMarker729"/>most specialized form of aggregation and is often what most OO designers and programmers think of when they consider aggregation. Composition implies containment, and is most often synonymous with a whole-part relationship – that is, the whole entity is composed of one or more parts. The whole <em class="italic">contains</em> the parts. The Has-A relationship will also apply to composition.</p>
<p>The outer object, or <em class="italic">whole</em>, can be made up of <em class="italic">parts</em>. With composition, parts do not exist without the whole. Implementation is usually an embedded object – that is, a data member of the contained object type. On rare occasions, the outer object will contain a pointer or reference to the contained object type; however, when this occurs, the outer object will be responsible for the creation and destruction of the inner object. The contained object has no<a id="_idIndexMarker730"/> purpose without its outer layer. Likewise, the outer layer is not <em class="italic">ideally</em> complete without its inner, contained pieces.</p>
<p>Let’s take a<a id="_idIndexMarker731"/> look at a composition as typically implemented. The example will illustrate containment – a <code>Student</code> <em class="italic">Has-A(n)</em> <code>Id</code>. More so, we will imply that an <code>Id</code> is a necessary part of a <code>Student</code> and will not exist without a <code>Student</code>. <code>Id</code> objects on their own serve no purpose. <code>Id</code> objects simply do not need to exist if they are not a part of a primary object that gives them purpose. Likewise, you might argue that a <code>Student</code> is incomplete without an <code>Id</code>, though this is a bit subjective! We will implement the <em class="italic">part</em> using an embedded object within the <em class="italic">whole</em>. </p>
<p>The composition example will be broken into many segments. Though only portions of the example are shown, the full program can be found in the following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
class Id final  <strong class="bold">// the cont<a id="_idTextAnchor461"/>ained 'part'</strong>
{        // this class is not intended to be extended 
private:
    string idNumber;
public:
    Id() = default;
    Id(const string &amp;id): idNumber(id) { }
    // We get default copy constructor, destructor
    // without including without including prototype
    // Id(const Id &amp;id) = default;
    // ~Id() = default;
    const string &amp;GetId() const { return idNumber; }
};</pre>
<p>In the <a id="_idIndexMarker732"/>previous code fragment, we have defined an <code>Id</code> class. An <code>Id</code> will be a class that can be contained by other classes needing a fully functional <code>Id</code> capability. The <code>Id</code> will become a <em class="italic">part</em> of any <em class="italic">whole</em> object that may choose to contain it. </p>
<p>Let’s move onward to build a set of classes that will ultimately contain this <code>Id</code>. We will start with a class we are familiar with, <code>Person</code>:</p>
<pre class="source-code">
class Person
{
private:
    string firstName;
    string lastName;
    char middleInitial = '\0';   // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
protected:
    void ModifyTitle(const string &amp;);
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    // We get default copy constructor w/o prototype 
    // Person(const Person &amp;) = default;  // copy ctor.
    // But, we need prototype destructor to add 'virtual' 
    virtual ~Person() = default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    // virtual functions
    virtual void Print() const;   
    virtual void IsA() const;
    virtual void Greeting(const string &amp;) const;
};
//  Assume the member functions for Person exist here
//  (they are the same as in previous chapters)</pre>
<p>In the <a id="_idIndexMarker733"/>previous segment of code, we have defined the <code>Person</code> class, as we are accustomed to describing it. To abbreviate this example, let us assume that the accompanying member functions exist as prototyped in the aforementioned class definition. You can reference these member functions in the earlier provided GitHub link for online<a id="_idTextAnchor462"/> code. </p>
<p>Now, let’s define our <code>Student</code> class. Though it will contain elements that we are accustomed to seeing, <code>Student</code> will also contain an <code>Id</code> as an embedded object:</p>
<pre class="source-code">
class Student: public Person  <strong class="bold">// 'whole' object</strong>
{
private:
    float gpa = 0.0;    // in-class initialization
    string currentCourse;
    static int numStudents;  
    <strong class="bold">Id studentId;  // is composed of a 'part'</strong>
public:    
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    // various member functions (many are inline)
    void EarnPhD() { ModifyTitle("Dr."); } 
    float GetGpa() const { return gpa; }         
    const string &amp;GetCurrentCourse() const
        { return currentCourse; }
    void SetCurrentCourse(const str<a id="_idTextAnchor463"/>ing &amp;); // proto. only
    void Print() const override;
    void IsA() const override 
        { cout &lt;&lt; "Student" &lt;&lt; endl; }
    static int GetNumberStudents() { return numStud<a id="_idTextAnchor464"/>ents; }
    // Access function for embedded Id object
    <strong class="bold">const string &amp;GetStudentId() const;</strong>   // prototype only
};
int Student::numStudents = 0;  // static data member
inline void Student::SetCurrentCourse(const string &amp;c)
{
    currentCourse = c;
}</pre>
<p>In the <a id="_idIndexMarker734"/>preceding <code>Student</code> class, we routinely notice that <code>Student</code> is derived from <code>Person</code>. As we already know, this means that a <code>Student</code> instance will include the memory layout of a <code>Person</code>, as a <code>Person</code> subobject. </p>
<p>However, notice the data member, <code>Id studentId;</code>, in the <code>Student</code> class definition. Here, <code>studentId</code> is of type <code>Id</code>. It is not a pointer, nor is it a reference to an <code>Id</code>. Data member <code>studentId</code> is an embedded (that is, an aggregate or member) object. This means that when a <code>Student</code> class is instantiated, not only will the memory from inherited classes be included but also the memory for any embedded objects. We will need to provide a means to initialize the embedded object, <code>studentId</code>. Note, we have seen member objects before, such as data members of type <code>string</code>; that is, data members that are of another class type.</p>
<p>Let’s move forward with the <code>Student</code> member functions to understand how we may initialize, manipulate, and access the embedded object:</p>
<pre class="source-code">
Student::Student(): <strong class="bold">studentId(to_string(numStudents + 100)</strong> 
                                         <strong class="bold">+ "Id")</strong> 
{
    numStudents++;   // increment static counter
}
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;t, float avg, 
                 const string &amp;course, const string &amp;id)<strong class="bold">:</strong>  
                 Person(fn, ln, mi, t), gpa(avg),
                 currentCourse(course), <strong class="bold">studentId(id)</strong>
{
    numStudents++;
}
Student::Student(const Student &amp;s)<strong class="bold">:</strong> Person(s),
                gpa(s.gpa), currentCourse(s.currentCourse),
     <a id="_idTextAnchor465"/>           <strong class="bold">studentId(s.studentId)</strong>
{
    numStudents++;
}
Student::~Student()   // destructor definition
{
    numStudents--;    // decrement static counter
    <strong class="bold">// embedded object studentId will also be destructed</strong>
}
void Student::Print() const
{
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with <a id="_idTextAnchor466"/>id: " &lt;&lt; <strong class="bold">studentId.Ge<a id="_idTextAnchor467"/>tId()</strong> &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}    
const string &amp;GetStudentId() const 
{   
    return <strong class="bold">studentId.GetId();</strong>   
} </pre>
<p>In the previously listed member functions of <code>Student</code>, let’s begin with our constructors. Notice in the default constructor, we utilize the member initialization list (<code>:</code>) to specify <code>studentId(to_string(numStudents + 100) + "Id")</code>. Because <code>studentId</code> is a member object, we have the opportunity to select (via the member initialization list) which constructor should be used for its initialization. Here, we merely select the one with the <code>Id(const string &amp;)</code> signature. In the absence of a specific value to use to initialize <code>Id</code>, we manufacture a string value to serve as the needed ID.</p>
<p>Similarly, in <a id="_idIndexMarker735"/>the alternate constructor for <code>Student</code>, we use the member initialization list to specify <code>studentId(id)</code>, which will also select the <code>Id(const string &amp;)</code> constructor, passing the parameter <code>id</code> to this constructor. </p>
<p>The copy constructor for <code>Student</code> additionally specifies how to initialize the <code>studentId</code> member object with the <code>studentId(s.studentId)</code> specification in the member initialization list. Here, we simply call the copy constructor for <code>Id</code>.</p>
<p>In our destructor for <code>Student</code>, we do not need to deallocate <code>studentId</code>. As this data member is an embedded (aggregate) object, its memory will go away when the memory for the outer object goes away. Of course, because <code>studentId</code> is an object itself, its own destructor will first be called before its memory is released. Under the hood, the compiler will (covertly) patch in a call to the <code>Id</code> destructor for <code>studentId</code> as the last line of code in the <code>Student</code> destructor. Actually, this will be the penultimate (next to last) implicit line in the destructor – the last line that will be covertly patched in will be a call to the <code>Person</code> destructor (to continue the destruction sequence).</p>
<p>Lastly, in the previous segment of code, let’s notice the call to <code>studentId.GetId()</code>, which occurs in both <code>Student::Print()</code> and <code>Student::GetStudentId()</code>. Here, the embedded object <code>studentId</code> calls its own public function <code>Id::GetId()</code> to retrieve its private data member in the scope of the <code>Student</code> class. Because <code>studentId</code> is private in <code>Student</code>, this embedded object may only be accessed within the scope of <code>Student</code> (that is, member functions of <code>Student</code>). However, the addition of <code>Student::GetStudentId()</code> provides a public wrapper for <code>Student</code> instances in other scopes to retrieve this information.</p>
<p>Finally, let’s take<a id="_idIndexMarker736"/> a look at our <code>main()</code> function:</p>
<pre class="source-code">
int main()
{
    Student s1("Cyrus", "Bond", 'I', "Mr.", 3.65, "C++",
               "6996CU");
    Student s2("Anne", "Brennan", 'M', "Ms.", 3.95, "C++",
               "909EU");
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " has id #: " &lt;&lt; <strong class="bold">s1.GetStudentId()</strong> &lt;&lt; endl;
    cout &lt;&lt; s2.GetFirstName() &lt;&lt; " " &lt;&lt; s2.GetLastName();
    cout &lt;&lt; " has id #: " &lt;&lt; <strong class="bold">s2.GetStudentId()</strong> &lt;&lt; endl;
    return 0;
}</pre>
<p>In the aforementioned <code>main()</code> function, we instantiate two <code>Student</code> instances: <code>s1</code> and <code>s2</code>. When the memory is created (in this case, on the stack) for each <code>Student</code>, memory for any inherited classes will also be included as subobjects. Additionally, memory for any embedded objects, such as <code>Id</code>, will also be laid out as a subobject within <code>Student</code>. The memory for the contained object, or <em class="italic">part</em>, will be allocated along with the allocation for the outer object, or <em class="italic">whole</em>.</p>
<p>Next, let’s notice the access to the contained piece, the embedded <code>Id</code> object. We start with a call to <code>s1.GetStudentId()</code>; <code>s1</code> accesses a <code>Student</code> member function, <code>GetStudentId()</code>. That student member function will utilize the member object of <code>studentId</code> to call <code>Id::GetId()</code> on this inner object of type <code>Id</code>. The member function <code>Student::GetStudentId()</code> can implement this desired public access by simply returning the value that <code>Id::GetId()</code> returns on the embedd<a id="_idTextAnchor468"/>ed object.</p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Cyrus Bond has id #: 6996CU
Anne Brennan has id<a id="_idTextAnchor469"/> #: 909EU </pre>
<p>This example <a id="_idIndexMarker737"/>details composition with its typical implementation, an embedded object. Let’s now take a look at a much less used, alternate implementation – that of inheritance.</p>
<h3>Considering an alternate implementation for composition</h3>
<p>It is useful to<a id="_idIndexMarker738"/> understand that composition can alternatively be implemented using inheritance, however, this is extremely controversial. Remember, inheritance is most often used to implement <em class="italic">Is-A</em> and not <em class="italic">Has-A</em> relationships. We briefly described using inheritance to implement Has-A relationships in <a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em>.</p>
<p>To recap, you would simply inherit from the <em class="italic">part</em>, rather than embed the part as a data member. When doing so, you no longer need to provide <em class="italic">wrapper</em> functions to the <em class="italic">part</em>, such as we saw in the previous program, with the <code>Student::GetStudentId()</code> method calling <code>studentId.GetId()</code> to provide access to its embedded part. The wrapper function was necessary with the embedded object example, as the part (<code>Id</code>) was private in the whole (<code>Student</code>). Programmers could not have accessed the private <code>studentId</code> data member of <code>Student</code> outside the scope of <code>Student</code>. Of course, member functions of <code>Student</code> (such as <code>GetStudentId()</code>) can access their own class’ private data members and in doing so, can implement the <code>Student::GetStudentId()</code> wrapper function to provide such (safe) access. </p>
<p>Had inheritance been used, the public interface of <code>Id::GetId()</code> would have been simply inherited as a public interface in <code>Student</code>, providing simple access without the need to first go through the embedded object explicitly. </p>
<p>Nonetheless, though inheriting a <em class="italic">part</em> is simple in some ways, it vastly compounds multiple inheritance. We know multiple inheritance can provide many potential complications. Also, using inheritance, the <em class="italic">whole</em> can only contain one of each <em class="italic">part</em> – not multiples of a <em class="italic">part</em>. </p>
<p>Additionally, implementing <a id="_idIndexMarker739"/>a whole-part relationship with inheritance may be confusing when you compare the implementation to the OO design. Remember, inheritance usually means <em class="italic">Is-A</em> and not <em class="italic">Has-A</em>. For these reasons, the most typical and appreciated implementation of an aggregate is through an embedded object. </p>
<p>Next, let’s move onward by looking at a more general form of aggregation.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor470"/>Defining and implementing a generalized aggregation</h2>
<p>We have looked at the most commonly used form of aggregation in OO designs, that of composition. Most notably, with composition, we have seen that the part does not have a reason to exist without the whole. Nonetheless, a more generalized (but less common) form of aggregation exists and is sometimes specified in OO designs. We will now consider this less common form of aggregation.</p>
<p>In a <strong class="bold">generalized aggregation</strong>, a <em class="italic">part</em> may <a id="_idIndexMarker740"/>exist without the <em class="italic">whole</em>. A part will be created separately and then attached to the whole at a later point in time. When the <em class="italic">whole</em> goes away, a <em class="italic">part</em> may then remain to be salvaged for use with another outer or <em class="italic">whole</em> object. </p>
<p>In a generalized aggregation, the Has-A relationship certainly applies, as does the whole-part designation. The difference is that the <em class="italic">whole</em> object will not create nor destroy a <em class="italic">part</em> subobject. Consider the straightforward example that a <code>Car</code> <em class="italic">Has-A(n)</em> <code>Engine</code>. A <code>Car</code> object also <em class="italic">Has-A</em> set of four <code>Tire</code> objects. The <code>Engine</code> or <code>Tire</code> objects can be manufactured separately and then passed to the constructor of the <code>Car</code> to provide these parts to the whole. Yet should an <code>Engine</code> be destroyed, a new <code>Engine</code> can easily be swapped out (using a member function), without requiring the entire <code>Car</code> to be destroyed and then reconstructed. </p>
<p>A generalized aggregation is equivalent to a Has-A relationship, yet we think of this with more flexibility and permanence of the individual parts as we did with composition. We consider this relationship as an aggregation simply because we wish to equate the objects with a Has-A meaning. The Has-A relationship in the <code>Car</code>, <code>Engine</code>, and <code>Tire</code> example is strong; the <code>Engine</code> and <code>Tire</code>s are necessary parts, required to make the whole <code>Car</code>.</p>
<p>Here, implementation typically is with the <em class="italic">whole</em> containing a pointer (or set of pointers) to the <em class="italic">part(s)</em>. It is important to note that the parts will be passed into a constructor (or another member function) of the outer object to establish the relationship. The<a id="_idIndexMarker741"/> critical marker is that the whole will not create (nor destroy) the parts, and the parts will never destroy the whole.</p>
<p>Incidentally, the longevity of the individual pieces (and the basic implementation) of a generalized aggregation will be similar to our next topic – association. Let’s move forward to our next section to understand the similarities, as well as the OO conceptual differences (sometimes subtle) between generalized aggregation a<a id="_idTextAnchor471"/><a id="_idTextAnchor472"/>nd association.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor473"/>Understanding association</h1>
<p>An <strong class="bold">association</strong> models a<a id="_idIndexMarker742"/> relationship that exists between otherwise unrelated class types. An association can provide ways for objects to interact to fulfill these relationships. Associations are not used for Has-A relationships, however, in some cases, there are shades of gray as to whether we’re describing a bonafide Has-A relationship, or whether we are merely using the phrase Has-A because it sounds appropriate linguistically. </p>
<p>Multiplicity<a id="_idIndexMarker743"/> for associations exists: one-to-one, one-to-many, many-to-one, or many-to-many. For example, a <code>Student</code> may be associated with a single <code>University</code>, and that <code>University</code> may be associated with many <code>Student</code> instances; this is a one-to-many association.</p>
<p>Associated objects have an independent existence. That is, two or more objects may be instantiated and exist independently for a portion of the application. At some point, one object may wish to assert a dependency or relationship with the other object. Later in the application, the associated objects may part ways and continue on their own unrelated paths.</p>
<p>For example, consider <a id="_idIndexMarker744"/>the relationship between a <code>Course</code> and an <code>Instructor</code>. A <code>Course</code> is associated with an <code>Instructor</code>. A <code>Course</code> requires an <code>Instructor</code>; an <code>Instructor</code> is integral to the <code>Course</code>. An <code>Instructor</code> may be associated with many <code>Course</code>(s). Yet each part exists independently – one will not create nor destroy the other. Instructors may also exist independently without courses; perhaps an instructor is taking time to write a book, is taking a sabbatical, or is a professor conducting research.</p>
<p>In this example, the<a id="_idIndexMarker745"/> association is very similar to a generalized aggregation. In both cases, the related objects also exist independently. In this case, whether one says that <code>Course</code> Has-A(n) <code>Instructor</code> or that a <code>Course</code> has a dependency on an <code>Instructor</code>, can be a shade of gray. You may ask yourself – is it just spoken language that makes me choose the wording of Has-A? Do I instead mean that there is a necessary link between the two? Perhaps the relationship is an association, and its descriptive adornment (to further describe the nature of the association) is <em class="italic">teaches</em>. You may have arguments supporting either choice. For this reason, generalized aggregations can be considered specialized types of associations; we will see that their implementations are the same using independently existing objects. Nonetheless, we will distinguish a typical association as being a relationship between objects that decisively do not support a true Has-A relationship.</p>
<p>For example, consider the relationship between <code>University</code> and <code>Instructor</code>. Rather than thinking of this as a Has-A relationship, we may instead consider the relationship between the two as that of association; we can think of the adornment describing this relationship as <em class="italic">employs</em>. Likewise, <code>University</code> ascertains a relationship with many <code>Student</code> objects. The association here may be described by the adornment <em class="italic">educates</em>. The distinction can be made that <code>University</code> is made up of <code>Department</code> objects, <code>Building</code> objects, and components of this nature to support any of its Has-A relationships through containment, yet its relationships with <code>Instructor</code> objects, <code>Student</code> objects, and so on are made using associations.</p>
<p>Now that we have distinguished typical associations from generalized aggregations, let’s take a look at how we can implement associations and some of the complexities involved.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor474"/>Implementing association</h2>
<p>Typically, an association <a id="_idIndexMarker746"/>between two or more objects is implemented using pointers or sets of pointers. The <em class="italic">one</em> side is implemented using a pointer to the associated object, whereas the <em class="italic">many</em> side of the relationship is implemented as a set of pointers to the associated objects. A set of pointers may be an array of pointers, a linked list of pointers, or truly any collection of pointers. Each type of collection will have its own set of advantages and drawbacks. For example, arrays of pointers are easy to use, have direct access to specific members, yet have a fixed number of items. Linked lists of pointers can accommodate any quantity of items, yet accessing a specific element requires traversing past others to find the desired item.</p>
<p>Occasionally, a reference may be used to implement the <em class="italic">one</em> side of an association. Recall that a reference must be initialized and cannot at a later date be reset to reference another object. Using a reference to model an association implies that one instance will be associated with a precise other instance for the duration of the primary object’s existence. This is extremely restrictive, so references are used very infrequently to implement associations. </p>
<p>Regardless of the implementation, when the primary object goes away, it will not interfere with (that is, delete) the associated object. </p>
<p>Let’s see a<a id="_idIndexMarker747"/> typical example illustrating the preferred implementation of a one-to-many association, utilizing a pointer on the <em class="italic">one</em> side, and a set of pointers on the <em class="italic">many</em> side. In this example, a <code>University</code> will be associated with many <code>Student</code> instances. And, for simplicity, a <code>Student</code> will be associated with a single <code>University</code>. </p>
<p>To save space, some portions of this program that are the same as in our last example will not be shown; however, the program in its entirety can be found in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter10/Chp10-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
// classes Id and Person are omitted here to save space.
// They will be as shown in previous example: Chp10-Ex1.cpp
<strong class="bold">class Student; // forward declaration</strong>
class University
{
private:
    string name;
    static constexpr int MAX = 25; // max students allowed
    // Notice: each studentBody element is set to a nullptr 
    // using in-class initialization 
    <strong class="bold">Student *studentBody[MAX] = { };</strong> // Association to
                                     // many students
    int currentNumStudents = 0;  // in-class initialization
public:
    University();
    University(const string &amp;);
    University(const University &amp;) = delete; // no copies
    ~University();
    void EnrollStudent(<strong class="bold">Student *</strong>);
    const string &amp;GetName() const { return name; }
    void PrintStudents() const;
};</pre>
<p>In the preceding<a id="_idIndexMarker748"/> segment, let’s first notice the forward declaration of <code>class Student;</code>. This declaration will allow our code to reference the <code>Student</code> type prior to the <code>Student</code> class definition. In the <code>University</code> class definition, we see that there is an array of pointers to <code>Student</code>. We also see that the <code>EnrollStudent()</code> method takes a <code>Student *</code> as an argument. The forward declaration enables such usage of <code>Student</code> prior to its definition.</p>
<p>We also <a id="_idIndexMarker749"/>notice that the <code>University</code> has a simple interface with constructors, a destructor, and a few member functions.</p>
<p>Next, let’s take a look at the <code>University</code> member function definitions:</p>
<pre class="source-code">
// Remember, currentNumStudents will be set w in-class init
// and name, as a string member object, will be init to 
// empty. And studentBody (array of ptrs) will also set w
// in-class initialization.
University::University()
{
    // in-lieu of in-class init, we could alternatively set
    // studentBody[i] to nullptr iteratively in a loop:
    // (the student body will start out empty)   
    // for (int i = 0; i &lt; MAX; i++) 
    //    <strong class="bold">studentBody[i] = nullptr;</strong> 
}
University::University(const string &amp;n): name(n)
{   
    // see default constructor for alt init of studentBody
}
University::~University()
{
    <strong class="bold">// The University will not delete the students</strong>
    for (int i = 0; i &lt; MAX; i++)   // only null out 
       <strong class="bold">studentBody[i] = nullptr;</strong>    // their link
}                      
void University::EnrollStudent(Student *s)
{
    // set an open slot in the studentBody to point to the
    // Student passed in as an input parameter
    <strong class="bold">studentBody[curren<a id="_idTextAnchor476"/>tNumStudents++] = s;</strong>
}
void University::PrintStudents()const
{
    cout &lt;&lt; name &lt;&lt; " has the following students:" &lt;&lt; endl;
    // Simple loop to process set of students, however we
    // will soon see safer, more modern ways to iterate 
    // over partial arrays w/o writing explicit 'for' loops
    for (int i = 0; i &lt; currentNumStudents; i++)
    {
       cout &lt;&lt; "\t" &lt;&lt; <strong class="bold">studentBody[i]-&gt;GetFirstName()</strong>;
       cout &lt;&lt; " " &lt;&lt; <strong class="bold">studentBody[i]-&gt;GetLastName()</strong>;
       cout &lt;&lt; endl;
    }
}</pre>
<p>Taking a <a id="_idIndexMarker750"/>closer look at the aforementioned <code>University</code> methods, we can see that in both constructors for <code>University</code>, we could alternatively null out the pointers to the elements comprising our <code>studentBody</code> using <code>nullptr</code> (versus our choice of using in-class initialization, which similarly initializes each element). Likewise, in the destructor, we similarly null out our links to the associated <code>Student</code> instances. Shortly in this section, we will see that there will be some additional backlink maintenance required, but for now, the point is that we will not delete the associated <code>Student</code> objects.</p>
<p>Since <code>University</code> objects and <code>Student</code> objects will exist independently, neither will create nor destroy instances of the other type. </p>
<p>We also <a id="_idIndexMarker751"/>come across an interesting member function, <code>EnrollStudent(Student *)</code>. In this method, a pointer to a specific <code>Student</code> will be passed in as an input parameter. We merely index into our array of pointers to <code>Student</code> objects, namely <code>studentBody</code>, and set an unused array element point to the newly enrolled <code>Student</code>. We keep track of how many current <code>Student</code> objects exist using a <code>currentNumStudents</code> counter, which is incremented with a post increment after the pointer assignment to the array is made.</p>
<p>We also notice that the <code>University</code> class has a <code>Print()</code> method that prints the university’s name, followed by its current student body. It does so by simply accessing each associated <code>Student</code> object in <code>studentBody</code> and asking each <code>Student</code> instance to invoke the <code>Student::GetFirstName()</code> and <code>Student::GetLastName()</code> methods.</p>
<p>Next, let’s now take a look at our <code>Student</code> class definition, along with its inline functions. Recall that we’re assuming that the <code>Person</code> class is the same as seen earlier in this chapter:</p>
<pre class="source-code">
class Student: public Person  
{
private:
    // data members
    float gpa = 0.0;  // in-class initialization
    string currentCourse;
    static int numStudents;
    Id studentId;  // part, Student Has-A studentId
    <strong class="bold">University *univ = nullptr;</strong>  // Assoc. to Univ object
public:                          
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;, University *);
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // destructor
    void EarnPhD() { ModifyTitle("Dr."); }
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
        { return currentCourse; }
    void SetCurrentCourse(const string &amp;); // proto. only
    void Print() const override;
    void IsA() const override 
        { cout &lt;&lt; "Student" &lt;&lt; endl; }
    static int GetNumberStudents() { return numStudents; }
    // Access functions for aggregate/associated objects
    const string &amp;GetStudentId() const 
        { return studentId.GetId(); }
    <strong class="bold">const string &amp;GetUniversity() const </strong>
        <strong class="bold">{ return univ-&gt;GetName(); }</strong>
};
int Student::numStudents = 0;  // def. of static data mbr.
inline void Student::SetCurrentCo<a id="_idTextAnchor477"/>urse(const string &amp;c)
{
    currentCourse = c;
}</pre>
<p>Here, in the <a id="_idIndexMarker752"/>previous code segment, we see the <code>Student</code> class definition. Notice that we have an association with a University with the pointer data member <code>University *univ = nullptr;</code> and that this member is initialized to <code>nullptr</code> using in-class initialization. </p>
<p>In the class definition for <code>Student</code>, we can also see there is a wrapper function to encapsulate access to the student’s university’s name with <code>Student::GetUniversity()</code>. Here, we allow the associated object, <code>univ</code>, to call its public method <code>University::GetName()</code> and return that value as the result of <code>Student::GetUniversity()</code>.</p>
<p>Now, let’s take a look at the non-inline member functions of <code>Student</code>:</p>
<pre class="source-code">
Student::Student(): studentId(to_string(numStudents + 100) 
                                        + "Id")
{
    // no current University association (set to nullptr 
    // with in-class initializat<a id="_idTextAnchor478"/>ion)
    numStudents++;
}
Student::Student(const string &amp;fn, const string &amp;ln, 
          char mi, const string &amp;t, float avg, 
          const string &amp;course, const string &amp;id, 
          University *univ): Person(fn, ln, mi, t), 
          gpa(avg), currentCourse(course), studentId(id)
{
    // establish link to University, then back link
    // note: forward link could also be set in the
    // member initialization list
    <strong class="bold">this-&gt;univ = univ;</strong>  // required use of ‹this›
    <strong class="bold">univ-&gt;EnrollStudent(this);</strong>  // another required 'this'
    numStudents++;
}
Student::Student(const Student &amp;s): Person(s), 
          gpa(s.gpa), currentCourse(s.currentCourse),
          studentId(s.studentId)
{
    // Notice, these three lines of code are the same as 
    // in the alternate constructor – we could instead make
    // a private helper method with this otherwise 
    // duplicative code as a means to simplify code 
    // maintenance. 
    <strong class="bold">this-&gt;univ = s.univ;    </strong>
    <strong class="bold">univ-&gt;EnrollStudent(this);</strong>
    numStudents++;
}
Student::~Student()  // destructor
{
    numStudents--;
    <strong class="bold">univ = nullptr;</strong>  // a Student does not delete its Univ
    // embedded object studentId will also be destructed
}
void Student::Print() const
{
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with id: " &lt;&lt; studentId.GetId() &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}</pre>
<p>In the preceding<a id="_idIndexMarker753"/> code segment, notice that the default <code>Student</code> constructor and the destructor both only null out their link to the <code>University</code> object (using <code>nullptr</code>). The default constructor has no way to set this link to an existing object, and should certainly not create a <code>University</code> instance to do so. Likewise, the <code>Student</code> destructor should not delete the <code>University</code> merely because the <code>Student</code> object’s life expectancy is complete.</p>
<p>The most interesting part of the preceding code happens in both the alternate constructor and copy constructor of <code>Student</code>. Let’s examine the alternate constructor. Here, we establish the link to the associated <code>University</code> as well as the backlink from the <code>University</code> back to the <code>Student</code>.</p>
<p>In the <code>this-&gt;univ = univ;</code> line of code, we are assigning the data member, <code>univ</code> (as pointed to by the <code>this</code> pointer) by setting it to point to where the input parameter, <code>univ</code>, points. Look closely at the previous class definition – the identifier for the <code>University *</code> is named <code>univ</code>. Additionally, the input parameter for the <code>University *</code> in the alternate constructor is named <code>univ</code>. We cannot simply assign <code>univ = univ;</code> in the body of this constructor (or in the member initialization list). The <code>univ</code> identifier that is in the most local scope is the input parameter, <code>univ</code>. Assigning <code>univ = univ;</code> would set this parameter to itself. Instead, we disambiguate the <code>univ</code> on the left-hand side of this assignment using the <code>this</code> pointer. The statement <code>this-&gt;univ = univ;</code> sets the data member <code>univ</code> to the input parameter <code>univ</code>. Could we merely have renamed the input parameter something different, such as <code>u</code>? Sure, but it is important to understand how to disambiguate an input parameter and data member with the same identifier when the need arises to do so.</p>
<p>Now, let’s examine the next line of code, <code>univ-&gt;EnrollStudent(this);</code>. Now that <code>univ</code> and <code>this-&gt;univ</code> point to the same object, it does not matter which is used to set the backlink. Here, <code>univ</code> calls <code>EnrollStudent()</code>, which is a public member function in the <code>University</code> class. No problem, <code>univ</code> is of type <code>University</code>. <code>University::EnrollStudent(Student *)</code> expects to be passed a pointer to a <code>Student</code> to complete the linkage on the <code>University</code> side. Luckily, the <code>this</code> pointer in our <code>Student</code> alternate constructor (the scope of the calling function) is a <code>Student *</code>. The <code>this</code> pointer (in the alternate constructor) is literally the <code>Student *</code> that we need to <a id="_idIndexMarker754"/>create the backlink. Here is another example where the explicit use of the <code>this</code> pointer is required to complete the task at hand.</p>
<p>Let’s move forward to our <code>main()</code> function:</p>
<pre class="source-code">
int main()
{
    University u1("The George Washington University");
    Student s1("Gabby", "Doone", 'A', "Miss", 3.85, "C++",
               "4225GWU", &amp;u1);
    Student s2("Giselle", "LeBrun", 'A', "Ms.", 3.45,
               "C++", "1227GWU", &amp;u1);
    Student s3("Eve", "Kendall", 'B', "Ms.", 3.71, "C++",
               "5542GWU", &amp;u1);
    cout &lt;&lt; s1.GetFirstName() &lt;<a id="_idTextAnchor479"/>&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s1.GetUniversity()</strong> &lt;&lt; endl;
    cout &lt;&lt; s2.GetFirstName() &lt;<a id="_idTextAnchor480"/>&lt; " " &lt;&lt; s2.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s2.GetUniversity()</strong> &lt;&lt; endl;
    cout &lt;&lt; s3.GetFirstName() &lt;&lt; " " &lt;&lt; s3.GetLastName();
    cout &lt;&lt; " attends " &lt;&lt; <strong class="bold">s3.GetUniversity()</strong> &lt;&lt; endl;
    <strong class="bold">u1.PrintStudents();</strong>
    return 0;
}</pre>
<p>Finally, in the previous code fragment in our <code>main()</code> function, we can create several independently existing objects, create an association between them, and then view that relationship in action.</p>
<p>First, we<a id="_idIndexMarker755"/> instantiate a <code>University</code>, namely <code>u1</code>. Next, we instantiate three <code>Student</code> objects, <code>s1</code>, <code>s2</code>, and <code>s3</code>, and associate each to <code>University u1</code>. Note that this association can be set when we instantiate a <code>Student</code>, or later on, for example, if the <code>Student</code> class supported a <code>SelectUniveristy(University *)</code> interface to do so.</p>
<p>We then print out each <code>Student</code>, along with the name of the <code>University</code> each <code>Student</code> attends. Then, we print out the student body for our <code>University</code>, <code>u1</code>. We notice that the link built between the associated objects is complete in both directions. </p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Gabby Doone attends The George Washington University
Giselle LeBrun attends The George Washington University
Eve Kendall attends The George Washington University
The George Washington University has the following students:
        Gabby Doone
        Giselle LeBrun
        Eve Kendall</pre>
<p>We’ve seen how easily associations can be set up and utilized between related objects. However, a <a id="_idIndexMarker756"/>lot of housekeeping will arise from implementing associations. Let’s move forward to understanding the necessary and related issues of reference counting and backlink maintenance, which will help with these housekeeping endeavors.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor481"/>Utilizing backlink maintenance and reference counting</h2>
<p>In the previous <a id="_idIndexMarker757"/>subsection, we have seen how to implement associations using pointers. We’ve seen how to link an object with a pointer to an object in an associated instance. And we’ve seen how to complete the circular, two-sided relationship by establishing a backlink.</p>
<p>However, as is typical for associated objects, the relationships are fluid and change over time. For example, the given <code>Student</code> body will change quite often for a given <code>University</code>, or the various <code>Course</code> set an <code>Instructor</code> will teach will change each semester. It will be typical, then, to remove a particular object’s association to another object, and perhaps associate, instead, to a different instance of that class. But, that also means that the associated object must know to remove its link to the first mentioned object. This becomes complicated.</p>
<p>For example, consider the <code>Student</code> and <code>Course</code> relationship. A <code>Student</code> is enrolled in many <code>Course</code> instances. A <code>Course</code> contains an association to many <code>Student</code> instances. This is a many-to-many association. Let’s imagine that the <code>Student</code> wishes to drop a <code>Course</code>. It is not enough for a specific <code>Student</code> instance to remove a pointer to a specific <code>Course</code> instance. Additionally, the <code>Student</code> must let the particular <code>Course</code> instance know that the <code>Student</code> in question should be removed from that <code>Course</code>’s roster. This is known as backlink maintenance. </p>
<p>Consider what would happen in the above scenario if a <code>Student</code> were to simply null out its link to the <code>Course</code> it was dropping, and do nothing further. The <code>Student</code> instance in question would be fine. However, the formerly associated <code>Course</code> instance would still contain a pointer to the <code>Student</code> in question. Perhaps this would equate to the <code>Student</code> receiving a failing grade in the <code>Course</code> as the <code>Instructor</code> still thinks the <code>Student</code> in question is enrolled, yet hasn’t been turning in their homework. In the end, the <code>Student</code> has been affected after all, with the failing grade.</p>
<p>Remember, with associated objects, one object will not delete the other when it is done with the other object. For example, when a <code>Student</code> drops a <code>Course</code>, they will not delete that <code>Course</code> – only remove their pointer to the <code>Course</code> in question (and definitely also handle the required backlink maintenance).</p>
<p>One idea to help us with overall link maintenance<a id="_idIndexMarker758"/> is to consider <strong class="bold">reference counting</strong>. The purpose of reference counting is to keep track of how many pointers may be pointing to a given instance. For example, if other objects point to a given instance, that instance should not be deleted. Otherwise, the pointers in the other object will point to deallocated memory, which will lead to numerous runtime errors. </p>
<p>Let’s consider an association with multiplicity, such as the relationship between a <code>Student</code> and a <code>Course</code>. A <code>Student</code> should keep track of how many <code>Course</code> pointers are pointing to the <code>Student</code>, that is, how many <code>Courses</code> the <code>Student</code> is taking. A <code>Student</code> should not be deleted while various <code>Courses</code> point to that <code>Student</code>. Otherwise, <code>Courses</code> will point to deleted memory. One way to handle this situation is to check within the <code>Student</code> destructor whether the object (<code>this</code>) contains any non-null pointers to <code>Course</code> instances. If the object does, it then needs to call a method through each of the active <code>Course</code> instances to request links to the <code>Student</code> be removed from each such <code>Course</code>. After each link is removed, the reference counter corresponding to the set of <code>Course</code> instances can be decremented. </p>
<p>Likewise, link maintenance should occur in the <code>Course</code> class in favor of <code>Student</code> instances. <code>Course</code> instances should not be deleted until all <code>Student</code> instances enrolled in that <code>Course</code> have been notified. Keeping a counter of how many <code>Student</code> instances point to a particular instance of a <code>Course</code> through reference counting is helpful. In this example, it is as simple as maintaining a variable to reflect the current number of <code>Student</code> instances enrolled in the <code>Course</code>. </p>
<p>We can meticulously conduct link maintenance ourselves, or we may choose to use smart pointers to manage the lifetime of an associated object. <strong class="bold">Smart pointers</strong> can be found in the C++ Standard Library. They <a id="_idIndexMarker759"/>encapsulate a pointer (that is, wrap a pointer within a class) to add smart features, including reference counting and memory management. Because smart pointers utilize templates, which we will not cover until <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, we will just mention their potential utility here. </p>
<p>We have now seen the importance of backlink maintenance and the utility of reference coun<a id="_idTextAnchor482"/>ting to fully support associations and their successful implementation. Let’s now briefly recap the OO concepts we’ve covered in this chapter – association, aggregation, and composition – before moving onward to our next chapter.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor483"/>Summary</h1>
<p>In this chapter, we have pressed forward with our pursuit of object-oriented programming by exploring various object relationships – association, aggregation, and composition. We have understood the various OO design concepts representing these relationships and have seen that C++ does not offer direct language support through keywords or specific language features to implement these concepts.</p>
<p>Nonetheless, we have learned several techniques for implementing these core OO relationships, such as embedded objects for composition and generalized aggregation, or using pointers to implement association. We have looked at the typical longevity of object existence with these relationships; for example, with aggregation, by creating and destroying its inner part (through an embedded object, or more rarely, by allocating and deallocating a pointer member). Or through the independent existence of associated objects that neither create nor destroy one another. We have also looked under the hood at the housekeeping required to implement association, particularly associations with multiplicity, by examining backlink maintenance and reference counting.</p>
<p>We have added key features to our OOP skills through understanding how to implement association, aggregation, and composition. We have seen examples of how these relationships may even be more prolific in OO designs than inheritance. By mastering these skills, we have completed our core skillset of implementing essential OO concepts in C++.</p>
<p>We are now ready to continue to <a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em>, which will begin our quest to expand our C++ programming repertoire.<a id="_idTextAnchor484"/> Let’s continue forward!</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor485"/>Questions</h1>
<ol>
<li>Add an additional <code>Student</code> constructor to the <code>University</code>/<code>Student</code> example in this chapter to accept the <code>University</code> constructor argument by reference, rather than by pointer. For example, in addition to the constructor with the signature <code>Student::Student(const string &amp;fn, const string &amp;ln, char mi, const string &amp;t, float avg, const string &amp;course, const string &amp;id, University *univ);</code>, overload this function with a similar one, but with <code>University &amp;univ</code> as the last parameter. How does this change the implicit call to this constructor? </li>
</ol>
<p>Hint: within your overloaded constructor, you will now need to take the address-of (<code>&amp;</code>) the <code>University</code> reference parameter to set the association (which is stored as a pointer). You may need to switch to object notation (<code>.</code>) to set the backlink (if you use parameter <code>univ</code>, versus data member <code>this-&gt;univ</code>).</p>
<ol>
<li value="2">Write a C++ program to implement a many-to-many association between objects of type <code>Course</code> and of type <code>Student</code>. You may choose to build on your previous programs that encapsulate <code>Student</code>. The many-to-many relationship should work as follows:<ol><li>A given <code>Student</code> may take zero to many <code>Course</code>s, and a given <code>Course</code> will associate to many <code>Student</code> instances. Encapsulate the <code>Course</code> class to minimally contain a course name, a set of pointers to associated <code>Student</code> instances, and a reference count to keep track of the number of <code>Student</code> instances that are in the <code>Course</code> (this will equate to how many <code>Student</code> instances point to a given instance of a <code>Course</code>). Add the appropriate interface to reasonably encapsulate this class.</li><li>Add to your <code>Student</code> class a set of pointers to the <code>Course</code> instances in which that <code>Student</code> is enrolled. Additionally, keep track of how many <code>Course</code> instances a given <code>Student</code> is currently enrolled. Add appropriate member functions to support this new functionality.</li><li>Model your many-sided associations using either a linked list of pointers (that is, the data part is a pointer to the associated object) or as an array of pointers to the associated objects. Note that an array will enforce a limit on the number of associated objects you can have, however, this may be reasonable because a given <code>Course</code> can only accommodate a maximum number of <code>Student</code>s and a <code>Student</code> may only enroll up to a maximum number of <code>Course</code>s per semester. If you choose the array of pointers approach, make sure your implementation includes error checking to accommodate exceeding the maximum number of associated objects in each array.</li><li>Be sure to check for simple errors, such as trying to add <code>Student</code>s to a <code>Course</code> that is full, or adding too many <code>Course</code>s to a <code>Student</code>’s schedule (assume there is an upper bound to five courses per semester).</li><li>Make sure your destructors do not delete the associated instances.</li><li>Introduce at least three <code>Student</code> objects, each of which takes two or more <code>Course</code>s. Additionally, make sure each <code>Course</code> has multiple <code>Student</code>s enrolled. Print each <code>Student</code>, including each <code>Course</code> in which they are enrolled. Likewise, print each <code>Course</code>, showing eac<a id="_idTextAnchor486"/>h <code>Student</code> enrolled in the <code>Course</code>.</li></ol></li>
<li>(Optional) Enhance your program in <em class="italic">Exercise 2</em> to gain experience with backlink maintenance and reference counting as follows:<ol><li>Implement a <code>DropCourse()</code> interface for <code>Student</code>. That is, create a <code>Student:: DropCourse(Course *)</code> method in <code>Student</code>. Here, find the <code>Course</code> the <code>Student</code> wishes to drop in their course list, but before removing the <code>Course</code>, call a method on that <code>Course</code> to remove the aforementioned <code>Student</code> (that is, <code>this</code>) from the <code>Course</code>. Hint: you can make a <code>Course::RemoveStudent(Student *)</code>) method to help with backlink removal.</li><li>Now, fully implement proper destructors. When a <code>Course</code> is destructed, have the <code>Course</code> destructor first tell each remaining associated <code>Student</code> to remove their link to that <code>Course</code>. Likewise, when a <code>Student</code> is destructed, loop through the <code>Student</code>’s course list to ask those <code>Courses</code> to remove the aforementioned <code>Student</code> (that is, <code>this</code>) from their student list. You may find reference counting in each class (that is, by checking <code>numStudents</code> or <code>numCourses</code>) helpful to see whether these tasks must be engaged.</li></ol></li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-190"><a id="_idTextAnchor487"/>Part 3: Expanding Your C++ Programming Repertoire</h1>
<p>The goal of this part is to expand your C++ programming skills, beyond the OOP skills, to encompass other critical features of C++. </p>
<p>The initial chapter in this section explores exception handling in C++ through understanding the mechanisms of <code>try</code>, <code>throw</code>, and <code>catch</code>, and through examining many examples to explore exception mechanics by delving into various exception handling scenarios. Additionally, this chapter expands exception class hierarchies with new exception classes. </p>
<p>The next chapter digs into the topics of the proper usage of friend functions and friend classes, as well as operator overloading (which may sometimes require friends), to make operations polymorphic between built-in and user defined types. </p>
<p>The subsequent chapter explores using C++ templates to help make code generic and usable for a variety of data types using template functions and template classes. Additionally, this chapter explains how operator overloading will assist in making template code extensible for virtually any data type.</p>
<p>In the next chapter, the Standard Template Library in C++ is introduced, and core STL containers such as <code>list</code>, <code>iterator</code>, <code>deque</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>, and <code>map</code> (including one using a functor) are examined. Additionally, STL algorithms and functors are introduced.</p>
<p>The final chapter in this section surveys testing OO programs and components by exploring canonical class form, creating drivers for component testing, testing classes related through inheritance, association, aggregation, and testing exception-handling mechanisms. </p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em></li>
<li><a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em></li>
<li><a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em></li>
<li><a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em></li>
<li><a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div></div>
<div><p class="hidden">Part 3: Expanding Your C++ Programming Repertoire</p>
</div>
<div><div></div>
</div>
</div></body></html>