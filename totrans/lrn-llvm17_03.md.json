["```cpp\n\nwith a, b: a * (4 + b)\n```", "```cpp\n\ncalc : (\"with\" ident (\",\" ident)* \":\")? expr ;\nexpr : term (( \"+\" | \"-\" ) term)* ;\nterm : factor (( \"*\" | \"/\") factor)* ;\nfactor : ident | number | \"(\" expr \")\" ;\nident : ([a-zAZ])+ ;\nnumber : ([0-9])+ ;\n```", "```cpp\n\n#ifndef LEXER_H\n#define LEXER_H\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n```", "```cpp\n\n    class Lexer;\n    class Token {\n      friend class Lexer;\n    public:\n      enum TokenKind : unsigned short {\n        eoi, unknown, ident, number, comma, colon, plus,\n        minus, star, slash, l_paren, r_paren, KW_with\n      };\n    ```", "```cpp\n\n    private:\n      TokenKind Kind;\n      llvm::StringRef Text;\n    public:\n      TokenKind getKind() const { return Kind; }\n      llvm::StringRef getText() const { return Text; }\n    ```", "```cpp\n\n      bool is(TokenKind K) const { return Kind == K; }\n      bool isOneOf(TokenKind K1, TokenKind K2) const {\n        return is(K1) || is(K2);\n      }\n      template <typename... Ts>\n      bool isOneOf(TokenKind K1, TokenKind K2, Ts... Ks) const {\n        return is(K1) || isOneOf(K2, Ks...);\n      }\n    };\n    ```", "```cpp\n\n    class Lexer {\n      const char *BufferStart;\n      const char *BufferPtr;\n    public:\n      Lexer(const llvm::StringRef &Buffer) {\n        BufferStart = Buffer.begin();\n        BufferPtr = BufferStart;\n      }\n      void next(Token &token);\n    private:\n      void formToken(Token &Result, const char *TokEnd,\n                     Token::TokenKind Kind);\n    };\n    #endif\n    ```", "```cpp\n\n    #include \"Lexer.h\"\n    namespace charinfo {\n    LLVM_READNONE inline bool isWhitespace(char c) {\n      return c == ' ' || c == '\\t' || c == '\\f' ||\n             c == '\\v' ||\n    c == '\\r' || c == '\\n';\n    }\n    LLVM_READNONE inline bool isDigit(char c) {\n      return c >= '0' && c <= '9';\n    }\n    LLVM_READNONE inline bool isLetter(char c) {\n      return (c >= 'a' && c <= 'z') ||\n             (c >= 'A' && c <= 'Z');\n    }\n    }\n    ```", "```cpp\n\n    void Lexer::next(Token &token) {\n      while (*BufferPtr &&\n             charinfo::isWhitespace(*BufferPtr)) {\n        ++BufferPtr;\n      }\n    ```", "```cpp\n\n      if (!*BufferPtr) {\n        token.Kind = Token::eoi;\n        return;\n      }\n    ```", "```cpp\n\n      if (charinfo::isLetter(*BufferPtr)) {\n        const char *end = BufferPtr + 1;\n        while (charinfo::isLetter(*end))\n          ++end;\n        llvm::StringRef Name(BufferPtr, end - BufferPtr);\n        Token::TokenKind kind =\n            Name == \"with\" ? Token::KW_with : Token::ident;\n        formToken(token, end, kind);\n        return;\n      }\n    ```", "```cpp\n\n      else if (charinfo::isDigit(*BufferPtr)) {\n        const char *end = BufferPtr + 1;\n        while (charinfo::isDigit(*end))\n          ++end;\n        formToken(token, end, Token::number);\n        return;\n      }\n    ```", "```cpp\n\n      else {\n        switch (*BufferPtr) {\n    #define CASE(ch, tok) \\\n    case ch: formToken(token, BufferPtr + 1, tok); break\n    CASE('+', Token::plus);\n    CASE('-', Token::minus);\n    CASE('*', Token::star);\n    CASE('/', Token::slash);\n    CASE('(', Token::Token::l_paren);\n    CASE(')', Token::Token::r_paren);\n    CASE(':', Token::Token::colon);\n    CASE(',', Token::Token::comma);\n    #undef CASE\n    ```", "```cpp\n\n        default:\n          formToken(token, BufferPtr + 1, Token::unknown);\n        }\n        return;\n      }\n    }\n    ```", "```cpp\n\n    void Lexer::formToken(Token &Tok, const char *TokEnd,\n                          Token::TokenKind Kind) {\n      Tok.Kind = Kind;\n      Tok.Text = llvm::StringRef(BufferPtr,\n                                 TokEnd - BufferPtr);\n      BufferPtr = TokEnd;\n    }\n    ```", "```cpp\n\n#ifndef PARSER_H\n#define PARSER_H\n#include \"AST.h\"\n#include \"Lexer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n```", "```cpp\n\n    class Parser {\n      Lexer &Lex;\n      Token Tok;\n      bool HasError;\n    ```", "```cpp\n\n      void error() {\n        llvm::errs() << \"Unexpected: \" << Tok.getText()\n                     << \"\\n\";\n        HasError = true;\n      }\n      void advance() { Lex.next(Tok); }\n      bool expect(Token::TokenKind Kind) {\n        if (Tok.getKind() != Kind) {\n          error();\n          return true;\n        }\n        return false;\n      }\n      bool consume(Token::TokenKind Kind) {\n        if (expect(Kind))\n          return true;\n        advance();\n        return false;\n      }\n    ```", "```cpp\n\n      AST *parseCalc();\n      Expr *parseExpr();\n      Expr *parseTerm();\n      Expr *parseFactor();\n    ```", "```cpp\n\n    public:\n      Parser(Lexer &Lex) : Lex(Lex), HasError(false) {\n        advance();\n      }\n    ```", "```cpp\n\n      bool hasError() { return HasError; }\n    ```", "```cpp\n\n      AST *parse();\n    };\n    #endif\n    ```", "```cpp\n\n    #include \"Parser.h\"\n    AST *Parser::parse() {\n      AST *Res = parseCalc();\n      expect(Token::eoi);\n      return Res;\n    }\n    ```", "```cpp\n\n    calc : (\"with\" ident (\",\" ident)* \":\")? expr ;\n    ```", "```cpp\n\n    AST *Parser::parseCalc() {\n      Expr *E;\n      llvm::SmallVector<llvm::StringRef, 8> Vars;\n    ```", "```cpp\n\n      if (Tok.is(Token::KW_with)) {\n        advance();\n    ```", "```cpp\n\n        if (expect(Token::ident))\n          goto _error;\n        Vars.push_back(Tok.getText());\n        advance();\n    ```", "```cpp\n\n        while (Tok.is(Token::comma)) {\n          advance();\n          if (expect(Token::ident))\n            goto _error;\n          Vars.push_back(Tok.getText());\n          advance();\n        }\n    ```", "```cpp\n\n        if (consume(Token::colon))\n          goto _error;\n      }\n    ```", "```cpp\n\n      E = parseExpr();\n    ```", "```cpp\n\n      if (Vars.empty()) return E;\n      else return new WithDecl(Vars, E);\n    ```", "```cpp\n\n    _error:\n      while (!Tok.is(Token::eoi))\n        advance();\n      return nullptr;\n    }\n    ```", "```cpp\n\n    Expr *Parser ::parseExpr() {\n      Expr *Left = parseTerm() ;\n      while (Tok.isOneOf(Token::plus, Token::minus)) {\n        BinaryOp::Operator Op =\n           Tok.is(Token::plus) ? BinaryOp::Plus :\n                                 BinaryOp::Minus;\n        advance();\n        Expr *Right = parseTerm();\n        Left = new BinaryOp(Op, Left, Right);\n      }\n      return Left;\n    }\n    ```", "```cpp\n\n    Expr *Parser::parseTerm() {\n      Expr *Left = parseFactor();\n      while (Tok.isOneOf(Token::star, Token::slash)) {\n        BinaryOp::Operator Op =\n            Tok.is(Token::star) ? BinaryOp::Mul :\n                                  BinaryOp::Div;\n        advance();\n        Expr *Right = parseFactor();\n        Left = new BinaryOp(Op, Left, Right);\n      }\n      return Left;\n    }\n    ```", "```cpp\n\n    Expr *Parser::parseFactor() {\n      Expr *Res = nullptr;\n      switch (Tok.getKind()) {\n      case Token::number:\n        Res = new Factor(Factor::Number, Tok.getText());\n        advance(); break;\n    ```", "```cpp\n\n      case Token::ident:\n        Res = new Factor(Factor::Ident, Tok.getText());\n        advance(); break;\n      case Token::l_paren:\n        advance();\n        Res = parseExpr();\n        if (!consume(Token::r_paren)) break;\n      default:\n        if (!Res) error();\n    ```", "```cpp\n\n        while (!Tok.isOneOf(Token::r_paren, Token::star,\n                            Token::plus, Token::minus,\n                            Token::slash, Token::eoi))\n          advance();\n      }\n      return Res;\n    }\n    ```", "```cpp\n\n    #ifndef AST_H\n    #define AST_H\n    #include \"llvm/ADT/SmallVector.h\"\n    #include \"llvm/ADT/StringRef.h\"\n    class AST;\n    class Expr;\n    class Factor;\n    class BinaryOp;\n    class WithDecl;\n    class ASTVisitor {\n    public:\n      virtual void visit(AST &){};\n      virtual void visit(Expr &){};\n      virtual void visit(Factor &) = 0;\n      virtual void visit(BinaryOp &) = 0;\n      virtual void visit(WithDecl &) = 0;\n    };\n    ```", "```cpp\n\n    class AST {\n    public:\n      virtual ~AST() {}\n      virtual void accept(ASTVisitor &V) = 0;\n    };\n    ```", "```cpp\n\n    class Expr : public AST {\n    public:\n      Expr() {}\n    };\n    ```", "```cpp\n\n    class Factor : public Expr {\n    public:\n      enum ValueKind { Ident, Number };\n    private:\n      ValueKind Kind;\n      llvm::StringRef Val;\n    public:\n      Factor(ValueKind Kind, llvm::StringRef Val)\n          : Kind(Kind), Val(Val) {}\n      ValueKind getKind() { return Kind; }\n      llvm::StringRef getVal() { return Val; }\n      virtual void accept(ASTVisitor &V) override {\n        V.visit(*this);\n      }\n    };\n    ```", "```cpp\n\n    class BinaryOp : public Expr {\n    public:\n      enum Operator { Plus, Minus, Mul, Div };\n    private:\n      Expr *Left;\n      Expr *Right;\n      Operator Op;\n    public:\n      BinaryOp(Operator Op, Expr *L, Expr *R)\n          : Op(Op), Left(L), Right(R) {}\n      Expr *getLeft() { return Left; }\n      Expr *getRight() { return Right; }\n      Operator getOperator() { return Op; }\n      virtual void accept(ASTVisitor &V) override {\n        V.visit(*this);\n      }\n    };\n    ```", "```cpp\n\n    class WithDecl : public AST {\n      using VarVector =\n                       llvm::SmallVector<llvm::StringRef, 8>;\n      VarVector Vars;\n      Expr *E;\n    public:\n      WithDecl(llvm::SmallVector<llvm::StringRef, 8> Vars,\n               Expr *E)\n          : Vars(Vars), E(E) {}\n      VarVector::const_iterator begin()\n                                    { return Vars.begin(); }\n      VarVector::const_iterator end() { return Vars.end(); }\n      Expr *getExpr() { return E; }\n      virtual void accept(ASTVisitor &V) override {\n        V.visit(*this);\n      }\n    };\n    #endif\n    ```", "```cpp\n\n#ifndef SEMA_H\n#define SEMA_H\n#include \"AST.h\"\n#include \"Lexer.h\"\nclass Sema {\npublic:\n  bool semantic(AST *Tree);\n};\n#endif\n```", "```cpp\n\n#include \"Sema.h\"\n#include \"llvm/ADT/StringSet.h\"\nnamespace {\nclass DeclCheck : public ASTVisitor {\n  llvm::StringSet<> Scope;\n  bool HasError;\n  enum ErrorType { Twice, Not };\n  void error(ErrorType ET, llvm::StringRef V) {\n    llvm::errs() << \"Variable \" << V << \" \"\n                 << (ET == Twice ? \"already\" : \"not\")\n                 << \" declared\\n\";\n    HasError = true;\n  }\npublic:\n  DeclCheck() : HasError(false) {}\n  bool hasError() { return HasError; }\n```", "```cpp\n\n  virtual void visit(Factor &Node) override {\n    if (Node.getKind() == Factor::Ident) {\n      if (Scope.find(Node.getVal()) == Scope.end())\n        error(Not, Node.getVal());\n    }\n  };\n```", "```cpp\n\n  virtual void visit(BinaryOp &Node) override {\n    if (Node.getLeft())\n      Node.getLeft()->accept(*this);\n    else\n      HasError = true;\n    if (Node.getRight())\n      Node.getRight()->accept(*this);\n    else\n      HasError = true;\n  };\n```", "```cpp\n\n  virtual void visit(WithDecl &Node) override {\n    for (auto I = Node.begin(), E = Node.end(); I != E;\n         ++I) {\n      if (!Scope.insert(*I).second)\n        error(Twice, *I);\n    }\n    if (Node.getExpr())\n      Node.getExpr()->accept(*this);\n    else\n      HasError = true;\n  };\n};\n}\n```", "```cpp\n\nbool Sema::semantic(AST *Tree) {\n  if (!Tree)\n    return false;\n  DeclCheck Check;\n  Tree->accept(Check);\n  return Check.hasError();\n}\n```", "```cpp\n\n    declare i32 @calc_read(ptr)\n    declare void @calc_write(i32)\n    ```", "```cpp\n\n    @a.str = private constant [2 x i8] c\"a\\00\"\n    ```", "```cpp\n\n    define i32 @main(i32, ptr) {\n    ```", "```cpp\n\n    entry:\n    ```", "```cpp\n\n      %2 = call i32 @calc_read(ptr @a.str)\n    ```", "```cpp\n\n      %3 = mul nsw i32 3, %2\n    ```", "```cpp\n\n      call void @calc_write(i32 %3)\n    ```", "```cpp\n\n      ret i32 0\n    }\n    ```", "```cpp\n\n#ifndef CODEGEN_H\n#define CODEGEN_H\n#include \"AST.h\"\nclass CodeGen\n{\npublic:\n void compile(AST *Tree);\n};\n#endif\n```", "```cpp\n\n    #include \"CodeGen.h\"\n    #include \"llvm/ADT/StringMap.h\"\n    #include \"llvm/IR/IRBuilder.h\"\n    #include \"llvm/IR/LLVMContext.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    ```", "```cpp\n\n    using namespace llvm;\n    ```", "```cpp\n\n    namespace {\n    class ToIRVisitor : public ASTVisitor {\n      Module *M;\n      IRBuilder<> Builder;\n      Type *VoidTy;\n      Type *Int32Ty;\n      PointerType *PtrTy;\n      Constant *Int32Zero;\n      Value *V;\n      StringMap<Value *> nameMap;\n    ```", "```cpp\n\n    public:\n      ToIRVisitor(Module *M) : M(M), Builder(M->getContext())\n      {\n        VoidTy = Type::getVoidTy(M->getContext());\n        Int32Ty = Type::getInt32Ty(M->getContext());\n        PtrTy = PointerType::getUnqual(M->getContext());\n        Int32Zero = ConstantInt::get(Int32Ty, 0, true);\n      }\n    ```", "```cpp\n\n      void run(AST *Tree) {\n        FunctionType *MainFty = FunctionType::get(\n            Int32Ty, {Int32Ty, PtrTy}, false);\n        Function *MainFn = Function::Create(\n            MainFty, GlobalValue::ExternalLinkage,\n            \"main\", M);\n    ```", "```cpp\n\n        BasicBlock *BB = BasicBlock::Create(M->getContext(),\n                                            \"entry\", MainFn);\n        Builder.SetInsertPoint(BB);\n    ```", "```cpp\n\n        Tree->accept(*this);\n    ```", "```cpp\n\n        FunctionType *CalcWriteFnTy =\n            FunctionType::get(VoidTy, {Int32Ty}, false);\n        Function *CalcWriteFn = Function::Create(\n            CalcWriteFnTy, GlobalValue::ExternalLinkage,\n            \"calc_write\", M);\n        Builder.CreateCall(CalcWriteFnTy, CalcWriteFn, {V});\n    ```", "```cpp\n\n        Builder.CreateRet(Int32Zero);\n      }\n    ```", "```cpp\n\n      virtual void visit(WithDecl &Node) override {\n        FunctionType *ReadFty =\n            FunctionType::get(Int32Ty, {PtrTy}, false);\n        Function *ReadFn = Function::Create(\n            ReadFty, GlobalValue::ExternalLinkage,\n            \"calc_read\", M);\n    ```", "```cpp\n\n        for (auto I = Node.begin(), E = Node.end(); I != E;\n             ++I) {\n    ```", "```cpp\n\n          StringRef Var = *I;\n          Constant *StrText = ConstantDataArray::getString(\n              M->getContext(), Var);\n          GlobalVariable *Str = new GlobalVariable(\n              *M, StrText->getType(),\n              /*isConstant=*/true,\n              GlobalValue::PrivateLinkage,\n              StrText, Twine(Var).concat(\".str\"));\n    ```", "```cpp\n\n          CallInst *Call =\n              Builder.CreateCall(ReadFty, ReadFn, {Str});\n    ```", "```cpp\n\n          nameMap[Var] = Call;\n        }\n    ```", "```cpp\n\n        Node.getExpr()->accept(*this);\n      };\n    ```", "```cpp\n\n      virtual void visit(Factor &Node) override {\n        if (Node.getKind() == Factor::Ident) {\n          V = nameMap[Node.getVal()];\n        } else {\n          int intval;\n          Node.getVal().getAsInteger(10, intval);\n          V = ConstantInt::get(Int32Ty, intval, true);\n        }\n      };\n    ```", "```cpp\n\n      virtual void visit(BinaryOp &Node) override {\n        Node.getLeft()->accept(*this);\n        Value *Left = V;\n        Node.getRight()->accept(*this);\n        Value *Right = V;\n        switch (Node.getOperator()) {\n        case BinaryOp::Plus:\n          V = Builder.CreateNSWAdd(Left, Right); break;\n        case BinaryOp::Minus:\n          V = Builder.CreateNSWSub(Left, Right); break;\n        case BinaryOp::Mul:\n          V = Builder.CreateNSWMul(Left, Right); break;\n        case BinaryOp::Div:\n          V = Builder.CreateSDiv(Left, Right); break;\n        }\n      };\n    };\n    }\n    ```", "```cpp\n\n    void CodeGen::compile(AST *Tree) {\n      LLVMContext Ctx;\n      Module *M = new Module(\"calc.expr\", Ctx);\n      ToIRVisitor ToIR(M);\n      ToIR.run(Tree);\n      M->print(outs(), nullptr);\n    }\n    ```", "```cpp\n\n    #include \"CodeGen.h\"\n    #include \"Parser.h\"\n    #include \"Sema.h\"\n    #include \"llvm/Support/CommandLine.h\"\n    #include \"llvm/Support/InitLLVM.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    ```", "```cpp\n\n    static llvm::cl::opt<std::string>\n        Input(llvm::cl::Positional,\n              llvm::cl::desc(\"<input expression>\"),\n              llvm::cl::init(\"\"));\n    ```", "```cpp\n\n    int main(int argc, const char **argv) {\n      llvm::InitLLVM X(argc, argv);\n      llvm::cl::ParseCommandLineOptions(\n          argc, argv, \"calc - the expression compiler\\n\");\n    ```", "```cpp\n\n      Lexer Lex(Input);\n      Parser Parser(Lex);\n      AST *Tree = Parser.parse();\n      if (!Tree || Parser.hasError()) {\n        llvm::errs() << \"Syntax errors occured\\n\";\n        return 1;\n      }\n    ```", "```cpp\n\n      Sema Semantic;\n      if (Semantic.semantic(Tree)) {\n        llvm::errs() << \"Semantic errors occured\\n\";\n        return 1;\n      }\n    ```", "```cpp\n\n      CodeGen CodeGenerator;\n      CodeGenerator.compile(Tree);\n      return 0;\n    }\n    ```", "```cpp\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid calc_write(int v)\n{\n  printf(\"The result is: %d\\n\", v);\n}\n```", "```cpp\n\nint calc_read(char *s)\n{\n  char buf[64];\n  int val;\n  printf(\"Enter a value for %s: \", s);\n  fgets(buf, sizeof(buf), stdin);\n  if (EOF == sscanf(buf, \"%d\", &val))\n  {\n    printf(\"Value %s is invalid\\n\", buf);\n    exit(1);\n  }\n  return val;\n}\n```", "```cpp\n\n    cmake_minimum_required (VERSION 3.20.0)\n    project (\"calc\")\n    ```", "```cpp\n\n    find_package(LLVM REQUIRED CONFIG)\n    message(\"Found LLVM ${LLVM_PACKAGE_VERSION}, build type ${LLVM_BUILD_TYPE}\")\n    list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})\n    ```", "```cpp\n\n    separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})\n    add_definitions(${LLVM_DEFINITIONS_LIST})\n    include_directories(SYSTEM ${LLVM_INCLUDE_DIRS})\n    llvm_map_components_to_libnames(llvm_libs Core)\n    ```", "```cpp\n\n    add_subdirectory (\"src\")\n    ```", "```cpp\n\nadd_executable (calc\n  Calc.cpp CodeGen.cpp Lexer.cpp Parser.cpp Sema.cpp)\ntarget_link_libraries(calc PRIVATE ${llvm_libs})\n```", "```cpp\n\n$ cmake -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_DIR=<path to llvm installation configuration> ../\n$ ninja\n```", "```cpp\n\n$ calc \"with a: a*3\" | llc –filetype=obj \\\n  -relocation-model=pic  –o=expr.o\n$ clang –o expr expr.o rtcalc.c\n$ expr\nEnter a value for a: 4\nThe result is: 12\n```", "```cpp\n\n$ calc \"with a: a*3\" | llc –filetype=obj –o=expr.obj\n$ cl expr.obj rtcalc.c\n$ expr\nEnter a value for a: 4\nThe result is: 12\n```"]