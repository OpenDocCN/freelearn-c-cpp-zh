["```cpp\nlayout (local_size_x = 32, local_size_y = 1, local_size_z =\n        1) in;\nvoid main() {\n    if (gl_GlobalInvocationID.x == 0 ) {\n        for ( uint i = 0; i < NUM_LIGHTS; ++i ) {\n            per_light_meshlet_instances[i * 2] = 0;\n            per_light_meshlet_instances[i * 2 + 1] = 0;\n        }\n    }\n    global_shader_barrier();\n```", "```cpp\n    uint light_index = gl_GlobalInvocationID.x %\n                       active_lights;\n    if (light_index >= active_lights) {\n        return;\n    }\n    const Light = lights[light_index];\n```", "```cpp\n    uint mesh_instance_index = gl_GlobalInvocationID.x /\n                               active_lights;\n    if (mesh_instance_index >= num_mesh_instances) {\n        return;\n    }\n    uint mesh_draw_index = mesh_instance_draws\n                           [mesh_instance_index].\n                           mesh_draw_index;\n    // Skip transparent meshes\n    MeshDraw mesh_draw = mesh_draws[mesh_draw_index];\n    if ( ((mesh_draw.flags & (DrawFlags_AlphaMask |\n           DrawFlags_Transparent)) != 0 ) ){\n        return;\n    }\n```", "```cpp\n    vec4 bounding_sphere = mesh_bounds[mesh_draw_index];\n    mat4 model = mesh_instance_draws\n                 [mesh_instance_index].model;\n    // Calculate mesh instance bounding sphere\n    vec4 mesh_world_bounding_center = model * vec4\n        (bounding_sphere.xyz, 1);\n    float scale = length( model[0] );\n    float mesh_radius = bounding_sphere.w * scale * 1.1;\n    // Artificially inflate bounding sphere\n    // Check if mesh is inside light\n    const bool mesh_intersects_sphere =\n    sphere_intersect(mesh_world_bounding_center.xyz,\n        mesh_radius, light.world_position, light.radius )\n            || disable_shadow_meshes_sphere_cull();\n    if (!mesh_intersects_sphere) {\n        return;\n    }\n```", "```cpp\n    uint per_light_offset =\n        atomicAdd(per_light_meshlet_instances[light_index],\n            mesh_draw.meshlet_count);\n    // Mesh inside light, add meshlets\n    for ( uint m = 0; m < mesh_draw.meshlet_count; ++m ) {\n        uint meshlet_index = mesh_draw.meshlet_offset + m;\n         meshlet_instances[light_index *\n             per_light_max_instances + per_light_offset\n                 + m] = uvec2( mesh_instance_index,\n                     meshlet_index );\n    }\n}\n```", "```cpp\nlayout (local_size_x = 32, local_size_y = 1, local_size_z =\n        1) in;\nvoid main() {\n    if (gl_GlobalInvocationID.x == 0 ) {\n        // Use this as atomic int\n        per_light_meshlet_instances[NUM_LIGHTS] = 0;\n    }\n    global_shader_barrier();\n```", "```cpp\n    // Each thread writes the command of a light.\n    uint light_index = gl_GlobalInvocationID.x;\n    if ( light_index >= active_lights ) {\n        return;\n    }\n```", "```cpp\n    // Write per light shadow data\n    const uint visible_meshlets =\n        per_light_meshlet_instances[light_index];\n    if (visible_meshlets > 0) {\n        const uint command_offset =\n            atomicAdd(per_light_meshlet_instances[\n                NUM_LIGHTS], 6);\n        uint packed_light_index = (light_index & 0xffff)\n                                   << 16;\n        meshlet_draw_commands[command_offset] =\n            uvec4( ((visible_meshlets + 31) / 32), 1, 1,\n                packed_light_index | 0 );\n        meshlet_draw_commands[command_offset + 1] =\n            uvec4( ((visible_meshlets + 31) / 32), 1, 1,\n                packed_light_index | 1 );\n   ... same for faces 2 to 5.\n    }\n}\n```", "```cpp\nuint get_cube_face_mask( vec3 cube_map_pos, vec3 aabb_min,\n                         vec3 aabb_max ) {\n    vec3 plane_normals[] = {\n        vec3(-1, 1, 0), vec3(1, 1, 0), vec3(1, 0, 1),\n            vec3(1, 0, -1), vec3(0, 1, 1), vec3(0, -1, 1)\n    };\n    vec3 abs_plane_normals[] = {\n        vec3(1, 1, 0), vec3(1, 1, 0), vec3(1, 0, 1),\n            vec3(1, 0, 1), vec3(0, 1, 1), vec3(0, 1, 1) };\n    vec3 aabb_center = (aabb_min + aabb_max) * 0.5f;\n    vec3 center = aabb_center - cube_map_pos;\n    vec3 extents = (aabb_max - aabb_min) * 0.5f;\n    bool rp[ 6 ];\n    bool rn[ 6 ];\n    for ( uint  i = 0; i < 6; ++i ) {\n        float dist = dot( center, plane_normals[ i ] );\n        float radius = dot( extents, abs_plane_normals[ i ]\n        );\n        rp[ i ] = dist > -radius;\n        rn[ i ] = dist < radius;\n    }\n    uint fpx = (rn[ 0 ] && rp[ 1 ] && rp[ 2 ] && rp[ 3 ] &&\n                aabb_max.x > cube_map_pos.x) ? 1 : 0;\n    uint fnx = (rp[ 0 ] && rn[ 1 ] && rn[ 2 ] && rn[ 3 ] &&\n                aabb_min.x < cube_map_pos.x) ? 1 : 0;\n    uint fpy = (rp[ 0 ] && rp[ 1 ] && rp[ 4 ] && rn[ 5 ] &&\n                aabb_max.y > cube_map_pos.y) ? 1 : 0;\n    uint fny = (rn[ 0 ] && rn[ 1 ] && rn[ 4 ] && rp[ 5 ] &&\n                aabb_min.y < cube_map_pos.y) ? 1 : 0;\n    uint fpz = (rp[ 2 ] && rn[ 3 ] && rp[ 4 ] && rp[ 5 ] &&\n                aabb_max.z > cube_map_pos.z) ? 1 : 0;\n    uint fnz = (rn[ 2 ] && rp[ 3 ] && rn[ 4 ] && rn[ 5 ] &&\n                aabb_min.z < cube_map_pos.z) ? 1 : 0;\n    return fpx | ( fnx << 1 ) | ( fpy << 2 ) | ( fny << 3 )\n    | ( fpz << 4 ) | ( fnz << 5 );\n}\n```", "```cpp\nout taskNV block {\n    uint meshlet_indices[32];\n     uint light_index_face_index;\n};\nvoid main() {\n    uint task_index = gl_LocalInvocationID.x;\n     uint meshlet_group_index = gl_WorkGroupID.x;\n```", "```cpp\n    // Calculate meshlet and light indices\n    const uint meshlet_index = meshlet_group_index * 32 +\n                               task_index;\n```", "```cpp\n    uint packed_light_index_face_index =\n        meshlet_draw_commands[gl_DrawIDARB].w;\n    const uint light_index =\n        packed_light_index_face_index >> 16;\n    const uint meshlet_index_read_offset =\n        light_index * per_light_max_instances;\n```", "```cpp\nuint global_meshlet_index = \n   meshlet_instances[meshlet_index_read_offset + \n   meshlet_index].y; \n   uint mesh_instance_index =\n        meshlet_instances[meshlet_index_read_offset +\n            meshlet_index].x;\n```", "```cpp\n    const uint face_index = (packed_light_index_face_index\n                             & 0xf);\n    mat4 model = mesh_instance_draws[mesh_instance_index]\n                 .model;\n```", "```cpp\n    vec4 world_center = model * vec4(meshlets\n                        [global_meshlet_index].center, 1);\n    float scale = length( model[0] );\n    float radius = meshlets[global_meshlet_index].radius *\n                   scale * 1.1;   // Artificially inflate\n                                     bounding sphere\nvec3 cone_axis = \n   mat3( model ) * vec3(int(meshlets \n   [global_meshlet_index].cone_axis[0]) / 127.0, \n   int(meshlets[global_meshlet_index]. \n   cone_axis[1]) / 127.0, \n   int(meshlets[global_meshlet_index]. \n   cone_axis[2]) / 127.0); \n   float cone_cutoff = int(meshlets[global_meshlet_index].\n                           cone_cutoff) / 127.0;\n    bool accept = false;\n    const vec4 camera_sphere = camera_spheres[light_index];\n    // Cone cull\n    accept = !coneCull(world_center.xyz, radius, cone_axis,\n             cone_cutoff, camera_sphere.xyz) ||\n             disable_shadow_meshlets_cone_cull();\n    // Sphere culling\n    if ( accept ) {\n        accept = sphere_intersect( world_center.xyz,\n                 radius, camera_sphere.xyz,\n                 camera_sphere.w) ||\n                 disable_shadow_meshlets_sphere_cull();\n    }\n    // Cubemap face culling\n    if ( accept ) {\n        uint visible_faces =\n        get_cube_face_mask( camera_sphere.xyz,\n            world_center.xyz - vec3(radius),\n                world_center.xyz + vec3(radius));\n        switch (face_index) {\n            case 0:\n                accept = (visible_faces & 1) != 0;\n                break;\n            case 1:\n                accept = (visible_faces & 2) != 0;\n                break;\n...same for faces 2 to 5.\n                    }\n        accept = accept || disable_shadow_meshlets_cubemap\n                 _face_cull();\n    }\n```", "```cpp\n         uvec4 ballot = subgroupBallot(accept);\n    uint index = subgroupBallotExclusiveBitCount(ballot);\n    if (accept)\n        meshlet_indices[index] = global_meshlet_index;\n    uint count = subgroupBallotBitCount(ballot);\n    if (task_index == 0)\n        gl_TaskCountNV = count;\n```", "```cpp\n        light_index_face_index =\n            packed_light_index_face_index;\n}\n```", "```cpp\nvoid main() {\n   ...\n    const uint light_index = light_index_face_index >> 16;\n    const uint face_index = (light_index_face_index & 0xf);\n    const int layer_index = int(CUBE_MAP_COUNT *\n                                light_index + face_index);\n    for (uint i = task_index; i < vertex_count; i +=\n       32)    {\n        uint vi = meshletData[vertexOffset + i];\n        vec3 position = vec3(vertex_positions[vi].v.x,\n                        vertex_positions[vi].v.y,\n                        vertex_positions[vi].v.z);\n        gl_MeshVerticesNV[ i ].gl_Position =\n        view_projections[layer_index] *\n           (model * vec4(position, 1));\n    }\n    uint indexGroupCount = (indexCount + 3) / 4;\n    for (uint i = task_index; i < indexGroupCount; i += 32) {\n        writePackedPrimitiveIndices4x8NV(i * 4,\n            meshletData[indexOffset + i]);\n    }\n```", "```cpp\n     gl_MeshPrimitivesNV[task_index].gl_Layer =\n         layer_index;\n    gl_MeshPrimitivesNV[task_index + 32].gl_Layer =\n        layer_index;\n    gl_MeshPrimitivesNV[task_index + 64].gl_Layer =\n        layer_index;\n    gl_MeshPrimitivesNV[task_index + 96].gl_Layer =\n        layer_index;\n    if (task_index == 0) {\n        gl_PrimitiveCountNV =\n            uint(meshlets[global_meshlet_index]\n                .triangle_count);\n    }\n}\n```", "```cpp\n    vec3 shadow_position_to_light = world_position –\n                                    light.world_position;\nconst float closest_depth =\n    texture(global_textures_cubemaps_array\n    [nonuniformEXT(cubemap_shadows_index)],\n    vec4(shadow_position_to_light,\n    shadow_light_index)).r;\n```", "```cpp\n    const float current_depth = vector_to_depth_value\n                                (shadow_position_to_light,\n                                 light.radius);\n    float shadow = current_depth - bias < closest_depth ?\n                   1 : 0;\n```", "```cpp\nfloat vector_to_depth_value( inout vec3 Vec, float radius) {\n    vec3 AbsVec = abs(Vec);\n    float LocalZcomp = max(AbsVec.x, max(AbsVec.y,\n                           AbsVec.z));\n    const float f = radius;\n    const float n = 0.01f;\n    float NormZComp = -(f / (n - f) - (n * f) / (n - f) /\n                        LocalZcomp);\n    return NormZComp;\n}\n```", "```cpp\nVkImageCreateInfo image_info = {\n    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };\nimage_info.flags = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT |\n                   VK_IMAGE_CREATE_SPARSE_BINDING_BIT;\n```", "```cpp\nVkPhysicalDeviceSparseImageFormatInfo2 format_info{\n    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT\n        _INFO_2 };\nformat_info.format = texture->vk_format;\nformat_info.type = to_vk_image_type( texture->type );\nformat_info.samples = VK_SAMPLE_COUNT_1_BIT;\nformat_info.usage = texture->vk_usage;\nformat_info.tiling = VK_IMAGE_TILING_OPTIMAL;\n```", "```cpp\nArray<VkSparseImageFormatProperties2> properties;\nvkGetPhysicalDeviceSparseImageFormatProperties2(\n    vulkan_physical_device, &format_info, &property_count,\n        properties.data );\nu32 block_width = properties[ 0 ].properties.\n                  imageGranularity.width;\nu32 block_height = properties[ 0 ].properties.\n                   imageGranularity.height;\n```", "```cpp\nVkMemoryRequirements memory_requirements{ };\nvkGetImageMemoryRequirements( vulkan_device, texture->\n                              vk_image,\n                              &memory_requirements );\n```", "```cpp\nu32 block_count = pool_size / ( block_width * block_height );\n```", "```cpp\nVmaAllocationCreateInfo allocation_create_info{ };\nallocation_create_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;\nVkMemoryRequirements page_memory_requirements;\npage_memory_requirements.memoryTypeBits =\n    memory_requirements.memoryTypeBits;\npage_memory_requirements.alignment =\n    memory_requirements.alignment;\npage_memory_requirements.size =\n    memory_requirements.alignment;\nvmaAllocateMemoryPages( vma_allocator,\n                        &page_memory_requirements,\n                        &allocation_create_info,\n                        block_count, page_pool->\n                        vma_allocations.data, nullptr );\n```", "```cpp\n    for ( u32 l = 0; l < light_count; ++l ) {\n    ```", "```cpp\n        Light& light = scene->lights[ l ];\n    ```", "```cpp\n        vec4s aabb_min_view = glms_mat4_mulv(\n    ```", "```cpp\n                              last_camera.view,\n    ```", "```cpp\n                              light.aabb_min );\n    ```", "```cpp\n        vec4s aabb_max_view = glms_mat4_mulv(\n    ```", "```cpp\n                              last_camera.view,\n    ```", "```cpp\n                              light.aabb_max );\n    ```", "```cpp\n        lights_aabb_view[ l * 2 ] = vec3s{\n    ```", "```cpp\n            aabb_min_view.x, aabb_min_view.y,\n    ```", "```cpp\n                aabb_min_view.z };\n    ```", "```cpp\n        lights_aabb_view[ l * 2 + 1 ] = vec3s{\n    ```", "```cpp\n            aabb_max_view.x, aabb_max_view.y,\n    ```", "```cpp\n                aabb_max_view.z };\n    ```", "```cpp\n    }\n    ```", "```cpp\n    vec4s max_point_screen = vec4s{ f32( ( x + 1 ) *\n    ```", "```cpp\n                             tile_size ), f32( ( y + 1 ) *\n    ```", "```cpp\n                             tile_size ), 0.0f, 1.0f };\n    ```", "```cpp\n                             // Top Right\n    ```", "```cpp\n    vec4s min_point_screen = vec4s{ f32( x * tile_size ),\n    ```", "```cpp\n                             f32( y * tile_size ),\n    ```", "```cpp\n                             0.0f, 1.0f }; // Top Right\n    ```", "```cpp\n    vec3s max_point_view = screen_to_view(\n    ```", "```cpp\n                           max_point_screen );\n    ```", "```cpp\n    vec3s min_point_view = screen_to_view(\n    ```", "```cpp\n                           min_point_screen );\n    ```", "```cpp\n    f32 tile_near = z_near * pow( z_ratio, f32( z ) *\n    ```", "```cpp\n                                  z_bin_range );\n    ```", "```cpp\n    f32 tile_far  = z_near * pow( z_ratio, f32( z + 1 ) *\n    ```", "```cpp\n                                  z_bin_range );\n    ```", "```cpp\n    vec3s min_point_near = line_intersection_to_z_plane(\n    ```", "```cpp\n                           eye_pos, min_point_view,\n    ```", "```cpp\n                           tile_near );\n    ```", "```cpp\n    vec3s min_point_far  = line_intersection_to_z_plane(\n    ```", "```cpp\n                           eye_pos, min_point_view,\n    ```", "```cpp\n                           tile_far );\n    ```", "```cpp\n    vec3s max_point_near = line_intersection_to_z_plane(\n    ```", "```cpp\n                           eye_pos, max_point_view,\n    ```", "```cpp\n                           tile_near );\n    ```", "```cpp\n    vec3s max_point_far  = line_intersection_to_z_plane(\n    ```", "```cpp\n                           eye_pos, max_point_view,\n    ```", "```cpp\n                           tile_far );\n    ```", "```cpp\n    vec3s min_point_aabb_view = glms_vec3_minv( glms_vec3_minv( min_point_near, min_point_far ), glms_vec3_minv( max_point_near, max_point_far ) );\n    ```", "```cpp\n    vec3s max_point_aabb_view = glms_vec3_maxv( glms_vec3_maxv( min_point_near, min_point_far ), glms_vec3_maxv( max_point_near, max_point_far ) );\n    ```", "```cpp\n    f32 minx = min( min( light_aabb_min.x,\n    ```", "```cpp\n                    light_aabb_max.x ), min(\n    ```", "```cpp\n                    min_point_aabb_view.x,\n    ```", "```cpp\n                    max_point_aabb_view.x ) );\n    ```", "```cpp\n    f32 miny = min( min( light_aabb_min.y,\n    ```", "```cpp\n                    light_aabb_max.y ), min(\n    ```", "```cpp\n                    min_point_aabb_view.y,\n    ```", "```cpp\n                    max_point_aabb_view.y ) );\n    ```", "```cpp\n    f32 minz = min( min( light_aabb_min.z,\n    ```", "```cpp\n                    light_aabb_max.z ), min(\n    ```", "```cpp\n                    min_point_aabb_view.z,\n    ```", "```cpp\n                    max_point_aabb_view.z ) );\n    ```", "```cpp\n    f32 maxx = max( max( light_aabb_min.x,\n    ```", "```cpp\n                    light_aabb_max.x ), max(\n    ```", "```cpp\n                    min_point_aabb_view.x,\n    ```", "```cpp\n                    max_point_aabb_view.x ) );\n    ```", "```cpp\n    f32 maxy = max( max( light_aabb_min.y,\n    ```", "```cpp\n                    light_aabb_max.y ), max(\n    ```", "```cpp\n                    min_point_aabb_view.y,\n    ```", "```cpp\n                    max_point_aabb_view.y ) );\n    ```", "```cpp\n    f32 maxz = max( max( light_aabb_min.z,\n    ```", "```cpp\n                    light_aabb_max.z ), max(\n    ```", "```cpp\n                    min_point_aabb_view.z,\n    ```", "```cpp\n                    max_point_aabb_view.z ) );\n    ```", "```cpp\n    f32 dx = abs( maxx - minx );\n    ```", "```cpp\n    f32 dy = abs( maxy - miny );\n    ```", "```cpp\n    f32 dz = abs( maxz - minz );\n    ```", "```cpp\n    f32 allx = abs( light_aabb_max.x - light_aabb_min.x )\n    ```", "```cpp\n               + abs( max_point_aabb_view.x –\n    ```", "```cpp\n               min_point_aabb_view.x );\n    ```", "```cpp\n    f32 ally = abs( light_aabb_max.y - light_aabb_min.y )\n    ```", "```cpp\n               + abs( max_point_aabb_view.y –\n    ```", "```cpp\n               min_point_aabb_view.y );\n    ```", "```cpp\n    f32 allz = abs( light_aabb_max.z - light_aabb_min.z )\n    ```", "```cpp\n               + abs( max_point_aabb_view.z –\n    ```", "```cpp\n               min_point_aabb_view.z );\n    ```", "```cpp\n     bool intersects = ( dx <= allx ) && ( dy < ally ) &&\n    ```", "```cpp\n                       ( dz <= allz );\n    ```", "```cpp\nf32 d = glms_vec2_distance( sphere_screen, tile_center );\nf32 diff = d * d - tile_radius_sq;\nif ( diff < 1.0e-4 ) {\n    continue;\n}\nf32 solid_angle = ( 2.0f * rpi ) * ( 1.0f - ( sqrtf(\n                    diff ) / d ) );\nf32 resolution = sqrtf( ( 4.0f * rpi * tile_pixels ) /\n                        ( 6 * solid_angle ) );\n```", "```cpp\n    VkImageAspectFlags aspect = TextureFormat::has_depth(\n    ```", "```cpp\n    texture->vk_format ) ? VK_IMAGE_ASPECT_DEPTH_BIT : VK_IMAGE_ASPECT_COLOR_BIT;\n    ```", "```cpp\n    for ( u32 block_y = 0; block_y < num_blocks_y;\n    ```", "```cpp\n          ++block_y ) {\n    ```", "```cpp\n          for ( u32 block_x = 0; block_x < num_blocks_x;\n    ```", "```cpp\n                ++block_x ) {\n    ```", "```cpp\n                    VkSparseImageMemoryBind sparse_bind{ };\n    ```", "```cpp\n                    VmaAllocation allocation = \n    ```", "```cpp\n                       page_pool-> vma_allocations\n    ```", "```cpp\n                          [ page_pool->used_pages++ ];\n    ```", "```cpp\n                    VmaAllocationInfo allocation_info{ };\n    ```", "```cpp\n                    vmaGetAllocationInfo( vma_allocator,\n    ```", "```cpp\n                                          allocation,\n    ```", "```cpp\n                                          &allocation_info );\n    ```", "```cpp\n            i32 dest_x = ( i32 )( block_x * block_width +\n    ```", "```cpp\n                                  x );\n    ```", "```cpp\n            i32 dest_y = ( i32 )( block_y * block_height +\n    ```", "```cpp\n                                  y );\n    ```", "```cpp\n            sparse_bind.subresource.aspectMask = aspect;\n    ```", "```cpp\n            sparse_bind.subresource.arrayLayer = layer;\n    ```", "```cpp\n            sparse_bind.offset = { dest_x, dest_y, 0 };\n    ```", "```cpp\n            sparse_bind.extent = { block_width,\n    ```", "```cpp\n                                   block_height, 1 };\n    ```", "```cpp\n            sparse_bind.memory =\n    ```", "```cpp\n                allocation_info.deviceMemory;\n    ```", "```cpp\n            sparse_bind.memoryOffset =\n    ```", "```cpp\n                allocation_info.offset;\n    ```", "```cpp\n            pending_sparse_queue_binds.push( sparse_bind\n    ```", "```cpp\n                                           );\n    ```", "```cpp\n        }\n    ```", "```cpp\n    }\n    ```", "```cpp\n    SparseMemoryBindInfo bind_info{ };\n    ```", "```cpp\n    bind_info.image = texture->vk_image;\n    ```", "```cpp\n    bind_info.binding_array_offset = array_offset;\n    ```", "```cpp\n    bind_info.count = num_blocks;\n    ```", "```cpp\n    pending_sparse_memory_info.push( bind_info );\n    ```", "```cpp\n    for ( u32 b = 0; b < pending_sparse_memory_info.size;\n    ```", "```cpp\n          ++b ) {\n    ```", "```cpp\n        SparseMemoryBindInfo& internal_info =\n    ```", "```cpp\n            pending_sparse_memory_info[ b ];\n    ```", "```cpp\n        VkSparseImageMemoryBindInfo& info =\n    ```", "```cpp\n            sparse_binding_infos[ b ];\n    ```", "```cpp\n        info.image = internal_info.image;\n    ```", "```cpp\n        info.bindCount = internal_info.count;\n    ```", "```cpp\n        info.pBinds = pending_sparse_queue_binds.data +\n    ```", "```cpp\n                      internal_info.binding_array_offset;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    VkBindSparseInfo sparse_info{\n    ```", "```cpp\n        VK_STRUCTURE_TYPE_BIND_SPARSE_INFO };\n    ```", "```cpp\n    sparse_info.imageBindCount =\n    ```", "```cpp\n        sparse_binding_infos.size;\n    ```", "```cpp\n    sparse_info.pImageBinds = sparse_binding_infos.data;\n    ```", "```cpp\n    sparse_info.signalSemaphoreCount = 1;\n    ```", "```cpp\n    sparse_info.pSignalSemaphores =\n    ```", "```cpp\n        &vulkan_bind_semaphore;\n    ```", "```cpp\n    vkQueueBindSparse( vulkan_main_queue, 1, &sparse_info,\n    ```", "```cpp\n                       VK_NULL_HANDLE );\n    ```"]