# 第2章。创建精灵

在本章中，我们将创建精灵、动画和动作。本章将涵盖以下主题：

+   创建精灵

+   获取精灵的位置和大小

+   操作精灵

+   创建动画

+   创建动作

+   控制动作

+   调用带动作的函数

+   缓动动作

+   使用纹理图集

+   使用批节点

+   使用3D模型

+   检测碰撞

+   绘制形状

# 简介

精灵是2D图像。我们可以通过改变它们的属性来动画化和变换它们。精灵基本上是项目中的项目，没有它们您的游戏就不完整。精灵不仅被显示，还可以被变换或移动。在本章中，您将学习如何使用Cocos2d-x中的3D模型创建精灵，然后我们将探讨精灵的优势。

# 创建精灵

精灵是游戏中最重要的东西。它们是在屏幕上显示的图像。在本食谱中，您将学习如何创建精灵并显示它。

## 准备工作

您可以通过以下步骤将上一章制作的图像添加到项目中：

1.  将图像复制到`Resource`文件夹`MyGame/Resources/res`中。

1.  在Xcode中打开您的项目。

1.  从Xcode菜单转到**产品** | **清理**。

当您将新图像添加到`resource`文件夹时，您必须进行清理和构建。如果您在添加新图像后没有进行清理，那么Xcode将无法识别它们。最后，在您将`run_01.png`添加到项目中后，您的项目看起来将如下截图所示：

![准备工作](img/B00561_02_01.jpg)

## 如何操作...

我们从以下代码中修改`HelloWorld::init`方法开始：

[PRE0]

然后，在我们构建并运行项目之后，我们可以看到以下内容：

![如何操作...](img/B00561_02_02.jpg)

## 它是如何工作的...

您可以从`Director::getWinSize`方法获取屏幕大小。`Director`类是一个单例类。您可以使用`getInstance`方法获取其实例。因此，您可以通过`Director::getInstance->getWinSize()`获取屏幕大小。

### 小贴士

请注意，您可以使用`getInstance`方法在Cocos2d-x中获取单例类的实例。

精灵是由图像组成的。您可以通过指定图像来创建精灵。在这种情况下，您通过`res`文件夹中的`run_01.png`创建精灵。

接下来，您需要指定精灵的坐标。在这种情况下，您将精灵设置在屏幕中心。`Size`类具有宽度和高度属性。您可以使用`setPosition`方法指定精灵的位置。`setPosition`方法的参数是`Vec2`。`Vec2`有两个属性，作为浮点向量，`x`轴坐标和`y`轴坐标。

最后一步是将精灵添加到图层上。图层就像屏幕上的透明纸。您将在[第4章](ch04.html "第4章。构建场景和图层")中了解图层，*构建场景和图层*。

屏幕上显示的所有对象都是**节点**。精灵和层是节点的类型。如果您在其他节点中没有添加它，该节点将不会显示在屏幕上。您可以通过`addChild`方法在其他节点中添加节点。

## 更多内容...

您可以使用静态坐标设置精灵。在以下情况下，我们看到精灵位置是`(100, 200)`。

[PRE1]

此外，您可以使用C++运算符重载将精灵设置在屏幕中心。

[PRE2]

如果您想从层中移除精灵，可以使用以下代码移除它：

[PRE3]

## 相关内容

`Sprite`类有很多属性。您可以操作它们并更改精灵的外观。您还将了解更多关于层和场景的内容，这些内容将在[第4章](ch04.html "第4章. 构建场景和层") *构建场景和层* 中解释。

# 获取精灵的位置和大小

精灵有一个特定的尺寸和位置。在本菜谱中，我们解释了如何查看精灵的尺寸和位置。

## 如何操作...

要获取精灵位置，请使用以下代码：

[PRE4]

要获取精灵大小，请使用以下代码：

[PRE5]

## 工作原理...

默认情况下，精灵位置是(`0,0`)。您可以使用`setPosition`方法更改精灵位置，并使用`getPosition`方法获取它。您可以使用`getContentSize`方法获取精灵大小。但是，您不能通过`setContentSize`方法更改精灵大小。`contentsize`是一个常量值。如果您想更改精灵大小，您必须更改精灵的缩放。您将在下一个菜谱中了解缩放。

## 更多内容...

### 设置锚点

**锚点**是一个您设置的点，用作指定在设置位置时将使用精灵的哪个部分。锚点使用左下角坐标系。默认情况下，所有Node对象的锚点为`(0.5, 0.5)`。这意味着默认锚点是中心。

要获取精灵中心的锚点，我们使用以下代码：

[PRE6]

要获取精灵左下角的锚点，我们使用以下代码：

[PRE7]

要获取精灵左上角的锚点，我们使用以下代码：

[PRE8]

要获取精灵右下角的锚点，我们使用以下代码：

[PRE9]

要获取精灵右上角的锚点，我们使用以下代码：

[PRE10]

以下图像显示了锚点的各种位置：

![设置锚点](img/B00561_02_03.jpg)

### 矩形

要获取精灵矩形，请使用以下代码：

[PRE11]

`Rect`是具有`Size`和`Vec2`等属性的精灵矩形。如果缩放不等于一，则`Rect`中的`Size`将不等于`size`，使用`getContentSize`方法。`getContentSize`的`Size`是原始图像大小。另一方面，`Rect`中使用`getBoundingBox`的`Size`是外观的大小。例如，当您将精灵设置为半缩放时，`Rect`中使用`getBoundingBox`的`Size`是大小的一半，而使用`getContentSize`的`Size`是原始大小。精灵的位置和大小在您需要指定屏幕上的精灵时是一个非常重要的点。

## 相关内容

+   *检测碰撞*配方，您可以使用`rect`检测碰撞。

# 操作精灵

精灵是一个可以通过改变其属性（包括旋转、位置、缩放、颜色等）进行动画或变换的2D图像。创建精灵后，您可以访问其各种属性，并进行操作。

## 如何做...

### 旋转

您可以将精灵的旋转更改为正或负度数。

[PRE12]

您可以使用`getRotation`方法获取旋转值。

[PRE13]

正值将其顺时针旋转，负值将其逆时针旋转。默认值是零。以下代码将精灵旋转30度顺时针，如下截图所示：

![旋转](img/B00561_02_04.jpg)

### 缩放

您可以更改精灵的缩放。默认值是`1.0f`，原始大小。以下代码将缩放到一半大小。

[PRE14]

您还可以分别更改宽度和高度。以下代码只会将宽度缩放到一半。

[PRE15]

以下代码只会将高度缩放到一半。

[PRE16]

以下代码将宽度缩放到两倍，高度缩放到一半。

[PRE17]

![缩放](img/B00561_02_05.jpg)

### 倾斜

您可以通过`X`、`Y`或同时针对`X`和`Y`均匀地更改精灵的倾斜。对于`X`和`Y`，默认值都是零。

以下代码将`X`倾斜调整为`20.0`：

[PRE18]

以下代码将`Y`倾斜调整为`20.0`：

[PRE19]

![倾斜](img/B00561_02_06.jpg)

### 颜色

您可以通过传递`Color3B`对象来更改精灵的颜色。`Color3B`具有RGB值。

[PRE20]

![颜色](img/B00561_02_07.jpg)

### 透明度

您可以更改精灵的不透明度。不透明度属性设置为0到255之间的值。

[PRE21]

当精灵设置为255时，它是完全不透明的，当设置为零时，它是完全透明的。默认值始终是255。

![透明度](img/B00561_02_08.jpg)

### 可见性

您可以通过传递布尔值来更改精灵的可见性。如果它是`false`，则精灵不可见；如果它是`true`，则精灵可见。默认值始终是`true`。

[PRE22]

### 小贴士

如果您想检查精灵的可见性，请使用`isVisible`方法而不是`getVisible`方法。精灵类没有`getVisible`方法。

[PRE23]

## 它是如何工作的...

精灵有许多属性。您可以使用`setter`和`getter`方法操作精灵。

RGB颜色是从0到255的3字节值。Cocos2d-x提供了预定义的颜色。

[PRE24]

您可以通过查看Cocos2d-x中的`ccType.h`文件来找到它们。

# 创建动画

当游戏中的角色开始移动时，游戏将变得生动。有许多方法可以制作动画角色。在这个菜谱中，我们将通过使用多个图像来动画化一个角色。

## 准备工作

您可以从以下一系列图像文件创建动画：

![准备工作](img/B00561_02_09.jpg)

您需要将跑步女孩的动画图像文件添加到您的项目中，并清理您的项目。

### 小贴士

请查看本章节的第一个菜谱*创建精灵*，了解如何将图像添加到您的项目中。

## 如何做...

您可以使用一系列图像创建动画。以下代码创建了跑步女孩的动画。

[PRE25]

## 工作原理...

您可以使用`Animation`类和`Animate`类创建动画。它们以固定的时间间隔更改多个图像。系列图像文件的名称有序列号，我们在for循环中为`Animation`类添加了文件名。我们可以使用Cocos2d-x中的`StringUtils`类创建格式化的字符串。

### 小贴士

`StringUtils`是一个非常有用的类。`StringUtils::toString`方法可以从各种值生成`std::string`值。

[PRE26]

`StringUtils::format`方法可以使用`printf`格式生成`std::string`值。

您可以通过使用CCLOG宏来查看日志。CCLOG非常有用。您可以在游戏执行期间检查日志中的变量值。CCLOG具有与`sprintf`函数相同的参数。

我们将使用`addSpriteFrameWithFile`方法将文件名添加到`Animation`实例中。它使用`setDelayPerunit`方法设置帧所占用的时间单位。使用`setRestoreOriginalFrame`方法设置为动画结束时恢复原始帧。真值是恢复原始帧。它设置为动画将要循环的次数。然后，通过传递您之前创建的`Animation`实例来创建`Animate`实例。最后，通过传递`Animate`实例来运行`runAction`方法。

如果您想永远运行动画，请使用`setLoops`方法设置`-1`。

[PRE27]

## 还有更多...

在前面的代码中，您无法控制每个动画帧。在这种情况下，您可以使用`AnimationFrame`类。这个类可以控制每个动画帧。您可以使用`AnimationFrame::create`方法的第二个参数设置帧所占用的时间单位。

[PRE28]

## 相关内容

+   *使用纹理图集创建动画*的菜谱

# 创建动作

Cocos2d-x有很多动作，例如移动、跳跃、旋转等。我们在游戏中经常使用这些动作。这类似于动画，当游戏中的角色开始动作时，游戏将变得生动。在这个菜谱中，您将学习如何使用许多动作。

## 如何做...

动作是游戏中非常重要的效果。Cocos2d-x 允许你使用各种动作。

### 移动

要在两秒内通过指定点移动精灵，你可以使用以下命令：

[PRE29]

要在两秒内将精灵移动到指定点，你可以使用以下命令：

[PRE30]

### 缩放

要在两秒内以 3x 的比例均匀缩放精灵，请使用以下命令：

[PRE31]

要在两秒内将 `X` 轴缩放 5x 和 `Y` 轴缩放 3x，请使用以下命令：

[PRE32]

要在两秒内以 3x 的比例均匀缩放精灵，请使用以下命令：

[PRE33]

要在两秒内将 `X` 轴缩放 5x 和 `Y` 轴缩放 3x，请使用以下命令：

[PRE34]

### 跳跃

要使精灵在两秒内跳过指定点三次，请使用以下命令：

[PRE35]

要使精灵在两秒内跳到指定点三次，请使用以下命令：

[PRE36]

### 旋转

要在两秒内顺时针旋转精灵 40 度，请使用以下命令：

[PRE37]

要在两秒内逆时针旋转精灵 40 度，请使用以下命令：

[PRE38]

### 闪烁

要使精灵在两秒内闪烁五次，请使用以下命令：

[PRE39]

### 淡入

要在两秒内淡入精灵，请使用以下命令：

[PRE40]

要在两秒内淡出精灵，请使用以下命令：

[PRE41]

### 扭曲

以下代码在两秒内将精灵的 `X` 轴扭曲 45 度和 `Y` 轴扭曲 30 度：

[PRE42]

以下代码在两秒内将精灵的 `X` 轴扭曲到 45 度和 `Y` 轴扭曲到 30 度。

[PRE43]

### 着色

以下代码通过指定的 RGB 值着色精灵：

[PRE44]

以下代码将精灵着色到指定的 RGB 值：

[PRE45]

## 它是如何工作的...

`Action` 对象使精灵改变其属性。`MoveTo`、`MoveBy`、`ScaleTo`、`ScaleBy` 等都是 `Action` 对象。你可以使用 `MoveTo` 或 `MoveBy` 将精灵从一个位置移动到另一个位置。

你会注意到每个 `Action` 都有一个 `By` 和 `To` 后缀。这就是它们有不同的行为的原因。带有 `By` 后缀的方法是相对于精灵的当前状态。带有 `To` 后缀的方法是相对于精灵的绝对状态。你知道 Cocos2d-x 中的所有动作都有 `By` 和 `To` 后缀，并且所有动作都有与其后缀相同的规则。

## 还有更多...

当你想执行精灵动作时，你创建一个动作并通过传递 `action` 实例来执行 `runAction` 方法。如果你想在精灵运行动作时停止动作，请执行 `stopAllActions` 方法或通过传递 `runAction` 方法的返回值作为 `action` 实例的 `stopAction`。

[PRE46]

如果你运行 `stopAllActions`，精灵正在运行的所有动作都将停止。如果你通过传递 `action` 实例来运行 `stopAction`，则将停止该特定动作。

# 控制动作

在之前的菜谱中，你学习了一些基本动作。然而，你可能想要使用更复杂的行为；例如，在移动时旋转角色，或者在跳跃后移动角色。在这个菜谱中，你将学习如何控制动作。

## 如何做到...

### 按顺序执行动作

`Sequence` 是一系列要按顺序执行的动作。这可以是一系列任意数量的动作。

[PRE47]

以下命令将按顺序执行以下动作：

+   在两秒内将精灵向右移动100像素

+   在两秒内顺时针旋转精灵360度

执行这些命令总共需要四秒。

### 生成动作

`Spawn` 与 `Sequence` 非常相似，不同之处在于所有动作将同时运行。你可以同时指定任意数量的动作。

[PRE48]

它将同时执行以下动作：

+   在两秒内将精灵向右移动100像素

+   顺时针旋转精灵360度

执行它们总共需要两秒。

### 重复动作

`Repeat` 对象是为了重复指定次数的动作。

[PRE49]

以下命令将执行一个 `rotate` 动作五次。

如果你想要无限重复，可以使用 `RepeatForever` 动作。

[PRE50]

### 反转动作

如果你生成一个 `action` 实例，你可以调用一个 `reverse` 方法以相反的动作运行。

[PRE51]

以下代码将按顺序执行以下动作：

+   在两秒内将精灵向右移动100像素。

+   在两秒内将精灵向左移动100像素。

此外，如果你生成一个序列动作，你可以调用一个 `reverse` 方法以相反的顺序运行它。

[PRE52]

以下代码将按顺序执行以下动作：

+   在两秒内将精灵向右移动100像素。

+   在两秒内顺时针旋转精灵360度

+   在两秒内逆时针旋转精灵360度

+   在两秒内将精灵向左移动100像素。

### DelayTime

`DelayTime` 是在指定秒数内延迟的动作。

[PRE53]

以下命令将按顺序执行以下动作：

+   在两秒内将精灵向右移动100像素

+   延迟下一个动作两秒

+   在两秒内顺时针旋转精灵360度

执行它总共需要六秒。

## 它是如何工作的...

`Sequence` 动作按顺序执行动作。你可以通过按顺序添加动作来生成一个 `Sequence` 实例。此外，你还需要指定 `nullptr` 作为最后一个参数。如果你没有指定 `nullptr`，你的游戏将会崩溃。

![如何工作...](img/B00561_02_10.jpg)

`Spawn` 动作同时运行动作。你可以像 `Sequence` 动作一样，通过添加动作和 `nullptr` 来生成一个 `Spawn` 实例。

![如何工作...](img/B00561_02_11.jpg)

`Repeat` 和 `RepeatForever` 动作可以运行，重复执行相同的动作。`Repeat` 动作有两个参数，即重复的动作和重复的次数。`RepeatForever` 动作有一个参数，即重复的动作，这就是为什么它会无限运行。

大多数动作，包括 `Sequence`、`Spawn` 和 `Repeat`，都有 `reverse` 方法。但像带有后缀 `To` 的 `MoveTo` 方法一样，它没有 `reverse` 方法；这就是为什么它不能运行反向动作。`Reverse` 方法生成其反向动作。以下代码使用了 `MoveBy::reverse` 方法。

[PRE54]

`DelayTime` 动作可以在此之后延迟一个动作。`DelayTime` 动作的好处是您可以将其放入 `Sequence` 动作中。结合 `DelayTime` 和 `Sequence` 是一个非常强大的功能。

## 更多内容...

`Spawn` 产生的结果与运行多个连续的 `runAction` 语句相同。

[PRE55]

然而，`Spawn` 的好处是您可以将其放入 `Sequence` 动作中。结合 `Spawn` 和 `Sequence` 是一个非常强大的功能。

[PRE56]

![更多内容...](img/B00561_02_12.jpg)

# 使用动作调用函数

您可能希望通过触发某些动作来调用一个函数。例如，您正在控制序列动作、跳跃和移动，并且想要为跳跃动作使用一个声音。在这种情况下，您可以通过触发这个跳跃动作来调用一个函数。在这个菜谱中，您将学习如何通过动作调用一个函数。

## 如何操作...

Cocos2d-x 有一个 `CallFunc` 对象，允许您创建一个函数并将其传递到您的 `Sequence` 中运行。这允许您向您的 `Sequence` 动作添加自己的功能。

[PRE57]

前面的命令将按顺序执行以下动作：

+   将精灵向右移动 100 像素，持续两秒

+   将精灵顺时针旋转 360 度，持续两秒

+   执行 CCLOG

## 工作原理...

`CallFunc` 动作通常用作回调函数。例如，如果您想在 `move` 动作完成后执行不同的过程。使用 `CallFunc`，您可以在任何时间调用方法。您可以使用 lambda 表达式作为回调函数。

如果您收到带有参数的回调，其代码如下：

[PRE58]

此参数的实例是运行动作的精灵。您可以通过将其转换为 `Sprite` 类来获取精灵实例。

然后，您还可以指定一个回调方法。`CallFunc` 有 `CC_CALLBACK_0` 宏作为参数。`CC_CALLBACK_0` 是一个用于调用不带参数的方法的宏。如果您想调用一个带有一个参数的方法，您需要使用 `CallFuncN` 动作和 `CC_CALLBACK_1` 宏。`CC_CALLBACK_1` 是一个用于调用一个参数的方法的宏。由 `CallFuncN` 调用的方法的参数是 `Ref` 类。

您可以使用以下代码调用一个方法：

[PRE59]

要使用参数调用一个方法，您可以使用以下代码：

[PRE60]

## 更多内容...

要组合 `CallFuncN` 和 `Reverse` 动作，请使用以下代码：

[PRE61]

前面的命令将按顺序执行以下动作：

+   将精灵向右移动 100 像素，持续两秒

+   将精灵顺时针旋转 360 度，持续两秒

+   将精灵向左移动 100 像素，持续两秒

# 缓动动作

**缓动**是通过指定加速度来动画化，以使动画平滑。缓动动作是模拟游戏中的物理效果的好方法。如果您在动画中使用缓动动作，您的游戏看起来将更加自然，动画也更加平滑。

## 如何做到...

让我们使用加速度和减速度将一个`Sprite`对象从`(200,200)`移动到`(500,200)`。

[PRE62]

接下来，让我们从屏幕顶部掉下一个`Sprite`对象，并使其弹跳。

[PRE63]

## 工作原理...

动画的持续时间与您是否使用缓动无关。`EaseIn`、`EaseOut`和`EaseInOut`有两个参数——第一个参数是缓动动作，第二个参数是缓动速率。如果您将此参数指定为`1.0f`，则此缓动动作与不使用缓动相同。任何大于`1.0f`的值，表示缓动速度快，小于`1.0f`，缓动速度将变慢。

下表列出了典型的缓动类型。

| 类名 | 描述 |
| --- | --- |
| `EaseIn` | 在加速的同时移动。 |
| `EaseOut` | 在减速的同时移动。 |
| `EaseInOut` | 在加速的同时开始移动，在减速时停止。 |
| `EaseExponentialIn` | 它与`EaseIn`类似，但意味着以指数曲线的速度加速。它也像`EaseIn`一样与`Out`和`InOut`一起使用。 |
| `EaseSineIn` | 它与`EaseIn`类似，但意味着以正弦曲线的速度加速。它也像`EaseIn`一样与`Out`和`InOut`一起使用。 |
| `EaseElasticIn` | 在慢慢摇动后移动，逐渐移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。 |
| `EaseBounceIn` | 在弹跳后移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。 |
| `EaseBackIn` | 在相反方向移动后开始移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。 |

这是一个显示典型缓动函数的图表：

![工作原理...](img/B00561_02_13.jpg)

# 使用纹理图集

**纹理图集**是一个包含每个精灵集合的大图像。我们通常使用纹理图集而不是单个图像。在本教程中，您将学习如何使用纹理图集。

## 准备工作

您必须将纹理图集文件添加到您的项目中，并清理您的项目。

+   `running.plist`

+   `running.png`

## 如何做到...

让我们尝试读取纹理图集文件，并从中创建一个精灵。

[PRE64]

## 工作原理...

首先，我们加载了纹理图集文件，当`SpritFrameCache`类缓存了其中包含的所有图像。其次，您生成了一个精灵。不要使用`Sprite::create`方法来生成它，而是使用`Sprite::createWithSpriteFrameName`方法。然后，您可以像处理普通精灵一样处理该精灵。

纹理图集是一个包含多个图像的大图像。它由一个 `plist` 文件和一个 `texture` 文件组成。您可以使用工具创建纹理图集。您将在第 10 章 [使用额外功能改进游戏](ch10.html "第 10 章。使用额外功能改进游戏") 中学习如何使用工具创建纹理图集，*使用额外功能改进游戏*。`plist` 文件定义为图像的原始文件名，它位于 `texture` 文件中。它还定义了纹理图集将使用的图像。纹理图集的 `plist` 文件是 xml 格式，如下所示。

[PRE65]

![它是如何工作的...](img/B00561_02_14.jpg)

为什么我们会使用纹理图集？因为高效使用内存是好的。当计算机将图像加载到内存中时，需要双倍的内存大小。例如，有十个大小为 100x100 的图像。我们将使用九个图像，但一个图像需要 128x128 大小的内存。另一方面，纹理图集是一个包含九个图像的图像，其大小为 1000x1000。它需要 1024x1024 的内存大小。这就是为什么使用纹理图集来节省不必要的内存使用。

## 还有更多...

纹理图集的大小在使用中会根据设备而变化。您可以在以下代码中检查设备的最大纹理大小：

[PRE66]

您可以使用纹理图集和 `plist` 文件生成动画。首先，您需要将 `run_animation.plist` 文件添加到您的项目中。该文件如下截图所示：

![还有更多...](img/B00561_02_15.jpg)

这个 `plist` 定义了一个帧动画。在这种情况下，我们使用从 `run_01.png` 到 `run_08.png` 的图像定义了一个名为 `run` 的动画。如果您将 `-1` 指定给 `loop` 键的值，动画将无限循环。纹理图集指定为 `running.plist`。

其次，您需要使用 `plist` 文件生成动画。

[PRE67]

您还需要使用 `AnimationCache::addAnimationWithFile` 方法缓存动画数据，使用动画 `plist`。接下来，您将通过指定在 `plist` 中定义为动画名称的 `run` 来生成一个 `Animation` 实例。然后，您从动画中生成一个动作。之后，您可以使用动作实例通过 `runAction` 方法进行动画处理。

## 相关内容

手动创建纹理图集非常困难。您最好使用像 `TexturePacker` 这样的工具，您将在第 11 章 [利用优势](ch11.html "第 11 章。利用优势") 中了解它。

# 使用批处理节点

如果屏幕上有许多精灵，渲染速度会变慢。然而，射击游戏需要很多图像，如子弹等。在这种情况下，如果渲染速度慢，游戏会得到不好的评价。在本章中，您将学习如何控制许多精灵。

## 如何做到这一点...

让我们尝试使用 `SpriteBatchNode` 显示许多精灵。

[PRE68]

## 它是如何工作的...

`SpriteBatchNode` 实例可用于以下操作：

+   使用纹理生成 `SpriteBatchNode` 实例

+   在层上添加实例

+   使用 `SpriteBatchNode` 实例中的纹理生成精灵

+   在 `SpriteBatchNode` 实例上添加这些精灵

`SpriteBatchNode` 只能引用一个纹理（一个图像文件或一个纹理图集）。只有包含在该纹理中的精灵可以添加到 `SpriteBatchNode` 中。所有添加到 `SpriteBatchNode` 的精灵都会在一个 OpenGL ES 绘制调用中绘制。如果精灵没有添加到 `SpriteBatchNode`，则需要为每个精灵进行一个 OpenGL ES 绘制调用，这效率较低。

## 更多...

以下截图是执行屏幕图像。您可以在左下角看到关于 Cocos2d-x 的三条信息。最上面一行是多边形的顶点数。中间一行是 OpenGL ES 绘制调用的次数。您理解到许多精灵可以通过一个 OpenGL ES 绘制调用来绘制。最下面一行是每帧帧数和每帧秒数。

![更多...](img/B00561_02_16.jpg)

### 小贴士

如果您想隐藏此调试信息，应将 `Director::setDisplayStats` 方法的值设置为 `false`。您可以在项目的 `AppDelegate.cpp` 中找到它。

[PRE69]

自 Cocos2d-x 版本 3 以来，绘制调用的 `auto batch` 功能已被添加，Cocos2d-x 可以通过一个 OpenGL ES 绘制调用绘制许多精灵，无需 `SpriteBatchNode`。然而，它有以下条件：

+   相同的纹理

+   相同的 `BlendFunc`

# 使用 3D 模态

Cocos2d-x 版本 3 支持一个令人兴奋的新功能，称为 **3D 模态**。我们可以在 Cocos2d-x 中使用和显示 3D 模态。在本教程中，您将学习如何使用 3D 模态。

## 准备工作

您必须将 3D 对象数据添加到您的项目中，并清理您的项目。在 `COCOS_ROOT/test/cpp-tests/Resources/Sprite3DTest` 文件夹中存在的资源文件是—`body.png` 和 `girl.c3b`

## 如何做...

让我们尝试显示一个 3D 模型并移动它。

[PRE70]

![如何做...](img/B00561_02_17.jpg)

## 它是如何工作的...

您可以像创建 2D 精灵并显示它一样，从 3D 模型创建 3D 精灵。`Placement` 方法和 `action` 方法与 2D 精灵中看到的方法完全相同。您可以从 3D 模型中定义的动画数据创建 `Animation3D` 实例。

## 更多...

最后，您将尝试将 3D 精灵向左或向右移动。当您运行以下代码时，您会注意到 3D 精灵的外观取决于它们在屏幕上的位置：

[PRE71]

## 参见

您可以使用 obj、c3b 和 c3t 等三维数据格式。其中“c3t”代表 Cocos 3d 二进制。您可以通过转换 `fbx` 文件来获取这种格式的数据。

# 检测碰撞

在动作游戏中，一个非常重要的技术是检测每个精灵之间的碰撞。然而，检测 `rect` 和 `rect` 或 `rect` 和 `point` 之间的碰撞相当复杂。在本教程中，您将学习如何轻松地检测碰撞。

## 如何做...

有两种检测碰撞的方法。第一种方法检查一个点是否包含在精灵的矩形内。

[PRE72]

第二种方法检查两个精灵的矩形是否重叠。

[PRE73]

## 它是如何工作的...

`Rect`类有两个属性——`size`和`origin`。`size`属性是精灵的大小。`origin`属性是精灵的左下角坐标。首先，你使用`getBoundingBox`方法获取精灵的`rect`。

![它是如何工作的...](img/B00561_02_18.jpg)

通过指定坐标使用`Rect::containsPoint`方法，可以检测它是否包含矩形。如果包含，该方法返回`true`。通过指定另一个矩形使用`Rect::intersectsRect`方法，可以检测它们是否重叠。如果重叠，该方法返回`true`。

下图显示了`rect`和`point`或`rect`和`rect`之间的碰撞：

![它是如何工作的...](img/B00561_02_19.jpg)

## 还有更多...

`Rect`类有更多方法，包括`getMinX`、`getMidX`、`getMaxX`、`getMinY`、`getMidY`、`getMaxY`和`unionWithRect`。你可以使用这些方法中的每一个来获取以下图中的值。

![还有更多...](img/B00561_02_20.jpg)

## 相关内容

+   如果你使用了物理引擎，你可以以不同的方式检测碰撞。查看[第9章](ch09.html "第9章。控制物理")，*控制物理*。

+   如果你想要考虑图像的透明部分来检测碰撞，请查看[第11章](ch11.html "第11章。利用优势")，*利用优势*。

# 绘制形状

在Cocos2d-x中，使用`DrawNode`类绘制形状可以变得简单。如果你可以使用`DrawNode`绘制各种形状，你将需要为这些形状准备纹理。在本节中，你将学习如何不使用纹理来绘制形状。

## 如何操作...

首先，你创建了一个`DrawNode`实例，如下面的代码所示。你也得到了窗口大小。

[PRE74]

### 绘制点

你可以通过指定点、半径和颜色来绘制点。

[PRE75]

![绘制点](img/B00561_02_21.jpg)

### 绘制线条

你可以通过指定起点、终点和颜色来绘制线条。使用`drawLine`方法时，将绘制一个`1px`粗的线条。如果你想绘制更粗的线条，请使用带有给定半径的`drawSegment`方法。

[PRE76]

![绘制线条](img/B00561_02_22.jpg)

### 绘制圆形

你可以像以下代码所示绘制圆形。参数的指定如下：

+   中心位置

+   半径

+   角度

+   段数

+   是否绘制到中心

+   缩放X轴

+   缩放Y轴

+   颜色

[PRE77]

![绘制圆形](img/B00561_02_23.jpg)

段数是多边形的顶点数。正如你所知，圆是一个具有许多顶点的多边形。增加顶点数接近于平滑的圆，但过程负载会增加。顺便说一句，如果你想得到一个实心圆，你应该使用`drawSolidCircle`方法。

### 绘制三角形

你可以使用以下代码，通过三个顶点和颜色绘制一个三角形。

[PRE78]

![绘制三角形](img/B00561_02_24.jpg)

### 绘制矩形

你可以使用以下代码，通过左下角点、右上角点和颜色绘制矩形。如果你使用`drawSolidRect`方法，你可以绘制填充颜色。

[PRE79]

![绘制矩形](img/B00561_02_25.jpg)

### 绘制多边形

你可以使用以下代码，通过给定的顶点、顶点数量、填充颜色、边框宽度和边框颜色绘制一个多边形。

[PRE80]

![绘制多边形](img/B00561_02_26.jpg)

### 绘制贝塞尔曲线

你可以使用以下代码绘制一个贝塞尔曲线，如所示。使用`drawQuadBezier`方法，你可以绘制一个二次贝塞尔曲线，使用`drawCubicBezier`方法你可以绘制一个三次贝塞尔曲线。`drawQuadBezier`方法的第三个参数和`drawCubicBezier`方法的第四个参数与圆一样，表示顶点数量。

[PRE81]

![绘制贝塞尔曲线](img/B00561_02_27.jpg)

## 它是如何工作的...

`DrawNode`就像一个机制，使得Cocos2d-x能够以高速处理，通过一次性绘制所有形状而不是分别或逐个绘制。当你绘制多个形状时，你应该使用一个`DrawNode`实例，而不是多个`DrawNode`实例并在其中添加多个形状。此外，`DrawNode`没有深度概念。Cocos2d-x将按照添加到`DrawNode`中的形状顺序进行绘制。
