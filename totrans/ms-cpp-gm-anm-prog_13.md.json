["```cpp\nstruct OGLMorphVertex {\n  glm::vec4 position = glm::vec4(0.0f);\n  glm::vec4 normal = glm::vec4(0.0f);\n}; \n```", "```cpp\nstruct OGLMorphMesh {\n  std::vector<OGLMorphVertex> morphVertices{};\n}; \n```", "```cpp\nstruct OGLMesh {\n  ...\n **std::vector<OGLMorphMesh> morphMeshes{};**\n}; \n```", "```cpp\n int animMeshCount = mesh->mNumAnimMeshes;\n  if (animMeshCount > 0) { \n```", "```cpp\n for (unsigned int i = 0; i < animMeshCount; ++i) {\n      aiAnimMesh* animMesh = mesh->mAnimMeshes[i];\n      unsigned int mAninVertexCount =\n        animMesh->mNumVertices; \n```", "```cpp\n if (animVertexCount != mVertexCount) {\n        Logger::log(1, \"%s error: morph mesh %i vertex\n          count does not match (orig mesh has %i vertices,\n          morph mesh %i)\\n\",\n      __  FUNCTION__, i, mVertexCount, animVertexCount);\n        continue;\n      } \n```", "```cpp\n if (animMesh->HasPositions()) {\n        OGLMorphMesh newMorphMesh{}; \n```", "```cpp\n for (unsigned int i = 0; i < animVertexCount; ++i) {\n          OGLMorphVertex vertex;\n          vertex.position.x = animMesh->mVertices[i].x;\n          vertex.position.y = animMesh->mVertices[i].y;\n          vertex.position.z = animMesh->mVertices[i].z; \n```", "```cpp\n if (animMesh->HasNormals()) {\n            vertex.normal.x = animMesh->mNormals[i].x;\n            vertex.normal.y = animMesh->mNormals[i].y;\n            vertex.normal.z = animMesh->mNormals[i].z;\n          } else {\n            vertex.normal = glm::vec4(0.0f);\n          } \n```", "```cpp\n newMorphMesh.morphVertices.emplace_back(vertex);\n        }\n        mMesh.morphMeshes.emplace_back(newMorphMesh);\n      }\n    }\n  } \n```", "```cpp\n unsigned int mNumAnimatedMeshes = 0;\n    unsigned int mAnimatedMeshVertexSize = 0;\n    ShaderStorageBuffer mAnimMeshVerticesBuffer{}; \n```", "```cpp\n for (const auto& mesh : mModelMeshes) {\n    if (mesh.morphMeshes.size() == 0) {\n      continue;\n    } \n```", "```cpp\n OGLMorphMesh animMesh;\n    animMesh.morphVertices.resize(\n      mesh.vertices.size() * mNumAnimatedMeshes); \n```", "```cpp\n for (unsigned int i = 0; i < mNumAnimatedMeshes; ++i) {\n      unsigned int vertexOffset = mesh.vertices.size() * i;\n      std::copy(mesh.morphMeshes[i].morphVertices.begin(),\n        mesh.morphMeshes[i].morphVertices.end(),\n        animMesh.morphVertices.begin() + vertexOffset);\n      mAnimatedMeshVertexSize = mesh.vertices.size();\n    } \n```", "```cpp\n mAnimMeshVerticesBuffer.uploadSsboData(\n      animMesh.morphVertices);\n  } \n```", "```cpp\nvoid AssimpModel::bindMorphAnimBuffer(int bindingPoint) {\n  mAnimMeshVerticesBuffer.bind(bindingPoint);\n} \n```", "```cpp\nenum class faceAnimation : uint8_t {\n  none = 0,\n  angry,\n  worried,\n  surprised,\n  happy\n}; \n```", "```cpp\n std::unordered_map<faceAnimation, std::string>\n    micFaceAnimationNameMap{}; \n```", "```cpp\n faceAnimation isFaceAnimType = faceAnimation::none;\n  float isFaceAnimWeight = 0.0f; \n```", "```cpp\n std::vector<glm::vec4> mFaceAnimPerInstanceData{};\n    ShaderStorageBuffer mFaceAnimPerInstanceDataBuffer{}; \n```", "```cpp\nstd::vector<glm::vec4> mFaceAnimPerInstanceData{};\nVkShaderStorageBufferData mFaceAnimPerInstanceDataBuffer{}; \n```", "```cpp\n for (const auto& model : mModelInstCamData.micModelList) {\n  ...\n **mFaceAnimPerInstanceData.****resize****(numberOfInstances);**\n      ...\n      for (size_t i = 0; i < numberOfInstances; ++i) { \n```", "```cpp\n glm::vec4 morphData = glm::vec4(0.0f);\n    if (instSettings.isFaceAnimType !=\n      faceAnimation::none)  { \n```", "```cpp\n morphData.x = instSettings.isFaceAnimWeight;\n      morphData.y =\n        static_cast<int>(instSettings.isFaceAnimType) – 1;\n      morphData.z = model->getAnimMeshVertexSize(); \n```", "```cpp\n }\n    mFaceAnimPerInstanceData.at(i) = morphData; \n```", "```cpp\n Shader mAssimpSkinningMorphShader{};\n    Shader mAssimpSkinningMorphSelectionShader{}; \n```", "```cpp\nVkPipelineLayout rdAssimpSkinningMorphPipelineLayout;\nVkPipelineLayout\n  rdAssimpSkinningMorphSelectionPipelineLayout;\nVkPipeline rdAssimpSkinningMorphPipeline;\nVkPipeline rdAssimpSkinningMorphSelectionPipeline;\nVkDescriptorSetLayout\n  rdAssimpSkinningMorphSelectionDescriptorLayout;\nVkDescriptorSetLayout\n  rdAssimpSkinningMorphPerModelDescriptorLayout;\nVkDescriptorSet rdAssimpSkinningMorphDescriptorSet;\nVkDescriptorSet\n  rdAssimpSkinningMorphSelectionDescriptorSet; \n```", "```cpp\nstruct MorphVertex {\n  vec4 position;\n  vec4 normal;\n}; \n```", "```cpp\nlayout (std430, binding = 4) readonly restrict\n    buffer AnimMorphBuffer {\n  MorphVertex morphVertices[];\n};\nlayout (std430, binding = 5) readonly restrict\n    buffer AnimMorphData {\n  vec4 vertsPerMorphAnim[];\n}; \n```", "```cpp\n int morphAnimIndex =\n    int(vertsPerMorphAnim[gl_InstanceID].y *\n        vertsPerMorphAnim[gl_InstanceID].z); \n```", "```cpp\n vec4 origVertex = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n  vec4 morphVertex = vec4(morphVertices[gl_VertexID +\n    morphAnimOffset].position.xyz, 1.0) \n```", "```cpp\n gl_Position = projection * view * worldPosSkinMat *\n    mix(origVertex, morphVertex,\n    vertsPerMorphAnim[gl_InstanceID].x); \n```", "```cpp\n vec4 origNormal =\n    vec4(aNormal.x, aNormal.y, aNormal.z, 1.0);\n  vec4 morphNormal =\n    vec4(morphVertices[gl_VertexID +\n    morphAnimOffset].normal.xyz, 1.0);\n  normal = transpose(inverse(worldPosSkinMat)) *\n    mix(origNormal, morphNormal,\n    vertsPerMorphAnim[gl_InstanceID].x); \n```", "```cpp\n void drawInstancedNoMorphAnims(int instanceCount);\n    void drawInstancedMorphAnims(int instanceCount); \n```", "```cpp\n for (unsigned int i = 0; i < mModelMeshes.size(); ++i) {\n    if (mModelMeshes.at(i).morphMeshes.size() > 0) {\n      continue;\n    }\n    OGLMesh& mesh = mModelMeshes.at(i);\n    drawInstanced(mesh, i, instanceCount);\n  } \n```", "```cpp\n ...\n    if (mModelMeshes.at(i).morphMeshes.size() == 0) {\n      continue;\n    ...\n    } \n```", "```cpp\n**model->****drawInstancedNoMorphAnims****(numberOfInstances);** \n```", "```cpp\n if (model->hasAnimMeshes()) {\n        mAssimpSkinningMorphShader.use();\n        ...\n        model->bindMorphAnimBuffer(4);\n        mFaceAnimPerInstanceDataBuffer.uploadSsboData(\n          mFaceAnimPerInstanceData, 5);\n        model->drawInstancedMorphAnims(numberOfInstances);\n      } \n```", "```cpp\n if (settings.isFaceAnimType != faceAnimation::none) {\n    out << YAML::Key << \"face-anim-index\";\n    out << YAML::Value << settings.isFaceAnimType;\n    out << YAML::Key << \"face-anim-weight\";\n    out << YAML::Value << settings.isFaceAnimWeight;\n  } \n```", "```cpp\nYAML::Emitter& operator<<(YAML::Emitter& out,\n    const faceAnimation& faceAnim) {\n  out << YAML::Flow;\n  out << static_cast<int>(faceAnim);\n  return out;\n} \n```", "```cpp\ntemplate<>\nstruct convert<faceAnimation> {\n  static bool decode(const Node& node, faceAnimation& rhs) {\n      rhs = static_cast<faceAnimation>(node.as<int>());\n      return true;\n    }\n  }; \n```", "```cpp\n if (node[\"face-anim\"]) {\n        rhs.isFaceAnimType =\n          node[\"face-anim\"].as<faceAnimation>();\n        rhs.isFaceAnimWeight =\n          node[\"face-anim-weight\"].as<float>();\n      } \n```", "```cpp\n if (rhs.isFaceAnimType != faceAnimation::none) {\n        node[\"face-anim\"] = rhs.isFaceAnimType;\n        node[\"face-anim-weight\"] = rhs.isFaceAnimWeight;\n      } \n```", "```cpp\nenum class graphNodeType : int8_t {\n  ...\n **faceAnim,**\n  NUM\n}; \n```", "```cpp\n mGraphNodeTypeMap[graphNodeType::faceAnim] = \"FaceAnim\"; \n```", "```cpp\n case graphNodeType::faceAnim:\n      newNode = std::make_shared<FaceAnimNode>(nodeId);\n      break; \n```", "```cpp\n float morphTimeDiff = 1.0f;\n  if (mFaceAnimBlendTime != 0.0f) {\n    morphTimeDiff = std::clamp(mCurrentTime /\n      mFaceAnimBlendTime, 0.0f, 1.0f);\n  } \n```", "```cpp\n float morphWeightDiff =\n    mFaceAnimEndWeight – mFaceAnimStartWeight;\n  float currentWeight =\n    mFaceAnimEndWeight - morphWeightDiff * morphTimeDiff; \n```", "```cpp\n instanceUpdateType updateType =\n    instanceUpdateType::faceAnimWeight;\n  nodeCallbackVariant result;\n  bool extra = false;\n  result = currentWeight;\n  fireNodeActionCallback(getNodeType(), updateType,\n    result, extra); \n```", "```cpp\n instanceUpdateType updateType =\n    instanceUpdateType::faceAnimIndex;\n  nodeCallbackVariant result;\n  bool extra = false;\n  result = mFaceAnim;\n  fireNodeActionCallback(getNodeType(), updateType,\n    result, extra); \n```", "```cpp\nenum class instanceUpdateType : uint8_t {\n  ...\n **faceAnimIndex,**\n **faceAnimWeight**\n}; \n```", "```cpp\nusing nodeCallbackVariant = std::variant<float, moveState, moveDirection, **faceAnimation**>; \n```", "```cpp\n if (nodeType == graphNodeType::instance ||\n            nodeType == graphNodeType::action **||**\n **nodeType == graphNodeType::faceAnim** {\n          newNode->setNodeActionCallback(\n            behavior->bdNodeActionCallbackFunction);\n        } \n```", "```cpp\n if (node->getNodeType() == graphNodeType::instance ||\n        node->getNodeType() == graphNodeType::action **||**\n **node->****getNodeType****() == graphNodeType::faceAnim** {\n      newNode->setNodeActionCallback(\n        mBehaviorData->bdNodeActionCallbackFunction);\n    } \n```", "```cpp\n void setFaceAnim(faceAnimation faceAnim);\n    void setFaceAnimWeight(float weight); \n```", "```cpp\n switch (nodeType) {\n    ...\n**case** **graphNodeType::faceAnim:** \n```", "```cpp\n switch (updateType) {\n        case instanceUpdateType::faceAnimIndex:\n          instance->setFaceAnim(\n            std::get<faceAnimation>(data));\n          break;\n        case instanceUpdateType::faceAnimWeight:\n          instance->setFaceAnimWeight(\n            std::get<float>(data));\n          break;\n        default:\n          break; \n```", "```cpp\n }\n      break; \n```", "```cpp\nstruct PerInstanceAnimData {\n  ...\n**unsigned****int** **headLeftRightAnimClipNum;**\n**unsigned****int** **headUpDownAnimClipNum;**\n  ...\n**float** **headLeftRightReplayTimestamp;**\n**float** **headUpDownReplayTimestamp**;\n}; \n```", "```cpp\n Shader mAssimpTransformHeadMoveComputeShader{}; \n```", "```cpp\n VkPipeline rdAssimpComputeHeadMoveTransformPipeline; \n```", "```cpp\n     uint headLeftRightClip =\n        instAnimData[instance].headLeftRightAnimClipNum; \n    ```", "```cpp\n     float headLeftRightRotInvScaleFactor =\n        lookupData[headLeftRightClip * clipOffset +\n          node * boneOffset + lookupWidth].x; \n    ```", "```cpp\n     int headLeftRightRotLookupIndex =\n        clamp(int(instAnimData[instance]\n          .headLeftRightReplayTimestamp *\n          headLeftRightRotInvScaleFactor) + 1, 0,\n          lookupWidth - 1); \n    ```", "```cpp\n     vec4 headLeftRightBaseRotation =\n         lookupData[headLeftRightClip * clipOffset + node *\n         boneOffset + lookupWidth + 1];\n    ...\n      vec4 headLeftRightRotation =\n        lookupData[headLeftRightClip * clipOffset + node *\n        boneOffset + lookupWidth +\n        HeadLeftRightRotLookupIndex]; \n    ```", "```cpp\n     vec4 headLeftRightRotationDiff =\n        qMult(qInverse(headLeftRightBaseRotation),\n          headLeftRightRotation); \n    ```", "```cpp\n     vec4 headRotationDiff =\n        qMult(headUpDownRotationDiff,\n        headLeftRightRotationDiff); \n    ```", "```cpp\n     vec4 finalRotation =\n        slerp(qMult(headRotationDiff, firstRotation),\n        qMult(headRotationDiff, secondRotation), blendFactor); \n    ```", "```cpp\n**float** **isHeadLeftRightMove =** **0.0f****;**\n**float** **isHeadUpDownMove =** **0.0f****;** \n```", "```cpp\nif (instSettings.isHeadLeftRightMove > 0.0f) {\n  animData.headLeftRightAnimClipNum =\n    modSettings.msHeadMoveClipMappings[\n    headMoveDirection::left];\n} else {\n  animData.headLeftRightAnimClipNum =\n   modSettings.msHeadMoveClipMappings[\n   headMoveDirection::right];\n} \n```", "```cpp\nanimData.headLeftRightReplayTimestamp =\n  std::fabs(instSettings.isHeadLeftRightMove) *\n    model->getMaxClipDuration(); \n```", "```cpp\nenum class headMoveDirection : uint8_t {\n  left = 0,\n  right,\n  up,\n  down,\n  NUM\n}; \n```", "```cpp\n std::unordered_map<headMoveDirection, std::string>\n    micHeadMoveAnimationNameMap{}; \n```", "```cpp\n std::map<headMoveDirection, int> msHeadMoveClipMappings{}; \n```", "```cpp\n bool hasHeadMovementAnimationsMapped(); \n```", "```cpp\n if (model->hasHeadMovementAnimationsMapped()) {\n          mAssimpTransformHeadMoveComputeShader.use();\n        } else {\n          mAssimpTransformComputeShader.use();\n        } \n```", "```cpp\nif (model->hasHeadMovementAnimationsMapped()) {\n  vkCmdBindPipeline(mRenderData.rdComputeCommandBuffer,\n    VK_PIPELINE_BIND_POINT_COMPUTE,\n    mRenderData.rdAssimpComputeHeadMoveTransformPipeline);\n} else {\n  vkCmdBindPipeline(mRenderData.rdComputeCommandBuffer,\n    VK_PIPELINE_BIND_POINT_COMPUTE,\n    mRenderData.rdAssimpComputeTransformPipeline);\n } \n```", "```cpp\nYAML::Emitter& operator<<(YAML::Emitter& out,\n    const headMoveDirection& moveDir) {\n  out << YAML::Flow;\n  out << static_cast<int>(moveDir);\n  return out;\n} \n```", "```cpp\n static bool decode(const Node& node, headMoveDirection& rhs) {\n        rhs = static_cast<headMoveDirection>(node.as<int>());\n    } \n```", "```cpp\n if (settings.isHeadLeftRightMove != 0.0f) {\n    out << YAML::Key << \"head-anim-left-right-timestamp\";\n    out << YAML::Value << settings.isHeadLeftRightMove;\n  }\n  if (settings.isHeadUpDownMove != 0.0f) {\n    out << YAML::Key << \"head-anim-up-down-timestamp\";\n    out << YAML::Value << settings.isHeadUpDownMove;\n  } \n```", "```cpp\n if (node[\"head-anim-left-right-timestamp\"]) {\n    rhs.isHeadLeftRightMove =\n     node[\"head-anim-left-right-timestamp\"].as<float>();\n  }\n  if (node[\"head-anim-up-down-timestamp\"]) {\n    rhs.isHeadUpDownMove =\n      node[\"head-anim-up-down-timestamp\"].as<float>();\n  } \n```"]