<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-361" class="chapter-number"><a id="_idTextAnchor361"/>9</h1>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor362"/>Advanced Container  Adaptor Usage</h1>
			<p>Container adaptors, as their name suggests, adapt underlying containers to provide specific interfaces and functionalities. Think of them as a way to enhance or modify an existing container so that it serves a different purpose without having to reinvent the wheel. They wrap around base containers and provide a distinct set of member functions, imbuing them with behavior that can be useful in various <span class="No-Break">programming scenarios.</span></p>
			<p>This chapter provides references for the <span class="No-Break">following containers:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">std::stack</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::queue</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::priority_queue</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::flat_set</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::flat_map</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::flat_multiset</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::flat_multimap</strong></span></li>
			</ul>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor363"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-364"><a id="_idTextAnchor364"/>std::stack</h1>
			<p><strong class="source-inline">std::stack</strong> is a<a id="_idIndexMarker570"/> data structure that represents a stack, a <strong class="bold">last-in, first-out</strong> (<strong class="bold">LIFO</strong>) data <a id="_idIndexMarker571"/>structure. It is implemented as an adapter class, which means it is built on top of other containers, such as <strong class="source-inline">std::deque</strong>, <strong class="source-inline">std::vector</strong>, and <strong class="source-inline">std::list</strong>, providing a simple and easy-to-use interface for working with stacks. You can push elements onto the top of the stack, pop elements from the top, and access the top element without accessing elements at other positions. <strong class="source-inline">std::stack</strong> is commonly used for tasks that require a stack-like behavior, such as tracking function call sequences, parsing expressions, and managing temporary data. It provides a convenient way to manage data to ensure the most recently added element is the first to <span class="No-Break">be removed.</span></p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor365"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::stack</strong> is a container<a id="_idIndexMarker572"/> adapter that’s designed to provide a LIFO data structure. It operates on top of another container, such as <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::deque</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">std::list</strong></span><span class="No-Break">.</span></p>
			<p>It’s particularly<a id="_idIndexMarker573"/> suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When a LIFO behavior <span class="No-Break">is needed</span></li>
				<li>When you only need to access the most recently <span class="No-Break">added element</span></li>
				<li>When insertions and deletions happen solely at <span class="No-Break">one end</span></li>
			</ul>
			<p>Choose <strong class="source-inline">std::stack</strong> when you require a simple interface to manage data in a LIFO manner. For more flexible operations, consider its <span class="No-Break">underlying container.</span></p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor366"/>Ideal use cases</h2>
			<p>The following <a id="_idIndexMarker574"/>are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::stack</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Expression evaluations and parsing</strong>: An example of this is evaluating <span class="No-Break">postfix expressions</span></li>
				<li><strong class="bold">Backtracking algorithms</strong>: An example of this is performing depth-first search <span class="No-Break">in graphs</span></li>
				<li><strong class="bold">Undo operations in software</strong>: Maintaining a history of user actions to <span class="No-Break">revert them</span></li>
			</ul>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor367"/>Performance</h2>
			<p>Since <strong class="source-inline">std::stack</strong> is a <a id="_idIndexMarker575"/>container adaptor, its algorithmic performance is dependent on the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion (</strong><span class="No-Break"><strong class="bold">push)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Deletion (</strong><span class="No-Break"><strong class="bold">pop)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Access (</strong><span class="No-Break"><strong class="bold">top)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Memory overhead</strong>: Directly tied to the <span class="No-Break">underlying container</span></li>
			</ul>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor368"/>Memory management</h2>
			<p><strong class="source-inline">std::stack</strong> behaves<a id="_idIndexMarker576"/> like its underlying container does. For instance, if <strong class="source-inline">std::vector</strong> is the base, resizing might involve reallocation, doubling <span class="No-Break">its memory.</span></p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor369"/>Thread safety</h2>
			<p>Like most STL<a id="_idIndexMarker577"/> containers, <strong class="source-inline">std::stack</strong> isn’t thread-safe for write operations. External synchronization is necessary for concurrent writes or a combination of reads <span class="No-Break">and writes.</span></p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor370"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::queue</strong> and <strong class="source-inline">std::priority_queue</strong> are <a id="_idIndexMarker578"/>other <a id="_idIndexMarker579"/>adapters in the STL, serving <strong class="bold">first-in, first-out</strong> (<strong class="bold">FIFO</strong>) behaviors and priority-driven <span class="No-Break">access, respectively.</span></p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor371"/>Sorting and searching complexity</h2>
			<p>Sorting and searching <a id="_idIndexMarker580"/>are not inherently suited for <strong class="source-inline">std::stack</strong>. You might have to transfer elements to a different container to sort <span class="No-Break">or search.</span></p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor372"/>Special interface and member functions</h2>
			<p><strong class="source-inline">std::stack</strong> is <a id="_idIndexMarker581"/>designed <a id="_idIndexMarker582"/>to offer three special <span class="No-Break">member functions:</span></p>
			<ul>
				<li><strong class="source-inline">push</strong>: Pushes an element onto the top of <span class="No-Break">the stack</span></li>
				<li><strong class="source-inline">pop</strong>: Removes (pops) an element from the top of <span class="No-Break">the stack</span></li>
				<li><strong class="source-inline">top</strong>: Gets the value of the top element in the stack without <span class="No-Break">removing it</span></li>
			</ul>
			<h2 id="_idParaDest-373"><a id="_idTextAnchor373"/>Comparisons</h2>
			<p>Compared <a id="_idIndexMarker583"/>to the raw underlying containers, <strong class="source-inline">std::stack</strong> offers a restricted interface tailored for <span class="No-Break">LIFO operations.</span></p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor374"/>Interactions with algorithms</h2>
			<p>Direct interactions<a id="_idIndexMarker584"/> with STL algorithms are limited due to the lack of iterator support. For algorithmic operations, consider the underlying <span class="No-Break">container directly.</span></p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor375"/>Exceptions</h2>
			<p>Attempting <a id="_idIndexMarker585"/>operations on an empty stack, such as <strong class="source-inline">pop</strong> or <strong class="source-inline">top</strong>, doesn’t throw but leads to undefined behavior. Ensure the stack isn’t empty before <span class="No-Break">such operations.</span></p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor376"/>Customization</h2>
			<p>While the <a id="_idIndexMarker586"/>behavior of <strong class="source-inline">std::stack</strong> can’t be altered much, using custom allocators or selecting a specific underlying container can influence performance and <span class="No-Break">storage characteristics.</span></p>
			<h2 id="_idParaDest-377"><a id="_idTextAnchor377"/>Example</h2>
			<p>The <a id="_idIndexMarker587"/>following code shows an example demonstrating the use of <strong class="source-inline">std::stack</strong>. This example implements a function to evaluate <strong class="bold">Reverse Polish Notation</strong> (<strong class="bold">RPN</strong>) expressions, a <a id="_idIndexMarker588"/>postfix mathematical notation. Using a stack is a natural fit for this type <span class="No-Break">of problem:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
double evaluateRPN(const std::string &amp;expression) {
  std::stack&lt;double&gt; s;
  std::istringstream iss(expression);
  std::string token;
  while (iss &gt;&gt; token) {
    if (token == "+" || token == "-" || token == "*" ||
        token == "/") {
      if (s.size() &lt; 2) {
        throw std::runtime_error("Invalid RPN expression");
      }
      double b = s.top();
      s.pop();
      double a = s.top();
      s.pop();
      if (token == "+") {
        s.push(a + b);
      } else if (token == "-") {
        s.push(a - b);
      } else if (token == "*") {
        s.push(a * b);
      } else if (token == "/") {
        if (b == 0.0) {
          throw std::runtime_error("Division by zero");
        }
        s.push(a / b);
      }
    } else {
      s.push(std::stod(token));
    }
  }
  if (s.size() != 1) {
    throw std::runtime_error("Invalid RPN expression");
  }
  return s.top();
}
int main() {
  try {
    // Evaluate RPN expressions
    std::cout &lt;&lt; "46 2 + = " &lt;&lt; evaluateRPN("46 2 +")
              &lt;&lt; "\n"; // 48
    std::cout &lt;&lt; "5 1 2 + 4 * + 3 - = "
              &lt;&lt; evaluateRPN("5 1 2 + 4 * + 3 -")
              &lt;&lt; "\n"; // 14
    std::cout &lt;&lt; "3 4 5 * - = " &lt;&lt; evaluateRPN("3 4 5 * -")
              &lt;&lt; "\n"; // -17
  } catch (const std::exception &amp;e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Here’s the <span class="No-Break">example output:</span></p>
			<pre class="console">
46 2 + = 48
5 1 2 + 4 * + 3 - = 14
3 4 5 * - = -17</pre>			<p>In the<a id="_idIndexMarker589"/> preceding example, the <span class="No-Break">following occurs:</span></p>
			<ul>
				<li>We use <strong class="source-inline">std::stack</strong> to manage operands and evaluate the <span class="No-Break">RPN expression.</span></li>
				<li>Operands are pushed onto the stack. When an operator is encountered, the necessary number of operands (usually two) are popped from the stack. Next, the operation is performed. Finally, the result is pushed back onto <span class="No-Break">the stack.</span></li>
				<li>If the expression is valid at the end of the evaluation, there should be precisely one number on the stack: <span class="No-Break">the result.</span></li>
				<li>The function handles possible errors, such as an invalid RPN expression or division <span class="No-Break">by zero.</span></li>
			</ul>
			<p>This is a typical <a id="_idIndexMarker590"/>use of <strong class="source-inline">std::stack</strong> as it showcases the LIFO nature of the data structure and its principle operations (<strong class="source-inline">push</strong>, <strong class="source-inline">pop</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">top</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor378"/>Best practices</h2>
			<p>Let’s explore<a id="_idIndexMarker591"/> the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::stack</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Maintain a LIFO discipline</strong>: A stack is designed for LIFO operations. Avoid manipulating the underlying container directly to access anything other than the top element. Bypassing the LIFO logic compromises the purpose and integrity of using <span class="No-Break">a stack.</span></li>
				<li><strong class="bold">Perform safety checks with empty()</strong>: Before invoking <strong class="source-inline">top()</strong> or <strong class="source-inline">pop()</strong>, always validate if the stack is empty using the <strong class="source-inline">empty()</strong> function. Accessing or popping from an empty stack leads to undefined behavior and potential <span class="No-Break">runtime errors.</span></li>
				<li><strong class="bold">Choose an underlying container</strong>: By default, <strong class="source-inline">std::stack</strong> uses <strong class="source-inline">std::deque</strong> as its container, which typically provides efficient push and pop operations. While you can customize this with containers such as <strong class="source-inline">std::vector</strong> or <strong class="source-inline">std::list</strong>, be aware of their respective performance and memory characteristics. For instance, while <strong class="source-inline">std::vector</strong> might have occasional resizing overheads, <strong class="source-inline">std::list</strong> has <span class="No-Break">per-element overheads.</span></li>
				<li><strong class="bold">Concurrency requires external synchronization</strong>: <strong class="source-inline">std::stack</strong> itself does not guarantee thread safety. If you’re accessing or modifying a stack from multiple threads, employ proper synchronization mechanisms, such as <strong class="source-inline">std::mutex</strong>, to prevent data races and <span class="No-Break">maintain consistency.</span></li>
				<li><strong class="bold">Be wary of direct container access</strong>: While the <strong class="source-inline">std::stack</strong> interface restricts you to the top element, the underlying container might not. Directly using the underlying container can provide broader access and introduce errors if you’re <span class="No-Break">not cautious.</span></li>
				<li><strong class="bold">Efficient element construction with emplace</strong>: Instead of pushing an already constructed element, use <strong class="source-inline">emplace</strong> to construct the element directly<a id="_idIndexMarker592"/> within the stack. This can reduce the need for temporary objects and potential copy/move operations, leading to more efficient and <span class="No-Break">concise code.</span></li>
				<li><strong class="bold">Exception safety</strong>: Certain operations might provide basic or strong exception safety, depending on the underlying container. Awareness of these guarantees is essential, especially if your application requires a certain level of <span class="No-Break">exception safety.</span></li>
				<li><strong class="bold">Mind the stack’s capacity</strong>: While <strong class="source-inline">std::stack</strong> doesn’t expose capacity or reservation mechanisms directly, the underlying container, especially if it’s <strong class="source-inline">std::vector</strong>, might have such behaviors. If you’re confident about the stack’s growth patterns, consider using an appropriate underlying container and managing its capacity <span class="No-Break">for optimization.</span></li>
				<li><strong class="bold">Beware of aliases and auto</strong>: When employing type aliases or automatic type deduction using <strong class="source-inline">auto</strong>, be explicitly aware of your stack’s type. This includes the type of elements it holds and the underlying container. This clarity ensures you remain informed about the stack’s performance characteristics <span class="No-Break">and limitations.</span></li>
				<li><strong class="bold">Avoid std::stack&lt;bool&gt; pitfalls</strong>: Just as with <strong class="source-inline">std::vector&lt;bool&gt;</strong>, using <strong class="source-inline">std::stack&lt;bool&gt;</strong> with certain underlying containers can have unexpected behaviors or inefficiencies due to container specializations. If you need a stack of Boolean values, consider alternatives or be well-informed about the specific container’s behavior with <span class="No-Break">Boolean types.</span></li>
			</ul>
			<h1 id="_idParaDest-379"><a id="_idTextAnchor379"/>std::queue</h1>
			<p><strong class="source-inline">std::queue</strong> represents <a id="_idIndexMarker593"/>a FIFO data structure. It is implemented as an adapter class and is typically based on other underlying containers, such as <strong class="source-inline">std::deque</strong> or <strong class="source-inline">std::list</strong>. <strong class="source-inline">std::queue</strong> provides a straightforward interface for working with queues, allowing you to enqueue (push) elements at the back and dequeue (pop) elements from the front. It is commonly used in C++ for situations where data needs to be processed in the order it was added, such as task scheduling, breadth-first traversal of graphs or trees, and managing work items in multi-threaded programs. <strong class="source-inline">std::queue</strong> ensures that the element in the queue that is the longest is the first to be dequeued, making it a useful tool for managing ordered <span class="No-Break">data processing.</span></p>
			<h2 id="_idParaDest-380"><a id="_idTextAnchor380"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::queue</strong> is a<a id="_idIndexMarker594"/> container adapter that’s built on top of another container such as <strong class="source-inline">std::deque</strong>, <strong class="source-inline">std::list</strong>, or <strong class="source-inline">std::vector</strong>. Its primary purpose is to provide FIFO <span class="No-Break">data access.</span></p>
			<p>It’s especially suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When sequential access <span class="No-Break">is needed</span></li>
				<li>When elements are to be processed in their <span class="No-Break">insertion order</span></li>
			</ul>
			<p>If searching, sorting, or random access is a primary concern, <strong class="source-inline">std::queue</strong> might not be the <span class="No-Break">optimal choice.</span></p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor381"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker595"/> some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::queue</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Task scheduling</strong>: Manage tasks in the order <span class="No-Break">they arrive</span></li>
				<li><strong class="bold">Data serialization</strong>: Ensure data is processed in the order <span class="No-Break">it’s received</span></li>
				<li><strong class="bold">Tree Traversal:</strong> Breadth-first traversal of graphs <span class="No-Break">or trees</span></li>
			</ul>
			<h2 id="_idParaDest-382"><a id="_idTextAnchor382"/>Performance</h2>
			<p>Since <strong class="source-inline">std::queue</strong> is a <a id="_idIndexMarker596"/>container adaptor, its algorithmic performance depends on the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion (</strong><span class="No-Break"><strong class="bold">push)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Deletion (</strong><span class="No-Break"><strong class="bold">pop)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Access (front and </strong><span class="No-Break"><strong class="bold">back)</strong></span><span class="No-Break">: </span><span class="No-Break"><em class="italic">O(1)</em></span></li>
				<li><strong class="bold">Memory overhead</strong>: Depends on the <span class="No-Break">underlying container</span></li>
			</ul>
			<p>The performance characteristics derive mainly from the base container, which is <span class="No-Break">typically </span><span class="No-Break"><strong class="source-inline">std::deque</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor383"/>Memory management</h2>
			<p>Its memory <a id="_idIndexMarker597"/>behavior depends on the underlying container. For instance, if you’re using <strong class="source-inline">std::deque</strong>, it manages blocks of memory and can grow <span class="No-Break">both ends.</span></p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor384"/>Thread safety</h2>
			<p>Reads and<a id="_idIndexMarker598"/> writes aren’t inherently thread-safe. External synchronization, such as mutexes, is necessary if concurrent access <span class="No-Break">is required.</span></p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor385"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::priority_queue</strong> is <a id="_idIndexMarker599"/>another adapter that provides access to the top-most element based on a priority, not <span class="No-Break">insertion order.</span></p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor386"/>Sorting and searching complexity</h2>
			<p>Sorting and<a id="_idIndexMarker600"/> searching does not apply to <strong class="source-inline">std::queue</strong>. <strong class="source-inline">std::queue</strong> is designed for FIFO access. Sorting or random searching would require manual iteration through the underlying container, which is suboptimal and defies the purpose of <span class="No-Break">a queue.</span></p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor387"/>Special interface and member functions</h2>
			<p>Its primary<a id="_idIndexMarker601"/> operations include <strong class="source-inline">push()</strong>, <strong class="source-inline">pop()</strong>, <strong class="source-inline">front()</strong>, and <strong class="source-inline">back()</strong>. <strong class="source-inline">size()</strong> and <strong class="source-inline">empty()</strong> are <a id="_idIndexMarker602"/>used for size checks <span class="No-Break">and emptiness.</span></p>
			<h2 id="_idParaDest-388"><a id="_idTextAnchor388"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker603"/> to <strong class="source-inline">std::stack</strong>, which offers LIFO access, <strong class="source-inline">std::queue</strong> ensures FIFO behavior. If random access is required, then <strong class="source-inline">std::vector</strong> might be <span class="No-Break">more appropriate.</span></p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor389"/>Interactions with algorithms</h2>
			<p>Direct interaction<a id="_idIndexMarker604"/> with most STL algorithms is limited due to the lack of iterators. If algorithmic operations are needed, you’d typically work on the underlying <span class="No-Break">container directly.</span></p>
			<h2 id="_idParaDest-390"><a id="_idTextAnchor390"/>Exceptions</h2>
			<p>The exceptions<a id="_idIndexMarker605"/> that are thrown depend on the operations of the underlying container. However, accessing elements from an empty queue (using <strong class="source-inline">front()</strong> or <strong class="source-inline">back()</strong>) can lead to <span class="No-Break">undefined behavior.</span></p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor391"/>Customization</h2>
			<p>Memory <a id="_idIndexMarker606"/>management can be customized by choosing an appropriate underlying container and possibly using <span class="No-Break">custom allocators.</span></p>
			<h2 id="_idParaDest-392"><a id="_idTextAnchor392"/>Example</h2>
			<p>One<a id="_idIndexMarker607"/> everyday use case for <strong class="source-inline">std::queue</strong> is implementing a <strong class="bold">breadth-first search</strong> (<strong class="bold">BFS</strong>) algorithm on a graph. Let’s create an example that showcases a BFS traversal using <strong class="source-inline">std::queue</strong>. Here is a basic BFS implementation on an undirected graph that uses an adjacency <span class="No-Break">list representation:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
class Graph {
public:
  Graph(int vertices) : numVertices(vertices) {
    adjList.resize(vertices);
  }
  void addEdge(int v, int w) {
    adjList[v].push_back(w);
    adjList[w].push_back(v);
  }
  void BFS(int startVertex) {
    std::vector&lt;bool&gt; visited(numVertices, false);
    std::queue&lt;int&gt; q;
    visited[startVertex] = true;
    q.push(startVertex);
    while (!q.empty()) {
      int currentVertex = q.front();
      std::cout &lt;&lt; currentVertex &lt;&lt; " ";
      q.pop();
      for (int neighbor : adjList[currentVertex]) {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          q.push(neighbor);
        }
      }
    }
  }
private:
  int numVertices{0};
  std::vector&lt;std::vector&lt;int&gt;&gt; adjList;
};
int main() {
  Graph g(6);
  g.addEdge(0, 1);
  g.addEdge(0, 2);
  g.addEdge(1, 3);
  g.addEdge(1, 4);
  g.addEdge(2, 4);
  g.addEdge(3, 4);
  g.addEdge(3, 5);
  std::cout &lt;&lt; "BFS starting from vertex 0: ";
  g.BFS(0); // Output: 0 1 2 3 4 5
  return 0;
}</pre>			<p>Here’s the <span class="No-Break">example output:</span></p>
			<pre class="console">
BFS starting from vertex 0: 0 1 2 3 4 5</pre>			<p>The following <a id="_idIndexMarker608"/>points explain <span class="No-Break">the code:</span></p>
			<ul>
				<li>The <strong class="source-inline">Graph</strong> class uses an adjacency list (<strong class="source-inline">adjList</strong>) to represent <span class="No-Break">the graph.</span></li>
				<li>The BFS traversal starts from a given vertex, marks it as visited, and then explores its neighbors. Neighbors are added to the queue and processed in the order they are encountered (FIFO order), ensuring a <span class="No-Break">breadth-first traversal.</span></li>
				<li>As vertices are visited, they are marked in the visited vector to ensure they’re not processed <span class="No-Break">multiple times.</span></li>
				<li>The BFS function uses the primary operations of <strong class="source-inline">std::queue: push</strong> to add vertices to the queue, <strong class="source-inline">front</strong> to inspect the next vertex to be processed, and <strong class="source-inline">pop</strong> to <span class="No-Break">remove it.</span></li>
			</ul>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor393"/>Best practices</h2>
			<p>Let’s explore <a id="_idIndexMarker609"/>the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::queue</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Maintain a FIFO discipline</strong>: A queue is inherently designed for FIFO operations. Attempting to use it for other purposes, such as random access or stack operations with LIFO order, can lead to suboptimal designs <span class="No-Break">and complexities.</span></li>
				<li><strong class="bold">Avoid direct iterator usage</strong>: <strong class="source-inline">std::queue</strong> does not expose direct iterators. If you need to iterate over the elements, consider if a queue is the proper data structure for your needs or if the underlying container should be <span class="No-Break">accessed directly.</span></li>
				<li><strong class="bold">Ensure safety with empty()</strong>: Before accessing elements with <strong class="source-inline">front()</strong> or <strong class="source-inline">back()</strong>, always check if the queue is empty using the <strong class="source-inline">empty()</strong> function. This prevents undefined behavior that could arise from trying to access elements in an <span class="No-Break">empty queue.</span></li>
				<li><strong class="bold">Be mindful of the underlying container</strong>: The default container for <strong class="source-inline">std::queue</strong> is <strong class="source-inline">std::deque</strong>, but you can use others, such as <strong class="source-inline">std::list</strong>. Each container has its characteristics, trade-offs, and memory <a id="_idIndexMarker610"/>overhead. For example, while <strong class="source-inline">std::list</strong> offers efficient insertions and deletions, its memory overhead per element is higher <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">std::deque</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">External synchronization is necessary for concurrency</strong>: If multiple threads access the queue, ensure you provide proper synchronization mechanisms, such as <strong class="source-inline">std::mutex</strong>, to avoid data races and inconsistencies. The operations on <strong class="source-inline">std::queue</strong> itself are not <span class="No-Break">inherently thread-safe.</span></li>
				<li><strong class="bold">Push and pop considerations</strong>: When pushing or popping elements, be aware that the operations might involve memory allocations or deallocations, especially if the underlying container is a <strong class="source-inline">std::vector</strong> container (though this is rare for a queue). This can be a performance concern in real-time or <span class="No-Break">performance-critical applications.</span></li>
				<li><strong class="bold">Use emplace for in-place construction</strong>: Instead of pushing an already constructed element, consider using <strong class="source-inline">emplace</strong> to construct the element directly within the queue. This can lead to more efficient code as it avoids temporary <span class="No-Break">object creation.</span></li>
				<li><strong class="bold">Avoid capacity-related assumptions</strong>: Unlike <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::queue</strong> doesn’t have capacity-related member functions. Without explicit knowledge or control, do not make assumptions about the underlying container’s size <span class="No-Break">or capacity.</span></li>
				<li><strong class="bold">Choose containers with appropriate exception guarantees</strong>: If exception safety is a concern, ensure the underlying container provides the necessary <a id="_idIndexMarker611"/>exception guarantees. For example, <strong class="source-inline">std::deque</strong> provides strong exception safety for its operations, ensuring data isn’t corrupted <span class="No-Break">during exceptions.</span></li>
				<li><strong class="bold">Be cautious with type aliases</strong>: If you’re using type aliases or auto-typing, be sure you know the exact type of your queue, especially if you’re working with queues of different underlying containers in the same code base. This ensures you don’t mistakenly assume a different container type’s characteristics or <span class="No-Break">performance trade-offs.</span></li>
			</ul>
			<h1 id="_idParaDest-394"><a id="_idTextAnchor394"/>std::priority_queue</h1>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor395"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::priority_queue</strong> is an adapter container built on top of a random-access container type, primarily <strong class="source-inline">std::vector</strong>. Its core strength revolves around <span class="No-Break">the following:</span></p>
			<ul>
				<li>Always having the highest priority element at <span class="No-Break">the top</span></li>
				<li>Ensuring efficient insertion and retrieval of the <span class="No-Break">top element</span></li>
			</ul>
			<p>It shines in the <a id="_idIndexMarker612"/><span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When priority-based access <span class="No-Break">is required</span></li>
				<li>When insertions are random but access always targets the element of the <span class="No-Break">highest importance</span></li>
			</ul>
			<p>In scenarios where order is not a concern or insertion order matters more than access priority, <strong class="source-inline">std::priority_queue</strong> might not be the <span class="No-Break">ideal choice.</span></p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor396"/>Ideal use cases</h2>
			<p>The <a id="_idIndexMarker613"/>following are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::priority_queue</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Job scheduling</strong>: Assigning jobs based on their urgency <span class="No-Break">or priority</span></li>
				<li><strong class="bold">Pathfinding algorithms</strong>: An example of such an algorithm is Dijkstra’s algorithm, where nodes with the shortest tentative distance are <span class="No-Break">processed first</span></li>
				<li><strong class="bold">Simulation systems</strong>: For events that should be processed based on priority rather <span class="No-Break">than sequence</span></li>
			</ul>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor397"/>Performance</h2>
			<p>Since <strong class="source-inline">std::priority_queue</strong> is a container adaptor, its algorithmic performance<a id="_idIndexMarker614"/> depends on the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(log n)</em>, as the element is placed in its suitable position based on <span class="No-Break">its priority</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(log n)</em> for the top element as the queue <span class="No-Break">restructures itself</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(1)</em> to the <span class="No-Break">top element</span></li>
				<li><strong class="bold">Memory overhead</strong>: Moderate, contingent on the <span class="No-Break">underlying container</span></li>
			</ul>
			<p>Note that when using <strong class="source-inline">std::vector</strong> as the underlying container, additional memory overheads might appear when <span class="No-Break">it resizes.</span></p>
			<h2 id="_idParaDest-398"><a id="_idTextAnchor398"/>Memory management</h2>
			<p>This is <a id="_idIndexMarker615"/>inherently dependent on the underlying container. With <strong class="source-inline">std::vector</strong>, memory reallocation might happen upon reaching capacity. Allocators can be utilized <span class="No-Break">for customization.</span></p>
			<h2 id="_idParaDest-399"><a id="_idTextAnchor399"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker616"/>access requires caution. Multiple reads are safe, but simultaneous reads or writes demand external synchronization mechanisms, such <span class="No-Break">as mutexes.</span></p>
			<h2 id="_idParaDest-400"><a id="_idTextAnchor400"/>Extensions and variants</h2>
			<p>If you <a id="_idIndexMarker617"/>want a container that ensures sequence preservation, you might consider <strong class="source-inline">std::queue</strong>. If an associative container with key-value pairs and inherent ordering is needed, <strong class="source-inline">std::map</strong> or <strong class="source-inline">std::set</strong> might be <span class="No-Break">more apt.</span></p>
			<h2 id="_idParaDest-401"><a id="_idTextAnchor401"/>Sorting and searching complexity</h2>
			<p>Sorting<a id="_idIndexMarker618"/> does not apply to <strong class="source-inline">std::priority_queue</strong>. Direct access to the top priority element for searching is <em class="italic">O(1)</em>. However, searching for other elements is not straightforward and isn’t the primary intent of <span class="No-Break">this container.</span></p>
			<h2 id="_idParaDest-402"><a id="_idTextAnchor402"/>Special interface and member functions</h2>
			<p>Beyond the <a id="_idIndexMarker619"/>basics (<strong class="source-inline">push</strong>, <strong class="source-inline">pop</strong>, <strong class="source-inline">top</strong>), explore <a id="_idIndexMarker620"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Directly constructs an element within the <span class="No-Break">priority queue</span></li>
				<li><strong class="source-inline">size</strong>: Retrieves the number <span class="No-Break">of elements</span></li>
				<li><strong class="source-inline">swap</strong>: Exchanges the contents of two <span class="No-Break">priority queues</span></li>
			</ul>
			<h2 id="_idParaDest-403"><a id="_idTextAnchor403"/>Comparisons</h2>
			<p>In <a id="_idIndexMarker621"/>contrast to <strong class="source-inline">std::queue</strong>, which respects FIFO ordering,  <strong class="source-inline">std::priority_queue</strong>  always ensures the highest priority element is accessible. Compared with <strong class="source-inline">std::set</strong>, the latter allows ordered access to all elements, while the former focuses <span class="No-Break">on priority.</span></p>
			<h2 id="_idParaDest-404"><a id="_idTextAnchor404"/>Interactions with algorithms</h2>
			<p>Given the <a id="_idIndexMarker622"/>lack of iterators, most STL algorithms can’t interact directly with <strong class="source-inline">std::priority_queue</strong>. However, it naturally aligns with user-defined algorithms that focus on the highest-priority elements, such as those that use <strong class="source-inline">push()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">pop()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor405"/>Exceptions</h2>
			<p>Throwing <a id="_idIndexMarker623"/>can occur during underlying container operations, such as memory allocation. Exception safety often aligns with that of the <span class="No-Break">underlying container.</span></p>
			<h2 id="_idParaDest-406"><a id="_idTextAnchor406"/>Customization</h2>
			<p>Here are <a id="_idIndexMarker624"/>some <span class="No-Break">customization options:</span></p>
			<ul>
				<li><strong class="bold">Allocators</strong>: Customize memory allocation using <span class="No-Break">custom allocators</span></li>
				<li><strong class="bold">Comparators</strong>: Modify the priority logic using custom comparator functions, allowing for a custom definition <span class="No-Break">of </span><span class="No-Break"><em class="italic">priority</em></span></li>
			</ul>
			<h2 id="_idParaDest-407"><a id="_idTextAnchor407"/>Example</h2>
			<p><strong class="source-inline">std::priority_queue</strong> is <a id="_idIndexMarker625"/>often used in scenarios where elements need to be processed based on their priorities. One of the most common examples of using <strong class="source-inline">std::priority_queue</strong> is implementing Dijkstra’s shortest path algorithm for <span class="No-Break">weighted graphs.</span></p>
			<p>The following code shows an example of implementing Dijkstra’s algorithm <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">std::priority_queue</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
class WeightedGraph {
public:
  WeightedGraph(int vertices) : numVertices(vertices) {
    adjList.resize(vertices);
  }
  void addEdge(int u, int v, int weight) {
    adjList[u].push_back({v, weight});
    adjList[v].push_back({u, weight});
  }
  void dijkstra(int startVertex) {
    std::priority_queue&lt;std::pair&lt;int, int&gt;,
                        std::vector&lt;std::pair&lt;int, int&gt;&gt;,
                        std::greater&lt;std::pair&lt;int, int&gt;&gt;&gt;
        pq;
    std::vector&lt;int&gt; distances(numVertices, INT_MAX);
    pq.push({0, startVertex});
    distances[startVertex] = 0;
    while (!pq.empty()) {
      int currentVertex = pq.top().second;
      pq.pop();
      for (auto &amp;neighbor : adjList[currentVertex]) {
        int vertex = neighbor.first;
        int weight = neighbor.second;
        if (distances[vertex] &gt;
            distances[currentVertex] + weight) {
          distances[vertex] =
              distances[currentVertex] + weight;
          pq.push({distances[vertex], vertex});
        }
      }
    }
    std::cout &lt;&lt; "Distances from vertex " &lt;&lt; startVertex
              &lt;&lt; ":\n";
    for (int i = 0; i &lt; numVertices; ++i) {
      std::cout &lt;&lt; i &lt;&lt; " -&gt; " &lt;&lt; distances[i] &lt;&lt; '\n';
    }
  }
private:
  int numVertices{0};
  std::vector&lt;std::list&lt;std::pair&lt;int, int&gt;&gt;&gt; adjList;
};
int main() {
  WeightedGraph g(5);
  g.addEdge(0, 1, 9);
  g.addEdge(0, 2, 6);
  g.addEdge(0, 3, 5);
  g.addEdge(1, 3, 2);
  g.addEdge(2, 4, 1);
  g.addEdge(3, 4, 2);
  g.dijkstra(0);
  return 0;
}</pre>			<p>Here’s the <span class="No-Break">example output:</span></p>
			<pre class="console">
Distances from vertex 0:
0 -&gt; 0
1 -&gt; 7
2 -&gt; 6
3 -&gt; 5
4 -&gt; 7</pre>			<p>The following<a id="_idIndexMarker626"/> happens in <span class="No-Break">this implementation:</span></p>
			<ul>
				<li>The <strong class="source-inline">WeightedGraph</strong> class uses an adjacency list to represent the graph, where each list element is a pair representing the neighboring vertex and the weight of <span class="No-Break">the edge.</span></li>
				<li>The <strong class="source-inline">dijkstra</strong> function calculates the shortest distance from a given vertex to all other vertices in <span class="No-Break">the graph.</span></li>
				<li><strong class="source-inline">std::priority_queue</strong> is used to select the next vertex with the shortest known distance <span class="No-Break">to process.</span></li>
				<li>Distances<a id="_idIndexMarker627"/> to vertices are updated based on the currently processed vertex and <span class="No-Break">its neighbors.</span></li>
				<li>As the algorithm progresses, <strong class="source-inline">priority_queue</strong> ensures that vertices are processed in increasing order of their known <span class="No-Break">shortest distances.</span></li>
			</ul>
			<p>Using <strong class="source-inline">std::priority_queue</strong> provides an efficient way to always process the vertex with the smallest known distance in <span class="No-Break">Dijkstra’s algorithm.</span></p>
			<h2 id="_idParaDest-408"><a id="_idTextAnchor408"/>Best practices</h2>
			<p>Let’s explore<a id="_idIndexMarker628"/> the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::priority_queue</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Top-element access</strong>: The primary purpose of <strong class="source-inline">std::priority_queue</strong> is to efficiently access the highest-priority element, not to provide ordered access to all its elements. Do not assume you can access the elements in a fully <span class="No-Break">sorted order.</span></li>
				<li><strong class="bold">Custom priority rules</strong>: If the default comparison logic doesn’t meet your needs, always provide a custom comparator. This ensures that the queue maintains elements according to your specific <span class="No-Break">priority rules.</span></li>
				<li><strong class="bold">Underlying container choices</strong>: By default, <strong class="source-inline">std::priority_queue</strong> uses <strong class="source-inline">std::vector</strong> as its underlying container. While this is often suitable, switching to containers such as <strong class="source-inline">std::deque</strong> or <strong class="source-inline">std::list</strong> can influence performance. Choose the container that aligns with your <span class="No-Break">specific requirements.</span></li>
				<li><strong class="bold">Check for emptiness</strong>: Before trying to access the top element or perform a pop operation, always verify that the queue isn’t empty. This prevents <span class="No-Break">undefined behavior.</span></li>
				<li><strong class="bold">Avoid underlying container manipulation</strong>: Directly manipulating the underlying container can disrupt the integrity of the priority queue. Avoid this to ensure that the priority order <span class="No-Break">remains consistent.</span></li>
				<li><strong class="bold">Efficient element construction</strong>: To construct elements directly within the priority<a id="_idIndexMarker629"/> queue, prefer the <strong class="source-inline">emplace</strong> method over <strong class="source-inline">push</strong>. This provides more efficient in-place construction and can save on unnecessary copies <span class="No-Break">or moves.</span></li>
				<li><strong class="bold">Thread safety</strong>: Like other STL containers, <strong class="source-inline">std::priority_queue</strong> is not inherently thread-safe. If you need to access or modify it across multiple threads, ensure you use appropriate <span class="No-Break">synchronization mechanisms.</span></li>
				<li><strong class="bold">Awareness of internal sorting</strong>: While it’s tempting to think of the priority queue as always holding a sorted list of elements, remember that it only ensures that the top-most element is the highest priority. The internal order of other elements is not guaranteed to <span class="No-Break">be sorted.</span></li>
				<li><strong class="bold">No iterators</strong>: Unlike many other STL containers, <strong class="source-inline">std::priority_queue</strong> does not provide iterators to its elements. This design intentionally keeps users from inadvertently breaking the queue’s <span class="No-Break">priority invariants.</span></li>
				<li><strong class="bold">Size considerations</strong>: Be mindful of the size and capacity of the underlying container, especially if you’re dealing with large datasets. Periodically checking and managing capacity can help in optimizing <span class="No-Break">memory usage.</span></li>
			</ul>
			<p>By following these best practices, you can ensure that you use <strong class="source-inline">std::priority_queue</strong> in a manner that is efficient and consistent with its <span class="No-Break">design intentions.</span></p>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor409"/>std::flat_set</h1>
			<p><strong class="source-inline">std::flat_set</strong> is a<a id="_idIndexMarker630"/> sorted associative container that’s designed to store a collection of unique elements in a sorted order. What sets <strong class="source-inline">std::flat_set</strong> apart from other associative containers, such as <strong class="source-inline">std::set</strong>, is that it is implemented as a flat container, often based on a sorted <strong class="source-inline">std::vector</strong> container. This means that elements are stored contiguously in memory, leading to optimal memory usage and faster iteration times compared to traditional tree-based <span class="No-Break">associative containers.</span></p>
			<p><strong class="source-inline">std::flat_set</strong> maintains <a id="_idIndexMarker631"/>its elements in a sorted order, allowing for efficient searching, insertion, and deletion operations, while also providing similar functionality and interface to other set-like containers in the C++ STL. It is especially useful when you need the advantages of both sorted storage and efficient <span class="No-Break">memory management.</span></p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor410"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::flat_set</strong> is a container that represents an associative set stored in a sorted flat array. It merges the benefits of a <strong class="source-inline">std::vector</strong> container (such as cache-friendliness) with those of a <strong class="source-inline">std::set</strong> container (such as <span class="No-Break">ordered storage).</span></p>
			<p>Use <strong class="source-inline">std::flat_set</strong> in the <a id="_idIndexMarker632"/><span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When you need ordered data with <span class="No-Break">set properties</span></li>
				<li>When memory allocation overhead is <span class="No-Break">a concern</span></li>
				<li>When you want to leverage cache locality advantages similar to those <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span></li>
			</ul>
			<p>If you need to perform many insertions and deletions, other set types, such as <strong class="source-inline">std::set</strong>, may be more suitable due to their <span class="No-Break">tree-based implementation.</span></p>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor411"/>Ideal use cases</h2>
			<p>The following<a id="_idIndexMarker633"/> are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::flat_set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Large data initialization</strong>: Given its contiguous memory storage, bulk loading data into a <strong class="source-inline">std::flat_set</strong> container and sorting it can <span class="No-Break">be efficient</span></li>
				<li><strong class="bold">Fast lookups</strong>: Benefiting from cache locality, searches within a <strong class="source-inline">std::flat_set</strong> container can be notably faster than tree-based sets for <span class="No-Break">smaller sizes</span></li>
				<li><strong class="bold">Intersecting/Synthesizing sets</strong>: If you’re performing operations to combine or <a id="_idIndexMarker634"/>intersect sets, the linear nature of <strong class="source-inline">std::flat_set</strong> can <span class="No-Break">be advantageous</span></li>
			</ul>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor412"/>Performance</h2>
			<p>Since <strong class="source-inline">std::flat_set</strong> is a container adaptor, its algorithmic performance depends on<a id="_idIndexMarker635"/> the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(n)</em> since shifting may <span class="No-Break">be required</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(n)</em> for the <span class="No-Break">same reasons</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> for lookup using <span class="No-Break">binary search</span></li>
				<li><strong class="bold">Memory overhead</strong>: Less than tree-based structures due to fewer <span class="No-Break">memory allocations</span></li>
			</ul>
			<p>The trade-off is the speed of lookups versus the cost of insertion and deletion, especially as the <span class="No-Break">set grows.</span></p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor413"/>Memory management</h2>
			<p><strong class="source-inline">std::flat_set</strong> uses <a id="_idIndexMarker636"/>a contiguous block of memory (similar to <strong class="source-inline">std::vector</strong>). Reallocations occur when this block is exhausted. You can influence the allocation strategy using <span class="No-Break">custom allocators.</span></p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor414"/>Thread safety</h2>
			<p>As with most<a id="_idIndexMarker637"/> STL containers, concurrent reads are safe, but writes or mixed operations necessitate <span class="No-Break">external synchronization.</span></p>
			<h2 id="_idParaDest-415"><a id="_idTextAnchor415"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::flat_map</strong> is a cousin of <strong class="source-inline">std::flat_set</strong> that stores key-value pairs in a flat <a id="_idIndexMarker638"/>structure. It offers similar performance characteristics <span class="No-Break">and uses.</span></p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor416"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker639"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Inherent to the container and usually <em class="italic">O(n </em><span class="No-Break"><em class="italic">log n)</em></span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> due to binary search on <span class="No-Break">sorted data</span></li>
			</ul>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor417"/>Special interface and member functions</h2>
			<p>Apart from<a id="_idIndexMarker640"/> the typical set functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, <strong class="source-inline">find</strong>), consider <a id="_idIndexMarker641"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">reserve</strong>: Allocates memory in anticipation <span class="No-Break">of insertions</span></li>
				<li><strong class="source-inline">capacity</strong>: Returns the current <span class="No-Break">allocation size</span></li>
			</ul>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor418"/>Comparisons</h2>
			<p>In <a id="_idIndexMarker642"/>contrast to <strong class="source-inline">std::set</strong>, <strong class="source-inline">std::flat_set</strong> offers better cache locality but can become inefficient with frequent insertions/deletions in <span class="No-Break">large datasets.</span></p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor419"/>Interactions with algorithms</h2>
			<p>STL algorithms<a id="_idIndexMarker643"/> that require random-access iterators, such as <strong class="source-inline">std::sort()</strong>, can be applied directly. However, remember that <strong class="source-inline">std::flat_set</strong> maintains its sorted order, so sorting manually <span class="No-Break">is redundant.</span></p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor420"/>Exceptions</h2>
			<p>Misusing<a id="_idIndexMarker644"/> iterators or exceeding capacity can cause exceptions. Many operations provide strong exception safety, ensuring <span class="No-Break">container consistency.</span></p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor421"/>Customization</h2>
			<p><strong class="source-inline">std::flat_set</strong> permits <a id="_idIndexMarker645"/>custom allocators, allowing for refined memory control. You can also supply custom comparators for <span class="No-Break">specialized sorting.</span></p>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor422"/>Best practices</h2>
			<p>Let’s explore<a id="_idIndexMarker646"/> the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::flat_set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Optimal usage scenarios</strong>: <strong class="source-inline">std::flat_set</strong> is best suited for use cases where the set is built once and queried multiple times. If your application demands frequent insertions and deletions, a traditional tree-based <strong class="source-inline">std::set</strong> container might be <span class="No-Break">more appropriate.</span></li>
				<li><strong class="bold">Cache locality</strong>: One of the primary advantages of <strong class="source-inline">std::flat_set</strong> over other set implementations is its continuous memory layout, making it cache-friendly. This can lead to significant performance improvements for smaller datasets or when the data can fit into <span class="No-Break">the cache.</span></li>
				<li><strong class="bold">Efficient merging</strong>: If you have multiple <strong class="source-inline">std::flat_set</strong> containers and need to merge them, consider inserting all elements into a single container first, then sort and make the entire collection unique. This approach is often more efficient than merging sorted sets element <span class="No-Break">by element.</span></li>
				<li><strong class="bold">Memory management</strong>: Using the <strong class="source-inline">reserve</strong> method is advisable if you have a reasonable estimate of the number of elements you’ll be inserting. This can minimize memory reallocations and <span class="No-Break">enhance performance.</span></li>
				<li><strong class="bold">Alternative set implementations</strong>: For datasets that are constantly changing in size or require frequent element modifications, consider switching to a <strong class="source-inline">std::set</strong> container, which is tree-based and can handle such modifications <span class="No-Break">more gracefully.</span></li>
				<li><strong class="bold">Maintaining element order</strong>: Since <strong class="source-inline">std::flat_set</strong> maintains its elements in<a id="_idIndexMarker647"/> a sorted order, it’s crucial to avoid manually sorting the container. Adding elements to a <strong class="source-inline">std::flat_set</strong> container will keep them in order based on the <span class="No-Break">provided comparator.</span></li>
				<li><strong class="bold">Element access and search</strong>: While <strong class="source-inline">std::flat_set</strong> offers member functions such as <strong class="source-inline">find</strong> for efficient searching, they are optimized for its internal structure. Using these member functions is generally more efficient than applying generic algorithms. If you ever need to use algorithms, ensure they are designed for sorted sequences, such as <strong class="source-inline">std::lower_bound</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">std::upper_bound</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Custom comparators</strong>: The default comparator for <strong class="source-inline">std::flat_set</strong> is <strong class="source-inline">std::less</strong>. However, if your data requires custom sorting logic, ensure you provide a custom comparator during the set’s construction. Remember, this comparator should give a strict weak ordering to maintain the <span class="No-Break">set’s properties.</span></li>
				<li><strong class="bold">Avoid frequent reallocations</strong>: Continuously adding elements without reserving memory or deleting elements can lead to frequent memory reallocations. This can negate some of the performance benefits <strong class="source-inline">std::flat_set</strong> provides. If your use case has such patterns, evaluate if other containers might be <span class="No-Break">more suitable.</span></li>
				<li><strong class="bold">Iterators and modifications</strong>: Unlike <strong class="source-inline">std::set</strong>, modifying elements (for example, through iterators) in a <strong class="source-inline">std::flat_set</strong> container without ensuring the order can lead to undefined behavior. Always confirm that the sorted order is maintained <span class="No-Break">post modifications.</span></li>
				<li><strong class="bold">Interactions with algorithms</strong>: Due to its contiguous memory layout, <strong class="source-inline">std::flat_set</strong> works well with algorithms that have been optimized for random-access <a id="_idIndexMarker648"/>iterators. However, be cautious with algorithms that modify the order or content as they can violate the <span class="No-Break">set’s properties.</span></li>
			</ul>
			<h1 id="_idParaDest-423"><a id="_idTextAnchor423"/>std::flat_map</h1>
			<p><strong class="source-inline">std::flat_map</strong> is<a id="_idIndexMarker649"/> a sorted associative container that combines the features of a map and a flat container. Similar to <strong class="source-inline">std::map</strong>, it allows you to store key-value pairs, and the keys are unique and ordered. However, unlike <strong class="source-inline">std::map</strong>, which is typically implemented as a balanced binary search tree, <strong class="source-inline">std::flat_map</strong> is implemented as a flat container, often based on a sorted <strong class="source-inline">std::vector</strong> container. This means that <strong class="source-inline">std::flat_map</strong> offers efficient memory usage and faster iteration times than traditional tree-based associative containers such as <strong class="source-inline">std::map</strong>. Elements in a <strong class="source-inline">std::flat_map</strong> container are stored contiguously in memory, which can lead to better cache locality and improved performance for certain <span class="No-Break">use cases.</span></p>
			<p><strong class="source-inline">std::flat_map</strong> provides functionality and interface similar to <strong class="source-inline">std::map</strong>, allowing you to perform operations such as insertion, deletion, and searching while maintaining the elements in a sorted order. It’s beneficial when you need both the advantages of sorted storage and the benefits of a <span class="No-Break">flat container.</span></p>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor424"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::flat_map</strong> is a container that pairs together keys and values, functioning as an associative array. The <a id="_idIndexMarker650"/>following reasons set it apart from other <span class="No-Break">map containers:</span></p>
			<ul>
				<li>It uses a vector-like structure, granting advantages in <span class="No-Break">cache locality.</span></li>
				<li>This contiguous memory layout fosters improved lookup times in <span class="No-Break">some scenarios.</span></li>
			</ul>
			<p>Its niche lies <a id="_idIndexMarker651"/>in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When the map is mainly built once and then <span class="No-Break">often queried</span></li>
				<li>When iteration speed and cache locality take precedence over <span class="No-Break">insertion/deletion speed</span></li>
				<li>When a <a id="_idIndexMarker652"/>sorted map representation <span class="No-Break">is essential</span></li>
			</ul>
			<p>If you foresee frequent modifications post-initialization, consider <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor425"/>Ideal use cases</h2>
			<p>The<a id="_idIndexMarker653"/> following are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::flat_map</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Configuration data</strong>: Storing configuration key-value pairs loaded once at startup but queried frequently during <span class="No-Break">application runtime</span></li>
				<li><strong class="bold">Spatial indexing</strong>: In graphics or game development, quick iteration and retrieval are more critical than <span class="No-Break">frequent modifications</span></li>
				<li><strong class="bold">Data serialization</strong>: For datasets that require sorting and occasional lookups but aren’t <span class="No-Break">modified regularly</span></li>
			</ul>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor426"/>Performance</h2>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(n)</em> due to<a id="_idIndexMarker654"/> the underlying <span class="No-Break">vector structure</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(n)</em> because elements may need to <span class="No-Break">be shifted</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> due to binary search on the <span class="No-Break">sorted array</span></li>
				<li><strong class="bold">Memory overhead</strong>: Generally, this is low, but it can escalate if the reserved capacity isn’t <span class="No-Break">utilized efficiently</span></li>
			</ul>
			<h2 id="_idParaDest-427"><a id="_idTextAnchor427"/>Memory management</h2>
			<p><strong class="source-inline">std::flat_map</strong>, like <strong class="source-inline">std::vector</strong>, may reallocate when its capacity is surpassed. It’s <a id="_idIndexMarker655"/>wise to employ <strong class="source-inline">reserve</strong> if you can predict the eventual size. Allocators can provide control over memory <span class="No-Break">management behaviors.</span></p>
			<h2 id="_idParaDest-428"><a id="_idTextAnchor428"/>Thread safety</h2>
			<p>While concurrent <a id="_idIndexMarker656"/>reads are safe, writes or a mixture of both necessitate external synchronization – for example, <span class="No-Break">using mutexes.</span></p>
			<h2 id="_idParaDest-429"><a id="_idTextAnchor429"/>Extensions and variants</h2>
			<p>For <a id="_idIndexMarker657"/>unordered associative containers, the STL offers <strong class="source-inline">std::unordered_map</strong>. If a balanced tree structure with ordered keys is preferred, then <strong class="source-inline">std::map</strong> is <span class="No-Break">your go-to.</span></p>
			<h2 id="_idParaDest-430"><a id="_idTextAnchor430"/>Sorting and searching complexity</h2>
			<p>Its <a id="_idIndexMarker658"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Inherent to its structure, it always <span class="No-Break">maintains order</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> due to <span class="No-Break">binary search</span></li>
			</ul>
			<h2 id="_idParaDest-431"><a id="_idTextAnchor431"/>Interface and member functions</h2>
			<p>Common<a id="_idIndexMarker659"/> members such as <strong class="source-inline">insert</strong>, <strong class="source-inline">find</strong>, and <strong class="source-inline">erase</strong> are present. However, you <a id="_idIndexMarker660"/>should also explore the <span class="No-Break">following gems:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Directly constructs elements <span class="No-Break">in place</span></li>
				<li><strong class="source-inline">lower_bound</strong> and <strong class="source-inline">upper_bound</strong>: These provide efficient <span class="No-Break">range searches</span></li>
				<li><strong class="source-inline">at</strong>: Provides direct access to values by key <span class="No-Break">with bounds-checking</span></li>
			</ul>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor432"/>Comparisons</h2>
			<p><strong class="source-inline">std::flat_map</strong> excels<a id="_idIndexMarker661"/> in iteration and lookup performance, especially for smaller datasets. However, if frequent modifications dominate your use case, you might lean <span class="No-Break">toward </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor433"/>Interactions with algorithms</h2>
			<p>Due to <a id="_idIndexMarker662"/>its random-access nature, <strong class="source-inline">std::flat_map</strong> pairs well with STL algorithms that thrive on such iterators. However, any algorithm that disrupts the key order should be <span class="No-Break">approached cautiously.</span></p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor434"/>Exceptions</h2>
			<p>Exceeding <a id="_idIndexMarker663"/>capacity or accessing out-of-bounds keys might trigger exceptions. Many operations offer strong exception safety, preserving map states if <span class="No-Break">exceptions arise.</span></p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor435"/>Customization</h2>
			<p><strong class="source-inline">std::flat_map</strong> allows<a id="_idIndexMarker664"/> for custom allocators, and you can specify a custom comparator during construction to dictate the <span class="No-Break">key order.</span></p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor436"/>Best practices</h2>
			<p>Let’s explore<a id="_idIndexMarker665"/> the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::flat_map:</strong></span></p>
			<ul>
				<li><strong class="bold">Insertion and deletion</strong>: Avoid using <strong class="source-inline">std::flat_map</strong> for frequent insertions and deletions due to the high cost. For such cases, consider alternatives, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Key modifications</strong>: Do not alter keys directly using iterators. This disrupts the sorted order of the map. If keys need to be modified, consider erasing the old key-value pair and inserting a new one to ensure <span class="No-Break">order maintenance.</span></li>
				<li><strong class="bold">Memory management</strong>: If you can predict the map’s eventual size, employ <strong class="source-inline">reserve()</strong> to reduce the frequency of memory reallocations, <span class="No-Break">enhancing performance.</span></li>
				<li><strong class="bold">Element construction</strong>: Utilize <strong class="source-inline">emplace</strong> to construct key-value pairs in place efficiently, maximizing performance and avoiding unnecessary temporary <span class="No-Break">object creation.</span></li>
				<li><strong class="bold">Container choice</strong>: Consider <a id="_idIndexMarker666"/>alternatives for use cases dominated by constant modifications, especially insertions and deletions. Containers such as <strong class="source-inline">std::map</strong> may offer better performance profiles in <span class="No-Break">such scenarios.</span></li>
				<li><strong class="bold">Concurrency</strong>: Ensure thread safety during multi-threaded access. Concurrent reads are generally safe, but writing or mixed read-write operations require external synchronization, such <span class="No-Break">as mutexes.</span></li>
				<li><strong class="bold">Lookup and iteration</strong>: Capitalize on the strengths of <strong class="source-inline">std::flat_map</strong>. It offers superior cache locality and efficient lookups, especially when the map is mainly <span class="No-Break">queried post-initialization.</span></li>
				<li><strong class="bold">Order maintenance</strong>: Given the sorted nature of <strong class="source-inline">std::flat_map</strong>, be cautious of operations that may disrupt this order. Always validate the order after any modifications to ensure the <span class="No-Break">container’s integrity.</span></li>
				<li><strong class="bold">Interface usage</strong>: Familiarize yourself with and employ member functions such as <strong class="source-inline">lower_bound </strong>and <strong class="source-inline">upper_bound</strong> for efficient range-based queries, leveraging the container’s <span class="No-Break">sorted characteristics.</span></li>
				<li><strong class="bold">Custom comparators</strong>: While the default comparator (<strong class="source-inline">std::less</strong>) works for many scenarios, <strong class="source-inline">std::flat_map</strong> allows you to specify custom comparators during instantiation, tailoring the key order to <span class="No-Break">specific needs.</span></li>
			</ul>
			<h1 id="_idParaDest-437"><a id="_idTextAnchor437"/>std::flat_multiset</h1>
			<p><strong class="source-inline">std::flat_multiset</strong> is a<a id="_idIndexMarker667"/> container that was introduced in the C++ STL that’s designed to store elements in a sorted order. Unlike <strong class="source-inline">std::multiset</strong>, which is typically implemented as a red-black tree, <strong class="source-inline">std::flat_multiset</strong> stores its elements in a contiguous memory block, similar to a <strong class="source-inline">std::vector</strong> container. This design choice offers improved cache performance due to data locality, making it efficient for scenarios where the container is not frequently modified after <span class="No-Break">being filled.</span></p>
			<h2 id="_idParaDest-438"><a id="_idTextAnchor438"/>Purpose and suitability</h2>
			<p><strong class="source-inline">Std::flat_multiset</strong> is a container that stores elements in a sorted array, similar to <strong class="source-inline">std::flat_set</strong>, but allows <a id="_idIndexMarker668"/>for multiple occurrences of <span class="No-Break">equivalent elements.</span></p>
			<p>This container offers <span class="No-Break">the following:</span></p>
			<ul>
				<li>Efficient lookup times thanks to its <span class="No-Break">sorted nature</span></li>
				<li>Improved cache locality and predictability in <span class="No-Break">memory usage</span></li>
			</ul>
			<p>It’s especially<a id="_idIndexMarker669"/> suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When duplicates are permissible and you need <span class="No-Break">sorted access</span></li>
				<li>When cache locality <span class="No-Break">is prioritized</span></li>
				<li>When the dataset’s size is relatively <span class="No-Break">stable post-initialization</span></li>
			</ul>
			<p>However, other containers might be more appropriate when frequent insertions or deletions become <span class="No-Break">the norm.</span></p>
			<h2 id="_idParaDest-439"><a id="_idTextAnchor439"/>Ideal use cases</h2>
			<p>The following<a id="_idIndexMarker670"/> are some of the ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::flat_multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Historical records</strong>: Storing repeated events in chronological order, such as <span class="No-Break">transaction logs</span></li>
				<li><strong class="bold">Frequency counter</strong>: Counting occurrences of elements when order and access speed <span class="No-Break">are vital</span></li>
				<li><strong class="bold">Sorted buffers</strong>: Temporary storage during processing, where the order is crucial, and duplicates <span class="No-Break">are expected</span></li>
			</ul>
			<h2 id="_idParaDest-440"><a id="_idTextAnchor440"/>Performance</h2>
			<p>Since <strong class="source-inline">std::flat_multiset</strong> is a<a id="_idIndexMarker671"/> container adaptor, its algorithmic performance depends on the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(n)</em> since maintaining order may necessitate <span class="No-Break">element shifting</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(n)</em> due to the possibility of shifting to <span class="No-Break">fill gaps</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> for lookups owing to <span class="No-Break">binary search</span></li>
				<li><strong class="bold">Memory overhead</strong>: It uses continuous memory, such as <strong class="source-inline">std::vector</strong>, but the lack of tree structures minimizes <span class="No-Break">memory overhead</span></li>
			</ul>
			<h2 id="_idParaDest-441"><a id="_idTextAnchor441"/>Memory management</h2>
			<p><strong class="source-inline">std::flat_multiset</strong> manages <a id="_idIndexMarker672"/>memory in chunks. Pre-allocating memory using <strong class="source-inline">reserve()</strong> can prevent frequent reallocations. Custom allocators can further modify <span class="No-Break">allocation behavior.</span></p>
			<h2 id="_idParaDest-442"><a id="_idTextAnchor442"/>Thread safety</h2>
			<p>Simultaneous<a id="_idIndexMarker673"/> reads are safe. However, concurrent modifications or simultaneous reads and writes need external <span class="No-Break">synchronization mechanisms.</span></p>
			<h2 id="_idParaDest-443"><a id="_idTextAnchor443"/>Extensions and variants</h2>
			<p>While <strong class="source-inline">std::flat_multiset</strong> stores <a id="_idIndexMarker674"/>multiple instances of an element, <strong class="source-inline">std::flat_set</strong> is its unique element counterpart. For hash-based approaches, you might want to look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">std::unordered_multiset</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-444"><a id="_idTextAnchor444"/>Sorting and searching complexity</h2>
			<p>Its sorting <a id="_idIndexMarker675"/>and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: This is inherent since <strong class="source-inline">std::flat_multiset</strong> <span class="No-Break">maintains order</span></li>
				<li><strong class="bold">Searching</strong>: Efficient <em class="italic">O(log n)</em> due to <span class="No-Break">binary searching</span></li>
			</ul>
			<h2 id="_idParaDest-445"><a id="_idTextAnchor445"/>Special interface and member functions</h2>
			<p><strong class="source-inline">std::flat_multiset</strong> offers much the same interface as its underlying type. Here are<a id="_idIndexMarker676"/> some especially <a id="_idIndexMarker677"/><span class="No-Break">useful functions:</span></p>
			<ul>
				<li><strong class="source-inline">equal_range</strong>: Returns range of <span class="No-Break">equivalent elements</span></li>
				<li><strong class="source-inline">count</strong>: Efficiently counts the occurrences of <span class="No-Break">an element</span></li>
				<li><strong class="source-inline">emplace</strong>: Constructs elements directly <span class="No-Break">in place</span></li>
			</ul>
			<h2 id="_idParaDest-446"><a id="_idTextAnchor446"/>Comparisons</h2>
			<p>Compared to <strong class="source-inline">std::multiset</strong>, <strong class="source-inline">std::flat_multiset</strong> offers a better cache locality <a id="_idIndexMarker678"/>but may suffer from frequent modifications. It excels in read-heavy <span class="No-Break">scenarios post-initialization.</span></p>
			<h2 id="_idParaDest-447"><a id="_idTextAnchor447"/>Interactions with algorithms</h2>
			<p>Being <a id="_idIndexMarker679"/>sorted, <strong class="source-inline">std::flat_multiset</strong> resonates well with binary search-based algorithms. However, those that shuffle or reorder might not <span class="No-Break">be ideal.</span></p>
			<h2 id="_idParaDest-448"><a id="_idTextAnchor448"/>Exceptions</h2>
			<p>Attempting to <a id="_idIndexMarker680"/>access out-of-bounds or mismanaging memory can lead to exceptions. Generally, operations are exception-safe, ensuring the container <span class="No-Break">remains consistent.</span></p>
			<h2 id="_idParaDest-449"><a id="_idTextAnchor449"/>Customization</h2>
			<p><strong class="source-inline">std::flat_multiset</strong> supports<a id="_idIndexMarker681"/> custom allocators, allowing for memory allocation fine-tuning. Moreover, custom comparators can adjust the <span class="No-Break">sorting behavior.</span></p>
			<h2 id="_idParaDest-450"><a id="_idTextAnchor450"/>Best practices</h2>
			<p>Let’s explore <a id="_idIndexMarker682"/>the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::flat_multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Insertion and deletion efficiency</strong>: Opt for <strong class="source-inline">std::flat_multiset</strong> primarily in scenarios where the set size stabilizes post-initialization. Frequent insertions or deletions will lead to inefficiencies due to the need to maintain a sorted order, often leading to <span class="No-Break">element shifting.</span></li>
				<li><strong class="bold">Iterator validity</strong>: Unlike some tree-based counterparts, such as <strong class="source-inline">std::multiset</strong>, the iterators for <strong class="source-inline">std::flat_multiset</strong> can become invalidated post-modification, especially those that change the container’s size. Always reassess iterator validity after altering <span class="No-Break">the container.</span></li>
				<li><strong class="bold">Memory management with reserve()</strong>:  If you have a rough estimate of the eventual size of your <strong class="source-inline">std::flat_multiset</strong> container, employ <strong class="source-inline">reserve()</strong> to allocate sufficient memory upfront. This prevents recurrent and costly reallocations. While reserving space for anticipated growth is important, over-reservation can lead to unnecessary memory consumption. Aim for a balance between <span class="No-Break">the two.</span></li>
				<li><strong class="bold">Choosing between std::flat_multiset and std::flat_set</strong>: In scenarios where duplicate elements are expected, and sorting is essential, <strong class="source-inline">std::flat_multiset</strong> is more suitable than <strong class="source-inline">std::flat_set</strong>. It retains all instances of an element, whereas the latter only keeps <span class="No-Break">unique entries.</span></li>
				<li><strong class="bold">Container alternatives for dynamic data</strong>: If your use case requires regular insertions and deletions, reconsider your container choice. Containers such as <strong class="source-inline">std::list</strong> or <strong class="source-inline">std::multiset</strong> might offer more efficiency for <span class="No-Break">such operations.</span></li>
				<li><strong class="bold">Efficient element construction</strong>: Instead of inserting pre-constructed elements, utilize <strong class="source-inline">emplace()</strong> to construct elements directly within the set. This can eliminate unnecessary temporary constructions and copies, particularly for complex <span class="No-Break">data types.</span></li>
				<li><strong class="bold">Concurrency concerns</strong>: Concurrent reading from <strong class="source-inline">std::flat_multiset</strong> is safe. Writing operations, whether they’re insertions, deletions, or modifications, require synchronization in a multi-threaded<a id="_idIndexMarker683"/> environment to ensure data integrity and prevent <span class="No-Break">data races.</span></li>
				<li><strong class="bold">Interaction with STL algorithms</strong>: Due to its sorted nature, <strong class="source-inline">std::flat_multiset</strong> pairs well with STL algorithms that benefit from sorted datasets, such as <strong class="source-inline">std::lower_bound</strong> or <strong class="source-inline">std::upper_bound</strong>. However, remember that algorithms that alter the order or introduce elements might invalidate this <span class="No-Break">inherent sorting.</span></li>
				<li><strong class="bold">Customization</strong>: While the default comparators work for basic types, for custom data types or specific sorting needs, provide a custom comparator to <strong class="source-inline">std::flat_multiset</strong> to control its <span class="No-Break">ordering behavior.</span></li>
				<li><strong class="bold">Exception safety</strong>: Be aware of operations that can throw exceptions, such as memory allocation failures. Ensuring exception-safe code will prevent data inconsistencies and potential <span class="No-Break">memory leaks.</span></li>
			</ul>
			<h1 id="_idParaDest-451"><a id="_idTextAnchor451"/>std::flat_multimap</h1>
			<p><strong class="source-inline">std::flat_multimap</strong> is a <a id="_idIndexMarker684"/>container adapter that combines the characteristics of associative and sequence containers. It stores key-value pairs, similar to <strong class="source-inline">std::multimap</strong>, but with a significant distinction: the elements are stored in a flat, contiguous memory space, akin to a <strong class="source-inline">std::vector</strong> container. This storage approach enhances cache performance due to improved data locality, which is especially beneficial for <span class="No-Break">read-intensive operations.</span></p>
			<h2 id="_idParaDest-452"><a id="_idTextAnchor452"/>Purpose and suitability</h2>
			<p><strong class="source-inline">Std::flat_multimap</strong> is a container <a id="_idIndexMarker685"/>within the STL that’s optimized for fast associative lookups. Its distinguishing features include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Storage in a sorted contiguous block of memory, akin <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span></li>
				<li>Allows multiple key-value pairs with <span class="No-Break">identical keys</span></li>
			</ul>
			<p>It is most suitable in the <a id="_idIndexMarker686"/><span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When cache locality and associative lookups are <span class="No-Break">both desired</span></li>
				<li>When the dataset stabilizes post-initialization since it’s not optimized for frequent insertions <span class="No-Break">or deletions</span></li>
			</ul>
			<p>Pick <strong class="source-inline">std::flat_multimap</strong> over other containers when the advantages of flat storage and allowance for key duplicity align with your <span class="No-Break">use case.</span></p>
			<h2 id="_idParaDest-453"><a id="_idTextAnchor453"/>Ideal use cases</h2>
			<p>The following are some of the<a id="_idIndexMarker687"/> ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::flat_multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Web browser history</strong>: Storing URLs with timestamps. Multiple entries (timestamps) can exist for the same <span class="No-Break">URL (key).</span></li>
				<li><strong class="bold">Word frequency counter</strong>: When words in a piece of text can have multiple meanings and you want to store each meaning alongside <span class="No-Break">its count.</span></li>
				<li><strong class="bold">Event scheduler</strong>: To maintain events (values) that occur at specific times (keys), where multiple events might happen at the <span class="No-Break">same timestamp.</span></li>
			</ul>
			<h2 id="_idParaDest-454"><a id="_idTextAnchor454"/>Performance</h2>
			<p>Since <strong class="source-inline">std::flat_multimap</strong> is a<a id="_idIndexMarker688"/> container adaptor, its algorithmic performance depends on the underlying <span class="No-Break">container implementation:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(n)</em> due to potential <span class="No-Break">element shifting</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(n)</em> due to <span class="No-Break">maintaining order</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> due to binary search on a <span class="No-Break">sorted array</span></li>
				<li><strong class="bold">Memory overhead</strong>: Relatively low with advantages in <span class="No-Break">cache locality</span></li>
			</ul>
			<p>The trade-off lies in enjoying faster lookups at the cost of slower insertions <span class="No-Break">and deletions.</span></p>
			<h2 id="_idParaDest-455"><a id="_idTextAnchor455"/>Memory management</h2>
			<p><strong class="source-inline">std::flat_multimap</strong> manages<a id="_idIndexMarker689"/> memory akin to <strong class="source-inline">std::vector</strong>. The <strong class="source-inline">reserve()</strong> function can anticipate and allocate memory for growth. Custom allocators can further tailor <span class="No-Break">memory behaviors.</span></p>
			<h2 id="_idParaDest-456"><a id="_idTextAnchor456"/>Thread safety</h2>
			<p>Concurrent reads <a id="_idIndexMarker690"/>are safe. However, writes or mixed read-writes require synchronization mechanisms such <span class="No-Break">as mutexes.</span></p>
			<h2 id="_idParaDest-457"><a id="_idTextAnchor457"/>Extensions and variants</h2>
			<p>For a container <a id="_idIndexMarker691"/>without duplicate key allowance, there’s <strong class="source-inline">std::flat_map</strong>. For unsorted and bucketed storage, you might want to <span class="No-Break">consider </span><span class="No-Break"><strong class="source-inline">std::unordered_multimap</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-458"><a id="_idTextAnchor458"/>Sorting and searching complexity</h2>
			<p>Its<a id="_idIndexMarker692"/> sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Inherent to the container and <span class="No-Break">managed internally</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> due to <span class="No-Break">binary search</span></li>
			</ul>
			<h2 id="_idParaDest-459"><a id="_idTextAnchor459"/>Interface and member functions</h2>
			<p>Apart <a id="_idIndexMarker693"/>from the<a id="_idIndexMarker694"/> standard functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, <strong class="source-inline">find</strong>), explore <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">equal_range</strong>: Returns bounds of all entries matching <span class="No-Break">a key</span></li>
				<li><strong class="source-inline">emplace</strong>: Directly constructs key-value pairs inside <span class="No-Break">the map</span></li>
			</ul>
			<h2 id="_idParaDest-460"><a id="_idTextAnchor460"/>Comparisons</h2>
			<p>Compared to <strong class="source-inline">std::multimap</strong>, <strong class="source-inline">std::flat_multimap</strong> offers better cache locality but <a id="_idIndexMarker695"/>slower modifications. When juxtaposed with <strong class="source-inline">std::unordered_multimap</strong>, it trades faster lookups for <span class="No-Break">inherent sorting.</span></p>
			<h2 id="_idParaDest-461"><a id="_idTextAnchor461"/>Interactions with algorithms</h2>
			<p><strong class="source-inline">std::flat_multimap</strong> is beneficial <a id="_idIndexMarker696"/>with algorithms such as <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong> due to its sorted nature. However, be cautious with algorithms that modify order or <span class="No-Break">introduce elements.</span></p>
			<h2 id="_idParaDest-462"><a id="_idTextAnchor462"/>Exceptions</h2>
			<p>Key insertions<a id="_idIndexMarker697"/> or lookups won’t throw, but be wary of memory allocation failures, especially during insertions, which can cause exceptions. Exception safety is prioritized, with many operations offering <span class="No-Break">strong guarantees.</span></p>
			<h2 id="_idParaDest-463"><a id="_idTextAnchor463"/>Customization</h2>
			<p>While<a id="_idIndexMarker698"/> custom allocators are permitted, <strong class="source-inline">std::flat_multimap</strong> relies on its internal sorting mechanism. Thus, custom comparators are essential to define <span class="No-Break">key order.</span></p>
			<h2 id="_idParaDest-464"><a id="_idTextAnchor464"/>Best practices</h2>
			<p>Let’s explore<a id="_idIndexMarker699"/> the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::flat_multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Insertion and deletion frequency</strong>: Refrain from using <strong class="source-inline">std::flat_multimap</strong> when the use case involves continuous or frequent insertions and deletions. Due to the container’s linear nature, such operations can <span class="No-Break">be costly.</span></li>
				<li><strong class="bold">Iterator expectations</strong>: Be aware that <strong class="source-inline">std::flat_multimap</strong> only supports input, output, forward, and bidirectional iterators. It does not provide <span class="No-Break">random-access iterators.</span></li>
				<li><strong class="bold">Key data type considerations</strong>: Prefer concise and lightweight data types for keys. Using large custom data types can exacerbate the costs of element shifting<a id="_idIndexMarker700"/> during insertions <span class="No-Break">and deletions.</span></li>
				<li><strong class="bold">Memory allocation management</strong>: If you have an estimate of the eventual size of <strong class="source-inline">std::flat_multimap</strong>, leverage the <strong class="source-inline">reserve()</strong> function. Pre-allocating memory can mitigate expensive reallocations <span class="No-Break">and copying.</span></li>
				<li><strong class="bold">Entry construction</strong>: Utilize the <strong class="source-inline">emplace</strong> method for in-situ construction of key-value pairs. This can be more efficient than creating and inserting an <span class="No-Break">entry separately.</span></li>
				<li><strong class="bold">Container suitability</strong>: Should the dataset be dynamic with frequent changes, consider the merits of alternative associative containers such as <strong class="source-inline">std::multimap</strong> or <strong class="source-inline">std::unordered_multimap</strong>. These containers might offer better performance for <span class="No-Break">such scenarios.</span></li>
				<li><strong class="bold">Concurrency</strong>: In multi-threaded environments, ensure that proper synchronization mechanisms, such as mutexes, are in place for write operations to <strong class="source-inline">std::flat_multimap</strong>. Concurrent reads are typically safe but write operations can lead to race conditions without <span class="No-Break">proper synchronization.</span></li>
				<li><strong class="bold">Key ordering</strong>: Implement and utilize custom comparators when the default key comparison doesn’t suffice. This ensures that <strong class="source-inline">std::flat_multimap</strong> retains its internal ordering based on your <span class="No-Break">specific requirements.</span></li>
				<li><strong class="bold">Search efficiency</strong>: Due to the sorted nature of <strong class="source-inline">std::flat_multimap</strong>, binary search algorithms, such as <strong class="source-inline">std::lower_bound  </strong>and <strong class="source-inline">std::upper_bound</strong>, can be used efficiently for operations such as range queries or finding <span class="No-Break">specific keys.</span></li>
				<li><strong class="bold">Exception safety</strong>: Avoid potential memory allocation failures, especially during insertions. Many operations on <strong class="source-inline">std::flat_multimap</strong> offer strong exception guarantees, ensuring that the container remains consistent, even if an operation throws <span class="No-Break">an exception.</span></li>
				<li><strong class="bold">Value handling</strong>: Given<a id="_idIndexMarker701"/> the allowance for key duplicity in <strong class="source-inline">std::flat_multimap</strong>, use member functions such as <strong class="source-inline">equal_range</strong> to handle and process all entries associated with a <span class="No-Break">specific key.</span></li>
				<li><strong class="bold">Capacity management</strong>: Regularly monitor the capacity and size of <strong class="source-inline">std::flat_multimap</strong> using member functions such as <strong class="source-inline">capacity()</strong>  and <strong class="source-inline">size()</strong>. If excess reserved space isn’t being utilized, consider using <strong class="source-inline">shrink_to_fit()</strong> to release <span class="No-Break">this memory.</span></li>
			</ul>
		</div>
	</body></html>