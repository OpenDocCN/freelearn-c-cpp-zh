["```cpp\nin vec3 VertexColor; \n```", "```cpp\n#version 460 \n\nlayout (location=0) in vec3 VertexPosition; \nlayout (location=1) in vec3 VertexColor; \n\nout vec3 Color; \n\nvoid main() \n{ \n  Color = VertexColor; \n\n  gl_Position = vec4(VertexPosition,1.0); \n}\n```", "```cpp\n#version 460 \n\nin vec3 Color;\nout vec4 FragColor; \n\nvoid main() {\n  FragColor = vec4(Color, 1.0); \n} \n```", "```cpp\nGLuint vaoHandle;\n```", "```cpp\nfloat positionData[] = { \n      -0.8f, -0.8f, 0.0f, \n      0.8f, -0.8f, 0.0f, \n      0.0f,  0.8f, 0.0f }; \nfloat colorData[] = { \n      1.0f, 0.0f, 0.0f, \n      0.0f, 1.0f, 0.0f, \n      0.0f, 0.0f, 1.0f }; \n\n// Create and populate the buffer objects \nGLuint vboHandles[2]; \nglGenBuffers(2, vboHandles); \nGLuint positionBufferHandle = vboHandles[0]; \nGLuint colorBufferHandle = vboHandles[1]; \n\n// Populate the position buffer \nglBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); \nglBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), \n       positionData, GL_STATIC_DRAW); \n\n// Populate the color buffer \nglBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); \nglBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), colorData, \n       GL_STATIC_DRAW);\n```", "```cpp\n// Create and set-up the vertex array object \nglGenVertexArrays( 1, &vaoHandle ); \nglBindVertexArray(vaoHandle); \n\n// Enable the vertex attribute arrays \nglEnableVertexAttribArray(0);  // Vertex position \nglEnableVertexAttribArray(1);  // Vertex color \n\n// Map index 0 to the position buffer \nglBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); \nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); \n\n// Map index 1 to the color buffer \nglBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); \nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);\n```", "```cpp\nglBindVertexArray(vaoHandle); \nglDrawArrays(GL_TRIANGLES, 0, 3 ); \n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexColor; \n```", "```cpp\n// Map index 0 to the position buffer \nglBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); \nglVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 0, NULL ); \n```", "```cpp\nglGenVertexArrays(1, &vaoHandle); \nglBindVertexArray(vaoHandle); \nglEnableVertexAttribArray(0); \nglEnableVertexAttribArray(1); \n\nglBindVertexBuffer(0, positionBufferHandle, 0, sizeof(GLfloat)*3); \nglBindVertexBuffer(1, colorBufferHandle, 0, sizeof(GLfloat)*3); \n\nglVertexAttribFormat(0, 3, GL_FLOAT, GL_FALSE, 0); \nglVertexAttribBinding(0, 0); \nglVertexAttribFormat(1, 3, GL_FLOAT, GL_FALSE, 0); \nglVertexAttribBinding(1, 1); \n```", "```cpp\nlayout (location = 0) out vec4 FragColor;\n```", "```cpp\nglBindAttribLocation(programHandle, 0, \"VertexPosition\"); \nglBindAttribLocation(programHandle, 1, \"VertexColor\"); \n```", "```cpp\nglBindFragDataLocation(programHandle, 0, \"FragColor\"); \n```", "```cpp\nGLint numAttribs; \nglGetProgramInterfaceiv(programHandle, GL_PROGRAM_INPUT,\n        GL_ACTIVE_RESOURCES, &numAttribs);\n```", "```cpp\nGLenum properties[] = {GL_NAME_LENGTH, GL_TYPE, GL_LOCATION};\n\nstd::cout << \"Active attributes\" << std::endl; \nfor( int i = 0; i < numAttribs; ++i ) { \n  GLint results[3]; \n  glGetProgramResourceiv(programHhandle, GL_PROGRAM_INPUT,\n        i, 3, properties, 3, NULL, results); \n\n  GLint nameBufSize = results[0] + 1; \n  char * name = new char[nameBufSize]; \n  glGetProgramResourceName(programHandle, \n       GL_PROGRAM_INPUT, i, nameBufSize, NULL, name);  \n  printf(\"%-5d %s (%s)n\", results[2], name, \n  getTypeString(results[1])); \n  delete [] name; \n}\n```", "```cpp\n    Active attributes:\n    1    VertexColor (vec3)\n    0    VertexPosition (vec3)\n```", "```cpp\n#version 430 \n\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexColor; \n\nout vec3 Color; \n\nuniform mat4 RotationMatrix; \n\nvoid main() { \n  Color = VertexColor; \n  gl_Position = RotationMatrix * vec4(VertexPosition,1.0); \n} \n```", "```cpp\n#version 460 \n\nin vec3 Color; \n\nlayout (location = 0) out vec4 FragColor; \n\nvoid main() { \n  FragColor = vec4(Color, 1.0); \n} \n```", "```cpp\n#include <glm/glm.hpp> \n#include <glm/gtc/matrix_transform.hpp> \n```", "```cpp\nglClear(GL_COLOR_BUFFER_BIT); \n\nglm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), angle, \n       glm::vec3(0.0f,0.0f,1.0f));\nGLuint location = glGetUniformLocation(programHandle,\n       \"RotationMatrix\"); \n\nif( location >= 0 ) { \n  glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(rotationMatrix)); \n} \n\nglBindVertexArray(vaoHandle); \nglDrawArrays(GL_TRIANGLES, 0, 3 ); \n```", "```cpp\nGLuint location = \n   glGetUniformLocation( programHandle, \"MyArray[1]\" );\n```", "```cpp\nGLuint location = \n   glGetUniformLocation( programHandle, \"MyMatrices.Rotation\" );\n```", "```cpp\nGLint numUniforms = 0; \nglGetProgramInterfaceiv( handle, GL_UNIFORM, \n   GL_ACTIVE_RESOURCES, &numUniforms);\n```", "```cpp\nGLenum properties[] = {GL_NAME_LENGTH, GL_TYPE, \n   GL_LOCATION, GL_BLOCK_INDEX}; \n\nstd::cout << \"Active uniforms\" << std::endl; \nfor( int i = 0; i < numUniforms; ++i ) { \n  GLint results[4]; \n  glGetProgramResourceiv(handle, GL_UNIFORM, i, 4, \n       properties, 4, NULL, results); \n  if( results[3] != -1 )  \n        continue;    // Skip uniforms in blocks  \n  GLint nameBufSize = results[0] + 1; \n  char * name = new char[nameBufSize]; \n  glGetProgramResourceName(handle, GL_UNIFORM, i, \n       nameBufSize, NULL, name);\n  printf(\"%-5d %s (%s)n\", results[2], name, \n       getTypeString(results[1])); \n  delete [] name; \n} \n```", "```cpp\n    Active uniforms:\n    0    RotationMatrix (mat4)\n```", "```cpp\nuniform BlobSettings { \n  vec4 InnerColor; \n  vec4 OuterColor; \n  float RadiusInner; \n  float RadiusOuter; \n}; \n```", "```cpp\n#version 430 \n\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexTexCoord; \n\nout vec3 TexCoord; \n\nvoid main() { \n  TexCoord = VertexTexCoord; \n  gl_Position = vec4(VertexPosition,1.0); \n} \n```", "```cpp\n#version 430 \n\nin vec3 TexCoord; \nlayout (location = 0) out vec4 FragColor; \n\nlayout (binding = 0) uniform BlobSettings { \n  vec4 InnerColor; \n  vec4 OuterColor; \n  float RadiusInner; \n  float RadiusOuter; \n}; \n\nvoid main() { \n  float dx = TexCoord.x - 0.5; \n  float dy = TexCoord.y - 0.5; \n  float dist = sqrt(dx * dx + dy * dy); \n  FragColor =\n    mix( InnerColor, OuterColor,\n       smoothstep( RadiusInner, RadiusOuter, dist )); \n} \n```", "```cpp\nGLuint blockIndex = glGetUniformBlockIndex(programHandle, \n   \"BlobSettings\");\n```", "```cpp\nGLint blockSize; \nglGetActiveUniformBlockiv(programHandle, blockIndex,\n        GL_UNIFORM_BLOCK_DATA_SIZE, &blockSize); \n\nGLubyte * blockBuffer; \nblockBuffer = (GLubyte *) malloc(blockSize); \n```", "```cpp\nconst GLchar *names[] = { \"InnerColor\", \"OuterColor\",\n       \"RadiusInner\", \"RadiusOuter\" }; \nGLuint indices[4]; \nglGetUniformIndices(programHandle, 4, names, indices); \n\nGLint offset[4]; \nglGetActiveUniformsiv(programHandle, 4, indices, \n       GL_UNIFORM_OFFSET, offset);\n```", "```cpp\n// Store data within the buffer at the appropriate offsets \nGLfloat outerColor[] = {0.0f, 0.0f, 0.0f, 0.0f}; \nGLfloat innerColor[] = {1.0f, 1.0f, 0.75f, 1.0f}; \nGLfloat innerRadius = 0.25f, outerRadius = 0.45f; \n\nmemcpy(blockBuffer + offset[0], innerColor, \n       4 * sizeof(GLfloat));\nmemcpy(blockBuffer + offset[1], outerColor, \n       4 * sizeof(GLfloat));\nmemcpy(blockBuffer + offset[2], &innerRadius, \n       sizeof(GLfloat));\nmemcpy(blockBuffer + offset[3], &outerRadius, \n       sizeof(GLfloat));\n```", "```cpp\nGLuint uboHandle; \nglGenBuffers( 1, &uboHandle ); \nglBindBuffer( GL_UNIFORM_BUFFER, uboHandle ); \nglBufferData( GL_UNIFORM_BUFFER, blockSize, blockBuffer, \n       GL_DYNAMIC_DRAW );\n```", "```cpp\nglBindBufferBase(GL_UNIFORM_BUFFER, 0, uboHandle); \n```", "```cpp\nuniform BlobSettings { \n  vec4 InnerColor; \n  vec4 OuterColor; \n  float RadiusInner; \n  float RadiusOuter; \n} Blob;\n```", "```cpp\nFragColor =\n    mix( Blob.InnerColor, Blob.OuterColor,\n        smoothstep( Blob.RadiusInner, Blob.RadiusOuter, dist ) \n  ); \n```", "```cpp\nconst GLchar *names[] = { \"BlobSettings.InnerColor\",  \n      \"BlobSettings.OuterColor\", \"BlobSettings. RadiusInner\", \n      \"BlobSettings.RadiusOuter\" }; \nGLuint indices[4]; \nglGetUniformIndices(programHandle, 4, names, indices); \n```", "```cpp\nlayout( std140 ) uniform BlobSettings { \n\n}; \n```", "```cpp\nlayout( row_major, shared ) uniform BlobSettings { \n   // ...\n}; \n```", "```cpp\nout gl_PerVertex {\n  vec4 gl_Position;\n  float gl_PointSize;\n  float gl_ClipDistance[];\n};\n```", "```cpp\nstd::string vertCode  = loadShaderCode(\"separable.vert.glsl\");\nstd::string fragCode1 = loadShaderCode(\"separable1.frag.glsl\");\nstd::string fragCode2 = loadShaderCode(\"separable2.frag.glsl\");\n```", "```cpp\nGLuint programs[3];\nconst GLchar * codePtrs = {vertCode.c_str(), fragCode1.c_str(),  \n  fragCode2.c_str()};\nprograms[0] = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, codePtrs);\nprograms[1] = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, codePtrs + 1);\nprograms[2] = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, codePtrs + 2);\n\n// Check for errors...\n```", "```cpp\nGLuint pipelines[2];\nglCreateProgramPipelines(2, pipelines);\n// First pipeline\nglUseProgramStages(pipelines[0], GL_VERTEX_SHADER_BIT, programs[0]);\nglUseProgramStages(pipelines[0], GL_FRAGMENT_SHADER_BIT, programs[1]);\n// Second pipeline\nglUseProgramStages(pipelines[1], GL_VERTEX_SHADER_BIT, programs[0]);\nglUseProgramStages(pipelines[1], GL_FRAGMENT_SHADER_BIT, programs[2]);\n```", "```cpp\nGLint location = glGetUniformLocation(programs[0], uniformName);\nglProgramUniform3f(programs[0], location, 0, 1, 0);\n```", "```cpp\nglUseProgram(0);\n```", "```cpp\nglBindProgramPipeline(pipelines[0]);\n// Draw...\nglBindProgramPipeline(pipelines[1]);\n// Draw...\n```", "```cpp\nGLuint program = glCreateProgram();\nglProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);\n\nglAttachShader(program, vertShader);\n\nglLinkProgram(program);\n// Check for errors...\n```", "```cpp\nglfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE); \n```", "```cpp\nglEnable(GL_DEBUG_OUTPUT); \n```", "```cpp\nvoid debugCallback(GLenum source, GLenum type, GLuint id, \n       GLenum severity, GLsizei length, \n       const GLchar * message, const void * param) { \n\n    // Convert GLenum parameters to strings \n  printf(\"%s:%s[%s](%d): %sn\", sourceStr, typeStr, \n       severityStr, id, message); \n}\n```", "```cpp\nglDebugMessageCallback( debugCallback, nullptr ); \n```", "```cpp\nglDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, \n       GL_DONT_CARE, 0, NULL, GL_TRUE);\n```", "```cpp\nclass GLSLProgramException : public std::runtime_error { \npublic: \n  GLSLProgramException( const string & msg ) : \n       std::runtime_error(msg) { } \n};\n```", "```cpp\nnamespace GLSLShader { \n  enum GLSLShaderType { \n        VERTEX = GL_VERTEX_SHADER,  \n        FRAGMENT = GL_FRAGMENT_SHADER,  \n        GEOMETRY = GL_GEOMETRY_SHADER,  \n        TESS_CONTROL = GL_TESS_CONTROL_SHADER,\n        TESS_EVALUATION = GL_TESS_EVALUATION_SHADER,  \n        COMPUTE = GL_COMPUTE_SHADER \n  }; \n}; \n```", "```cpp\nclass GLSLProgram  { \nprivate: \n  int  handle; \n  bool linked; \n  std::map<string, int> uniformLocations;\n  GLint getUniformLocation(const char *);\n\n  // A few other helper functions \n\npublic: \n  GLSLProgram();\n  ~GLSLProgram();\n\n  // Make it non-copyable\n  GLSLProgram(const GLSLProgram &) = delete;\n  GLSLProgram & operator=(const GLSLProgram &) = delete; \n\n  void compileShader( const char * filename );  \n  void compileShader( const char * filename, \n  GLSLShader::GLSLShaderType type );\n  void compileShader( const string & source, \n       GLSLShader::GLSLShaderType type,\n       const char * filename = nullptr );\n  void link();\n  void use();\n  void validate();\n\n  int    getHandle(); \n  bool   isLinked(); \n\n  void   bindAttribLocation( GLuint location, const char * name);  \n  void   bindFragDataLocation( GLuint location, const char * name );  \n  void   setUniform(const char *name, float x, float y, float z); \n  void   setUniform(const char *name, const glm::vec3 & v); \n  void   setUniform(const char *name, const glm::vec4 & v); \n  void   setUniform(const char *name, const glm::mat4 & m); \n  void   setUniform(const char *name, const glm::mat3 & m); \n  void   setUniform(const char *name, float val ); \n  void   setUniform(const char *name, int val ); \n  void   setUniform(const char *name, bool val );\n\n  void findUniformLocations();\n  // ... \n};\n```", "```cpp\nGLSLProgram prog; \n\ntry { \n  prog.compileShader(\"myshader.vert.glsl\"); \n  prog.compileShader(\"myshader.frag.glsl\"); \n  prog.link(); \n  prog.validate(); \n  prog.use(); \n} catch( GLSLProgramException &e ) { \n  cerr << e.what() << endl; \n  exit(EXIT_FAILURE); \n} \n\nprog.setUniform(\"ModelViewMatrix\", matrix); \nprog.setUniform(\"LightPosition\", 1.0f, 1.0f, 1.0f); \n```"]