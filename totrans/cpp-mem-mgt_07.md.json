["```cpp\nvoid* malloc(size_t n);\nvoid free(void *p);\n```", "```cpp\n#include <cstdlib>\nint main() {\n   using std::malloc, std::free;\n   int *p = static_cast<int*>(malloc(sizeof(int)));\n   free(p); // fine since it comes from malloc()\n   free(p); // NOOOOOO unless (stroke of luck?) p is null\n}\n```", "```cpp\nvoid *operator new(std::size_t);\nvoid *operator new[](std::size_t);\nvoid operator delete(void *) noexcept;\nvoid operator delete[](void *) noexcept;\n// since C++14\nvoid operator delete(void *, std::size_t) noexcept;\nvoid operator delete[](void *, std::size_t) noexcept;\n```", "```cpp\nX *p = new X{ /* ... args ... */ };\n```", "```cpp\n// allocate enough space to put an X object\nvoid * buf = operator new(sizeof(X));\n// construct an X object at that location\nX *p = ... // apply X::X( /* ... args ... */ ) on buf\n```", "```cpp\ndelete p; // suppose that p is of type X*\n```", "```cpp\np->~X(); // destroy the pointed-to object\noperator delete(p); // free the associated memory\n```", "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <new>\nvoid *operator new(std::size_t n) {\n    std::cout << \"operator new(\" << n << \")\\n\";\n    auto p = std::malloc(n);\n    if(!p) throw std::bad_alloc{};\n    return p;\n}\nvoid operator delete(void *p) noexcept {\n    std::cout << \"operator delete(...)\\n\";\n    std::free(p);\n}\nvoid operator delete(void *p, std::size_t n) noexcept {\n    std::cout << \"operator delete(..., \" << n << \")\\n\";\n    ::operator delete(p);\n}\nvoid *operator new[](std::size_t n) {\n    std::cout << \"operator new[](\" << n << \")\\n\";\n    auto p = std::malloc(n);\n    if(!p) throw std::bad_alloc{};\n    return p;\n}\nvoid operator delete[](void *p) noexcept {\n    std::cout << \"operator delete[](...)\\n\";\n    std::free(p);\n}\nvoid operator delete[](void *p, std::size_t n) noexcept {\n    std::cout << \"operator delete[](..., \" << n << \")\\n\";\n    ::operator delete[](p);\n}\nint main() {\n   auto p = new int{ 3 };\n   delete p;\n   p = new int[10];\n   delete []p;\n}\n```", "```cpp\nvoid *operator new(std::size_t, const std::nothrow_t&);\nvoid *operator new[](std::size_t, const std::nothrow_t&);\nvoid operator delete(void *, const std::nothrow_t&)\n   noexcept;\nvoid operator delete[](void *, const std::nothrow_t&)\n   noexcept;\n// since C++14\nvoid operator delete\n   (void *, std::size_t, const std::nothrow_t&) noexcept;\nvoid operator delete[]\n   (void *, std::size_t, nullptr than to just write it as if no failure occurred! The fact is that there are costs to using exceptions in one’s programs: it can make binaries slightly bigger, and it can slow down code execution, particularly when exceptions are caught (there are also issues of style involved; some people would not use exceptions even if they led to faster code, and that’s just part of life). For that reason, application domains such as games or embedded systems often shun exceptions and go to some lengths to write code that does not depend on them. The non-throwing versions of the allocation functions target these domains.\nType `std::nothrow_t` is what is called a `std::nothrow` object) can be used to guide the compiler when generating code. Note that these function signatures require the `std::nothrow_t` arguments to be passed by `const` reference, not by value, so make sure you respect this signature if you seek to replace them.\nAn example usage of these functions would be as follows:\n\n```", "```cpp\n\n You might be surprised about the position of `nothrow` in the `new` expression, but if you think about it, it’s essentially the only syntactic space for additional arguments passed to `operator new()`; the first argument passed to the function is the number of contiguous bytes to allocate (here: `sizeof(X)`), and in expression `new X { ...args... }`, what follows the type of object to construct is the list of arguments passed to its constructor. Thus, the place to specify the additional arguments to `operator new()` itself is between `new` and the type of the object to construct, between parentheses.\nA word on the position of additional arguments to operator new()\nTo illustrate this better with an artificially crafted example, one could write the following `operator` `new()` overload:\n`void* operator new(std::size_t,` `);`\nThen, a possible call to that hypothetical operator would be as follows:\n`X *p = new (3, 1.5) X{ /* ... */ };`\nHere, we can see how two additional arguments, an `int` argument and a `double` argument, are passed by client code.\nReturning to the `nothrow` version of `operator new()` and `operator new[]()`, one thing that is subtle and needs to be understood is why one needs to write overloads of `operator delete()` and `operator delete[]()`. After all, even with client code that uses the `nothrow` version of `new`, as was the case in our example, it’s highly probable that the “normal” version of `operator delete()` will be used to end the life of that object. Why, then, write a `nothrow` version of `operator delete()`?\nThe reason is `operator new()`? Well, remember that memory allocation through `operator new()` is a two-step operation: find the location to place the object, then construct the object at that location. Thus, even if `operator new()` does not throw, we do not know whether the constructor that will be called will throw. Our code will obtain the pointer only after both the allocation *and* the construction that follows have successfully completed execution; as such, client code cannot manage exceptions that occur after allocation succeeded but during the construction of the object, at least not in such a way as to deallocate the memory… It’s difficult to deallocate a pointer your code has not yet seen!\nFor that reason, it falls on the C++ runtime to perform the deallocation if an exception is thrown by the constructor, and this is true for all versions of `operator new()`, not just the `nothrow` ones. The algorithm (informally) is as follows:\n\n```", "```cpp\n\n As this algorithm shows, the C++ runtime has to deallocate the memory for us when the constructor throws an exception. But how does it do so? Well, it will use the `operator delete()` (or `operator delete[]()`) whose signature matches that of the version of `new` or `new[]` that was used to perform the allocation. For example, if we use `operator new(size_t,``)` to allocate and the constructor fails, it will use `operator delete(void*,``)` to perform the implicit deallocation.\nThat is the reason why, if we overload the `nothrow` versions of `new` and `new[]`, we have to overload the `nothrow` versions of `delete` and `delete[]` (they will be used for deallocation if a constructor throws), and why we also have to overload the “normal” throwing versions of `new`, `new[]`, `delete`, and `delete[]`. Expressed informally, code that uses `X *p = new(nothrow)X;` will usually call `delete p;` to end the life of the pointee, and as such, the `nothrow` and throwing versions of the allocation functions have to be coherent with one another.\nHere is a full, yet naïve implementation where the throwing versions delegate to the non-throwing ones to reduce repetition:\n\n```", "```cpp\n\n As you can see, there are quite a few functions to write to get a full, cohesive set of allocation operators if we want to cover both the throwing and the non-throwing versions of this mechanism.\nWe still have a lot to cover. For example, we mentioned a few times already the idea of placing an object at a specific memory location, in particular at the second of the two-step process modeled by calls to `new`. Let’s see how this is done.\nThe most important operator new: placement new\nThe most important version of `operator new()` and friends is not one you can replace, but even if you could… well, let’s just state that it would be difficult to achieve something more efficient:\n\n```", "```cpp\n\n We call these the placement allocation functions, mostly known as **placement new** by the programming community.\nWhat is the purpose of these functions? You might remember, at the beginning of our discussion of the global versions of the allocation operators, that we stated: “What `new` does is find the location where an object will be constructed.” This does not necessarily mean that `new` will allocate memory, and indeed, placement `new` does not allocate; it simply yields back the address it has been given as argument. *This allows us to place an object wherever we want in memory*… as long as we have the right to write the memory at that location.\nPlacement `new` serves many purposes:\n\n*   If we have sufficient rights, it can let us map an object onto a piece of memory-mapped hardware, giving us an *extremely* thin layer of abstraction over that device.\n*   It enables us to decouple allocation from construction, leading to significant speed improvements when writing containers.\n*   It opens up options to implement important facilities such as types `optional<T>` (that might or might not store a `T` object) and `variant<T0,T1,...,Tn>` (that stores an object of one of types `T0`,`T1`,...,`Tn`), or even `std::string` and `std::function` that sometimes allocate external memory, but sometimes use their internal data structures and avoid allocation altogether. Placement `new` is not the only way to do this, but it is one of the options in our toolbox.\n\nOne important benefit of placement `new` is most probably in the implementation of containers and the interaction between containers and allocators, themes we will explore from [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172) to [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199) of this book. For now, we will limit ourselves to a simple, artificial example that’s meant as an illustration of how placement `new` works its magic, not as an example of something you should do (indeed, you should *not* do what the following example does!).\nSuppose that you want to compute the length of a null-delimited character string and cannot remember the name of the C function that efficiently computes its length (better known as `std::strlen()`). One way to achieve similar results but *much* less efficiently would be to write the following:\n\n```", "```cpp\n\n That’s inefficient because the `std::string` constructor might allocate memory. We just wanted to count the characters until the first occurrence of a zero in the sequence, but it works (note: if you do the same maneuver with a `std::string_view` instead of with a `std::string`, its performance will actually be quite reasonable!). Now, suppose you want to show off to your friends the fact that you can place an object where you want in memory, and then use that object’s data members to do what you set out to do. You can (but should not) write the following:\n\n```", "```cpp\n\n What are the benefits of the complicated version in comparison to the simple one? None whatsoever, but it shows the intricacies of doing this sort of low-level memory management maneuver. From the comments in the code example, the steps work as follows:\n\n*   Step `A)` makes sure that the location where the object will be constructed is of the right size and shape: it’s a buffer of bytes (type `char`), aligned in memory as a `std::string` object should be, and of sufficient size to hold a `std::string` object.\n*   Step `B)` paints a `std::string` object in that buffer. That’s what a constructor does, really: it (conceptually) transforms raw memory into an object and initializes the state of that object. If the `std::string` constructor throws an exception, then the object has never been constructed and our `string_length()` function concludes without satisfying its postconditions. There is no memory allocation involved here unless the constructor itself allocates, but that’s fair (the object does what it has to do).\n*   Step `C)` uses the newly constructed object; in our case, it’s just a matter of querying the size of that character string, but we could do whatever we want here. Do note, however, that (a) the object’s lifetime is tied to the buffer in which it is located, and (b) since we explicitly called the constructor, we will need to explicitly destroy it, which means that if an exception is thrown when we use the object, we will need to make sure the object’s destructor is called somehow.\n*   Step `D)` destroys the object before we leave the function, as not doing so would lead to a possible leak of resources. If the buffer’s lifetime ends at a point where the object is not yet destroyed, things will be very wrong: either the destructor of the object we put in that buffer will never be called and code will leak, or someone might try to use the object even though the storage for that object is not ours anymore, leading to UB. Note the syntax, `s->~string()`, which calls the destructor but does not deallocate the storage for `*s`.\n\nThis is a bad example of placement `new` usage, but it is explicit and (hopefully) instructive. We will use this feature in much more reasonable ways in order to gain significant speed advantages when we write containers with explicit memory management in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172).\nA note on make_shared<T>(args...)\nWe mentioned in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096) that `make_shared<T>(args...)` usually leads to a better memory layout than `shared_ptr<T>{ new T(args...) }` would, at least with respect to cache usage. We can start to see why that is so.\nCalling `shared_ptr<T>::shared_ptr(T*)` makes the object responsible for a preexisting pointee, the one whose address is passed as argument. Since that object has been constructed, the `shared_ptr<T>` object has to allocate a reference counter separately, ending up with two separate allocations, probably on different cache lines. In most programs, this worsened locality may induce slowdowns at runtime.\nOn the other hand, calling `make_shared<T>(args...)` makes this factory function responsible for creating a block of memory whose layout accommodates the `T` object and the reference counter, respecting the size and alignment constraints of both. There’s more than one way to do this, of course, including (a) resorting to a `union` where “coexist” a pair of pointers and a single pointer to a block that contains a counter and a `T` object, and (b) resorting to a byte buffer of appropriate size and alignment, then performing placement `new` for both objects in the appropriate locations within that buffer. In the latter case, we end up with a single allocation for a contiguous block of memory able to host both objects and two placement `new` calls.\nMember versions of the allocation operators\nSometimes, we have special knowledge of the needs and requirements of specific types with respect to dynamic memory allocation. A full example that goes into detail about a real-life (but simplified) use case of such type-specific knowledge is given in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153), where we discuss arena-based allocation.\nFor now, we will limit ourselves to covering the syntax and the effect of a member function overload of the allocation operators. In the example that follows, we suppose class `X` would somehow benefit from a per-class specialization of these mechanisms, and show that client code will call these specializations when we call `new X` but not when we call `new int`:\n\n```", "```cpp\n\n One important detail to mention is that these overloaded operators will be inherited by derived classes, which means that if the implementation of these operators somehow depends on details specific to that class – for example, its size of alignment or anything else that might be invalidated in derived classes through such seemingly inconspicuous details as adding a data member – consider marking the class that overloads these operators as `final`.\nAlignment-aware versions of the allocation operators\nWhen designing C++17, a fundamental problem with the memory allocation process was fixed with respect to what we call `std::max_align_t`.\nThere are many reasons for this, but a simple example would be when communicating with specialized hardware with requirements that differ from the ones on our computer. Suppose the following `Float4` type is such a type. Its size is `4*sizeof(float)`, and we require a `Float4` to be aligned on a 16-byte boundary:\n\n```", "```cpp\n\n In this example, if we remove `alignas(16)` from the type declaration, the natural alignment of type `Float4` would be `alignof(float)`, which is probably 4 on most platforms.\nThe problem with such types before C++17 is that variables generated by the compiler would respect our alignment requirements, but those located in dynamically allocated storage would, by default, end up with an alignment of `std::max_align_t`, which would be incorrect. That makes sense, of course; functions such as `malloc()` and `operator new()` will, by default, cover the “worst-case scenario” of the platform, not knowing what will be constructed in the allocated storage, but they cannot be assumed to implicitly cover even worse scenarios than this.\nSince C++17, we can specify `operator new()` or `operator new[]()` by passing an additional argument of type `std::align_val_t`, an integral type. This has to be done explicitly at the call site, as the following example shows:\n\n```", "```cpp\n\n The memory block allocated for `p` in this example will be aligned on a boundary of `std::max_align_t`, whereas the memory block allocated for `q` will be aligned on a 16-byte boundary. The former might satisfy the requirements of our type if we’re lucky and cause chaos otherwise; the latter will respect our constraints if the allocation operator overload is implemented correctly.\nDestroying delete\nC++20 brings a novel and highly specialized feature called destroying `delete`. The use case targeted here is a member function overload that benefits from specific knowledge of the type of object being destroyed in order to better perform the destruction process. When that member function is defined for some type `T`, it is preferred over other options when `delete` is invoked on a `T*`, even if `T` exposes another overload of `operator delete()`. To use destroying `delete` for some type `X`, one must implement the following member function:\n\n```", "```cpp\n\n Here, `std::destroying_delete_t` is a tag type like `std::nothrow_t`, which we saw earlier in this chapter. Note that the first argument of the destroying `delete` for class `X` is an `X*`, not a `void*`, as the destroying `delete` has the double role of destroying the object and deallocating memory… hence its name!\nHow does that work, and why is that useful? Let’s look at a concrete example with the following `Wrapper` class. In this example, an object of type `Wrapper` hides one of two implementations, modeled by `Wrapper::ImplA` and `Wrapper::ImplB`. The implementation is selected at construction time based on an enumerated value of type `Wrapper::Kind`. The intent is to remove the need for `virtual` functions from this class, replacing them with `if` statements based on the kind of implementation that was chosen. Of course, in this (admittedly) small example, there’s still only one `virtual` function (`Impl::f()`) as we aim to minimize the example’s complexity. There is also a wish to keep the destructor of class `Wrapper` trivial, a property that can be useful on occasion.\nWe will look at this example step by step as it is a bit more elaborate than the previous ones. First, let’s examine the basic structure of `Wrapper` including `Wrapper::Kind`, `Wrapper::Impl`, and its derived classes:\n\n```", "```cpp\n\n Visibly, `Wrapper::Impl` does not have a `virtual` destructor, yet `Wrapper` keeps as a data member an `Impl*` named `p`, which means that simply calling `delete p` might not call the appropriate destructor for the pointed-to object.\nThe `Wrapper` class exposes a constructor that takes a `Kind` as argument, then calls `Wrapper::create()` to construct the appropriate implementation, modeled by a type derived from `Impl`:\n\n```", "```cpp\n\n Now comes the destroying `delete`. Since we know by construction that the only possible implementations would be `ImplA` and `ImplB`, we test `p->kind` to know which one was chosen for `p`, then directly call the appropriate destructor. Once that is done, the `Wrapper` object itself is finalized and memory is freed through a direct call to `operator delete()`:\n\n```", "```cpp\n\n For client code, the fact that we decided to use a destroying `delete` is completely transparent:\n\n```", "```cpp\n\n The destroying `delete` is a recent C++ facility as of this writing, but it is a tool that can let us get more control over the destruction process of our objects. Most of your types probably do not need this feature, but it’s good to know it exists for those cases where you need that extra bit of control over execution speed and program size. As always, measure the results of your efforts to ensure that they bring the desired benefits.\nSummary\nWhew, that was quite the ride! Now that we have the basics of memory allocation operator overloading handy, we will start to use them to our advantage. Our first application will be a leak detector ([*Chapter 8*](B21071_08.xhtml#_idTextAnchor128)) using the global forms of these operators, followed by simplified examples of exotic memory management ([*Chapter 9*](B21071_09.xhtml#_idTextAnchor141)) using specialized, custom forms of the global operators, and arena-based memory management ([*Chapter 10*](B21071_10.xhtml#_idTextAnchor153)) with member versions of the operators that will perform very satisfying optimizations.\n\n```"]