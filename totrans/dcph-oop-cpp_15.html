<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-243"><a id="_idTextAnchor655"/>15</h1>
<h1 id="_idParaDest-244"><a id="_idTextAnchor656"/>Testing Classes and Components</h1>
<p>This chapter will continue our pursuit of increasing your C++ programming repertoire beyond OOP concepts through exploring means to test the classes and components that comprise our OO programs. We will explore various strategies to help ensure that the code we write will be well-tested and robust. </p>
<p>This chapter shows how to test your OO programs through testing individual classes, as well as testing the various components that work together.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the canonical class form and creating robust classes</li>
<li>Creating drivers to test classes </li>
<li>Testing classes related by inheritance, association, or aggregation</li>
<li>Testing exception handling mechanisms</li>
</ul>
<p>By the end of this chapter, you will have various techniques in your programming arsenal to ensure that your code is well-tested before it goes into production. Having the skills to consistently produce robust code will help you become a more beneficial programmer.</p>
<p>Let’s increase our C++ skills set by examining various techniques for OO testing.</p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor657"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter15</code> in a file named <code>Chp15-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3AxyLFH">https://bit.ly/3AxyLFH</a>.</p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor658"/><a id="_idTextAnchor659"/><a id="_idTextAnchor660"/>Contemplating OO testing</h1>
<p><a id="_idTextAnchor661"/>Software testing <a id="_idIndexMarker983"/>is immensely important prior to any code deployment. Testing <a id="_idIndexMarker984"/>object-oriented software will require different techniques than other types of software. Because OO software contains relationships between classes, we must understand how to test dependencies and relationships that may exist between classes. Additionally, each object may progress through different states based on the order that operations are applied to each instance, as well as through specific interactions with related objects (for example, via association). The overall flow of control through an OO application is much more complex than with procedural applications, as the combinations and order of operations applied to a given object and influences from associated objects are numerous.</p>
<p>Nonetheless, there are metrics and processes we can apply to test OO software. These range from understanding idioms and patterns we can apply for class specification, to creating drivers to test classes both independently and as they relate to other classes. These processes can further include creating scenarios to provide likely sequences of events or states that objects may progress through. Relationships between objects, such as inheritance, association, and aggregation become very important in testing; related objects can influence the state of an existing object.</p>
<p>Let’s begin our quest in testing OO software by understanding a simple pattern that we can often apply to classes we develop. This idiom will ensure that a class is potentially complete, with no unexpected behavior. We will start with the canonical class form.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor662"/>Understanding the canonical class form</h1>
<p>For<a id="_idIndexMarker985"/> many classes in C++, it is reasonable to follow a pattern for class specification to ensure that a new class contains a full set of desired components. The <strong class="bold">canonical class form</strong> is a robust specification of a class that enables class instances to provide uniform behavior (analogous to standard data types) in areas such as initialization, assignment, argument passing, and usage in return values from functions. The canonical class form will apply to most classes that are intended for either instantiation or that will serve as public base classes for new derived classes. Classes that are intended to serve as private or protected base classes (even if they may be instantiated themselves) may not follow all parts of this idio<a id="_idTextAnchor663"/><a id="_idTextAnchor664"/>m.</p>
<p>A class<a id="_idIndexMarker986"/> following <strong class="bold">orthodox</strong> canonical form <a id="_idIndexMarker987"/>will include the follo<a id="_idTextAnchor665"/>wing:</p>
<ul>
<li>A default constructor (or an <code>=default</code> prototype to explicitly allow this interface)</li>
<li>A copy constructor</li>
<li>An overloaded assignment operator</li>
<li>A virtual destructor</li>
</ul>
<p>Though any of the aforementioned components may be prototyped with <code>=default</code> to explicitly utilize the default, system-supplied implementations, modern preferences are moving away from such practices (as these prototypes are generally redundant). The exception is the default constructor whose interface you will not otherwise get without using <code>=default</code> when other constructors are present.</p>
<p>A class following the <strong class="bold">extended</strong> canonical form<a id="_idIndexMarker988"/> will additionally<a id="_idIndexMarker989"/> include the following:</p>
<ul>
<li>A <em class="italic">move</em> copy constructor</li>
<li>A <em class="italic">move</em> assignment operator</li>
</ul>
<p>Let’s look at each component of the canonical class form in the next subsections.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor666"/>Default constructor</h2>
<p>A <code>=default</code> to the default constructor prototype; this is especially useful when in-class initialization is utilized.</p>
<p>Additionally, a default constructor for a given class’ base class will be called in the absence of an alternate base class constructor specification in the member initialization list. If a base class has no such default constructor (and one hasn’t been provided because a constructor with another signature exists), the implicit call to the base class constructor will be flagged as an error. </p>
<p>Let’s also<a id="_idIndexMarker992"/> consider multiple<a id="_idIndexMarker993"/> inheritance situations in which a diamond-shaped hierarchy occurs, and virtual base classes are used to eliminate duplication of the most base class subobjects within instances of the most derived class. In this scenario, the default constructor for the now <em class="italic">shared</em> base class subobject is called unless otherwise specified in the member initialization list of the derived class responsible for creating the diamond shape. This occurs even if non-default constructors are specified in the member initialization list at the middle level; remember these specifications are ignored when the mid-levels specify a potentially shared virtual b<a id="_idTextAnchor667"/>ase class.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor668"/>Copy constructor</h2>
<p>A <strong class="bold">copy cons<a id="_idTextAnchor669"/>tructor</strong> is often<a id="_idIndexMarker994"/> crucial for all objects <a id="_idIndexMarker995"/>containing pointer data members. Unless a copy constructor is supplied by the programmer, a system-supplied copy constructor will be linked in when necessary in the application. The system-supplied copy constructor performs a member-wise (shallow) copy of all data members. This means that multiple instances of a class may contain pointers to <em class="italic">shared</em> pieces of memory representing the data that should have been individualized. Unless resource sharing is intended, raw pointer data members in the newly instantiated object will want to allocate their own memory and copy the data values from the source object into this memory. Also, remember to use the member initialization list in a derived class copy constructor to specify the base class’ copy constructor to copy the base class data members. Certainly, copying the base class subobject in a deep fashion is crucial; additionally, the base class data members are inevitably private, so selecting the base class copy constructor in the derived class’ member initialization list is very important.</p>
<p>By specifying a copy constructor, we also help provide an expected manner for the creation of objects passed (or returned) by value from a function. Ensuring deep copies in these scenarios is crucial. The user may think these copies are <em class="italic">by value</em>, yet if their pointer data members are actually shared with the source instance, it’s not truly passing (or returning) an object by value.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor670"/>Overloaded assignment operator</h2>
<p>An <strong class="bold">overloaded assignment operator</strong>, much like the copy constructor, is often also crucial for all objects <a id="_idIndexMarker996"/>containing pointer <a id="_idIndexMarker997"/>data members. The default behavior for the system-supplied assignment operator is a shallow assignment of data from source to destination object. Again, when data members are raw pointers, unless the two objects want to share the resources for heap data members, it is highly recommended that the assignment operator should be overloaded. Allocated space in the destination object should be equal to the source data member sizes for any such pointer data members. The contents (data) should then be copied from source to destination object for each pointer data member.</p>
<p>Also, remember that an overloaded assignment operator is not <em class="italic">inherited</em>; each class is responsible for writing its own version. This makes sense, as the derived class inevitably has more data members to copy than the assignment operator function in its base class. However, when overloading an assignment operator in a derived class, remember to call the base class’ assignment operator to perform a deep assignment of inherited base class members (which may be private and otherwise <a id="_idTextAnchor671"/>inaccessible).</p>
<h2 id="_idParaDest-251">Virtua<a id="_idTextAnchor672"/>l destructor</h2>
<p>A <code>=default</code>).</p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor673"/>Move copy constructor</h2>
<p>A <code>this</code>. We then must null the source object’s pointers to those data members so that both instances do not <em class="italic">share</em> the dynamically allocated data members. We have, in essence, moved (the memory for) the pointer data members. </p>
<p>What about the non-pointer data members? The memory for these data members will be copied as usual. The memory for the non-pointer data members and the memory for the pointers themselves (not the memory pointed to by those pointers), still reside in the source instance. As such, the best we can do is designate a null value (<code>nullptr</code>) for the source object’s pointers and place a <code>0</code> (or similar) value in the non-pointer data members to indicate that these members are no longer relevant.</p>
<p>We will <a id="_idIndexMarker1002"/>use the <code>move()</code> function, found in the C++ Standard Library, to indicate a move copy constructor a<a id="_idTextAnchor674"/>s follows:</p>
<pre class="source-code">
Person p1("Alexa", "Gutierrez", 'R', "Ms.");
Person p2(<strong class="bold">move(p1)</strong>);  // move copy constructor
Person p3 = <strong class="bold">move(p2);</strong> // also the move copy constructor</pre>
<p>Additionally, with classes related by inheritance, we will also use <code>move()</code> in the member initialization list of the derived class move copy constructor. This will specify the base class move copy constructor to help initialize the subobject.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor675"/>Move assignment operator</h2>
<p>A <strong class="bold">move assignment operator</strong> is<a id="_idIndexMarker1003"/> much like an <a id="_idIndexMarker1004"/>overloaded assignment operator and is often crucial for all objects containing pointer data members. However, the goal is to again conserve memory by <em class="italic">moving</em> the dynamically allocated data of the source object to the destination object (versus performing a deep assignment). As with the overloaded assignment operator, we will test for self-assignment and then delete any previously dynamically allocated data members from the (pre-existing) destination object. However, we will then simply copy the pointer data members from the source object to those in the destination object. We will also null out the pointers in the source object so that the two instances do not share these dynamically allocated data members.</p>
<p>Also, much like the move copy constructor, non-pointer data members will be simply copied from source to destination object and replaced with a <code>nullptr</code> value in the source object to indicate non-usage. </p>
<p>We will again use the <code>move(<a id="_idTextAnchor676"/>)</code> function as follows:</p>
<pre class="source-code">
Person p3("Alexa", "Gutierrez", 'R', "Ms.")<a id="_idTextAnchor677"/>;
Person p5("Xander", "LeBrun", 'R', "Dr.");
p5 = <strong class="bold">move(p3);</strong>  // move assignment; replaces p5</pre>
<p>Additionally, with classes<a id="_idIndexMarker1005"/> related by<a id="_idIndexMarker1006"/> inheritance, we can again specify that the move assignment operator of the derived class will call the base class move assignment operator to help complete the task.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor678"/>Bringing the components of canonical class form together</h2>
<p>Let’s see an example of a pair of classes that embrace the canonical class form. We will start with our <code>Person</code> class. This example<a id="_idIndexMarker1007"/> can be found, as a complete program, in our GitHub repository: </p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp</a></p>
<pre class="source-code">
class Person
{
private:    // Note slightly modified data members
    string firstName, lastName;
    char middleInitial = '\0';   // in-class initialization
    // pointer data member to demo deep copy and operator =
    char *title = nullptr;      // in-class initialization
protected: // Assume usual protected member functions exist 
public:
    <strong class="bold">Person() = default;</strong>      <strong class="bold">// default constructor</strong>
    // Assume other usual constructors exist  
    <strong class="bold">Person(const Person &amp;);</strong>  <strong class="bold">// copy constructor</strong>
    <strong class="bold">Person(Person &amp;&amp;);</strong>       <strong class="bold">// move copy constructor</strong>
    <strong class="bold">virtual ~Person() { delete [] title };</strong> <strong class="bold">// virtual dest.</strong>
    // Assume usual access functions a<a id="_idTextAnchor679"/>nd virtual fns. exist 
    <strong class="bold">Person &amp;operator=(const Person &amp;);</strong>  <strong class="bold">// assignment op.</strong>
    <strong class="bold">Person &amp;operator=(Person &amp;&amp;);</strong>  <strong class="bold">// move assignment op.<a id="_idTextAnchor680"/></strong>
};
<strong class="bold">// copy constructor</strong>
Person::Person(const Person &amp;p): firstName(p.firstName),
      lastName(p.lastName), middleInitial(p.middleInitial)
{ 
    // Perform a deep copy for the pointer data member 
    // That is, allocate memory, then copy contents
    title = new char [strlen(p.title) + 1];
    strcpy(title, p.title);
}
<strong class="bold">// overloaded assignment operator</strong>
Person &amp;Person::operator=(const Person &amp;p)
{
    if (this != &amp;p)  // check for self-assignment
    {
       // delete existing Person ptr data mbrs. for 'this'
       delete [] title;
       // Now re-allocate correct size and copy from source
       // Non-pointer data members are simply copied from
       // source to destination object
       firstName = p.firstName; // assignment btwn. strings
       lastName = p.lastName;
       middleInitial = p.middleInitial;
       title = new char [strlen(p.title) + 1]; // mem alloc 
       strcpy(title, p.title);
    }
    return *this;  // allow for cascaded assignments
}</pre>
<p>In the<a id="_idIndexMarker1008"/> previous class definition, we notice that <code>Person</code> contains a default constructor, copy constructor, overloaded assignment operator, and a virtual destructor. Here, we have embraced the orthodox canonical class form as a pattern applicable for a class that might one day serve as a public base class. Also notice that we have added the prototypes for the move copy constructor and move assignment operator to additionally embrace the extended canonical class form. </p>
<p>The prototypes of the move copy constructor <code>Person(Person &amp;&amp;);</code> and the move assignment operator <code>Person &amp;operator=(Person &amp;&amp;);</code> contain parameters of type <code>Person &amp;&amp;</code>. These are examples <a id="_idIndexMarker1009"/>of <code>Person &amp;</code>, will bind to the original copy constructor and overloaded assignment operator, whereas r-value reference parameters will bind to the appli<a id="_idTextAnchor681"/>cable move methods instead.</p>
<p>Let’s now<a id="_idIndexMarker1011"/> look at the definitions for the methods contributing to the extended canonical class form – the move copy constructor and the move assignment operator for <code>Person</code>:</p>
<pre class="source-code">
<strong class="bold">// move copy constructor</strong>
Person::Person(Person &amp;&amp;p): firstName(p.firstName), 
    lastName(p.lastName), middleInitial(p.middleInitial),
    title(p.title)  // dest ptr t<a id="_idTextAnchor682"/>akes <a id="_idTextAnchor683"/>over src ptr's memory
{   
    // Overtake source object's dynamically alloc. memory
    // or use simple assignments (non-ptr data members) 
    // to copy source object's members in member init. list 
    // Then null-out source object's ptrs to that memory
    // Clear source obj's string mbrs, or set w null char
    p.firstName.clear(); // set src object to empty string
    p.lastName.clear();
    p.middleInitial = '\0'; // null char indicates non-use
    p.title = nullptr; // null out src ptr; don't share mem
}
<strong class="bold">// move overloaded assignment operator</strong>
Person &amp;Person::operator=(Person &amp;&amp;p)
{ 
    if (this != &amp;p)       // check for self-assignment
    {
        // delete destination object's ptr data members
        delete [] title;      
        // for ptr mbrs: overtake src obj's dynam alloc mem
        // and null source object's pointers to that memory
        // for non-ptr mbrs, a simple assignment suffices
        // followed by clearing source data member
        firstName = p.firstName;  // string assignment
        p.firstName.clear();   // clear source data member 
        lastName = p.lastName;
        p.lastName.clear();
        middleInitial = p.middleInitial; // simple<a id="_idTextAnchor684"/> =
        p.middleInitial = '\0'; // null char shows non-use
        title = p.title; // ptr assignment to take over mem
        p.title = nullptr;   // null out src pointer
    }
    return *this;  // allow for cascaded assignments  
}</pre>
<p>Notice, in the <a id="_idIndexMarker1012"/>preceding move copy constructor for data members that are pointers, we overtake the source object’s dynamically allocated memory by using simple pointer assignments in the member initialization list (versus memory allocation such as we would employ in a deep copy constructor). We then place a <code>nullptr</code> value in the source object’s pointer data members in the body of the constructor. For non-pointer data members, we simply copy the values from the source to the destination object and place a zeroed or empty value (such as <code>'\0'</code> for <code>p.middleInitial</code> or using <code>clear()</code> for <code>p.firstName</code>) in the source object to indicate its further non-use.</p>
<p>In the move assignment operator, we check for self-assignment and then employ the same scheme to merely move the dynamically allocated memory from the source object to the destination object with a simple pointer assignment. We copy simple data members as well, and of course, replace source object data values with either null pointers (<code>nullptr</code>) or zeroed values to indicate further non-use. The return value of <code>*this</code> allows for cascaded assignments.</p>
<p>Now, let’s see <a id="_idIndexMarker1013"/>how a derived class, <code>Student</code>, employs both the orthodox and extended canonical class form while utilizing its base class components to aid in the implementation of selected idiom methods:</p>
<pre class="source-code">
class Student: public Person
{
private:  
    float gpa = 0.0;        // in-class initialization
    string currentCourse;
    // one pointer data member to demo deep copy and op=
    const char *studentId = nullptr; // in-class init.
    static int numStudents; 
public:
    <strong class="bold">Student();</strong>                 <strong class="bold">// default constructor</strong>
    // Assume other usual constructors exist  
    <strong class="bold">Student(const Student &amp;);</strong>  <strong class="bold">// copy constructor</strong>
    <strong class="bold">Student(Student &amp;&amp;);</strong>       <strong class="bold">// move copy constructor</strong>
    <strong class="bold">~Student() override;</strong>       <strong class="bold">// virtual destructor</strong>
    // Assume usual access functions exist 
    // as well as virtual overrides and additional methods
    <strong class="bold">Student &amp;operator=(const Student &amp;);</strong>  <strong class="bold">// assignment op.</strong>
    <strong class="bold">Student &amp;operator=(Student &amp;&amp;);</strong>  <strong class="bold">// move assignment op.</strong>
};
// See online code for default constructor implementation
// as well as implementation for other usual member fns.
<strong class="bold">// copy constructor</strong>
Student::Student(const Student &amp;s)<strong class="bold">: Person(s)</strong>, 
                 gpa(s.gpa), cu<a id="_idTextAnchor685"/>rrentCourse(s.currentCourse)
{   <strong class="bold">// Use member init. list to specify base copy </strong>
    <strong class="bold">// constructor to initialize base sub-object</strong>
    // Also use mbr init list to set most derived data mbrs
    // Perform deep copy for Student ptr data members 
    // use temp - const data can't be directly modified 
    char *temp = new char [strlen(s.studentId) + 1];
    strcpy (temp, s.studentId);
    studentId = temp;
    numStudents++;
}
<strong class="bold">// Overloaded assignment operator</strong>
Student &amp;Student::operator=(const Student &amp;s)
{
   if (this != &amp;s)   // check for self-assignment
   {   <strong class="bold">// call base class assignment operator</strong>
       <strong class="bold">Person::operator=(s);</strong> 
       // delete existing Student ptr data mbrs for 'this'
       delete [] studentId;
       // for ptr members, reallocate correct size and copy
       // from source; for non-ptr members, just use =
       gpa = s.gpa;  // simple assignment
       currentCourse = s.currentCourse;
       // deep copy of pointer data mbr (use a temp since
       // data is const and can't be directly modified)
       char *temp = new char [strlen(s.studentId) + 1];
       strcpy (temp, s.studentId);
       studentId = temp;
   }
   return *this;
}</pre>
<p>In the preceding class definition, we again see that <code>Student</code> contains a default constructor, a copy constructor, an overloaded assignment operator, and a virtual destructor to complete the orthodox canonical class form. </p>
<p>Notice, however, that in the <code>Student</code> copy constructor, we specify the use of the <code>Person</code> copy constructor through the member initialization list. Similarly, in the <code>Student</code> overloaded assignment operator, once we check for self-assignment, we call the overloaded <a id="_idIndexMarker1014"/>assignment operator in <code>Person</code> to help us complete the task using <code>Person::operator=(s);</code>.</p>
<p>Let’s now look at the method definitions contributing to the extended canonical class form of <code>Student</code> – the move copy constructor and the move assignment operator:</p>
<pre class="source-code">
<strong class="bold">// move copy constructor</strong>
Student::Student(Student &amp;&amp;s)<strong class="bold">: Person(move(s))</strong>, gpa(s.gpa),
    currentCourse(s.currentCourse), 
    studentId(s.studentId) // take over src obj's resource 
{   
    // First, use mbr. init. list to specify base move copy 
    // constructor to initialize base sub-object. Then
    // overtake source object's dynamically allocated mem.
    // or use simple assignments (non-ptr data members) 
    // to copy source object's members in mbr. init. list.
    // Then null-out source object's ptrs to that memory or 
    // clear out source obj's string mbrs. in method body
    s.gpa = 0.0;     // then zero-out source object member
    s.currentCourse.clear();  // clear out source member
    s.studentId = nullptr; // null out src ptr data member
    numStudents++;  // it is a design choice whether or not 
    // to inc. counter; src obj is empty but still exists
}
<strong class="bold">// move assignment operator</strong>
Student &amp;Student::operator=(Student &amp;&amp;s)
{
   // make sure we're not assigning an object to itself
   if (this != &amp;s)
   {
      <strong class="bold">Person::operator=(move(s));</strong>  // call base move oper=
      delete [] studentId;  // delete existing ptr data mbr
      // for ptr data members, take over src objects memory
      // for non-ptr data members, simple assignment is ok
      gpa = s.gpa; // assignment of source to dest data mbr
      s.gpa = 0.0; // zero out source object data member
      currentCourse = s.currentCourse; // string assignment
      s.currentCourse.clear(); // set src to empty string
      studentId = s.studentId; // pointer assignment
      s.studentId = nullptr;   // null out src ptr data mbr
   }
   return *this;  // allow for cascaded assignments
}</pre>
<p>Notice, in the<a id="_idIndexMarker1015"/> previously listed <code>Student</code> move copy constructor, we specify the utilization of the base class move copy constructor in the member initialization list. The remainder of the <code>Student</code> move copy constructor is similar to that found in the <code>Person</code> base class.</p>
<p>Likewise, let’s notice in the <code>Student</code> move assignment operator, the call to the base class move <code>operator=</code> with <code>Person::operator=(move(s));</code>. The remainder of this method is similar to that found in the base class.</p>
<p>A good rule of thumb is that most non-trivial classes should minimally utilize the orthodox canonical class form. Of course, there are exceptions. For example, a class that will only serve as a protected or private base class need not have a virtual destructor because derived class instances cannot be upcast past a non-public inheritance boundary. Similarly, if we have a good reason to not want copies or to disallow an assignment, we can prohibit copies or assignments using the <code>= delete</code> specification in the extended signature of either of these methods. </p>
<p>Nonetheless, the canonical class form will add robustness to classes that embrace this idiom. The uniformity among classes utilizing this idiom with respect to their implementation<a id="_idIndexMarker1016"/> of initialization, assignment, and argument passing will be valued by programmers.</p>
<p>Let’s move forward to take a look at a complementary idea to the canonical class form, that of robustness.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor686"/>Ensuring a class is robust</h2>
<p>An important feature of C++ is the ability to build libraries of classes for widespread reuse. Whether we wish to achieve this goal, or simply wish to provide reliable code for our own organization’s use, our code must be robust. A <strong class="bold">robust class</strong> will be well-tested, should follow the canonical class<a id="_idIndexMarker1017"/> form (except for requiring a virtual destructor in protected and private base classes), and be portable (or included in a platform-specific library). Any class that is a candidate for reuse, or which is to be used in any professional capacity, must absolutely be robust.</p>
<p>A robust class must ensure that all instances of a given class are fully constructed. A <strong class="bold">fully constructed object</strong> is <a id="_idIndexMarker1018"/>one in which all data members are appropriately initialized. All constructors for a given class (including copy constructors) must be verified to initialize all data members. The values with which data members are loaded should be checked for range suitability. Remember, an uninitialized data member is a potential disaster! Precautions should be made in the event that a given constructor does not complete properly or if the initial values of data members are inappropriate. </p>
<p>Fully constructed objects may be validated using a variety of techniques. A rudimentary (and not advised) technique is to embed a status data member into each class (or derive or embed a status ancestor/member). Set the status member to <code>0</code> in the member initialization list and to <code>1</code> as the last line of the constructor. Probe this value after instantiation. The huge downfall of this approach is that users will certainly forget to probe the <em class="italic">fully constructed</em> success flag.</p>
<p>An alternative to the simple, aforementioned scheme is to utilize in-class initialization for all simple data types, resetting these members in the member initialization list of each alternate constructor to the desired values. After instantiation, the values may again be probed to determine whether an alternate constructor completed successfully. This is still far from an ideal implementation.</p>
<p>A much better technique is to utilize <a id="_idIndexMarker1019"/>exception handling. Embedding exception handling inside each constructor is ideal. If data members are not initialized within a suitable range, first try to re-enter their values, or open an alternate database for input, for example. As a last resort, you can throw an exception to report the <em class="italic">not fully constructed object</em>. We will more closely examine exception handling with respect to testing later in this chapter.</p>
<p>Meanwhile, let us move forward with a technique to rigorously test our classes and components<a id="_idTextAnchor687"/> – creating drivers to test classes.</p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor688"/>Creating drivers to test classes</h1>
<p>In <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, we briefly talked about breaking our code into source <a id="_idIndexMarker1020"/>and header files. Let us briefly recap. Typically, the<a id="_idIndexMarker1021"/> header file will be named after the class (such as <code>Student.h</code>) and will contain the class definition, plus any inline member function definitions. By placing inline functions in a header file, they will be properly re-expanded should their implementations change (as the header is subsequently included in each source file, creating a dependency with that header).</p>
<p>The implementation for the methods of each class will be placed in a corresponding source code file (such as <code>Student.cpp</code>), which will include the header on which it is based (that is, <code>#include "Student.h"</code>). Note that the double quotes imply that this header is in our current working directory; we could also specify a path as to where to find the header. By comparison, the angle brackets used with C++ libraries tell the preprocessor to look in predesignated directories by the compiler. Also, note that each derived class header file will include the header file for its base class (so that it may see member function prototypes).</p>
<p>Note that any static data member or method definitions will appear in their corresponding source code files (so that only one definition per application will exist). </p>
<p>With this header and source code file structure in mind, we can now create a driver to test each individual class or each grouping of closely related classes (such as those related through association or aggregation). Classes related through inheritance can be tested in their own, individual driver files. Each driver file can be named to reflect the class that is being tested, such as <code>StudentDriver.cpp</code>. The driver file will include the relevant header files for the class(es) being tested. Of course, the source files from the classes in question would be compiled and linked to the driver file as part of the compilation process. </p>
<p>The driver file can simply contain a <code>main()</code> function as a test bed to instantiate the class(es) in question and serve as a scope to test each member function. The driver will test default instantiation, typical instantiation, copy construction, assignment between objects, and each of the additional methods in the class(es). Should virtual destructors or other virtual functions exist, we should instantiate derived class instances (in the derived class’ driver), upcasting these instances to be stored using base class pointers, and then invoke the virtual functions to verify that the correct behaviors occur. In the case of a virtual destructor, we can trace which destructor is the entry point in the destruction sequence by deleting a dynamically allocated instance (or waiting for a stack instance to go out of scope) and single-stepping through our debugger to verify all is as expected.</p>
<p>We can also test that objects are fully constructed; we will see more on this topic shortly. </p>
<p>Assuming we <a id="_idIndexMarker1022"/>have our usual <code>Person</code> and <code>Student</code> class <a id="_idIndexMarker1023"/>hierarchy, here is a simple driver (the file containing <code>main()</code>) to test the <code>Student</code> class. This driver can be found in our GitHub repository. To make a complete program, you will also need to compile and link together the <code>Student.cpp</code> and <code>Person.cpp</code> files found in this same directory. Here is the GitHub repository URL for the driver: </p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp</a></p>
<pre class="source-code">
<strong class="bold">#include "Person.h"</strong>  // include releva<a id="_idTextAnchor689"/>nt class header files
<strong class="bold">#include "Student.h"</strong>
using std::cout;    // preferred to: using namespace std;
using std::endl;
constexpr int MAX = 3;
int main() // Driver to test Student class, stored in above
{          // filename for chapter example consistency 
    // Test all instantiation means, even copy constructor
    <strong class="bold">Student s0;</strong> <strong class="bold">// Default construction</strong>
    // alternate constructor
    <strong class="bold">Student s1("Jo", "Li", 'H', "Ms.", 3.7, "C++", </strong>
<strong class="bold">               "UD1234");</strong>
    <strong class="bold">Student s2("Sam", "Lo", 'A', "Mr.", 3.5, "C++",</strong>
<strong class="bold">               "UD2245");</strong>
    // These initializations implicitly invoke copy const.
    <strong class="bold">Student s3(s1);</strong>
    <strong class="bold">Student s4 = s2;</strong>   <strong class="bold">// This is also initialization</strong>
    // Test the assignment operator
    Student s5("Ren", "Ze", 'A', "Dr.", 3.8, "C++",
               "BU5563");
    Student s6;
    <strong class="bold">s6 = s5;</strong>  <strong class="bold">// this is an assignment, not initialization</strong>
    // Test each public method. A sample is shown here
    <strong class="bold">s1.Print();</strong>  <strong class="bold">// Be sure to test each method!</strong> 
            
    // Generalize derived instances as base types 
    // Do the polymorphic operations work as expected?
    Person *people[MAX] = { }; // initialized with nullptrs
    // base instance for comparison
    people[0] = new Person("Juliet", "Martinez", 'M',
                           "Ms.");
    // derived instances, generalized with base class ptrs.   
    <strong class="bold">people[1] = new Student("Zack", "Moon", 'R', "Dr.",</strong>
<strong class="bold">                            3.8, "C++", "UMD1234");</strong>  
    <strong class="bold">p<a id="_idTextAnchor690"/>eople[2] = new Student("Gabby", "Doone", 'A', "Dr.", <a id="_idTextAnchor691"/></strong>
<strong class="bold">                            3.9, "C++", "GWU4321");</strong>
    for (auto *item : people)  // loop through all elements
<a id="_idTextAnchor692"/>    {
       <strong class="bold">item-&gt;IsA();</strong>
       cout &lt;&lt; "  ";
       <strong class="bold">item-&gt;Print();</strong>
    }
    // Test destruction sequence (dynam. alloc. instances)
    for (auto *item : people)  // loop thru all elements
       <strong class="bold">delete item;</strong>   <strong class="bold">// engage virtual dest. sequence</strong>
    return 0;
}</pre>
<p>Briefly reviewing the <a id="_idIndexMarker1024"/>preceding program fragment, we can see<a id="_idIndexMarker1025"/> that we have tested each means for instantiation, including the copy constructor. We’ve also tested the assignment operator, verified each member function works (an example method is shown), and verified that the virtual functions (including the virtual destructor), work as intended.</p>
<p>Now that we have seen a basic driver test our classes, let’s consider some additional metrics we can use when testing classes related via<a id="_idTextAnchor693"/> inheritance, associatio<a id="_idTextAnchor694"/><a id="_idTextAnchor695"/><a id="_idTextAnchor696"/>n, or aggregation.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor697"/>Testing related classes</h1>
<p>With OO programs, it is <a id="_idIndexMarker1026"/>not sufficient to simply test an individual class for completeness and robustness, though these are good starting points. Completeness entails not only following the canonical class form but also ensuring that data members have a safe means for access using appropriate access methods (labeled as <code>const</code> when not modifying the instance). Completeness also verifies that the required interface as specified by the OO design has been implemented. </p>
<p>Robustness leads us to verify that all of the aforementioned methods had been tested within an appropriate driver, evaluated for platform independence, and verified that each means for instantiation leads to a fully constructed object. We can augment this type of testing with threshold testing of data members, for instance, noting when exceptions are thrown. Completeness and robustness, though seemingly comprehensive, are actually the<a id="_idIndexMarker1027"/> most straightforward means for OO component testing.</p>
<p>The more challenging means for testing is to test the interaction between related classes. </p>
<h2 id="_idParaDest-258">Testing classes related thro<a id="_idTextAnchor698"/><a id="_idTextAnchor699"/>ugh inheritance, association, or aggregation</h2>
<p>Classes related through various object relationships require various additional means for component testing. Objects with various relationships with one another can impact the state progression a given instance may have during its life expectancy within the application. This type of testing will require the most detailed effort. We will find that scenarios will be useful to help us capture the usual interactions between related objects, leading to more comprehensive ways to test classes that interact with one another.</p>
<p>Let’s begin by considering how<a id="_idTextAnchor700"/> we can test classes related to inheritance.</p>
<h3>Adding strategies to test inheritance</h3>
<p>Classes<a id="_idIndexMarker1028"/> related through public inheritance need to have virtual functions verified. For example, have all intended derived class methods been overridden? Remember, a derived class does not need to override all virtual functions specified in its base class if base class behaviors are still deemed appropriate at the derived class level. It will be necessary to compare the implementation to the design to ensure that we have overridden all required polymorphic operations with suitable methods. </p>
<p>Certainly, the binding of virtual functions is done at runtime (that is, dynamic binding). It will be important to create derived class instances and store them using base class pointers so that the polymorphic operations can be applied. We then need to verify that the derived class behavior shines through. If not, perhaps we may find ourselves in an unintended function hiding situation, or perhaps the base class operation wasn’t marked <code>virtual</code> as intended (keeping in mind that the keywords <code>virtual</code> and <code>override</code> at the derived class level, though nice and recommended, are optional and do not affect the dynamic behavior).</p>
<p>Though classes <a id="_idIndexMarker1029"/>related through inheritance have unique testing strategies, remember that instantiation will create a single object, that is, of a base class or of a derived class type. When we instantiate one such type, we have one such instance, not a pair of instances working together. A derived class merely has a base class subobject, which is part of itself. Let’s consider how this compares with associated objects or aggregates, which can be separate objects (association), potentially interacting with their companions.</p>
<h3>Adding strategies to test aggregation and association</h3>
<p>Classes<a id="_idIndexMarker1030"/> related through association or aggregation may be multiple instances <a id="_idIndexMarker1031"/>communicating with one another and causing state changes with one another. This is certainly more complex than the object relationship of inheritance. </p>
<p>Classes related via aggregation are generally easier to test than those related via association. Thinking of the most common form of aggregation (composition), the embedded (inner) object is part of the outer (whole) object. When the outer object is instantiated, we get the memory for the inner object embedded within the <em class="italic">whole</em>. The memory layout is not tremendously different (other than the potential ordering) when compared to the memory layout of a derived class instance, which contains a base class subobject. In each case, we are still dealing with a single instance (even though it has embedded <em class="italic">parts</em>). The point of comparison with testing, however, is that operations applied to the <em class="italic">whole</em> are often delegated to the <em class="italic">parts</em> or components. We will rigorously need to test the operations, on the whole, to ensure that they delegate necessary information to each of the parts. </p>
<p>Classes related via the lesser-used form of a general aggregation (where the whole contains pointers to the parts versus the typical embedded object implementation of composition) have similar issues to an association, as the implementation is similar. With that in mind, let’s take a look at testing issues relating to associated objects.</p>
<p>Classes related via an association are often independently existing objects, which at some point in the application have created a link to one another. There may or may not be a predetermined point in the application when the two objects create a link to one another. Operations applied to one object may cause a change in the associated object. For example, let us consider a <code>Student</code> and a <code>Course</code>. Both may exist independently, then at some point in the application, a <code>Student</code> may add a <code>Course</code> with <code>Student::AddCourse()</code>. By doing so, not only does a particular <code>Student</code> instance now contain a link to a specific <code>Course</code> instance, but the <code>Student::AddCourse()</code> operation has caused a change in the <code>Course</code> class. That particular <code>Student</code> instance is<a id="_idIndexMarker1032"/> now part of a particular <code>Course</code> instance’s roster. At any point, the <code>Course</code> may be canceled, rippling a change in all <code>Student</code> instances who are enrolled in that <code>Course</code>. These changes reflect states in which each associated object may exist. For <a id="_idIndexMarker1033"/>example, a <code>Student</code> may be in a state of <em class="italic">currently enrolled</em>, or <em class="italic">dropping</em> a <code>Course</code>. There are many possibilities. How do we test all of them?</p>
<h3>Adding scenarios to aid in testing object relationships</h3>
<p>The notion of a scenario comes up in object-oriented analysis as a means to both create OO designs and test them. A <strong class="bold">scenario</strong> is a<a id="_idIndexMarker1034"/> descriptive walkthrough of a likely series of events that will occur in an application. A scenario will feature classes and how they may interact with one another for a specific situation. Many related scenarios can be collected into the OO<a id="_idIndexMarker1035"/> concept of a <strong class="bold">use case</strong>. In the OO analysis and design phases, scenarios help determine which classes may exist in the application as well as operations and relationships each may have. In testing, scenarios can be reused to form the basis for driver creation to test various object relationships. With this in mind, a series of drivers can be developed to test numerous scenarios (that is, use cases). This type of modeling will more thoroughly be able to provide a test bed for related objects than the initial, simple means of testing for completeness and robustness.</p>
<p>Another area of concern between any type of related classes is that of version control. What happens, for example, if a base class definition or default behavior changes? How will that impact a derived class? How will that impact associated objects? With each change, we inevitably will need to revisit component testing for all related classes.</p>
<p>Next, let’s consider how exception handling mechanisms factor into OO component testing.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor701"/>Testing exception handling mechanisms</h1>
<p>Now that we can create <a id="_idIndexMarker1036"/>drivers to test each class (or a grouping of related classes), we will want to understand which methods in our code may throw exceptions. For these scenarios, we will want to add try blocks within the driver to ensure we know how to handle each potential exception thrown. Before doing so, we should ask ourselves, did we include adequate exception handling in our code during the development process? For example, considering instantiation, do our constructors check whether an object is fully constructed? Do they throw exceptions if not? If the answer is no, our classes may not be as robust as we had anticipated. </p>
<p>Let’s consider embedding exception handling into a constructor, and how we may construct a driver to test all potential means for instantiation.</p>
<h2 id="_idParaDest-260">Embedding except<a id="_idTextAnchor702"/>ion handling in constructors to create robust classes</h2>
<p>We may <a id="_idIndexMarker1037"/>recall from our recent <a href="B19087_11.xhtml#_idTextAnchor488"><em class="italic">Chapter 11</em></a>, <em class="italic">Handling Exceptions</em>, that we can create our own exception classes, derived from the C++ Standard Library <code>exception</code> class. Let’s assume that we have created such a class, namely <code>ConstructionException</code>. If at any point in a constructor we are not able to properly initialize a given instance to provide a fully constructed object, we can throw a <code>ConstructionException</code> from any constructor. The implication of potentially throwing a <code>ConstructionException</code> is that we now should enclose instantiation within try blocks and add matching catch blocks to anticipate a <code>ConstructionException</code> that may be thrown. Keep in mind, however, that instances declared within the scope of a try block have scope only within the <code>try</code>-<code>catch</code> pairing. </p>
<p>The good news is that if an object does not complete construction (that is, if an exception is thrown before the constructor completes), the object will technically not exist. If an object does not technically exist, there will be no necessary clean up of a partially instantiated object. We will, however, need to think about what this means to our application if an instance we anticipate does not fully construct. How will that alter the progression of our code? Part of testing is to ensure that we have considered all ways in which our code may be used and bulletproof our code accordingly!</p>
<p>It is important to note that the introduction of <code>try</code> and <code>catch</code> blocks may alter our program flow, and it is crucial to include this type of testing in our drivers. We may seek scenarios that account for the <code>try</code> and <code>catch</code> blocks as we conduct our testing. </p>
<p>We have now seen<a id="_idIndexMarker1038"/> how we can augment our test drivers to accommodate classes that may throw exceptions. We have also discussed in this chapter adding scenarios in our drivers to help track the states between objects with relationships and, of course, simp<a id="_idTextAnchor703"/>le class idioms we can follow to set us up for success. Let us now briefly recap these concepts before moving forward to our next chapter.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor704"/>Summary</h1>
<p>In this chapter, we have increased our ability to become better C++ programmers by examining various OO class and component testing practices and strategies. Our primary goal is to ensure that our code is robust, well-tested, and can be deployed error-free to our various organizations.</p>
<p>We have considered programming idioms, such as following the canonical class form to ensure that our classes are complete and have expected behavior for construction/destruction, assignment, and usage in argument passing and as return values from functions. We have talked about what it means to create a robust class – one that follows the canonical class form that is also well-tested, platform-independent, and tested for fully constructed objects. </p>
<p>We have also explored how to create drivers to test individual classes or sets of related classes. We have established a checklist of items to test individual classes within a driver. We have looked more thoroughly at object relationships to understand that objects that interact with one another require more sophisticated testing. That is, as objects move from state to state, they may be impacted by associated objects, which can further alter their course of progression. We’ve added utilizing scenarios as test cases for our drivers to better capture the dynamic states in which instances may move within an application.</p>
<p>Finally, we have taken a look at how exception handling mechanisms can impact how we test our code. We have augmented our drivers to account for the flow of control that try and catch blocks may redirect our applications from their anticipated, typical progression. </p>
<p>We are now ready to continue forward with the next part of our book, design patterns and idioms in C++. We will start with <a href="B19087_16.xhtml#_idTextAnchor711"><em class="italic">Chapter 16</em></a>, <em class="italic">Using the Observer Pattern</em>. In the remaining chapters, we will understand how to apply popular design patterns and employ them in our coding. These skills will m<a id="_idTextAnchor705"/>ake us better programmers. Let’s move forward!</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor706"/>Questions</h1>
<ol>
<li>Consider a pair of classes from one of your previous exercises containing an object relationship (hint – public in<a id="_idTextAnchor707"/>heritance will be easier to consider than association).<ol><li>Do your classes follow the canonical class form? Orthodox or extended? Why, or why not? If they do not and should, revise the classes to follow this idiom.</li><li><a id="_idTextAnchor708"/>Would you consider your classes robust? Why, or why not?</li></ol></li>
<li>Create a driver (or two) to test your pair of classes:<ol><li>Be sure to test for the usual checklist of items (construction, assignment, destruction, the public interface, upcasting (if applicable), and use of a virtual function). </li><li>(Optional) If you selected two classes related using association, create a separate driver to follow a typical sc<a id="_idTextAnchor709"/>enario detailing the interaction of the two classes.</li><li>Be sure to include testing of exception handling in one of your test drivers.</li></ol></li>
<li>Create a <code>ConstructionException</code> class (derived from the C++ Standard Library <code>exception</code>). Embed checks within your constructors in a sample class to throw a <code>ConstructionException</code> when necessary. Be sure to enclose all forms of instantiation of this class within the appropriate <code>try</code> and <code>catch</code> block pairings.</li>
</ol>
</div>
<div><div></div>
</div>
</div>

<div><div><h1 id="_idParaDest-263"><a id="_idTextAnchor710"/>Part 4: Design Patterns and Idioms in C++</h1>
<p>The goal of this part is to expand your C++ repertoire, beyond OOP and other necessary skills, to include knowledge of core design patterns. Design patterns provide well-proven techniques and strategies to solve recurring types of OO problems. This section introduces common design patterns and demonstrates in depth how to apply these patterns by building on previous examples within the book in creative ways. Each chapter contains detailed code examples to exemplify each pattern.</p>
<p>The initial chapter in this section introduces the idea of design patterns and discusses the advantages of utilizing such patterns within coding solutions. The initial chapter also introduces the Observer pattern and provides an in-depth program to appreciate the various components of this pattern.</p>
<p>The next chapter explains the Factory Method pattern and likewise provides detailed programs, showing how to implement the Factory Method pattern with and without an Object Factory. This chapter additionally compares an Object Factory to an Abstract Factory.</p>
<p>The following chapter introduces the Adapter pattern and provides implementation strategies and program examples using inheritance versus association to implement the Adapter class. Additionally, an adapter as a simple wrapper class is illustrated.</p>
<p>The Singleton pattern is examined in the following chapter. Following two simple examples, a paired-class implementation is demonstrated with a detailed example. Registries to accommodate Singletons are also introduced. </p>
<p>The final chapter in this section and book introduces the pImpl pattern to reduce compile-time dependencies within your code. A basic implementation is provided and then expanded upon using unique pointers. Performance issues are additionally explored relating to this pattern.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19087_16.xhtml#_idTextAnchor711"><em class="italic">Chapter 16</em></a>, <em class="italic">Using the Observer Pattern</em></li>
<li><a href="B19087_17.xhtml#_idTextAnchor743"><em class="italic">Chapter 17</em></a>, <em class="italic">Applying the Factory Pattern</em></li>
<li><a href="B19087_18.xhtml#_idTextAnchor783"><em class="italic">Chapter 18</em></a>, <em class="italic">Applying the Adapter Pattern</em></li>
<li><a href="B19087_19.xhtml#_idTextAnchor829"><em class="italic">Chapter 19</em></a>, <em class="italic">Using the Singleton Pattern</em></li>
<li><a href="B19087_20.xhtml#_idTextAnchor876"><em class="italic">Chapter 20</em></a>, <em class="italic">Removing Implementation Details Using the pImpl Pattern</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div></div>
<div><p class="hidden">Part 4: Design Patterns and Idioms in C++</p>
</div>
<div><div></div>
</div>
</div></body></html>