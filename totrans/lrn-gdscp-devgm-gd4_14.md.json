["```cpp\nextends Node\nvar _observers: Dictionary = {}\nfunc subscribe(event_name: String, callback: Callable):\n   if not event_name in _observers:\n      _observers[event_name] = []\n   _observers[event_name].append(callback)\nfunc publish(event_name: String):\n   if not event_name in _observers:\n      return\n   for callable: Callable in _observers[event_name]:\n      callable.call()\n```", "```cpp\nextends Node\nfunc _ready():\n   while randf() < 0.99:\n      print(\"You're still fighting the boss!\")\n   print(\"The boss dies x.x\")\n   killed_boss.\n\t\t\tNow, we can create a little achievement system and subscribe to this event, to be notified when the boss battle is over:\n\n```", "```cpp\n\n\t\t\tAdd this script as an autoload, named `AchievementSystem`, and then you can run the project. In the console, you’ll see that it works perfectly:\n\n```", "```cpp\n\n\t\t\tThe signals, which are default in Godot, and the Event Bus patterns are both close cousins of the Observer pattern. The big difference between signals and the Event Bus is that with signals, you can only subscribe to one specific entity, such as when we subscribe to one enemy’s `died` signal to signify that the enemy died, whereas an Event Bus is global. It doesn’t matter what node or object threw the event; everyone who is subscribed to the event will get notified, such as when any node (it doesn’t matter which) throws the `game_over` event to signify that the game ended. The Observer pattern and all its different forms are widely known.\n\t\t\tLearn more\n\t\t\tLearn more about the Observer pattern here: [https://gameprogrammingpatterns.com/observer.html](https://gameprogrammingpatterns.com/observer.html).\n\t\t\tThe Event Bus programming pattern is ideal for decoupling your code. Let’s now explore a pattern that has a completely different purpose, namely optimizing load times.\n\t\t\tUnderstanding Object Pooling\n\t\t\tThe second programming pattern we’ll see is Object Pooling. The purpose of this pattern is to keep up the frame rate of our game while still being able to create and destroy many objects or nodes. Let’s take a deeper dive into what we are trying to solve – that is, the problem.\n\t\t\tThe problem\n\t\t\tIn some games, we want to be able to spawn and remove objects really quickly. In the little game that we have constructed over the course of the book, for example, we want to be able to spawn and remove projectiles and arrows fast and reliably. With the rates our arrows are being shot at now, this is not a big issue, but it could become one if we increased this rate, especially in multiplayer. Creating new nodes – for example, by using the `instantiate()` function we saw in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632) and adding them to the scene tree – is pretty slow. The game needs to load the scene file from disk and then allocate new memory every time we create a new node. Then, when the node gets freed, the game has to free up that memory again.\n\t\t\tTo optimize this process, we can use an Object Pool, which we will discuss in the next section.\n\t\t\tThe solution\n\t\t\tTheses loading problems can be solved by the Object Pooling pattern. Object Pooling basically means that we keep a list, also called a pool, of already initialized nodes somewhere. For example, with a bunch of arrows, when we need an arrow, we can simple take one from this list. When it is not needed anymore, we return it to that list so that it can be reused later on.\n\t\t\t![Figure 14.2 – Any class that wants an instance can ask the Object Pool](img/B19358_14_02.jpg)\n\n\t\t\tFigure 14.2 – Any class that wants an instance can ask the Object Pool\n\t\t\tBecause we do not actually delete or remove the arrow node from the scene tree, we will need to make sure, through code, that the node stops working in the background when it is supposed to be stored away in the Object Pool. When an object is in use, we say it is alive because it lives within the game. When it is in the Object Pool, it is dead because it is not in use anymore. When we want to return a live object to the pool, we say that it gets killed.\n\t\t\t![Figure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool](img/B19358_14_03.jpg)\n\n\t\t\tFigure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool\n\t\t\tHere is an example of what an Object Pool’s script could look like:\n\n```", "```cpp\n\n\t\t\tYou can see that we keep an array, called `_pool`, which will contain all of our dead nodes. First, we create a number of objects within the `_init()` function of type `scene` and add these new objects as children to `root_node`, which we can pass to this `_init()` function. The number of objects we populate the pool with is defined by `pool_size`.\n\t\t\tIn the `_init()` function, we also connect to the `died` signal of each node using the `kill_node()` function. This means that the node, when it dies, needs to emit the `died` signal. The `kill_node()` function, in turn, will call the `set_dead()` function on that node. This function should disable the node and will be different for each kind of node, so we need to implement that later on in the definition of the node script itself. After this, the node is returned to the `_pool`.\n\t\t\tYou can also see that I called a function called `bind()` on the `kill_node` callable – `kill_node.bind(new_node)`. This binds arguments to `Callable`, which means that if the signal is emitted and this `Callable` gets called, the arguments we bind here are given to the `kill_node()` function. This way, we know what object is being killed in the `set_dead()` function.\n\t\t\tWhen we need an instance from the pool, we call the `get_dead_node()` function, which will first check whether there are still objects in the pool; if not, we return nothing. If there are still objects in the pool, we remove the first element from e `_pool`, set it as alive, and then return it.\n\t\t\tLastly, we implemented a `free_nodes()` function that frees all the nodes that are present in the pool. This way, we can free them all conveniently when we stop the game.\n\t\t\tImplementing the Object Pool in our game\n\t\t\tLet’s implement the Object Pool in our own game! The obvious nodes to pool from our Vampire Survivor like game are the projectile and the enemy. We’ll use a pool to deal with the projectiles here. You can always take a stab at making an Object Pool that deals with the enemies:\n\t\t\tCreate a script, `object_pool.gd`, that has the exact content of the script from the previous section. Save it under a new folder, `parts/object_pool`.\n\t\t\tLet’s prepare the `projectile.gd` script so that it can be in a pool:\n\n\t\t\t\t1.  At the top, add a new custom signal, `died`. This will be called when the projectile can go back into the pool.\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Then, add two functions, `set_alive()` and `set_dead()`, which we call from the Object Pool:\n\n    ```", "```cpp\n\n    The `set_alive` function turns on the `_physics_process` and the collision detection for the projectile, but only if this code is run from the server. Then it shows the projectile, no matter if we are running from the server or not so that everyone can see it. The `set_dead` function undoes all these changes to make sure the projectile is unusable while dead.\n\n\t\t\tImportant note\n\t\t\tWe use the `set_deferred()` function on the `_enemy_detection_area` to set `monitoring` to `true` or `false` because this change has to be incorporated by the physics engine and we need to wait until all physics calculations for that frame are executed. The `set_deferred()` function sets the value to our desired value at the end of the current frame.\n\n\t\t\t\t1.  Now, replace the original `_ready()` function with the one in the next code snipper which makes sure new instances don’t start acting when they are created and put into the scene tree:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Lastly, replace the mentions of `queue_free()` with `died.emit()` because the Object Pool will manage how the node gets created:\n\n    ```", "```cpp\n    var projectile_pool: ObjectPool\n    var projectile_scene: PackedScene = preload(\"res://parts/projectile/projectile.tscn\")\n    ```", "```cpp\n\n    \t\t\t\t3.  Now, we only want to initialize this variable when we run from the server. The server will manage all the projectiles. Add the following line to `_ready()`:\n\n    ```", "```cpp\n    func _exit_tree():\n       if projectile_pool:\n          projectile_pool.free_nodes()\n          projectile_pool.free()\n    ```", "```cpp\n\n\t\t\tImportant note\n\t\t\tNodes in the scene tree will be freed automatically when we close the game. But objects that are not inside of the tree, like our `projectile_pool` or nodes we take out of the scene tree, are not managed by the same process. So, we need to manage when to delete them ourselves.\n\n\t\t\t\t1.  Lastly, we’ll need to update the `player.gd` script to access the Object Pool for a projectile and set its target and position. Replace the original way we created a new projectile with this code:\n\n    ```", "```cpp\n\n\t\t\tThis is all we need to do to implement our Object Pool in our multiplayer game. When you look at the **Remote Tree** while running the game, you’ll see that 50 projectiles have been created at the start, ready to be launched by the players.\n\t\t\t![Figure 14.4 – 50 projectiles are created, ready to be used](img/B19358_14_04.jpg)\n\n\t\t\tFigure 14.4 – 50 projectiles are created, ready to be used\n\t\t\tThat’s it for the Object Pool pattern. It is very useful to keep frame rates in check when you need lots of objects to spawn and disappear often. Let’s look at yet another completely different pattern in the next section.\n\t\t\tWorking with State Machines\n\t\t\tGames are massive pieces of code that can get quite complex. To lower the complexity of code, we can try to separate different pieces so that they only perform one action very well. That is exactly what we are going to do with a State Machine. Let’s first start with a better problem statement.\n\t\t\tThe problem\n\t\t\tAgents, such as the player or enemies, often have to operate in very different scenarios. In a platformer game, such as **Super Mario Bros** for example, the character needs to be able to walk, run, jump, dive, wall slide, fly, and so on. This is a lot of different kinds of code. If we try to fit this into one big class for the player, we’ll end up with a jumble of code that is very hard to understand, debug, or extend.\n\t\t\tUltimately, we want our game’s code to be easily understood and maintained. That’s why we will learn about the State Machine in the next section.\n\t\t\tThe solution\n\t\t\tA great way to combat this complexity is by separating the behavior for each of these wanted behaviors (walking, jumping, etc.) into different files and classes. This is exactly what the State Machine pattern does. The State Machine swaps out part or the complete behavior of an object with a different behavior, depending on the state it is in.\n\t\t\tEach of the behaviors we identified earlier (walking, jumping, etc.) is defined as a totally independent state that alters the behavior of the agent and is saved in a separate file.\n\t\t\t![Figure 14.5 – An example of how states could connect with each other](img/B19358_14_05.jpg)\n\n\t\t\tFigure 14.5 – An example of how states could connect with each other\n\t\t\tThe State Machine can only have one active state at one time. This rule makes sure that we don’t mix up behaviors or code.\n\t\t\tEach of these states knows which other states it can transition to. This transition gets triggered from the code of that state by asking the State Machine directly to transition.\n\t\t\tNow that we have a surface-level idea of what a State Machine can do, let’s quickly list all the things it should do. The State Machine should do the following:\n\n\t\t\t\t*   Have a list of all possible states\n\t\t\t\t*   Designate one active state\n\t\t\t\t*   Be able to transition from one state to another\n\t\t\t\t*   Update the current active state and provide it with direct input\n\n\t\t\tWith that in mind, let’s take a look at the code for the actual State Machine itself:\n\n```", "```cpp\n\n\t\t\tYou can see that in the `_ready()` function, we scan all the children of the State Machine and add it to a dictionary of `states`. This dictionary will help us to quickly look up states when we need them in the `transition()` function. This also means that we will add each state as a child node to the State Machine itself, like so:\n\t\t\t![Figure 14.6 – The State Machine with each state as a child node](img/B19358_14_06.jpg)\n\n\t\t\tFigure 14.6 – The State Machine with each state as a child node\n\t\t\tAt the end of the `_ready()` function, we transition to `starting_state`, which is an export variable that we can use to set the initial state of the State Machine.\n\t\t\tIn the `transition()` function that is used to transition to a new state, we first check whether we have `current_state`; if we do, we’ll first have to call the `exit()` function on it to make sure it can clean itself up. After that, we use  `state_name`, which is provided as an argument to look up the next state, assign it as `current_state`, and call the `enter()` function on it.\n\t\t\tThe `_physics_process()` and `_input()` methods are used to directly feed into the `process()` and `input()` functions of `current_state`, if there is a current state.\n\t\t\tNow, let’s have a look at the `state` class itself:\n\n```", "```cpp\n\n\t\t\tThe state class is a simple skeleton with functions that we have to implement when we inherit from it. This means that if we have a jump state, for example, we’ll need to make sure that the `enter()`, `exit()`, `input()` and `process()` functions all work as they should during the jumping behavior of our character.\n\t\t\tIf we want to go from one state to another, we can simply use `_state_machine.transition()` from within the state and provide the name of the state we want to transition to.\n\t\t\tWe can now create specialized states and connect them through code, by calling the `transition()` function on the `_state_machine` object.\n\t\t\tAn example state\n\t\t\tLet’s take a quick look at an example state, `Walk`, for the player. This is the state when the player moves freely around:\n\n```", "```cpp\n\n\t\t\tYou can see we extend the `State` script from earlier. Then, we implement the `process()` function to do our movement calculations, which are specific to walking around, and the `input()` function to detect when we want to transition from this state to the `Jump` state.\n\t\t\tWe don’t need to override every function from the `State` script, just the ones that we need, which in this case are the `process()` and `input()` functions.\n\t\t\tState Machines, in one way or another, are used in almost every game you ever played. It is a very important concept to understand. They abstract complex behavior into separate classes that are easy to understand and maintain.\n\t\t\tLet’s conclude the chapter with some additional exercises.\n\t\t\tAdditional exercises – Sharpening the axe\n\n\t\t\t\t1.  The implementation of our Event Bus makes it possible to subscribe to an event, but not to unsubscribe when the receiver doesn’t want to be subscribed anymore. Implement an `unsubscribe()` function that unsubscribes a `Callable` from an event:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  The Object Pool we have implemented returns nothing when we try to call `get_dead_node()` while the pool is empty. A smarter way of dealing with this would be to create a new object, basically extending the Object Pool on the fly. Create a new function, `get_dead_node_or_create_new()`, in such a way that when the pool is empty, it creates a new object that is correctly connected and returned to the pool when it dies.\n\n\t\t\tSummary\n\t\t\tAfter learning how to program and make a game, we finally took a step back and learned about higher-level patterns that help us structure our project and code nicely. First, we learned about what programming patterns are in general. Then, we learned about the Event Bus, Object Pool, and State Machine patterns that can help us in different ways. These three are some of the widely used patterns in gaming and are applied outside of game development too.\n\t\t\tFrom here, you can start to investigate more niche programming patterns, such as the following:\n\n\t\t\t\t*   **Components, also known as** **Composition**: [https://gameprogrammingpatterns.com/component.html](https://gameprogrammingpatterns.com/component.html)\n\t\t\t\t*   **Commands**: [https://gameprogrammingpatterns.com/command.html](https://gameprogrammingpatterns.com/command.html)\n\t\t\t\t*   **Service** **Locators**: [https://gameprogrammingpatterns.com/service-locator.html](https://gameprogrammingpatterns.com/service-locator.html)\n\n\t\t\tIn the next chapter, we’ll look at the filesystem and learn how to save the state of our game so that our players can start a game from where they left off.\n\t\t\tQuiz time\n\n\t\t\t\t*   Programming patterns are standardized ways of solving problems in a program or game. What is the advantage of knowing them?\n\t\t\t\t*   Any piece of code can be considered as a pattern. But when we call something an anti-pattern, does this mean that it works in our favor?\n\t\t\t\t*   The Signals and Event Bus patterns are very similar because, in both, we subscribe to events, but what is their fundamental difference?\n\t\t\t\t*   Why would we use an Object Pool pattern in our game?\n\t\t\t\t*   What is the line of code with which we can transition from one state to another using the State Machine pattern?\n\n```"]