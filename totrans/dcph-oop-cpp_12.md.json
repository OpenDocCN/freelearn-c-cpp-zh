["```cpp\nclass Student;  // forward declaration of Student class\nclass Id  // Partial class – full class can be found online\n{\nprivate:\n    string idNumber;\n    Student *student = nullptr;  // in-class initialization\npublic:  // Assume constructors, destructor, etc. exist\n    void SetStudent(Student *);\n    // all member fns. of Student are friend fns to/of Id\n    friend class Student;\n};\n// Note: Person class is as often defined; see online code\nclass Student : public Person\n{\nprivate:\n    float gpa = 0.0;    // in-class initialization\n    string currentCourse;\n    static int numStudents;\n    Id *studentId = nullptr;\npublic:   // Assume constructors, destructor, etc. exist\n    // only the following mbr fn. of Id is a friend fn.\n    friend void Id::SetStudent(Student *); // to/of Student\n};\n```", "```cpp\nusing Item = int;  \nclass LinkList;  // forward declaration\nclass LinkListElement\n{\nprivate:\n   void *data = nullptr;   // in-class initialization\n   LinkListElement *next = nullptr;\n   // private access methods to be used in scope of friend \n   void *GetData() const { return data; } \n   LinkListElement *GetNext() const { return next; }\n   void SetNext(LinkListElement *e) { next = e; }\npublic:\n// All member functions of LinkList are friend \n   // functions of LinkListElement \n   friend class LinkList;   \n   LinkListElement() = default;\n   LinkListElement(Item *i): data(i), next(nullptr) { }\n   ~LinkListElement() { delete static_cast<Item *>(data); \n                        next = nullptr; }\n};\n// LinkList should only be extended as a protected/private\n// base class; it does not contain a virtual destructor. It\n// can be used as-is, or as implementation for another ADT.\nclass LinkList\n{\nprivate:\n   LinkListElement *head = nullptr, *tail = nullptr, \n                   *current = nullptr;  // in-class init.\npublic:\n   LinkList() = default;\n   LinkList(LinkListElement *e) \n       { head = tail = current = e; }\n   void InsertAtFront(Item *);\n   LinkListElement *RemoveAtFront();  \n   void DeleteAtFront()  { delete RemoveAtFront(); }\n   bool IsEmpty() const { return head == nullptr; } \n   void Print() const;    // see online definition\n   ~LinkList() { while (!IsEmpty()) DeleteAtFront(); }\n};\n```", "```cpp\nvoid LinkList::InsertAtFront(Item *theItem)\n{\n   LinkListElement *newHead = new LinkListElement(theItem);\n   // Note: temp can access private SetNext() as if it were\n   // in its own scope – it is in the scope of a friend fn.\n   newHead->SetNext(head);// same as: newHead->next = head;\n   head = newHead;\n}\nLinkListElement *LinkList::RemoveAtFront()\n{\n   LinkListElement *remove = head;\n   head = head->GetNext();  // head = head->next;\n   current = head;    // reset current for usage elsewhere\n   return remove;\n}\n```", "```cpp\nStudent &operator+(float gpa, const Student &s);\n```", "```cpp\n// Assume usual header files and std namespace inclusions\nclass Person\n{\nprivate: \n    string firstName, lastname;\n    char middleInitial = '\\0';\n    char *title = nullptr; // use ptr member to demonstrate\n                           // deep assignment\nprotected:\n    void ModifyTitle(const string &); // converts to char *\npublic:                               \n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const char *);  \n    Person(const Person &);  // copy constructor\n    virtual ~Person();  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; }  \n    const string &GetLastName() const { return lastName; }    \n    const char *GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n    virtual void Print() const;\n    virtual void IsA() const;\n    // overloaded operator functions\n    Person &operator=(const Person &); // overloaded assign\n    bool operator==(const Person &);   // overloaded\n                                       // comparison\n    Person &operator+(const string &); // overloaded plus\n    // non-mbr friend fn. for op+ (to make associative)\n    friend Person &operator+(const string &, Person &);  \n};\n```", "```cpp\n// Assume the required constructors, destructor and basic\n// member functions prototyped in the class def. exist.\n// overloaded assignment operator\nPerson &Person::operator=(const Person &p)\n{\n    if (this != &p)  // make sure we're not assigning an \n    {                // object to itself\n        // delete any previously dynamically allocated data \n        // from the destination object\n        delete title;\n        // Also, remember to reallocate memory for any \n        // data members that are pointers\n        // Then, copy from source to destination object \n        // for each data member\n        firstName = p.firstName;\n        lastName = p.lastName;\n        middleInitial = p.middleInitial;\n        // Note: a pointer is used for title to demo the\n        // necessary steps to implement a deep assignment -\n        // otherwise, we would implement title with string\n        title = new char[strlen(p.title) + 1]; // mem alloc\n        strcpy(title, p.title);\n    }\n    return *this;  // allow for cascaded assignments\n}\n```", "```cpp\n    // disallow assignment\n    Person &operator=(const Person &) = delete;\n```", "```cpp\n// overloaded comparison operator\nbool Person::operator==(const Person &p)\n{   \n    // if the objects are the same object, or if the\n    // contents are equal, return true. Otherwise, false.\n    if (this == &p) \n        return true;\n    else if ( (!firstName.compare(p.firstName)) &&\n              (!lastName.compare(p.lastName)) &&\n              (!strcmp(title, p.title)) &&\n              (middleInitial == p.middleInitial) )\n        return true;\n    else\n        return false;\n}\n```", "```cpp\n// overloaded operator + (member function)\nPerson &Person::operator+(const string &t)\n{\n    ModifyTitle(t);\n    return *this;\n}\n```", "```cpp\n// overloaded + operator (not a mbr function) \nPerson &operator+(const string &t, Person &p)\n{\n    p.ModifyTitle(t);\n    return p;\n}\n```", "```cpp\nint main()\n{\n    Person p1;      // default constructed Person\n    Person p2(\"Gabby\", \"Doone\", 'A', \"Miss\");\n    Person p3(\"Renee\", \"Alexander\", 'Z', \"Dr.\");\n    p1.Print();\n    p2.Print();\n    p3.Print();  \n    p1 = p2;       // invoke overloaded assignment operator\n    p1.Print();\n    p2 = \"Ms.\" + p2;  // invoke overloaded + operator\n    p2.Print();       // then invoke overloaded = operator\n    p1 = p2 = p3;     // overloaded = can handle cascaded =\n    p2.Print();     \n    p1.Print();\n    if (p2 == p2)   // overloaded comparison operator\n       cout << \"Same people\" << endl;\n    if (p1 == p3)\n       cout << \"Same people\" << endl;\n   return 0;\n}\n```", "```cpp\nNo first name No last name\nMiss Gabby A. Doone\nDr. Renee Z. Alexander\nMiss Gabby A. Doone\nMs. Gabby A. Doone\nDr. Renee Z. Alexander\nDr. Renee Z. Alexander\nSame people\nSame people\n```", "```cpp\n    class ArrayInt // starting point for the class def.\n    {          // be sure to add: using std::to_string;\n    private:   // and also: using std::out_of_range;\n        int numElements = 0;     // in-class init.\n        int *contents = nullptr; // dynam. alloc. array\n    public:\n        ArrayInt(int size); // set numElements and\n                            // allocate contents\n        // returns a referenceable memory location or\n        // throws an exception\n        int &operator[](int index) \n        {             \n            if (index < numElements) \n                return contents[index];\n            else    // index is out of bounds\n                throw std::out_of_range(\n                                  std::to_string(index));\n        }                        \n    };\n    int main()\n    {\n        ArrayInt a1(5); // Create ArrayInt of 5 elements\n        try\n        {\n            a1[4] = 7;      // a1.operator[](4) = 7;\n        }\n        catch (const std::out_of_range &e)\n        {\n            cout << \"Out of range: \" << e.what() << endl;\n        }\n    }\n    ```"]