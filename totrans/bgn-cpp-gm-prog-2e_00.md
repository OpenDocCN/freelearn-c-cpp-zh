# 贡献者

# 关于作者

**约翰·霍顿**是一位基于英国的编程和游戏爱好者。他对编写应用程序、游戏、书籍和博客文章充满热情。他是 Game Code School 的创始人。

# 关于审稿人

**安德烈亚斯·奥赫尔克**是一位专业的全栈软件开发工程师。他拥有计算机科学学士学位，喜欢尝试软件和硬件。他的标志一直是他对电子和计算机的热情和亲和力。他的爱好包括游戏开发、构建嵌入式系统、运动和制作音乐。他目前在一家德国金融机构全职担任高级软件工程师。此外，他还曾在加利福尼亚州旧金山担任顾问和游戏开发者。他还是《学习 LibGDX 游戏开发》一书的作者。

# Packt 正在寻找像你这样的作者

如果你有兴趣成为 Packt 的作者，请访问 [authors.packtpub.com](http://authors.packtpub.com) 并今天申请。我们已与成千上万的开发者和技术专业人士合作，就像你一样，帮助他们将见解分享给全球技术社区。你可以提交一般申请，申请我们正在招募作者的特定热门话题，或者提交你自己的想法。

# 目录

## 前言

## *第一章*：C++、SFML、Visual Studio 和开始第一个游戏

### 2 我们将构建的游戏

### 2 森林！！！

### 3 乒乓球

### 3 丧尸竞技场

### 4 托马斯迟到了

### 4 外星人入侵++

### 5 遇见 C++

### 6 微软 Visual Studio

### 6 SFML

### 7 设置开发环境

### 7 关于 Mac 和 Linux 怎么办？

### 8 安装 Visual Studio 2019 社区版

### 10 设置 SFML

### 12 创建新项目

### 16 配置项目属性

### 18 规划森林！！！

### 22 项目资源

### 22 外包资源

### 22 制作自己的音效

### 23 将资源添加到项目中

### 23 探索资源

### 24 理解屏幕和内部坐标

### 27 开始编写游戏代码

### 28 使用注释使代码更清晰

### 28 主函数

### 29 展示和语法

### 30 从函数返回值

### 31 运行游戏

### 31 使用 SFML 打开窗口

### 32 #包括 SFML 功能

### 33 面向对象编程、类和对象

### 35 使用命名空间 sf

### 35 SFML VideoMode 和 RenderWindow

### 36 运行游戏

### 36 主游戏循环

### 38 当循环

### 39 C 风格代码注释

### 39 输入、更新、绘制、重复

### 40 检测按键

### 40 清除和绘制场景

### 41 运行游戏

### 41 绘制游戏背景

### 41 使用纹理准备精灵

### 44 背景精灵的双缓冲

### 45 运行游戏

### 45 处理错误

### 46 配置错误

### 46 编译错误

### 46 链接错误

### 47 故障

### 47 摘要

### 47 常见问题解答

## *第二章：变量、运算符和决策 – 精灵动画*

### 50 C++ 变量

### 50 变量的类型

### 51 声明和初始化变量

### 55 操作变量

### 55 C++ 算术和赋值运算符

### 使用表达式完成任务

### 添加云彩、一棵树和一只嗡嗡叫的蜜蜂

### 准备树

### 准备蜜蜂

### 准备云彩

### 绘制树、蜜蜂和云彩

### 随机数

### 在 C++ 中生成随机数

### 使用 if 和 else 做决策

### 逻辑运算符

### C++ 中的 if 和 else

### 如果他们从桥上过来，就射击他们！

### 射击他们……或者做这个代替

### 读者挑战

### 计时

### 帧率问题

### SFML 帧率解决方案

### 移动云彩和蜜蜂

### 赋予蜜蜂生命

### 吹动云彩

### 总结

### 常见问题解答

## *第三章*: C++ 字符串和 SFML 时间 – 玩家输入和用户界面

### 暂停和重新开始游戏

### C++ 字符串

### 声明字符串

### 将值赋给字符串

### 操作字符串

### SFML 的文本和字体类

### 实现用户界面

### 添加时间条

### 总结

### 常见问题解答

## *第四章*: 循环、数组、开关、枚举和函数 – 实现游戏机制

### 循环

### while 循环

### for 循环

### 数组

### 声明数组

### 初始化数组元素

### 这些数组对我们游戏真正做了什么？

### 使用 switch 进行决策

### 类枚举

### 函数入门

### 函数返回类型

### 函数名称

### 函数参数

### 函数体

### 函数原型

### 组织函数

### 函数陷阱！

### 更多关于函数的内容

### 关于函数的绝对最终话 - 至今

### 生长树枝

### 准备树枝

### 每帧更新分支精灵

### 绘制树枝

### 移动树枝

### 总结

### 常见问题解答

## *第五章*：碰撞、声音和结束条件 – 使游戏可玩

### 准备玩家（和其他精灵）

### 绘制玩家和其他精灵

### 处理玩家的输入

### 处理设置新游戏

### 检测玩家切割

### 检测按键释放

### 动画切割的木材和斧头

### 处理死亡

### 简单的声音效果

### SFML 声音如何工作

### 何时播放声音

### 添加声音代码

### 改进游戏和代码

### 总结

### 常见问题解答

## *第六章*: 面向对象编程 - 开始 Pong 游戏

### 面向对象编程

### 封装

### 多态

### 继承

### 为什么使用面向对象编程？

### 究竟什么是类？

### Pong 球拍的理论

### 类变量和函数声明

### 类函数定义

### 使用类的实例

### 创建 Pong 项目

### 编写 Bat 类

### 编写 Bat.h

### 构造函数

### 继续解释 Bat.h

### 编写 Bat.cpp

### 使用 Bat 类和编写主函数

### 总结

### 常见问题解答

## *第七章*: 动态碰撞检测和物理 - 完成 Pong 游戏

### 编写 Ball 类

### 使用 Ball 类

### 碰撞检测和计分

### 运行游戏

### 总结

### 常见问题解答

## *第八章*: SFML 视图 - 开始 Zombie Shooter 游戏

### 规划和启动 Zombie Arena 游戏

### 创建新项目

### 项目资源

### 探索资源

### 将资源添加到项目中

### 面向对象编程和 Zombie Arena 项目

### 创建玩家 - 第一个类

### 编写 Player 类头文件

### 229 编写玩家类函数定义

### 239 使用 SFML View 控制游戏摄像机

### 242 启动僵尸竞技场游戏引擎

### 247 管理代码文件

### 249 开始编写主游戏循环代码

### 260 摘要

### 260 常见问题解答

## *第九章*: C++ 引用、精灵图集和顶点数组

### 262 C++ 引用

### 265 引用摘要

### 266 SFML 顶点数组和精灵图集

### 266 什么是精灵图集？

### 267 什么是顶点数组？

### 268 从瓦片构建背景

### 269 构建顶点数组

### 271 使用顶点数组进行绘制

### 271 创建随机生成的滚动背景

### 279 使用背景

### 282 摘要

### 283 常见问题解答

## *第十章*: 指针、标准模板库和纹理管理

### 286 了解指针

### 287 指针语法

### 288 声明指针

### 289 初始化指针

### 290 重新初始化指针

### 291 解引用指针

### 293 指针是多才多艺且强大的

### 297 指针和数组

### 298 指针摘要

### 298 标准模板库

### 299 什么是映射？

### 300 声明映射

### 300 向映射中添加数据

### 301 在映射中查找数据

### 301 从映射中删除数据

### 301 检查映射的大小

### 在映射中检查键

### 遍历映射的键值对

### auto 关键字

### STL 总结

### TextureHolder 类

### 编写 TextureHolder 头文件

### 编写 TextureHolder 函数定义

### TextureHolder 我们取得了什么成果？

### 构建一群僵尸

### 编写 Zombie.h 文件

### 编写 Zombie.cpp 文件

### 使用僵尸类创建一群僵尸

### 让一群僵尸复活（复活）

### 使用 TextureHolder 类处理所有纹理

### 更改背景获取纹理的方式

### 更改玩家获取纹理的方式

### 总结

### 常见问题解答

## *第十一章*：碰撞检测、拾取和子弹

### 编写 Bullet 类

### 编写 Bullet 头文件

### 编写 Bullet 源文件

### 让子弹飞

### 包含 Bullet 类

### 控制变量和子弹数组

### 重新装填枪

### 射击子弹

### 每帧更新子弹

### 每帧绘制子弹

### 给玩家添加准星

### 编写拾取类

### 编写拾取类头文件

### 编写拾取类函数定义

### 使用拾取类

### 检测碰撞

### 371 有僵尸被射击吗？

### 375 玩家是否被僵尸触碰？

### 376 玩家是否触碰到拾取物？

### 377 摘要

### 377 常见问题解答

## *第十二章*：分层视图和实现 HUD

### 379 添加所有文本和 HUD 对象

### 384 更新 HUD

### 387 绘制 HUD、主页和升级屏幕

### 390 摘要

### 391 常见问题解答

## *第十三章*：音效、文件 I/O 和完成游戏

### 394 保存和加载高分

### 396 准备音效

### 398 升级

### 401 重新开始游戏

### 402 播放剩余的声音

### 402 玩家装弹时添加音效

### 403 制作射击声音

### 404 玩家被击中时播放声音

### 405 拾取物品时播放声音

### 406 射击僵尸时制作噗嗤声

### 408 摘要

### 408 常见问题解答

## *第十四章*：抽象和代码管理 – 更好地使用面向对象编程

### 410 托马斯迟到了游戏

### 410 托马斯迟到了的功能

### 414 创建项目

### 416 项目的资源

### 419 结构化托马斯迟到了代码

### 421 构建游戏引擎

### 422 重复使用 TextureHolder 类

### 425 编写 Engine.h

### 429 编写 Engine.cpp

### 438 到目前为止的引擎类

### 439 编写主函数

### 441 摘要

### 441 常见问题解答

## *第十五章*: 高级面向对象编程 – 继承和多态

### 444 继承

### 444 扩展类

### 447 多态

### 448 抽象类 – 虚函数和纯虚函数

### 450 构建 PlayableCharacter 类

### 451 编码 PlayableCharacter.h

### 456 编码 PlayableCharacter.cpp

### 462 构建 Thomas 和 Bob 类

### 462 编码 Thomas.h

### 463 编码 Thomas.cpp

### 466 编码 Bob.h

### 466 编码 Bob.cpp

### 469 更新游戏引擎以使用 Thomas 和 Bob

### 469 更新 Engine.h 以添加 Bob 和 Thomas 的实例

### 470 更新输入函数以控制 Thomas 和 Bob

### 471 更新 update 函数以生成和更新 PlayableCharacter 实例

### 476 绘制 Bob 和 Thomas

### 480 总结

### 481 常见问题解答

## *第十六章*: 构建可玩关卡和碰撞检测

### 484 设计一些关卡

### 489 构建 LevelManager 类

### 489 编码 LevelManager.h

### 492 编码 LevelManager.cpp 文件

### 499 编码 loadLevel 函数

### 504 更新引擎

### 508 碰撞检测

### 508 编码 detectCollisions 函数

### 515 更多碰撞检测

### 517 总结

## *第十七章*: 声音空间化和 HUD

### 520 什么是空间化？

### 520 发射器、衰减和监听器

### 521 使用 SFML 处理空间化

### 523 构建 SoundManager 类

### 524 编写 SoundManager.h

### 525 编写 SoundManager.cpp 文件

### 531 将 SoundManager 添加到游戏引擎

### 532 填充声音发射器

### 532 编写 populateEmitters 函数

### 535 播放声音

### 539 实现 HUD 类

### 539 编写 HUD.h

### 540 编写 HUD.cpp 文件

### 543 使用 HUD 类

### 547 总结

## *第十八章*: 粒子系统与着色器

### 549 构建粒子系统

### 550 编写 Particle 类

### 553 编写 ParticleSystem 类

### 553 探索 SFML 的 Drawable 类和面向对象编程

### 556 Drawable 继承的替代方案

### 563 使用 ParticleSystem 对象

### 571 OpenGL、着色器与 GLSL

### 572 可编程管线与着色器

### 573 编写片段着色器

### 574 编写顶点着色器

### 575 向引擎类添加着色器

### 576 加载着色器

### 577 更新和绘制着色器

### 581 总结

## *第十九章*: 游戏编程设计模式 – 开始 Space Invaders ++游戏

### 584 Space Invaders ++

### 587 为什么是 Space Invaders ++？

### 588 设计模式

### 588 屏幕、输入处理器、UI 面板和按钮

### 591 实体-组件模式

### 593 优先使用组合而非继承

### 595 工厂模式

### 597 C++ 智能指针

### 598 共享指针

### 599 唯一指针

### 600 智能指针的转换

### 602 C++ 断言

### 603 创建 Space Invaders ++ 项目

### 603 使用过滤器组织代码文件

### 605 添加 DevelopState 文件

### 605 编写 SpaceInvaders ++.cpp

### 606 编写 GameEngine 类

### 609 编写 SoundEngine 类

### 612 编写 ScreenManager 类

### 616 编写 BitmapStore 类

### 619 编写 ScreenManagerRemoteControl 类

### 620 我们现在在哪里？

### 620 编写 Screen 类及其依赖项

### 620 编写 Button 类

### 622 编写 UIPanel 类

### 627 编写 InputHandler 类

### 633 编写 Screen 类

### 637 添加 WorldState.h 文件

### 638 编写选择屏幕的派生类

### 638 编写 SelectScreen 类

### 641 编写 SelectInputHandler 类

### 643 编写 SelectUIPanel 类

### 646 编写游戏屏幕的派生类

### 646 编写 GameScreen 类

### 650 编写 GameInputHandler 类

### 652 编写 GameUIPanel 类

### 654 编写 GameOverInputHandler 类

### 656 编写 GameOverUIPanel 类

### 658 运行游戏

### 660 总结

## *第二十章*：游戏对象和组件

### 662 准备编写组件

### 662 编写组件基类

### 664 编写碰撞组件

### 664 编写 ColliderComponent 类

### 666 编写 RectColliderComponent 类

### 669 编写图形组件

### 669 编写 GraphicsComponent 类

### 671 编写 StandardGraphicsComponent 类

### 674 编写 TransformComponent 类

### 677 编写更新组件

### 677 编写 UpdateComponent 类

### 679 编写 BulletUpdateComponent 类

### 684 编写 InvaderUpdateComponent 类

### 693 编写 PlayerUpdateComponent 类

### 699 编写 GameObject 类

### 707 解释 GameObject 类

### 716 摘要

## *第二十一章*：文件 I/O 和游戏对象工厂

### 718 文件 I/O 和工厂类的结构

### 720 描述世界中的对象

### 723 编写 GameObjectBlueprint 类

### 727 编写 ObjectTags 类

### 729 编写 BlueprintObjectParser 类

### 734 编写 PlayModeObjectLoader 类

### 736 编写 GameObjectFactoryPlayMode 类

### 741 编写 GameObjectSharer 类

### 742 编写 LevelManager 类

### 747 更新 ScreenManager 和 ScreenManagerRemote Control 类

### 749 我们现在在哪里？

### 750 摘要

## *第二十二章*：使用游戏对象和构建游戏

### 752 生成子弹

### 752 编写 BulletSpawner 类

### 753 更新 GameScreen.h

### 756 处理玩家的输入

### 760 使用游戏手柄

### 763 编写 PhysicsEnginePlayMode 类

### 774 制作游戏

### 781 理解执行流程和调试

### 重新使用代码制作不同游戏和构建设计模式

### 786 摘要

## *第二十三章*：在出发之前……

### 谢谢！

## 你可能喜欢的其他书籍
