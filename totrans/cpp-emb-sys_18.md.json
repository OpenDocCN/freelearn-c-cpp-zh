["```cpp\nbool data_read_ready = false;\nbool data_send_timeout = false;\nint main() {\n    // initialize hardware\nwhile(1) {\n        if(data_read_ready) {\n            sensor_data_read_and_buffer();\n            data_read_ready = false;\n        }\n        if(data_send_timeout) {\n            data_send_from_buffer();\n            data_send_timeout = false;\n        }\n        if(!data_read_ready && !data_send_timeout) {\n            enter_sleep();\n        }\n    }\n} \n```", "```cpp\ntemplate<typename CallableHolder>\nclass task {\npublic:\n    constexpr static std::uint8_t c_prio_default = 250;\n    constexpr static std::uint8_t c_prio_max = 255;\n    constexpr static std::uint8_t c_prio_min = 0;\n    task(CallableHolder the_task, std::uint8_t prio = c_prio_default) :\n        the_task_(the_task), priority_(prio) {}\n    void execute() {\n        if(the_task_) {\n            the_task_();\n        }\n    }\n    bool operator<(const task &rhs) const\n    {\n        return priority_ < rhs.priority_;\n    }\nprivate:\n    CallableHolder the_task_;\n    std::uint8_t priority_ = c_prio_default;\n}; \n```", "```cpp\n using callable_holder = std::function<void()>;\n    auto fun_a = []() {\n        printf(\"High priority task!\\r\\n\");\n    };\n    task<callable_holder> task_a(fun_a, 255);\n    auto fun_b = []() {\n        printf(\"Low priority task!\\r\\n\");\n    };\n    task<callable_holder> task_b(fun_b, 20);\n    if(task_a < task_b) {\n        task_b.execute();\n    }\n    else {\n        task_a.execute();\n    } \n```", "```cpp\nHigh priority task! \n```", "```cpp\n using callable_etl = etl::delegate<void()>;\n    using task_etl = task<callable_etl>;\n    class test {\n    public:\n        test(int x) : x_(x) {}\n        void print() const {\n            printf(\"This is a test, x = %d.\\r\\n\", x_);\n        }\n        void static print_static() {\n            printf(\"This is a static method in test.\\r\\n\");\n        }\n    private:\n        int x_ = 0;\n    };\n    test test_1(42);\n    task_etl task_member_fun(callable_etl::create<test, &test::print>\n(test_1));\n    task_member_fun.execute();\n    task_etl task_static_fun(callable_etl::create<test::print_static>());\n    task_static_fun.execute();\n    task_etl task_lambda([](){\n        printf(\"This is non capturing lambda!\\r\\n\");\n    });\n    task_lambda.execute(); \n```", "```cpp\nThis is a test, x = 42.\nThis is a static method in test.\nThis is non capturing lambda! \n```", "```cpp\ncmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel\ncmake --build build --target run_in_renode \n```", "```cpp\n std::priority_queue<int, etl::vector<int, 6>> pq{};\n    pq.push(12);\n    pq.push(6);\n    pq.push(16);\n    pq.push(8);\n    pq.push(1);\n    pq.push(10);\n    printf(\"priority queue elements:\\r\\n\");\n    while(!pq.empty()) {\n        printf(\"top element: %d, size: %d\\r\\n\", pq.top(), pq.size());\n        pq.pop();\n    } \n```", "```cpp\npriority queue elements:\ntop element: 16, size: 6\ntop element: 12, size: 5\ntop element: 10, size: 4\ntop element: 8, size: 3\ntop element: 6, size: 2\ntop element: 1, size: 1 \n```", "```cpp\ncmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel\n-DMAIN_CPP_FILE_NAME=main_pq.cpp\ncmake --build build --target run_in_renode \n```", "```cpp\ntemplate<typename Task, std::size_t Size>\nstruct sequencer {\n    sequencer() = delete;\n    static void add(Task task) {\n        if(pq.size() < Size) {\n            __disable_irq();\n            pq.push(task);\n            __enable_irq();\n        }\n    }\n    static void run() {\n        if(!pq.empty()) {\n            __disable_irq();\n            auto task = pq.top();\n            pq.pop();\n            __enable_irq();\n            task.execute();\n        }\n    }\nprivate:\n    static inline std::priority_queue<Task, etl::vector<Task, Size>> pq{};\n}; \n```", "```cpp\n using callable_etl = etl::delegate<void()>;\n    using task_etl = task<callable_etl>;\n    class test {\n    public:\n        test(int x) : x_(x) {}\n        void print() const {\n            printf(\"This is a test, x = %d.\\r\\n\", x_);\n        }\n        void static print_static() {\n            printf(\"This is a static method in test.\\r\\n\");\n        }\n    private:\n        int x_ = 0;\n    };\n    test test_1(42);\n    task_etl task_member_fun(callable_etl::create<test, &test::print>\n(test_1), 20);\n    task_etl task_static_fun(callable_etl::create<test::print_static>(), 30);\n    task_etl task_lambda([](){\n        printf(\"This is non capturing lambda!\\r\\n\");\n    }, 10);\n    using seq = sequencer<task_etl, 16>;\n    seq::add(task_member_fun);\n    seq::add(task_static_fun);\n    seq::add(task_lambda);\n    while(true)\n    {\n        seq::run();\n    } \n```", "```cpp\nThis is a static method in test.\nThis is a test, x = 42.\nThis is non capturing lambda! \n```", "```cpp\ncmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel\n-DMAIN_CPP_FILE_NAME=main_seq.cpp\ncmake --build build --target run_in_renode \n```"]