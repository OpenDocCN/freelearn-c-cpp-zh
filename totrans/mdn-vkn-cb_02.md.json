["```cpp\nVkPhysicalDevice physicalDevice;  // Valid Physical Device\nVkDevice device; // Valid Device\nVkInstance instance; // Valid Instance\nconst uint32_t apiVersion = VK_API_VERSION_1_3;\nconst VmaVulkanFunctions vulkanFunctions = {\n    .vkGetInstanceProcAddr = vkGetInstanceProcAddr,\n    .vkGetDeviceProcAddr = vkGetDeviceProcAddr,\n#if VMA_VULKAN_VERSION >= 1003000\n    .vkGetDeviceBufferMemoryRequirements =\n        vkGetDeviceBufferMemoryRequirements,\n    .vkGetDeviceImageMemoryRequirements =\n        vkGetDeviceImageMemoryRequirements,\n#endif\n};\nVmaAllocator allocator = nullptr;\nconst VmaAllocatorCreateInfo allocInfo = {\n    .physicalDevice = physicalDevice,\n    .device = device,\n    .pVulkanFunctions = &vulkanFunctions,\n    .instance = instance,\n    .vulkanApiVersion = apiVersion,\n};\nvmaCreateAllocator(&allocInfo, &allocator);\n```", "```cpp\n    VkDeviceSize size;  // The requested size of the buffer\n    VmaAllocator allocator;  // valid VMA Allocator\n    VkUsageBufferFlags use;  // Transfer src/dst/uniform/SSBO\n    VkBuffer buffer;        // The created buffer\n    VkBufferCreateInfo createInfo = {\n        .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n        .pNext = nullptr,\n        .flags = {},\n        .size = size,\n        .usage = use,\n        .sharingMode = VK_SHARING_MODE_EXCLUSIVE,\n        .queueFamilyIndexCount = {},\n        .pQueueFamilyIndices = {},\n    };\n    ```", "```cpp\n    const VmaAllocationCreateFlagBits allocCreateInfo = {\n        VMA_ALLOCATION_CREATE_MAPPED_BIT,\n        VMA_MEMORY_USAGE_CPU_ONLY,\n    };\n    ```", "```cpp\n    VmaAllocation allocation;  // Needs to live until the\n                               // buffer is destroyed\n    VK_CHECK(vmaCreateBuffer(allocator, &createInfo,\n                             &allocCreateInfo, &buffer,\n                             &allocation, nullptr));\n    ```", "```cpp\n    VmaAllocationInfo allocationInfo;\n    vmaGetAllocationInfo(allocator, allocation,\n                         &allocationInfo);\n    ```", "```cpp\n    VmaAllocator allocator;   // Valid VMA allocator\n    VmaAllocation allocation; // Valid VMA allocation\n    void *data;               // Data to be uploaded\n    size_t size;              // Size of data in bytes\n    void *map = nullptr;\n    VK_CHECK(vmaMapMemory(allocator, allocation,\n                          &map));\n    memcpy(map, data, size);\n    vmaUnmapMemory(allocator_, allocation_);\n    VK_CHECK(vmaFlushAllocation(allocator_,\n                                allocation_, offset,\n                                size));\n    ```", "```cpp\n    VkDeviceSize srcOffset;\n    VkDeviceSize dstOffset;\n    VkDeviceSize size;\n    VkCommandBuffer commandBuffer; // Valid Command Buffer\n    VkBuffer stagingBuffer; // Valid host-visible buffer\n    VkBuffer buffer; // Valid device-local buffer\n    VkBufferCopy region(srcOffset, dstOffset, size);\n    vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer, 1, &region);\n    ```", "```cpp\nconst VkBufferCreateInfo stagingBufferInfo = {\n    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,\n    .size = size,\n    .usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n};\nconst VmaAllocationCreateInfo\n    stagingAllocationCreateInfo = {\n        .flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |\n            VMA_ALLOCATION_CREATE_MAPPED_BIT,\n        .usage = VMA_MEMORY_USAGE_CPU_ONLY,\n};\nconst VmaAllocationCreateFlagBits allocCreateInfo = {\n    VMA_ALLOCATION_CREATE_MAPPED_BIT,\n    VMA_MEMORY_USAGE_CPU_ONLY,\n};\nVmaAllocation allocation;  // Needs to live until the\n                           // buffer is destroyed\nVK_CHECK(vmaCreateBuffer(allocator, &stagingBufferInfo,\n                         &allocCreateInfo, &buffer,\n                         &allocation, nullptr));\n```", "```cpp\nvkCmdDraw(...); // draws into color attachment 0\nvkCmdDraw(...); // reads from color attachment 0\n```", "```cpp\nVkCommandBuffer commandBuffer;  // Valid Command Buffer\nVkImage image;                  // Valid image\nconst VkImageSubresourceRange subresource = {\n    .aspectMask =.baseMipLevel = 0,\n    .levelCount = VK_REMAINING_MIP_LEVELS,\n    .baseArrayLayer = 0,\n    .layerCount = 1,\n};\nconst VkImageMemoryBarrier imageBarrier = {\n    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,\n    .srcAccessMask =\n        VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR,\n    .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR,\n    .oldLayout = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,\n    .newLayout = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,\n    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n    .image = image,\n    .subresourceRange = &subresource,\n};\nvkCmdPipelineBarrier(\n    commandBuffer,\n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0,\n    nullptr, 0, nullptr, 1, &memoryBarrier);\n```", "```cpp\nvkCmdDraw(...); // draws into color attachment 0\nvkCmdPipelineBarrier(...);\nvkCmdDraw(...); // reads from color attachment 0\n```", "```cpp\nVkFormat format;     // Image format\nVkExtents extents;   // Image size\nuint32_t mipLevels;  // Number of mip levels\nuint32_t layerCount; // Number of layers (sides of cubemap)\nconst VkImageCreateInfo imageInfo = {\n    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,\n    .flags = 0, // optional\n    .imageType = VK_IMAGE_TYPE_2D,  // 1D, 2D, 3D\n    .format = format,\n    .extent = extents,\n    .mipLevels = mipLevels,\n    .arrayLayers = layerCount,\n    .samples = VK_SAMPLE_COUNT_1_BIT,\n    .tiling = VK_IMAGE_TILING_OPTIMAL,\n    .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,\n    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,\n    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,\n};\n```", "```cpp\nconst VmaAllocationCreateInfo allocCreateInfo = {\n    .flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,\n    .usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE,\n    .priority = 1.0f,\n};\n```", "```cpp\nVkImage image = VK_NULL_HANDLE;\nVK_CHECK(vmaCreateImage(vmaAllocator_, &imageInfo,\n                        &allocCreateInfo, &image,\n                        &vmaAllocation_, nullptr));\n```", "```cpp\nVmaAllocationInfo allocationInfo;\nvmaGetAllocationInfo(vmaAllocator_, vmaAllocation_,\n                     &allocationInfo);\n```", "```cpp\nVkDevice device;  // Valid Vulkan Device\nVkImage image;    // Valid Image object\nVkFormat format;\nuint32_t numMipLevels;  // Number of mip levels\nuint32_t layers;  // Number of layers (cubemap faces)\nconst VkImageViewCreateInfo imageViewInfo = {\n    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,\n    .image = image,\n    .viewType =\n        VK_IMAGE_VIEW_TYPE_2D,  // 1D, 2D, 3D, Cubemap\n                                // and arrays\n    .format = format,\n    .components =\n        {\n            .r = VK_COMPONENT_SWIZZLE_IDENTITY,\n            .g = VK_COMPONENT_SWIZZLE_IDENTITY,\n            .b = VK_COMPONENT_SWIZZLE_IDENTITY,\n            .a = VK_COMPONENT_SWIZZLE_IDENTITY,\n        },\n    .subresourceRange = {\n        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,\n        .baseMipLevel = 0,\n        .levelCount = numMipLevels,\n        .baseArrayLayer = 0,\n        .layerCount = layers,\n    }};\nVkImageView imageView{VK_NULL_HANDLE};\nVK_CHECK(vkCreateImageView(device, &imageViewInfo,\n                           nullptr, &imageView));\n```", "```cpp\nVkDevice device;  // Valid Vulkan Device\nVkFilter minFilter;\nVkFilter maxFilter;\nfloat maxLod;  // Max mip level\nconst VkSamplerCreateInfo samplerInfo = {\n    .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,\n    .magFilter = minFilter,\n    .minFilter = magFilter,\n    .mipmapMode = maxLod > 0\n                      ? VK_SAMPLER_MIPMAP_MODE_LINEAR\n                      : VK_SAMPLER_MIPMAP_MODE_NEAREST,\n    .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n    .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n    .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,\n    .mipLodBias = 0,\n    .anisotropyEnable = VK_FALSE,\n    .minLod = 0,\n    .maxLod = maxLod,\n};\nVkSampler sampler{VK_NULL_HANDLE};\nVK_CHECK(vkCreateSampler(device, &samplerInfo, nullptr,\n                         &sampler));\n```", "```cpp\nlayout(set = 0, binding=0) uniform Transforms\n{\n    mat4 model;\n    mat4 view;\n    mat4 projection;\n} MVP;\n```", "```cpp\nstruct Vertex {\n    vec3 pos;\n    vec2 uv;\n    vec3 normal;\n};\nlayout(set = 0, binding=0) uniform Transforms\n{\n    mat4 model;\n    mat4 view;\n    mat4 projection;\n} MVP;\nlayout(set = 1, binding = 0) uniform texture2D textures[];\nlayout(set = 1, binding = 1) uniform sampler   samplers[];\nlayout(set = 2, binding = 0) readonly buffer VertexBuffer\n{\n    Vertex vertices[];\n} vertexBuffer;\n```", "```cpp\nconstexpr uint32_t kMaxBindings = 1000;\nconst VkDescriptorSetLayoutBinding texBinding = {\n    .binding = 0,\n    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,\n    .descriptorCount = kMaxBindings,\n    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,\n};\nconst VkDescriptorSetLayoutBinding samplerBinding = {\n    .binding = 1,\n    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLER,\n    .descriptorCount = kMaxBindings,\n    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,\n};\nstruct SetDescriptor {\n  uint32_t set_;\n  std::vector<VkDescriptorSetLayoutBinding> bindings_;\n};\nstd::vector<SetDescriptor> sets(1);\nsets[0].set_ = 1;\nsets[0].bindings_.push_back(texBinding);\nsets[0].bindings_.push_back(samplerBinding);\n```", "```cpp\nconstexpr VkDescriptorBindingFlags flagsToEnable =\n    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |\n    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;\nfor (size_t setIndex = 0;\n     const auto& set : sets) {\n  std::vector<VkDescriptorBindingFlags> bindFlags(\n      set.bindings_.size(), flagsToEnable);\n  const VkDescriptorSetLayoutBindingFlagsCreateInfo\n      extendedInfo{\n          .sType =\n              VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,\n          .pNext = nullptr,\n          .bindingCount = static_cast<uint32_t>(\n              set.bindings_.size()),\n          .pBindingFlags = bindFlags.data(),\n      };\n  const VkDescriptorSetLayoutCreateInfo dslci = {\n      .sType =\n          VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,\n      .pNext = &extendedInfo,\n      .flags =\n          VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,\n      .bindingCount =\n          static_cast<uint32_t>(set.bindings_.size()),\n      .pBindings = set.bindings_.data(),\n  };\n  VkDescriptorSetLayout descSetLayout{VK_NULL_HANDLE};\n  VK_CHECK(vkCreateDescriptorSetLayout(\n      context_->device(), &dslci, nullptr,\n      &descSetLayout));\n}\n```", "```cpp\nlayout (push_constant) uniform Transforms {\n    mat4 model;\n} PushConstants;\n```", "```cpp\nconst VkPushConstantRange range = {\n    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,\n    .offset = 0,\n    .size = 64,\n};\nstd::vector<VkPushConstantRange> pushConsts;\npushConsts.push_back(range);\n```", "```cpp\nstd::vector<VkDescriptoSetLayout> descLayouts;\nconst VkPipelineLayoutCreateInfo pipelineLayoutInfo = {\n    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n    .setLayoutCount = (uint32_t)descLayouts.size(),\n    .pSetLayouts = descLayouts.data(),\n    .pushConstantRangeCount =\n        !pushConsts.empty()\n            ? static_cast<uint32_t>(pushConsts.size())\n            : 0,\n    .pPushConstantRanges = !pushConsts.empty()\n                               ? pushConsts.data()\n                               : nullptr,\n};\nVkPipelineLayout pipelineLayout{VK_NULL_HANDLE};\nVK_CHECK(vkCreatePipelineLayout(context_->device(),\n                                &pipelineLayoutInfo,\n                                nullptr,\n                                &pipelineLayout));\n```", "```cpp\nconstexpr uint32_t swapchainImages = 3;\nstd::vector<VkDescriptorPoolSize> poolSizes;\npoolSizes.emplace_back(VkDescriptorPoolSize{\n    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,\n    swapchainImages* kMaxBindings});\npoolSizes.emplace_back(VkDescriptorPoolSize{\n    VK_DESCRIPTOR_TYPE_SAMPLER,\n    swapchainImages* kMaxBindings});\n```", "```cpp\nconst VkDescriptorPoolCreateInfo descriptorPoolInfo = {\n    .sType =\n        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,\n    .flags =\n        VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT |\n        VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,\n    .maxSets = MAX_DESCRIPTOR_SETS,\n    .poolSizeCount =\n        static_cast<uint32_t>(poolSizes.size()),\n    .pPoolSizes = poolSizes.data(),\n};\nVkDescriptorPool descriptorPool{VK_NULL_HANDLE};\nVK_CHECK(vkCreateDescriptorPool(context_->device(),\n                                &descriptorPoolInfo,\n                                nullptr,\n                                &descriptorPool));\n```", "```cpp\nVkDescriptorSetAllocateInfo allocInfo = {\n    .sType =\n        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,\n    .descriptorPool = descriptorPool,\n    .descriptorSetCount = 1,\n    .pSetLayouts = &descSetLayout,\n};\nVkDescriptorSet descriptorSet{VK_NULL_HANDLE};\nVK_CHECK(vkAllocateDescriptorSets(context_->device(),\n                                  &allocInfo,\n                                  &descriptorSet));\n```", "```cpp\n    layout(set = 1, binding = 0) uniform texture2D textures[];\n    layout(set = 1, binding = 1) uniform sampler   samplers[];\n    layout(set = 2, binding = 0) readonly buffer VertexBuffer\n    {\n      Vertex vertices[];\n    } vertexBuffer;\n    ```", "```cpp\n    VkImageView imageViews[2];  // Valid Image View objects\n    VkDescriptorImageInfo texInfos[] = {\n     VkDescriptorImageInfo{\n      .imageView = imageViews[0],\n      .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n        },\n     VkDescriptorImageInfo{\n      .imageView = imageViews[1],\n      .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n     },\n    };\n    const VkWriteDescriptorSet texWriteDescSet = {\n        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n        .dstSet = 1,\n        ee,\n        .dstArrayElement = 0,\n        .descriptorCount = 2,\n        .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,\n        .pImageInfo = &texInfos,\n        .pBufferInfo = nullptr,\n    };\n    ```", "```cpp\n    VkSampler sampler[2];  // Valid Sampler object\n    VkDescriptorImageInfo samplerInfos[] = {\n        VkDescriptorImageInfo{\n            .sampler = sampler[0],\n        },\n        VkDescriptorImageInfo{\n            .sampler = sampler[1],\n        },\n    };\n    const VkWriteDescriptorSet samplerWriteDescSet = {\n        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n        .dstSet = 1,\n        .dstBinding = 1,\n        .dstArrayElement = 0,\n        .descriptorCount = 2,\n        .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,\n        .pImageInfo = &samplerInfos,\n        .pBufferInfo = nullptr,\n    };\n    ```", "```cpp\n    VkBuffer buffer;            // Valid Buffer object\n    VkDeviceSize bufferLength;  // Range of the buffer\n    const VkDescriptorBufferInfo bufferInfo = {\n        .buffer = buffer,\n        .offset = 0,\n        .range = bufferLength,\n    };\n    const VkWriteDescriptorSet bufferWriteDescSet = {\n      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,\n      .dstSet = 2,\n      .dstBinding = 0,\n      .dstArrayElement = 0,\n      .descriptorCount = 1,\n      .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,\n      .pImageInfo = nullptr,\n      .pBufferInfo = &bufferInfo,\n    };\n    ```", "```cpp\n    VkDevice device; // Valid Vulkan Device\n    std::vector<VkWriteDescriptorSet> writeDescSets;\n    writeDescSets.push_back(texWriteDescSet);\n    writeDescSets.push_back(samplerWriteDescSet);\n    writeDescSets.push_back(bufferWriteDescSet);\n    vkUpdateDescriptorSets(device, static_cast<uint32_t>(writeDescSets.size()),\n                          writeDescSets.data(), 0, nullptr);\n    ```", "```cpp\nVkCommandBuffer commandBuffer;   // Valid Command Buffer\nVkPipelineLayout pipelineLayout; // Valid Pipeline layout\nuint32_t set;                    // Set number\nVkDescriptorSet descSet;         // Valid Descriptor Set\nvkCmdBindDescriptorSets(\n    commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,\n    pipelineLayout, set, 1u, &descSet, 0, nullptr);\n```", "```cpp\nVkCommandBuffer commandBuffer;   // Valid Command Buffer\nVkPipelineLayout pipelineLayout; // Valid Pipeline Layout\nglm::vec4 mat;                   // Valid matrix\nvkCmdPushConstants(commandBuffer, pipelineLayout,\n                   VK_SHADER_STAGE_FRAGMENT_BIT, 0,\n                   sizeof(glm::vec4), &mat);\n```", "```cpp\nlayout (VkSpecializationInfo structure that specifies the constant values and their IDs. You then pass this structure to the VkPipelineShaderStageCreateInfo structure when creating a pipeline:\n\n```", "```cpp\n\n Because specialization constants are real constants, branches that depend on them may be entirely removed during the final compilation of the shader. On the other hand, specialization constants should not be used to control parameters such as uniforms, as they are not as flexible and require to be known during the construction of the pipeline.\nImplementing MDI and PVP\nMDI and PVP are features of modern graphics APIs that allow for greater flexibility and efficiency in vertex processing.\nMDI allows issuing multiple draw calls with a single command, each of which derives its parameters from a buffer stored in the device (hence the *indirect* term). This is particularly useful because those parameters can be modified in the GPU itself.\nWith PVP, each shader instance retrieves its vertex data based on its index and instance IDs instead of being initialized with the vertex’s attributes. This allows for flexibility because the vertex attributes and their format are not baked into the pipeline and can be changed solely based on the shader code.\nIn the first sub-recipe, we will focus on the implementation of **MDI**, demonstrating how this powerful tool can streamline your graphics operations by allowing multiple draw calls to be issued from a single command, with parameters that can be modified directly in the GPU. In the following sub-recipe, we will guide you through the process of setting up **PVP**, highlighting how the flexibility of this feature can enhance your shader code by enabling changes to vertex attributes without modifying the pipeline.\nImplementing MDI\nFor using MDI, we store all mesh data belonging to the scene in one big buffer for all the meshes’ vertices and another one for the meshes’ indices, with the data for each mesh stored sequentially, as depicted in *Figure 2**.12*.\nThe drawing parameters are stored in an extra buffer. They must be stored sequentially, one for each mesh, although they don’t have to be provided in the same order as the meshes:\n![Figure 2.12 – MDI data layout](img/B18491_02_12.jpg)\n\nFigure 2.12 – MDI data layout\nWe will now learn how to implement MDI using the Vulkan API.\nGetting ready\nIn the repository, we provide a utility function to decompose an `EngineCore::Model` object into multiple buffers suitable for an MDI implementation, called `EngineCore::convertModel2OneBuffer()`, located in `GLBLoader.cpp`.\nHow to do it…\nLet’s begin by looking at the indirect draw parameters’ buffer.\nThe commands are stored following the same layout as the `VkDrawIndexedIndirectCommand` structure:\n\n```", "```cpp\n\n `indexCount` specifies how many indices are part of this command and, in our case, is the number of indices for a mesh. One command reflects one mesh, so its `instanceCount` value is one. The `firstVertex` member is the index of the first index element in the buffer to use for this mesh, while `vertexOffset` points to the first vertex element in the buffer to use. An example with the correct offsets is shown in *Figure 2**.12*.\nOnce the vertex, index, and indirect commands buffers are bound, calling `vkCmdDrawIndexedIndirect` consists of providing the buffer with the indirect commands and an offset into the buffer. The rest is done by the device:\n\n```", "```cpp\n\n In this recipe, we learned how to utilize `vkCmdDrawIndexedIndirect`, a key function in Vulkan that allows for high-efficiency drawing.\nUsing PVP\nThe PVP technique allows vertex data and their attributes to be extracted from buffers with custom code instead of relying on the pipeline to provide them to vertex shaders.\nGetting ready\nWe will use the following structures to perform the extraction of vertex data – the `Vertex` structure, which encodes the vertex’s position (`pos`), `normal`, UV coordinates (`uv`), and its material index (`material`):\n\n```", "```cpp\n\n We will also use a buffer object, referred to in the shader as `VertexBuffer`:\n\n```", "```cpp\n\n Next, we will learn how to use the `vertexBuffer` object to access vertex data.\nHow to do it…\nThe shader code used to access the vertex data looks like this:\n\n```", "```cpp\n\n Note that the vertex and its attributes are not declared as inputs to the shader. `gl_VertexIndex` is automatically computed and provided to the shader based on the draw call and the parameters recorded in the indirect command retrieved from the indirect command buffer.\nIndex and vertex buffers\nNote that both the index and vertex buffers are still provided and bound to the pipeline before the draw call is issued. The index buffer must have the `VK_BUFFER_USAGE_INDEX_BUFFER_BIT` flag enabled for the technique to work.\nAdding flexibility to the rendering pipeline using dynamic rendering\nIn this recipe, we will delve into the practical application of dynamic rendering in Vulkan to enhance the flexibility of the rendering pipeline. We will guide you through the process of creating pipelines without the need for render passes and framebuffers and discuss how to ensure synchronization. By the end of this section, you will have learned how to implement this feature in your projects, thereby simplifying your rendering process by eliminating the need for render passes and framebuffers and giving you more direct control over synchronization.\nGetting ready\nTo enable the feature, we must have access to the `VK_KHR_get_physical_device_properties2` instance extension, instantiate a structure of type `VkPhysicalDeviceDynamicRenderingFeatures`, and set its `dynamicRendering` member to `true`:\n\n```", "```cpp\n\n This structure needs to be plugged into the `VkDeviceCreateInfo::pNext` member when creating a Vulkan device:\n\n```", "```cpp\n\n Having grasped the concept of enabling dynamic rendering, we will now move forward and explore its implementation using the Vulkan API.\nHow to do it…\nInstead of creating render passes and framebuffers, we must call the `vkCmdBeginRendering` command and provide the attachments and their load and store operations using the `VkRenderingInfo` structure. Each attachment (colors, depth, and stencil) must be specified with instances of the `VkRenderingAttachmentInfo` structure. *Figure 2**.13* presents a diagram of the structure participating in a call to `vkCmdBeginRendering`:\n![Figure 2.13 – Dynamic rendering structure diagram](img/B18491_02_13.jpg)\n\nFigure 2.13 – Dynamic rendering structure diagram\nAny one of the attachments, `pColorAttachments`, `pDepthAttachment`, and `pStencilAttachment`, can be `null`. Shader output written to location `x` is written to the color attachment at `pColorAttachment[x]`.\nTransferring resources between queue families\nIn this recipe, we will demonstrate how to transfer resources between queue families by uploading textures to a device from the CPU using a transfer queue and generating mip-level data in a graphics queue. Generating mip levels needs a graphics queue because it utilizes `vkCmdBlitImage`, supported only by graphics queues.\nGetting ready\nAn example is provided in the repository in `chapter2/mainMultiDrawIndirect.cpp`, which uses the `EngineCore::AsyncDataUploader` class to perform texture upload and mipmap generation on different queues.\nHow to do it…\nIn the following diagram, we illustrate the procedure of uploading texture through a transfer queue, followed by the utilization of a graphics queue for mip generation:\n![Figure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families](img/B18491_02_14.jpg)\n\nFigure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families\nThe process can be summarized as follows:\n\n1.  Record the commands to upload the texture to the device and add a barrier to release the texture from the transfer queue using the `VkDependencyInfo` and `VkImageMemoryBarrier2` structures, specifying the source queue family as the family of the transfer queue and the destination queue family as the family of the graphics queue.\n2.  Create a semaphore and use it to signal when the command buffer finishes, and attach it to the submission of the command buffer.\n3.  Create a command buffer for generating mip levels and add a barrier to acquire the texture from the transfer queue into the graphics queue using the `VkDependencyInfo` and `VkImageMemoryBarrier2` structures.\n4.  Attach the semaphore created in *step 2* to the `SubmitInfo` structure when submitting the command buffer for processing. The semaphore will be signaled when the first command buffer has completed, allowing the mip-level-generation command buffer to start.\n\n    Two auxiliary methods will help us create acquire and release barriers for a texture. They exist in the `VulkanCore::Texture` class. The first one creates an acquire barrier:\n\n    ```", "```cpp\n\n    Besides the command buffer, this function requires the indices of the source and destination family queues. It also assumes a few things, such as the subresource range spanning the entire image.\n\n     5.  Another method records the release barrier:\n\n    ```", "```cpp\n\n    This method makes the same assumptions as the previous one. The main differences are the source and destination stages and access masks.\n\n     6.  To perform the upload and mipmap generation, we create two instances of `VulkanCore::CommandQueueManager`, one for the transfer queue and another for the graphics queue:\n\n    ```", "```cpp\n\n     7.  With valid `VulkanCore::Context` and `VulkanCore::Texture` instances in hand, we can upload the texture by retrieving a command buffer from the transfer family. We also create a staging buffer for transferring the texture data to device-local memory:\n\n    ```", "```cpp\n\n     8.  For submitting the command buffer for processing, we create a semaphore to synchronize the upload command buffer and the one used for generating mipmaps:\n\n    ```", "```cpp\n\n     9.  The next step is to acquire a new command buffer from the graphics queue family for generating mipmaps. We also create an acquire barrier and reuse the semaphore from the previous command buffer submission:\n\n    ```", "```cpp\n\nIn this chapter, we have navigated the complex landscape of advanced Vulkan programming, building upon the foundational concepts introduced earlier. Our journey encompassed a diverse range of topics, each contributing crucial insights to the realm of high-performance graphics applications. From mastering Vulkan’s intricate memory model and efficient allocation techniques to harnessing the power of the VMA library, we’ve equipped ourselves with the tools to optimize memory management. We explored the creation and manipulation of buffers and images, uncovering strategies for seamless data uploads, staging buffers, and ring-buffer implementations that circumvent data races. The utilization of pipeline barriers to synchronize data access was demystified, while techniques for rendering pipelines, shader customization via specialization constants, and cutting-edge rendering methodologies such as PVP and MDI were embraced. Additionally, we ventured into dynamic rendering approaches without relying on render passes and addressed the intricacies of resource handling across multiple threads and queues. With these profound understandings, you are primed to create graphics applications that harmonize technical prowess with artistic vision using the Vulkan API.\n\n```"]