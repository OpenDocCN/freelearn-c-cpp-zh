- en: Selecting an IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **integrated development environment** (**IDE**) has the ability to greatly
    help or hinder development. Depending on the specific goals of a project, an IDE
    could prove extremely easy to integrate into a workflow or simply get in the way.
    IDEs are designed to have a small learning curve and will often offer an easy
    way to build solutions from existing drivers and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be discussing how to select an IDE, taking a look at
    the different types of IDEs, and selecting one to use to create all of the source
    code you'll find in the code pack used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick list of the main topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE selection criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-abstracted IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source/free IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proprietary IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the IDE for this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no software or hardware requirements for this chapter (software will
    be installed toward the end).
  prefs: []
  type: TYPE_NORMAL
- en: The IDE selection criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision to select an IDE can take place at many different levels of an
    organization. A single engineer may be using the IDE for just one project. In
    this case, they're likely to simply select whatever they're familiar with or whatever
    happens to ship with the **microcontroller unit** (**MCU**) for that project.
    At the other end of the spectrum, an entire department could be integrating the
    IDE into their development workflow. In this case, the decision could affect dozens
    of engineers and address multiple target platforms for years down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Some engineers prefer no IDE at all—instead, they'll pull together their favourite
    text editor and a command-line compiler or linker (such as GCC or Clang), handcraft
    some makefiles, and set off with coding. This is a perfectly valid approach, too—it
    will result in a great amount of flexibility and less dependence on proprietary
    tools and should certainly be considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of IDEs in the following sections is not meant to be exhaustive. The
    list is presented in order to provide examples of the wide variety of IDEs available
    and the different focal points of each. Here are some quick points to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Language support**: Not everything on an embedded MCU is written in C99 (or
    assembly) anymore; there are many language options out there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging support**: Unless you plan on context-switching to a different
    tool each time, debugging is necessary. Your IDE should have some debugging capability.
    Many IDEs will rely on the **GNU Debugger** (**GDB**) for the underlying debug
    protocol, which means they should be compatible with any debug hardware that supports
    a GDB interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread-aware debugging**: Ideally, the IDE will have thread-aware debug capability.
    Remember, each task has its own stack. By default, most debug capabilities will
    only show the stack associated with the current program counter, which becomes
    problematic when attempting to analyze any task that isn''t currently running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device support**: Pick an IDE that can be made aware of hardware registers
    in your device (unless you won''t be debugging with it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The platform OS**: That is, Windows, Linux, or macOS—you can always run a
    virtual machine, but it is generally more convenient to run the IDE natively on
    your preferred OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: The initial cost of a tool should take into account both the monetary
    price and the amount of time it would take to integrate the tool into your team''s
    workflow. This initial cost is tightly coupled with the current state of an organization/individual.
    For example, the cost (in time) of getting a familiar IDE up and running is generally
    very low, but this cost is dependent on what is familiar to the team. A high total
    cost of ownership can be caused by a number of different factors. Some IDEs are
    freely available but have volatile availability (vendor-supplied IDEs often fall
    into this category). If an IDE has many bugs, the cost of ownership may be high
    because of lost productivity. Finally, paid proprietary solutions often require
    annual maintenance agreements for support, updates for the latest hardware, and
    new versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with other tools**: There are many components that make up developing
    an embedded system. Having an IDE that integrates as much as possible is helpful,
    but some of the items to consider are the target hardware, test fixtures, debugging
    hardware, RTOS firmware, user firmware, target middleware, ancillary host software
    to help configure hardware (that is, STM32Cube), software to help you analyze
    and debug code (that is, static analysis tools), and testing frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Ideally, an IDE will provide a pleasant environment to code
    in and boost productivity by making code creation easier through automating cross-references
    (such as IntelliSense).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: In a perfect world, the original IDE would be available,
    fully supported, and provide updates to make the most of new hardware targets
    throughout the entire lifetime of a product or project. For long-term projects,
    it is a good idea to check the history (and licensing model) of the IDE you are
    planning to use. If the IDE is only available via subscription (with no perpetual
    licensing option), there could come a day when it is simply no longer available.
    Ensuring a perpetual license is always on hand enables you to run the IDE indefinitely
    and gives you the assurance that you''ll always be able to reproduce binaries
    from source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The eco-system**: Most IDEs come with more than just the IDE itself. They''ll
    have plugins, middleware, forums, and sometimes entire communities of developers
    with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next sections, we''ll cover a few different conceptual groups of IDEs.
    Grouping IDEs in this way isn''t especially rigid, but it does help to frame expectations
    of what their motivations and use cases are. Sometimes, an IDE can be placed into
    more than one group, which is also perfectly acceptable. The groups we''ll use
    to categorize the IDEs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Free MCU vendor IDEs and hardware-centric IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-abstracted IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source/free IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proprietary IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example IDEs presented in this chapter date to 2019\. While embedded system
    firmware development tools don't change quite as quickly as other software disciplines,
    expect the landscape to look a bit different over time!
  prefs: []
  type: TYPE_NORMAL
- en: Free MCU vendor IDEs and hardware-centric IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days, larger MCU manufacturers will generally provide access to a free
    IDE to help lower the barriers to entry for potential developers. Historically,
    these IDEs didn't offer much more than a compiler and were generally pretty terrible
    to work with if you were using them daily. However, in the past few years, there's
    been a shift to higher quality vendor-supplied IDEs, as chip manufacturers try
    to differentiate themselves from their competitors. Sometimes, they have extra
    features integrated that will help configure hardware and/or vendor-supplied drivers,
    which can be helpful during hardware development, initial board bring-up, and
    early firmware development, where hardware peripherals are being exercised and
    integrated with the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Since these tools aren't the core business concern of a hardware manufacturer,
    they will often be changed on a whim. This makes vendor IDEs a risky choice for
    long-running projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost to prove this point, STM changed their IDE offerings while this book
    was being written. All of the examples needed to be imported into the new software:
    STM32CubeIDE.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we'll be using an STM32 MCU for our target, we'll take a look at the IDE
    supplied by STM (at the time of writing, this is STM32CubeIDE). For each of the
    different MCU vendors, you could consider their proprietary IDE—for example, if
    you were developing on NXP MCUs, you would likely consider MCUXpresso.
  prefs: []
  type: TYPE_NORMAL
- en: STM32CubeIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of STM, there are multiple IDEs offered by the same MCU vendor.
    Sometime after acquiring Atollic, STM rolled in a fully-customized version of
    Atollic TrueStudio with their STMCubeMX application, resulting in STM32CubeIDE.
    Although Atollic TrueStudio is still available, it is deprecated and not recommended
    for new designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for STM32CubeIDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, Linux, or macOS |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | GDB, STLink, JLink, JTrace, and more |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Eclipse |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC, extensible |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary—freeware |'
  prefs: []
  type: TYPE_TB
- en: 'Now that we''ve looked at the IDEs designed with only one MCU in mind, we''ll
    take a look at the polar opposite to vendor-supplied IDEs: platform-abstracted
    IDEs.'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-abstracted IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of increasingly complex MCUs, ballooning expectations of device
    functionality, and shrinking development cycles has pushed many software tooling
    companies to focus on creating abstractions above the hardware, which is meant
    to make the development of complex devices easier and faster. The most successful
    platforms and abstractions tend to take on a life of their own after a few years
    on the market. Mbed and Arduino both have extensive user communities, with many
    user-created websites and blogs dedicated to each platform.
  prefs: []
  type: TYPE_NORMAL
- en: Because platform consistency is paramount for ease of use, implementations will
    often include many features that focus on ease of use, sometimes at the expense
    of performance and good design practice. For example, some hardware targets will
    expose an API for something such as a PWM output, even though the underlying MCU
    hardware has no peripheral that supports that functionality. This creates a faster
    prototyping experience across many different hardware targets, since the API will
    seamlessly map the functionality to a software routine. However, device performance
    can be negatively impacted as a result. Sometimes the programmer isn't even aware
    of the complex trade-offs that are being made underneath the simple API calls
    they're making.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different contributing factors that determine whether or not
    it is a good idea to base a project around a platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing on top of a platform could be good in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The platform has nearly everything you''ll need included with it**: If the
    platform already has all the major pieces, there is little uncertainty; all that
    is required is some domain-specific code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Your intended target device has a development board that meets your exact
    requirements**: This results in less uncertainty than attempting to add many missing
    subcircuits and properly integrate them with existing platform code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most engineers on the team already have deep experience with the platform**: *Deep*
    experience means they have added capability similar to any customizations the
    project requires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Designing on top of a platform could be bad in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Few team members have experience with the desired platform**: Some are more
    complex than others—not having someone with first-hand experience can be risky.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The MCU you intend to use is not already supported by the platform**: There
    are often many ancillary requirements for adding MCU support to a platform that
    add no value to your project. Adding support for a new device to an existing complex
    platform will require more effort for a very simple project than creating the
    project on top of bare metal or with minimal vendor-supplied libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black box debugging is difficult**: As an embedded engineer moves further
    away from hardware, it becomes increasingly difficult to understand why the system
    is behaving the way it is, especially when there are multiple layers of **other
    people''s code** (**OPC**) to dig through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A young, real-time embedded engineer's professional development can be severely
    hampered by investing too much time and energy into platforms early on. With all
    of this additional complexity, there is additional risk and uncertainty around
    whether deadlines will be met reliably in a real-time system. Digging into a complex
    code base to try and track down a complex intermittent bug can be a real challenge.
    This challenge becomes even larger when a solid foundation of low-level knowledge
    isn't there to draw upon.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, we'll cover a few options for platform-abstracted
    IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: ARM Mbed Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ARM Mbed is an IoT-focused platform that provides a very large middleware library
    and a consistent development environment across many different hardware vendors.
    Originally, the Mbed platform was only available through a website, but they have
    now added Mbed Studio—an offline IDE available for Windows and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for ARM Mbed Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://os.mbed.com/studio/](https://os.mbed.com/studio/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or online (Mbed online) |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | pyOCD for limited graphical debugging or GDB (console
    only) |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Theia |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | ARM Compiler 6, GCC, and IAR |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Apache 2.0 |'
  prefs: []
  type: TYPE_TB
- en: Since Mbed is platform-oriented, projects can be set up with the Mbed IDE, then
    exported to various offline IDEs, such as ARM Keil uVision, or makefile based
    projects, which import to Eclipse and Visual Studio Code. If your project requires
    the functionality provided by the included middleware and it is well implemented,
    not needing to re-invent the wheel can be a serious timesaver.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino platform is an extremely pervasive platform with a huge ecosystem
    of hardware and software. Generally used to introduce newcomers to electronics
    and programming, the Arduino IDE uses strictly structured libraries that expose
    a dialect of C/C++ for users to write sketches. The goal of Arduino is to make
    prototyping quick and easy for non-programmers. As such, it hides as many details
    about the underlying hardware as possible inside libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for the Arduino IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, Linux, and online |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | None |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Proprietary Java, processing |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | avg-gcc, board-specific |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | GNU |'
  prefs: []
  type: TYPE_TB
- en: There are also many more non-Arudino supplied IDEs that can be used to program
    the Arduino platform. Some will have additional capabilities and expose more of
    the underlying C/C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered fully abstracted IDEs, we'll move on to more traditionally
    oriented IDEs that are open source and/or freely available.
  prefs: []
  type: TYPE_NORMAL
- en: Open source/free IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since IBM created the Eclipse foundation to promote an open source, highly extensible
    IDE, many Eclipse-based IDEs have popped up. We'll take a look at two such IDEs
    in this section. In recent years, Microsoft has started to focus heavily on open
    source projects, creating the freely available, open source Visual Studio Code
    text editor, which is also covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: AC6 System Workbench for STM32 (S4STM32)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AC6 is a consulting firm that has contributed an Eclipse-based IDE that targets
    STM32 MCUs. System Workbench adds some support for STM-based discovery boards
    to help get projects set up quickly. AC6 also offers System Workbench for Linux,
    which can be useful if you are developing an application with one of the multi-core
    devices (from the STM32MP1 family).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for AC6 System Workbench for STM32:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [http://ac6-tools.com/content.php/content_SW4MCU.xphp](http://ac6-tools.com/content.php/content_SW4MCU.xphp)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | GDB |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Eclipse |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary free |'
  prefs: []
  type: TYPE_TB
- en: Another alternative to System Workbench is to start with a bare Eclipse CDT
    install.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse CDT and GCC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also choose to roll your own Eclipse-based IDE from scratch. Eclipse
    CDT is the de facto standard for C/C++ development. You'll also need to provide
    a compiler. ARM provides a full GCC site for cross-compiling to ARM Cortex-M devices
    from Windows, Linux, and macOS. It can be found at [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for Eclipse CDT:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.eclipse.org/cdt/](https://www.eclipse.org/cdt/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | GDB |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Eclipse |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | **Eclipse Public License** (**EPL**) |'
  prefs: []
  type: TYPE_TB
- en: 'For those that don''t care for the Eclipse IDE, another alternative exists
    and is becoming increasingly popular: Visual Studio Code.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2015, Microsoft released Visual Studio Code, which is a text editor that
    provides the ability to add extensions. While this sounds fairly straightforward
    on the surface, there are enough extensions available to give a very respectable
    IDE experience, including IntelliSense and full debug capability. If you're used
    to Visual Studio-based IntelliSense and debugging, then this environment will
    be very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://code.visualstudio.com/](https://code.visualstudio.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | GDB, ST-Link, and others |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Visual Studio Code |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | Many |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | MIT |'
  prefs: []
  type: TYPE_TB
- en: 'Similar to Eclipse CDT, Visual Studio Code will need GCC installed, as well
    as an extension. In order to get Visual Studio properly set up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To install GCC for Cortex-M, go to [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install the JLink tools (used to connect to the debug probe), go to [https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install the `cortex-debug` extension, go to [https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug](https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, all of the IDEs we have covered have been free of charge (and in some
    cases, open source). The next section includes IDEs that cost money and are largely
    closed source. *Why would anyone want such a thing?,* you ask. Read on and find
    out what these solutions have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the norm for cross-compiling applications for MCUs, paid proprietary IDEs
    are starting to be outnumbered by free, open source solutions. However, the mere
    existence of free options doesn't immediately render paid options obsolete. The
    selling point of proprietary IDEs is that they provide the widest range of device
    support and require the least amount of attention from the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Designed to work out of the box, the paid professional-grade solutions'' claim
    to fame is saving developers time. These time savings will typically come in three
    main forms: unified environments for setting up an MCU, unified debugging environments,
    and vendor-supplied middleware, common across multiple MCU vendors.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting an MCU up and running is easier now than it ever has been, but once
    a project gets advanced enough that it starts defining specific memory regions
    in RAM and ROM or adding additional executable space in Quad-SPI-based flash,
    some additional configuration will be required. The best professional IDEs will
    provide some help (via GUIs), which makes these configurations a bit easier than
    needing to dive into scatter files and assembly-based start-up code (although
    these are *excellent* skills to have!)
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the ability to quickly configure an MCU via a GUI, debugger support
    in pro-grade IDEs will also typically be very straightforward, generally limited
    to selecting the debugger from a drop-down list and possibly fine-tuning some
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: If you read through all of the options that different MCUs could possess, it
    probably comes as no surprise that the same MCU won't be a great fit for every
    project you undertake. Being able to quickly move between MCU families (and even
    vendors) while maintaining a unified interface is an excellent advantage. However,
    getting locked into a platform-based approach, where hardware interfaces start
    to become defined (as well as firmware APIs), can be limiting, too (that is, Arduino
    or MBed hardware definitions).
  prefs: []
  type: TYPE_NORMAL
- en: Using well-written middleware from an established company breaks you free from
    the tendency of hardware-oriented platforms focusing on only the day-lighted peripherals.
    It moves the focus from accessing a particular platform's pins to accessing properly
    abstracted MCU peripherals. This distinction is subtle but quite important when
    it comes to design flexibility. Well-written middleware will provide consistent
    abstractions of MCU peripherals, as well as more sophisticated middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to paid tooling is the monetary cost, which needs to be evaluated
    against the development time, labor, and opportunity costs of a delayed product
    launch. Do you have an idea of the amount of time you can save by using middleware
    instead of reinventing that firmware wheel? What about the amount of time gained
    by having an IDE that works consistently for any processor you choose? Some basic
    **return-on-investment** (**ROI**) calculations comparing the cash outlay against
    *honest* *and accurate* estimates of the developer's time will typically tip the
    scales toward bought-in middleware for moderately complex projects. That is, of
    course, assuming cash is available to purchase software tooling.
  prefs: []
  type: TYPE_NORMAL
- en: ARM/Keil uVision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keil originally developed one of the first C compilers for the 8-bit 8051 architecture
    back in the 1980s. The company moved on to support other cores and was eventually
    acquired by ARM. They currently offer one of the most efficient compilers for
    ARM Cortex-M devices (Clang/LLVM). A free version of the uVision IDE is available
    but is limited to 32 KB code space. Various tiers of the IDE are available in
    several licensing options (such as perpetual, subscription-based, and so on).
    Modules of code are added through *software packs*, which simplifies rapidly setting
    up projects. A very fully featured middleware stack is available as a top-tier
    offering, which comes abstractions for different RTOSes as well as a uniform API
    on top of all of the supported MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for uVision:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [http://www2.keil.com/mdk5/uvision/](http://www2.keil.com/mdk5/uvision/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | Many |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | armcc, armClang, GCC |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | free-$$$ |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: FreeRTOS task-aware debugging is not available—Keil uVision has elaborate support
    for their own freely available CMSIS RTX RTOS instead. The code editor in uVision
    MDK is also overdue a facelift.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Keil uVision, IAR Embedded Workbench is another long-standing IDE
    for embedded work.
  prefs: []
  type: TYPE_NORMAL
- en: IAR Embedded Workbench
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, IAR Embedded Workbench has a very similar feature set to Keil uVision.
    One major difference is that IAR doesn't have the advanced capability of incorporating
    modular software packs. Advanced debugging features are a bit more easily accessible
    and intuitive in IAR versus uVision. The code editor is equally disappointing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for IAR Embedded Workbench:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.iar.com/iar-embedded-workbench/](https://www.iar.com/iar-embedded-workbench/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | Many |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | $$–$$$ |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: Now that we've covered the old standbys, we'll get into the more recently available
    offerings, starting with Rowley CrossWorks.
  prefs: []
  type: TYPE_NORMAL
- en: Rowley CrossWorks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rowley Crossworks is a slightly lower priced entry point than Keil and IAR.
    Middleware is licensed separately from the IDE. FreeRTOS-aware task-based debugging
    is not available from within the IDE; instead, support is available for the **CrossWorks
    Tasking Library** (**CTL**) RTOS solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for CrossWorks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.rowley.co.uk/](https://www.rowley.co.uk/) |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | Many |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC, LLVM |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | $–$$$ |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: 'Next up is an IDE created by a company known for its debugging hardware: SEGGER
    Embedded Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: SEGGER Embedded Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEGGER—the manufacturer of the debug probe we'll be using—also offers many software
    products, including their own IDE (and RTOS). It is available free of charge for
    non-commercial use, with no limitations. They also have a full middleware stack
    available, which is licensed separately from the IDE. FreeRTOS-aware debugging
    is available directly in the IDE, with the appropriate plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for Embedded Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://www.segger.com/products/development-tools/embedded-studio/](https://www.segger.com/products/development-tools/embedded-studio/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger Support** | SEGGER |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC, LLVM |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | Free for noncommercial use or $$-$$$ |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary, JLink as a license dongle |'
  prefs: []
  type: TYPE_TB
- en: 'We''ll end the list of paid IDEs on a curious note: SysProgs Visual GDB.'
  prefs: []
  type: TYPE_NORMAL
- en: SysProgs Visual GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual GDB isn't actually an IDE. It is a plugin for Microsoft Visual Studio
    and Visual Studio Code. It has been in existence for quite some time (since 2012).
    The main purpose of Visual GDB is to provide a consistent UI (Visual Studio) for
    interacting with GDB-enabled debuggers and GNU make utilities. Its main target
    user is programmers that are familiar with Visual Studio as a development environment
    and would like to continue that environment in their embedded work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick stats for Visual GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Website** | [https://sysprogs.com/](https://sysprogs.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| **Host OS** | Windows, macOS, or Linux |'
  prefs: []
  type: TYPE_TB
- en: '| **Debugger support** | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **IDE framework** | Visual Studio, Visual Studio Code |'
  prefs: []
  type: TYPE_TB
- en: '| **Compiler** | GCC, ARM |'
  prefs: []
  type: TYPE_TB
- en: '| **Multi-core debug** | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | $ |'
  prefs: []
  type: TYPE_TB
- en: '| **License type** | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: Visual GDB offers integration with a graphical configuration utility—STM Cube—as
    well as Arduino projects, so migrating from different development frameworks may
    be a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll select an IDE specifically for our use case, which is developing
    the coding exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the IDE used in this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've categorized several different IDEs, it's time to consider which
    one will be used for the example code covered in the remainder of this book. In
    keeping with the low-cost theme in order to reduce the barriers to entry, we're
    going to focus on the IDEs that don't require any monetary investment—anything
    that is freely available for non-professional use (without time or code limits)
    can be considered. This immediately eliminates Keil uVision, IAR Embedded Workbench,
    and SysProgs Visual GDB. Keil has a free version that is code-limited to 32 KB,
    but we might use that up quickly, depending on how much middleware we elect to
    include in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Since a large part of this book also covers debugging with a J-Link probe, we'd
    like to have an IDE that supports either J-Link or GDB, as well. In a perfect
    world, the IDE would also support task-aware FreeRTOS debugging, live variable
    watches, and so on. The FreeRTOS kernel-aware debugging isn't a deal-breaker,
    as we'll see in the next chapter, because SEGGER Ozone includes this capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the IDE should be multi-platform to promote ease of adoption for anyone
    brave enough to make the journey. Given this set of criteria, we''re left with
    a limited number of options, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Potential IDE | Monetarily free  version available | No code size limits
    | SEGGER J-Link supported | FreeRTOS kernel-aware debug | Multi-platform |'
  prefs: []
  type: TYPE_TB
- en: '| Keil uVision | ✓ | X | ✓ | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| IAR | X | N/A | ✓ | ✓ | X |'
  prefs: []
  type: TYPE_TB
- en: '| Visual GDB | X | N/A | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| Rowley CrossWorks | X | N/A | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| VS Code | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| Eclipse CDT | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| AC6 S4STM32 | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino IDE | ✓ | ✓ | ✓ | X | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| ARM MBed Studio | ✓ | ✓ | ✓ | X | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| STM32CubeIDE | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| SEGGER Embedded Studio | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: So, what are the main points we can derive from this table and the previous
    observations?
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse CDT is a potential candidate, but it is slightly less desirable because
    of the additional setup required compared to some of the other solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code is an extensible code editor (out of the box), similar to Eclipse. Additional
    plug-ins will be needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STM32But IDE promises professional-grade debug capability and multi-task RTOS
    aware debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEGGER Embedded Studio promises a very similar feature set to STM32CubeIDE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be using STM32CubeIDE for the code examples. Since STM32CubeIDE also contains
    code generators for the STM32 line of MCUs, let's take a look at some of the advantages
    of using a code generation tool, as well as the tradeoffs to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Considering STM32Cube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STM32CubeIDE is the merger of two components—IDE and the STMCubeMX graphical
    configuration and code generation utility for STM32 MCUs. The *CubeMX* component
    can be useful in a few different points in the development cycle. Let's talk about
    the relevant phases of the development cycle, identify how CubeMX can help, and
    what the trade-offs are.
  prefs: []
  type: TYPE_NORMAL
- en: Device selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern MCUs have the option of mapping peripherals to several different
    pins. However, each pin is usually shared between several different peripherals.
    So, it is possible, on a pin-constrained device, to have the required peripherals *available *(present
    on the MCU) but not *accessible* (able to be mapped to a physical pin). Hardware
    designers can quickly evaluate whether or not individual models of an STM32 MCU
    break out the necessary combinations of peripherals that are required for a given
    application. Having the ability to quickly and accurately perform these evaluations
    across multiple chips can be a major time saver. Usually, designers need to become
    intimately familiar with datasheets for each chip before making such decisions.
    CubeMX is by no means a substitute for proper due diligence, but it does help
    to quickly narrow the field of potential devices.
  prefs: []
  type: TYPE_NORMAL
- en: Each peripheral on STM32 MCUs can be individually turned off, which saves power.
    With the current proliferation of battery-powered (and energy-harvesting) IoT
    devices, minimizing power consumption is a hot topic. Another way to reduce power
    is to clock the chip at a lower frequency. CubeMX allows engineers to quickly
    calculate how much power the chip will draw under specific configurations. Speed
    and accuracy are both important when investigating potential MCUs for a project.
    Getting an accurate power consumption estimate by entering a peripheral/clock
    configuration into CubeMX is much faster compared to perusing the datasheet and
    creating a spreadsheet from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Once a target MCU has been selected and the custom hardware has been manufactured,
    it is time to *bring up* that new piece of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware bring-up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware *bring-up* is the act of first powering on a custom-designed piece
    of hardware and performing some level of verification on it. Custom hardware will
    often have many differences compared to a development/evaluation board (it is
    custom, after all!). One area that may differ is clock hardware. STM32 clock trees
    are fairly complex—a single clock source feeds many different subsystems. The
    clock frequencies get modified along the way by multipliers and dividers. CubeMX
    contains a graphical wizard to help properly configure the STM32 clock tree and
    generate initialization code to get the chip up and running quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Early firmware effort will also be required to verify the hardware is operational.
    It is always a good idea to double-check whether the MCU can be configured to
    access all required off-chip circuitry that is present on the board. Often, it
    is in everyone's best interest to quickly evaluate the viability of the hardware,
    rather than wait until all aspects of firmware are fully fleshed out.
  prefs: []
  type: TYPE_NORMAL
- en: When it is time to make use of the complex peripherals included on STM32 MCUs,
    CubeMX can be used to quickly set up pin mapping from the internal peripheral
    to the external pins of the MCU. It also contains simple, menu-driven interfaces
    for selecting how the peripheral should be configured. Initialization code is
    automatically generated, which uses STM's **Hardware Abstraction Layer** (**HAL**)
    drivers. The relevant peripheral interrupts are also configured and stubbed out
    for the user. This enables an embedded engineer to get through verification as
    quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: After all of the hardware is proven, it will be time to add in the additional
    layers of firmware (middleware) that will live between the low-level drivers and
    the application firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STM has partnered with many different middleware providers over the years to
    make bringing in additional functionality more straightforward for their customers.
    For example, FreeRTOS primitives can be selected with a few drop-down menus in
    CubeMX. A FAT file system can be set up, as well as a TCP/IP stack, libraries
    for JPEG images, and Mbed TLS. Make no mistake, the tool won't perform advanced
    configuration like a well-versed programmer, but as a bare minimum, it provides
    a solid start for evaluating unfamiliar libraries. Some engineers may find the
    initial configurations to fit their requirements directly, which means more time
    to focus on other portions of their solution.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we've got a device selected, hardware verified, and some middleware
    stacks in place, it must be time to move on to coding the final application! Well...
    not quite. Using all of this code as supplied comes with some gotchas—let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While all of these features sound incredible in theory, developers have had
    mixed feelings regarding CubeMX and its use in real-world applications. Most of
    these concerns and trade-offs involve how the tool fits into a workflow; other
    times, the challenges stem from usability issues.
  prefs: []
  type: TYPE_NORMAL
- en: From a usability standpoint, CubeMX *generally* works well; other times, it
    generates invalid code that simply won't work as intended. This seems to have
    been more of an issue when it was first released. Occasionally, versions would
    ship that would create projects that didn't even compile. However, as a minimum,
    it has always provided an excellent reference point for the configuration of the
    advanced peripherals available on the newer STM32 devices.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges engineers face when integrating CubeMX to their workflow are
    typical of any utility that generates code that tightly couples with user code.
    Initially, the tool can be used to create a large code base that can be quickly
    stood up and provide a large portion of the required functionality. However, as
    the project progresses, tweaks will be almost inevitable; it can become cumbersome
    keeping the custom user code separate from the auto-generated CubeMX code. You
    may find yourself in a copy-paste loop, continually copying pieces of working
    code from one peripheral to another. This is a practice that proliferates in our
    industry. Embedded firmware engineers desperately need to break out of the copy-paste
    infinite loop. [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml), *Tips
    for Creating Well-Abstracted Architecture*, covers what tradeoffs are being made
    when adopting these types of workflows. It also has some suggestions on how to
    set up your code base for long-term growth, rather than rot.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that being said, portions of code used in our examples will be implemented
    using STMCubeMX-generated code as a starting point. STM32 HAL is widely used in
    the industry, so anyone that has programmed STM32 before is likely to be familiar
    with it. Keep in mind that the example code in this book is meant to be easy to
    grasp. It is designed to highlight how to implement RTOS concepts, rather than
    serve as an extensible foundation for future additions. The primary intent of
    using code that is close to what STM32 CubeMX generates is to make it easier for
    you to start experimenting on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STM32CubeIDE needs to be installed and the source repository will need to be
    imported in order to compile and run the example code in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Installing STM32CubeIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install STM32CubeIDE, follow these two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download STM32CubeIDE from [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install it using the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that STM32CubeIDE is installed, we will need to import the source tree.
    Let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the source tree into STM32CubeIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After installing STM32CubeIDE, you''ll need to import the source tree into
    the Eclipse workspace. A workspace is the Eclipse term for a collection of related
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Since STM32CubeIDE is based on the Eclipse IDE, you'll find the following instructions
    familiar if you've used Eclipse in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download or clone the GitHub repository from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is best practice to keep the path to the repo short with no spaces; that
    is, `c:\projects`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The base git path used in the examples is `c:\projects\packBookRTOS`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open STM32CubeIDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the entire repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to Menu: File | Import.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select General | Existing Projects Into Workspace | Next.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Browse for and select the folder containing the repo, (`c:\projects\packBookRTOS `),
    which should look similar to the following after selection:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ed3ecc0-3ff3-4f3b-994a-e5229d63fae6.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Finish. The Next button is always gray.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, the Project Explorer panel will show all of the imported chapters
    (the following screenshot only shows code for [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml), *Selecting
    an IDE,* and [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml), *Debugging
    Tools for Real-Time Systems, *since they are the only examples currently written):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9bf3eb6-eab6-45f2-aca2-1ca290115d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To ensure everything is installed correctly, right-click on `Chapter5_6` and
    select Build. The output in the Console window should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13b8f7b8-ccb3-4ca9-b871-d7789e37775d.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You should now be able to build the FreeRTOS example projects
    included with this book!
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the Eclipse project doesn't include folders in exactly
    the same way that they are organized on the disk (that is, Drivers and Middleware
    aren't subfolders of Chapter5_6 on the filesystem). This is done deliberately
    to allow reuse of common code across projects/chapters. This concept is covered
    in more depth in [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml), Tips
    on Creating Well-Abstracted Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of an IDE and why you might choose
    to use one. A list of considerations was presented, along with categories of IDEs
    and suggestions for when it is best to use them. All of this material was put
    to use as we selected the IDE used in this book. Finally, we took a look at STMCubeMX
    and discussed how it can be used in different stages of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good understanding of the trade-offs to be made when designing a workflow
    (which includes choosing software tools) for your embedded system's code development
    will help you to make informed decisions, which can make a huge impact on productivity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue looking at tools for increasing productivity
    on FreeRTOS-based embedded firmware projects. The next set of tools allows you
    to actually *see* how your code is behaving in an extremely convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one IDE that is best for each MCU/language combination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paid IDEs are a must for professional-grade work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vendor-supplied IDEs are always the best IDEs to use for that vendor''s hardware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Software-generated code is always better than human-crafted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The IDE selected in this book was chosen because it has the best long-term
    availability and widest device compatibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three stages of development where STMCubeMX is helpful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STM32CubeIDE user guide can be found at[ https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf](https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
