<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor406"/><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor408"/><span class="koboSpan" id="kobo.2.1">Named Arguments, Method Chaining, and the Builder Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to examine a solution to a very common C++ problem: too many arguments. </span><span class="koboSpan" id="kobo.3.2">No, we are not talking about the arguments between C++ programmers, such as whether to put curly braces at the end of the line or the start of the next one (we have no solution to that problem). </span><span class="koboSpan" id="kobo.3.3">This is the problem of C++ functions with too many arguments. </span><span class="koboSpan" id="kobo.3.4">If you have maintained a large C++ system long enough, you have seen it—functions start with simple declarations and, over time, grow additional arguments, often defaulted, to support </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">new features.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What are the problems with long </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">function declarations?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the alternative?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">What are the downsides of using the named </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">arguments idiom?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How can the named arguments idiom </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">be generalized?</span></span></li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor409"/><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Here is the example </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">code: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Here is the Google Benchmark library: </span><a href="https://github.com/google/benchmark"><span class="koboSpan" id="kobo.21.1">https://github.com/google/benchmark</span></a><span class="koboSpan" id="kobo.22.1"> (see </span><a href="B19262_04.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Swap – From Simple to Subtle</span></em><span class="koboSpan" id="kobo.26.1">, for </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">installation instructions).</span></span></p>
<p><a id="_idTextAnchor411"/><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.28.1">The problem </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">with arguments</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Everyone who has worked on a sufficiently large C++ system at some point have had to add arguments </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.31.1">to a function. </span><span class="koboSpan" id="kobo.31.2">To avoid breaking the existing code, the new argument is often given a default value which usually retains the old functionality. </span><span class="koboSpan" id="kobo.31.3">That works great the first time, is OK the second time, and then one has to start counting arguments on every function call. </span><span class="koboSpan" id="kobo.31.4">There are other problems with long function declarations as well, and if we want a better solution, it is worth our time to understand what they are before trying to solve them. </span><span class="koboSpan" id="kobo.31.5">We begin this section with a more in-depth analysis of the problem before moving on to </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the solution</span><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.33.1">.</span></span><a id="_idTextAnchor414"/></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor415"/><span class="koboSpan" id="kobo.34.1">What’s wrong with many arguments?</span></h2>
<p><span class="koboSpan" id="kobo.35.1">Whether the code that passes around a lot of arguments was written this way from the start or has grown </span><em class="italic"><span class="koboSpan" id="kobo.36.1">organically</span></em><span class="koboSpan" id="kobo.37.1">, it is fragile and vulnerable to programmer mistakes. </span><span class="koboSpan" id="kobo.37.2">The main problem is that there are, usually, many arguments of the same type, and they can be miscounted. </span><span class="koboSpan" id="kobo.37.3">Consider designing a civilization-building game—when a player creates a new city, a corresponding object is constructed. </span><span class="koboSpan" id="kobo.37.4">The player gets to choose what facilities to build in the city, and the game sets the options for </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">available resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water,
       bool is_coastal,
       bool has_forest);
  ...
</span><span class="koboSpan" id="kobo.39.2">};</span></pre>
<p><span class="koboSpan" id="kobo.40.1">It looks like we have taken care of everything. </span><span class="koboSpan" id="kobo.40.2">To start the game, let’s give each player a city with a keep, a guard tower, two buildings, and a </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">guard company:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.42.1">
City Capital(2, 1, 1, City::KEEP,
             false, false, false, false);</span></pre>
<p><span class="koboSpan" id="kobo.43.1">Can you see the mistake? </span><span class="koboSpan" id="kobo.43.2">The compiler, fortunately, can—not enough arguments. </span><span class="koboSpan" id="kobo.43.3">Since the compiler won’t let us make a mistake here, this is no big deal, we just need to add the argument for </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">has_forest</span></strong><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Also, let’s say the game placed the city near a river, so it has </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">water now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
City Capital(2, 1, 1, City::KEEP,
             false, true, false, false, false);</span></pre>
<p><span class="koboSpan" id="kobo.48.1">That was easy ... </span><span class="koboSpan" id="kobo.48.2">Oops! </span><span class="koboSpan" id="kobo.48.3">We now have the city on the river but without fresh water (just what is in that river?). </span><span class="koboSpan" id="kobo.48.4">At least the townsfolk won’t starve, thanks to the free granary they accidentally received. </span><span class="koboSpan" id="kobo.48.5">That error—where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">true</span></strong><span class="koboSpan" id="kobo.50.1"> value was passed to the wrong parameter—will have </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.51.1">to be found during debugging. </span><span class="koboSpan" id="kobo.51.2">Also, this code is quite verbose, and we may find ourselves typing the same values over and over. </span><span class="koboSpan" id="kobo.51.3">Maybe the game tries to place cities near the rivers and forests by default? </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">OK then:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       enter_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true);
  ...
</span><span class="koboSpan" id="kobo.53.2">};</span></pre>
<p><span class="koboSpan" id="kobo.54.1">Now, let’s go back to our first attempt to create a city—it now compiles, one argument short, and we are none the wiser that we miscounted the arguments. </span><span class="koboSpan" id="kobo.54.2">The game is a great success, and, in the next update, we get an exciting new building—a temple! </span><span class="koboSpan" id="kobo.54.3">We need to add a new argument to the constructor, of course. </span><span class="koboSpan" id="kobo.54.4">It makes sense to add it after </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">with_granary</span></strong><span class="koboSpan" id="kobo.56.1">, with all the other buildings, and before the terrain features. </span><span class="koboSpan" id="kobo.56.2">But then we have to edit every call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">City</span></strong><span class="koboSpan" id="kobo.58.1"> constructor. </span><span class="koboSpan" id="kobo.58.2">What is worse, it is very easy to make a mistake since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">false</span></strong><span class="koboSpan" id="kobo.60.1"> for </span><em class="italic"><span class="koboSpan" id="kobo.61.1">no temple</span></em><span class="koboSpan" id="kobo.62.1"> looks, to both the programmer and the compiler, exactly like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">false</span></strong><span class="koboSpan" id="kobo.64.1"> for </span><em class="italic"><span class="koboSpan" id="kobo.65.1">no fresh water</span></em><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">The new argument has to be inserted in the right place, in a long line of very </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">similarly-looking values.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Of course, the existing </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.69.1">game code works without temples, so they are only needed in the new updated code. </span><span class="koboSpan" id="kobo.69.2">There is some value in not disturbing existing code unless necessary. </span><span class="koboSpan" id="kobo.69.3">We could do that if we added the new argument at the end and gave it the default value, so any constructor call that was not changed still creates the exact same city </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">as before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false);
  ...
</span><span class="koboSpan" id="kobo.71.2">};</span></pre>
<p><span class="koboSpan" id="kobo.72.1">But now, we let short-term convenience dictate our long-term interface design. </span><span class="koboSpan" id="kobo.72.2">The parameters no longer </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.73.1">have even a logical grouping, and in the long run, mistakes are even more likely. </span><span class="koboSpan" id="kobo.73.2">Also, we did not fully solve the problem of not updating the code that does not need to change—the next release adds a new terrain, desert, and with it, </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">another argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false,
       bool is_desert = false);
  ...
</span><span class="koboSpan" id="kobo.75.2">};</span></pre>
<p><span class="koboSpan" id="kobo.76.1">Once started, we have to give default values to all new arguments added at the end. </span><span class="koboSpan" id="kobo.76.2">Also, in order to create a city in the desert, we also have to specify whether it has a temple. </span><span class="koboSpan" id="kobo.76.3">There is no logical reason why it has to be this way, but we are bound by the process in which the interface evolved. </span><span class="koboSpan" id="kobo.76.4">The situation gets even worse when you consider that many types we used are convertible to </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">each other:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
City Capital(2, 1, false, City::KEEP,
             false, true, false, false, false);</span></pre>
<p><span class="koboSpan" id="kobo.79.1">This creates a city with zero guard companies and not whatever the programmer expected to disable </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.80.1">when they set the third argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">false</span></strong><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">Even </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">enum</span></strong><span class="koboSpan" id="kobo.84.1"> types do not offer full protection. </span><span class="koboSpan" id="kobo.84.2">You probably noticed that all new cities usually start as a keep, so it would make sense to have that as the default </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
// Example 01
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center = KEEP,
       bool with_forge = false,
       bool with_granary = false,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false,
       bool is_desert = false);
  ...
</span><span class="koboSpan" id="kobo.86.2">};</span></pre>
<p><span class="koboSpan" id="kobo.87.1">Now, we don’t have to type as many arguments and might even avoid some mistakes (if you don’t write arguments, you can’t write them in the wrong order). </span><span class="koboSpan" id="kobo.87.2">But, we can make </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">new ones:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
City Capital(2, 1, City::CITADEL);</span></pre>
<p><span class="koboSpan" id="kobo.90.1">The two guard companies we just hired (because the numerical value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">CITADEL</span></strong><span class="koboSpan" id="kobo.92.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">2</span></strong><span class="koboSpan" id="kobo.94.1">) will find themselves quite short on space in the lowly keep (which we intended to change but did not). </span><span class="koboSpan" id="kobo.94.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">enum class</span></strong><span class="koboSpan" id="kobo.96.1"> of C++11 offers better protection since each one is a different type </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.97.1">without conversions to integers, but the overall problem remains. </span><span class="koboSpan" id="kobo.97.2">As we have seen, there are two problems with passing a lot of values to C++ functions as separate arguments. </span><span class="koboSpan" id="kobo.97.3">First, it creates very long declarations and function calls that are error-prone. </span><span class="koboSpan" id="kobo.97.4">Second, if we need to add a value or change the type of a parameter, there is a lot of code to be edited. </span><span class="koboSpan" id="kobo.97.5">The solution to both problems existed even before C++ was created; it comes from C—use aggregates—that is, structs—to combine many values into </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">one para</span><a id="_idTextAnchor416"/><span class="koboSpan" id="kobo.99.1">m</span><a id="_idTextAnchor417"/><span class="koboSpan" id="kobo.100.1">eter.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor418"/><span class="koboSpan" id="kobo.101.1">Aggregate parameters</span></h2>
<p><span class="koboSpan" id="kobo.102.1">With aggregate parameters, we create a struct or a class that contains all the values, instead of adding </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.103.1">one parameter per value. </span><span class="koboSpan" id="kobo.103.2">We don’t have to be limited to one aggregate; for example, our city may take several structs, one for all terrain-related features that the game sets, and another for all features that the player </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">controls directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
struct city_features_t {
  size_t number_of_buildings = 1;
  size_t number_of_towers = 0;
  size_t guard_strength = 0;
  enum center_t { KEEP, PALACE, CITADEL };
  center_t center = KEEP;
  bool with_forge = false;
  bool with_granary = false;
  bool with_temple = false;
};
struct terrain_features_t {
  bool has_fresh_water = true;
  bool is_coastal = false;
  bool has_forest = true;
  bool is_desert = false;
};
class City {
  public:
  City(city_features_t city_features,
       terrain_features_t terrain_features);
  ...
</span><span class="koboSpan" id="kobo.105.2">};</span></pre>
<p><span class="koboSpan" id="kobo.106.1">This solution </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.107.1">has many advantages. </span><span class="koboSpan" id="kobo.107.2">First of all, assigning values to the arguments can be done explicitly, by name, and is very visible (and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">very verbose):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
city_features_t city_features;
city_features.number_of_buildings = 2;
city_features.center = city_features::KEEP;
...
</span><span class="koboSpan" id="kobo.109.2">terrain_features_t terrain_features;
terrain_features.has_fresh_water = true;
...
</span><span class="koboSpan" id="kobo.109.3">City Capital(city_features, terrain_features);</span></pre>
<p><span class="koboSpan" id="kobo.110.1">It is much easier to see what each argument’s value is, and mistakes are much less likely (the alternative, aggregate initialization of the structs, only moves the problem from one initialization to the other). </span><span class="koboSpan" id="kobo.110.2">If we need to add a new feature, most of the time we just have to add a new data member to one of the aggregate types. </span><span class="koboSpan" id="kobo.110.3">Only the code that actually deals with the new argument has to be updated; all the functions and classes that simply pass the arguments and forward them do not need to change at all. </span><span class="koboSpan" id="kobo.110.4">We can even give the aggregate types default values to provide default values for all arguments, as we have done in the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">last example.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">This is, overall, an excellent solution to the problem of functions with many parameters. </span><span class="koboSpan" id="kobo.112.2">However, it has one drawback: the aggregates have to be explicitly created and initialized, line by line. </span><span class="koboSpan" id="kobo.112.3">This works out fine for many cases, especially when these classes and structs </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.113.1">represent state variables that we are going to keep for a long time. </span><span class="koboSpan" id="kobo.113.2">But, when used purely as parameter containers, they create unnecessarily verbose code, starting from the fact that the aggregate variable must have a name. </span><span class="koboSpan" id="kobo.113.3">We don’t really need that name, as we are going to use it only once to call the function, but we have to make one up. </span><span class="koboSpan" id="kobo.113.4">It would be tempting just to use a </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">temporary variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
struct city_features_t {
  size_t number_of_buildings = 1;
  size_t number_of_towers = 0;
  size_t guard_strength = 0;
  enum center_t { KEEP, PALACE, CITADEL };
  center_t center = KEEP;
  bool with_forge = false;
  bool with_granary = false;
  bool with_temple = false;
};
struct terrain_features_t {
  bool has_fresh_water = true;
  bool is_coastal = false;
  bool has_forest = true;
  bool is_desert = false;
};
City Capital({2, 1, 0, KEEP, true, false, false},
             {true, false, false, true});</span></pre>
<p><span class="koboSpan" id="kobo.116.1">This works, but it brings us full circle, right to where we started; a function with a long list of easily mixed Boolean arguments. </span><span class="koboSpan" id="kobo.116.2">The fundamental problem we encounter is that C++ functions have positional arguments, and we are trying to come up with something that would let </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.117.1">us specify arguments by name. </span><span class="koboSpan" id="kobo.117.2">Aggregate objects resolve this problem mostly as a side effect, and if the overall design benefits from collecting a group of values into one class, you should certainly do it. </span><span class="koboSpan" id="kobo.117.3">However, as a solution specifically for the problem of named arguments, with no other, more permanent reason to group the values together, they fall short. </span><span class="koboSpan" id="kobo.117.4">We will now see how this deficiency can </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">be </span><a id="_idTextAnchor419"/><span class="koboSpan" id="kobo.119.1">a</span><a id="_idTextAnchor420"/><span class="koboSpan" id="kobo.120.1">ddressed.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor421"/><span class="koboSpan" id="kobo.121.1">Named arguments in C++</span></h1>
<p><span class="koboSpan" id="kobo.122.1">We have seen how collecting logically related values into aggregate objects gives us a side benefit; we can </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.123.1">pass these values to functions and access them by name instead of by their order in a long list. </span><span class="koboSpan" id="kobo.123.2">The key is </span><em class="italic"><span class="koboSpan" id="kobo.124.1">logically related</span></em><span class="koboSpan" id="kobo.125.1">, though; aggregating </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.126.1">values for no reason other than they happen to be used together in one function call creates unnecessary objects with names we would rather not have to invent. </span><span class="koboSpan" id="kobo.126.2">We need a way to create temporary aggregates, preferably without explicit names or declarations. </span><span class="koboSpan" id="kobo.126.3">We have a solution to this problem, and had it for a long time in C++; all it needs is a fresh look from a different perspective, which we are about </span><a id="_idTextAnchor422"/><span class="koboSpan" id="kobo.127.1">t</span><a id="_idTextAnchor423"/><span class="koboSpan" id="kobo.128.1">o </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">take now.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor424"/><span class="koboSpan" id="kobo.130.1">Method chaining</span></h2>
<p><span class="koboSpan" id="kobo.131.1">Method chaining </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.132.1">is a borrowed C++ technique; it </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.133.1">originates in </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Smalltalk</span></strong><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">Its </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.136.1">main purpose is to eliminate unnecessary local variables. </span><span class="koboSpan" id="kobo.136.2">You have used method chaining already, although you may not have realized it. </span><span class="koboSpan" id="kobo.136.3">Consider this code that you have probably written </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">many times:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
// Example 02
int i, j;
std::cout &lt;&lt; i &lt;&lt; j;</span></pre>
<p><span class="koboSpan" id="kobo.139.1">The last line invoked the inserter operator </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">&lt;&lt;</span></strong><span class="koboSpan" id="kobo.141.1"> twice. </span><span class="koboSpan" id="kobo.141.2">The first time it is invoked on the object on the left-hand side of the operator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">std::cout</span></strong><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">What object is the second call on? </span><span class="koboSpan" id="kobo.143.3">In general, the operator syntax is just a way to call a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">Usually, this particular operator is a non-member function, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">std::ostream</span></strong><span class="koboSpan" id="kobo.147.1"> class has several member function overloads as well, and one of them is for </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">int</span></strong><span class="koboSpan" id="kobo.149.1"> values. </span><span class="koboSpan" id="kobo.149.2">So, the last line really </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">
// Example 02-
std::cout.operator&lt;&lt;(i).operator&lt;&lt;(j);</span></pre>
<p><span class="koboSpan" id="kobo.152.1">The second </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.153.1">call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.155.1"> is done on </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.156.1">the result of the first one. </span><span class="koboSpan" id="kobo.156.2">The equivalent C++ code </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
// Example 02
auto&amp; out1 = std::cout.operator(i);
out1.operator&lt;&lt;(j);</span></pre>
<p><span class="koboSpan" id="kobo.159.1">This is the method chaining—the call to one method function returns the object on which the next method should be called. </span><span class="koboSpan" id="kobo.159.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">std::cout</span></strong><span class="koboSpan" id="kobo.161.1">, the member </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.163.1"> returns a reference to the object itself. </span><span class="koboSpan" id="kobo.163.2">By the way, the non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.165.1"> does the same, only instead of the implicit argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">this</span></strong><span class="koboSpan" id="kobo.167.1">, it has the stream object as an explicit first argument. </span><span class="koboSpan" id="kobo.167.2">Now, we can use method chaining to eliminate the explicitly named </span><a id="_idTextAnchor425"/><a id="_idTextAnchor426"/><span class="No-Break"><span class="koboSpan" id="kobo.168.1">argument object.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor427"/><span class="koboSpan" id="kobo.169.1">Method chaining and named arguments</span></h2>
<p><span class="koboSpan" id="kobo.170.1">As we have seen before, the aggregate argument objects work well when they are not used mainly </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.171.1">to hold arguments; if we need an object to hold the state </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.172.1">of the system, and we build it over time and keep it for a long time, we can also pass this object as a single argument to any function that needs this state. </span><span class="koboSpan" id="kobo.172.2">It’s creating aggregates for just one function call that we have a problem with. </span><span class="koboSpan" id="kobo.172.3">On the other hand, we do not like to write functions with many arguments either. </span><span class="koboSpan" id="kobo.172.4">This is particularly true for functions that usually have most arguments left as default, with only a few changes. </span><span class="koboSpan" id="kobo.172.5">Going back to our game, let’s say that each day, game time, is processed by a </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">function call.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">The function is called, once per game day, to advance the city through the day and process the consequences of various random events the game </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">can generate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
class City {
  ...
</span><span class="koboSpan" id="kobo.176.2">  void day(bool flood = false, bool fire = false,
    bool revolt = false, bool exotic_caravan = false,
    bool holy_vision = false, bool festival = false, ... </span><span class="koboSpan" id="kobo.176.3">);
  ...
</span><span class="koboSpan" id="kobo.176.4">};</span></pre>
<p><span class="koboSpan" id="kobo.177.1">A lot of </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.178.1">different events can happen over time, but rarely more than one happens on any particular day. </span><span class="koboSpan" id="kobo.178.2">We set all arguments to false by default, but this does </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.179.1">not really help; there is no particular order to these events, and if the festival happens, all the previous arguments must be specified even though they are still equal to their </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">default values.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">An aggregate object helps a lot, but we need to create and </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">name it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
class City {
  ...
</span><span class="koboSpan" id="kobo.183.2">  struct DayEvents {
    bool flood = false;
    bool fire = false;
    ...
</span><span class="koboSpan" id="kobo.183.3">  };
  void day(DayEvents events);
  ...
</span><span class="koboSpan" id="kobo.183.4">};
City capital(...);
City::DayEvents events;
events.fire = true;
capital.day(events);</span></pre>
<p><span class="koboSpan" id="kobo.184.1">We would </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.185.1">like to create a temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">DayEvents</span></strong><span class="koboSpan" id="kobo.187.1"> object just for the </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.188.1">call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">City::day()</span></strong><span class="koboSpan" id="kobo.190.1">, but we need a way to set its data members. </span><span class="koboSpan" id="kobo.190.2">This is where method chaining </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">comes in:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
// Example 03
class City {
  ...
</span><span class="koboSpan" id="kobo.192.2">  class DayEvents {
    friend City;
    bool flood = false;
    bool fire = false;
    public:
    DayEvents() = default;
    DayEvents&amp; SetFlood() { flood = true; return *this; }
    DayEvents&amp; SetFire() { fire = true; return *this; }
    ...
</span><span class="koboSpan" id="kobo.192.3">  };
  void day(DayEvents events);
  ...
</span><span class="koboSpan" id="kobo.192.4">};
City capital(...);
capital.day(City::DayEvents().SetFire());</span></pre>
<p><span class="koboSpan" id="kobo.193.1">The default constructor constructs an unnamed temporary object. </span><span class="koboSpan" id="kobo.193.2">On that object, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">SetFire()</span></strong><span class="koboSpan" id="kobo.195.1"> method. </span><span class="koboSpan" id="kobo.195.2">It modifies the object and returns a reference to itself. </span><span class="koboSpan" id="kobo.195.3">We pass the created and modified temporary object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">day()</span></strong><span class="koboSpan" id="kobo.197.1"> function, which processes the events of the day, displays the updated graphics of the city in flames, plays the sound of fire, and updates the status of the city to reflect that some buildings were damaged </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">by fire.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Since each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Set()</span></strong><span class="koboSpan" id="kobo.201.1"> methods return a reference to the same object, we can invoke more than one in a method chain, to specify multiple events. </span><span class="koboSpan" id="kobo.201.2">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Set()</span></strong><span class="koboSpan" id="kobo.203.1"> methods can take arguments, of course; for example, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">SetFire()</span></strong><span class="koboSpan" id="kobo.205.1"> that always changes the </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.206.1">fire event to </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">true</span></strong><span class="koboSpan" id="kobo.208.1"> from its default </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">false</span></strong><span class="koboSpan" id="kobo.210.1">, we could have </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.211.1">a method that can set the event flag </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">either way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
DayEvents&amp; SetFire(bool value = true) {
  fire = value;
  return *this;
}</span></pre>
<p><span class="koboSpan" id="kobo.214.1">Today is the market day in our city, which coincides with a major festival, so the king hired an extra guard company in addition to the two already stationed in </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the city:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
City capital(...);
capital.day(City::DayEvents().
</span><span class="koboSpan" id="kobo.216.2">            SetMarket().
</span><span class="koboSpan" id="kobo.216.3">            SetFestival().
</span><span class="koboSpan" id="kobo.216.4">            SetGuard(3));</span></pre>
<p><span class="koboSpan" id="kobo.217.1">Note that we did not have to specify anything for all the events that did not happen. </span><span class="koboSpan" id="kobo.217.2">We now have true named arguments; when we call a function, we pass the arguments in any order, by name, and we do not need to explicitly mention any arguments we wish to leave at their default values. </span><span class="koboSpan" id="kobo.217.3">This is the C++ named arguments idiom. </span><span class="koboSpan" id="kobo.217.4">A call with named arguments is, of course, more verbose than a call with positional arguments; each argument must have the name explicitly written. </span><span class="koboSpan" id="kobo.217.5">That was the point of the exercise. </span><span class="koboSpan" id="kobo.217.6">On the other hand, we come out ahead if there is a long list of default arguments we did not have to change. </span><span class="koboSpan" id="kobo.217.7">One question that could be asked is that of performance—we have a lot of extra function calls, the constructor, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Set()</span></strong><span class="koboSpan" id="kobo.219.1"> call for every named argument, and that must cost something. </span><span class="koboSpan" id="kobo.219.2">Let’s find o</span><a id="_idTextAnchor428"/><span class="koboSpan" id="kobo.220.1">u</span><a id="_idTextAnchor429"/><span class="koboSpan" id="kobo.221.1">t exactly what </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">it costs.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor430"/><span class="koboSpan" id="kobo.223.1">Performance of the named arguments idiom</span></h2>
<p><span class="koboSpan" id="kobo.224.1">There is definitely more going on with the named argument call, as more functions are called. </span><span class="koboSpan" id="kobo.224.2">On the </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.225.1">other hand, the function calls are really simple and, if they are defined in the header file, and the entire implementation is visible to the compiler, there is no reason for the compiler not to inline all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Set()</span></strong><span class="koboSpan" id="kobo.227.1"> calls and eliminate the unnecessary temporary variables. </span><span class="koboSpan" id="kobo.227.2">With good optimization, we could expect similar performance from the named arguments idiom and the explicitly named </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">aggregate object.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">The appropriate tool to measure the performance of a single function call is the micro benchmark. </span><span class="koboSpan" id="kobo.229.2">We use the Google microbenchmark library for this purpose. </span><span class="koboSpan" id="kobo.229.3">While the benchmarks are usually written in one file, we need another source file if we want the function we call to be external, not inlined. </span><span class="koboSpan" id="kobo.229.4">On the other hand, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Set()</span></strong><span class="koboSpan" id="kobo.231.1"> methods should definitely be inlined, so they should be defined in the header file. </span><span class="koboSpan" id="kobo.231.2">The second source file should contain the definition of the function we are calling with named or positional arguments. </span><span class="koboSpan" id="kobo.231.3">Both files are combined at </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">link time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
$CXX named_args.C named_args_extra.C -g -O4 -I. </span><span class="koboSpan" id="kobo.233.2">\
  -Wall -Wextra -Werror -pedantic --std=c++14 \
  -I$GBENCH_DIR/include $GBENCH_DIR/lib/libbenchmark.a \
  -lpthread -lrt -lm -o named_args</span></pre>
<p><span class="koboSpan" id="kobo.234.1">We can compare the positional arguments, the named arguments, and the arguments aggregate. </span><span class="koboSpan" id="kobo.234.2">The result will depend on the type and number of arguments. </span><span class="koboSpan" id="kobo.234.3">For example, for a function with four Boolean arguments, we can compare </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">these calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
// Example 04
// Positional arguments:
Positional p(true, false, true, false);
// Named arguments idiom:
Named n(Named::Options().SetA(true).SetC(true));
// Aggregate object:
Aggregate::Options options;
options.a = true;
options.c = true;
Aggregate a(options));</span></pre>
<p><span class="koboSpan" id="kobo.237.1">The performance measured by the benchmark will depend greatly on the compiler and on the options that control optimization. </span><span class="koboSpan" id="kobo.237.2">For example, these numbers were collected on GCC12 </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">with -O3:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
Benchmark                 Time  UserCounters...
</span><span class="koboSpan" id="kobo.239.2">BM_positional_const   0.233 ns  items_per_second=138.898G/s
BM_named_const        0.238 ns  items_per_second=134.969G/s
BM_aggregate_const    0.239 ns  items_per_second=135.323G/s</span></pre>
<p><span class="koboSpan" id="kobo.240.1">There is no noticeable performance hit for the explicitly named aggregate object that the compiler </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.241.1">was able to inline and optimize away. </span><span class="koboSpan" id="kobo.241.2">The named and positional arguments perform similarly. </span><span class="koboSpan" id="kobo.241.3">Note that the performance of the function calls depends greatly on what else is going on in the program at the same time, since the arguments are passed on registers, and register availability is affected by </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">the context.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">In our benchmark, we have used compile-time constants as argument values. </span><span class="koboSpan" id="kobo.243.2">This is not uncommon, especially for arguments that specify certain options—very often, at each call site, many of the options will be static, unchanging (the values are different in other places in the code where the same function is called, but on this line, many of the values are fixed at compile time). </span><span class="koboSpan" id="kobo.243.3">For example, if we have a special code branch to process natural disasters in our game, the ordinary branch will always call our day simulation with a flood, fire, and other disaster flags set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">false</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">But, just as often the arguments are computed at runtime. </span><span class="koboSpan" id="kobo.245.3">How does this affect the performance? </span><span class="koboSpan" id="kobo.245.4">Let’s create another benchmark where the values of the arguments are retrieved, for example, from </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">a vector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
// Example 04
std::vector&lt;int&gt; v; // Fill v with random values
size_t i = 0;
// ... </span><span class="koboSpan" id="kobo.247.2">Benchmark loop ...
</span><span class="koboSpan" id="kobo.247.3">const bool a = v[i++];
const bool b = v[i++];
const bool c = v[i++];
const bool d = v[i++];
if (i == v.size()) i = 0; // Assume v.size() % 4 == 0
Positional p(a, b, c, d); // Positional arguments
Named n(Named::Options().
</span><span class="koboSpan" id="kobo.247.4">  SetA(a).SetC(b).SetC(c).SetD(d)); // Named arguments
Aggregate::Options options;
options.a = a;
options.b = b;
options.c = c;
options.d = d;
Aggregate a(options)); // Aggregate object</span></pre>
<p><span class="koboSpan" id="kobo.248.1">By the way, it would </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.249.1">be ill-advised to shorten the preceding code in </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">this manner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
Positional p(v[i++], v[i++], v[i++], v[i++]);</span></pre>
<p><span class="koboSpan" id="kobo.252.1">The reason is that the order in which the arguments are evaluated is undefined, so it is arbitrary which of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">i++</span></strong><span class="koboSpan" id="kobo.254.1"> calls is executed first. </span><span class="koboSpan" id="kobo.254.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">i</span></strong><span class="koboSpan" id="kobo.256.1"> starts from </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">0</span></strong><span class="koboSpan" id="kobo.258.1">, this call may end up calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Positional(v[0], v[1], v[2], v[3])</span></strong><span class="koboSpan" id="kobo.260.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Positional(v[3], v[2], v[1], v[0])</span></strong><span class="koboSpan" id="kobo.262.1"> or any </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">other permutation.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">On the same compiler and hardware, we now get </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">different numbers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
Benchmark                 Time  UserCounters...
</span><span class="koboSpan" id="kobo.266.2">BM_positional_vars     50.8 ns  items_per_second=630.389M/s
BM_named_vars          49.4 ns  items_per_second=647.577M/s
BM_aggregate_vars      45.8 ns  items_per_second=647.349M/s</span></pre>
<p><span class="koboSpan" id="kobo.267.1">We can see from the results that the compiler completely eliminated the overhead of the unnamed temporary object (or the named aggregate) and generated similarly performing code for all three ways to pass arguments into the function. </span><span class="koboSpan" id="kobo.267.2">In general, the result of the compiler optimizations is difficult to predict. </span><span class="koboSpan" id="kobo.267.3">For example, CLANG produces significantly different results (named argument calls are faster when most parameters are compile-time constants but slower when they are </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">run-time values).</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The benchmark </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.270.1">does not favor any particular argument-passing mechanism. </span><span class="koboSpan" id="kobo.270.2">We can say that the named arguments idiom performs no worse than an explicitly named aggregate object or the equivalent positional parameters, at least, if the compiler were able to eliminate the unnamed temporary especially. </span><span class="koboSpan" id="kobo.270.3">On some compilers, the named arguments may be faster if the function has many arguments. </span><span class="koboSpan" id="kobo.270.4">If the optimization does not happen, the call may be a bit slower. </span><span class="koboSpan" id="kobo.270.5">On the other hand, in many cases the performance of the function call itself is not critical; for example, our cities are constructed only when the player builds one, a few times during the game. </span><span class="koboSpan" id="kobo.270.6">The day events are processed once per game day, which probably takes more than a few seconds of real-time, not least so the player can enjoy interacting with the game. </span><span class="koboSpan" id="kobo.270.7">On the other hand, the functions that are repeatedly called in performance-critical code should be inlined whenever possible, and we can expect better optimizations for argument passing in this case as well. </span><span class="koboSpan" id="kobo.270.8">Overall, we can conclude that, unless the performance of the particular function call is critical for program performance, one should not be concerned with the overhead of named arguments. </span><span class="koboSpan" id="kobo.270.9">For performance-critical calls, performance should be measured on a case-by-case basis, and it is possible for named arguments to be </span><a id="_idTextAnchor431"/><a id="_idTextAnchor432"/><span class="koboSpan" id="kobo.271.1">faster than </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">positional ones.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor433"/><span class="koboSpan" id="kobo.273.1">General method chaining</span></h1>
<p><span class="koboSpan" id="kobo.274.1">Applications of </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.275.1">method chaining in C++ are not limited to argument passing (we have already seen another application, although a well-hidden one, in the form of streaming I/O). </span><span class="koboSpan" id="kobo.275.2">For use in other contexts, it is helpful to consider some more gene</span><a id="_idTextAnchor434"/><a id="_idTextAnchor435"/><span class="koboSpan" id="kobo.276.1">ral forms of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">method chaining.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor436"/><span class="koboSpan" id="kobo.278.1">Method chaining versus method cascading</span></h2>
<p><span class="koboSpan" id="kobo.279.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.280.1">method cascading</span></em><span class="koboSpan" id="kobo.281.1"> is not often </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.282.1">found in the context of C++, and for a good reason—C++ does not really support it. </span><span class="koboSpan" id="kobo.282.2">Method cascading refers to calling </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.283.1">a sequence of methods on the </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.284.1">same object. </span><span class="koboSpan" id="kobo.284.2">For example, in </span><em class="italic"><span class="koboSpan" id="kobo.285.1">Dart</span></em><span class="koboSpan" id="kobo.286.1">, where method cascading is supported explicitly, we can write </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
var opt = Options();
opt.SetA()..SetB();</span></pre>
<p><span class="koboSpan" id="kobo.289.1">This code first calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">SetA()</span></strong><span class="koboSpan" id="kobo.291.1"> on the opt object, then calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">SetB()</span></strong><span class="koboSpan" id="kobo.293.1"> on the same object. </span><span class="koboSpan" id="kobo.293.2">The equivalent code </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
var opt = Options();
opt.SetA()
opt.SetB();</span></pre>
<p><span class="koboSpan" id="kobo.296.1">But wait, did we not just do the same with C++ and our options object? </span><span class="koboSpan" id="kobo.296.2">We did, but we skimmed over an important difference. </span><span class="koboSpan" id="kobo.296.3">In method chaining, the next method is applied to the result of the previous one. </span><span class="koboSpan" id="kobo.296.4">This is a chained call </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">in C++:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
Options opt;
opt.SetA().SetB();</span></pre>
<p><span class="koboSpan" id="kobo.299.1">This chained call is equivalent to the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
Options opt;
Options&amp; opt1 = opt.SetA();
Options&amp; opt2 = opt1.SetB();</span></pre>
<p><span class="koboSpan" id="kobo.302.1">C++ does not have the cascading syntax, but the code equivalent to a cascade would </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">be this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
Options opt;
opt.SetA();
opt.SetB();</span></pre>
<p><span class="koboSpan" id="kobo.305.1">But this is exactly what we did earlier, and the short form was </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
Options opt;
opt.SetA().SetB();</span></pre>
<p><span class="koboSpan" id="kobo.308.1">What makes the C++ cascading possible in this case is that the methods return the reference to the same object. </span><span class="koboSpan" id="kobo.308.2">We can still say that the equivalent code </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
Options opt;
Options&amp; opt1 = opt.SetA();
Options&amp; opt2 = opt1.SetB();</span></pre>
<p><span class="koboSpan" id="kobo.311.1">And, it’s </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.312.1">technically true. </span><span class="koboSpan" id="kobo.312.2">But, because of the </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.313.1">way the methods are written, we have the additional guarantee that </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">opt</span></strong><span class="koboSpan" id="kobo.315.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">opt1</span></strong><span class="koboSpan" id="kobo.317.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">opt2</span></strong><span class="koboSpan" id="kobo.319.1"> all refer to the same object. </span><span class="koboSpan" id="kobo.319.2">Method cascading can always be implemented through method chaining, but it restricts the interfaces because all calls must return a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">this</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">This implementation </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.322.1">technique is sometimes called by the somewhat unwieldy name </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">cascading-by-chaining by returning self</span></strong><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">The method chaining, in general, is not restricted to return </span><em class="italic"><span class="koboSpan" id="kobo.325.1">self,</span></em><span class="koboSpan" id="kobo.326.1"> or the reference to the object itself (</span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">*this</span></strong><span class="koboSpan" id="kobo.328.1"> in C++). </span><span class="koboSpan" id="kobo.328.2">What can be accomplished wit</span><a id="_idTextAnchor437"/><a id="_idTextAnchor438"/><span class="koboSpan" id="kobo.329.1">h more general chaining? </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">Let’s see.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor439"/><span class="koboSpan" id="kobo.331.1">General method chaining</span></h2>
<p><span class="koboSpan" id="kobo.332.1">If the chained method does not return a reference to the object itself, it should return a new object. </span><span class="koboSpan" id="kobo.332.2">Usually, this object is of the same type, or at least a type from the same class hierarchy, if the </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.333.1">methods are polymorphic. </span><span class="koboSpan" id="kobo.333.2">For example, let’s consider a class that implements data collection. </span><span class="koboSpan" id="kobo.333.3">It has a method to filter the data using a predicate (a callable object, an object with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">operator()</span></strong><span class="koboSpan" id="kobo.335.1"> that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">true</span></strong><span class="koboSpan" id="kobo.337.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">false</span></strong><span class="koboSpan" id="kobo.339.1">). </span><span class="koboSpan" id="kobo.339.2">It also has a method to sort the collection. </span><span class="koboSpan" id="kobo.339.3">Each of these methods creates a new collection object and leaves the original object intact. </span><span class="koboSpan" id="kobo.339.4">Now, if we want to filter all valid data in our collection, and assuming that we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">is_valid</span></strong><span class="koboSpan" id="kobo.341.1"> predicate object, we can create a sorted collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">valid data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
Collection c;
... </span><span class="koboSpan" id="kobo.343.2">store data in the collection ...
</span><span class="koboSpan" id="kobo.343.3">Collection valid_c = c.filter(is_valid);
Collection sorted_valid_c = valid_c.sort();</span></pre>
<p><span class="koboSpan" id="kobo.344.1">The intermediate object can be eliminated using </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">method chaining:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
Collection c;
...
</span><span class="koboSpan" id="kobo.346.2">Collection sorted_valid_c = c.filter(is_valid).sort();</span></pre>
<p><span class="koboSpan" id="kobo.347.1">It should be clear after reading the last section that this is an example of method chaining, and a </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.348.1">more general one than what we saw earlier—each method returns an object of the same type, but not the same object. </span><span class="koboSpan" id="kobo.348.2">The difference between chaining and cascading is very clear in this example—a cascade of methods would filter and sort the original collection (assuming we</span><a id="_idTextAnchor440"/><a id="_idTextAnchor441"/><span class="koboSpan" id="kobo.349.1"> decided to support </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">such operations).</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor442"/><span class="koboSpan" id="kobo.351.1">Method chaining in class hierarchies</span></h2>
<p><span class="koboSpan" id="kobo.352.1">When applied </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.353.1">to class hierarchies, method chaining </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.354.1">runs into a particular problem; let’s say that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">sort()</span></strong><span class="koboSpan" id="kobo.356.1"> method returns a sorted data collection that is an object of a different type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.358.1"> , which is derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Collection</span></strong><span class="koboSpan" id="kobo.360.1"> class. </span><span class="koboSpan" id="kobo.360.2">The reason it is a derived class is that after sorting we can support efficient search, and so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.362.1"> class has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">search()</span></strong><span class="koboSpan" id="kobo.364.1"> method that the base class does not have. </span><span class="koboSpan" id="kobo.364.2">We can still use method chaining, and even call the base class methods on the derived class, but doing so breaks </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the chain:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
// Example 05
class SortedCollection;
class Collection {
  public:
  Collection filter();
  // sort() converts Collection to SortedCollection.
</span><span class="koboSpan" id="kobo.366.2">  SortedCollection sort();
};
class SortedCollection : public Collection {
  public:
  SortedCollection search();
  SortedCollection median();
};
SortedCollection Collection::sort() {
  SortedCollection sc;
  ... </span><span class="koboSpan" id="kobo.366.3">sort the collection ...
</span><span class="koboSpan" id="kobo.366.4">  return sc;
}
Collection c;
auto c1 = c.sort().search().filter.median();</span></pre>
<p><span class="koboSpan" id="kobo.367.1">In this example, the chaining </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.368.1">worked for a while: we were </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.369.1">able to sort a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Collection</span></strong><span class="koboSpan" id="kobo.371.1">, search the result, and filter the result of the search. </span><span class="koboSpan" id="kobo.371.2">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">sort()</span></strong><span class="koboSpan" id="kobo.373.1"> operates on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Collection</span></strong><span class="koboSpan" id="kobo.375.1"> and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.377.1">. </span><span class="koboSpan" id="kobo.377.2">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">search()</span></strong><span class="koboSpan" id="kobo.379.1"> needs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.381.1">, so it works as intended. </span><span class="koboSpan" id="kobo.381.2">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">filter()</span></strong><span class="koboSpan" id="kobo.383.1"> needs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Collection</span></strong><span class="koboSpan" id="kobo.385.1">; the method can be invoked on a derived class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.387.1">, but the return result is still going to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Collection</span></strong><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">Then the chain breaks: the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">median()</span></strong><span class="koboSpan" id="kobo.391.1"> needs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.393.1">, which we have, except </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">filter()</span></strong><span class="koboSpan" id="kobo.395.1"> effectively cast it back to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Collection</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">There is no way to tell median() that the object is really a </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.399.1"> (other </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">than casting).</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">Polymorphism, or virtual functions, does not help here; first of all, we would need to define virtual functions for </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">search()</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">median()</span></strong><span class="koboSpan" id="kobo.405.1"> in the base class, even though we don’t intend to support this functionality there, as only the derived class supports them. </span><span class="koboSpan" id="kobo.405.2">We cannot declare them pure virtual because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Collection</span></strong><span class="koboSpan" id="kobo.407.1"> as a concrete class, and any class with a pure virtual function is an abstract class, so objects of this class cannot be instantiated. </span><span class="koboSpan" id="kobo.407.2">We can make these functions abort at runtime, but at the very least we have moved the detection of a programming error—searching in an unsorted collection—from compile time to runtime. </span><span class="koboSpan" id="kobo.407.3">Worse, it does not </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">even help:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
class SortedCollection;
class Collection {
  public:
  Collection filter();
  // Converts Collection to SortedCollection
  SortedCollection sort();
  virtual SortedCollection median();
};
class SortedCollection : public Collection {
  public:
  SortedCollection search();
  SortedCollection median() override;
};
SortedCollection Collection::sort() {
  SortedCollection sc;
  ... </span><span class="koboSpan" id="kobo.409.2">sort the collection ...
</span><span class="koboSpan" id="kobo.409.3">  return sc;
}
SortedCollection Collection::median() {
  cout &lt;&lt; "Collection::median called!!!" </span><span class="koboSpan" id="kobo.409.4">&lt;&lt; endl;
  abort();
  return {};     // Still need to return something
}
Collection c;
auto c1 = c.sort().search().filter().median();</span></pre>
<p><span class="koboSpan" id="kobo.410.1">This is not going to work because </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Collection::filter</span></strong><span class="koboSpan" id="kobo.412.1"> returns a copy of the object, not a reference to it. </span><span class="koboSpan" id="kobo.412.2">The object it returns is the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Collection</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">If called on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.416.1"> object, it rips out the base class portion from the derived object and returns that. </span><span class="koboSpan" id="kobo.416.2">If you think that making </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">filter()</span></strong><span class="koboSpan" id="kobo.418.1"> virtual as well, and overriding it in the derived class, solves this problem at the expense of overriding every function in the base class, you have another surprise coming—virtual functions must have identical return types, except for </span><em class="italic"><span class="koboSpan" id="kobo.419.1">covariant return types</span></em><span class="koboSpan" id="kobo.420.1">. </span><span class="koboSpan" id="kobo.420.2">References to the base and derived classes are covariant return types. </span><span class="koboSpan" id="kobo.420.3">Classes themselves, returned by value, </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">are not.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Note that this </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.423.1">problem would not have happened if we were returning object references. </span><span class="koboSpan" id="kobo.423.2">However, we can only return references to </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.424.1">the object we are called on; if we create a new object in the body of a method function and return a reference to it, it’s a dangling reference to a temporary object that is deleted the moment the function returns. </span><span class="koboSpan" id="kobo.424.2">The result is undefined behavior (the program is likely to crash). </span><span class="koboSpan" id="kobo.424.3">On the other hand, if we always return the reference to the original object, we cannot change its type from based to derived in the </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">first place.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">The C++ solution to this problem involves the use of templates and a curious design pattern. </span><span class="koboSpan" id="kobo.426.2">In fact, it is so mind-twisting that the word </span><em class="italic"><span class="koboSpan" id="kobo.427.1">curious</span></em><span class="koboSpan" id="kobo.428.1"> is even in its name—the Curiously Recurring Template Pattern. </span><span class="koboSpan" id="kobo.428.2">We have a whole chapter on the CRTP pattern in this book. </span><span class="koboSpan" id="kobo.428.3">The application of the pattern to our case is relatively straightforward—the base class needs to return the right type from its functions, but can’t because it does not know what the type is. </span><span class="koboSpan" id="kobo.428.4">The solution—pass the right type into the base class as the template argument. </span><span class="koboSpan" id="kobo.428.5">Of course, the base class would have to be a base class template for this </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">to work:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
template &lt;typename T&gt; class Collection {
  public:
  Collection() {}
  T filter(); // "*this" is really a T, not a Collection
  T sort() {
    T sc; // Create new sorted collection
    ...
</span><span class="koboSpan" id="kobo.430.2">    return sc;
  }
};
class SortedCollection :
  public Collection&lt;SortedCollection&gt; {
  public:
  SortedCollection search();
  SortedCollection median();
};
Collection&lt;SortedCollection&gt; c;
auto c1 = c.sort().search().filter().median();</span></pre>
<p><span class="koboSpan" id="kobo.431.1">The chain here </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.432.1">starts similarly to our initial example: </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">sort()</span></strong><span class="koboSpan" id="kobo.434.1"> is invoked on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Collection</span></strong><span class="koboSpan" id="kobo.436.1"> and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.438.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">search()</span></strong><span class="koboSpan" id="kobo.440.1"> applies </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.441.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.443.1"> and returns another </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.445.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">filter()</span></strong><span class="koboSpan" id="kobo.447.1"> is called. </span><span class="koboSpan" id="kobo.447.2">This time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">filter()</span></strong><span class="koboSpan" id="kobo.449.1"> from the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Collection</span></strong><span class="koboSpan" id="kobo.451.1"> knows what the real type of the object is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Collection</span></strong><span class="koboSpan" id="kobo.453.1"> itself is a template instantiated on the type of the derived object. </span><span class="koboSpan" id="kobo.453.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">filter()</span></strong><span class="koboSpan" id="kobo.455.1"> works on any collection but returns an object of the same type as the initial collection – in our case, both are </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.457.1"> objects. </span><span class="koboSpan" id="kobo.457.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">median()</span></strong><span class="koboSpan" id="kobo.459.1"> needs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">SortedCollection</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">gets it.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">This is a complex solution. </span><span class="koboSpan" id="kobo.463.2">While it works, its complexity suggests that method chaining should be used judiciously when the object type has to change in the middle of the chain. </span><span class="koboSpan" id="kobo.463.3">There is a good reason for that—changing the object type is fundamentally different than calling a sequence of methods. </span><span class="koboSpan" id="kobo.463.4">It is a more significant event that perhaps should be made explicit, and the new object should get its </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">own name.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Now that we know what method chaining is, let us see where else it can </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">be useful.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor443"/><span class="koboSpan" id="kobo.467.1">The Builder pattern</span></h1>
<p><span class="koboSpan" id="kobo.468.1">Let us go almost all the way back to the start of the chapter and take another look at the way we pass </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.469.1">named arguments to a C++ function. </span><span class="koboSpan" id="kobo.469.2">Instead of a constructor with many arguments, we settled on an options object where each argument is </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">explicitly named:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
City GreensDale(City::Options()
  .SetCenter(City::KEEP)
  .SetBuildings(3)
  .SetGuard(1)
  .SetForge()
);</span></pre>
<p><span class="koboSpan" id="kobo.472.1">Let us now focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Options</span></strong><span class="koboSpan" id="kobo.474.1"> object itself, specifically, the way we construct it. </span><span class="koboSpan" id="kobo.474.2">The constructor does not create a finished object (that would just move the problem from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">City</span></strong><span class="koboSpan" id="kobo.476.1"> constructor to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Options</span></strong><span class="koboSpan" id="kobo.478.1"> constructor). </span><span class="koboSpan" id="kobo.478.2">Instead, we build the object piece by piece. </span><span class="koboSpan" id="kobo.478.3">This is a particular case of a very general design pattern – </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">the Builder.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor444"/><span class="koboSpan" id="kobo.480.1">Basics of the Builder pattern</span></h2>
<p><span class="koboSpan" id="kobo.481.1">The Builder design pattern is used whenever we decide that an object cannot be constructed in </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.482.1">what we consider a complete state by the constructor alone. </span><span class="koboSpan" id="kobo.482.2">Instead, we write a helper class, or builder class, that builds these objects and hands them out to </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the program.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">The first question you might ask is “Why?” </span><span class="koboSpan" id="kobo.484.2">– isn’t the constructor supposed to do exactly that job? </span><span class="koboSpan" id="kobo.484.3">There could be several reasons. </span><span class="koboSpan" id="kobo.484.4">One very common reason is that we use a more general object to represent some more specific data set. </span><span class="koboSpan" id="kobo.484.5">For example, we want an object that holds Fibonacci numbers or prime numbers, and we decided to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">std::vector</span></strong><span class="koboSpan" id="kobo.486.1"> to store them. </span><span class="koboSpan" id="kobo.486.2">Now we have a problem: the vector has whatever constructors the STL provides, but we need to ensure that our vector has the right numbers in it, and we can’t write a new constructor. </span><span class="koboSpan" id="kobo.486.3">We could create a special class to hold only prime numbers, but we will end up with a lot of classes that, after being constructed differently, are used in very similar ways. </span><span class="koboSpan" id="kobo.486.4">We would have to write new code to process prime numbers, odd numbers, square numbers, etc when using a vector for all of them would be perfectly sufficient. </span><span class="koboSpan" id="kobo.486.5">Alternatively, we could just use vectors everywhere and write the right values into them whenever our program needs it. </span><span class="koboSpan" id="kobo.486.6">This is no good too: we expose and duplicate a lot of low-level code that we would like to encapsulate and reuse (which is why we wanted a constructor for each kind </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">of number).</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The solution is the Builder pattern: the code for computing and storing the numbers is encapsulated in </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.489.1">a builder class, but the object created by the builder is a generic vector. </span><span class="koboSpan" id="kobo.489.2">For example, here is a builder for Fibonacci numbers (the sequence of numbers that starts with 1, 1, and every subsequent number is a sum of the last </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">two numbers):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
// Example 08
class FibonacciBuilder {
  using V = std::vector&lt;unsigned long&gt;;
  V cache_ { 1, 1, 2, 3, 5 };
  public:
  V operator()(size_t n) {
    while (cache_.size() &lt; n) {     // Cache new numbers
      cache_.push_back(cache_[cache_.size() - 1] +
                       cache_[cache_.size() - 2]);
    }
    return V{cache_.begin(), cache_.begin() + n};
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.492.1">Suppose our program needs to get sequences of the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">n</span></strong><span class="koboSpan" id="kobo.494.1"> Fibonacci numbers for some algorithm (the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">n</span></strong><span class="koboSpan" id="kobo.496.1"> varies at run time). </span><span class="koboSpan" id="kobo.496.2">We may need these numbers more than once, sometimes for larger values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">n</span></strong><span class="koboSpan" id="kobo.498.1"> than before and sometimes for smaller ones. </span><span class="koboSpan" id="kobo.498.2">All we need to do is to ask </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the builder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
FibonacciBuilder b;
auto fib10 = b(10);</span></pre>
<p><span class="koboSpan" id="kobo.501.1">We could keep the already known values somewhere in the program, but that complicates the program with the additional job of tracking them. </span><span class="koboSpan" id="kobo.501.2">It is better to move that work to a class dedicated to constructing Fibonacci numbers and nothing else - a builder. </span><span class="koboSpan" id="kobo.501.3">Is it worth it to cache Fibonacci numbers? </span><span class="koboSpan" id="kobo.501.4">Probably not really, but remember that this is a concise example: if we needed, say, prime numbers instead, reusing already known values would be very much worth it (but the code would be </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">much longer).</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">The other common </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.504.1">reason to use the builder is that the code necessary to build an object may be too complex for a constructor. </span><span class="koboSpan" id="kobo.504.2">Often, it manifests itself in the large number of arguments we would have to pass to a constructor if we tried to write one. </span><span class="koboSpan" id="kobo.504.3">The way we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Options</span></strong><span class="koboSpan" id="kobo.506.1"> argument for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">City</span></strong><span class="koboSpan" id="kobo.508.1"> at the start of this section is a trivial example of that, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Options</span></strong><span class="koboSpan" id="kobo.510.1"> object acting as its own builder. </span><span class="koboSpan" id="kobo.510.2">Particular situations where builders are most useful include cases where the construction process is conditional and the data needed to fully construct an object varies in both the number and the type depending on some run-time variables. </span><span class="koboSpan" id="kobo.510.3">Again, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">City</span></strong><span class="koboSpan" id="kobo.512.1"> is a trivial example of that: no single </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">City</span></strong><span class="koboSpan" id="kobo.514.1"> needs every constructor argument, but without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Options</span></strong><span class="koboSpan" id="kobo.516.1"> and its (trivial) builder, we would have to provide a parameter for every one </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">The approach we have seen for our Fibonacci vector builder is a common variant of the Builder pattern in C++; it’s not very exciting but it works. </span><span class="koboSpan" id="kobo.518.2">In this chapter, we are going to see some alternative ways to implement a Builder. </span><span class="koboSpan" id="kobo.518.3">The first one generalizes the way we built </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor445"/><span class="koboSpan" id="kobo.522.1">The fluent Builder</span></h2>
<p><span class="koboSpan" id="kobo.523.1">The way we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Options</span></strong><span class="koboSpan" id="kobo.525.1"> object is through method chaining. </span><span class="koboSpan" id="kobo.525.2">Each method takes a small step </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.526.1">toward constructing the final object. </span><span class="koboSpan" id="kobo.526.2">There is a general </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.527.1">name for this approach: the fluent interface. </span><span class="koboSpan" id="kobo.527.2">While it is not limited to designing builders, the fluent interface became popular in C++ mostly as a way to build </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">complex objects.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">The fluent builder relies on method chaining: each member function of the builder class contributes to constructing the object that is being built and returns the builder itself, so the work can continue. </span><span class="koboSpan" id="kobo.529.2">For example, here is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">Employee</span></strong><span class="koboSpan" id="kobo.531.1"> class (possibly for some </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">workplace database):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
// Example 09
class Employee {
  std::string prefix_;
  std::string first_name_;
  std::string middle_name_;
  std::string last_name_;
  std::string suffix_;
  friend class EmployeeBuilder;
  Employee() = default;
  public:
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const Employee&amp; e);
};</span></pre>
<p><span class="koboSpan" id="kobo.534.1">We are going to </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.535.1">add even more data to the class later, but already it has enough </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.536.1">data members to make a single constructor hard to use (too many arguments of the same type). </span><span class="koboSpan" id="kobo.536.2">We could use a constructor with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Options</span></strong><span class="koboSpan" id="kobo.538.1"> object, but, going forward, we expect the need to do some computations during the construction of the object: we may need to validate certain data, and other parts of the employee record may be conditional: two fields that cannot be set at the same time, a field whose default value depends on other fields, etc. </span><span class="koboSpan" id="kobo.538.2">So let’s start designing a builder for </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">this class.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">EmployeeBuilder</span></strong><span class="koboSpan" id="kobo.542.1"> needs to construct an </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Employee</span></strong><span class="koboSpan" id="kobo.544.1"> object first, then provide several chained methods to set different fields of the object, and, finally, hand over the constructed object. </span><span class="koboSpan" id="kobo.544.2">There may be some error checking involved, or more complex operations affecting other multiple fields, but a basic builder looks </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
// Example 09
class EmployeeBuilder {
  Employee e_;
  public:
  EmployeeBuilder&amp; SetPrefix(std::string_view s) {
    e_.prefix_ = s; return *this;
  }
  EmployeeBuilder&amp; SetFirstName(std::string_view s) {
    e_.first_name_ = s ; return *this;
  }
  EmployeeBuilder&amp; SetMiddleName(std::string_view s) {
    e_.middle_name_ = s; return *this;
  }
  EmployeeBuilder&amp; SetLastName(std::string_view s) {
    e_.last_name_ = s; return *this;
  }
  EmployeeBuilder&amp; SetSuffix(std::string_view s) {
    e_.suffix_ = s; return *this;
  }
  operator Employee() {
    assert(!e_.first_name_.empty() &amp;&amp;
           !e_.last_name_.empty());
    return std::move(e_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.547.1">Several design </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.548.1">decisions had to be made along the way. </span><span class="koboSpan" id="kobo.548.2">First, we decided </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.549.1">to make the constructor </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Employee::Employee()</span></strong><span class="koboSpan" id="kobo.551.1"> private, so only friends such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">EmployeeBuilder</span></strong><span class="koboSpan" id="kobo.553.1"> can create these objects. </span><span class="koboSpan" id="kobo.553.2">This ensures that a partially initialized or otherwise invalid </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">Employee</span></strong><span class="koboSpan" id="kobo.555.1"> object cannot appear in the program: the only way to get one is from a builder. </span><span class="koboSpan" id="kobo.555.2">This is usually the safer choice, but sometimes we need to be able to default-construct the objects (for example, to use them in containers or for many serialization/deserialization implementations). </span><span class="koboSpan" id="kobo.555.3">Second, the builder holds the object that is being built until it can be moved to the caller. </span><span class="koboSpan" id="kobo.555.4">This is the common approach, but we have to be careful to use each builder object only once. </span><span class="koboSpan" id="kobo.555.5">We could also provide a way to reinitialize the builder; this is often done when the builder needs to do a lot of computations whose results are reused for building multiple objects. </span><span class="koboSpan" id="kobo.555.6">Finally, in order to construct an </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Employee</span></strong><span class="koboSpan" id="kobo.557.1"> object, we need to construct a </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">builder first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
;</span></pre>
<p><span class="koboSpan" id="kobo.560.1">The other common </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.561.1">approach is to provide a static function </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Employee::create()</span></strong><span class="koboSpan" id="kobo.563.1"> that </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.564.1">constructs a builder; in this case, the builder constructor is made private, </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">with friends.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">As we mentioned in the section on </span><em class="italic"><span class="koboSpan" id="kobo.567.1">Method chaining in class hierarchies</span></em><span class="koboSpan" id="kobo.568.1">, the chained methods do not have to all return references to the same class. </span><span class="koboSpan" id="kobo.568.2">If our </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Employee</span></strong><span class="koboSpan" id="kobo.570.1"> object has an internal structure such as separate sub-records for the home address, job location, and so on, we could have a more structured approach to the builder </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">The goal here is to design an interface so the client code could look </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
// Example 09
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
  .Job()
    .SetTitle("Safety Inspector")
    .SetOffice("Sector 7G")
  .Address()
    .SetHouse("742")
    .SetStreet("Evergreen Terrace")
    .SetCity("Springfield")
  .Awards()
    .Add("Remorseless Eating Machine")
;</span></pre>
<p><span class="koboSpan" id="kobo.575.1">To do this, we need </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.576.1">to implement a hierarchy of builders </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.577.1">with a common </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
// Example 09
class JobBuilder;
class AwardBuilder;
class AbstractBuilder {
  protected:
  Employee&amp; e_;
  public:
  explicit AbstractBuilder(Employee&amp; e) : e_(e) {}
  operator Employee() {
    assert(!e_.first_name_.empty() &amp;&amp;
           !e_.last_name_.empty());
      return std::move(e_);
  }
  JobBuilder Job();
  AddressBuilder Address();
  AwardBuilder Awards();
};</span></pre>
<p><span class="koboSpan" id="kobo.580.1">We still start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">EmployeeBuilder</span></strong><span class="koboSpan" id="kobo.582.1"> which constructs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Employee</span></strong><span class="koboSpan" id="kobo.584.1"> object; the rest of the builders hold a reference to it, and, by calling the corresponding member function on </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">AbstractBuilder</span></strong><span class="koboSpan" id="kobo.586.1"> we can switch to a different type of builder for the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Employee</span></strong><span class="koboSpan" id="kobo.588.1"> object. </span><span class="koboSpan" id="kobo.588.2">Note that, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">AbstractBuilder</span></strong><span class="koboSpan" id="kobo.590.1"> serves as the base class for all other builders, there </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.591.1">are no pure virtual functions (or any other virtual functions): as we </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.592.1">have seen earlier, run-time polymorphism is not particularly useful in </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">method chaining:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
class EmployeeBuilder : public AbstractBuilder {
  Employee employee_;
  public:
  EmployeeBuilder() : AbstractBuilder(employee_) {}
  EmployeeBuilder&amp; SetPrefix(std::string_view s){
    e_.prefix_ = s; return *this;
  }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.595.1">To add the job information, we switch to </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">JobBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
// Example 09
class JobBuilder : public AbstractBuilder {
  public:
  explicit JobBuilder(Employee&amp; e) : AbstractBuilder(e) {}
  JobBuilder&amp; SetTitle(std::string_view s) {
    e_.title_ = s; return *this;
  }
  …
  JobBuilder&amp; SetManager(std::string_view s) {
    e_.manager_ = s; return *this;
  }
  JobBuilder&amp; SetManager(const Employee&amp; manager) {
    e_.manager_ = manager.first_name_ + " " +
                  manager.last_name_;
     return *this;
  }
  JobBuilder&amp; CopyFrom(const Employee&amp; other) {
    e_.manager_ = other.manager_;
    …
    return *this;
  }
};
JobBuilder AbstractBuilder::Job() {
  return JobBuilder(e_);
}</span></pre>
<p><span class="koboSpan" id="kobo.600.1">Once we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">JobBuilder</span></strong><span class="koboSpan" id="kobo.602.1">, all its chained methods return a reference to itself; of course, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">JobBuilder</span></strong><span class="koboSpan" id="kobo.604.1"> is also an </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">AbstractBuilder</span></strong><span class="koboSpan" id="kobo.606.1">, so we could switch to another builder type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">AddressBuilder</span></strong><span class="koboSpan" id="kobo.608.1"> any time. </span><span class="koboSpan" id="kobo.608.2">Note that we can declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">AbstractBuilder::Job()</span></strong><span class="koboSpan" id="kobo.610.1"> method with just the forward declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">JobBuilder</span></strong><span class="koboSpan" id="kobo.612.1">, but the implementation has to be deferred until the type itself </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">is defined.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">In this example, we also </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.615.1">see the flexibility of the Builder pattern</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.616.1"> that would be very difficult to implement using constructors only. </span><span class="koboSpan" id="kobo.616.2">For example, there are two ways to define an employee’s manager: we can provide the name, or use another employee record. </span><span class="koboSpan" id="kobo.616.3">Also, we can copy the workplace information from another employee’s records, and still use </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">Set</span></strong><span class="koboSpan" id="kobo.618.1"> methods to modify the fields that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">Other builders such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">AddressBuilder</span></strong><span class="koboSpan" id="kobo.622.1"> are likely to be similar. </span><span class="koboSpan" id="kobo.622.2">But there may be very different builders as well. </span><span class="koboSpan" id="kobo.622.3">For example, an employee could have an arbitrary number </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">of awards:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
// Example 09
class Employee {
  … name, job, address, etc …
  std::vector&lt;std::string&gt; awards_;
};</span></pre>
<p><span class="koboSpan" id="kobo.625.1">The corresponding </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.626.1">builder needs to reflect the nature of the information </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.627.1">that it is adding to </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">the object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
// Example 09
class AwardBuilder : public AbstractBuilder {
  public:
  explicit AwardBuilder(Employee&amp; e) : AbstractBuilder(e)
  {}
  AwardBuilder&amp; Add(std::string_view award) {
    e_.awards_.emplace_back(award); return *this;
  }
};
AwardBuilder AbstractBuilder::Awards() {
  return AwardBuilder(e_);
}</span></pre>
<p><span class="koboSpan" id="kobo.630.1">We can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">AwardBuilder::Add()</span></strong> <a id="_idTextAnchor446"/><span class="koboSpan" id="kobo.632.1">as many times as we need to build the particular </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">Employee</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.634.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Here is our builder in action. </span><span class="koboSpan" id="kobo.635.2">Note how, for different employees, we can use different ways to supply the </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">required information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
Employee Barry = EmployeeBuilder()
  .SetFirstName("Barnabas")
  .SetLastName("Mackleberry")
;</span></pre>
<p><span class="koboSpan" id="kobo.638.1">We can use </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.639.1">one employee record to add the manager’s name </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.640.1">to </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">another employee:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
  .Job()
    .SetTitle("Safety Inspector")
    .SetOffice("Sector 7G")
    .SetManager(Barry) // Writes "Barnabas Mackleberry"
  .Address()
    .SetHouse("742")
    .SetStreet("Evergreen Terrace")
    .SetCity("Springfield")
  .Awards()
    .Add("Remorseless Eating Machine")
;</span></pre>
<p><span class="koboSpan" id="kobo.643.1">We can copy employment records </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">between employees:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
Employee Lenny = EmployeeBuilder()
  .SetFirstName("Lenford")
  .SetLastName("Leonard")
  .Job()
    .CopyFrom(Homer)
;</span></pre>
<p><span class="koboSpan" id="kobo.646.1">Some of the fields, such as first and last name, are optional, and the builder checks the finished records for completeness before they can be accessed (see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">AbstractBuilder::operator Employee()</span></strong><span class="koboSpan" id="kobo.648.1"> above). </span><span class="koboSpan" id="kobo.648.2">Other fields, such as name suffixes, </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">are optional:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
Employee Smithers = EmployeeBuilder()
  .SetFirstName("Waylon")
  .SetLastName("Smithers")
  .SetSuffix("Jr") // Only when needed!
</span><span class="koboSpan" id="kobo.650.2">;</span></pre>
<p><span class="koboSpan" id="kobo.651.1">The fluent builder </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.652.1">is a powerful C++ pattern for constructing complex </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.653.1">objects with many components, particularly when parts of the object are optional. </span><span class="koboSpan" id="kobo.653.2">However, it can get quite verbose for objects containing large amounts of highly structured data. </span><span class="koboSpan" id="kobo.653.3">There are alternatives, </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">of course.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor447"/><span class="koboSpan" id="kobo.655.1">The implicit builder</span></h2>
<p><span class="koboSpan" id="kobo.656.1">We have already </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.657.1">seen a case where the Builder pattern was employed without a dedicated builder object: all </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Options</span></strong><span class="koboSpan" id="kobo.659.1"> objects for named argument </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.660.1">passing act as their own builders. </span><span class="koboSpan" id="kobo.660.2">We are going to see another version which is particularly interesting because there is no explicit builder object here. </span><span class="koboSpan" id="kobo.660.3">This design is particularly suitable for building nested hierarchical data such as XML files. </span><span class="koboSpan" id="kobo.660.4">We are going to demonstrate its use to build a (very simplified) </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">HTML writer.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">In this design, HTML records are going to be represented by the corresponding classes: a class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">&lt;P&gt;</span></strong><span class="koboSpan" id="kobo.664.1"> tag, another for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">&lt;UL&gt;</span></strong><span class="koboSpan" id="kobo.666.1"> tag, and so on. </span><span class="koboSpan" id="kobo.666.2">All of these classes elaborate the common base </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">class, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">HTMLElement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.670.1">
class HTMLElement {
  public:
  const std::string name_;
  const std::string text_;
  const std::vector&lt;HTMLElement&gt; children_;
  HTMLElement(std::string_view name, std::string_view text)
    : name_(name), text_(text) {}
  HTMLElement(std::string_view name, std::string_view text,
              std::vector&lt;HTMLElement&gt;&amp;&amp; children)
    : name_(name), text_(text),
      children_(std::move(children)) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
    const HTMLElement&amp; element);
};</span></pre>
<p><span class="koboSpan" id="kobo.671.1">There is, of course, a lot more to an HTML element, but we have to keep things simple. </span><span class="koboSpan" id="kobo.671.2">Also, our base </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.672.1">element allows unlimited nesting: any element can have a vector </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.673.1">of child elements, each of which can have child elements, and so on. </span><span class="koboSpan" id="kobo.673.2">Printing of an element is, </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">therefore, recursive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const HTMLElement&amp; element) {
  out &lt;&lt; "&lt;" &lt;&lt; element.name_ &lt;&lt; "&gt;\n";
  if (!element.text_.empty())
    out &lt;&lt; "  " &lt;&lt; element.text_ &lt;&lt; "\n";
  for (const auto&amp; e : element.children_) out &lt;&lt; e;
  out &lt;&lt; "&lt;/" &lt;&lt; element.name_ &lt;&lt; "&gt;" &lt;&lt; std::endl;
  return out;
}</span></pre>
<p><span class="koboSpan" id="kobo.676.1">Note that, in order to add child elements, we have to supply them in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">std::vector</span></strong><span class="koboSpan" id="kobo.678.1"> which is then moved into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.680.1"> object. </span><span class="koboSpan" id="kobo.680.2">The rvalue reference means that the vector argument is going to be a temporary value or a result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">std::move</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">However, we are not going to add the child elements to vectors ourselves: this is the job of the derived classes for the specific elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">&lt;P&gt;</span></strong><span class="koboSpan" id="kobo.684.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">&lt;UL&gt;</span></strong><span class="koboSpan" id="kobo.686.1">, etc). </span><span class="koboSpan" id="kobo.686.2">The specific element classes can prevent the addition of child elements when the syntax does not allow it, as well as enforce other restrictions on the fields of an </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">HTML element.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">What do these specific classes look like? </span><span class="koboSpan" id="kobo.688.2">The simpler ones are going to look </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
class HTML : public HTMLElement {
  public:
  HTML() : HTMLElement("html", "") {}
  HTML(std::initializer_list&lt;HTMLElement&gt; children) :
    HTMLElement("html", "", children) {};
};</span></pre>
<p><span class="koboSpan" id="kobo.691.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">HTML</span></strong><span class="koboSpan" id="kobo.693.1"> class represents the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">&lt;html&gt;</span></strong><span class="koboSpan" id="kobo.695.1"> tag. </span><span class="koboSpan" id="kobo.695.2">Classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">Body</span></strong><span class="koboSpan" id="kobo.697.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">Head</span></strong><span class="koboSpan" id="kobo.699.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">UL</span></strong><span class="koboSpan" id="kobo.701.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">OL</span></strong><span class="koboSpan" id="kobo.703.1">, and many more, are written exactly the same way. </span><span class="koboSpan" id="kobo.703.2">The class </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">P</span></strong><span class="koboSpan" id="kobo.705.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">&lt;P&gt;</span></strong><span class="koboSpan" id="kobo.707.1"> tag is similar except it does </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.708.1">not allow nested objects, so it has only one </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.709.1">constructor that takes the text argument. </span><span class="koboSpan" id="kobo.709.2">It is very important that these classes do not add any data members; they must initialize the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.711.1"> object and nothing else. </span><span class="koboSpan" id="kobo.711.2">The reason should be obvious if you look at the base class again: we store a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.713.1"> child objects. </span><span class="koboSpan" id="kobo.713.2">However, they were constructed – as </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">HTML</span></strong><span class="koboSpan" id="kobo.715.1"> or as </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">UL,</span></strong><span class="koboSpan" id="kobo.717.1"> or as anything else – they are only </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.719.1"> objects now. </span><span class="koboSpan" id="kobo.719.2">Any extra data is going to </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">be lost.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">You may also notice that the vector parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.723.1"> constructor is initialized from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">std::initializer_list</span></strong><span class="koboSpan" id="kobo.725.1"> argument. </span><span class="koboSpan" id="kobo.725.2">This conversion is done implicitly by the compiler from the list of the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">constructor arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
// Example 10
auto doc = HTML{
  Head{
    Title{"Mary Had a Little Lamb"}
  },
  Body{
    P{"Mary Had a Little Lamb"},
    OL{
      LI{"Its fleece was white as snow"},
      LI{"And everywhere that Mary went"},
      LI{"The lamb was sure to go"}
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.728.1">This statement begins with a call to construct an </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">HTML</span></strong><span class="koboSpan" id="kobo.730.1"> object using two arguments. </span><span class="koboSpan" id="kobo.730.2">They are </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Head</span></strong><span class="koboSpan" id="kobo.732.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">Body</span></strong><span class="koboSpan" id="kobo.734.1"> objects, but they get converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.736.1"> and put into </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">std::initializer_list&lt;HTMLElement&gt;</span></strong><span class="koboSpan" id="kobo.738.1"> by the compiler. </span><span class="koboSpan" id="kobo.738.2">The list is then used to initialize a vector, which is moved into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">children_</span></strong><span class="koboSpan" id="kobo.740.1"> vector in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">HTML</span></strong><span class="koboSpan" id="kobo.742.1"> object. </span><span class="koboSpan" id="kobo.742.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">Head</span></strong><span class="koboSpan" id="kobo.744.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Body</span></strong><span class="koboSpan" id="kobo.746.1"> objects themselves have child objects, one of which (</span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">OL</span></strong><span class="koboSpan" id="kobo.748.1">) has its own </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">child objects.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Note it gets </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.751.1">a little tricky if you want to have additional constructor </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.752.1">arguments because you cannot mix regular arguments with initializer list elements. </span><span class="koboSpan" id="kobo.752.2">This problem happens, for example, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">LI</span></strong><span class="koboSpan" id="kobo.754.1"> class. </span><span class="koboSpan" id="kobo.754.2">The straightforward way to implement this class, based on what we learned so far, is </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
//Example 10
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  LI(std::string_view text,
     std::initializer_list&lt;HTMLElement&gt; children) :
    HTMLElement("li", text, children) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.757.1">Unfortunately, you can’t call this constructor with something </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
//Example 10
LI{"A",
  UL{
    LI{"B"},
    LI{"C"}
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.760.1">It seems obvious </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.761.1">that what the programmer wanted </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.762.1">is for the first argument to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">"A"</span></strong><span class="koboSpan" id="kobo.764.1"> and the second argument (and any more arguments, if we had them) should go into the initializer list. </span><span class="koboSpan" id="kobo.764.2">But that doesn’t work: generally, to form an initializer list, we have to enclose the element sequence in braces </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">{…}</span></strong><span class="koboSpan" id="kobo.766.1">. </span><span class="koboSpan" id="kobo.766.2">Only when the entire argument list matches an initializer list can these braces be omitted. </span><span class="koboSpan" id="kobo.766.3">With some arguments not being part of the initializer list, we have to </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">be explicit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.768.1">
//Example 10
LI{"A",
  {UL{        // Notice { before UL!
</span><span class="koboSpan" id="kobo.768.2">    LI{"B"},
    LI{"C"}
  }}            // And closing } here
}</span></pre>
<p><span class="koboSpan" id="kobo.769.1">If you don’t want to write the extra braces, you have to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">constructor slightly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.771.1">
//Example 11
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  template &lt;typename ... </span><span class="koboSpan" id="kobo.771.2">Children&gt;
  LI(std::string_view text, const Children&amp;... </span><span class="koboSpan" id="kobo.771.3">children) :
    HTMLElement("li", text,
           std::initializer_list&lt;HTMLElement&gt;{children...})
  {}
};</span></pre>
<p><span class="koboSpan" id="kobo.772.1">Instead of using </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.773.1">an initializer list parameter, we use a parameter pack and explicitly convert it to an initializer list (which is then converted to a vector). </span><span class="koboSpan" id="kobo.773.2">Of course, the parameter </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.774.1">pack will accept an arbitrary number of arguments of any type, not just </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.776.1"> and its derived classes, but the conversion to the initializer list will fail. </span><span class="koboSpan" id="kobo.776.2">If you want to follow the practice that any template that did not fail to instantiate should not produce compilation errors in its body, you have to restrict the types in the parameter pack to classes derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.778.1">. </span><span class="koboSpan" id="kobo.778.2">This is easily done using </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">C++20 concepts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">
// Example 12
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  LI(std::string_view text,
     const std::derived_from&lt;HTMLElement&gt;
     auto&amp; ... </span><span class="koboSpan" id="kobo.780.2">children) :
    HTMLElement("li", text,
           std::initializer_list&lt;HTMLElement&gt;{children...})
  {}
};</span></pre>
<p><span class="koboSpan" id="kobo.781.1">If you don’t use C++20 but still want to restrict the parameter types, you should read the </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.782.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.783.1">, </span><em class="italic"><span class="koboSpan" id="kobo.784.1">SFINAE, Concepts, and Overload Resolution Management</span></em><span class="koboSpan" id="kobo.785.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">With the parameter </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.788.1">pack used as an intermediary for constructing </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.789.1">an initializer list, we can avoid the extra braces and write our HTML document </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
// Examples 11, 12
auto doc = HTML{
  Head{
    Title{"Mary Had a Little Lamb"}
  },
  Body{
    P{"Mary Had a Little Lamb"},
    OL{
      LI{"Its fleece was white as snow"},
      LI{"And everywhere that Mary went"},
      LI{"The lamb was sure to go"}
    },
    UL{
      LI{"It followed her to school one day"},
      LI{"Which was against the rules",
        UL{
          LI{"It made the children laugh and play"},
          LI{"To see a lamb at school"}
        }
      },
      LI{"And so the teacher turned it out"}
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.792.1">This does look like an application of the Builder pattern: even though the final construction is done by a single call to the HTMLElement constructor, that constructor just moves the </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.793.1">already constructed vector of child elements into its final location. </span><span class="koboSpan" id="kobo.793.2">The actual construction is done in steps like all builders do. </span><span class="koboSpan" id="kobo.793.3">But where is the builder object? </span><span class="koboSpan" id="kobo.793.4">There isn’t one, not explicitly. </span><span class="koboSpan" id="kobo.793.5">Part of the builder functionality is provided by all </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.794.1">the derived objects, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">HTML</span></strong><span class="koboSpan" id="kobo.796.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">UL</span></strong><span class="koboSpan" id="kobo.798.1">, etc. </span><span class="koboSpan" id="kobo.798.2">They may look like they represent the corresponding HTML constructs, but they really don’t: after the entire document is constructed, we only have </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">HTMLElement</span></strong><span class="koboSpan" id="kobo.800.1"> objects. </span><span class="koboSpan" id="kobo.800.2">The derived objects are used only to build the document. </span><span class="koboSpan" id="kobo.800.3">The rest of the builder code is generated by the compiler when it does all the implicit conversions between parameter packs, initializer lists, and vectors. </span><span class="koboSpan" id="kobo.800.4">By the way, any half-decent optimizing compiler is going to get rid of all the intermediate copies and copy the input strings straight into the final vector where they are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">be stored.</span></span></p>
<p><span class="koboSpan" id="kobo.802.1">Of course, this is a very simplified example, and for any practical use, we would need to store more data with HTML elements and give the programmer a way to initialize this data. </span><span class="koboSpan" id="kobo.802.2">We could combine the implicit builder approach with the fluent interface to provide an easy way to add optional values such as style, type, etc, to all </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">HTMLElement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">By now you have seen three distinct Builder designs: there is the “traditional” builder with a single builder object, the fluent builder that employs method chaining, and the implicit builder that uses many small builder helper objects and relies heavily on compiler-generated code. </span><span class="koboSpan" id="kobo.805.2">There are other designs, but they are mostly variants and combinations of th</span><a id="_idTextAnchor448"/><span class="koboSpan" id="kobo.806.1">e approaches you have learned. </span><span class="koboSpan" id="kobo.806.2">Our study of the Builder pattern has drawn to </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">a close.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor449"/><span class="koboSpan" id="kobo.808.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.809.1">Yet again, we have seen the power of C++ to essentially create a new language out of the existing one; C++ does not have named function arguments, only positional ones. </span><span class="koboSpan" id="kobo.809.2">That is part of the core language. </span><span class="koboSpan" id="kobo.809.3">And yet, we were able to extend the language and add support for named arguments in a reasonable-looking way, using the method chaining technique. </span><span class="koboSpan" id="kobo.809.4">We have also explored the other applications of method chaining beyond the named </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">arguments idiom.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">One of these applications, the fluent builder, is again an exercise in creating new languages: the power of the fluent interface, in general, is that it can be used to create domain-specific languages to execute sequences of instructions on some data. </span><span class="koboSpan" id="kobo.811.2">And so the fluent builder can be used to allow the programmer to describe the construction of objects as a sequence of steps that are familiar in a particular domain. </span><span class="koboSpan" id="kobo.811.3">Then, of course, there is the implicit builder that (with the right indents) even makes C++ code look a bit like the HTML document that is </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">being built.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">The next chapter introduces the only purely performance-oriented idiom in this book. </span><span class="koboSpan" id="kobo.813.2">We have discussed in several chapters the performance cost of memory allocation, and its impact on the implementation of several patterns. </span><span class="koboSpan" id="kobo.813.3">The next idiom, local buffe</span><a id="_idTextAnchor450"/><span class="koboSpan" id="kobo.814.1">r</span><a id="_idTextAnchor451"/><span class="koboSpan" id="kobo.815.1"> optimization, attacks the problem head-on, by avoiding memory </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">allocation altogether.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor452"/><span class="koboSpan" id="kobo.817.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.818.1">Why do functions with many arguments of the same or related types lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">fragile code?</span></span></li>
<li><span class="koboSpan" id="kobo.820.1">How do aggregate argument objects improve code maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">and robustness?</span></span></li>
<li><span class="koboSpan" id="kobo.822.1">What is the named argument idiom and how does it differ from </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">aggregate arguments?</span></span></li>
<li><span class="koboSpan" id="kobo.824.1">What is the difference between method chaining </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">and cascading?</span></span></li>
<li><span class="koboSpan" id="kobo.826.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">Builder pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.828.1">What is the fluent interface and when is </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">it used?</span></span></li>
</ol>
</div>
</body></html>