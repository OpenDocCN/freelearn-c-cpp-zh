<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor406"/><a id="_idTextAnchor407"/>9</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor408"/>Named Arguments, Method Chaining, and the Builder Pattern</h1>
<p>In this chapter, we are going to examine a solution to a very common C++ problem: too many arguments. No, we are not talking about the arguments between C++ programmers, such as whether to put curly braces at the end of the line or the start of the next one (we have no solution to that problem). This is the problem of C++ functions with too many arguments. If you have maintained a large C++ system long enough, you have seen it—functions start with simple declarations and, over time, grow additional arguments, often defaulted, to support new features.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What are the problems with long function declarations?</li>
<li>What is the alternative?</li>
<li>What are the downsides of using the named arguments idiom?</li>
<li>How can the named arguments idiom be generalized?</li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor409"/><a id="_idTextAnchor410"/>Technical requirements</h1>
<p>Here is the example code: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09</a>.</p>
<p>Here is the Google Benchmark library: <a href="https://github.com/google/benchmark">https://github.com/google/benchmark</a> (see <a href="B19262_04.xhtml#_idTextAnchor152"><em class="italic">Chapter 4</em></a>, <em class="italic">Swap – From Simple to Subtle</em>, for installation instructions).</p>
<p><a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>The problem with arguments</p>
<p>Everyone who has worked on a sufficiently large C++ system at some point have had to add arguments <a id="_idIndexMarker459"/>to a function. To avoid breaking the existing code, the new argument is often given a default value which usually retains the old functionality. That works great the first time, is OK the second time, and then one has to start counting arguments on every function call. There are other problems with long function declarations as well, and if we want a better solution, it is worth our time to understand what they are before trying to solve them. We begin this section with a more in-depth analysis of the problem before moving on to the solution<a id="_idTextAnchor413"/>.<a id="_idTextAnchor414"/></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor415"/>What’s wrong with many arguments?</h2>
<p>Whether the code that passes around a lot of arguments was written this way from the start or has grown <em class="italic">organically</em>, it is fragile and vulnerable to programmer mistakes. The main problem is that there are, usually, many arguments of the same type, and they can be miscounted. Consider designing a civilization-building game—when a player creates a new city, a corresponding object is constructed. The player gets to choose what facilities to build in the city, and the game sets the options for available resources:</p>
<pre class="source-code">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water,
       bool is_coastal,
       bool has_forest);
  ...
};</pre>
<p>It looks like we have taken care of everything. To start the game, let’s give each player a city with a keep, a guard tower, two buildings, and a guard company:</p>
<pre class="source-code">
City Capital(2, 1, 1, City::KEEP,
             false, false, false, false);</pre>
<p>Can you see the mistake? The compiler, fortunately, can—not enough arguments. Since the compiler won’t let us make a mistake here, this is no big deal, we just need to add the argument for <code>has_forest</code>. Also, let’s say the game placed the city near a river, so it has water now:</p>
<pre class="source-code">
City Capital(2, 1, 1, City::KEEP,
             false, true, false, false, false);</pre>
<p>That was easy ... Oops! We now have the city on the river but without fresh water (just what is in that river?). At least the townsfolk won’t starve, thanks to the free granary they accidentally received. That error—where the <code>true</code> value was passed to the wrong parameter—will have <a id="_idIndexMarker460"/>to be found during debugging. Also, this code is quite verbose, and we may find ourselves typing the same values over and over. Maybe the game tries to place cities near the rivers and forests by default? OK then:</p>
<pre class="source-code">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       enter_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true);
  ...
};</pre>
<p>Now, let’s go back to our first attempt to create a city—it now compiles, one argument short, and we are none the wiser that we miscounted the arguments. The game is a great success, and, in the next update, we get an exciting new building—a temple! We need to add a new argument to the constructor, of course. It makes sense to add it after <code>with_granary</code>, with all the other buildings, and before the terrain features. But then we have to edit every call to the <code>City</code> constructor. What is worse, it is very easy to make a mistake since the <code>false</code> for <em class="italic">no temple</em> looks, to both the programmer and the compiler, exactly like the <code>false</code> for <em class="italic">no fresh water</em>. The new argument has to be inserted in the right place, in a long line of very similarly-looking values.</p>
<p>Of course, the existing <a id="_idIndexMarker461"/>game code works without temples, so they are only needed in the new updated code. There is some value in not disturbing existing code unless necessary. We could do that if we added the new argument at the end and gave it the default value, so any constructor call that was not changed still creates the exact same city as before:</p>
<pre class="source-code">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false);
  ...
};</pre>
<p>But now, we let short-term convenience dictate our long-term interface design. The parameters no longer <a id="_idIndexMarker462"/>have even a logical grouping, and in the long run, mistakes are even more likely. Also, we did not fully solve the problem of not updating the code that does not need to change—the next release adds a new terrain, desert, and with it, another argument:</p>
<pre class="source-code">
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center,
       bool with_forge,
       bool with_granary,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false,
       bool is_desert = false);
  ...
};</pre>
<p>Once started, we have to give default values to all new arguments added at the end. Also, in order to create a city in the desert, we also have to specify whether it has a temple. There is no logical reason why it has to be this way, but we are bound by the process in which the interface evolved. The situation gets even worse when you consider that many types we used are convertible to each other:</p>
<pre class="source-code">
City Capital(2, 1, false, City::KEEP,
             false, true, false, false, false);</pre>
<p>This creates a city with zero guard companies and not whatever the programmer expected to disable <a id="_idIndexMarker463"/>when they set the third argument to <code>false</code>. Even <code>enum</code> types do not offer full protection. You probably noticed that all new cities usually start as a keep, so it would make sense to have that as the default as well:</p>
<pre class="source-code">
// Example 01
class City {
  public:
  enum center_t { KEEP, PALACE, CITADEL };
  City(size_t number_of_buildings,
       size_t number_of_towers,
       size_t guard_strength,
       center_t center = KEEP,
       bool with_forge = false,
       bool with_granary = false,
       bool has_fresh_water = true,
       bool is_coastal = false,
       bool has_forest = true,
       bool with_temple = false,
       bool is_desert = false);
  ...
};</pre>
<p>Now, we don’t have to type as many arguments and might even avoid some mistakes (if you don’t write arguments, you can’t write them in the wrong order). But, we can make new ones:</p>
<pre class="source-code">
City Capital(2, 1, City::CITADEL);</pre>
<p>The two guard companies we just hired (because the numerical value of <code>CITADEL</code> is <code>2</code>) will find themselves quite short on space in the lowly keep (which we intended to change but did not). The <code>enum class</code> of C++11 offers better protection since each one is a different type <a id="_idIndexMarker464"/>without conversions to integers, but the overall problem remains. As we have seen, there are two problems with passing a lot of values to C++ functions as separate arguments. First, it creates very long declarations and function calls that are error-prone. Second, if we need to add a value or change the type of a parameter, there is a lot of code to be edited. The solution to both problems existed even before C++ was created; it comes from C—use aggregates—that is, structs—to combine many values into one para<a id="_idTextAnchor416"/>m<a id="_idTextAnchor417"/>eter.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor418"/>Aggregate parameters</h2>
<p>With aggregate parameters, we create a struct or a class that contains all the values, instead of adding <a id="_idIndexMarker465"/>one parameter per value. We don’t have to be limited to one aggregate; for example, our city may take several structs, one for all terrain-related features that the game sets, and another for all features that the player controls directly:</p>
<pre class="source-code">
struct city_features_t {
  size_t number_of_buildings = 1;
  size_t number_of_towers = 0;
  size_t guard_strength = 0;
  enum center_t { KEEP, PALACE, CITADEL };
  center_t center = KEEP;
  bool with_forge = false;
  bool with_granary = false;
  bool with_temple = false;
};
struct terrain_features_t {
  bool has_fresh_water = true;
  bool is_coastal = false;
  bool has_forest = true;
  bool is_desert = false;
};
class City {
  public:
  City(city_features_t city_features,
       terrain_features_t terrain_features);
  ...
};</pre>
<p>This solution <a id="_idIndexMarker466"/>has many advantages. First of all, assigning values to the arguments can be done explicitly, by name, and is very visible (and very verbose):</p>
<pre class="source-code">
city_features_t city_features;
city_features.number_of_buildings = 2;
city_features.center = city_features::KEEP;
...
terrain_features_t terrain_features;
terrain_features.has_fresh_water = true;
...
City Capital(city_features, terrain_features);</pre>
<p>It is much easier to see what each argument’s value is, and mistakes are much less likely (the alternative, aggregate initialization of the structs, only moves the problem from one initialization to the other). If we need to add a new feature, most of the time we just have to add a new data member to one of the aggregate types. Only the code that actually deals with the new argument has to be updated; all the functions and classes that simply pass the arguments and forward them do not need to change at all. We can even give the aggregate types default values to provide default values for all arguments, as we have done in the last example.</p>
<p>This is, overall, an excellent solution to the problem of functions with many parameters. However, it has one drawback: the aggregates have to be explicitly created and initialized, line by line. This works out fine for many cases, especially when these classes and structs <a id="_idIndexMarker467"/>represent state variables that we are going to keep for a long time. But, when used purely as parameter containers, they create unnecessarily verbose code, starting from the fact that the aggregate variable must have a name. We don’t really need that name, as we are going to use it only once to call the function, but we have to make one up. It would be tempting just to use a temporary variable:</p>
<pre class="source-code">
struct city_features_t {
  size_t number_of_buildings = 1;
  size_t number_of_towers = 0;
  size_t guard_strength = 0;
  enum center_t { KEEP, PALACE, CITADEL };
  center_t center = KEEP;
  bool with_forge = false;
  bool with_granary = false;
  bool with_temple = false;
};
struct terrain_features_t {
  bool has_fresh_water = true;
  bool is_coastal = false;
  bool has_forest = true;
  bool is_desert = false;
};
City Capital({2, 1, 0, KEEP, true, false, false},
             {true, false, false, true});</pre>
<p>This works, but it brings us full circle, right to where we started; a function with a long list of easily mixed Boolean arguments. The fundamental problem we encounter is that C++ functions have positional arguments, and we are trying to come up with something that would let <a id="_idIndexMarker468"/>us specify arguments by name. Aggregate objects resolve this problem mostly as a side effect, and if the overall design benefits from collecting a group of values into one class, you should certainly do it. However, as a solution specifically for the problem of named arguments, with no other, more permanent reason to group the values together, they fall short. We will now see how this deficiency can be <a id="_idTextAnchor419"/>a<a id="_idTextAnchor420"/>ddressed.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor421"/>Named arguments in C++</h1>
<p>We have seen how collecting logically related values into aggregate objects gives us a side benefit; we can <a id="_idIndexMarker469"/>pass these values to functions and access them by name instead of by their order in a long list. The key is <em class="italic">logically related</em>, though; aggregating <a id="_idIndexMarker470"/>values for no reason other than they happen to be used together in one function call creates unnecessary objects with names we would rather not have to invent. We need a way to create temporary aggregates, preferably without explicit names or declarations. We have a solution to this problem, and had it for a long time in C++; all it needs is a fresh look from a different perspective, which we are about <a id="_idTextAnchor422"/>t<a id="_idTextAnchor423"/>o take now.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor424"/>Method chaining</h2>
<p>Method chaining <a id="_idIndexMarker471"/>is a borrowed C++ technique; it <a id="_idIndexMarker472"/>originates in <strong class="bold">Smalltalk</strong>. Its <a id="_idIndexMarker473"/>main purpose is to eliminate unnecessary local variables. You have used method chaining already, although you may not have realized it. Consider this code that you have probably written many times:</p>
<pre class="source-code">
// Example 02
int i, j;
std::cout &lt;&lt; i &lt;&lt; j;</pre>
<p>The last line invoked the inserter operator <code>&lt;&lt;</code> twice. The first time it is invoked on the object on the left-hand side of the operator, <code>std::cout</code>. What object is the second call on? In general, the operator syntax is just a way to call a function named <code>operator&lt;&lt;()</code>. Usually, this particular operator is a non-member function, but the <code>std::ostream</code> class has several member function overloads as well, and one of them is for <code>int</code> values. So, the last line really is this:</p>
<pre class="source-code">
// Example 02-
std::cout.operator&lt;&lt;(i).operator&lt;&lt;(j);</pre>
<p>The second <a id="_idIndexMarker474"/>call to <code>operator&lt;&lt;()</code> is done on <a id="_idIndexMarker475"/>the result of the first one. The equivalent C++ code is this:</p>
<pre class="source-code">
// Example 02
auto&amp; out1 = std::cout.operator(i);
out1.operator&lt;&lt;(j);</pre>
<p>This is the method chaining—the call to one method function returns the object on which the next method should be called. In the case of <code>std::cout</code>, the member <code>operator&lt;&lt;()</code> returns a reference to the object itself. By the way, the non-member <code>operator&lt;&lt;()</code> does the same, only instead of the implicit argument <code>this</code>, it has the stream object as an explicit first argument. Now, we can use method chaining to eliminate the explicitly named <a id="_idTextAnchor425"/><a id="_idTextAnchor426"/>argument object.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor427"/>Method chaining and named arguments</h2>
<p>As we have seen before, the aggregate argument objects work well when they are not used mainly <a id="_idIndexMarker476"/>to hold arguments; if we need an object to hold the state <a id="_idIndexMarker477"/>of the system, and we build it over time and keep it for a long time, we can also pass this object as a single argument to any function that needs this state. It’s creating aggregates for just one function call that we have a problem with. On the other hand, we do not like to write functions with many arguments either. This is particularly true for functions that usually have most arguments left as default, with only a few changes. Going back to our game, let’s say that each day, game time, is processed by a function call.</p>
<p>The function is called, once per game day, to advance the city through the day and process the consequences of various random events the game can generate:</p>
<pre class="source-code">
class City {
  ...
  void day(bool flood = false, bool fire = false,
    bool revolt = false, bool exotic_caravan = false,
    bool holy_vision = false, bool festival = false, ... );
  ...
};</pre>
<p>A lot of <a id="_idIndexMarker478"/>different events can happen over time, but rarely more than one happens on any particular day. We set all arguments to false by default, but this does <a id="_idIndexMarker479"/>not really help; there is no particular order to these events, and if the festival happens, all the previous arguments must be specified even though they are still equal to their default values.</p>
<p>An aggregate object helps a lot, but we need to create and name it:</p>
<pre class="source-code">
class City {
  ...
  struct DayEvents {
    bool flood = false;
    bool fire = false;
    ...
  };
  void day(DayEvents events);
  ...
};
City capital(...);
City::DayEvents events;
events.fire = true;
capital.day(events);</pre>
<p>We would <a id="_idIndexMarker480"/>like to create a temporary <code>DayEvents</code> object just for the <a id="_idIndexMarker481"/>call to <code>City::day()</code>, but we need a way to set its data members. This is where method chaining comes in:</p>
<pre class="source-code">
// Example 03
class City {
  ...
  class DayEvents {
    friend City;
    bool flood = false;
    bool fire = false;
    public:
    DayEvents() = default;
    DayEvents&amp; SetFlood() { flood = true; return *this; }
    DayEvents&amp; SetFire() { fire = true; return *this; }
    ...
  };
  void day(DayEvents events);
  ...
};
City capital(...);
capital.day(City::DayEvents().SetFire());</pre>
<p>The default constructor constructs an unnamed temporary object. On that object, we invoke the <code>SetFire()</code> method. It modifies the object and returns a reference to itself. We pass the created and modified temporary object to the <code>day()</code> function, which processes the events of the day, displays the updated graphics of the city in flames, plays the sound of fire, and updates the status of the city to reflect that some buildings were damaged by fire.</p>
<p>Since each of the <code>Set()</code> methods return a reference to the same object, we can invoke more than one in a method chain, to specify multiple events. Also, the <code>Set()</code> methods can take arguments, of course; for example, instead of <code>SetFire()</code> that always changes the <a id="_idIndexMarker482"/>fire event to <code>true</code> from its default <code>false</code>, we could have <a id="_idIndexMarker483"/>a method that can set the event flag either way:</p>
<pre class="source-code">
DayEvents&amp; SetFire(bool value = true) {
  fire = value;
  return *this;
}</pre>
<p>Today is the market day in our city, which coincides with a major festival, so the king hired an extra guard company in addition to the two already stationed in the city:</p>
<pre class="source-code">
City capital(...);
capital.day(City::DayEvents().
            SetMarket().
            SetFestival().
            SetGuard(3));</pre>
<p>Note that we did not have to specify anything for all the events that did not happen. We now have true named arguments; when we call a function, we pass the arguments in any order, by name, and we do not need to explicitly mention any arguments we wish to leave at their default values. This is the C++ named arguments idiom. A call with named arguments is, of course, more verbose than a call with positional arguments; each argument must have the name explicitly written. That was the point of the exercise. On the other hand, we come out ahead if there is a long list of default arguments we did not have to change. One question that could be asked is that of performance—we have a lot of extra function calls, the constructor, and a <code>Set()</code> call for every named argument, and that must cost something. Let’s find o<a id="_idTextAnchor428"/>u<a id="_idTextAnchor429"/>t exactly what it costs.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor430"/>Performance of the named arguments idiom</h2>
<p>There is definitely more going on with the named argument call, as more functions are called. On the <a id="_idIndexMarker484"/>other hand, the function calls are really simple and, if they are defined in the header file, and the entire implementation is visible to the compiler, there is no reason for the compiler not to inline all the <code>Set()</code> calls and eliminate the unnecessary temporary variables. With good optimization, we could expect similar performance from the named arguments idiom and the explicitly named aggregate object.</p>
<p>The appropriate tool to measure the performance of a single function call is the micro benchmark. We use the Google microbenchmark library for this purpose. While the benchmarks are usually written in one file, we need another source file if we want the function we call to be external, not inlined. On the other hand, the <code>Set()</code> methods should definitely be inlined, so they should be defined in the header file. The second source file should contain the definition of the function we are calling with named or positional arguments. Both files are combined at link time:</p>
<pre class="source-code">
$CXX named_args.C named_args_extra.C -g -O4 -I. \
  -Wall -Wextra -Werror -pedantic --std=c++14 \
  -I$GBENCH_DIR/include $GBENCH_DIR/lib/libbenchmark.a \
  -lpthread -lrt -lm -o named_args</pre>
<p>We can compare the positional arguments, the named arguments, and the arguments aggregate. The result will depend on the type and number of arguments. For example, for a function with four Boolean arguments, we can compare these calls:</p>
<pre class="source-code">
// Example 04
// Positional arguments:
Positional p(true, false, true, false);
// Named arguments idiom:
Named n(Named::Options().SetA(true).SetC(true));
// Aggregate object:
Aggregate::Options options;
options.a = true;
options.c = true;
Aggregate a(options));</pre>
<p>The performance measured by the benchmark will depend greatly on the compiler and on the options that control optimization. For example, these numbers were collected on GCC12 with -O3:</p>
<pre class="source-code">
Benchmark                 Time  UserCounters...
BM_positional_const   0.233 ns  items_per_second=138.898G/s
BM_named_const        0.238 ns  items_per_second=134.969G/s
BM_aggregate_const    0.239 ns  items_per_second=135.323G/s</pre>
<p>There is no noticeable performance hit for the explicitly named aggregate object that the compiler <a id="_idIndexMarker485"/>was able to inline and optimize away. The named and positional arguments perform similarly. Note that the performance of the function calls depends greatly on what else is going on in the program at the same time, since the arguments are passed on registers, and register availability is affected by the context.</p>
<p>In our benchmark, we have used compile-time constants as argument values. This is not uncommon, especially for arguments that specify certain options—very often, at each call site, many of the options will be static, unchanging (the values are different in other places in the code where the same function is called, but on this line, many of the values are fixed at compile time). For example, if we have a special code branch to process natural disasters in our game, the ordinary branch will always call our day simulation with a flood, fire, and other disaster flags set to <code>false</code>. But, just as often the arguments are computed at runtime. How does this affect the performance? Let’s create another benchmark where the values of the arguments are retrieved, for example, from a vector:</p>
<pre class="source-code">
// Example 04
std::vector&lt;int&gt; v; // Fill v with random values
size_t i = 0;
// ... Benchmark loop ...
const bool a = v[i++];
const bool b = v[i++];
const bool c = v[i++];
const bool d = v[i++];
if (i == v.size()) i = 0; // Assume v.size() % 4 == 0
Positional p(a, b, c, d); // Positional arguments
Named n(Named::Options().
  SetA(a).SetC(b).SetC(c).SetD(d)); // Named arguments
Aggregate::Options options;
options.a = a;
options.b = b;
options.c = c;
options.d = d;
Aggregate a(options)); // Aggregate object</pre>
<p>By the way, it would <a id="_idIndexMarker486"/>be ill-advised to shorten the preceding code in this manner:</p>
<pre class="source-code">
Positional p(v[i++], v[i++], v[i++], v[i++]);</pre>
<p>The reason is that the order in which the arguments are evaluated is undefined, so it is arbitrary which of the <code>i++</code> calls is executed first. If <code>i</code> starts from <code>0</code>, this call may end up calling <code>Positional(v[0], v[1], v[2], v[3])</code> or <code>Positional(v[3], v[2], v[1], v[0])</code> or any other permutation.</p>
<p>On the same compiler and hardware, we now get different numbers:</p>
<pre class="source-code">
Benchmark                 Time  UserCounters...
BM_positional_vars     50.8 ns  items_per_second=630.389M/s
BM_named_vars          49.4 ns  items_per_second=647.577M/s
BM_aggregate_vars      45.8 ns  items_per_second=647.349M/s</pre>
<p>We can see from the results that the compiler completely eliminated the overhead of the unnamed temporary object (or the named aggregate) and generated similarly performing code for all three ways to pass arguments into the function. In general, the result of the compiler optimizations is difficult to predict. For example, CLANG produces significantly different results (named argument calls are faster when most parameters are compile-time constants but slower when they are run-time values).</p>
<p>The benchmark <a id="_idIndexMarker487"/>does not favor any particular argument-passing mechanism. We can say that the named arguments idiom performs no worse than an explicitly named aggregate object or the equivalent positional parameters, at least, if the compiler were able to eliminate the unnamed temporary especially. On some compilers, the named arguments may be faster if the function has many arguments. If the optimization does not happen, the call may be a bit slower. On the other hand, in many cases the performance of the function call itself is not critical; for example, our cities are constructed only when the player builds one, a few times during the game. The day events are processed once per game day, which probably takes more than a few seconds of real-time, not least so the player can enjoy interacting with the game. On the other hand, the functions that are repeatedly called in performance-critical code should be inlined whenever possible, and we can expect better optimizations for argument passing in this case as well. Overall, we can conclude that, unless the performance of the particular function call is critical for program performance, one should not be concerned with the overhead of named arguments. For performance-critical calls, performance should be measured on a case-by-case basis, and it is possible for named arguments to be <a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>faster than positional ones.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor433"/>General method chaining</h1>
<p>Applications of <a id="_idIndexMarker488"/>method chaining in C++ are not limited to argument passing (we have already seen another application, although a well-hidden one, in the form of streaming I/O). For use in other contexts, it is helpful to consider some more gene<a id="_idTextAnchor434"/><a id="_idTextAnchor435"/>ral forms of method chaining.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor436"/>Method chaining versus method cascading</h2>
<p>The term <em class="italic">method cascading</em> is not often <a id="_idIndexMarker489"/>found in the context of C++, and for a good reason—C++ does not really support it. Method cascading refers to calling <a id="_idIndexMarker490"/>a sequence of methods on the <a id="_idIndexMarker491"/>same object. For example, in <em class="italic">Dart</em>, where method cascading is supported explicitly, we can write the following:</p>
<pre class="source-code">
var opt = Options();
opt.SetA()..SetB();</pre>
<p>This code first calls <code>SetA()</code> on the opt object, then calls <code>SetB()</code> on the same object. The equivalent code is this:</p>
<pre class="source-code">
var opt = Options();
opt.SetA()
opt.SetB();</pre>
<p>But wait, did we not just do the same with C++ and our options object? We did, but we skimmed over an important difference. In method chaining, the next method is applied to the result of the previous one. This is a chained call in C++:</p>
<pre class="source-code">
Options opt;
opt.SetA().SetB();</pre>
<p>This chained call is equivalent to the following code:</p>
<pre class="source-code">
Options opt;
Options&amp; opt1 = opt.SetA();
Options&amp; opt2 = opt1.SetB();</pre>
<p>C++ does not have the cascading syntax, but the code equivalent to a cascade would be this:</p>
<pre class="source-code">
Options opt;
opt.SetA();
opt.SetB();</pre>
<p>But this is exactly what we did earlier, and the short form was the same:</p>
<pre class="source-code">
Options opt;
opt.SetA().SetB();</pre>
<p>What makes the C++ cascading possible in this case is that the methods return the reference to the same object. We can still say that the equivalent code is this:</p>
<pre class="source-code">
Options opt;
Options&amp; opt1 = opt.SetA();
Options&amp; opt2 = opt1.SetB();</pre>
<p>And, it’s <a id="_idIndexMarker492"/>technically true. But, because of the <a id="_idIndexMarker493"/>way the methods are written, we have the additional guarantee that <code>opt</code>, <code>opt1</code>, and <code>opt2</code> all refer to the same object. Method cascading can always be implemented through method chaining, but it restricts the interfaces because all calls must return a reference to <code>this</code>. This implementation <a id="_idIndexMarker494"/>technique is sometimes called by the somewhat unwieldy name <code>*this</code> in C++). What can be accomplished wit<a id="_idTextAnchor437"/><a id="_idTextAnchor438"/>h more general chaining? Let’s see.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor439"/>General method chaining</h2>
<p>If the chained method does not return a reference to the object itself, it should return a new object. Usually, this object is of the same type, or at least a type from the same class hierarchy, if the <a id="_idIndexMarker495"/>methods are polymorphic. For example, let’s consider a class that implements data collection. It has a method to filter the data using a predicate (a callable object, an object with an <code>operator()</code> that returns <code>true</code> or <code>false</code>). It also has a method to sort the collection. Each of these methods creates a new collection object and leaves the original object intact. Now, if we want to filter all valid data in our collection, and assuming that we have an <code>is_valid</code> predicate object, we can create a sorted collection of valid data:</p>
<pre class="source-code">
Collection c;
... store data in the collection ...
Collection valid_c = c.filter(is_valid);
Collection sorted_valid_c = valid_c.sort();</pre>
<p>The intermediate object can be eliminated using method chaining:</p>
<pre class="source-code">
Collection c;
...
Collection sorted_valid_c = c.filter(is_valid).sort();</pre>
<p>It should be clear after reading the last section that this is an example of method chaining, and a <a id="_idIndexMarker496"/>more general one than what we saw earlier—each method returns an object of the same type, but not the same object. The difference between chaining and cascading is very clear in this example—a cascade of methods would filter and sort the original collection (assuming we<a id="_idTextAnchor440"/><a id="_idTextAnchor441"/> decided to support such operations).</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor442"/>Method chaining in class hierarchies</h2>
<p>When applied <a id="_idIndexMarker497"/>to class hierarchies, method chaining <a id="_idIndexMarker498"/>runs into a particular problem; let’s say that our <code>sort()</code> method returns a sorted data collection that is an object of a different type, <code>SortedCollection</code> , which is derived from the <code>Collection</code> class. The reason it is a derived class is that after sorting we can support efficient search, and so the <code>SortedCollection</code> class has a <code>search()</code> method that the base class does not have. We can still use method chaining, and even call the base class methods on the derived class, but doing so breaks the chain:</p>
<pre class="source-code">
// Example 05
class SortedCollection;
class Collection {
  public:
  Collection filter();
  // sort() converts Collection to SortedCollection.
  SortedCollection sort();
};
class SortedCollection : public Collection {
  public:
  SortedCollection search();
  SortedCollection median();
};
SortedCollection Collection::sort() {
  SortedCollection sc;
  ... sort the collection ...
  return sc;
}
Collection c;
auto c1 = c.sort().search().filter.median();</pre>
<p>In this example, the chaining <a id="_idIndexMarker499"/>worked for a while: we were <a id="_idIndexMarker500"/>able to sort a <code>Collection</code>, search the result, and filter the result of the search. The call to <code>sort()</code> operates on a <code>Collection</code> and returns a <code>SortedCollection</code>. The call to <code>search()</code> needs a <code>SortedCollection</code>, so it works as intended. The call to <code>filter()</code> needs a <code>Collection</code>; the method can be invoked on a derived class such as <code>SortedCollection</code>, but the return result is still going to be a <code>Collection</code>. Then the chain breaks: the call to <code>median()</code> needs a <code>SortedCollection</code>, which we have, except <code>filter()</code> effectively cast it back to a <code>Collection</code>. There is no way to tell median() that the object is really a <code>SortedCollection</code> (other than casting).</p>
<p>Polymorphism, or virtual functions, does not help here; first of all, we would need to define virtual functions for <code>search()</code> and <code>median()</code> in the base class, even though we don’t intend to support this functionality there, as only the derived class supports them. We cannot declare them pure virtual because we use the <code>Collection</code> as a concrete class, and any class with a pure virtual function is an abstract class, so objects of this class cannot be instantiated. We can make these functions abort at runtime, but at the very least we have moved the detection of a programming error—searching in an unsorted collection—from compile time to runtime. Worse, it does not even help:</p>
<pre class="source-code">
class SortedCollection;
class Collection {
  public:
  Collection filter();
  // Converts Collection to SortedCollection
  SortedCollection sort();
  virtual SortedCollection median();
};
class SortedCollection : public Collection {
  public:
  SortedCollection search();
  SortedCollection median() override;
};
SortedCollection Collection::sort() {
  SortedCollection sc;
  ... sort the collection ...
  return sc;
}
SortedCollection Collection::median() {
  cout &lt;&lt; "Collection::median called!!!" &lt;&lt; endl;
  abort();
  return {};     // Still need to return something
}
Collection c;
auto c1 = c.sort().search().filter().median();</pre>
<p>This is not going to work because <code>Collection::filter</code> returns a copy of the object, not a reference to it. The object it returns is the base class, <code>Collection</code>. If called on a <code>SortedCollection</code> object, it rips out the base class portion from the derived object and returns that. If you think that making <code>filter()</code> virtual as well, and overriding it in the derived class, solves this problem at the expense of overriding every function in the base class, you have another surprise coming—virtual functions must have identical return types, except for <em class="italic">covariant return types</em>. References to the base and derived classes are covariant return types. Classes themselves, returned by value, are not.</p>
<p>Note that this <a id="_idIndexMarker501"/>problem would not have happened if we were returning object references. However, we can only return references to <a id="_idIndexMarker502"/>the object we are called on; if we create a new object in the body of a method function and return a reference to it, it’s a dangling reference to a temporary object that is deleted the moment the function returns. The result is undefined behavior (the program is likely to crash). On the other hand, if we always return the reference to the original object, we cannot change its type from based to derived in the first place.</p>
<p>The C++ solution to this problem involves the use of templates and a curious design pattern. In fact, it is so mind-twisting that the word <em class="italic">curious</em> is even in its name—the Curiously Recurring Template Pattern. We have a whole chapter on the CRTP pattern in this book. The application of the pattern to our case is relatively straightforward—the base class needs to return the right type from its functions, but can’t because it does not know what the type is. The solution—pass the right type into the base class as the template argument. Of course, the base class would have to be a base class template for this to work:</p>
<pre class="source-code">
template &lt;typename T&gt; class Collection {
  public:
  Collection() {}
  T filter(); // "*this" is really a T, not a Collection
  T sort() {
    T sc; // Create new sorted collection
    ...
    return sc;
  }
};
class SortedCollection :
  public Collection&lt;SortedCollection&gt; {
  public:
  SortedCollection search();
  SortedCollection median();
};
Collection&lt;SortedCollection&gt; c;
auto c1 = c.sort().search().filter().median();</pre>
<p>The chain here <a id="_idIndexMarker503"/>starts similarly to our initial example: <code>sort()</code> is invoked on a <code>Collection</code> and returns a <code>SortedCollection</code>, then <code>search()</code> applies <a id="_idIndexMarker504"/>to the <code>SortedCollection</code> and returns another <code>SortedCollection</code>, then <code>filter()</code> is called. This time, <code>filter()</code> from the base class <code>Collection</code> knows what the real type of the object is because <code>Collection</code> itself is a template instantiated on the type of the derived object. So, <code>filter()</code> works on any collection but returns an object of the same type as the initial collection – in our case, both are <code>SortedCollection</code> objects. Finally, <code>median()</code> needs a <code>SortedCollection</code> and gets it.</p>
<p>This is a complex solution. While it works, its complexity suggests that method chaining should be used judiciously when the object type has to change in the middle of the chain. There is a good reason for that—changing the object type is fundamentally different than calling a sequence of methods. It is a more significant event that perhaps should be made explicit, and the new object should get its own name.</p>
<p>Now that we know what method chaining is, let us see where else it can be useful.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor443"/>The Builder pattern</h1>
<p>Let us go almost all the way back to the start of the chapter and take another look at the way we pass <a id="_idIndexMarker505"/>named arguments to a C++ function. Instead of a constructor with many arguments, we settled on an options object where each argument is explicitly named:</p>
<pre class="source-code">
City GreensDale(City::Options()
  .SetCenter(City::KEEP)
  .SetBuildings(3)
  .SetGuard(1)
  .SetForge()
);</pre>
<p>Let us now focus on the <code>Options</code> object itself, specifically, the way we construct it. The constructor does not create a finished object (that would just move the problem from the <code>City</code> constructor to the <code>Options</code> constructor). Instead, we build the object piece by piece. This is a particular case of a very general design pattern – the Builder.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor444"/>Basics of the Builder pattern</h2>
<p>The Builder design pattern is used whenever we decide that an object cannot be constructed in <a id="_idIndexMarker506"/>what we consider a complete state by the constructor alone. Instead, we write a helper class, or builder class, that builds these objects and hands them out to the program.</p>
<p>The first question you might ask is “Why?” – isn’t the constructor supposed to do exactly that job? There could be several reasons. One very common reason is that we use a more general object to represent some more specific data set. For example, we want an object that holds Fibonacci numbers or prime numbers, and we decided to use a <code>std::vector</code> to store them. Now we have a problem: the vector has whatever constructors the STL provides, but we need to ensure that our vector has the right numbers in it, and we can’t write a new constructor. We could create a special class to hold only prime numbers, but we will end up with a lot of classes that, after being constructed differently, are used in very similar ways. We would have to write new code to process prime numbers, odd numbers, square numbers, etc when using a vector for all of them would be perfectly sufficient. Alternatively, we could just use vectors everywhere and write the right values into them whenever our program needs it. This is no good too: we expose and duplicate a lot of low-level code that we would like to encapsulate and reuse (which is why we wanted a constructor for each kind of number).</p>
<p>The solution is the Builder pattern: the code for computing and storing the numbers is encapsulated in <a id="_idIndexMarker507"/>a builder class, but the object created by the builder is a generic vector. For example, here is a builder for Fibonacci numbers (the sequence of numbers that starts with 1, 1, and every subsequent number is a sum of the last two numbers):</p>
<pre class="source-code">
// Example 08
class FibonacciBuilder {
  using V = std::vector&lt;unsigned long&gt;;
  V cache_ { 1, 1, 2, 3, 5 };
  public:
  V operator()(size_t n) {
    while (cache_.size() &lt; n) {     // Cache new numbers
      cache_.push_back(cache_[cache_.size() - 1] +
                       cache_[cache_.size() - 2]);
    }
    return V{cache_.begin(), cache_.begin() + n};
  }
};</pre>
<p>Suppose our program needs to get sequences of the first <code>n</code> Fibonacci numbers for some algorithm (the value of <code>n</code> varies at run time). We may need these numbers more than once, sometimes for larger values of <code>n</code> than before and sometimes for smaller ones. All we need to do is to ask the builder:</p>
<pre class="source-code">
FibonacciBuilder b;
auto fib10 = b(10);</pre>
<p>We could keep the already known values somewhere in the program, but that complicates the program with the additional job of tracking them. It is better to move that work to a class dedicated to constructing Fibonacci numbers and nothing else - a builder. Is it worth it to cache Fibonacci numbers? Probably not really, but remember that this is a concise example: if we needed, say, prime numbers instead, reusing already known values would be very much worth it (but the code would be much longer).</p>
<p>The other common <a id="_idIndexMarker508"/>reason to use the builder is that the code necessary to build an object may be too complex for a constructor. Often, it manifests itself in the large number of arguments we would have to pass to a constructor if we tried to write one. The way we build the <code>Options</code> argument for our <code>City</code> at the start of this section is a trivial example of that, with the <code>Options</code> object acting as its own builder. Particular situations where builders are most useful include cases where the construction process is conditional and the data needed to fully construct an object varies in both the number and the type depending on some run-time variables. Again, our <code>City</code> is a trivial example of that: no single <code>City</code> needs every constructor argument, but without the <code>Options</code> and its (trivial) builder, we would have to provide a parameter for every one of them.</p>
<p>The approach we have seen for our Fibonacci vector builder is a common variant of the Builder pattern in C++; it’s not very exciting but it works. In this chapter, we are going to see some alternative ways to implement a Builder. The first one generalizes the way we built our <code>Options</code>.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor445"/>The fluent Builder</h2>
<p>The way we build the <code>Options</code> object is through method chaining. Each method takes a small step <a id="_idIndexMarker509"/>toward constructing the final object. There is a general <a id="_idIndexMarker510"/>name for this approach: the fluent interface. While it is not limited to designing builders, the fluent interface became popular in C++ mostly as a way to build complex objects.</p>
<p>The fluent builder relies on method chaining: each member function of the builder class contributes to constructing the object that is being built and returns the builder itself, so the work can continue. For example, here is an <code>Employee</code> class (possibly for some workplace database):</p>
<pre class="source-code">
// Example 09
class Employee {
  std::string prefix_;
  std::string first_name_;
  std::string middle_name_;
  std::string last_name_;
  std::string suffix_;
  friend class EmployeeBuilder;
  Employee() = default;
  public:
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const Employee&amp; e);
};</pre>
<p>We are going to <a id="_idIndexMarker511"/>add even more data to the class later, but already it has enough <a id="_idIndexMarker512"/>data members to make a single constructor hard to use (too many arguments of the same type). We could use a constructor with an <code>Options</code> object, but, going forward, we expect the need to do some computations during the construction of the object: we may need to validate certain data, and other parts of the employee record may be conditional: two fields that cannot be set at the same time, a field whose default value depends on other fields, etc. So let’s start designing a builder for this class.</p>
<p>The <code>EmployeeBuilder</code> needs to construct an <code>Employee</code> object first, then provide several chained methods to set different fields of the object, and, finally, hand over the constructed object. There may be some error checking involved, or more complex operations affecting other multiple fields, but a basic builder looks like this:</p>
<pre class="source-code">
// Example 09
class EmployeeBuilder {
  Employee e_;
  public:
  EmployeeBuilder&amp; SetPrefix(std::string_view s) {
    e_.prefix_ = s; return *this;
  }
  EmployeeBuilder&amp; SetFirstName(std::string_view s) {
    e_.first_name_ = s ; return *this;
  }
  EmployeeBuilder&amp; SetMiddleName(std::string_view s) {
    e_.middle_name_ = s; return *this;
  }
  EmployeeBuilder&amp; SetLastName(std::string_view s) {
    e_.last_name_ = s; return *this;
  }
  EmployeeBuilder&amp; SetSuffix(std::string_view s) {
    e_.suffix_ = s; return *this;
  }
  operator Employee() {
    assert(!e_.first_name_.empty() &amp;&amp;
           !e_.last_name_.empty());
    return std::move(e_);
  }
};</pre>
<p>Several design <a id="_idIndexMarker513"/>decisions had to be made along the way. First, we decided <a id="_idIndexMarker514"/>to make the constructor <code>Employee::Employee()</code> private, so only friends such as <code>EmployeeBuilder</code> can create these objects. This ensures that a partially initialized or otherwise invalid <code>Employee</code> object cannot appear in the program: the only way to get one is from a builder. This is usually the safer choice, but sometimes we need to be able to default-construct the objects (for example, to use them in containers or for many serialization/deserialization implementations). Second, the builder holds the object that is being built until it can be moved to the caller. This is the common approach, but we have to be careful to use each builder object only once. We could also provide a way to reinitialize the builder; this is often done when the builder needs to do a lot of computations whose results are reused for building multiple objects. Finally, in order to construct an <code>Employee</code> object, we need to construct a builder first:</p>
<pre class="source-code">
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
;</pre>
<p>The other common <a id="_idIndexMarker515"/>approach is to provide a static function <code>Employee::create()</code> that <a id="_idIndexMarker516"/>constructs a builder; in this case, the builder constructor is made private, with friends.</p>
<p>As we mentioned in the section on <em class="italic">Method chaining in class hierarchies</em>, the chained methods do not have to all return references to the same class. If our <code>Employee</code> object has an internal structure such as separate sub-records for the home address, job location, and so on, we could have a more structured approach to the builder as well.</p>
<p>The goal here is to design an interface so the client code could look like this:</p>
<pre class="source-code">
// Example 09
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
  .Job()
    .SetTitle("Safety Inspector")
    .SetOffice("Sector 7G")
  .Address()
    .SetHouse("742")
    .SetStreet("Evergreen Terrace")
    .SetCity("Springfield")
  .Awards()
    .Add("Remorseless Eating Machine")
;</pre>
<p>To do this, we need <a id="_idIndexMarker517"/>to implement a hierarchy of builders <a id="_idIndexMarker518"/>with a common base class:</p>
<pre class="source-code">
// Example 09
class JobBuilder;
class AwardBuilder;
class AbstractBuilder {
  protected:
  Employee&amp; e_;
  public:
  explicit AbstractBuilder(Employee&amp; e) : e_(e) {}
  operator Employee() {
    assert(!e_.first_name_.empty() &amp;&amp;
           !e_.last_name_.empty());
      return std::move(e_);
  }
  JobBuilder Job();
  AddressBuilder Address();
  AwardBuilder Awards();
};</pre>
<p>We still start with <code>EmployeeBuilder</code> which constructs the <code>Employee</code> object; the rest of the builders hold a reference to it, and, by calling the corresponding member function on <code>AbstractBuilder</code> we can switch to a different type of builder for the same <code>Employee</code> object. Note that, while <code>AbstractBuilder</code> serves as the base class for all other builders, there <a id="_idIndexMarker519"/>are no pure virtual functions (or any other virtual functions): as we <a id="_idIndexMarker520"/>have seen earlier, run-time polymorphism is not particularly useful in method chaining:</p>
<pre class="source-code">
class EmployeeBuilder : public AbstractBuilder {
  Employee employee_;
  public:
  EmployeeBuilder() : AbstractBuilder(employee_) {}
  EmployeeBuilder&amp; SetPrefix(std::string_view s){
    e_.prefix_ = s; return *this;
  }
  …
};</pre>
<p>To add the job information, we switch to the <code>JobBuilder</code>:</p>
<pre class="source-code">
// Example 09
class JobBuilder : public AbstractBuilder {
  public:
  explicit JobBuilder(Employee&amp; e) : AbstractBuilder(e) {}
  JobBuilder&amp; SetTitle(std::string_view s) {
    e_.title_ = s; return *this;
  }
  …
  JobBuilder&amp; SetManager(std::string_view s) {
    e_.manager_ = s; return *this;
  }
  JobBuilder&amp; SetManager(const Employee&amp; manager) {
    e_.manager_ = manager.first_name_ + " " +
                  manager.last_name_;
     return *this;
  }
  JobBuilder&amp; CopyFrom(const Employee&amp; other) {
    e_.manager_ = other.manager_;
    …
    return *this;
  }
};
JobBuilder AbstractBuilder::Job() {
  return JobBuilder(e_);
}</pre>
<p>Once we have a <code>JobBuilder</code>, all its chained methods return a reference to itself; of course, a <code>JobBuilder</code> is also an <code>AbstractBuilder</code>, so we could switch to another builder type such as <code>AddressBuilder</code> any time. Note that we can declare the <code>AbstractBuilder::Job()</code> method with just the forward declaration of the <code>JobBuilder</code>, but the implementation has to be deferred until the type itself is defined.</p>
<p>In this example, we also <a id="_idIndexMarker521"/>see the flexibility of the Builder pattern<a id="_idIndexMarker522"/> that would be very difficult to implement using constructors only. For example, there are two ways to define an employee’s manager: we can provide the name, or use another employee record. Also, we can copy the workplace information from another employee’s records, and still use <code>Set</code> methods to modify the fields that are not the same.</p>
<p>Other builders such as <code>AddressBuilder</code> are likely to be similar. But there may be very different builders as well. For example, an employee could have an arbitrary number of awards:</p>
<pre class="source-code">
// Example 09
class Employee {
  … name, job, address, etc …
  std::vector&lt;std::string&gt; awards_;
};</pre>
<p>The corresponding <a id="_idIndexMarker523"/>builder needs to reflect the nature of the information <a id="_idIndexMarker524"/>that it is adding to the object:</p>
<pre class="source-code">
// Example 09
class AwardBuilder : public AbstractBuilder {
  public:
  explicit AwardBuilder(Employee&amp; e) : AbstractBuilder(e)
  {}
  AwardBuilder&amp; Add(std::string_view award) {
    e_.awards_.emplace_back(award); return *this;
  }
};
AwardBuilder AbstractBuilder::Awards() {
  return AwardBuilder(e_);
}</pre>
<p>We can call <code>AwardBuilder::Add()</code> <a id="_idTextAnchor446"/>as many times as we need to build the particular <code>Employee</code> object.</p>
<p>Here is our builder in action. Note how, for different employees, we can use different ways to supply the required information:</p>
<pre class="source-code">
Employee Barry = EmployeeBuilder()
  .SetFirstName("Barnabas")
  .SetLastName("Mackleberry")
;</pre>
<p>We can use <a id="_idIndexMarker525"/>one employee record to add the manager’s name <a id="_idIndexMarker526"/>to another employee:</p>
<pre class="source-code">
Employee Homer = EmployeeBuilder()
  .SetFirstName("Homer")
  .SetMiddleName("J")
  .SetLastName("Simpson")
  .Job()
    .SetTitle("Safety Inspector")
    .SetOffice("Sector 7G")
    .SetManager(Barry) // Writes "Barnabas Mackleberry"
  .Address()
    .SetHouse("742")
    .SetStreet("Evergreen Terrace")
    .SetCity("Springfield")
  .Awards()
    .Add("Remorseless Eating Machine")
;</pre>
<p>We can copy employment records between employees:</p>
<pre class="source-code">
Employee Lenny = EmployeeBuilder()
  .SetFirstName("Lenford")
  .SetLastName("Leonard")
  .Job()
    .CopyFrom(Homer)
;</pre>
<p>Some of the fields, such as first and last name, are optional, and the builder checks the finished records for completeness before they can be accessed (see the <code>AbstractBuilder::operator Employee()</code> above). Other fields, such as name suffixes, are optional:</p>
<pre class="source-code">
Employee Smithers = EmployeeBuilder()
  .SetFirstName("Waylon")
  .SetLastName("Smithers")
  .SetSuffix("Jr") // Only when needed!
;</pre>
<p>The fluent builder <a id="_idIndexMarker527"/>is a powerful C++ pattern for constructing complex <a id="_idIndexMarker528"/>objects with many components, particularly when parts of the object are optional. However, it can get quite verbose for objects containing large amounts of highly structured data. There are alternatives, of course.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor447"/>The implicit builder</h2>
<p>We have already <a id="_idIndexMarker529"/>seen a case where the Builder pattern was employed without a dedicated builder object: all <code>Options</code> objects for named argument <a id="_idIndexMarker530"/>passing act as their own builders. We are going to see another version which is particularly interesting because there is no explicit builder object here. This design is particularly suitable for building nested hierarchical data such as XML files. We are going to demonstrate its use to build a (very simplified) HTML writer.</p>
<p>In this design, HTML records are going to be represented by the corresponding classes: a class for the <code>&lt;P&gt;</code> tag, another for the <code>&lt;UL&gt;</code> tag, and so on. All of these classes elaborate the common base class, <code>HTMLElement</code>:</p>
<pre class="source-code">
class HTMLElement {
  public:
  const std::string name_;
  const std::string text_;
  const std::vector&lt;HTMLElement&gt; children_;
  HTMLElement(std::string_view name, std::string_view text)
    : name_(name), text_(text) {}
  HTMLElement(std::string_view name, std::string_view text,
              std::vector&lt;HTMLElement&gt;&amp;&amp; children)
    : name_(name), text_(text),
      children_(std::move(children)) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
    const HTMLElement&amp; element);
};</pre>
<p>There is, of course, a lot more to an HTML element, but we have to keep things simple. Also, our base <a id="_idIndexMarker531"/>element allows unlimited nesting: any element can have a vector <a id="_idIndexMarker532"/>of child elements, each of which can have child elements, and so on. Printing of an element is, therefore, recursive:</p>
<pre class="source-code">
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const HTMLElement&amp; element) {
  out &lt;&lt; "&lt;" &lt;&lt; element.name_ &lt;&lt; "&gt;\n";
  if (!element.text_.empty())
    out &lt;&lt; "  " &lt;&lt; element.text_ &lt;&lt; "\n";
  for (const auto&amp; e : element.children_) out &lt;&lt; e;
  out &lt;&lt; "&lt;/" &lt;&lt; element.name_ &lt;&lt; "&gt;" &lt;&lt; std::endl;
  return out;
}</pre>
<p>Note that, in order to add child elements, we have to supply them in a <code>std::vector</code> which is then moved into the <code>HTMLElement</code> object. The rvalue reference means that the vector argument is going to be a temporary value or a result of <code>std::move</code>. However, we are not going to add the child elements to vectors ourselves: this is the job of the derived classes for the specific elements (<code>&lt;P&gt;</code>, <code>&lt;UL&gt;</code>, etc). The specific element classes can prevent the addition of child elements when the syntax does not allow it, as well as enforce other restrictions on the fields of an HTML element.</p>
<p>What do these specific classes look like? The simpler ones are going to look like this:</p>
<pre class="source-code">
class HTML : public HTMLElement {
  public:
  HTML() : HTMLElement("html", "") {}
  HTML(std::initializer_list&lt;HTMLElement&gt; children) :
    HTMLElement("html", "", children) {};
};</pre>
<p>This <code>HTML</code> class represents the <code>&lt;html&gt;</code> tag. Classes such as <code>Body</code>, <code>Head</code>, <code>UL</code>, <code>OL</code>, and many more, are written exactly the same way. The class <code>P</code> for the <code>&lt;P&gt;</code> tag is similar except it does <a id="_idIndexMarker533"/>not allow nested objects, so it has only one <a id="_idIndexMarker534"/>constructor that takes the text argument. It is very important that these classes do not add any data members; they must initialize the base <code>HTMLElement</code> object and nothing else. The reason should be obvious if you look at the base class again: we store a vector of <code>HTMLElement</code> child objects. However, they were constructed – as <code>HTML</code> or as <code>UL,</code> or as anything else – they are only <code>HTMLElement</code> objects now. Any extra data is going to be lost.</p>
<p>You may also notice that the vector parameter of the <code>HTMLElement</code> constructor is initialized from a <code>std::initializer_list</code> argument. This conversion is done implicitly by the compiler from the list of the constructor arguments:</p>
<pre class="source-code">
// Example 10
auto doc = HTML{
  Head{
    Title{"Mary Had a Little Lamb"}
  },
  Body{
    P{"Mary Had a Little Lamb"},
    OL{
      LI{"Its fleece was white as snow"},
      LI{"And everywhere that Mary went"},
      LI{"The lamb was sure to go"}
    }
  }
};</pre>
<p>This statement begins with a call to construct an <code>HTML</code> object using two arguments. They are <code>Head</code> and <code>Body</code> objects, but they get converted to <code>HTMLElement</code> and put into <code>std::initializer_list&lt;HTMLElement&gt;</code> by the compiler. The list is then used to initialize a vector, which is moved into the <code>children_</code> vector in the <code>HTML</code> object. Both <code>Head</code> and <code>Body</code> objects themselves have child objects, one of which (<code>OL</code>) has its own child objects.</p>
<p>Note it gets <a id="_idIndexMarker535"/>a little tricky if you want to have additional constructor <a id="_idIndexMarker536"/>arguments because you cannot mix regular arguments with initializer list elements. This problem happens, for example, with the <code>LI</code> class. The straightforward way to implement this class, based on what we learned so far, is as follows:</p>
<pre class="source-code">
//Example 10
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  LI(std::string_view text,
     std::initializer_list&lt;HTMLElement&gt; children) :
    HTMLElement("li", text, children) {}
};</pre>
<p>Unfortunately, you can’t call this constructor with something like this:</p>
<pre class="source-code">
//Example 10
LI{"A",
  UL{
    LI{"B"},
    LI{"C"}
  }
}</pre>
<p>It seems obvious <a id="_idIndexMarker537"/>that what the programmer wanted <a id="_idIndexMarker538"/>is for the first argument to be <code>"A"</code> and the second argument (and any more arguments, if we had them) should go into the initializer list. But that doesn’t work: generally, to form an initializer list, we have to enclose the element sequence in braces <code>{…}</code>. Only when the entire argument list matches an initializer list can these braces be omitted. With some arguments not being part of the initializer list, we have to be explicit:</p>
<pre class="source-code">
//Example 10
LI{"A",
  {UL{        // Notice { before UL!
    LI{"B"},
    LI{"C"}
  }}            // And closing } here
}</pre>
<p>If you don’t want to write the extra braces, you have to change the constructor slightly:</p>
<pre class="source-code">
//Example 11
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  template &lt;typename ... Children&gt;
  LI(std::string_view text, const Children&amp;... children) :
    HTMLElement("li", text,
           std::initializer_list&lt;HTMLElement&gt;{children...})
  {}
};</pre>
<p>Instead of using <a id="_idIndexMarker539"/>an initializer list parameter, we use a parameter pack and explicitly convert it to an initializer list (which is then converted to a vector). Of course, the parameter <a id="_idIndexMarker540"/>pack will accept an arbitrary number of arguments of any type, not just <code>HTMLElement</code> and its derived classes, but the conversion to the initializer list will fail. If you want to follow the practice that any template that did not fail to instantiate should not produce compilation errors in its body, you have to restrict the types in the parameter pack to classes derived from <code>HTMLElement</code>. This is easily done using C++20 concepts:</p>
<pre class="source-code">
// Example 12
class LI : public HTMLElement {
  public:
  explicit LI(std::string_view text) :
    HTMLElement("li", text) {}
  LI(std::string_view text,
     const std::derived_from&lt;HTMLElement&gt;
     auto&amp; ... children) :
    HTMLElement("li", text,
           std::initializer_list&lt;HTMLElement&gt;{children...})
  {}
};</pre>
<p>If you don’t use C++20 but still want to restrict the parameter types, you should read the <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a>, <em class="italic">SFINAE, Concepts, and Overload Resolution Management</em> in this book.</p>
<p>With the parameter <a id="_idIndexMarker541"/>pack used as an intermediary for constructing <a id="_idIndexMarker542"/>an initializer list, we can avoid the extra braces and write our HTML document like this:</p>
<pre class="source-code">
// Examples 11, 12
auto doc = HTML{
  Head{
    Title{"Mary Had a Little Lamb"}
  },
  Body{
    P{"Mary Had a Little Lamb"},
    OL{
      LI{"Its fleece was white as snow"},
      LI{"And everywhere that Mary went"},
      LI{"The lamb was sure to go"}
    },
    UL{
      LI{"It followed her to school one day"},
      LI{"Which was against the rules",
        UL{
          LI{"It made the children laugh and play"},
          LI{"To see a lamb at school"}
        }
      },
      LI{"And so the teacher turned it out"}
    }
  }
};</pre>
<p>This does look like an application of the Builder pattern: even though the final construction is done by a single call to the HTMLElement constructor, that constructor just moves the <a id="_idIndexMarker543"/>already constructed vector of child elements into its final location. The actual construction is done in steps like all builders do. But where is the builder object? There isn’t one, not explicitly. Part of the builder functionality is provided by all <a id="_idIndexMarker544"/>the derived objects, such as <code>HTML</code>, <code>UL</code>, etc. They may look like they represent the corresponding HTML constructs, but they really don’t: after the entire document is constructed, we only have <code>HTMLElement</code> objects. The derived objects are used only to build the document. The rest of the builder code is generated by the compiler when it does all the implicit conversions between parameter packs, initializer lists, and vectors. By the way, any half-decent optimizing compiler is going to get rid of all the intermediate copies and copy the input strings straight into the final vector where they are going to be stored.</p>
<p>Of course, this is a very simplified example, and for any practical use, we would need to store more data with HTML elements and give the programmer a way to initialize this data. We could combine the implicit builder approach with the fluent interface to provide an easy way to add optional values such as style, type, etc, to all <code>HTMLElement</code> objects.</p>
<p>By now you have seen three distinct Builder designs: there is the “traditional” builder with a single builder object, the fluent builder that employs method chaining, and the implicit builder that uses many small builder helper objects and relies heavily on compiler-generated code. There are other designs, but they are mostly variants and combinations of th<a id="_idTextAnchor448"/>e approaches you have learned. Our study of the Builder pattern has drawn to a close.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor449"/>Summary</h1>
<p>Yet again, we have seen the power of C++ to essentially create a new language out of the existing one; C++ does not have named function arguments, only positional ones. That is part of the core language. And yet, we were able to extend the language and add support for named arguments in a reasonable-looking way, using the method chaining technique. We have also explored the other applications of method chaining beyond the named arguments idiom.</p>
<p>One of these applications, the fluent builder, is again an exercise in creating new languages: the power of the fluent interface, in general, is that it can be used to create domain-specific languages to execute sequences of instructions on some data. And so the fluent builder can be used to allow the programmer to describe the construction of objects as a sequence of steps that are familiar in a particular domain. Then, of course, there is the implicit builder that (with the right indents) even makes C++ code look a bit like the HTML document that is being built.</p>
<p>The next chapter introduces the only purely performance-oriented idiom in this book. We have discussed in several chapters the performance cost of memory allocation, and its impact on the implementation of several patterns. The next idiom, local buffe<a id="_idTextAnchor450"/>r<a id="_idTextAnchor451"/> optimization, attacks the problem head-on, by avoiding memory allocation altogether.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor452"/>Questions</h1>
<ol>
<li value="1">Why do functions with many arguments of the same or related types lead to fragile code?</li>
<li>How do aggregate argument objects improve code maintainability and robustness?</li>
<li>What is the named argument idiom and how does it differ from aggregate arguments?</li>
<li>What is the difference between method chaining and cascading?</li>
<li>What is the Builder pattern?</li>
<li>What is the fluent interface and when is it used?</li>
</ol>
</div>
</body></html>