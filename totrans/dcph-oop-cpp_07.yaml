- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Dynamic Binding through Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will further extend our knowledge of object-oriented programming
    in C++. We will begin by introducing a powerful OO concept, **polymorphism**,
    and then understand how this idea is implemented in C++ through *direct language
    support*. We will implement polymorphism using virtual functions in hierarchies
    of related classes, and understand how we can achieve runtime binding of a specific
    derived class method to a more generic, base class operation. We will understand
    how the OO concept of polymorphism presented in this chapter will support versatile
    and robust designs and easily extensible code in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of polymorphism and why it is important to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining virtual functions, understanding how virtual functions override base
    class methods (or halt the overriding process with the `final` specifier), generalizing
    derived class objects, the need for virtual destructors, as well as understanding
    function hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand dynamic (runtime) binding of methods to operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed understanding of the **virtual function table** (v-table)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of polymorphism,
    and how to implement this idea in C++ through virtual functions. You will understand
    how virtual functions enable the runtime binding of methods to operations in C++.
    You will see how an operation can be specified in a base class and overridden
    with a preferred implementation in a derived class. You will understand when and
    why it is important to utilize a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how instances of derived classes are often stored using base class
    pointers and why this is significant. We will discover that, regardless of how
    an instance is stored (as its own type or as that of a base class), the correct
    version of a virtual function will always be applied through dynamic binding.
    Specifically, you will see how runtime binding works under the hood as we examine
    virtual function pointers and virtual function tables in C++.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the direct language support of polymorphism in C++ using virtual
    functions, you will be on your way to creating an extensible hierarchy of related
    classes, featuring dynamic binding of methods to operations. Let us augment our
    understanding of C++ as an OOP language by detailing these ideals.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter07](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter07).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter07`
    in a file named `Chp7-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3QQUGxg](https://bit.ly/3QQUGxg).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce an essential object-oriented concept, polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: From [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in
    Detail*, and [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing Hierarchies
    with Single Inheritance*, you now understand the key OO ideas of encapsulation,
    information hiding, generalization, and specialization. You know how to encapsulate
    a class, how to build inheritance hierarchies using single inheritance, and the
    various reasons to build hierarchies (such as supporting Is-A relationships or
    for the lesser-used reason of supporting implementation inheritance). Let’s begin
    by extending our basic OO terminology by exploring **polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a base class specifies an operation such that a derived class may redefine
    the operation in its class with a more suitable method, the operation is said
    to be **polymorphic**. Let’s revisit our definitions of **operation** and **method**,
    as well as their implications, to understand how these concepts lay the groundwork
    for polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, an **operation** maps to the complete signature of the member function
    (name plus type and number of arguments – no return type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, in C++, a **method** maps to the definition or body of the operation
    (that is, the implementation or body of the member function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that in OO terms, an **operation** implements a behavior of a class.
    The implementation of a base class operation may be via several distinct derived
    class **methods**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Student` *Is-A* `Person`. Yet, a polymorphic operation will allow `Student`
    behaviors to be revealed on `Student` objects, even when they have *taken on the
    form* of a `Person`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this chapter, we will see derived class objects taking
    on the form of their public base classes, that is, taking on *many forms* (**polymorphism**).
    We will see how a polymorphic operation can be specified in a base class and overridden
    with a preferred implementation in a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at the C++ language feature that allows us to implement
    polymorphism, namely, virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing polymorphism with virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism allows dynamic binding of a method to an operation. Dynamic, or
    runtime, binding of a method to an operation is important because derived class
    instances may be pointed to by base class objects (that is, by pointers of a base
    class type). In these situations, the pointer type does not provide adequate information
    regarding the correct method that should be applied to the referenced instance.
    We need another way – one done at runtime – to determine which method applies
    to each instance.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is the case that a pointer to an instance of a derived class type
    will be generalized as a pointer to the base class type. When an operation is
    applied to the pointer, the correct method for what the object truly is should
    be applied, rather than the method that *seems* appropriate for the generalized
    pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the relevant keywords and logistics necessary to define virtual
    functions so that we may implement polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Defining virtual functions and overriding base class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Virtual functions** in C++ directly support polymorphism. A **virtual function**
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A member function that correctly allows methods for a given operation to be
    overridden successively in a hierarchy to provide more suitable definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member function that allows dynamic, rather than the usual static, binding
    for methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A virtual function is specified using the keyword **virtual** with the following
    nuances:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `virtual` should precede the return type of the function in its
    prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in the derived class with the same name and signature of a virtual
    function in any ancestor class redefine the virtual function in those base classes.
    Here, the keyword `virtual` is optional in the derived class prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally and preferred, the keyword `override` can be added as part of the
    extended signature in the derived class prototype. This recommended practice will
    allow the compiler to flag an error if the signature of the intended overridden
    method does not match the signature as specified in the base class. The `override`
    keyword can eliminate unintended function hiding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with the same name, yet a different signature in a derived class,
    do not redefine a virtual function in their base class; rather, they hide the
    methods found in their base classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the keyword `final` can be added as part of the extended signature
    of a virtual function prototype if the virtual function in question is not intended
    to be further overridden in a derived class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derived class need not redefine virtual functions specified in its base
    class if the inherited methods are suitable. However, should a derived class redefine
    an operation with a new method, the same signature (as specified by the base class)
    must be used for the overridden method. Furthermore, derived classes should only
    redefine virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Print()` is a virtual function defined in the base class `Person`. It will
    be overridden with a more appropriate implementation in the `Student` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the base class `Person`, introduces a virtual function, `Print()`. By
    labeling this function as `virtual`, the `Person` class is inviting any future
    descendants to redefine this function with a more suitable implementation or method,
    should they be so motivated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual function defined in the base class `Person` is, in fact, overridden
    with a more appropriate implementation in the `Student` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice here that the derived class `Student` introduces a new implementation
    of `Print()` that will override (that is, replace), the definition in `Person`.
    Note that if the implementation of `Person::Print()` were acceptable to `Student`,
    `Student` would not be obligated to override this function, even if it is marked
    as `virtual` in the base class. The mechanics of public inheritance would simply
    allow the derived class to inherit this method.
  prefs: []
  type: TYPE_NORMAL
- en: But because this function is `virtual` in `Person`, `Student` may opt to redefine
    this operation with a more suitable method. Here, it does. In the `Student::Print()`
    implementation, `Student` first calls `Person::Print()` to take advantage of the
    aforementioned base class function, then prints additional information itself.
    `Student::Print()` is choosing to call a base class function for help; it is not
    required to do so if the desired functionality can be implemented fully within
    its own class scope.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when `Student::Print()` is defined to override `Person::Print()`,
    the same signature as specified by the base class is used. This is important.
    Should a new signature have been used, we would get into a potential function
    hiding scenario, which we will soon discuss in our *Considering function hiding*
    subsection within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that though the virtual functions in `Person` and `Student` are written
    inline, a virtual function will almost never be expanded as inline code by the
    compiler since the specific method for the operation must be determined at runtime.
    A very few cases exist for compiler devirtualization, involving final methods
    or knowing an instance’s dynamic type; such rare cases would allow a virtual function
    to be inlined.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, polymorphic functions are meant to have the ability to override or
    replace base class versions of a given function. Function overriding differs from
    function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Important distinction
  prefs: []
  type: TYPE_NORMAL
- en: '**Function overriding** is defined by introducing the same function name with
    the same signature in a hierarchy of related classes (via virtual functions),
    whereas the derived class version is meant to replace the base class version.
    In contrast, **function overloading** is defined when two or more functions with
    the same name, but with different signatures, exist in the same scope of the program
    (such as in the same class).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, operations not initially specified as virtual when introduced
    in a base class definition are not polymorphic and, therefore, should not be overridden
    in any derived class. This means that if a base class does not use the keyword
    `virtual` when defining an operation, the base class does not intend for the derived
    class to redefine this operation with a more suitable derived class method. The
    base class instead is insisting that the implementation it has provided is suitable
    for *any* of its descendants. Should the derived class attempt to redefine a non-virtual
    base class operation, a subtle bug will be introduced into the application. The
    error will be that derived class instances stored using derived class pointers
    will use the derived class method, yet derived class instances stored using base
    class pointers will use the base class definition. Instances should always use
    their own behavior irrespective of how they are stored – this is the point of
    polymorphism. Never redefine a non-virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Operations not specified in a base class as virtual in C++ are not polymorphic,
    and should never be overridden by a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward and discover scenarios when we may want to collect derived
    class objects by a base class type, and when we may then need to qualify our destructors
    as virtual.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing derived class objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we view an inheritance hierarchy, it is typically one that employs public
    base classes; that is, it is a hierarchy that utilizes public inheritance to express
    Is-A relationships. When using inheritance in this manner, we may be motivated
    to collect groups of related instances together. For example, a hierarchy of `Student`
    specializations might include `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    Assuming each of these derived classes has a public base class of `Student`, it
    would be appropriate to say a `GraduateStudent` *Is-A* `Student`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We may find a reason in our application to group these *somewhat-like* instances
    together into one common set. For example, imagine that we are implementing a
    billing system for a university. The university may wish for us to collect all
    students, regardless of their derived class types, into one set to process them
    uniformly, so as to calculate their semester bills.
  prefs: []
  type: TYPE_NORMAL
- en: The `Student` class may have a polymorphic operation to `CalculateSemesterBill()`,
    which is implemented as a virtual function in `Student` with a default method.
    However, selected derived classes, such as `GraduateStudent`, may have preferred
    implementations that they wish to provide by overriding the operation in their
    own class with a more appropriate method. A `GraduateStudent`, for example, may
    have a different method to compute their total bill versus a `NonDegreeStudent`.
    Hence, each derived class may override the default implementation of `CalculateSemesterBill()`
    in each of their classes.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, in our bursar application, we can create a set of pointers of type
    `Student`, though each pointer will inevitably point to instances of the derived
    class types, such as `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    When instances of derived class types have been generalized in this fashion, it
    is appropriate to apply functions (often virtual) to the set as defined in the
    base class level corresponding to the pointer type of the collection. Virtual
    functions allow these generalized instances to invoke a polymorphic operation
    to yield their individual derived class methods or implementations of these functions.
    This is exactly what we want. But, there are still more details to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This basic premise of generalizing derived class instances will allow us to
    understand why we may need virtual destructors within many of our class definitions.
    Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing virtual destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now can conceptualize situations when grouping derived class instances into
    a *somewhat-like* set stored by their common base class type may be useful. It
    is actually very powerful to collect sibling type derived class instances by their
    base class type and employ virtual functions to allow their distinct behaviors
    to shine through.
  prefs: []
  type: TYPE_NORMAL
- en: But, let’s consider what happens when the memory for a derived class instance
    stored by a base class pointer goes away. We know its destructor is called, but
    which one? We actually know that a chain of destructors is called, starting with
    the destructor of the object type in question. But how do we know the actual derived
    class object type if the instance has been genericized by being stored using a
    base class pointer? A **virtual destructor** solves this issue.
  prefs: []
  type: TYPE_NORMAL
- en: By labeling a destructor as `virtual`, we are allowing it to be overridden as
    the *starting point* in the destruction sequence for a class and any of its descendants.
    The choice as to which destructor to use as the entry point of destruction will
    be deferred to runtime using dynamic binding, based on the object’s actual type,
    not what the pointer type may be that references it. We will soon see how this
    process is automated by examining C++’s underlying virtual function table.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual destructor, unlike all other virtual functions, actually specifies
    the starting point for a full sequence of functions to be executed. Recall that
    as the last line of code in a destructor, the compiler automatically patches in
    a call to call the immediate base class destructor, and so on, until we reach
    the initial base class in the hierarchy. The destruction chain exists to provide
    a forum to release dynamically allocated data members in all subobjects of a given
    instance. Contrasting this behavior to other virtual functions, those merely allow
    the single, correct version of the function to be executed (unless the programmer
    chooses to call a base class version of the same function as a helper function
    during the derived method implementation).
  prefs: []
  type: TYPE_NORMAL
- en: You may ask why it is important to start the destruction sequence at the proper
    level. That is, starting at the level that matches the object’s actual type (versus
    a generalized pointer type that may point to the object). Recall that each class
    may have dynamically allocated data members. The destructor will deallocate these
    data members. Starting with the correct level destructor will ensure that you
    do not introduce any memory leaks into your application by forgoing appropriate
    destructors and their corresponding memory deallocations.
  prefs: []
  type: TYPE_NORMAL
- en: Are virtual destructors always necessary? That is a good question! Virtual destructors
    are always necessary when using a public base class hierarchy, that is, when using
    public inheritance. Recall that public base classes support Is-A relationships,
    which easily lead to allowing a derived class instance to be stored using a pointer
    of its base class type. For example, a `GraduateStudent` *Is-A* `Student`, so
    we can store a `GraduateStudent` as a `Student` in times when we require more
    generic processing along with its sibling types. We can always upcast in this
    fashion across a public inheritance boundary. However, when we use implementation
    inheritance (that is, private or protected base classes), upcasting is not allowed.
    So, for hierarchies employing private or protected inheritance, virtual destructors
    are not necessary because upcasting is simply disallowed; hence, it would never
    be ambiguous as to which destructor should be the entry point for classes in private
    and protected base class hierarchies. As a second example, we did not include
    a virtual destructor in our `LinkedList` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Single Inheritance*; therefore, `LinkedList` should
    only be extended as a protected or private base class. We did, however, include
    a virtual destructor in our `Queue` and `PriorityQueue` classes because `PriorityQueue`
    uses `Queue` as a public base class. A `PriorityQueue` may be upcast to a `Queue`
    (but not to a `LinkedList`), necessitating the virtual destructor introduction
    at the `Queue` and its descendent levels in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Are the optional keywords `virtual` and `override` recommended when overriding
    a virtual destructor? Those are also good questions. We know that an overridden
    destructor is only the starting point in the destruction sequence. We also know
    that, unlike other virtual functions, the derived class destructor will have a
    unique name from the base class destructor. Even though a derived class destructor
    automatically overrides a base class destructor that has been declared as `virtual`,
    the usage of the *optional* keyword `override` is recommended in the derived class
    destructor prototype for documentation. However, the usage of the *optional* keyword
    `virtual` in the derived class destructor is generally no longer used. The reasoning
    is that the `override` keyword is meant to provide a safety net to catch spelling
    mistakes between originally defined and overridden functions. With destructors,
    the function names are not the same, hence this safety net is not an error-checking
    advantage, but more documentative.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by putting all the necessary pieces together so we can see virtual
    functions of all varieties, including destructors, in action.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all the pieces together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we have understood the nuances of virtual functions,
    including virtual destructors. It is important to see our code in action with
    all its various components and details. We need to see in one cohesive program
    the basic syntax to specify virtual functions, including how we may collect derived
    class instances by base class types, and see how virtual destructors play a role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a more complex, full program example to fully illustrate
    polymorphism, implemented using virtual functions in C++. This example will be
    broken into many segments; the full program can be found in the following GitHub
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter07/Chp7-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter07/Chp7-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definition, we have augmented our familiar class
    for `Person`, adding four virtual functions, namely, the destructor (`~Person()`),
    `Print()`, `IsA()`, and `Greeting(const string &)`. Notice that we have simply
    placed the keyword `virtual` in front of the return type (if any) of each member
    function. The remainder of the class definition is as we have explored in depth
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the non-inline member function definitions for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have specified all of the non-inline member
    functions of `Person`. Notice that the four virtual functions – the destructor,
    `Print()`, `IsA()`, and `Greeting()` – do not include the `virtual` keyword in
    the methods (that is, member function definitions) themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s examine the `Student` class definition and its inline functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition for `Student`, we again have all of the assorted
    components we are accustomed to seeing to comprise this class. Additionally, notice
    that we have overridden and redefined three virtual functions – the destructor,
    `Print()`, and `IsA()` – using the keyword `override`. These preferred definitions
    essentially replace or override the default methods specified for these operations
    in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that we choose not to redefine `void Person::Greeting(const
    string &)`, which was introduced as a virtual function in the `Person` class.
    Simply inheriting this method is fine if we find the inherited definition acceptable
    for instances of the `Student` class. Furthermore, notice the additional qualification
    on `Print()` with the `final` qualifier. This keyword indicates that `Print()`
    may not be overridden in derived classes from `Student`; the method overridden
    at the `Student` level will be the final implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the meaning of `override`, when paired with a destructor, is unique,
    in that it does not imply that the derived class destructor replaces the base
    class destructor. Instead, it means that the derived class (virtual) destructor
    is the correct beginning point for the *chain of destruction* sequence when initiated
    by derived class instances (irrespective of how they are stored). The virtual
    derived class destructor is merely the entry point for the complete destruction
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Also remember, the derived class of `Student` is not required to override a
    virtual function that is defined in `Person`. Should the `Student` class find
    the base class method acceptable, it is automatically inherited. Virtual functions
    merely allow the derived class to redefine an operation with a more appropriate
    method when so needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s examine the non-inline `Student` class member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed section of code, we list the non-inline member function
    definitions for `Student`. Again, notice that the keyword `override` will not
    appear in any of the virtual member function definitions themselves, only in their
    respective prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let’s examine the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we declare an array of pointers to `Person`. Doing so, allows
    us to collect both `Person` and `Student` instances in this set. Of course, the
    only operations we may apply to instances stored in this generalized fashion are
    those found in the base class, `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate several `Person` and several `Student` instances, storing
    each instance via an element in the generalized set of pointers. When a `Student`
    is stored in this fashion, an upcast to the base class type is performed (but
    the instance is not altered in any fashion). Recall that when we looked at memory
    layout for derived class instances in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Single Inheritance*, we noticed that a `Student`
    instance first includes the memory layout of a `Person`, followed by the additional
    memory required for `Student` data members. This upcast merely points to the starting
    point of this collective memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we proceed through a loop to apply operations as found in the `Person`
    class to all instances in this generalized collection. These operations happen
    to be polymorphic. That is, the virtual functions allow the specific implementation
    for methods to be called through runtime binding to match the actual object type
    (irrespective of the fact that the object may be stored in a generalized pointer).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`
    and `Student`, again using the generalized `Person` pointers. Because we know
    `delete()` will patch in a call to the destructor, we wisely have made the destructors
    `virtual`, enabling dynamic binding to choose the appropriate starting destructor
    (in the destruction chain) for each object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at the output for the aforementioned program, we can see that
    the specific method for each object is appropriately called for each virtual function,
    including the destruction sequence. Derived class objects have both the derived,
    then base class destructor invoked and executed. Here is the output for the full
    program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have competency utilizing the concept of polymorphism and the mechanics
    of virtual functions, let’s take a look at a less usual situation relating to
    virtual functions, that of function hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Considering function hiding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Function hiding** is not an often-used feature of C++. In fact, it is often
    employed quite by accident! Let’s review a key point we know about inherited member
    functions to get started. When an operation is specified by a base class, it is
    intended to provide a protocol for usage and redefinition (in the case of virtual
    functions) for all derived class methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a derived class will alter the signature of a method that is intended
    to redefine an operation specified by a base class (let’s think of virtual functions).
    In this case, the new function, which differs in signature from the operation
    specified in its ancestor class, will not be considered a virtual redefinition
    of the inherited operation. In fact, it will *hide* inherited methods for the
    virtual function that have the same name specified in ancestor classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When programs are compiled, the signature of each function is compared against
    the class definition for correct usage. Typically, when a member function is not
    found in the class that *seemingly* matches the instance type, the hierarchy is
    traversed in an upward fashion until such a match is found or until the hierarchy
    is exhausted. Let us take a closer look at what the compiler contemplates:'
  prefs: []
  type: TYPE_NORMAL
- en: When a function is found with the same name as the function being sought out,
    the signature is examined to see whether it matches the function call exactly,
    or if type conversion can be applied. When the function is found, but type conversion
    cannot be applied, the normal traversal sequence is ended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that hide virtual functions normally halt this upward search sequence,
    thus hiding a virtual function that otherwise may have been invoked. Recall that
    at compile time, we are just checking syntax (not deciding which version of a
    virtual function to call). But if we can’t find a match, an error is flagged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function hiding is actually considered helpful and was intended by the language.
    If the class designer provided a specific function with a given signature and
    interface, that function should be used for instances of that type. Hidden or
    unsuspected functions above in the hierarchy should not be used in this specific
    scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following modification to our previous full program example to,
    first, illustrate function hiding, and then provide a more flexible solution for
    managing function hiding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the `Person` class introduces `virtual void Print()` with no parameters.
    Imagine that `Student`, instead of overriding `Print()` with the same signature,
    changes the signature to `virtual void Print(const char *)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the signature of `Print()` has changed from base to derived class.
    The derived class function does not redefine the `virtual void Print();` of its
    base class. It is a new function that will in fact hide the existence of `Person::Print()`.
    This is actually what was intended, since you may not recall that the base class
    offers such an operation, and tracking upward might cause surprising results in
    your application if you intended `Print(const string &)` to be called but `Print()`
    is called instead. By adding this new function, the derived class designer is
    dictating this interface is the appropriate `Print()` for instances of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: However, nothing is straightforward in C++. For situations where a `Student`
    is upcast to a `Person`, the `Person::Print()` with no arguments will be called.
    The `Student::Print(const string &)` is not a virtual redefinition because it
    does not have the same signature. Hence, the `Person::Print()` will be called
    for generalized `Student` instances. And yet `Student::Print(const string &)`
    will be called for `Student` instances stored in `Student` variables. Unfortunately,
    this is inconsistent with how an instance will behave if it is stored in its own
    type versus a generalized type. Though function hiding was meant to work in this
    fashion, it may inevitably not be what you would like to happen. Programmers,
    beware!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the cumbersome code that might ensue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit downcasting or use of the scope resolution operator may be required
    to reveal an otherwise hidden function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the aforementioned example, we have a generalized set of two `Person` pointers.
    One entry points to a `Person` and one entry points to a `Student`. Once the `Student`
    is generalized, the only applicable operations are those found in the `Person`
    base class. Therefore, a call to `people[1]->Print();` works and a call to `people[1]->Print("Go
    Team!");` does not work. The latter call to `Print(const char *)` is an error
    at the generalized base class level, even though the object truly is a `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, from a generalized pointer, we wish to call specific functions found at
    the `Student` level in the hierarchy, we will then need to downcast the instance
    back to its own type (`Student`). We add a downcast with the call: `(dynamic_cast<Student
    *> (people[1]))->Print("I have to study");`. Here, we are taking a risk – if `people[1]`
    was actually a `Person` and not a `Student`, this would generate a runtime error.
    However, by first checking the result of the dynamic cast to `Student *` prior
    to invoking `Print()`, we can ensure we have made an appropriate cast.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate `Student s1;`. Should we try to call `s1.Print()`, we get
    a compiler error – `Student::Print(const string &)` hides the base class presence
    of `Person::Print()`. Remember, `s1` is stored in its own type, `Student`, and
    since `Student::Print(const string &)` is found, the traversal upward to otherwise
    uncover `Person::Print()` is halted.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, our call to `s1.Print("I got an A!");` is successful because `Print(const
    string &)` is found at the `Student` class level. Lastly, notice that the call
    to `s1.Person::Print();` works but requires knowledge of the otherwise hidden
    function. By using the scope resolution operator (`::`), we can find the base
    class version of `Print()`. Even though `Print()` is virtual in the base class
    (implying dynamic binding), using the scope resolution operation reverts this
    call to a statically bound function call.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s propose that we would like to add a new interface to a derived class with
    a function that would otherwise hide a base class function. Knowing about function
    hiding, what should we ideally do? We could simply override the virtual function
    as found in the base class with a new method in the derived class, and then we
    could overload that function to add the additional interface. Yes, we’re now both
    overriding and overloading. That is, we are overriding the base class function,
    and overloading the overridden function in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what we would now have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the more flexible interface to add the new member function while keeping
    the existing interface that would otherwise be hidden:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code fragment, the `Student` class both overrides `Person::Print()`
    with `Student::Print()` and overloads `Student::Print()` with `Student::Print(const
    string &)` to envelop the additional desired interface. Now, for `Student` objects
    stored in `Student` variables, both interfaces are available – the base class
    interface is no longer hidden. Of course, `Student` objects referenced by `Person`
    pointers only have the `Person::Print()` interface, which is to be expected.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, function hiding does not surface often, but when it does, it is often
    an unwelcome surprise. Now you understand what may happen and why, which helps
    in making you a better programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at all the uses surrounding virtual functions, let’s
    look under the hood to see why virtual functions are able to support dynamic binding
    of a specific method to an operation. To thoroughly understand runtime binding,
    we will need to look at the v-table. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how polymorphism is implemented with virtual functions
    to allow for dynamic binding of an operation to a specific implementation or method,
    let’s understand why virtual functions allow for runtime binding.
  prefs: []
  type: TYPE_NORMAL
- en: Non-virtual functions are statically bound at compile time. That is, the address
    of the function in question is determined at compile time, based on the assumed
    type of the object at hand. For example, if an object is instantiated of type
    `Student`, a function call would have its prototype verified starting with the
    `Student` class, and if not found, the hierarchy would be traversed upward to
    each base class, such as `Person`, to look for the matching prototype. When found,
    the correct function call would be patched in. This is how static binding works.
  prefs: []
  type: TYPE_NORMAL
- en: However, a virtual function is a type of function in C++ that employs a dynamic
    binding at runtime. At compile time, any virtual function call is merely replaced
    with a lookup mechanism to delay binding until runtime. Certainly, each compiler
    vendor may differ in their implementation of automating virtual functions. However,
    there is a widely utilized implementation that involves virtual function pointers,
    a virtual function table, and virtual function table entries for each object type
    containing virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to investigate how dynamic binding is commonly implemented
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending runtime binding of methods to operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that virtual functions allow for dynamic binding of an operation (specified
    in a base class) to a specific implementation or method (often specified in a
    derived class). How does this work?
  prefs: []
  type: TYPE_NORMAL
- en: When a base class specifies one or more new virtual functions (not just redefinitions
    of an ancestor’s virtual functions), a **virtual function pointer** (**vptr**)
    is created below the memory comprising a given instance of that type. This happens
    at runtime when the memory for an instance is created (on the stack, heap, or
    static/extern area). When the instance in question is constructed, not only will
    the appropriate constructor be called to initialize the instance, but this vptr
    will be initialized to point to the **virtual function pointer table** (**v-table**)
    entry for that class type.
  prefs: []
  type: TYPE_NORMAL
- en: The v-table entry for a given class type will consist of a set of function pointers.
    These function pointers are often organized into an array of function pointers.
    A **function pointer** is a pointer to an actual function. By dereferencing this
    pointer, you will actually invoke the function to which the pointer points. There
    is an opportunity to pass arguments to the function, however, in order for this
    call to be generic through a function pointer, the arguments must be uniform for
    any version of this function that the pointer in question may point to. The premise
    of a function pointer gives us the ability to point to different versions of a
    particular function. That is, we could point to different methods for a given
    operation. This is the basis for which we can automate dynamic binding in C++
    for virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the particular v-table entry for a specific object type. We know
    that this table entry will consist of a set of function pointers, such as an array
    of function pointers. The order in which these function pointers are arranged
    will be consistent with the order in which the virtual functions are newly introduced
    by a given class. Functions overriding existing virtual functions that were newly
    introduced at a higher level in the hierarchy will simply replace table entries
    with preferred versions of functions to be called, but will not cause an additional
    entry to be allocated in the array of function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: So, when the program begins running first in global memory (as a hidden external
    variable), a v-table will be set up. This table will contain entries for each
    object type that contains virtual functions. The entry for a given object type
    will contain a set of function pointers (such as an array of function pointers)
    that organizes and initializes the dynamically-bound functions for that class.
    The specific order of the function pointers will correspond to the order in which
    the virtual functions were introduced (possibly by their ancestor class), and
    the specific function pointers will be initialized to the preferred versions of
    these functions for the specific class type in question. That is, the function
    pointers may point to overridden methods as specified at their own class level.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when an object of a given type is instantiated, the vptr within that object
    (there will be one per subobject level of newly introduced – not redefined – virtual
    functions) will be set to point to the corresponding v-table entry for that instance.
  prefs: []
  type: TYPE_NORMAL
- en: It will be useful to see this detail with code and a memory diagram. Let’s look
    under the hood to see the code in action!
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the v-table in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to detail the memory model and see the underlying C++ mechanics that
    will be set up at runtime, let’s consider our detailed, full program example from
    this section with base class `Person` and derived class `Student`. As a reminder,
    we will show the key elements of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abbreviated definitions of the `Person` and `Student` classes (we’ll omit the
    data members and most member function definitions to save space):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Person` and `Student` class definitions are as expected. Assume that the
    data members and member functions are as shown in the full program example. For
    brevity, we have just included the virtual functions introduced or redefined at
    each level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting key elements of our `main()` function in abbreviated form (reduced
    to three instances):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice in our `main()` function that we instantiate one `Person` instance and
    two `Student` instances. All are stored in a generic array of pointers of the
    base class type, `Person`. We then iterate through the set calling virtual functions
    on each instance, namely `IsA()`, `Print()`, `Greeting()`, and the destructor
    (which is implicitly called when we delete each instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the memory model for the previous example, we have the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Memory model for the current example ](img/Figure_7.01_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Memory model for the current example
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned memory diagram (which follows the preceding program),
    notice that we have an array of pointers to the genericized instances of `Person`.
    The first instance is, in fact, a `Person`, and the second two instances are of
    type `Student`. But, as a `Student` *Is-A* `Person`, it is acceptable to upcast
    a `Student` to a `Person`. The top part of the memory layout is in fact, a `Person`
    for each of the `Student` instances. For instances that are in fact of type `Student`,
    the additional data members for `Student` will follow all the memory required
    for the `Person` subobject.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `vptr` entries immediately follow the data members for the `Person`
    object (or subobject) for each of the three instances. The location for the `vptr`
    is the same offset from the top of each object. This is because the virtual functions
    in question are all introduced at the `Person` level in the hierarchy. Some may
    be overridden in the `Student` class with more appropriate definitions for `Student`,
    but the level in which each is introduced is at the `Person` level, hence the
    `vptr` below the `Person` object (or subobject) will reflect a pointer to the
    list of operations introduced at the `Person` level.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, let’s say that `Student` introduced wholly new virtual functions
    (and not merely redefinitions of existing virtual functions), such as we saw in
    the previous function hiding scenario. There would then be a second `vptr` entry
    below the `Student` subobject with those additional (new virtual) operations added.
  prefs: []
  type: TYPE_NORMAL
- en: When each object is instantiated, first the appropriate constructors (proceeding
    up the hierarchy) will be called for each instance. Additionally, the compiler
    will patch in a pointer assignment for each instance’s `vptr` to be set to the
    `v-table` entry corresponding to the object’s type. That is, when a `Person` is
    instantiated, its `vptr` will point to the `v-table` entry for `Person`. When
    a `Student` is instantiated, its `vptr` will point to the `v-table` entry for
    `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that the `v-table` entry for `Person` or `Student` contains an
    array of function pointers to the appropriate virtual functions for that type.
    The `v-table` entry for each type actually has more information embedded, such
    as the size of an instance of that type, and so on. To simplify, we will just
    look at the portion of the `v-table` entries that automate the dynamic binding
    for each class type.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `v-table` entry for `Person` is an array of four function pointers.
    Each function pointer will point to the most suitable version of the destructor,
    `Print()`, `IsA()`, and `Greeting()` for a `Person`. The order in which these
    function pointers occur corresponds to the order in which these virtual functions
    were introduced by this class. That is, `vptr[0]` will point to the `Person` destructor,
    `vptr[1]` will point to `Person::Print()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the v-table entry for `Student`. The order in which the virtual
    functions (as function pointers) are laid into the array is the same order as
    for the `Person` class. This is because the base class introduced these functions
    and the ordering in this array of pointers is set by that level. But notice that
    the actual functions that are pointed to have been overridden for `Student` instances
    to mostly be methods that were redefined by the derived class, `Student`. That
    is, the `Student` destructor is specified (as the starting point for destruction),
    followed by `Student::Print()`, then `Student::IsA()`, and then `Person::Greeting()`.
    Notice that `vptr[3]` points to `Person::Greeting()`. This is because `Student`
    did not redefine this function in its class definition; `Student` found the `Person`
    definition, which is inherited, to be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing this memory diagram with the code in our `main()` function, notice that
    after we instantiate a `Person` and two `Student` instances, storing each in the
    genericized `Person` array of pointers, we iterate through a loop containing several
    operations. We uniformly call `people[i]->Print();`, then `people[i]->IsA();`,
    then `people[i]->Greeting("Hello");`, and then `delete people[i];` (which patches
    in a destructor call).
  prefs: []
  type: TYPE_NORMAL
- en: Because each of these functions is virtual, the decision as to which function
    should be called is deferred to be looked up at runtime. This is done by accessing
    each instance’s hidden `vptr` member, indexing into the appropriate `v-table`
    entry based on the operation at hand, and then dereferencing the function pointer
    found at that entry to call the appropriate method. The compiler knows, for example,
    that `vptr[0]` will be the destructor, `vptr[1]` will be the next virtual function
    introduced in the base class definition, and so on, so that the element position
    in the v-table that should be activated is easily determined by the name of the
    polymorphic operation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that a call in `main()` to `people[i]->Print();` was replaced with `*(people[i]->vptr[1])();`,
    which is the syntax for dereferencing a function pointer to call the function
    at hand. Notice that we are first accessing which function using `people[i]->vptr[1]`,
    then dereferencing the function pointer using `*`. Notice the parentheses `()`at
    the end of the statement, which is where any parameters would be passed to the
    function. Because the code to dereference the function pointer needs to be uniform,
    the parameters to any such function must also be uniform. That is why any virtual
    functions overridden in a derived class must use the same signature as specified
    by the base class. It all makes sense when you look under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We have now thoroughly examined the OO idea of polymorphism and how it is implemented
    in C++ using virtual functions. Let’s briefly recap what we’ve covered in this
    chapter before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have moved even further along our journey with object-oriented
    programming by understanding how virtual functions in C++ provide direct language
    support for the OO idea of polymorphism. We have seen how virtual functions provide
    dynamic binding of a specific method to an operation in our inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how, using virtual functions, an operation specified by a base
    class can be overridden by a derived class, providing a more suitable implementation.
    We have seen that the correct method for each object can be selected using runtime
    binding, regardless of whether the object is stored in its own type or in a generalized
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that objects are often generalized using base class pointers and
    how this can allow the uniform processing of related derived class types. We have
    seen that, regardless of how an instance is stored (as its own type or as that
    of a base class using a pointer), the correct version of a virtual function will
    always be applied through dynamic binding. We have seen that in public inheritance
    hierarchies where upcasting may be routinely done, having a virtual destructor
    is essential.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how dynamic binding works through examining a typical compiler
    implementation of embedding a vptr into instances, and how these pointers reference
    v-table entries (containing sets of member function pointers) relevant to each
    object type.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that virtual functions allow us to take advantage of dynamic binding
    of operations to the most appropriate methods, enabling us to use C++ as an OOP
    language to implement robust designs featuring polymorphism, which promotes easily
    extensible code.
  prefs: []
  type: TYPE_NORMAL
- en: By extending our OOP knowledge with the utilization of virtual functions, we
    can now move forward to include additional object-oriented concepts and details
    relating to inheritance and polymorphism. Continuing to [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*, we will next learn how to employ the OO ideal of
    abstract classes, along with all the assorted OOP considerations surrounding this
    next object-oriented concept. Let’s continue!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using your [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing Hierarchies
    with Single Inheritance*, solution, augment your inheritance hierarchy to further
    specialize `Student` with `GraduateStudent` and `NonDegreeStudent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add necessary data members to your `GraduateStudent` class. Data members to
    consider might be *dissertation topic* or *graduate advisor*. Include appropriate
    constructors (default, alternate, and copy), a destructor, access member functions,
    and a suitable public interface. Be sure to place your data members in the private
    access region. Do the same for `NonDegreeStudent`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add polymorphic operations to `Person`, `Student`, `GraduateStudent`, and `NonDegreeStudent`
    as necessary. Introduce at the `Person` level virtual functions `IsA()` and `Print()`.
    Override `IsA()` and `Print()` in your derived classes as necessary. It may be
    that you override `IsA()` in `Student` and `GraduateStudent`, but choose to override
    `Print()` only in the `Student()` class. Be sure to include virtual destructors
    in each of your classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate `Student`, `GraduateStudent`, `NonDegreeStudent`, and `Person` several
    times and utilize the appropriate `public` interfaces on each. Be sure to dynamically
    allocate several instances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array of pointers to `Person` and allocate instances of `Person`,
    `Student`, `GraduateStudent`, and `NonDegreeStudent` to be members of this array.
    Once generalized, only call polymorphic operations that are found at the `Person`
    level (and other public methods of `Person`). Be sure to delete any dynamically
    allocated instances.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array of pointers to `Student` and allocate only instances of `GraduateStudent`
    and `NonDegreeStudent` to be members of this array. Now, call operations that
    are found at the `Student` level to be applied to these generalized instances.
    Additionally, utilize operations found at the `Person` level – they are inherited
    and additionally available for generalized `Student` instances. Be sure to delete
    any dynamically allocated instances pointed to in your array.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
