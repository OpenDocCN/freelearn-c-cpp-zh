<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.2.1">Vulkan Core Concepts</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our goal for this chapter is to implement a simple program that displays a shaded triangle on screen, with the triangle’s vertices and attributes being sourced directly from the shaders. </span><span class="koboSpan" id="kobo.3.2">In the process of implementing the code to render this triangle, we will cover most of Vulkan’s fundamental objects, the ones you need to create a very simple application. </span><span class="koboSpan" id="kobo.3.3">Although the code required for this minimal example is extensive, the majority of it can be reused and tweaked for other applications. </span><span class="koboSpan" id="kobo.3.4">By the end of the chapter, you will know how to bootstrap communication with the driver, how to create and manage basic Vulkan objects, and how to issue rendering commands to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, following a brief introduction to the Vulkan API, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Calling </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">API functions</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Vulkan objects</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Using Volk to load Vulkan functions </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and extensions</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">extensions correctly</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using the Validation Layer for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">error checking</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Enumerating available </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">instance layers</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Enumerating available </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">instance extensions</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Initializing the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Vulkan instance</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">a surface</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Enumerating Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">physical devices</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Caching the properties of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">queue families</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Enumerating physical </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">device extensions</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Reserving </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">queue families</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Creating a Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">logical device</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Retrieving the queue </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">object handle</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">command pool</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Allocating, recording, and </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">submitting commands</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Reusing </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">command buffers</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">render passes</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.45.1">Creating framebuffers</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">image views</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">The Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">graphics pipeline</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">Compiling </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.51.1">shaders </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">to SPIR-V</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Dynamic states</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">graphics pipeline</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Swapchain</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">Understanding synchronization in the swapchain – fences </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">and semaphores</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Populating submission information </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">for presentation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.61.1">Presenting images</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">a triangle</span></span></li>
</ul>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.64.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.65.1">To successfully run the code featured in this and rest of chapters, your system must meet the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">following requirements:</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">A Windows computer equipped with a GPU that supports Vulkan 1.3. </span><span class="koboSpan" id="kobo.67.2">We recommend having a machine with at least 16 GB of RAM and a modern graphics card. </span><span class="koboSpan" id="kobo.67.3">The code for various chapters was tested with GTX 1080, GTX 1060, RTX 3050, and RTX 4060. </span><span class="koboSpan" id="kobo.67.4">Please note that </span><a href="B18491_07.xhtml#_idTextAnchor299"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.69.1">, Ray Tracing and Hybrid Rendering</span></em><span class="koboSpan" id="kobo.70.1">, requires RTX 3050/4060 series card since it demonstrates use of </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">ray tracing.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">To get started, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.74.1">Download and Install Vulkan SDK 1.3.268: Visit the LunarG website at </span><a href="https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe"><span class="koboSpan" id="kobo.75.1">https://sdk.lunarg.com/sdk/download/1.3.268.0/windows/VulkanSDK-1.3.268.0-Installer.exe</span></a><span class="koboSpan" id="kobo.76.1"> and download the Vulkan SDK 1.3.268 installer. </span><span class="koboSpan" id="kobo.76.2">Run the installer to complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">installation process.</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">Install Python 3.12: Download the latest version of Python 3.12 from the official Python website and follow the installation </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">instructions provided.</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">Clone the Repository: Ensure you have Git installed on your computer. </span><span class="koboSpan" id="kobo.80.2">If not, download and install Git from </span><a href="https://git-scm.com/downloads"><span class="koboSpan" id="kobo.81.1">https://git-scm.com/downloads</span></a><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">Once Git is installed, open a command prompt or terminal and execute git clone </span><a href="https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook"><span class="koboSpan" id="kobo.83.1">https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook</span></a><span class="koboSpan" id="kobo.84.1"> to clone </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the repository.</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">Open the Project in Visual Studio 2022: Launch Visual Studio 2022. </span><span class="koboSpan" id="kobo.86.2">Navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">File</span></strong><span class="koboSpan" id="kobo.88.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Open</span></strong><span class="koboSpan" id="kobo.90.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">Folder</span></strong><span class="koboSpan" id="kobo.92.1"> and select the folder where you cloned the repository. </span><span class="koboSpan" id="kobo.92.2">This action will load the project into </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">Visual Studio.</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">Build the Project: Within Visual Studio, you can choose to build the project for debugging or release. </span><span class="koboSpan" id="kobo.94.2">For learning purposes and when making changes to the code, it’s recommended to use the </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Debug</span></strong><span class="koboSpan" id="kobo.96.1"> build configuration. </span><span class="koboSpan" id="kobo.96.2">This allows you to step through the code and understand its execution flow. </span><span class="koboSpan" id="kobo.96.3">For simply running the executables, you can use the </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Release</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.98.1">build configuration.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.99.1">The project is structured to facilitate easy navigation and understanding of the code examples provided in each chapter. </span><span class="koboSpan" id="kobo.99.2">Here’s a detailed guide on how to locate and work with </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the code:</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The project is organized into several key directories, each serving a </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">specific purpose:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">source/chapterX</span></strong><span class="koboSpan" id="kobo.104.1">: This directory contains the main source code for each chapter. </span><span class="koboSpan" id="kobo.104.2">Replace X with the chapter number you are working on. </span><span class="koboSpan" id="kobo.104.3">For example, the source code for this chapter is located </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">source/chapter1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">source/vulkancore</span></strong><span class="koboSpan" id="kobo.109.1">: This directory is dedicated to the Vulkan specific code and components. </span><span class="koboSpan" id="kobo.109.2">It includes utilities, wrappers, and other Vulkan related functionalities that are used throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the project.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">source/enginecore</span></strong><span class="koboSpan" id="kobo.112.1">: This directory houses the core engine components that are shared across multiple chapters. </span><span class="koboSpan" id="kobo.112.2">These components provide foundational functionality that is reused in various parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">the project.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.114.1">The recipe for this chapter can be run by launching </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Chapter01_Traingle.exe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1"> executable.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.117.1">Getting to know the Vulkan API</span></h1>
<p><span class="koboSpan" id="kobo.118.1">The Vulkan API, introduced in 2016 by the Khronos Group, is a low-overhead, cross-platform </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.119.1">computing API that is the successor to OpenGL and its variants (WebGL and OpenGL ES). </span><span class="koboSpan" id="kobo.119.2">In fact, Vulkan was called </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Next Generation OpenGL</span></strong><span class="koboSpan" id="kobo.121.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">glNext</span></strong><span class="koboSpan" id="kobo.123.1">) before it </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.124.1">was officially named Vulkan. </span><span class="koboSpan" id="kobo.124.2">OpenGL has been around since 1992 and it was the de facto introductory graphics API everyone learned (and learns still today). </span><span class="koboSpan" id="kobo.124.3">Allied with its simplicity, OpenGL is ubiquitous </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">even today.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">So, how is Vulkan different from OpenGL? </span><span class="koboSpan" id="kobo.126.2">It starts with its complexity. </span><span class="koboSpan" id="kobo.126.3">Vulkan is intended to provide application authors more control over the graphics hardware so that they can implement a solution that caters to their needs. </span><span class="koboSpan" id="kobo.126.4">Applications can implement solutions as simple as they want or as complex as they need. </span><span class="koboSpan" id="kobo.126.5">In practice, this means that the application is now responsible for controlling the hardware, making it more complex. </span><span class="koboSpan" id="kobo.126.6">The drivers, on the other hand, became simpler. </span><span class="koboSpan" id="kobo.126.7">For instance, if an application is really concerned about resource management, it can implement its own resource management algorithms and not rely on the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">driver’s implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">In short, Vulkan offers more fine-grained control over the GPU compared to OpenGL due to its </span><em class="italic"><span class="koboSpan" id="kobo.129.1">lower-level</span></em><span class="koboSpan" id="kobo.130.1"> nature. </span><span class="koboSpan" id="kobo.130.2">It empowers applications to handle tasks that were traditionally managed by graphics drivers, such as initiating communication between the application and the hardware. </span><span class="koboSpan" id="kobo.130.3">However, this increased control comes with added complexity. </span><span class="koboSpan" id="kobo.130.4">Vulkan abstracts a large part of the GPU-specific implementation, allowing the same code to run on a wide range of GPUs. </span><span class="koboSpan" id="kobo.130.5">While it is possible to use device-specific extensions to maximize the computation potential of a particular GPU, these are not necessities but optional choices to optimize performance. </span><span class="koboSpan" id="kobo.130.6">In both desktop and mobile environments, managing this complexity to make optimal use of the GPU can be challenging due to the vast array </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">of possibilities.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.132.1">Calling API functions</span></h1>
<p><span class="koboSpan" id="kobo.133.1">Due to the </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.134.1">many knobs Vulkan provides to control every little thing that the hardware can do, Vulkan tends to be more verbose than OpenGL. </span><span class="koboSpan" id="kobo.134.2">Since the control of every single aspect of the rendering process is now exposed to the application, there is simply more information that needs to be communicated with the graphics driver (mind you, the graphics driver still exists; it’s just simpler than it used </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">to be).</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">The most prominent pattern used by the Vulkan API is structure-as-parameter. </span><span class="koboSpan" id="kobo.136.2">It is used for creating and allocating objects, querying their capabilities and information, describing layouts, and much more. </span><span class="koboSpan" id="kobo.136.3">In this pattern, instead of passing all possible values for the creation of an object as parameters of a function, you must stick all that information in a structure provided by the Vulkan SDK and then pass that structure as a parameter to </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">In this recipe, you will learn how Vulkan functions are expected to be called and how to check their </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">return value.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.140.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.141.1">Creating objects </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.142.1">in Vulkan requires you to fill an instance of a special structure (there’s one for each object you would like to create) and pass it to the creation function, which takes a pointer to a variable that will store the object’s handle upon return. </span><span class="koboSpan" id="kobo.142.2">Most functions in the API return a result that can be used to detect errors, and it’s usually a very good idea to do so to catch errors as soon </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">as possible.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.144.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.145.1">This recipe will show how to create a Vulkan sampler (</span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">VkSampler</span></strong><span class="koboSpan" id="kobo.147.1">) by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">vkCreateSampler</span></strong><span class="koboSpan" id="kobo.149.1"> function and how you can create a macro that can be used to check the return value of Vulkan function calls without repeating the same code over and </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">over again.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.151.1">The following code demonstrates how to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">VkSampler</span></strong><span class="koboSpan" id="kobo.153.1"> sampler, a Vulkan object that dictates how a texture is sampled in </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">a shader.</span></span></li>
<li><span class="koboSpan" id="kobo.155.1">Before calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">vkCreateSampler</span></strong><span class="koboSpan" id="kobo.157.1"> function that creates the sampler, you need to fill a structure called </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">VkSamplerCreateInfo</span></strong><span class="koboSpan" id="kobo.159.1"> with all the parameters you’d like the new sampler </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">to have.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.161.1">In the example, we are setting its minification and magnification filter types, how the texture coordinates are treated before sampling the texture, and everything else that Vulkan allows to be controlled in an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">this type:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.163.1">
VkDevice device;
const VkSamplerCreateInfo samplerInfo = {
      .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
      .magFilter = VK_FILTER_LINEAR,
      .minFilter = VK_FILTER_LINEAR,
      .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .mipLodBias = 0,
      .anisotropyEnable = VK_FALSE,
      .minLod = 0,
      .maxLod = maxLod,
  };
VkSampler sampler = VK_NULL_HANDLE;
const VkResult result = vkCreateSampler(device, &amp;samplerInfo, nullptr, &amp;sampler);
assert(result == VK_SUCCESS);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.164.1">Another </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.165.1">interesting thing about this pattern is that besides instantiating the right type of structure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">VkSamplerCreateInfo</span></strong><span class="koboSpan" id="kobo.167.1"> in this example), we also need to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">sType</span></strong><span class="koboSpan" id="kobo.169.1"> member to the correct value that matches the type of structure being used (</span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</span></strong><span class="koboSpan" id="kobo.171.1"> in the snippet). </span><span class="koboSpan" id="kobo.171.2">This property is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">VkStructureType</span></strong><span class="koboSpan" id="kobo.173.1"> declared by the Vulkan SDK. </span><span class="koboSpan" id="kobo.173.2">If you use the wrong value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">sType</span></strong><span class="koboSpan" id="kobo.175.1">, you won’t get a compilation error, and maybe not even a runtime error. </span><span class="koboSpan" id="kobo.175.2">Maybe not even an error at all! </span><span class="koboSpan" id="kobo.175.3">Well, at least not while running it on your development machine. </span><span class="koboSpan" id="kobo.175.4">As soon as someone else tries your code on their device, then it could crash. </span><span class="koboSpan" id="kobo.175.5">Luckily, there is a mechanism that helps us detect this kind of mistake at runtime. </span><span class="koboSpan" id="kobo.175.6">It’s called the Validation Layer, and we’re going to talk more about it in </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">this chapter.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.177.1">The last thing to notice about the listing is that while creating objects in Vulkan, the handle to the object is not returned from the function but is stored in a pointer </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.178.1">passed to the function. </span><span class="koboSpan" id="kobo.178.2">In our preceding example, the handle to the new sampler will be stored in the variable sampler (the last parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">vkCreateSampler</span></strong><span class="koboSpan" id="kobo.180.1"> function). </span><span class="koboSpan" id="kobo.180.2">That’s why we’re passing the address of the local variable to </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">the function.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.182.1">The reason for that is that most functions in the API return a result denoting whether the operation was successful or not. </span><span class="koboSpan" id="kobo.182.2">In most cases, checking the return value, of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">VkResult</span></strong><span class="koboSpan" id="kobo.184.1">, against </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">VK_SUCCESS</span></strong><span class="koboSpan" id="kobo.186.1"> is fine (and displaying a message on screen or terminating), but in a few cases, the result may not represent an irrecoverable error but a situation that needs to be rectified before we </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">can continue.</span></span></p></li> <li><span class="koboSpan" id="kobo.188.1">This pattern is so common that we use a simple utility macro that checks the return value. </span><span class="koboSpan" id="kobo.188.2">If the result is anything different than </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">VK_SUCCESS</span></strong><span class="koboSpan" id="kobo.190.1">, it prints a message, along with the stringified error code, and asserts. </span><span class="koboSpan" id="kobo.190.2">Check </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">it out:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.192.1">
#define VK_CHECK(func)                                \
  {                                                   \
    const VkResult result = func;                     \
    if (result != VK_SUCCESS) {                       \
      std::cerr &lt;&lt; "Error calling function " &lt;&lt; #func \
                &lt;&lt; " at " &lt;&lt; __FILE__ &lt;&lt; ":"          \
                &lt;&lt; __LINE__ &lt;&lt; ". </span><span class="koboSpan" id="kobo.192.2">Result is "         \
                &lt;&lt; string_VkResult(result)            \
                &lt;&lt; std::endl;                         \
      assert(false);                                  \
    }                                                 \
  }</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.193.1">Vulkan objects </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.194.1">are created almost always the same way: by providing their attributes in a structure, calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">create</span></strong><span class="koboSpan" id="kobo.196.1"> function, and providing a pointer to store the handle to the newly created object. </span><span class="koboSpan" id="kobo.196.2">Most functions return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">VkResult</span></strong><span class="koboSpan" id="kobo.198.1"> value that can be used to check whether the function succeeded </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">or not.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.200.1">Learning about Vulkan objects</span></h1>
<p><span class="koboSpan" id="kobo.201.1">The Vulkan API is extensive and many times larger than OpenGL (in any way you’d like to measure). </span><span class="koboSpan" id="kobo.201.2">Nonetheless, only a handful of very important objects are necessary to write many types </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.202.1">of applications. </span><span class="koboSpan" id="kobo.202.2">As mentioned at the beginning of this chapter, the Vulkan API was leveled against the most demanding applications, those that need to control every single minute detail of the hardware to extract the maximum performance. </span><span class="koboSpan" id="kobo.202.3">But most applications don’t need all that flexibility and can get by with just </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">basics</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">In this recipe, you will learn what Vulkan objects are and how they relate to </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">each other.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.208.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.209.1">Objects in </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.210.1">Vulkan are opaque handles, and their types begin with the letters </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Vk</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">A Vulkan instance is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">VkInstance</span></strong><span class="koboSpan" id="kobo.214.1">, a Vulkan device is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">VkDevice</span></strong><span class="koboSpan" id="kobo.216.1">, and so on. </span><span class="koboSpan" id="kobo.216.2">Some objects need an instance of other objects to be created or allocated from. </span><span class="koboSpan" id="kobo.216.3">This dependency creates an implicit logical sequence as to object creation. </span><span class="koboSpan" id="kobo.216.4">A Vulkan physical device, </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">VkPhysicalDevice</span></strong><span class="koboSpan" id="kobo.218.1">, which represents a GPU on the </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.219.1">system, can only be created if a Vulkan instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">VkInstance</span></strong><span class="koboSpan" id="kobo.221.1">, already exists. </span><span class="koboSpan" id="kobo.221.2">The next section will present a diagram that may be helpful in understanding Vulkan’s capabilities and </span><em class="italic"><span class="koboSpan" id="kobo.222.1">when</span></em><span class="koboSpan" id="kobo.223.1"> objects may </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">be created.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.225.1">How to do it…</span></h2>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.226.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.227.1">.1</span></em><span class="koboSpan" id="kobo.228.1"> is a summary of what we consider the most important objects in Vulkan; the ones that we cover in this book and that will satisfy most graphics applications. </span><span class="koboSpan" id="kobo.228.2">They are also the bare minimum for a simple – but flexible – </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">pr</span><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.230.1">ogram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer005">
<span class="koboSpan" id="kobo.231.1"><img alt="Figure 1.1 – Object dependency in Vulkan" src="image/B18491_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.232.1">Figure 1.1 – Object dependency in Vulkan</span></p>
<ol>
<li><span class="koboSpan" id="kobo.233.1">In the preceding diagram, each node is a Vulkan object with its name on the top half and its </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.234.1">Vulkan type in the bottom half. </span><span class="koboSpan" id="kobo.234.2">The diagram also encodes the dependency between the objects, explicit and implicit. </span><span class="koboSpan" id="kobo.234.3">The arrows connecting objects denote what an object needs to be created (besides their parameters, which are not </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">depicted there).</span></span></li>
<li><span class="koboSpan" id="kobo.236.1">Solid arrows are explicit dependencies: an object needs a reference to all objects pointed by the arrows leaving its node. </span><span class="koboSpan" id="kobo.236.2">For example, a device needs a reference to a physical device to be created; a buffer view needs a reference to a buffer and the device. </span><span class="koboSpan" id="kobo.236.3">Dashed arrows indicate implicit dependencies: a queue object needs a reference to a device, but it doesn’t explicitly need a reference to a physical device, only a queue index to a family of queues, which is obtained from a physical device. </span><span class="koboSpan" id="kobo.236.4">It doesn’t need a physical device, but it needs something that is provided </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">by one.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Solid lines with an open arrow at the end denote objects that are allocated from others, generally a pool of those types of objects. </span><span class="koboSpan" id="kobo.238.2">A command buffer isn’t created; it is allocated from a command pool (which in turn needs to be created at </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">some point).</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">This diagram is useful for the beginner because it helps visualize multiple dependencies </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.241.1">that aren’t exactly obvious. </span><span class="koboSpan" id="kobo.241.2">The descriptor set is one of those objects: to obtain one, you need a reference to a descriptor set layout. </span><span class="koboSpan" id="kobo.241.3">They are not created by the application; they are allocated from a descriptor pool. </span><span class="koboSpan" id="kobo.241.4">Finally, a descriptor set references buffers, image views, and samplers. </span><span class="koboSpan" id="kobo.241.5">They are not required, and that’s why that type of relation in the diagram represents an optional reference. </span><span class="koboSpan" id="kobo.241.6">We’ll talk more about descriptor sets in </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.242.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.243.1">, Working with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.244.1">Modern Vulkan.</span></em></span></li>
</ol>
<p><span class="koboSpan" id="kobo.245.1">In the remainder of this chapter and the next chapter, we will cover the creation of all objects in the diagram in the order that they would usually be implemented. </span><span class="koboSpan" id="kobo.245.2">That means starting at the top with the Vulkan instance and moving downward, fulfilling the dependencies represented in </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the diagram.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.247.1">Using Volk to load Vulkan functions and extensions</span></h1>
<p><span class="koboSpan" id="kobo.248.1">Volk </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.249.1">is an open source library created by Arseny Kapoulkine that provides simple </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.250.1">cross-platform support for loading Vulkan </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.251.1">functions. </span><span class="koboSpan" id="kobo.251.2">The library provides several </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.252.1">key features, the most important ones being </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.253.1">automatically loading Vulkan’s function pointers and providing </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">cross-platform support.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">In this recipe, you will learn how to use Volk to load Vulkan functions and </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">their extensions.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.257.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.258.1">Download </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.259.1">Volk from </span><a href="https://github.com/zeux/volk"><span class="koboSpan" id="kobo.260.1">https://github.com/zeux/volk</span></a><span class="koboSpan" id="kobo.261.1"> and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">volk.c</span></strong><span class="koboSpan" id="kobo.263.1"> to your project and enable the preprocessor defines for your platform, </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">VK_USE_PLATFORM_WIN32_KHR</span></strong><span class="koboSpan" id="kobo.265.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">VK_USE_PLATFORM_XLIB_KHR</span></strong><span class="koboSpan" id="kobo.267.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">VK_USE_PLATFORM_MACOS_MVK</span></strong><span class="koboSpan" id="kobo.269.1">, and so on, before </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">including </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">volk.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.273.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.274.1">Volk </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.275.1">automatically loads Vulkan’s function pointers, so you </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.276.1">don’t have to manually handle </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.277.1">the details of loading them and checking </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.278.1">for available extensions. </span><span class="koboSpan" id="kobo.278.2">If you use Volk in your application, do not link against the static version of the Vulkan library (</span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">VKstatic.1.lib</span></strong><span class="koboSpan" id="kobo.280.1"> on Windows) or load the shared library directly (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">vulkan-1.dll</span></strong><span class="koboSpan" id="kobo.282.1"> on Windows). </span><span class="koboSpan" id="kobo.282.2">Volk will do that </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">for you.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.284.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">volkInitialize()</span></strong><span class="koboSpan" id="kobo.286.1"> during the application’s startup process, before any other Vulkan functions </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">are used.</span></span></li>
<li><span class="koboSpan" id="kobo.288.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">volkLoadInstance</span></strong><span class="koboSpan" id="kobo.290.1"> after the creation of the Vulkan instance. </span><span class="koboSpan" id="kobo.290.2">It replaces global function pointers with functions retrieved </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">vkGetInstanceProcAddr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.294.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">volkLoadDevice</span></strong><span class="koboSpan" id="kobo.296.1"> after the creation of the Vulkan logical device. </span><span class="koboSpan" id="kobo.296.2">It replaces global function pointers with functions retrieved </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">vkGetDeviceProcAddr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">.</span></span></li>
</ol>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.300.1">Using Vulkan extensions correctly</span></h1>
<p><span class="koboSpan" id="kobo.301.1">Vulkan relies </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.302.1">heavily on extensions. </span><span class="koboSpan" id="kobo.302.2">Extensions are functions and types that are part of the </span><em class="italic"><span class="koboSpan" id="kobo.303.1">Vulkan Specification</span></em><span class="koboSpan" id="kobo.304.1">; they are provided in addition to the core API but aren’t guaranteed to exist for a particular version of the API. </span><span class="koboSpan" id="kobo.304.2">Either they are experimental or vendor- and card-specific and are not guaranteed to be present, either at compile time or runtime. </span><span class="koboSpan" id="kobo.304.3">Official extensions are registered with the Khronos Group and are part of the spec, so you can find their </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">documentation there.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Extensions may be introduced to a </span><em class="italic"><span class="koboSpan" id="kobo.307.1">Vulkan Specification</span></em><span class="koboSpan" id="kobo.308.1"> version and later promoted to the core set of functionalities on a newer version. </span><span class="koboSpan" id="kobo.308.2">Or not at all! </span><span class="koboSpan" id="kobo.308.3">The functionality to present rendering results to a surface (such as a window on a GUI), for example, is still an extension </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.309.1">even in Vulkan 1.3 (the most recent version as of the writing of this book). </span><span class="koboSpan" id="kobo.309.2">If you are curious, here’s a link to it, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">VK_KHR_surface</span></strong><span class="koboSpan" id="kobo.311.1"> device extension:  </span><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html"><span class="No-Break"><span class="koboSpan" id="kobo.312.1">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.313.1">.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.314.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.315.1">.2</span></em><span class="koboSpan" id="kobo.316.1"> offers a high-level over</span><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.317.1">view of </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">the process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<span class="koboSpan" id="kobo.319.1"><img alt="Figure 1.2 – Vulkan extensions" src="image/B18491_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Figure 1.2 – Vulkan extensions</span></p>
<p><span class="koboSpan" id="kobo.321.1">Vulkan version 1.1, for example, contains its core functionality – functions and types present in that version – plus extensions. </span><span class="koboSpan" id="kobo.321.2">Some, all, or none of those extensions may be promoted to the core set of functionalities in Vulkan 1.2. </span><span class="koboSpan" id="kobo.321.3">Some might be considered deprecated and removed. </span><span class="koboSpan" id="kobo.321.4">The same thing happens when the specification is updated to version 1.3: some, all, or none of those extensions may be promoted from version 1.2 to the new version, and some might </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">be deprecated.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">In this recipe, we will present the right way to deal with extensions during compile time and </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">during runtime.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.325.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.326.1">There are two types of extensions in Vulkan: instance- and device-level extensions. </span><span class="koboSpan" id="kobo.326.2">Before using </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.327.1">an extension, you need to check if it is available during compile time and only add code that uses the extension if the extension is available. </span><span class="koboSpan" id="kobo.327.2">Generally speaking, you don’t need to check extensions at runtime. </span><span class="koboSpan" id="kobo.327.3">You also need to request the instance or device to enable the extensions by providing the name of the extension as </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">a string.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.329.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.330.1">In addition to an extension being present at compile time, you need to enable it at the right level (instance or device) and check if it has been enabled just before using it </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">at runtime.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.332.1">The pattern of checking whether a particular extension can be used at compile time and runtime is </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">shown next:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
bool isEnabledForDevice(VkDevice device,
                        const std::string &amp;extName) {
  // std::unordered_map&lt;std::string&gt; deviceExtensions;
  return deviceExtensions.contains(extName);
}
  VkDevice device;  // Valid Vulkan Device
#if defined(VK_KHR_win32_surface)
  // VK_KHR_WIN32_SURFACE_EXTENSION_NAME is defined as the string
  // "VK_KHR_win32_surface"
  if (isEnabledForDevice(device, VK_KHR_WIN32_SURFACE_EXTENSION_NAME)) {
    // VkWin32SurfaceCreateInfoKHR struct is available, as well as the
    // vkCreateWin32SurfaceKHR() function
    VkWin32SurfaceCreateInfoKHR surfaceInfo;
  }
#endif</span></pre></li> <li><span class="koboSpan" id="kobo.335.1">Besides new functions and types, the Vulkan SDK offers macros for each extension. </span><span class="koboSpan" id="kobo.335.2">Those </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.336.1">macros can be used to check whether they are present, their name, and version. </span><span class="koboSpan" id="kobo.336.2">In the preceding listing, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">VK_KHR_win32_surface</span></strong><span class="koboSpan" id="kobo.338.1"> macro is defined and set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">1</span></strong><span class="koboSpan" id="kobo.340.1"> if the extension is available. </span><span class="koboSpan" id="kobo.340.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">VK_KHR_WIN32_SURFACE_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.342.1"> macro defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">const char *</span></strong><span class="koboSpan" id="kobo.344.1"> as the name of the extension (in this case, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">VK_KHR_win32_surface</span></strong><span class="koboSpan" id="kobo.346.1">) and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">VK_KHR_WIN32_SURFACE_SPEC_VERSION</span></strong><span class="koboSpan" id="kobo.348.1"> macro, defined as an integer, that specifies its </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">version number.</span></span></li>
<li><span class="koboSpan" id="kobo.350.1">Before creating an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">VkWin32SurfaceCreateInfoKHR</span></strong><span class="koboSpan" id="kobo.352.1">, we check if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">VK_KHR_win32_surface</span></strong><span class="koboSpan" id="kobo.354.1"> device extension is present and enabled. </span><span class="koboSpan" id="kobo.354.2">The code is guarded by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">+#if+</span></strong><span class="koboSpan" id="kobo.356.1"> directive, and if the extension is present, we proceed to check if it’s enabled at runtime using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">VK_KHR_WIN32_SURFACE_EXTENSION_NAME</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1"> macro.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.359.1">This check is especially important if you are writing cross-platform code. </span><span class="koboSpan" id="kobo.359.2">While it may seem obvious that some extensions should be available, they may not be available for all platforms or graphics cards you are planning </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">to support.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.361.1">Using the Validation Layer for error checking</span></h1>
<p><span class="koboSpan" id="kobo.362.1">In the spirit of a high-performant, low-overhead API, Vulkan does not perform error-checking </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.363.1">by default. </span><span class="koboSpan" id="kobo.363.2">Doing so would incur a performance penalty, which may be unacceptable for some applications. </span><span class="koboSpan" id="kobo.363.3">On the other hand, due to Vulkan’s complexity, it is very easy for the application to </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">make mistakes.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">To help </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.366.1">application authors detect errors, Vulkan provides layers, which can be enabled during development and later disabled for shipping. </span><span class="koboSpan" id="kobo.366.2">That combination isn’t mandatory, as developers don’t have to enable error-detecting layers for testing nor disable them for shipping, although that is the most </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">common scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">In this recipe, we will introduce what Vulkan layers are and how their messages are presented, as well as offer tips on how to learn more about the meaning of </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">those messages.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.370.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.371.1">Layers are provided with the Vulkan SDK, so if you are using Vulkan, chances are you also have access to layers </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">by default.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.373.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.374.1">Layers are implementations of Vulkan functions that can be inserted in the call chain, intercepting entry points into the API. </span><span class="koboSpan" id="kobo.374.2">Those implementations can then perform error checking, performance measurements, or even detect </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">possible optimizations.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">The Vulkan SDK provides </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.377.1">a few layers that are </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">Plug and Play</span></strong><span class="koboSpan" id="kobo.379.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.380.1">PnP</span></strong><span class="koboSpan" id="kobo.381.1">). </span><span class="koboSpan" id="kobo.381.2">The only work you need to do is find which layers are present and enable them for the Vulkan instance. </span><span class="koboSpan" id="kobo.381.3">After that, at runtime, layers should start doing their jobs as soon as you start calling </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">Vulkan functions.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.383.1">The most important layer available in the SDK is the Validation Layer. </span><span class="koboSpan" id="kobo.383.2">This layer will validate all Vulkan function calls and their parameters. </span><span class="koboSpan" id="kobo.383.3">It also maintains an internal state – which Vulkan does not – to ensure that your application is not missing a synchronization step or using the wrong layouts </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">for images.</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">As an example, the following message shows a real message displayed by the Validation Layer. </span><span class="koboSpan" id="kobo.385.2">Although somewhat cryptic, the message is very useful: it starts by displaying the error ID (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">VUID-VkSamplerCreateInfo-sType-sType</span></strong><span class="koboSpan" id="kobo.387.1">), which you can use to search for it on the web; it also displays the device </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.388.1">associated with the error; and finally, it displays the message ID and text, which informs us, in this example, that </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.389.1">the structure we used to create a sampler (</span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">VkSamplerCreateInfo</span></strong><span class="koboSpan" id="kobo.391.1">) needs to have its </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">sType</span></strong><span class="koboSpan" id="kobo.393.1"> member equal </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
VUID-VkSamplerCreateInfo-sType-sType(ERROR / SPEC): msgNum: -129708450 - Validation Error: [ VUID-VkSamplerCreateInfo-sType-sType ] Object 0: handle = 0x1fbd501b6e0, name = Device, type = VK_OBJECT_TYPE_DEVICE; | MessageID = 0xf844ce5e | vkCreateSampler: parameter pCreateInfo-&gt;sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO. </span><span class="koboSpan" id="kobo.397.2">The Vulkan spec states: sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO (https://vulkan.lunarg.com/doc/view/1.3.236.0/windows/1.3-extensions/vkspec.html#VUID-VkSamplerCreateInfo-sType-sType)
    Objects: 1
        [0] 0x1fbd501b6e0, type: 3, name: Device</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.398.1">Even the most experienced graphics programmers will face Validation Layer errors. </span><span class="koboSpan" id="kobo.398.2">Getting used to how they look and how to figure out what they mean is the first step in writing a Vulkan application that is Validation </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">Layer error-free.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.400.1">Enumerating available instance layers</span></h1>
<p><span class="koboSpan" id="kobo.401.1">Enabling an </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.402.1">instance layer is as easy as providing its name as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">const char *</span></strong><span class="koboSpan" id="kobo.404.1"> to the instance creation function. </span><span class="koboSpan" id="kobo.404.2">Unfortunately, not all layers exist in all implementations, and we need to check the available ones before trying to </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">enable them.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">In this recipe, you will learn how to enumerate the available instance layers and how to transform them into strings so that they are easier </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">to manage.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.408.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.409.1">The code snippets shown in this section are part of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Context</span></strong><span class="koboSpan" id="kobo.411.1"> class.. </span><span class="koboSpan" id="kobo.411.2">It encapsulates most of the initialization and object </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">creation functions.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.413.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.414.1">Checking the </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.415.1">available extensions is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">to do:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.417.1">First, you need to query the number of extensions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">vkEnumerateInstanceLayerProperties</span></strong><span class="koboSpan" id="kobo.419.1"> function, create an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">VkLayerProperties</span></strong><span class="koboSpan" id="kobo.421.1"> big enough to store all extensions, and request their data by issuing a call to the same function again, </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
uint32_t instanceLayerCount{0};
VK_CHECK(vkEnumerateInstanceLayerProperties(
    &amp;instanceLayerCount, nullptr));
std::vector&lt;VkLayerProperties&gt; layers(
    instanceLayerCount);
VK_CHECK(vkEnumerateInstanceLayerProperties(
    &amp;instanceLayerCount, layers.data()));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.424.1">The second call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">vkEnumerateInstanceLayerProperties</span></strong><span class="koboSpan" id="kobo.426.1"> will store all available layers in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">layers</span></strong><span class="koboSpan" id="kobo.428.1"> vector, which then can be used for querying, diagnostics, and </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">so on.</span></span></p></li> <li><span class="koboSpan" id="kobo.430.1">With that information in hand, it’s always a good idea to verify whether the layers you are trying to enable are available. </span><span class="koboSpan" id="kobo.430.2">Since the instance creation function accepts the name of the layers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">const char *</span></strong><span class="koboSpan" id="kobo.432.1"> format, we need to convert the extension names </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">to strings:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.434.1">
std::vector&lt;std::string&gt; availableLayers;
std::transform(
    layers.begin(), layers.end(),
    std::back_inserter(availableLayers),
    [](const VkLayerProperties&amp; properties) {
      return properties.layerName;
    });</span></pre></li> <li><span class="koboSpan" id="kobo.435.1">Finally, the requested layers need to be filtered according to the available ones. </span><span class="koboSpan" id="kobo.435.2">With two </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.436.1">vectors of strings, one for the available layers and one for the requested layers, we can use the following utility function to </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">perform filtering:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
std::unordered_set&lt;std::string&gt; filterExtensions(
    std::vector&lt;std::string&gt; availableExtensions,
    std::vector&lt;std::string&gt; requestedExtensions) {
  std::sort(availableExtensions.begin(),
            availableExtensions.end());
  std::sort(requestedExtensions.begin(),
            requestedExtensions.end());
  std::vector&lt;std::string&gt; result;
  std::set_intersection(
      availableExtensions.begin(),
      availableExtensions.end(),
      requestedExtensions.begin(),
      requestedExtensions.end(),
      std::back_inserter(result));
  return std::unordered_set&lt;std::string&gt;(
      result.begin(), result.end());
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.439.1">This function is very handy because instance layers and instance and device extensions are all referred </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.440.1">to by their names as </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">const char*</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">This function can be applied to filter all layers and extensions you need </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">in Vulkan.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.444.1">Enumerating available instance extensions</span></h1>
<p><span class="koboSpan" id="kobo.445.1">The same process of filtering requested layers against available ones should be repeated for </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">instance extensions.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">In this </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.448.1">recipe, you will learn how to obtain available instance extensions, how to store them as strings, and how to convert them to pointers to characters so that they can be passed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">Vulkan API.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.450.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.451.1">The process is very similar to the one described in the previous recipe, which also includes a utility function to perform an intersection of the available layers and the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">requested ones.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.453.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.454.1">Obtaining a list of extensions is as easy as obtaining the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">available layers.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.456.1">First, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">vkEnumerateInstanceExtensionProperties</span></strong><span class="koboSpan" id="kobo.458.1"> twice, once to determine how many extensions are available and then one more time to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the extens</span><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.460.1">ions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.461.1">
uint32_t extensionsCount{0};
vkEnumerateInstanceExtensionProperties(
    nullptr, &amp;extensionsCount, nullptr);
std::vector&lt;VkExtensionProperties&gt;
    extensionProperties(extensionsCount);
vkEnumerateInstanceExtensionProperties(
    nullptr, &amp;extensionsCount,
    extensionProperties.data());
std::vector&lt;std::string&gt; availableExtensions;
std::transform(
    extensionProperties.begin(),
    extensionProperties.end(),
    std::back_inserter(availableExtensions),
    [](const VkExtensionProperties&amp; properties) {
      return properties.extensionName;
    });</span></pre></li> <li><span class="koboSpan" id="kobo.462.1">Finally, we can filter the requested layers and extensions using the list of available </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.463.1">layers and extensions from the previous steps. </span><span class="koboSpan" id="kobo.463.2">Notice that we are requesting the Validation Layer and guarding all extensions with a conditional </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">preprocessor block:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.465.1">
const std::vector&lt;std::string&gt;
    requestedInstanceLayers = {
        "VK_LAYER_KHRONOS_validation"};
const std::vector&lt;std::string&gt;
    requestedInstanceExtensions = {
#if defined(VK_KHR_win32_surface)
      VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
#endif
#if defined(VK_EXT_debug_utils),
      VK_EXT_DEBUG_UTILS_EXTENSION_NAME,
#endif
#if defined(VK_KHR_surface)
      VK_KHR_SURFACE_EXTENSION_NAME,
#endif
    };
const auto enabledInstanceLayers =
    filterExtensions(availableLayers,
                      requestedInstanceLayers);
const auto enabledInstanceExtensions =
    filterExtensions(availableExtensions,
                      requestedInstanceExtensions);</span></pre></li> <li><span class="koboSpan" id="kobo.466.1">To pass the </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.467.1">vectors of strings to the API, we need to convert them to vectors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">const char*</span></strong><span class="koboSpan" id="kobo.469.1"> because the API only accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">const char*</span></strong><span class="koboSpan" id="kobo.471.1"> parameters. </span><span class="koboSpan" id="kobo.471.2">We also need to perform the same conversion for the vector of instance layers (which is omitted here </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">for brevity):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
std::vector&lt;const char*&gt; instanceExtensions(
    enabledInstanceExtensions.size());
std::transform(enabledInstanceExtensions.begin(),
                enabledInstanceExtensions.end(),
                instanceExtensions.begin(),
                std::mem_fn(&amp;std::string::c_str));</span></pre></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.474.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.475.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">instanceExtensions</span></strong><span class="koboSpan" id="kobo.477.1"> vector must </span><em class="italic"><span class="koboSpan" id="kobo.478.1">not</span></em><span class="koboSpan" id="kobo.479.1"> outlive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">enabledInstanceExtensions</span></strong><span class="koboSpan" id="kobo.481.1"> vector. </span><span class="koboSpan" id="kobo.481.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">instanceExtensions</span></strong><span class="koboSpan" id="kobo.483.1"> contains pointers to the strings in </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">enabledInstanceExtensions</span></strong><span class="koboSpan" id="kobo.485.1">, once the latter is destroyed, the pointers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">instanceExtensions</span></strong><span class="koboSpan" id="kobo.487.1"> would all </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">be dangling.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.489.1">Initializing the Vulkan instance</span></h1>
<p><span class="koboSpan" id="kobo.490.1">To start using Vulkan, we need to create a Vulkan instance. </span><span class="koboSpan" id="kobo.490.2">One can think of a Vulkan instance as </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.491.1">a way of initializing the Vulkan library. </span><span class="koboSpan" id="kobo.491.2">To create one, you need to provide a set of required and optional information such as application name, engine name, version, and a list of desired layers </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">and extensions.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">In this recipe, you will learn how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">Vulkan instance.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.495.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.496.1">Instantiating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">VkApplicationInfo</span></strong><span class="koboSpan" id="kobo.498.1"> structure used to create an instance requires the version of the application and the Vulkan API version. </span><span class="koboSpan" id="kobo.498.2">The former can be created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">VK_MAKE_VERSION</span></strong><span class="koboSpan" id="kobo.500.1"> macro, while the latter can be provided as one of the preprocessor definitions available in </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">the SDK.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.502.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.503.1">With all of those in hand, all we need to do is create a </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">Vulkan instance:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.505.1">Create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">VkApplicationInfo</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.507.1">structure first:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
const VkApplicationInfo applicationInfo_ = {
    .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    .pApplicationName = "Essential Graphics With Vulkan",
    .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
    .apiVersion = VK_API_VERSION_1_3,
};</span></pre></li> <li><span class="koboSpan" id="kobo.509.1">You will also need an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">VkInstanceCreateInfo</span></strong><span class="koboSpan" id="kobo.511.1"> structure with the requested instance layers and extensions. </span><span class="koboSpan" id="kobo.511.2">Then, </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">vkCreateInstance</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.515.1">
const VkInstanceCreateInfo instanceInfo = {
    .sType =
        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    .pApplicationInfo = &amp;applicationInfo_,
    .enabledLayerCount = static_cast&lt;uint32_t&gt;(
        requestedLayers.size()),
    .ppEnabledLayerNames = requestedLayers.data(),
    .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
        instanceExtensions.size()),
    .ppEnabledExtensionNames =  instanceExtensions.data(),
};
VkInstanc</span><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.516.1">e instance_{VK_NULL_HANDLE};
VK_CHECK(vkCreateInstance(&amp;instanceInfo, nullptr,
                          &amp;instance_));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.517.1">Once the </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.518.1">Vulkan instance has been created, you should keep it stored safely, as it will need to be destroyed before your </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">application exits.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.520.1">Creating a surface</span></h1>
<p><span class="koboSpan" id="kobo.521.1">Just as in OpenGL, presenting the final render output to the screen needs support from the windowing system and is platform-dependent. </span><span class="koboSpan" id="kobo.521.2">For this reason, the Vulkan Core API does not </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.522.1">contain functions to render the final image to the screen. </span><span class="koboSpan" id="kobo.522.2">Those functions and types are extensions. </span><span class="koboSpan" id="kobo.522.3">For this recipe, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">VK_KHR_surface</span></strong><span class="koboSpan" id="kobo.524.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">VK_KHR_swapchain</span></strong><span class="koboSpan" id="kobo.526.1"> extensions. </span><span class="koboSpan" id="kobo.526.2">We will cover only the Windows case here and use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">VK_KHR_win32_surface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1"> extension.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">In this recipe, you will learn how to create a surface for presenting the final output of </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">your rendering.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.531.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.532.1">The first step in the process of rendering an image onto the screen starts with the creation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">VkSurfaceKHR</span></strong><span class="koboSpan" id="kobo.534.1"> object. </span><span class="koboSpan" id="kobo.534.2">Since this object is needed while reserving queues from a physical device, this step is done after the instance has been created but before the physical devices are enumerated and before the device is created, as the device needs information about which queue families we </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">will use.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.536.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.537.1">Creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">VkSurfaceKHR</span></strong><span class="koboSpan" id="kobo.539.1"> object is simple but needs support from the </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">windowing system.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.541.1">On Windows, you need an instance handle  to the executable a (</span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">HINSTANCE)</span></strong><span class="koboSpan" id="kobo.543.1"> and a window handle (</span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">HWND</span></strong><span class="koboSpan" id="kobo.545.1">) for where to present the image. </span><span class="koboSpan" id="kobo.545.2">We’re using GLFW, so the </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.546.1">window used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">VkWin32SurfaceCreateInfoKHR</span></strong><span class="koboSpan" id="kobo.548.1"> structure can be obtained with </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">glfwGetWin32Window(GLFWwindow*)</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">The handle to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">VkSurfaceKHR</span></strong><span class="koboSpan" id="kobo.552.1"> object is stored </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">Context::surface_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
const auto window = glfwGetWin32Window(glfwWindow);
#if defined(VK_USE_PLATFORM_WIN32_KHR) &amp;&amp; \
    defined(VK_KHR_win32_surface)
    if (enabledInstanceExtensions_.contains(
            VK_KHR_WIN32_SURFACE_EXTENSION_NAME)) {
      if (window != nullptr) {
        const VkWin32SurfaceCreateInfoKHR ci = {
            .sType =
                VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
            .hinstance = GetModuleHandle(NULL),
            .hwnd = (HWND)window,
        };
        VK_CHECK(vkCreateWin32SurfaceKHR(
            instance_, &amp;ci, nullptr, &amp;surface_));
      }
    }
#endif</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.557.1">The surface </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.558.1">creation varies slightly between platforms, but the process is </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">very similar.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.560.1">Enumerating Vulkan physical devices</span></h1>
<p><span class="koboSpan" id="kobo.561.1">Before we can create a device in Vulkan, we need to select a suitable physical device, as a system may </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.562.1">have multiple Vulkan-capable GPUs and we want to choose one with the capabilities required by our application. </span><span class="koboSpan" id="kobo.562.2">To do this, we need to enumerate all available physical devices on the system. </span><span class="koboSpan" id="kobo.562.3">This can be achieved by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">vkEnumeratePhysicalDevices</span></strong><span class="koboSpan" id="kobo.564.1"> function, which returns a list of all physical devices on the system that support the Vulkan API. </span><span class="koboSpan" id="kobo.564.2">Once we have the list of physical devices, we can inspect their properties and features using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">vkGetPhysicalDeviceProperties</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">vkGetPhysicalDeviceFeatures</span></strong><span class="koboSpan" id="kobo.568.1"> functions to determine if they have the required capabilities. </span><span class="koboSpan" id="kobo.568.2">Finally, we can choose the most suitable physical device and use it to create a logical device through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">vkCreateDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">In this recipe, you will learn how to enumerate all Vulkan-capable devices present in the system so that you can choose one that best fits </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">your needs.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.573.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.574.1">In our code, we encapsulate a physical device in a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">VulkanCore::PhysicalDevice</span></strong><span class="koboSpan" id="kobo.576.1">, which retrieves a physical device’s properties and stores them for </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">later use.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Also, make sure to check out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Context::choosePhysicalDevice()</span></strong><span class="koboSpan" id="kobo.580.1"> method if you’d like to use a better heuristic to choose one physical device on systems that have multiple devices that </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">support Vulkan.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.582.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.583.1">Enumerating physical devices employs the same pattern used throughout the API, which requires </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.584.1">us to first request the number of items available and then fetch and store them into </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">a vector:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">vkEnumeratePhysicalDevices</span></strong><span class="koboSpan" id="kobo.587.1"> is called twice, first to query how many objects are available, and a second time to fetch the handles to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">VkPhysicalDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.590.1">
std::vector&lt;PhysicalDevice&gt;
Context::enumeratePhysicalDevices(
    const std::vector&lt;std::string&gt;&amp;
        requestedExtensions) const {
  uint32_t deviceCount{0};
  VK_CHECK(vkEnumeratePhysicalDevices(
      instance_, &amp;deviceCount, nullptr));
  ASSERT(deviceCount &gt; 0,
          "No Vulkan devices found");
  std::vector&lt;VkPhysicalDevice&gt; devices(
      deviceCount);
  VK_CHECK(vkEnumeratePhysicalDevices(
      instance_, &amp;deviceCount, devices.data()));
  std::vector&lt;PhysicalDevice&gt; physicalDevices;
  for (const auto device : devices) {
    physicalDevices.emplace_back(PhysicalDevice(
        device, surface_, requestedExtensions,
        printEnumerations_));
  }
  return physicalDevices;
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.591.1">This method </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.592.1">returns a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">PhysicalDevice</span></strong><span class="koboSpan" id="kobo.594.1"> objects. </span><span class="koboSpan" id="kobo.594.2">In the code, this list is passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Context::choosePhysicalDevice()</span></strong><span class="koboSpan" id="kobo.596.1"> helper method, which can be used to select an appropriate physical device based on the requested extensions and other GPU capabilities you may need. </span><span class="koboSpan" id="kobo.596.2">For the sake of simplicity, we always choose the first physical device from </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">the list.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.598.1">Caching the properties of queue families</span></h1>
<p><span class="koboSpan" id="kobo.599.1">In Vulkan, a physical device can have one or more queue families, where each queue family </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.600.1">represents a set of command queues that share certain properties, such as capabilities or usage. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.602.1">.3</span></em><span class="koboSpan" id="kobo.603.1"> depicts a f</span><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.604.1">ictional set of families and </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">their queues:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.606.1"><img alt="Figure 1.3 – Queue families and their queues" src="image/B18491_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.607.1">Figure 1.3 – Queue families and their queues</span></p>
<p><span class="koboSpan" id="kobo.608.1">Each queue family supports a specific set of operations and commands that can be executed in parallel. </span><span class="koboSpan" id="kobo.608.2">For example, there may be a graphics queue family, a compute queue family, and a transfer queue family, each optimized for different types </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">of operations.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">In this recipe, you will learn how to retrieve the properties of a queue family and where they are stored in the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the repository.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.612.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.613.1">In the repository provided with this book, queue families and their properties are stored and managed by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">VulkanCore::PhysicalDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1"> class.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.616.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.617.1">Each queue family has its own set of properties, such as the number of queues, the type of operations </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.618.1">it can perform, and the priority of the queues. </span><span class="koboSpan" id="kobo.618.2">When creating a logical device, we must specify which queue families and how many queues of each type we want </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">to use.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.620.1">To query the queue families available and their properties, use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">vkGetPhysicalDeviceQueueFamilyProperties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
uint32_t queueFamilyCount{0};
vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice_, &amp;queueFamilyCount, nullptr);
queueFamilyProperties_.resize(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(
    physicalDevice_, &amp;queueFamilyCount,
    queueFamilyProperties_.data());</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.624.1">The properties of the families are stored in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">std::vector&lt;VkQueueFamilyProperties&gt; PhysicalDevice::queueFamilyProperties_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.627.1">Enumerating physical device extensions</span></h1>
<p><span class="koboSpan" id="kobo.628.1">Physical device </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.629.1">extensions must be explicitly enabled by the application and may only be available on specific physical devices or device drivers. </span><span class="koboSpan" id="kobo.629.2">It’s important to check for the availability of required extensions and to gracefully handle situations where extensions are </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">not supported.</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">In this recipe, you will learn how to enumerate all physical device extensions and how to convert and store them to strings for </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">later use.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.633.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.634.1">Enumerating physical device extensions is managed by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">VulkanCore::PhysicalDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.636.1"> class.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.637.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.638.1">Obtaining all </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.639.1">physical device extensions for a physical device is simple. </span><span class="koboSpan" id="kobo.639.2">Here, we also provide code to store them as strings so that they are easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">work with.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.641.1">Enumerating all physical device extensions is done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">vkEnumerateDeviceExtensionProperties</span></strong><span class="koboSpan" id="kobo.643.1"> function. </span><span class="koboSpan" id="kobo.643.2">The result is an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">VkExtensionProperties</span></strong><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">This structure contains information such as the extension name, version, and a brief description of the </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">extension’s purpose:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
uint32_t propertyCount{0};
VK_CHECK(vkEnumerateDeviceExtensionProperties(
    physicalDevice_, nullptr, &amp;propertyCount,
    nullptr));
std::vector&lt;VkExtensionProperties&gt; properties(
    propertyCount);
VK_CHECK(vkEnumerateDeviceExtensionProperties(
    physicalDevice_, nullptr, &amp;propertyCount,
    properties.data()));</span></pre></li> <li><span class="koboSpan" id="kobo.648.1">Convert the extension’s name </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">std::string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.652.1">
std::transform(
    properties.begin(), properties.end(),
    std::back_inserter(extensions_),
    [](const VkExtensionProperties&amp; property) {
      return std::string(property.extensionName);
    });</span></pre></li> <li><span class="koboSpan" id="kobo.653.1">This array </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.654.1">is processed so that we end up with only the names of the extensions as strings. </span><span class="koboSpan" id="kobo.654.2">Further processing filters the requested extensions against the available ones using our </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">filterExtensions</span></strong><span class="koboSpan" id="kobo.656.1"> utility function and stores them in </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">std::unordered_set&lt;std::string&gt;  </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">PhysicalDevice::enabledExtensions_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
enabledExtensions_ = util::filterExtensions(
    extensions_, requestedExtensions);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.661.1">In summary, mastering the enumeration of physical device extensions is an important aspect of Vulkan. </span><span class="koboSpan" id="kobo.661.2">It ensures optimal utilization of your </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">device’s capabilities.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.663.1">Reserving queue families</span></h1>
<p><span class="koboSpan" id="kobo.664.1">In Vulkan, a queue family is a group of one or more queues that share common properties, such as the type of operations they can perform. </span><span class="koboSpan" id="kobo.664.2">When creating a Vulkan device, we must </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.665.1">specify which queue families we want to use and how many queues of each family </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">For rendering and presentation, we typically need at least one graphics queue family, which is responsible for executing graphics commands. </span><span class="koboSpan" id="kobo.667.2">Additionally, we may require a compute queue family for executing compute workloads and a transfer queue family for handling </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">data transfers.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">In this recipe, you will learn how to find queue families based on their properties and how to select a queue family that supports presentation, which can be used to present the final render output on </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the screen.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.671.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.672.1">In the repository, reserving queues is encapsulated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">VulkanCore::PhysicalDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.674.1"> class.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.675.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.676.1">One additional step necessary before creating a Vulkan device is to gather the indices to the queue families we’d like to use. </span><span class="koboSpan" id="kobo.676.2">For that, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">PhysicalDevice::reserveQueues()</span></strong><span class="koboSpan" id="kobo.678.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">PhysicalDevice</span></strong><span class="koboSpan" id="kobo.680.1"> class to handle the process, which takes the type of queues we’d like to reserve as a parameter. </span><span class="koboSpan" id="kobo.680.2">It also </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.681.1">takes a handle to a Vulkan surface (</span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">VkSurfaceKHR</span></strong><span class="koboSpan" id="kobo.683.1">), which we will use later to verify whether a queue supports presentation, necessary to display the final render on </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the screen.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.685.1">We iterate over the queue families properties, stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">queueFamilyProperties_</span></strong><span class="koboSpan" id="kobo.687.1">, and store the index to the queue family index if its type has </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">been requested:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.689.1">
uint32_t graphicsFamilyIndex{UINT32_MAX};
uint32_t presentationFamilyIndex{UINT32_MAX};
for (uint32_t queu</span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.690.1">eFamilyIndex = 0;
      queueFamilyIndex &lt;
          queueFamilyProperties_.size() &amp;&amp;
      requestedQueueTypes != 0;
      ++queueFamilyIndex) {
  if (graphicsFamilyIndex == UINT32_MAX &amp;&amp;
      (queueFamilyProperties_[queueFamilyIndex]
            .queueFlags &amp;
        VK_QUEUE_GRAPHICS_BIT)) {
    graphicsFamilyIndex = queueFamilyIndex;
  }</span></pre></li> <li><span class="koboSpan" id="kobo.691.1">To detect if a queue family supports presentation, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">vkGetPhysicalDeviceSurfaceSupportKHR</span></strong><span class="koboSpan" id="kobo.693.1"> function, guarded by the </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">preprocessor macros:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
#if defined(VK_KHR_surface)
  if (enabledInstanceExtensions_.contains(
          VK_KHR_SURFACE_EXTENSION_NAME)) {
    if (presentationFamilyIndex == UINT32_MAX &amp;&amp;
        surface != VK_NULL_HANDLE) {
      VkBool32 supportsPresent{VK_FALSE};
      vkGetPhysicalDeviceSurfaceSupportKHR(
          physicalDevice_, queueFamilyIndex,
          surface, &amp;supportsPresent);
      if (supportsPresent == VK_TRUE) {
        presentationFamilyIndex = queueFamilyIndex;
      }
    }
  }
#endif
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.696.1">The indices </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.697.1">of other types of queue families may be obtained in a </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">similar manner.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.699.1">Creating a Vulkan logical device</span></h1>
<p><span class="koboSpan" id="kobo.700.1">A Vulkan device </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.701.1">is a logical representation of a physical GPU. </span><span class="koboSpan" id="kobo.701.2">It’s an object that is associated with a selected physical device (an existing GPU in the system) and is used to perform all graphics and compute operations. </span><span class="koboSpan" id="kobo.701.3">The device also provides access to physical GPU capabilities through queues. </span><span class="koboSpan" id="kobo.701.4">Queues are used to submit commands to the GPU, such as draw calls or memory transfers. </span><span class="koboSpan" id="kobo.701.5">The device also provides access to other Vulkan objects, such as pipelines, buffers, </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">and images.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">In this recipe, you will learn how to create a Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">logical device.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.705.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.706.1">The code in </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.707.1">this recipe is available as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">VulkanCore::Context</span></strong><span class="koboSpan" id="kobo.709.1"> class in the repository. </span><span class="koboSpan" id="kobo.709.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">Context</span></strong><span class="koboSpan" id="kobo.711.1"> class represents a Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">logical device.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.713.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.714.1">To create a Vulkan device, we need to provide a physical device and the indices of the queue families we want to use. </span><span class="koboSpan" id="kobo.714.2">Using this information, we can create a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">VkDeviceQueueCreateInfo</span></strong><span class="koboSpan" id="kobo.716.1"> structures, which determines the number of queues we want to use from each family and their </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">respective priorities.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.718.1">The most common use case for creating a device is to use one queue per family and set its priority </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
auto physicalDevice_ = enumeratePhysicalDevices(
    requestedExtensions)[0];
// Retrieves a vector of (queue family indices and
// their number)
const vector&lt;uint32_t&gt; familyIndices =
    physicalDevice_.reservedFamilies();
std::vector&lt;VkDeviceQueueCreateInfo&gt;
    queueCreateInfos;
float priority{1.0f};
for (const auto&amp; queueFamilyIndex :
      familyIndices) {
  queueCreateInfos.emplace_back(
      VkDeviceQueueCreateInfo{
          .sType =
              VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
          .queueFamilyIndex = queueFamilyIndex,
          .queueCount = 1,
          .pQueuePriorities = &amp;priority,
      });
  ++index;
}</span></pre></li> <li><span class="koboSpan" id="kobo.723.1">The list of </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.724.1">requested device extensions is converted from strings to </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">const char*</span></strong><span class="koboSpan" id="kobo.726.1">, filtered against the available extensions, and added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">VkDeviceCreateInfo</span></strong><span class="koboSpan" id="kobo.728.1"> structure, along with the index of the families we’d like to use and the layers we’d like </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">to enable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.730.1">
std::vector&lt;const char*&gt; deviceExtensions(
    physicalDevice_.enabledExtensions().size());
std::transform(
    physicalDevice_.enabledExtensions().begin(),
    physicalDevice_.enabledExtensions().end(),
    deviceExtensions.begin(),
    std::mem_fn(&amp;std::string::c_str));
const VkDeviceCreateInfo dci = {
    .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    .queueCreateInfoCount = static_cast&lt;uint32_t&gt;(
        queueCreateInfos.size()),
    .pQueueCreateInfos = queueCreateInfos.data(),
    .enabledLayerCount = static_cast&lt;uint32_t&gt;(
        requestedLayers.size()),
    .ppEnabledLayerNames = requestedLayers.data(),
    .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
        deviceExtensions.size()),
    .ppEnabledExtensionNames =
        deviceExtensions.data(),
};
VK_CHECK(vkCreateDevice(
    physicalDevice_.vkPhysicalDevice(), &amp;dci,
    nullptr, &amp;device_));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.731.1">A Vulkan device </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.732.1">is one of the most important objects you need, as it’s needed to create almost every other Vulkan object </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">there is.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.734.1">Retrieving the queue object handle</span></h1>
<p><span class="koboSpan" id="kobo.735.1">Once the </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.736.1">logical device has been created, we need to obtain the handle to queues. </span><span class="koboSpan" id="kobo.736.2">That is accomplished with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">vkGetDeviceQueue</span></strong><span class="koboSpan" id="kobo.738.1"> function. </span><span class="koboSpan" id="kobo.738.2">This handle will be used to submit command buffers for processing on </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">In this recipe, you will learn how to obtain the handle to a </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">Vulkan queue.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.742.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.743.1">In the repository, all queues are retrieved and stored by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">VulkanCore::Context</span></strong><span class="koboSpan" id="kobo.745.1"> class. </span><span class="koboSpan" id="kobo.745.2">That class maintains a list for each type of queue: graphics, compute, transfer, and sparse, along with a special queue </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">for presentation.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.747.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.748.1">To retrieve </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.749.1">the handle to a queue, just call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">vkGetDeviceQueue</span></strong><span class="koboSpan" id="kobo.751.1"> function with the queue family index and the </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">queue index:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
VkQueue queue{VK_NULL_HANDLE};
uint32_t queueFamilyIndex; // valid queue family
vkGetDeviceQueue(device, queueFamilyIndex, 0, &amp;queue);</span></pre> <p><span class="koboSpan" id="kobo.754.1">Knowing which queue families are available is not enough. </span><span class="koboSpan" id="kobo.754.2">Once we determine which queues are available and the queues we need, we request the handle to one of the queues from the family using the API presented in </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">this recipe.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.756.1">Creating a command pool</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.757.1">Command buffers</span></strong><span class="koboSpan" id="kobo.758.1"> provide the </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.759.1">ability to record graphics and compute commands, while command queues allow those buffers to be submitted to the hardware. </span><span class="koboSpan" id="kobo.759.2">Commands recorded in the command buffers are then executed by </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">Each queue is </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.762.1">associated with a specific queue family, which defines the capabilities of the queue. </span><span class="koboSpan" id="kobo.762.2">For example, a queue family may only support graphics operations, or it may support both graphics and compute operations. </span><span class="koboSpan" id="kobo.762.3">The number of families and their capabilities can be retrieved using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">vkGetPhysicalDeviceQueueFamilyProperties</span></strong><span class="koboSpan" id="kobo.764.1"> function, discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.765.1">Caching the properties of queue families</span></em><span class="koboSpan" id="kobo.766.1"> recipe. </span><span class="koboSpan" id="kobo.766.2">A queue family may contain one or </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">more queues.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Command buffers are containers for the actual commands that are executed by the GPU. </span><span class="koboSpan" id="kobo.768.2">To record commands, you allocate a command buffer, then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">vkCmd*</span></strong><span class="koboSpan" id="kobo.770.1"> family of functions to record the commands into them. </span><span class="koboSpan" id="kobo.770.2">Once the commands have been recorded, the command buffer can be submitted to a command queue </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">for execution.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">Command buffers are allocated from a command pool, which in turn is created from a device and is associated with a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">queue family.</span></span></p>
<p><span class="koboSpan" id="kobo.774.1">In this recipe, you will learn how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">command pool.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.776.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.777.1">Command pools and allocating and submitting command buffers is managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">VulkanCore:: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">CommandQueueManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.780.1"> class.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.781.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.782.1">Creating a </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.783.1">command pool is easy. </span><span class="koboSpan" id="kobo.783.2">All you need is the queue family index and a creation flag. </span><span class="koboSpan" id="kobo.783.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.785.1"> flag is enough for </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">our purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">To create a command pool, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">vkCreateCommandPool</span></strong><span class="koboSpan" id="kobo.789.1"> function. </span><span class="koboSpan" id="kobo.789.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.791.1"> flag means that each command buffer allocated from this pool may be reset individually or implicitly by </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">vkCmdBeginCommandBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
uint32_t queueFamilyIndex; // Valid queue family index
const VkCommandPoolCreateInfo commandPoolInfo = {
    .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    .flags =
      VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    .queueFamilyIndex = queueFamilyIndex,
};
VkCommandPool commandPool{VK_NULL_HANDLE};
VK_CHECK(
    vkCreateCommandPool(device, &amp;commandPoolInfo,
                        nullptr, &amp;commandPool));</span></pre> <p><span class="koboSpan" id="kobo.796.1">With a command pool object, you can start allocating command buffers for </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">recording commands.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.798.1">Allocating, recording, and submitting commands</span></h1>
<p><span class="koboSpan" id="kobo.799.1">Command buffers are allocated from command pools using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">vkAllocateCommandBuffers</span></strong><span class="koboSpan" id="kobo.801.1"> function. </span><span class="koboSpan" id="kobo.801.2">Command buffers must be initialized with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">vkBeginCommandBuffer</span></strong><span class="koboSpan" id="kobo.803.1"> function before being recorded into the buffer and prepared </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.804.1">for submission with </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">vkEndCommandBuffer</span></strong><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">Commands are </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.807.1">recorded into the buffer between those function calls </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.808.1">and are executed only after the command buffer is submitted to the device </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">vkQueueSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">In this recipe, you will learn how to allocate command buffers, how to record commands in the command buffer, and how to submit them for execution on </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">the GPU.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.814.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.815.1">Command buffers are allocated from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">VulkanCore::CommandQueueManager</span></strong><span class="koboSpan" id="kobo.817.1"> class and submitted using the same class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">VulkanCore::CommandQueueManager</span></strong><span class="koboSpan" id="kobo.819.1"> provides basic functions to maintain a set of command buffers </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">for processing.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.821.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.822.1">A command buffer’s life cycle starts with its allocation from a command pool. </span><span class="koboSpan" id="kobo.822.2">Once it has started, commands can be recorded into it. </span><span class="koboSpan" id="kobo.822.3">Before submission, you need to explicitly message them that recording has ended. </span><span class="koboSpan" id="kobo.822.4">They can then be submitted </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">for execution:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.824.1">To allocate command buffers, you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">vkAllocateCommandBuffers</span></strong><span class="koboSpan" id="kobo.826.1">, passing in the command pool, the number of buffers you want to allocate, and a pointer to a structure that specifies the properties of the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">command buffers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
const VkCommandBufferAllocateInfo commandBufferInfo = {
        .sType =
            VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        .commandPool = commandPool_,
        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
        .commandBufferCount = 1,
    };
    VkCommandBuffer cmdBuffer{VK_NULL_HANDLE};
    VK_CHECK(vkAllocateCommandBuffers(
        device, &amp;commandBufferInfo, &amp;cmdBuffer));</span></pre></li> <li><span class="koboSpan" id="kobo.829.1">After successfully </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.830.1">allocating a command buffer, the recording </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.831.1">of Vulkan commands can begin. </span><span class="koboSpan" id="kobo.831.2">The recording </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.832.1">process is initiated through a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">vkBeginCommandBuffer</span></strong><span class="koboSpan" id="kobo.834.1"> function, with parameters including the command buffer and a pointer to a structure that defines recording properties. </span><span class="koboSpan" id="kobo.834.2">Once recording is completed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">vkEndCommandBuffer</span></strong><span class="koboSpan" id="kobo.836.1"> function is called to finalize </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">the process:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.838.1">
const VkCommandBufferBeginInfo info = {
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
};
VK_CHECK(vkBeginCommandBuffer(cmdBuffer, &amp;info));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.839.1">Here are some examples of commonly used commands that can be recorded in a Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">command buffer:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">vkCmdBindPipeline</span></strong><span class="koboSpan" id="kobo.842.1">: Binds a pipeline to the command buffer. </span><span class="koboSpan" id="kobo.842.2">This command sets the current pipeline state for subsequent </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">draw calls.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">vkCmdBindDescriptorSets</span></strong><span class="koboSpan" id="kobo.845.1">: Binds descriptor sets to the command buffer. </span><span class="koboSpan" id="kobo.845.2">Descriptor sets hold references to buffer and image resources that can be used </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">by shaders.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">vkCmdBindVertexBuffers</span></strong><span class="koboSpan" id="kobo.848.1">: Binds vertex buffers to the command buffer. </span><span class="koboSpan" id="kobo.848.2">Vertex buffers contain the vertex data for </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">a mesh.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">vkCmdDraw</span></strong><span class="koboSpan" id="kobo.851.1">: Executes a draw call, which processes vertices and rasterizes the </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">resulting pixels.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">vkCmdDispatch</span></strong><span class="koboSpan" id="kobo.854.1">: Executes a </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">compute shader.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">vkCmdCopyBuffer</span></strong><span class="koboSpan" id="kobo.857.1">: Copies data from one buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">to another.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">vkCmdCopyImage</span></strong><span class="koboSpan" id="kobo.860.1">: Copies data from one image </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">to another.</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.862.1">Once you </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.863.1">are done recording commands, you must </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">vkEndCommandBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.867.1">
VK_CHECK(vkEndCommandBuffer(cmdBuffer));</span></pre></li> <li><span class="koboSpan" id="kobo.868.1">Once a </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.869.1">command buffer has been recorded, it still lives in your </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.870.1">application and needs to be submitted to the GPU for processing. </span><span class="koboSpan" id="kobo.870.2">That is accomplished by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">vkQueueSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.872.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.873.1">
VkDevice device;  // Valid Vulkan Device
VkQueue queue;  // Valid Vulkan Queue
VkFence fence{VK_NULL_HANDLE};
const VkFenceCreateInfo fenceInfo = {
    .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    .flags = VK_FENCE_CREATE_SIGNALED_BIT,
};
VK_CHECK(vkCreateFence(device, &amp;fenceInfo, nullptr,
                        &amp;fence));
const VkSubmitInfo submitInfo = {
    .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    .commandBufferCount = 1,
    .pCommandBuffers = cmdBuffer,
};
VK_CHECK(
    vkQueueSubmit(queue, 1, submitInfo, fence));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.874.1">In the </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.875.1">preceding code, the fence is a specific Vulkan object that facilitates synchronization between the GPU and the CPU. </span><span class="koboSpan" id="kobo.875.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">vkQueueSubmit</span></strong><span class="koboSpan" id="kobo.877.1"> function is </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.878.1">an asynchronous operation that does not block the application. </span><span class="koboSpan" id="kobo.878.2">Therefore, once a command buffer is submitted, we can only determine whether it </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.879.1">has been processed by checking the status of the fence using functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">vkGetFenceStatus</span></strong><span class="koboSpan" id="kobo.881.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">vkWaitForFences</span></strong><span class="koboSpan" id="kobo.883.1">. </span><span class="koboSpan" id="kobo.883.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.884.1">Understanding synchronization in the swapchain – fences and semaphores</span></em><span class="koboSpan" id="kobo.885.1"> recipe to understand how fences can be used to synchronize your application and the execution of commands submitted to </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">the GPU.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.887.1">Reusing command buffers</span></h1>
<p><span class="koboSpan" id="kobo.888.1">Command buffers </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.889.1">can be recorded once and submitted multiple times. </span><span class="koboSpan" id="kobo.889.2">They can also be used once and reset before the next use or just recorded, submitted, </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">and discarded.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">In this recipe, you will learn how to reuse a command buffer without creating a race condition between your application and </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">the GPU.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.893.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.894.1">The code provided in </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">VulkanCore::CommandQueueManager</span></strong><span class="koboSpan" id="kobo.896.1"> doesn’t synchronize command buffers but provides functions to help you do so, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">goToNextCmdBuffer</span></strong><span class="koboSpan" id="kobo.898.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">waitUntilSubmitIsComplete</span></strong><span class="koboSpan" id="kobo.900.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">waitUntilAllSubmitsAreComplete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.904.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.905.1">Using command buffers can be accomplished in </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">two ways:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.907.1">Create a command buffer and reuse it indefinitely. </span><span class="koboSpan" id="kobo.907.2">In this case, once the command buffer is submitted, you must wait for it to be processed before starting to </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.908.1">record new commands. </span><span class="koboSpan" id="kobo.908.2">One way to guarantee that the buffer has finished being processed is by checking the status of the fences associated with it. </span><span class="koboSpan" id="kobo.908.3">If the fence is to be reused, you need to reset its state </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">as well:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.910.1">
VkDevice device; // Valid Vulkan Device
VK_CHECK(vkWaitForFences(device, 1, &amp;fences, true,
                         UINT32_MAX));
VK_CHECK(vkResetFences(device, 1, &amp;fences));</span></pre><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.911.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.912.1">.4</span></em><span class="koboSpan" id="kobo.913.1"> shows the case where the command buffer submitted for processing is reused immediately after being submitted for processing on the GPU. </span><span class="koboSpan" id="kobo.913.2">Without any form of synchronization, reusing the command buffer wil</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.914.1">l result in a race condition, as it may be still processing in </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">the GPU:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.916.1"><img alt="Figure 1.4 – Recording and submitting command buffers without using fences" src="image/B18491_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.917.1">Figure 1.4 – Recording and submitting command buffers without using fences</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.918.1">By using fences, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.919.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.920.1">.5</span></em><span class="koboSpan" id="kobo.921.1">, it’s possible to prevent a race condition by checking the state of the fence associated with a command buffer before reusing it. </span><span class="koboSpan" id="kobo.921.2">If the fence has been signaled, no wait is necessary, but if the fence has </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.922.1">not been signaled before reusing a command buf</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.923.1">fer, the application must wait for it to be signaled </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">before continuing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.925.1"><img alt="Figure 1.5 – Recording and submitting command buffers using fences" src="image/B18491_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.926.1">Figure 1.5 – Recording and submitting command buffers using fences</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.927.1">Allocate command buffers as needed. </span><span class="koboSpan" id="kobo.927.2">This is the easiest approach. </span><span class="koboSpan" id="kobo.927.3">Whenever you need to record and submit commands, just allocate a new command buffer from the pool, record commands, submit it, and forget about it. </span><span class="koboSpan" id="kobo.927.4">In this case, you need to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</span></strong><span class="koboSpan" id="kobo.929.1"> flag when creating the command pool. </span><span class="koboSpan" id="kobo.929.2">You might still need a fence associated with the buffer if you need to track the state of resources used by the commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">that buffer.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.931.1">Limiting the number of command buffers your application uses is a good practice that can help reduce the amount of memory your </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">program needs.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.933.1">Creating render passes</span></h1>
<p><span class="koboSpan" id="kobo.934.1">A render pass </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.935.1">object represents a series of rendering operations that read from and write to images. </span><span class="koboSpan" id="kobo.935.2">It’s a high-level abstraction that helps the GPU optimize the rendering process. </span><span class="koboSpan" id="kobo.935.3">An attachment in Vulkan is a reference to an image that is used as a target during a render pass. </span><span class="koboSpan" id="kobo.935.4">Attachments can be color attachments (for storing color information) or depth or stencil attachments (for storing depth/stencil information).</span><a id="_idTextAnchor086"/> <span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.936.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.937.1">.6</span></em><span class="koboSpan" id="kobo.938.1"> shows an overview of what a render pass object </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">consists of:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.940.1"><img alt="Figure 1.6 – Render pass and framebuffer composition" src="image/B18491_01_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.941.1">Figure 1.6 – Render pass and framebuffer composition</span></p>
<p><span class="koboSpan" id="kobo.942.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.944.1"> structure is used when creating a render pass in Vulkan to define the properties of each attachment. </span><span class="koboSpan" id="kobo.944.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">initialLayout</span></strong><span class="koboSpan" id="kobo.946.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">finalLayout</span></strong><span class="koboSpan" id="kobo.948.1"> fields play a crucial role in optimizing the usage of attachments and layout transitions </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.949.1">during the render pass execution. </span><span class="koboSpan" id="kobo.949.2">By setting the initial and final layouts correctly, you can avoid using additional pipeline barriers to transition image layouts, as these transitions are automatically managed by the render pass execution. </span><span class="koboSpan" id="kobo.949.3">For example, if you can have a color attachment that is initially in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">VK_IMAGE_LAYOUT_UNDEFINED</span></strong><span class="koboSpan" id="kobo.951.1"> layout and should transition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</span></strong><span class="koboSpan" id="kobo.953.1"> layout at the end of the render pass, you can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">initialLayout</span></strong><span class="koboSpan" id="kobo.955.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">finalLayout</span></strong><span class="koboSpan" id="kobo.957.1"> fields accordingly. </span><span class="koboSpan" id="kobo.957.2">This eliminates the need for an explicit pipeline barrier to handle the transition, as the render pass will automatically perform the layout transition as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">its execution.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">A subpass is a part of a render pass that performs a specific rendering operation. </span><span class="koboSpan" id="kobo.959.2">Attachments are loaded for each subpass, read and/or written to, and finally stored at the end of the subpass. </span><span class="koboSpan" id="kobo.959.3">Load and store operations define whether an attachment’s contents should be loaded, cleared, or not cared about (which means the driver/hardware is free to choose what to do – or what not to do) while being loaded and whether they should be stored or not cared about when stored at the end of the pass. </span><span class="koboSpan" id="kobo.959.4">They have a significant impact on performance, especially on mobile GPUs. </span><span class="koboSpan" id="kobo.959.5">For mobile GPUs, minimizing the number of load/store operations can lead to significant performance improvements. </span><span class="koboSpan" id="kobo.959.6">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span></strong><span class="koboSpan" id="kobo.961.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">VK_ATTACHMENT_STORE_OP_DONT_CARE</span></strong><span class="koboSpan" id="kobo.963.1"> when possible, we can avoid unnecessary memory bandwidth usage, which is a common bottleneck on </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">mobile devices.</span></span></p>
<p><span class="koboSpan" id="kobo.965.1">A subpass dependency describes the order in which subpasses should be executed and the synchronization </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.966.1">required between them. </span><span class="koboSpan" id="kobo.966.2">On mobile GPUs, using multiple subpasses can help reduce memory bandwidth usage by keeping intermediate data in on-chip memory (tile-based rendering). </span><span class="koboSpan" id="kobo.966.3">This avoids the need to write and read back data from the main memory, which can be expensive in terms of power consumption </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.968.1">Vulkan also supports render pass compatibility, which allows a framebuffer created for one render pass to be used with another compatible render pass, enhancing resource utilization and performance. </span><span class="koboSpan" id="kobo.968.2">Compatibility requires matching attachment counts, formats, load/store operations, sample counts, and compatible layouts; however, subpass structures </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">can differ.</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">In this recipe, you will learn how to create </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">render passes.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.972.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.973.1">The creation of a render pass isn’t complicated but requires an assortment of information that is easier to manage if encapsulated in its own class. </span><span class="koboSpan" id="kobo.973.2">This way, the destructor of the class can take care of destroying the object at the right time, without us having to add code to deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">its destruction.</span></span></p>
<p><span class="koboSpan" id="kobo.975.1">Render passes are wrapped by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">VulkanCore::RenderPass</span></strong><span class="koboSpan" id="kobo.977.1"> class in the code provided with </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">the book.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.979.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.980.1">Creating a render pass needs a list of all attachments that will be used in that pass, along with their load and store operations and the final layout desired for each one of the attachments. </span><span class="koboSpan" id="kobo.980.2">A render pass must be associated with a type of pipeline (graphics, compute, and so on), so the constructor also takes a value of </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">VkPipelineBindPoint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.984.1">The following code sample shows one of the constructors of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">VulkanCore::RenderPass</span></strong><span class="koboSpan" id="kobo.986.1"> class. </span><span class="koboSpan" id="kobo.986.2">Be aware that we have not yet introduced Vulkan images (which are encapsulated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">Texture</span></strong><span class="koboSpan" id="kobo.988.1"> class in the code). </span><span class="koboSpan" id="kobo.988.2">We will discuss images in more detail in </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.989.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.990.1">, Working with Modern Vulkan,</span></em><span class="koboSpan" id="kobo.991.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.992.1">Creating images (</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.993.1">textures)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.994.1"> recipe.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.995.1">The constructor iterates over all attachments that will be used in the render pass and creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.997.1"> structure for each one. </span><span class="koboSpan" id="kobo.997.2">This structure contains basic information that is extracted from the attachments themselves (such as format and initial layout), but it also records what to do with each </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.998.1">attachment when it is loaded and stored. </span><span class="koboSpan" id="kobo.998.2">While iterating over all the attachments used in the render pass, we create two other auxiliary variables: one list with the indices of attachments that are of type color (</span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">colorAttachmentReferences</span></strong><span class="koboSpan" id="kobo.1000.1">) and a variable that stores the index of the attachment that is depth and/or stencil (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">depthStencilAttachmentReference</span></strong><span class="koboSpan" id="kobo.1002.1">), since render passes only support one </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">depth/stencil attachment:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
RenderPass::RenderPass(
    const Context&amp; context,
    const std::vector&lt;std::shared_ptr&lt;Texture&gt;&gt;
        attachments,
    const std::vector&lt;VkAttachmentLoadOp&gt;&amp; loadOp,
    const std::vector&lt;VkAttachmentStoreOp&gt;&amp; storeOp,
    const std::vector&lt;VkImageLayout&gt;&amp; layout,
    VkPipelineBindPoint bindPoint,
    const std::string&amp; name)
    : device_{context.device()} {
  ASSERT(attachments.size() == loadOp.size() &amp;&amp;
             attachments.size() == storeOp.size() &amp;&amp;
             attachments.size() == layout.size(),
         "The sizes of the attachments and their load "
         "and store operations and final layouts "
         "must match");
  std::vector&lt;VkAttachmentDescription&gt;
      attachmentDescriptors;
  std::vector&lt;VkAttachmentReference&gt;
      colorAttachmentReferences;
  std::optional&lt;VkAttachmentReference&gt;
      depthStencilAttachmentReference;</span></pre></li> <li><span class="koboSpan" id="kobo.1005.1">For each </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.1006.1">attachment, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">VkAttachmentDescription</span></strong><span class="koboSpan" id="kobo.1008.1"> structure and append it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">attachmentDescriptors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1"> vector:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
  for (uint32_t index = 0; index &lt; attachments.size();
       ++index) {
    attachmentDescriptors.emplace_back(
        VkAttachmentDescription{
            .format = attachments[index]-&gt;vkFormat(),
            .samples = VK_SAMPLE_COUNT_1_BIT,
            .loadOp =
                attachments[index]-&gt;isStencil()
                    ? </span><span class="koboSpan" id="kobo.1011.2">VK_ATTACHMENT_LOAD_OP_DONT_CARE
                    : loadOp[index],
            .storeOp =
                attachments[index]-&gt;isStencil()
                    ? </span><span class="koboSpan" id="kobo.1011.3">VK_ATTACHMENT_STORE_OP_DONT_CARE
                    : storeOp[index],
            .stencilLoadOp =
                attachments[index]-&gt;isStencil()
                    ? </span><span class="koboSpan" id="kobo.1011.4">loadOp[index]
                    : VK_ATTACHMENT_LOAD_OP_DONT_CARE,
            .stencilStoreOp =
                attachments[index]-&gt;isStencil()
                    ? </span><span class="koboSpan" id="kobo.1011.5">storeOp[index]
                    : VK_ATTACHMENT_STORE_OP_DONT_CARE,
            .initialLayout =
                attachments[index]-&gt;vkLayout(),
            .finalLayout = layout[index],
        });</span></pre></li> <li><span class="koboSpan" id="kobo.1012.1">If the </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.1013.1">attachment is a depth or a stencil texture, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">VkAttachmentReference</span></strong><span class="koboSpan" id="kobo.1015.1"> structure for it and store it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">depthStencilAttachmentReference</span></strong><span class="koboSpan" id="kobo.1017.1"> auxiliary variable. </span><span class="koboSpan" id="kobo.1017.2">Otherwise, the attachment is a color attachment, and we create and store a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">VkAttachmentReference</span></strong><span class="koboSpan" id="kobo.1019.1"> structure to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">colorAttachmentReferences</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1"> vector:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
    if (attachments[index]-&gt;isStencil() ||
        attachments[index]-&gt;isDepth()) {
      depthStencilAttachmentReference =
          VkAttachmentReference{
              .attachment = index,
              .layout =
                  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
          };
    } else {
      colorAttachmentReferences.emplace_back(
          VkAttachmentReference{
              .attachment = index,
              .layout =
                  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
          });
    }
  }</span></pre></li> <li><span class="koboSpan" id="kobo.1023.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">RenderPass</span></strong><span class="koboSpan" id="kobo.1025.1"> class only creates one subpass, which stores the color attachment </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.1026.1">references and the depth/stencil </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">attachment reference:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
  const VkSubpassDescription spd = {
      .pipelineBindPoint =
          VK_PIPELINE_BIND_POINT_GRAPHICS,
      .colorAttachmentCount = static_cast&lt;uint32_t&gt;(
          colorAttachmentReferences.size()),
      .pColorAttachments =
          colorAttachmentReferences.data(),
      .pDepthStencilAttachment =
          depthStencilAttachmentReference.has_value()
              ? </span><span class="koboSpan" id="kobo.1028.2">&amp;depthStencilAttachmentReference
                     .value()
              : nullptr,
  };</span></pre></li> <li><span class="koboSpan" id="kobo.1029.1">The only subpass we </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.1030.1">use for this recipe depends on an external subpass (since there’s only one subpass, it must depend on an </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">external one):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
  const VkSubpassDependency subpassDependency = {
      .srcSubpass = VK_SUBPASS_EXTERNAL,
      .srcStageMask =
          VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
          VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
      .dstStageMask =
          VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
          VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
      .dstAccessMask =
          VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
          VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
  };</span></pre></li> <li><span class="koboSpan" id="kobo.1033.1">Lastly, all this information is stored in a structure of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">VkRenderPassCreateInfo</span></strong><span class="koboSpan" id="kobo.1035.1">, which is passed, along with the device, to create a render pass with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">vkCreateRenderPass</span></strong><span class="koboSpan" id="kobo.1037.1">. </span><span class="koboSpan" id="kobo.1037.2">The handle is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">RenderPass::renderPass_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1039.1">member variable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
  const VkRenderPassCreateInfo rpci = {
      .sType =
          VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
      .attachmentCount = static_cast&lt;uint32_t&gt;(
          attachmentDescriptors.size()),
      .pAttachments = attachmentDescriptors.data(),
      .subpassCount = 1,
      .pSubpasses = &amp;spd,
      .dependencyCount = 1,
      .pDependencies = &amp;subpassDependency,
  };
  VK_CHECK(vkCreateRenderPass(device_, &amp;rpci, nullptr,
                              &amp;renderPass_));
  context.setVkObjectname(renderPass_,
                          VK_OBJECT_TYPE_RENDER_PASS,
                          "Render pass: " + name);
}</span></pre></li> <li><span class="koboSpan" id="kobo.1041.1">Destroying the </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.1042.1">render pass happens in the destructor, by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">vkDestroyRenderPass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
RenderPass::~RenderPass() {
  vkDestroyRenderPass(device_, renderPass_, nullptr);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1046.1">Render passes store information on </span><em class="italic"><span class="koboSpan" id="kobo.1047.1">what to do</span></em><span class="koboSpan" id="kobo.1048.1"> with attachments (loaded, cleared, stored) and describe subpass dependencies. </span><span class="koboSpan" id="kobo.1048.2">They also describe which attachments are resolve attachments (see the </span><em class="italic"><span class="koboSpan" id="kobo.1049.1">Enabling and using Vulkan’s MSAA</span></em><span class="koboSpan" id="kobo.1050.1"> recipe in </span><a href="B18491_06.xhtml#_idTextAnchor283"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1051.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1052.1">, Anti-Aliasing Techniques</span></em><span class="koboSpan" id="kobo.1053.1">, to know more about resolve attachments and how they are used to implement MSAA </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">in Vulkan).</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.1055.1">Creating framebuffers</span></h1>
<p><span class="koboSpan" id="kobo.1056.1">While the render pass object contains information about what to do with each attachment </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.1057.1">and their initial and final layouts, a framebuffer contains actual references to the attachments used in the render pass, which are provided in the form </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">VkImageViews</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1061.1">In this recipe, you will learn how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">framebuffer object.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.1063.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1064.1">In the repository, Vulkan framebuffers are encapsulated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">VulkanCore::Framebuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1"> class.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.1067.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1068.1">Framebuffers refer to attachments (it answers the question “Which attachments will we be using for this </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">render pass?”).</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1070.1">The references are image views and are passed as a list, along with the handle of the render pass, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">vkCreateFramebuffer</span></strong><span class="koboSpan" id="kobo.1072.1"> framebuffer </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">creation function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
uint32_t width, height; // Width and height of attachments
VkDevice device; // Valid Vulkan Device
std::vector&lt;VkImageView&gt; imageViews; // Valid Image Views
const VkFramebufferCreateInfo framebufferInfo = {
    .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    .renderPass = renderPass,
    .attachmentCount =
        static_cast&lt;uint32_t&gt;(attachments.size()),
    .pAttachments = imageViews.data(),
    .width = attachments[0]-&gt;vkExtents().width,
    .height = attachments[0]-&gt;vkExtents().height,
    .layers = 1,
};
VK_CHECK(
    vkCreateFramebuffer(device_, &amp;framebufferInfo,
                        nullptr, &amp;framebuffer_));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1075.1">Creating </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.1076.1">framebuffers is straightforward, and they are not strictly necessary anymore if you use </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">dynamic rendering.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1078.1">Creating image views</span></h1>
<p><span class="koboSpan" id="kobo.1079.1">In Vulkan, an image view is a way to specify how an image should be interpreted and accessed by the GPU. </span><span class="koboSpan" id="kobo.1079.2">It provides a view into an image’s memory and defines its format, dimensions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">data layout.</span></span></p>
<p><span class="koboSpan" id="kobo.1081.1">An image view </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.1082.1">can be thought of as a window into an image’s memory that describes how the image should be accessed. </span><span class="koboSpan" id="kobo.1082.2">It allows the image to be used in a variety of ways, such as a source or destination for rendering commands, or as a texture in </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">a shader.</span></span></p>
<p><span class="koboSpan" id="kobo.1084.1">Image views are created by specifying the image they will be associated with, along with a set of parameters that define the image’s format, aspect ratio, and range. </span><span class="koboSpan" id="kobo.1084.2">Once created, an image view can be bound to a pipeline or shader to be used in rendering or other operations. </span><span class="koboSpan" id="kobo.1084.3">They are represented by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">VkImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.1087.1">In this recipe, you will learn how to create </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">image views.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1089.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1090.1">In the repository, image views are stored by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.1092.1"> class and don’t have a </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">dedicated wrapper.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.1094.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1095.1">Before creating </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.1096.1">an image view, you need the handle a Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">image object:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1098.1">Creating an image view is simple; all you need is the handle to a Vulkan image object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">VkImage</span></strong><span class="koboSpan" id="kobo.1100.1">) and a few parameters that dictate how to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">underlying image:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1102.1">
VkImage image; // Valid VkImage
const VkImageAspectFlags aspectMask =
    isDepth() ? </span><span class="koboSpan" id="kobo.1102.2">VK_IMAGE_ASPECT_DEPTH_BIT
              : VK_IMAGE_ASPECT_COLOR_BIT;
const VkImageViewCreateInfo imageViewInfo = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    .image = image_,
    .viewType = viewType,
    .format = format,
    .components =
        {
            .r = VK_COMPONENT_SWIZZLE_IDENTITY,
            .g = VK_COMPONENT_SWIZZLE_IDENTITY,
            .b = VK_COMPONENT_SWIZZLE_IDENTITY,
            .a = VK_COMPONENT_SWIZZLE_IDENTITY,
        },
    .subresourceRange = {
        .aspectMask = aspectMask,
        .baseMipLevel = 0,
        .levelCount = numMipLevels,
        .baseArrayLayer = 0,
        .layerCount = layers,
    }};
VK_CHECK(vkCreateImageView(context_.device(),
                            &amp;imageViewInfo, nullptr,
                            &amp;imageView_));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1103.1">Image views </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.1104.1">can span an entire image (mip levels and layers), just one element (mip level or layer), or even just a portion of </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">the image.</span></span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1106.1">The Vulkan graphics pipeline</span></h1>
<p><span class="koboSpan" id="kobo.1107.1">The graphics pipeline is a crucial concept that describes the process of rendering graphics in </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.1108.1">a Vulkan application. </span><span class="koboSpan" id="kobo.1108.2">The pipeline consists of a series of stages, each with a specific purpose, that take raw data and transform it into a fully rendered image on the screen. </span><span class="koboSpan" id="kobo.1108.3">While some stages of the pipeline are more obvious, such as the viewport or rasterization, other stages such as the shader stage, vertex input, and dynamic states are less apparent but equally important. </span><span class="koboSpan" id="kobo.1108.4">In the following recipes, we will explore some of the less obvious stages of the pipeline and explain their importance in the rendering process. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1109.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1110.1">.7</span></em><span class="koboSpan" id="kobo.1111.1"> shows an overview of all str</span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.1112.1">uctures you may need to populate to create a graphics pipeline and </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">their properties:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.1114.1"><img alt="Figure 1.7 – Vulkan graphics pipeline" src="image/B18491_01_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1115.1">Figure 1.7 – Vulkan graphics pipeline</span></p>
<p><span class="koboSpan" id="kobo.1116.1">In this recipe, you will learn a little more about pipelines in Vulkan and their most </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">important characteristics.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1118.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.1119.1">Here are the </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.1120.1">most important characteristics of pipelines </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">in Vulkan:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1122.1">In Vulkan, graphics pipelines are mostly immutable objects, meaning that once they are created, they cannot be modified except in certain instances. </span><span class="koboSpan" id="kobo.1122.2">This is why it is necessary to create a new pipeline with a different topology if you wish to reuse a pipeline to draw different shapes. </span><span class="koboSpan" id="kobo.1122.3">However, some pipeline properties can be changed dynamically at runtime, such as the viewport and scissor rectangles, which are referred to as </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">dynamic states.</span></span></li>
<li><span class="koboSpan" id="kobo.1124.1">One important exception to the pipeline stages that won’t be covered in this book is the vertex input state. </span><span class="koboSpan" id="kobo.1124.2">Although it is not entirely straightforward to create, we will </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.1125.1">not discuss it here since we exclusively utilize the </span><strong class="bold"><span class="koboSpan" id="kobo.1126.1">Programmable Vertex Pulling</span></strong><span class="koboSpan" id="kobo.1127.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1128.1">PVP</span></strong><span class="koboSpan" id="kobo.1129.1">) method to access indices and vertices at the vertex shader stage. </span><span class="koboSpan" id="kobo.1129.2">For additional information about PVP, please refer to the  </span><em class="italic"><span class="koboSpan" id="kobo.1130.1">Implementing Programmable Vertex Pulling and Multi-Draw Indirect</span></em><span class="koboSpan" id="kobo.1131.1"> recipe in </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1132.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1133.1">, Working with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1134.1">Modern Vulkan.</span></em></span></li>
<li><span class="koboSpan" id="kobo.1135.1">Similarly, the pipeline layout, a property of the graphics pipeline (and not a stage), is a data structure that outlines the anticipated layout of resources utilized by the shaders, including their location, quantity, and type, as well as pertinent details regarding push constants. </span><span class="koboSpan" id="kobo.1135.2">Since this chapter does not provide any resources to the shaders, the pipeline layout is initialized with default values. </span><span class="koboSpan" id="kobo.1135.3">Descriptor sets and push constants will be covered in </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1136.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1137.1">, Working with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1138.1">Modern Vulkan.</span></em></span></li>
</ol>
<h1 id="_idParaDest-89"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1139.1">Compiling shaders to SPIR-V</span></h1>
<p><span class="koboSpan" id="kobo.1140.1">In contrast to OpenGL, which typically compiles shaders from high-level languages into binary </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.1141.1">format during runtime, Vulkan only supports an intermediate </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.1142.1">representation called SPIR-V. </span><span class="koboSpan" id="kobo.1142.2">SPIR-V is a </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.1143.1">cross-platform, low-level intermediate representation that can be produced from various </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">shading languages.</span></span></p>
<p><span class="koboSpan" id="kobo.1145.1">In this recipe, you will learn how to compile GLSL to SPIR-V using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">glslang</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1"> library.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.1148.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1149.1">In this recipe, we use a third-party library that compiles GLSL code into SPIR-V at runtime </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.1150.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">glslang</span></strong><span class="koboSpan" id="kobo.1152.1">. </span><span class="koboSpan" id="kobo.1152.2">It can be downloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">from </span></span><a href="https://github.com/KhronosGroup/glslang.git"><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">https://github.com/KhronosGroup/glslang.git</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1156.1">In our code, we provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">VulkanCore::ShaderModule</span></strong><span class="koboSpan" id="kobo.1158.1"> class that encapsulates shaders. </span><span class="koboSpan" id="kobo.1158.2">It provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">ShaderModule::glslToSpirv</span></strong><span class="koboSpan" id="kobo.1160.1"> method (and overloads) that compiles shader source code from GLSL </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">to SPIR-V.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1162.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1163.1">The steps presented here are part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">ShaderModule::glslToSpirv()</span></strong><span class="koboSpan" id="kobo.1165.1"> method. </span><span class="koboSpan" id="kobo.1165.2">Here’s how </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">it works:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1167.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">glslang</span></strong><span class="koboSpan" id="kobo.1169.1"> library needs to be initialized once by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">glslang::InitializeProcess()</span></strong><span class="koboSpan" id="kobo.1171.1">, so its initialization is guarded by a static </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">Boolean variable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1173.1">
std::vector&lt;char&gt; ShaderModule::glslToSpirv(
    const std::vector&lt;char&gt;&amp; data,
    EShLanguage shaderStage,
    const std::string&amp; shaderDir,
    const char* entryPoint) {
  static bool glslangInitialized = false;
  if (!glslangInitialized) {
    glslang::InitializeProcess();
    glslangInitialized = true;
  }</span></pre></li> <li><span class="koboSpan" id="kobo.1174.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">TShader</span></strong><span class="koboSpan" id="kobo.1176.1"> object is instantiated by a function to contain shaders and various other parameters that are necessary for generating SPIR-V bytecode. </span><span class="koboSpan" id="kobo.1176.2">These </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.1177.1">parameters include the input client and GLSL </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.1178.1">versions, as well as entry points into </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">the shaders:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1180.1">
  glslang::TShader tshader(shaderStage);
  const char* glslCStr = data.data();
  tshader.setStrings(&amp;glslCStr, 1);
  glslang::EshTargetClientVersion clientVersion =
      glslang::EShTargetVulkan_1_3;
  glslang::EShTargetLanguageVersion langVersion =
      glslang::EShTargetSpv_1_3;
  tshader.setEnvInput(glslang::EShSourceGlsl,
                      shaderStage,
                      glslang::EShClientVulkan, 460);
  tshader.setEnvClient(glslang::EShClientVulkan,
                       clientVersion);
  tshader.setEnvTarget(glslang::EShTargetSpv,
                       langVersion);
  tshader.setEntryPoint(entryPoint);
  tshader.setSourceEntryPoint(entryPoint);</span></pre></li> <li><span class="koboSpan" id="kobo.1181.1">Afterward, we collect constraints on resources that are typically available for shaders </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.1182.1">in the system, such as the maximum </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.1183.1">number of textures or vertex attributes, and establish messages that the compiler should present. </span><span class="koboSpan" id="kobo.1183.2">Lastly, we compile the shader into SPIR-V and verify </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">the result:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1185.1">
  const TBuiltInResource* resources =
      GetDefaultResources();
  const EShMessages messages =
      static_cast&lt;EShMessages&gt;(
          EShMsgDefault | EShMsgSpvRules |
          EShMsgVulkanRules | EShMsgDebugInfo |
          EShMsgReadHlsl);
  CustomIncluder includer(shaderDir);
  std::string preprocessedGLSL;
  if (!tshader.preprocess(
          resources, 460, ENoProfile, false, false,
          messages, &amp;preprocessedGLSL, includer)) {
    std::cout &lt;&lt; "Preprocessing failed for shader: "
              &lt;&lt; std::endl;
    printShader(data);
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; tshader.getInfoLog() &lt;&lt; std::endl;
    std::cout &lt;&lt; tshader.getInfoDebugLog()
              &lt;&lt; std::endl;
    ASSERT(false, "includes are forbidden");
    return std::vector&lt;char&gt;();
  }</span></pre></li> <li><span class="koboSpan" id="kobo.1186.1">In the last phase, linking options are established for both debug and release builds. </span><span class="koboSpan" id="kobo.1186.2">In debug builds, regular debugging information is enabled while optimizations </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.1187.1">and debug information stripping </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.1188.1">are disabled. </span><span class="koboSpan" id="kobo.1188.2">Conversely, in release builds, the optimizer is enabled, which may result in the removal of unused shader variables, including structure members. </span><span class="koboSpan" id="kobo.1188.3">However, because discrepancies in structure sizes may cause problems if the same optimizations are not applied to the C++ code, optimizations are also disabled in </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">release builds:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1190.1">
  glslang::SpvOptions options;
#ifdef _DEBUG
  tshader.setDebugInfo(true);
  options.generateDebugInfo = true;
  options.disableOptimizer = true;
  options.optimizeSize = false;
  options.stripDebugInfo = false;
  options.emitNonSemanticShaderDebugSource = true;
#else
  options.disableOptimizer = true;  // Special care!
</span><span class="koboSpan" id="kobo.1190.2">  options.optimizeSize = true;
  options.stripDebugInfo = true;
#endif
  glslang::TProgram program;
  program.addShader(&amp;tshader);
  if (!program.link(messages)) {
    std::cout &lt;&lt; "Parsing failed for shader "
              &lt;&lt; std::endl;
    std::cout &lt;&lt; program.getInfoLog() &lt;&lt; std::endl;
    std::cout &lt;&lt; program.getInfoDebugLog()
              &lt;&lt; std::endl;
    ASSERT(false, "link failed");
  }
  std::vector&lt;uint32_t&gt; spirvData;
  spv::SpvBuildLogger spvLogger;
  glslang::GlslangToSpv(
       program.getIntermediate(shaderStage), spirvData,
      &amp;spvLogger, &amp;options);
  std::vector&lt;char&gt; byteCode;
  byteCode.resize(spirvData.size() *
                  (sizeof(uint32_t) / sizeof(char)));
  std::memcpy(byteCode.data(), spirvData.data(),
              byteCode.size());
  return byteCode;
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1191.1">For truly </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.1192.1">performant applications, shaders are not compiled from </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.1193.1">GLSL at runtime. </span><span class="koboSpan" id="kobo.1193.2">They are compiled at build time and loaded from disk in the SPIR-V format when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">application starts.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.1195.1">Dynamic states</span></h1>
<p><span class="koboSpan" id="kobo.1196.1">While </span><strong class="bold"><span class="koboSpan" id="kobo.1197.1">pipeline state objects</span></strong><span class="koboSpan" id="kobo.1198.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">PSOs</span></strong><span class="koboSpan" id="kobo.1200.1">) include immutable states, such as shader programs and </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.1201.1">vertex input bindings, some properties of a pipeline state can be changed dynamically at draw time using dynamic state objects. </span><span class="koboSpan" id="kobo.1201.2">This </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.1202.1">feature provides greater flexibility and can minimize the necessity to recreate pipelines. </span><span class="koboSpan" id="kobo.1202.2">Dynamic state objects can be used to change properties such as viewport and scissor rectangles, line width, blend constants, and stencil reference values. </span><span class="koboSpan" id="kobo.1202.3">However, not all properties of a pipeline can be changed dynamically, and the use of dynamic states can have a small </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">performance overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.1204.1">Without using dynamic states, the application has a few </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">alternatives available:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1206.1">Create pipelines during the application startup. </span><span class="koboSpan" id="kobo.1206.2">If you are aware of which pipelines will be required, they can be created beforehand at the expense of a higher </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">startup cost.</span></span></li>
<li><span class="koboSpan" id="kobo.1208.1">Utilize pipeline caches. </span><span class="koboSpan" id="kobo.1208.2">The graphics driver features a built-in mechanism for pipeline caching that can automatically generate a cache </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">for you.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1210.1">Several parameters, such as the viewport, line width, and depth bias, can be dynamically modified. </span><span class="koboSpan" id="kobo.1210.2">While some dynamic states were included in Vulkan 1.0, others were added as extensions or included as part of Vulkan 1.3. </span><span class="koboSpan" id="kobo.1210.3">If a parameter is marked as dynamic (using the appropriate structure), its value is ignored during </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">pipeline creation.</span></span></p>
<p><span class="koboSpan" id="kobo.1212.1">In this recipe, you will learn about dynamic states, which allow some pipeline parameters to be dynamically set after a pipeline has </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">been created.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1214.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1215.1">Dynamic states are created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">VkPipelineDynamicStateCreateInfo</span></strong><span class="koboSpan" id="kobo.1217.1"> structure. </span><span class="koboSpan" id="kobo.1217.2">An instance of this structure is filled with states you would like to be dynamic and is later plugged into the creation of a pipeline, which we’ll cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">next recipe.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1219.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1220.1">To allow </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.1221.1">parameters to be dynamically set, we need to create an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">VkPipelineDynamicStateCreateInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1"> structure.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1224.1">The next code fragment shows how to enable the dynamic state for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">viewport parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1226.1">
const std::array&lt;VkDynamicState, 1&gt; dynamicStates = {
    VK_DYNAMIC_STATE_VIEWPORT,
};
const VkPipelineDynamicStateCreateInfo dynamicState = {
    .sType =
      VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    .dynamicStateCount =
        static_cast&lt;uint32_t&gt;(dynamicStates.size()),
    .pDynamicStates = dynamicStates.data(),
};</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">VkDynamicState</span></strong><span class="koboSpan" id="kobo.1228.1"> is an enumeration that contains all possible states that can be dynamically set. </span><span class="koboSpan" id="kobo.1228.2">In the preceding snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">dynamicStates</span></strong><span class="koboSpan" id="kobo.1230.1"> array contains only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">VK_DYNAMIC_STATE_VIEWPORT</span></strong><span class="koboSpan" id="kobo.1232.1"> value, but it may contain a much larger set of values </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">VkDynamicState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1236.1">The previously created instance will be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">next recipe.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1238.1">Creating a graphics pipeline</span></h1>
<p><span class="koboSpan" id="kobo.1239.1">Once all </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.1240.1">the required states and pipeline properties have been gathered and instantiated, creating a graphics pipeline in Vulkan is a straightforward process. </span><span class="koboSpan" id="kobo.1240.2">This involves populating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">VkGraphicsPipelineCreateInfo</span></strong><span class="koboSpan" id="kobo.1242.1"> structure and </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">vkCreateGraphicsPipelines</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1246.1">In this recipe, you will learn how to create a graphics pipeline object </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">in Vulkan.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1248.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1249.1">For more information, please refer to the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">VulkanCore::Pipeline</span></strong><span class="koboSpan" id="kobo.1251.1"> class in </span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">the repository.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.1253.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1254.1">Populating the structures referenced by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">VkGraphicsPipelineCreateInfo</span></strong><span class="koboSpan" id="kobo.1256.1"> is not complicated, but a </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">tedious task.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1258.1">Once all structures of all states have been instantiated, all we need to do is create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">VkGraphicsPipelineCreateInfo</span></strong><span class="koboSpan" id="kobo.1260.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">vkCreateGraphicsPipelines</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1264.1">
const VkGraphicsPipelineCreateInfo pipelineInfo = {
    .sType=VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    .stageCount = uint32_t(shaderStages.size()),
    .pStages = shaderStages.data(),
    .pVertexInputState = &amp;vinfo,
    .pInputAssemblyState = &amp;inputAssembly,
    .pViewportState = &amp;viewportState,
    .pRasterizationState = &amp;rasterizer,
    .pMultisampleState = &amp;multisampling,
    .pDepthStencilState = &amp;depthStencilState, // Optional
    .pColorBlendState = &amp;colorBlending,
    .pDynamicState = &amp;dynamicState,
    .layout = layout,
    .renderPass = renderPass,
    .basePipelineHandle = VK_NULL_HANDLE, // Optional
    .basePipelineIndex = -1,  // Optional
};
VkPipeline gfxPipeline = VK_NULL_HANDLE;
VK_CHECK(vkCreateGraphicsPipelines(
    device_, VK_NULL_HANDLE, 1, &amp;pipelineInfo,
    nullptr, &amp;gfxPipeline));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1265.1">Creating a </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.1266.1">graphics pipeline is an expensive operation. </span><span class="koboSpan" id="kobo.1266.2">One way to avoid the penalty of creating pipelines is to cache them and reuse them the next time your </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">application runs.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1268.1">Swapchain</span></h1>
<p><span class="koboSpan" id="kobo.1269.1">A swapchain in Vulkan </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.1270.1">mimics the functionality of double and triple buffering from OpenGL but with a more explicit role for the application in managing swapchain buffers. </span><span class="koboSpan" id="kobo.1270.2">This approach provides better control over the configuration, synchronization, and presentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">of images.</span></span></p>
<p><span class="koboSpan" id="kobo.1272.1">A Vulkan swapchain is a collection of images associated with a surface (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">VkSurfaceKHR</span></strong><span class="koboSpan" id="kobo.1274.1">) that are used to display rendering outputs in a window. </span><span class="koboSpan" id="kobo.1274.2">Even though it is a key part of the Vulkan API, the functions and types used to create and manage a swapchain are part of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">VK_KHR_swapchain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1"> extension.</span></span></p>
<p><span class="koboSpan" id="kobo.1277.1">The number of images in a swapchain object must be determined during its construction but must fall between the minimum (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">minImageCount</span></strong><span class="koboSpan" id="kobo.1279.1">) and maximum (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">maxImageCount</span></strong><span class="koboSpan" id="kobo.1281.1">) possible values provided by the device. </span><span class="koboSpan" id="kobo.1281.2">Those values can be retrieved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">VkSurfaceCapabilitiesKHR</span></strong><span class="koboSpan" id="kobo.1283.1"> structure of the Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">physical device.</span></span></p>
<p><span class="koboSpan" id="kobo.1285.1">Swapchain </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.1286.1">images (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">VkImage</span></strong><span class="koboSpan" id="kobo.1288.1">) are created and owned by the swapchain object and, as a result, their memory isn’t provided or allocated by the application. </span><span class="koboSpan" id="kobo.1288.2">Image views (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">VkImageView</span></strong><span class="koboSpan" id="kobo.1290.1">) are not created by the swapchain object and thus must be </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">created separately.</span></span></p>
<p><span class="koboSpan" id="kobo.1292.1">In this recipe, you will learn how to create, manage, and destroy </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">swapchain images.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1294.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1295.1">The swapchain is managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">VulkanCore::Swapchain</span></strong><span class="koboSpan" id="kobo.1297.1"> class in </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">the code.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1299.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1300.1">The swapchain extension provides a set of functions and types to create, manage, and destroy swapchains. </span><span class="koboSpan" id="kobo.1300.2">Some key functions and types include </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">the following:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">vkCreateSwapchainKHR</span></strong><span class="koboSpan" id="kobo.1303.1">: This function is used to create a swapchain. </span><span class="koboSpan" id="kobo.1303.2">You need to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">VkSwapchainCreateInfoKHR</span></strong><span class="koboSpan" id="kobo.1305.1"> structure that contains details about the surface, the number of images, their format, dimensions, usage flags, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">swapchain properties.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">vkGetSwapchainImagesKHR</span></strong><span class="koboSpan" id="kobo.1308.1">: After creating a swapchain, this function is used to retrieve handles to the images in the swapchain. </span><span class="koboSpan" id="kobo.1308.2">You can then create image views and framebuffers for rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">and presentation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">vkAcquireNextImageKHR</span></strong><span class="koboSpan" id="kobo.1311.1">: This function is used to acquire an available image from the swapchain for rendering. </span><span class="koboSpan" id="kobo.1311.2">It also requires providing a semaphore or fence to signal when the image is ready </span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">for rendering.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">vkQueuePresentKHR</span></strong><span class="koboSpan" id="kobo.1314.1">: Once rendering is complete, this function is used to submit the swapchain image for presentation on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">display device.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">vkDestroySwapchainKHR</span></strong><span class="koboSpan" id="kobo.1317.1">: This function is responsible for destroying the swapchain and cleaning up resources associated </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">with it.</span></span></li>
</ol>
<h1 id="_idParaDest-101"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1319.1">Understanding synchronization in the swapchain – fences and semaphores</span></h1>
<p><span class="koboSpan" id="kobo.1320.1">The application and the GPU processes run in parallel; unless specified otherwise, the command </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.1321.1">buffers and their commands also run in parallel on the GPU. </span><span class="koboSpan" id="kobo.1321.2">To enforce an order between the CPU and the GPU, and between command </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.1322.1">buffers being processed in the GPU, Vulkan provides two mechanisms: </span><strong class="bold"><span class="koboSpan" id="kobo.1323.1">fences</span></strong><span class="koboSpan" id="kobo.1324.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1325.1">semaphores</span></strong><span class="koboSpan" id="kobo.1326.1">. </span><span class="koboSpan" id="kobo.1326.2">Fences are used to synchronize </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.1327.1">work between </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.1328.1">the GPU and the CPU, while semaphores are used to synchronize workloads executed in </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.1330.1">In this recipe, you will learn about fences and semaphores: why they are necessary, how they are used (and when), and how to use semaphores with </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">a swapchain.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.1332.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1333.1">Examples of semaphores can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">VulkanCore::Swapchain</span></strong><span class="koboSpan" id="kobo.1335.1"> class, while examples of fences can be found in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">VulkanCore::CommandQueueManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1"> class.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1338.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1339.1">Fences and semaphores have different uses. </span><span class="koboSpan" id="kobo.1339.2">Let’s explore each one of those elements and how to use semaphores </span><span class="No-Break"><span class="koboSpan" id="kobo.1340.1">with swapchains.</span></span></p>
<ol>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1341.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1342.1">.8</span></em><span class="koboSpan" id="kobo.1343.1"> shows how an application, running on the CPU, may submit commands to the GPU and proceed with its work right after submission (without synchronization). </span><span class="koboSpan" id="kobo.1343.2">This may be intended, but if you wish to wait for commands on the GPU to finish being processed before continuing, you may use a fence to signal when work on the GPU has been complete</span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1344.1">d. </span><span class="koboSpan" id="kobo.1344.2">Once commands on the GPU are finished processing, the fence is signaled, and the application </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">may proceed:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.1346.1"><img alt="Figure 1.8 – Command buffer recording and execution on the device without synchronization" src="image/B18491_01_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1347.1">Figure 1.8 – Command buffer recording and execution on the device without synchronization</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1348.1">Semaphores </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.1349.1">work in a similar manner but are used </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.1350.1">between commands or jobs running on the GPU. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1351.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1352.1">.10</span></em><span class="koboSpan" id="kobo.1353.1"> illustrates using a semaphore to synchronize commands being processed on the GPU. </span><span class="koboSpan" id="kobo.1353.2">The application is responsible for creating semaphores and adding dependencies between command buffers and semaphores itself before submitting the buffers for processing. </span><span class="koboSpan" id="kobo.1353.3">Once a task is processed on the GPU, the semaphore is signaled, and the next task can continue. </span><span class="koboSpan" id="kobo.1353.4">This enforces an ordering </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">between commands:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.1355.1"><img alt="Figure 1.9 – Fences" src="image/B18491_01_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1356.1">Figure 1.9 – Fences</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1357.1">The process of acquiring an image, rendering, and presenting are all asynchronous and need to be synchronized. </span><span class="koboSpan" id="kobo.1357.2">In this recipe, we will use two semaphores </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.1358.1">for the synchronization: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">imageAvaila</span><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1360.1">ble</span></strong><span class="koboSpan" id="kobo.1361.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">imageRendered</span></strong><span class="koboSpan" id="kobo.1363.1">. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1364.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1365.1">.10</span></em><span class="koboSpan" id="kobo.1366.1"> illustrates how semaphores </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.1367.1">affect the execution of commands on </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">the device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.1369.1"><img alt="Figure 1.10 – Semaphores" src="image/B18491_01_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1370.1">Figure 1.10 – Semaphores</span></p>
<p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">imageAvailable_</span></strong><span class="koboSpan" id="kobo.1372.1"> is signaled once the image acquired is available, prompting the command queue that will render into the image to start processing. </span><span class="koboSpan" id="kobo.1372.2">Once the command buffer finishes, it signals the other semaphore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">imageRendered</span></strong><span class="koboSpan" id="kobo.1374.1">, which in turn allows the presentat</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1375.1">ion of that image to start. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1376.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1377.1">.11</span></em><span class="koboSpan" id="kobo.1378.1"> demonstrates how synchronization is implemented using </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">two semaphores:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.1380.1"><img alt="Figure 1.11 – Synchronization of the swapchain" src="image/B18491_01_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1381.1">Figure 1.11 – Synchronization of the swapchain</span></p>
<p><span class="koboSpan" id="kobo.1382.1">Fences and </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.1383.1">semaphores aren’t difficult to understand, but they </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.1384.1">are crucial for synchronization in Vulkan. </span><span class="koboSpan" id="kobo.1384.2">Make sure you understand how they are used </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">before continuing.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1386.1">Populating submission information for presentation</span></h1>
<p><span class="koboSpan" id="kobo.1387.1">Submitting a command buffer requires an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">VkSubmitInfo</span></strong><span class="koboSpan" id="kobo.1389.1"> structure, which allows </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.1390.1">specifying semaphores for waiting (to start processing) and signaling (once the command buffer finishes executing). </span><span class="koboSpan" id="kobo.1390.2">Those semaphores are optional and usually not needed. </span><span class="koboSpan" id="kobo.1390.3">But when submitting a command buffer for presenting images onto the screen, those semaphores allow Vulkan to synchronize the execution of the buffer with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">presentation engine.</span></span></p>
<p><span class="koboSpan" id="kobo.1392.1">In this recipe, you will learn how to submit a command buffer for processing by the GPU after it has </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">been recorded.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1394.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1395.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">VulkanCore::Swapchain</span></strong><span class="koboSpan" id="kobo.1397.1"> class in the repository provides a utility function to fill the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">VkSubmitInfo</span></strong><span class="koboSpan" id="kobo.1399.1"> structure for you since the semaphores used to synchronize the execution with the presentation engine are stored in the swapchain. </span><span class="koboSpan" id="kobo.1399.2">If no semaphores are needed in the structure, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">waitForImageAvailable</span></strong><span class="koboSpan" id="kobo.1401.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">signalImagePresented</span></strong><span class="koboSpan" id="kobo.1403.1"> parameters should be set </span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.1407.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1408.1">The synchronization information used to submit command buffers that need to be synchronized </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.1409.1">with the presentation engine is provided by an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">VkSubmitInfo</span></strong><span class="koboSpan" id="kobo.1411.1"> structure and contains references to the semaphores that will be used for synchronization in the device. </span><span class="koboSpan" id="kobo.1411.2">It also contains the command buffer that will </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">be submitted.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1413.1">The fence is associated with the command buffer and is not a specific one for synchronizing </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">the swapchain:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1415.1">
const VkSubmitInfo submitInfo = {
    .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    .waitSemaphoreCount = 1,
    .pWaitSemaphores = &amp;imageAvailable,
    .pWaitDstStageMask = submitStageMask,
    .commandBufferCount = 1,
    .pCommandBuffers = buffer,
    .signalSemaphoreCount = 1,
    .pSignalSemaphores = &amp;imagePresented,
};
VK_CHECK(vkQueueSubmit(queue_, 1, &amp;submitInfo, fence));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1416.1">Once a command buffer has been submitted for processing, it’s up to the driver and the GPU to execute the commands recorded there. </span><span class="koboSpan" id="kobo.1416.2">The only way to know whether the command buffer has finished processing is by checking the fence provided </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">vkQueueSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.1420.1">Presenting images</span></h1>
<p><span class="koboSpan" id="kobo.1421.1">Presenting an </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.1422.1">image onto the screen isn’t automatic in Vulkan. </span><span class="koboSpan" id="kobo.1422.2">You need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">vkQueuePresentKHR</span></strong><span class="koboSpan" id="kobo.1424.1"> function along with an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">VkPresentInfoKHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1"> structure.</span></span></p>
<p><span class="koboSpan" id="kobo.1427.1">In this recipe, you will learn how to queue an image for presentation once it has </span><span class="No-Break"><span class="koboSpan" id="kobo.1428.1">finished rendering.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1429.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1430.1">The presentation in our code is done in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">VulkanCore::Swapchain::present()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1"> method.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1433.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1434.1">Requesting an acquired image to be presented is done by </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">vkQueuePresentKHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1438.1">This time, we need to provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">imageRendered</span></strong><span class="koboSpan" id="kobo.1440.1"> semaphore, which indicates when the rendering process has finished using </span><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">the image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1442.1">
const VkPresentInfoKHR presentInfo{
    .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    .waitSemaphoreCount = 1,
    .pWaitSemaphores = &amp;imageRendered_,
    .swapchainCount = 1,
    .pSwapchains = &amp;swapchain_,
    .pImageIndices = &amp;imageIndex_,
};
VK_CHECK(vkQueuePresentKHR(presentQueue_, &amp;presentInfo));</span></pre> <p><span class="koboSpan" id="kobo.1443.1">The image won’t be presented right away once </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">VkQueuePresentKHR</span></strong><span class="koboSpan" id="kobo.1445.1"> is called. </span><span class="koboSpan" id="kobo.1445.2">This call merely sets up the synchronization mechanism so that Vulkan knows when the image can be sent </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">for display.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1447.1">Rendering a triangle</span></h1>
<p><span class="koboSpan" id="kobo.1448.1">Now that we’ve learned about all basic Vulkan objects and how they work, we can finally create a </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.1449.1">small example application that displays a static shaded triangle on </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.1451.1">In this recipe, we will present a full example that renders a static triangle on the screen. </span><span class="koboSpan" id="kobo.1451.2">The vertex data and attributes are statically provided in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">vertex shader.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1453.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1454.1">The code in this recipe can be found in the repository in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">source/chapter1/main.cpp</span></strong><span class="koboSpan" id="kobo.1456.1">. </span><span class="koboSpan" id="kobo.1456.2">The vertex and fragment shaders are located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">source/chapter1/resources/shaders</span></strong><span class="koboSpan" id="kobo.1458.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">triangle.vert</span></strong><span class="koboSpan" id="kobo.1460.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">triangle.frag</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1"> files.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1463.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1464.1">The code presented here is an unabridged version of the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">the repository.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1466.1">For this recipe, we will use two shaders: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">triangle.vert</span></strong><span class="koboSpan" id="kobo.1468.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">triangle.frag</span></strong><span class="koboSpan" id="kobo.1470.1">. </span><span class="koboSpan" id="kobo.1470.2">The vertex shader does not accept any inputs, as all the data it needs is defined right there in the shader itself as two arrays: one for vertex data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">positions</span></strong><span class="koboSpan" id="kobo.1472.1">) and the other for color </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">data (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">colors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">).</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1476.1">Both sets of data are sent to the output as-is without any transformations, as they are already in their respective output spaces (screen space for the position data and the output color space for the color data). </span><span class="koboSpan" id="kobo.1476.2">The position is output through the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">gl_VertexIndex</span></strong><span class="koboSpan" id="kobo.1478.1"> variable, while the color is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">outColor</span></strong><span class="koboSpan" id="kobo.1480.1"> variable at </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">location </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1483.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1484.1">
#version 460
layout(location = 0) out vec4 outColor;
vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);
vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);
void main() {
   gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
   outColor = vec4(colors[gl_VertexIndex], 1.0);
}</span></pre></li> <li><span class="koboSpan" id="kobo.1485.1">The fragment </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.1486.1">shader accepts the color data from the vertex stage and directly outputs it as the fragment color through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">outColor</span></strong><span class="koboSpan" id="kobo.1488.1"> variable at </span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">location </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1492.1">
#version 460
layout(location = 0) in vec4 inColor;
layout(location = 0) out vec4 outColor;
void main() {
    outColor = inColor;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1493.1">We only need one render pass that will output the render result to a framebuffer with only one attachment, color attachment 0. </span><span class="koboSpan" id="kobo.1493.2">The color attachment’s load operation is </span><em class="italic"><span class="koboSpan" id="kobo.1494.1">clear</span></em><span class="koboSpan" id="kobo.1495.1"> as we will clear it for rendering, whereas the store operation is </span><em class="italic"><span class="koboSpan" id="kobo.1496.1">store</span></em><span class="koboSpan" id="kobo.1497.1"> as we want the output to be recorded into the attachment. </span><span class="koboSpan" id="kobo.1497.2">The output will go straight into the swapchain, so the acquired swapchain image is </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.1498.1">the color attachment 0. </span><span class="koboSpan" id="kobo.1498.2">Since each render pass outputs directly onto the swapchain image, and a framebuffer is associated with an attachment and is immutable, we need the number of framebuffers to match the number of swapchain images. </span><span class="koboSpan" id="kobo.1498.3">Each framebuffer will be associated with one swapchain image as the color attachment 0. </span><span class="koboSpan" id="kobo.1498.4">The shaders don’t need access to external buffers, such as vertex and index, </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">or textures.</span></span></p></li> <li><span class="koboSpan" id="kobo.1500.1">The first step is to initialize a window and create a context with the features we will use by default in this book. </span><span class="koboSpan" id="kobo.1500.2">For more details, please refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">VulkanCore::VulkanFeatureChain</span></strong><span class="koboSpan" id="kobo.1502.1"> class in the repo. </span><span class="koboSpan" id="kobo.1502.2">The context, which encapsulates the instance and the physical and logical devices, is initialized with a few useful extensions, one graphics queue, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">default features:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1504.1">
int main(int argc, char** argv) {
  initWindow(&amp;window_);
  // Create Context
  VulkanCore::VulkanFeatureChain featureChain;
  VulkanCore::Context::createDefaultFeatureChain(
      featureChain);
  VulkanCore::Context context(
      (void*)glfwGetWin32Window(window_),
      {},  // layers
      {
          VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
          VK_KHR_SURFACE_EXTENSION_NAME,
          VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
      },  // instance extensions
      {VK_KHR_SWAPCHAIN_EXTENSION_NAME},  // device
                                          // extensions
      VK_QUEUE_GRAPHICS_BIT,  // request a graphics
                              // queue only
      featureChain, true);</span></pre></li> <li><span class="koboSpan" id="kobo.1505.1">The swapchain is initialized with a common format and color space, along with the extensions </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.1506.1">from the physical device. </span><span class="koboSpan" id="kobo.1506.2">In this example, we </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.1507.1">use the </span><strong class="bold"><span class="koboSpan" id="kobo.1508.1">First In First Out</span></strong><span class="koboSpan" id="kobo.1509.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1510.1">FIFO</span></strong><span class="koboSpan" id="kobo.1511.1">) presentation mode because it’s the only mode that is supported </span><span class="No-Break"><span class="koboSpan" id="kobo.1512.1">by default:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1513.1">
  // Create Swapchain
  const VkExtent2D extents = context.physicalDevice()
                                 .surfaceCapabilities()
                                 .minImageExtent;
  context.createSwapchain(
      VK_FORMAT_B8G8R8A8_UNORM,
      VK_COLORSPACE_SRGB_NONLINEAR_KHR,
      VK_PRESENT_MODE_FIFO_KHR, extents);
  const VkRect2D renderArea = {
      .offset = {.x = 0, .y = 0}, .extent = extents};</span></pre></li> <li><span class="koboSpan" id="kobo.1514.1">Both shaders are initialized from the resources in the repo, along with a vector of framebuffers. </span><span class="koboSpan" id="kobo.1514.2">The </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.1515.1">number of framebuffers matches the number of swapchain images, as we’ll need one framebuffer for each acquired </span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1">image later:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1517.1">
  // Create Shader Modules
  const auto shadersPath =
      std::filesystem::current_path() /
      "resources/shaders";
  const auto vertexShaderPath =
      shadersPath / "triangle.vert";
  const auto fragShaderPath =
      shadersPath / "triangle.frag";
  const auto vertexShader = context.createShaderModule(
      vertexShaderPath.string(),
      VK_SHADER_STAGE_VERTEX_BIT);
  const auto fragShader = context.createShaderModule(
      fragShaderPath.string(),
      VK_SHADER_STAGE_FRAGMENT_BIT);
  // Create Framebuffers
  std::vector&lt;std::shared_ptr&lt;VulkanCore::Framebuffer&gt;&gt;
      swapchain_framebuffers(
          context.swapchain()-&gt;numberImages());</span></pre></li> <li><span class="koboSpan" id="kobo.1518.1">We only need one render pass with one subpass. </span><span class="koboSpan" id="kobo.1518.2">A render pass isn’t associated with any resources. </span><span class="koboSpan" id="kobo.1518.3">It only specifies the load and store operations of each framebuffer’s color attachment and their use by the subpasses. </span><span class="koboSpan" id="kobo.1518.4">For this reason, we don’t need multiple render passes, like framebuffers do. </span><span class="koboSpan" id="kobo.1518.5">One is enough, and it is reused for all swapchain images. </span><span class="koboSpan" id="kobo.1518.6">The final layout of the color attachment 0, the swapchain image, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</span></strong><span class="koboSpan" id="kobo.1520.1">, as it will </span><span class="No-Break"><span class="koboSpan" id="kobo.1521.1">be presented:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1522.1">
  // Create Render Pass
  std::shared_ptr&lt;VulkanCore::RenderPass&gt; renderPass =
      context.createRenderPass(
          {context.swapchain()-&gt;texture(0)},
          {VK_ATTACHMENT_LOAD_OP_CLEAR},
          {VK_ATTACHMENT_STORE_OP_STORE},
          {VK_IMAGE_LAYOUT_PRESENT_SRC_KHR},
          VK_PIPELINE_BIND_POINT_GRAPHICS);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1523.1">Finally, we create a pipeline that contains mostly the default parameters. </span><span class="koboSpan" id="kobo.1523.2">Besides the two </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.1524.1">shaders compiled before, we set the viewport to be the size of the output and disable depth testing. </span><span class="koboSpan" id="kobo.1524.2">We then create a Command Queue Manager instance to manage the command buffers and </span><span class="No-Break"><span class="koboSpan" id="kobo.1525.1">their fences:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1526.1">  // Create Graphics Pipeline
  auto pipeline = context.createGraphicsPipeline(
      VulkanCore::Pipeline::GraphicsPipelineDescriptor{
          .vertexShader_ = vertexShader,
          .fragmentShader_ = fragShader,
          .viewport = context.swapchain()-&gt;extent(),
          .depthTestEnable = false,
      },
      renderPass-&gt;vkRenderPass());
  // Create Command Queue Manager
  auto commandMgr = context.createGraphicsCommandQueue(
      context.swapchain()-&gt;numberImages(),
      context.swapchain()-&gt;numberImages());
  // FPS Counter
  EngineCore::FPSCounter fps(glfwGetTime());</span></pre></li> <li><span class="koboSpan" id="kobo.1527.1">The main render loop executes until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">GLFW</span></strong><span class="koboSpan" id="kobo.1529.1"> window is closed. </span><span class="koboSpan" id="kobo.1529.2">On each iteration, we first </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.1530.1">acquire a swapchain image and its index. </span><span class="koboSpan" id="kobo.1530.2">If a framebuffer for this swapchain image doesn’t exist yet, we create one. </span><span class="koboSpan" id="kobo.1530.3">We then obtain a command buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">for rendering:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1532.1">
  // Main Render Loop
  while (!glfwWindowShouldClose(window_)) {
    fps.update(glfwGetTime());
    const auto texture =
        context.swapchain()-&gt;acquireImage();
    const auto swapchainImageIndex =
        context.swapchain()-&gt;currentImageIndex();
    // Create the framebuffer the first time we get
    // here, once for each swapchain image
    if (swapchain_framebuffers[swapchainImageIndex] ==
        nullptr) {
      swapchain_framebuffers[swapchainImageIndex] =
          context.createFramebuffer(
              renderPass-&gt;vkRenderPass(), {texture},
              nullptr, nullptr);
    }
    auto commandBuffer =
        commandMgr.getCmdBufferToBegin();</span></pre></li> <li><span class="koboSpan" id="kobo.1533.1">Before starting rendering, we begin the render pass by providing a clear color (black), and the </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.1534.1">render pass and framebuffer handles. </span><span class="koboSpan" id="kobo.1534.2">We then bind the pipeline to the current command buffer, and we are ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">start rendering:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1536.1">
    // Begin Render Pass
    constexpr VkClearValue clearColor{0.0f, 0.0f, 0.0f,
                                      0.0f};
    const VkRenderPassBeginInfo renderpassInfo = {
        .sType =
            VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        .renderPass = renderPass-&gt;vkRenderPass(),
        .framebuffer =
            swapchain_framebuffers[swapchainImageIndex]
                -&gt;vkFramebuffer(),
        .renderArea = renderArea,
        .clearValueCount = 1,
        .pClearValues = &amp;clearColor,
    };
    vkCmdBeginRenderPass(commandBuffer,
                         &amp;renderpassInfo,
                         VK_SUBPASS_CONTENTS_INLINE);
    pipeline-&gt;bind(commandBuffer);</span></pre></li> <li><span class="koboSpan" id="kobo.1537.1">Finally, we issue the draw call with three vertices and one instance. </span><span class="koboSpan" id="kobo.1537.2">This call will invoke the vertex </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.1538.1">shader three times (one for each vertex), instantiating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">gl_VertexIndex</span></strong><span class="koboSpan" id="kobo.1540.1"> variable in the shader to 0, 1, and 2. </span><span class="koboSpan" id="kobo.1540.2">We use this variable to index into the position and color arrays in the shader itself. </span><span class="koboSpan" id="kobo.1540.3">We then submit the command buffer and present the </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">swapchain image:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1542.1">
    vkCmdDraw(commandBuffer, 3, 1, 0, 0);
    vkCmdEndRenderPass(commandBuffer);
    commandMgr.endCmdBuffer(commandBuffer);
    constexpr VkPipelineStageFlags flags =
        VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    const auto submitInfo =
        context.swapchain()-&gt;createSubmitInfo(
            &amp;commandBuffer, &amp;flags);
    commandMgr.submit(&amp;submitInfo);
    commandMgr.goToNextCmdBuffer();
    // Present render output to the screen
    context.swapchain()-&gt;present();
    glfwPollEvents();
    // Increment frame number
    fps.incFrame();
  }</span></pre></li> <li><span class="koboSpan" id="kobo.1543.1">After the render loop ends, and before exiting the program, we wait for all queues to </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.1544.1">finish processing before destroying all Vulkan objects in the opposite order in which they </span><span class="No-Break"><span class="koboSpan" id="kobo.1545.1">were created:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1546.1">
  commandMgr.waitUntilAllSubmitsAreComplete</span><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.1547.1">();
  glfwDestroyWindow(window_);
  glfwTerminate();
  return 0;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1548.1">The result of this recipe should look like </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1549.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1550.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.1552.1"><img alt="Figure 1.12 – Recipe result" src="image/B18491_01_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1553.1">Figure 1.12 – Recipe result</span></p>
<p><span class="koboSpan" id="kobo.1554.1">Vulkan is </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.1555.1">verbose and, as mentioned before, provides many ways to customize your graphics application. </span><span class="koboSpan" id="kobo.1555.2">A simple example such as this needed around 1,000 lines of code! </span><span class="koboSpan" id="kobo.1555.3">But there is no reason for panic. </span><span class="koboSpan" id="kobo.1555.4">Most of that code can be reused (and will be reused) for the remainder of the book to explain all techniques and recipes in </span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1">the text.</span></span></p>
</div>
</body></html>