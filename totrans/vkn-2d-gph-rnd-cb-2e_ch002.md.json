["```cpp\nsudo apt-get update\n```", "```cpp\nsudo apt-get install build-essential\n```", "```cpp\nsudo apt-get install cmake\n```", "```cpp\nsudo apt-get install git\n```", "```cpp\nsudo apt-get install python3.7\n```", "```cpp\nwget -qO- https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo tee /etc/apt/trusted.gpg.d/lunarg.asc\nsudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-1.3.250-jammy.list https://packages.lunarg.com/vulkan/1.3.250/lunarg-vulkan-1.3.250-jammy.list\nsudo apt update\nsudo apt install vulkan-sdk\n```", "```cpp\nsource ~/vulkan/1.3.250.1/setup-env.sh\n```", "```cpp\ngit clone https://github.com/corporateshark/bootstrapping\n```", "```cpp\nbootstrap.py\n```", "```cpp\nCloning into ‘M:\\Projects.CPP\\Book_Rendering\\Sources\\deps\\src\\assimp’...\nremote: Enumerating objects: 25, done.\nremote: Counting objects: 100% (25/25), done.\nremote: Compressing objects: 100% (24/24), done.\nremote: Total 51414 (delta 2), reused 10 (delta 1), pack-reused 51389\nReceiving objects: 100% (51414/51414), 148.46 MiB | 3.95 MiB/s, done.\nResolving deltas: 100% (36665/36665), done.\nChecking out files: 100% (2163/2163), done.\n```", "```cpp\n[{\n “name”: “vulkan”,\n “source”: {\n  “type”: “git”,\n  “url”: “https://github.com/KhronosGroup/Vulkan-Headers.git”,\n   “revision”: “v1.3.252”\n }\n}]\n```", "```cpp\nint main() {\n  printf(“Hello World!\\n”);\n  return 0;\n}\n```", "```cpp\nmacro(SETUP_GROUPS src_files)\n  foreach(FILE ${src_files})\n    get_filename_component(PARENT_DIR “${FILE}” PATH)\n```", "```cpp\n set(GROUP “${PARENT_DIR}”)\n    string(REPLACE “/” “\\\\” GROUP “${GROUP}”)\n```", "```cpp\n source_group(“${GROUP}” FILES “${FILE}”)\n  endforeach()\nendmacro()\n```", "```cpp\nmacro(SETUP_APP projname chapter)\n  set(FOLDER_NAME ${chapter})\n  set(PROJECT_NAME ${projname})\n  project(${PROJECT_NAME} CXX)\n```", "```cpp\n file(GLOB_RECURSE SRC_FILES LIST_DIRECTORIES false\n       RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} src/*.c??)\n  file(GLOB_RECURSE HEADER_FILES LIST_DIRECTORIES false\n       RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} src/*.h)\n```", "```cpp\n include_directories(src)\n```", "```cpp\n add_executable(${PROJ_NAME} ${SRC_FILES} ${HEADER_FILES})\n```", "```cpp\n SETUP_GROUPS(“${SRC_FILES}”)\n  SETUP_GROUPS(“${HEADER_FILES}”)\n```", "```cpp\n set_target_properties(${PROJ_NAME}\n    PROPERTIES OUTPUT_NAME_DEBUG ${PROJ_NAME}_Debug)\n  set_target_properties(${PROJ_NAME}\n    PROPERTIES OUTPUT_NAME_RELEASE ${PROJ_NAME}_Release)\n  set_target_properties(${PROJ_NAME}\n    PROPERTIES OUTPUT_NAME_RELWITHDEBINFO ${PROJ_NAME}_ReleaseDebInfo)\n```", "```cpp\n set_property(\n    TARGET ${PROJ_NAME} PROPERTY CXX_STANDARD 20)\n  set_property(\n    TARGET ${PROJ_NAME} PROPERTY CXX_STANDARD_REQUIRED ON)\n```", "```cpp\n if(MSVC)\n    add_definitions(-D_CONSOLE)\n    set_property(TARGET ${PROJ_NAME} PROPERTY\n      VS_DEBUGGER_WORKING_DIRECTORY “${CMAKE_SOURCE_DIR}”)\n  endif()\n  if(APPLE)\n    set_target_properties(${PROJECT_NAME} PROPERTIES\n      XCODE_GENERATE_SCHEME TRUE\n      XCODE_SCHEME_WORKING_DIRECTORY “${CMAKE_SOURCE_DIR}”)\n  endif()\nendmacro()\n```", "```cpp\ncmake_minimum_required(VERSION 3.16)\nproject(Chapter01)\ninclude(../../CMake/CommonMacros.txt)\nSETUP_APP(Ch01_Sample01_CMake “Chapter 01”)\n```", "```cpp\nCMake Warning (dev) in CMakeLists.txt:\nNo project() command is present. The top-level CMakeLists.txt file must contain a literal, direct call to the project() command. Add a line of project(ProjectName) near the top of the file, but after cmake_minimum_required().\n```", "```cpp\ncmake .. -G “Visual Studio 17 2022” -A x64\n```", "```cpp\ncmake .. -G “Unix Makefiles”\n```", "```cpp\ncmake --build . --config Release\n```", "```cpp\ncmake .. -G “Ninja”\n```", "```cpp\nninja\n[2/2] Linking CXX executable Ch01_Sample01_CMake.exe\n```", "```cpp\n{\n     “name”: “glfw”,\n     “source”: {\n           “type”: “git”,\n           “url”: “https://github.com/glfw/glfw.git”,\n           “revision”: “3.4”\n     }\n}\n```", "```cpp\n#include <shared/HelpersGLFW.h>\nint main(void) {\n  uint32_t width = 1280;\n  uint32_t height = 800;\n```", "```cpp\nGLFWwindow* window =\n  initWindow(“GLFW example”, width, height);\n```", "```cpp\n while (!glfwWindowShouldClose(window)) {\n    glfwPollEvents();\n  }\n  glfwDestroyWindow(window);\n  glfwTerminate();\n  return 0;\n}\n```", "```cpp\nGLFWwindow* initWindow(const char* windowTitle,\n  uint32_t& outWidth, uint32_t& outHeight) {\n  glfwSetErrorCallback([](int error,\n                          const char* description) {\n    printf(“GLFW Error (%i): %s\\n”, error, description);\n  });\n  if (!glfwInit())return nullptr;\n```", "```cpp\n const bool wantsWholeArea = !outWidth || !outHeight;\n  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n  glfwWindowHint(GLFW_RESIZABLE,\n    wantsWholeArea ? GLFW_FALSE : GLFW_TRUE);\n  GLFWmonitor* monitor    = glfwGetPrimaryMonitor();\n  const GLFWvidmode* mode = glfwGetVideoMode(monitor);\n  int x = 0;\n  int y = 0;\n  int w = mode->width;\n  int h = mode->height;\n  if (wantsWholeArea) {\n    glfwGetMonitorWorkarea(monitor, &x, &y, &w, &h);\n  } else {\n    w = outWidth;\n    h = outHeight;\n  }\n```", "```cpp\n GLFWwindow* window = glfwCreateWindow(\n    w, h, windowTitle, nullptr, nullptr);\n  if (!window) {\n    glfwTerminate();\n    return nullptr;\n  }\n  if (wantsWholeArea) glfwSetWindowPos(window, x, y);\n  glfwGetWindowSize(window, &w, &h);\n  outWidth  = (uint32_t)w;\n  outHeight = (uint32_t)h;\n```", "```cpp\n glfwSetKeyCallback(window, [](GLFWwindow* window,\n    int key, int, int action, int) {\n    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {\n      glfwSetWindowShouldClose(window, GLFW_TRUE);\n    }\n  });\n  return window;\n}\n```", "```cpp\n{\n     “name”: “taskflow”,\n     “source”: {\n           “type”: “git”,\n           “url”:\n             “https://github.com/taskflow/taskflow.git”,\n           “revision”: “v3.7.0”\n     }\n}\n```", "```cpp\n#include <taskflow/taskflow.hpp>\nint main() {\n  tf::Taskflow taskflow;\n  std::vector<int> items{ 1, 2, 3, 4, 5, 6, 7, 8 };\n```", "```cpp\n auto task = taskflow.for_each_index(\n    0u, static_cast<uint32_t>(items.size()), 1u, [&](int i) {\n      printf(“%i”, items[i]); }).name(“for_each_index”);\n```", "```cpp\n taskflow.emplace([]() {\n    printf(“\\nS - Start\\n”); }).name(“S”).precede(task);\n  taskflow.emplace([]() {\n    printf(“\\nT - End\\n”); }).name(“T”).succeed(task);\n```", "```cpp\n std::ofstream os(“.cache/taskflow.dot”);\n  taskflow.dump(os);\n```", "```cpp\n tf::Executor executor;\n  executor.run(taskflow).wait();\n  return 0;\n}\n```", "```cpp\nS – Start\n18345672\nT - End\n```", "```cpp\ndot -Tpng taskflow.dot > output.png\n```"]