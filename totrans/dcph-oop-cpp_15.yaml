- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Classes and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts through exploring means to test the classes and components
    that comprise our OO programs. We will explore various strategies to help ensure
    that the code we write will be well-tested and robust.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows how to test your OO programs through testing individual classes,
    as well as testing the various components that work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the canonical class form and creating robust classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating drivers to test classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing classes related by inheritance, association, or aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing exception handling mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have various techniques in your programming
    arsenal to ensure that your code is well-tested before it goes into production.
    Having the skills to consistently produce robust code will help you become a more
    beneficial programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our C++ skills set by examining various techniques for OO testing.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter15).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter15` in a file named `Chp15-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3AxyLFH](https://bit.ly/3AxyLFH).'
  prefs: []
  type: TYPE_NORMAL
- en: Contemplating OO testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is immensely important prior to any code deployment. Testing
    object-oriented software will require different techniques than other types of
    software. Because OO software contains relationships between classes, we must
    understand how to test dependencies and relationships that may exist between classes.
    Additionally, each object may progress through different states based on the order
    that operations are applied to each instance, as well as through specific interactions
    with related objects (for example, via association). The overall flow of control
    through an OO application is much more complex than with procedural applications,
    as the combinations and order of operations applied to a given object and influences
    from associated objects are numerous.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, there are metrics and processes we can apply to test OO software.
    These range from understanding idioms and patterns we can apply for class specification,
    to creating drivers to test classes both independently and as they relate to other
    classes. These processes can further include creating scenarios to provide likely
    sequences of events or states that objects may progress through. Relationships
    between objects, such as inheritance, association, and aggregation become very
    important in testing; related objects can influence the state of an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin our quest in testing OO software by understanding a simple pattern
    that we can often apply to classes we develop. This idiom will ensure that a class
    is potentially complete, with no unexpected behavior. We will start with the canonical
    class form.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the canonical class form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many classes in C++, it is reasonable to follow a pattern for class specification
    to ensure that a new class contains a full set of desired components. The **canonical
    class form** is a robust specification of a class that enables class instances
    to provide uniform behavior (analogous to standard data types) in areas such as
    initialization, assignment, argument passing, and usage in return values from
    functions. The canonical class form will apply to most classes that are intended
    for either instantiation or that will serve as public base classes for new derived
    classes. Classes that are intended to serve as private or protected base classes
    (even if they may be instantiated themselves) may not follow all parts of this
    idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class following **orthodox** canonical form will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor (or an `=default` prototype to explicitly allow this interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual destructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though any of the aforementioned components may be prototyped with `=default`
    to explicitly utilize the default, system-supplied implementations, modern preferences
    are moving away from such practices (as these prototypes are generally redundant).
    The exception is the default constructor whose interface you will not otherwise
    get without using `=default` when other constructors are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class following the **extended** canonical form will additionally include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A *move* copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *move* assignment operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each component of the canonical class form in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Default constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `=default` to the default constructor prototype; this is especially useful
    when in-class initialization is utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a default constructor for a given class’ base class will be called
    in the absence of an alternate base class constructor specification in the member
    initialization list. If a base class has no such default constructor (and one
    hasn’t been provided because a constructor with another signature exists), the
    implicit call to the base class constructor will be flagged as an error.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also consider multiple inheritance situations in which a diamond-shaped
    hierarchy occurs, and virtual base classes are used to eliminate duplication of
    the most base class subobjects within instances of the most derived class. In
    this scenario, the default constructor for the now *shared* base class subobject
    is called unless otherwise specified in the member initialization list of the
    derived class responsible for creating the diamond shape. This occurs even if
    non-default constructors are specified in the member initialization list at the
    middle level; remember these specifications are ignored when the mid-levels specify
    a potentially shared virtual base class.
  prefs: []
  type: TYPE_NORMAL
- en: Copy constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **copy constructor** is often crucial for all objects containing pointer data
    members. Unless a copy constructor is supplied by the programmer, a system-supplied
    copy constructor will be linked in when necessary in the application. The system-supplied
    copy constructor performs a member-wise (shallow) copy of all data members. This
    means that multiple instances of a class may contain pointers to *shared* pieces
    of memory representing the data that should have been individualized. Unless resource
    sharing is intended, raw pointer data members in the newly instantiated object
    will want to allocate their own memory and copy the data values from the source
    object into this memory. Also, remember to use the member initialization list
    in a derived class copy constructor to specify the base class’ copy constructor
    to copy the base class data members. Certainly, copying the base class subobject
    in a deep fashion is crucial; additionally, the base class data members are inevitably
    private, so selecting the base class copy constructor in the derived class’ member
    initialization list is very important.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying a copy constructor, we also help provide an expected manner for
    the creation of objects passed (or returned) by value from a function. Ensuring
    deep copies in these scenarios is crucial. The user may think these copies are
    *by value*, yet if their pointer data members are actually shared with the source
    instance, it’s not truly passing (or returning) an object by value.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **overloaded assignment operator**, much like the copy constructor, is often
    also crucial for all objects containing pointer data members. The default behavior
    for the system-supplied assignment operator is a shallow assignment of data from
    source to destination object. Again, when data members are raw pointers, unless
    the two objects want to share the resources for heap data members, it is highly
    recommended that the assignment operator should be overloaded. Allocated space
    in the destination object should be equal to the source data member sizes for
    any such pointer data members. The contents (data) should then be copied from
    source to destination object for each pointer data member.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that an overloaded assignment operator is not *inherited*; each
    class is responsible for writing its own version. This makes sense, as the derived
    class inevitably has more data members to copy than the assignment operator function
    in its base class. However, when overloading an assignment operator in a derived
    class, remember to call the base class’ assignment operator to perform a deep
    assignment of inherited base class members (which may be private and otherwise
    inaccessible).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual destructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `=default`).
  prefs: []
  type: TYPE_NORMAL
- en: Move copy constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `this`. We then must null the source object’s pointers to those data members
    so that both instances do not *share* the dynamically allocated data members.
    We have, in essence, moved (the memory for) the pointer data members.
  prefs: []
  type: TYPE_NORMAL
- en: What about the non-pointer data members? The memory for these data members will
    be copied as usual. The memory for the non-pointer data members and the memory
    for the pointers themselves (not the memory pointed to by those pointers), still
    reside in the source instance. As such, the best we can do is designate a null
    value (`nullptr`) for the source object’s pointers and place a `0` (or similar)
    value in the non-pointer data members to indicate that these members are no longer
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `move()` function, found in the C++ Standard Library, to indicate
    a move copy constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, with classes related by inheritance, we will also use `move()`
    in the member initialization list of the derived class move copy constructor.
    This will specify the base class move copy constructor to help initialize the
    subobject.
  prefs: []
  type: TYPE_NORMAL
- en: Move assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **move assignment operator** is much like an overloaded assignment operator
    and is often crucial for all objects containing pointer data members. However,
    the goal is to again conserve memory by *moving* the dynamically allocated data
    of the source object to the destination object (versus performing a deep assignment).
    As with the overloaded assignment operator, we will test for self-assignment and
    then delete any previously dynamically allocated data members from the (pre-existing)
    destination object. However, we will then simply copy the pointer data members
    from the source object to those in the destination object. We will also null out
    the pointers in the source object so that the two instances do not share these
    dynamically allocated data members.
  prefs: []
  type: TYPE_NORMAL
- en: Also, much like the move copy constructor, non-pointer data members will be
    simply copied from source to destination object and replaced with a `nullptr`
    value in the source object to indicate non-usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again use the `move()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, with classes related by inheritance, we can again specify that
    the move assignment operator of the derived class will call the base class move
    assignment operator to help complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the components of canonical class form together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see an example of a pair of classes that embrace the canonical class
    form. We will start with our `Person` class. This example can be found, as a complete
    program, in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we notice that `Person` contains a default
    constructor, copy constructor, overloaded assignment operator, and a virtual destructor.
    Here, we have embraced the orthodox canonical class form as a pattern applicable
    for a class that might one day serve as a public base class. Also notice that
    we have added the prototypes for the move copy constructor and move assignment
    operator to additionally embrace the extended canonical class form.
  prefs: []
  type: TYPE_NORMAL
- en: The prototypes of the move copy constructor `Person(Person &&);` and the move
    assignment operator `Person &operator=(Person &&);` contain parameters of type
    `Person &&`. These are examples of `Person &`, will bind to the original copy
    constructor and overloaded assignment operator, whereas r-value reference parameters
    will bind to the applicable move methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at the definitions for the methods contributing to the extended
    canonical class form – the move copy constructor and the move assignment operator
    for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the preceding move copy constructor for data members that are pointers,
    we overtake the source object’s dynamically allocated memory by using simple pointer
    assignments in the member initialization list (versus memory allocation such as
    we would employ in a deep copy constructor). We then place a `nullptr` value in
    the source object’s pointer data members in the body of the constructor. For non-pointer
    data members, we simply copy the values from the source to the destination object
    and place a zeroed or empty value (such as `'\0'` for `p.middleInitial` or using
    `clear()` for `p.firstName`) in the source object to indicate its further non-use.
  prefs: []
  type: TYPE_NORMAL
- en: In the move assignment operator, we check for self-assignment and then employ
    the same scheme to merely move the dynamically allocated memory from the source
    object to the destination object with a simple pointer assignment. We copy simple
    data members as well, and of course, replace source object data values with either
    null pointers (`nullptr`) or zeroed values to indicate further non-use. The return
    value of `*this` allows for cascaded assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how a derived class, `Student`, employs both the orthodox and
    extended canonical class form while utilizing its base class components to aid
    in the implementation of selected idiom methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class definition, we again see that `Student` contains a default
    constructor, a copy constructor, an overloaded assignment operator, and a virtual
    destructor to complete the orthodox canonical class form.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that in the `Student` copy constructor, we specify the use
    of the `Person` copy constructor through the member initialization list. Similarly,
    in the `Student` overloaded assignment operator, once we check for self-assignment,
    we call the overloaded assignment operator in `Person` to help us complete the
    task using `Person::operator=(s);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at the method definitions contributing to the extended canonical
    class form of `Student` – the move copy constructor and the move assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the previously listed `Student` move copy constructor, we specify
    the utilization of the base class move copy constructor in the member initialization
    list. The remainder of the `Student` move copy constructor is similar to that
    found in the `Person` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, let’s notice in the `Student` move assignment operator, the call to
    the base class move `operator=` with `Person::operator=(move(s));`. The remainder
    of this method is similar to that found in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is that most non-trivial classes should minimally utilize
    the orthodox canonical class form. Of course, there are exceptions. For example,
    a class that will only serve as a protected or private base class need not have
    a virtual destructor because derived class instances cannot be upcast past a non-public
    inheritance boundary. Similarly, if we have a good reason to not want copies or
    to disallow an assignment, we can prohibit copies or assignments using the `=
    delete` specification in the extended signature of either of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, the canonical class form will add robustness to classes that embrace
    this idiom. The uniformity among classes utilizing this idiom with respect to
    their implementation of initialization, assignment, and argument passing will
    be valued by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to take a look at a complementary idea to the canonical class
    form, that of robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a class is robust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important feature of C++ is the ability to build libraries of classes for
    widespread reuse. Whether we wish to achieve this goal, or simply wish to provide
    reliable code for our own organization’s use, our code must be robust. A **robust
    class** will be well-tested, should follow the canonical class form (except for
    requiring a virtual destructor in protected and private base classes), and be
    portable (or included in a platform-specific library). Any class that is a candidate
    for reuse, or which is to be used in any professional capacity, must absolutely
    be robust.
  prefs: []
  type: TYPE_NORMAL
- en: A robust class must ensure that all instances of a given class are fully constructed.
    A **fully constructed object** is one in which all data members are appropriately
    initialized. All constructors for a given class (including copy constructors)
    must be verified to initialize all data members. The values with which data members
    are loaded should be checked for range suitability. Remember, an uninitialized
    data member is a potential disaster! Precautions should be made in the event that
    a given constructor does not complete properly or if the initial values of data
    members are inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Fully constructed objects may be validated using a variety of techniques. A
    rudimentary (and not advised) technique is to embed a status data member into
    each class (or derive or embed a status ancestor/member). Set the status member
    to `0` in the member initialization list and to `1` as the last line of the constructor.
    Probe this value after instantiation. The huge downfall of this approach is that
    users will certainly forget to probe the *fully constructed* success flag.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the simple, aforementioned scheme is to utilize in-class initialization
    for all simple data types, resetting these members in the member initialization
    list of each alternate constructor to the desired values. After instantiation,
    the values may again be probed to determine whether an alternate constructor completed
    successfully. This is still far from an ideal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A much better technique is to utilize exception handling. Embedding exception
    handling inside each constructor is ideal. If data members are not initialized
    within a suitable range, first try to re-enter their values, or open an alternate
    database for input, for example. As a last resort, you can throw an exception
    to report the *not fully constructed object*. We will more closely examine exception
    handling with respect to testing later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, let us move forward with a technique to rigorously test our classes
    and components – creating drivers to test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating drivers to test classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*,
    we briefly talked about breaking our code into source and header files. Let us
    briefly recap. Typically, the header file will be named after the class (such
    as `Student.h`) and will contain the class definition, plus any inline member
    function definitions. By placing inline functions in a header file, they will
    be properly re-expanded should their implementations change (as the header is
    subsequently included in each source file, creating a dependency with that header).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation for the methods of each class will be placed in a corresponding
    source code file (such as `Student.cpp`), which will include the header on which
    it is based (that is, `#include "Student.h"`). Note that the double quotes imply
    that this header is in our current working directory; we could also specify a
    path as to where to find the header. By comparison, the angle brackets used with
    C++ libraries tell the preprocessor to look in predesignated directories by the
    compiler. Also, note that each derived class header file will include the header
    file for its base class (so that it may see member function prototypes).
  prefs: []
  type: TYPE_NORMAL
- en: Note that any static data member or method definitions will appear in their
    corresponding source code files (so that only one definition per application will
    exist).
  prefs: []
  type: TYPE_NORMAL
- en: With this header and source code file structure in mind, we can now create a
    driver to test each individual class or each grouping of closely related classes
    (such as those related through association or aggregation). Classes related through
    inheritance can be tested in their own, individual driver files. Each driver file
    can be named to reflect the class that is being tested, such as `StudentDriver.cpp`.
    The driver file will include the relevant header files for the class(es) being
    tested. Of course, the source files from the classes in question would be compiled
    and linked to the driver file as part of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: The driver file can simply contain a `main()` function as a test bed to instantiate
    the class(es) in question and serve as a scope to test each member function. The
    driver will test default instantiation, typical instantiation, copy construction,
    assignment between objects, and each of the additional methods in the class(es).
    Should virtual destructors or other virtual functions exist, we should instantiate
    derived class instances (in the derived class’ driver), upcasting these instances
    to be stored using base class pointers, and then invoke the virtual functions
    to verify that the correct behaviors occur. In the case of a virtual destructor,
    we can trace which destructor is the entry point in the destruction sequence by
    deleting a dynamically allocated instance (or waiting for a stack instance to
    go out of scope) and single-stepping through our debugger to verify all is as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: We can also test that objects are fully constructed; we will see more on this
    topic shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have our usual `Person` and `Student` class hierarchy, here is
    a simple driver (the file containing `main()`) to test the `Student` class. This
    driver can be found in our GitHub repository. To make a complete program, you
    will also need to compile and link together the `Student.cpp` and `Person.cpp`
    files found in this same directory. Here is the GitHub repository URL for the
    driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter15/Chp15-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Briefly reviewing the preceding program fragment, we can see that we have tested
    each means for instantiation, including the copy constructor. We’ve also tested
    the assignment operator, verified each member function works (an example method
    is shown), and verified that the virtual functions (including the virtual destructor),
    work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a basic driver test our classes, let’s consider some additional
    metrics we can use when testing classes related via inheritance, association,
    or aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing related classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With OO programs, it is not sufficient to simply test an individual class for
    completeness and robustness, though these are good starting points. Completeness
    entails not only following the canonical class form but also ensuring that data
    members have a safe means for access using appropriate access methods (labeled
    as `const` when not modifying the instance). Completeness also verifies that the
    required interface as specified by the OO design has been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Robustness leads us to verify that all of the aforementioned methods had been
    tested within an appropriate driver, evaluated for platform independence, and
    verified that each means for instantiation leads to a fully constructed object.
    We can augment this type of testing with threshold testing of data members, for
    instance, noting when exceptions are thrown. Completeness and robustness, though
    seemingly comprehensive, are actually the most straightforward means for OO component
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: The more challenging means for testing is to test the interaction between related
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Testing classes related through inheritance, association, or aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes related through various object relationships require various additional
    means for component testing. Objects with various relationships with one another
    can impact the state progression a given instance may have during its life expectancy
    within the application. This type of testing will require the most detailed effort.
    We will find that scenarios will be useful to help us capture the usual interactions
    between related objects, leading to more comprehensive ways to test classes that
    interact with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by considering how we can test classes related to inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding strategies to test inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes related through public inheritance need to have virtual functions verified.
    For example, have all intended derived class methods been overridden? Remember,
    a derived class does not need to override all virtual functions specified in its
    base class if base class behaviors are still deemed appropriate at the derived
    class level. It will be necessary to compare the implementation to the design
    to ensure that we have overridden all required polymorphic operations with suitable
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, the binding of virtual functions is done at runtime (that is, dynamic
    binding). It will be important to create derived class instances and store them
    using base class pointers so that the polymorphic operations can be applied. We
    then need to verify that the derived class behavior shines through. If not, perhaps
    we may find ourselves in an unintended function hiding situation, or perhaps the
    base class operation wasn’t marked `virtual` as intended (keeping in mind that
    the keywords `virtual` and `override` at the derived class level, though nice
    and recommended, are optional and do not affect the dynamic behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Though classes related through inheritance have unique testing strategies, remember
    that instantiation will create a single object, that is, of a base class or of
    a derived class type. When we instantiate one such type, we have one such instance,
    not a pair of instances working together. A derived class merely has a base class
    subobject, which is part of itself. Let’s consider how this compares with associated
    objects or aggregates, which can be separate objects (association), potentially
    interacting with their companions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding strategies to test aggregation and association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes related through association or aggregation may be multiple instances
    communicating with one another and causing state changes with one another. This
    is certainly more complex than the object relationship of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via aggregation are generally easier to test than those related
    via association. Thinking of the most common form of aggregation (composition),
    the embedded (inner) object is part of the outer (whole) object. When the outer
    object is instantiated, we get the memory for the inner object embedded within
    the *whole*. The memory layout is not tremendously different (other than the potential
    ordering) when compared to the memory layout of a derived class instance, which
    contains a base class subobject. In each case, we are still dealing with a single
    instance (even though it has embedded *parts*). The point of comparison with testing,
    however, is that operations applied to the *whole* are often delegated to the
    *parts* or components. We will rigorously need to test the operations, on the
    whole, to ensure that they delegate necessary information to each of the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via the lesser-used form of a general aggregation (where the
    whole contains pointers to the parts versus the typical embedded object implementation
    of composition) have similar issues to an association, as the implementation is
    similar. With that in mind, let’s take a look at testing issues relating to associated
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classes related via an association are often independently existing objects,
    which at some point in the application have created a link to one another. There
    may or may not be a predetermined point in the application when the two objects
    create a link to one another. Operations applied to one object may cause a change
    in the associated object. For example, let us consider a `Student` and a `Course`.
    Both may exist independently, then at some point in the application, a `Student`
    may add a `Course` with `Student::AddCourse()`. By doing so, not only does a particular
    `Student` instance now contain a link to a specific `Course` instance, but the
    `Student::AddCourse()` operation has caused a change in the `Course` class. That
    particular `Student` instance is now part of a particular `Course` instance’s
    roster. At any point, the `Course` may be canceled, rippling a change in all `Student`
    instances who are enrolled in that `Course`. These changes reflect states in which
    each associated object may exist. For example, a `Student` may be in a state of
    *currently enrolled*, or *dropping* a `Course`. There are many possibilities.
    How do we test all of them?
  prefs: []
  type: TYPE_NORMAL
- en: Adding scenarios to aid in testing object relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The notion of a scenario comes up in object-oriented analysis as a means to
    both create OO designs and test them. A **scenario** is a descriptive walkthrough
    of a likely series of events that will occur in an application. A scenario will
    feature classes and how they may interact with one another for a specific situation.
    Many related scenarios can be collected into the OO concept of a **use case**.
    In the OO analysis and design phases, scenarios help determine which classes may
    exist in the application as well as operations and relationships each may have.
    In testing, scenarios can be reused to form the basis for driver creation to test
    various object relationships. With this in mind, a series of drivers can be developed
    to test numerous scenarios (that is, use cases). This type of modeling will more
    thoroughly be able to provide a test bed for related objects than the initial,
    simple means of testing for completeness and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Another area of concern between any type of related classes is that of version
    control. What happens, for example, if a base class definition or default behavior
    changes? How will that impact a derived class? How will that impact associated
    objects? With each change, we inevitably will need to revisit component testing
    for all related classes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s consider how exception handling mechanisms factor into OO component
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exception handling mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can create drivers to test each class (or a grouping of related
    classes), we will want to understand which methods in our code may throw exceptions.
    For these scenarios, we will want to add try blocks within the driver to ensure
    we know how to handle each potential exception thrown. Before doing so, we should
    ask ourselves, did we include adequate exception handling in our code during the
    development process? For example, considering instantiation, do our constructors
    check whether an object is fully constructed? Do they throw exceptions if not?
    If the answer is no, our classes may not be as robust as we had anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider embedding exception handling into a constructor, and how we may
    construct a driver to test all potential means for instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding exception handling in constructors to create robust classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may recall from our recent [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions*, that we can create our own exception classes, derived from
    the C++ Standard Library `exception` class. Let’s assume that we have created
    such a class, namely `ConstructionException`. If at any point in a constructor
    we are not able to properly initialize a given instance to provide a fully constructed
    object, we can throw a `ConstructionException` from any constructor. The implication
    of potentially throwing a `ConstructionException` is that we now should enclose
    instantiation within try blocks and add matching catch blocks to anticipate a
    `ConstructionException` that may be thrown. Keep in mind, however, that instances
    declared within the scope of a try block have scope only within the `try`-`catch`
    pairing.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that if an object does not complete construction (that is,
    if an exception is thrown before the constructor completes), the object will technically
    not exist. If an object does not technically exist, there will be no necessary
    clean up of a partially instantiated object. We will, however, need to think about
    what this means to our application if an instance we anticipate does not fully
    construct. How will that alter the progression of our code? Part of testing is
    to ensure that we have considered all ways in which our code may be used and bulletproof
    our code accordingly!
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the introduction of `try` and `catch` blocks may
    alter our program flow, and it is crucial to include this type of testing in our
    drivers. We may seek scenarios that account for the `try` and `catch` blocks as
    we conduct our testing.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how we can augment our test drivers to accommodate classes
    that may throw exceptions. We have also discussed in this chapter adding scenarios
    in our drivers to help track the states between objects with relationships and,
    of course, simple class idioms we can follow to set us up for success. Let us
    now briefly recap these concepts before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have increased our ability to become better C++ programmers
    by examining various OO class and component testing practices and strategies.
    Our primary goal is to ensure that our code is robust, well-tested, and can be
    deployed error-free to our various organizations.
  prefs: []
  type: TYPE_NORMAL
- en: We have considered programming idioms, such as following the canonical class
    form to ensure that our classes are complete and have expected behavior for construction/destruction,
    assignment, and usage in argument passing and as return values from functions.
    We have talked about what it means to create a robust class – one that follows
    the canonical class form that is also well-tested, platform-independent, and tested
    for fully constructed objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have also explored how to create drivers to test individual classes or sets
    of related classes. We have established a checklist of items to test individual
    classes within a driver. We have looked more thoroughly at object relationships
    to understand that objects that interact with one another require more sophisticated
    testing. That is, as objects move from state to state, they may be impacted by
    associated objects, which can further alter their course of progression. We’ve
    added utilizing scenarios as test cases for our drivers to better capture the
    dynamic states in which instances may move within an application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have taken a look at how exception handling mechanisms can impact
    how we test our code. We have augmented our drivers to account for the flow of
    control that try and catch blocks may redirect our applications from their anticipated,
    typical progression.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with the next part of our book, design
    patterns and idioms in C++. We will start with [*Chapter 16*](B19087_16.xhtml#_idTextAnchor711),
    *Using the Observer Pattern*. In the remaining chapters, we will understand how
    to apply popular design patterns and employ them in our coding. These skills will
    make us better programmers. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a pair of classes from one of your previous exercises containing an
    object relationship (hint – public inheritance will be easier to consider than
    association).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do your classes follow the canonical class form? Orthodox or extended? Why,
    or why not? If they do not and should, revise the classes to follow this idiom.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you consider your classes robust? Why, or why not?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a driver (or two) to test your pair of classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to test for the usual checklist of items (construction, assignment,
    destruction, the public interface, upcasting (if applicable), and use of a virtual
    function).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: (Optional) If you selected two classes related using association, create a separate
    driver to follow a typical scenario detailing the interaction of the two classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to include testing of exception handling in one of your test drivers.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ConstructionException` class (derived from the C++ Standard Library
    `exception`). Embed checks within your constructors in a sample class to throw
    a `ConstructionException` when necessary. Be sure to enclose all forms of instantiation
    of this class within the appropriate `try` and `catch` block pairings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 4: Design Patterns and Idioms in C++'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to expand your C++ repertoire, beyond OOP and other
    necessary skills, to include knowledge of core design patterns. Design patterns
    provide well-proven techniques and strategies to solve recurring types of OO problems.
    This section introduces common design patterns and demonstrates in depth how to
    apply these patterns by building on previous examples within the book in creative
    ways. Each chapter contains detailed code examples to exemplify each pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The initial chapter in this section introduces the idea of design patterns and
    discusses the advantages of utilizing such patterns within coding solutions. The
    initial chapter also introduces the Observer pattern and provides an in-depth
    program to appreciate the various components of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains the Factory Method pattern and likewise provides detailed
    programs, showing how to implement the Factory Method pattern with and without
    an Object Factory. This chapter additionally compares an Object Factory to an
    Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter introduces the Adapter pattern and provides implementation
    strategies and program examples using inheritance versus association to implement
    the Adapter class. Additionally, an adapter as a simple wrapper class is illustrated.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern is examined in the following chapter. Following two simple
    examples, a paired-class implementation is demonstrated with a detailed example.
    Registries to accommodate Singletons are also introduced.
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter in this section and book introduces the pImpl pattern to reduce
    compile-time dependencies within your code. A basic implementation is provided
    and then expanded upon using unique pointers. Performance issues are additionally
    explored relating to this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19087_16.xhtml#_idTextAnchor711), *Using the Observer Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19087_17.xhtml#_idTextAnchor743), *Applying the Factory Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B19087_18.xhtml#_idTextAnchor783), *Applying the Adapter Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 19*](B19087_19.xhtml#_idTextAnchor829), *Using the Singleton Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 20*](B19087_20.xhtml#_idTextAnchor876), *Removing Implementation
    Details Using the pImpl Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Design Patterns and Idioms in C++'
  prefs: []
  type: TYPE_NORMAL
