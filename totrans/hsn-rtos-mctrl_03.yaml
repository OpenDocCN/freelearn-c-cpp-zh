- en: Understanding RTOS Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 RTOS 任务
- en: The super loop programming paradigm is typically one of the first programming
    methods that an embedded systems engineer will encounter. A program implemented
    with a super loop has a single top-level loop that cycles through the various
    functions the system needs to perform. These simple `while` loops are easy to
    create and understand (when they are small). In FreeRTOS, tasks are very similar
    to super loops – the main difference is that the system can have more than one
    task, but only one super loop.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 超级循环编程范式通常是嵌入式系统工程师遇到的第一个编程方法之一。使用超级循环实现的程序有一个顶层循环，该循环遍历系统需要执行的各种函数。这些简单的 `while`
    循环易于创建和理解（当它们很小的时候）。在 FreeRTOS 中，任务与超级循环非常相似——主要区别是系统可以有多个任务，但只有一个超级循环。
- en: In this chapter, we will take a closer look at super loops and different ways
    of achieving a degree of parallelism with them. After that, a comparison between
    super loops and tasks will be made and a theoretical way of thinking about task
    execution will be introduced. Finally, we'll take a look at how tasks are *actually* executed
    with an RTOS kernel and compare two basic scheduling algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地研究超级循环以及使用它们实现一定程度的并行性的不同方法。之后，将比较超级循环和任务，并介绍关于任务执行的理论思考方式。最后，我们将探讨如何在
    RTOS 内核中实际执行任务，并比较两种基本的调度算法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing super loop programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍超级循环编程
- en: Achieving parallel operations with super loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超级循环实现并行操作
- en: Comparing RTOS tasks to super loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较RTOS任务与超级循环
- en: Achieving parallel operations with RTOS tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RTOS 任务实现并行操作
- en: RTOS tasks versus super loops – pros and cons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTOS 任务与超级循环——优点和缺点
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no software or hardware requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有软件或硬件要求。
- en: Introducing super loop programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍超级循环编程
- en: There is one common property that all embedded systems share – they don't have
    an exit point. Because of its nature, embedded code is generally expected to always
    be available – silently running in the background, taking care of housekeeping
    tasks, and ready for user input at any time. Unlike desktop environments that
    are meant to start and stop programs, there isn't anything for a micro-controller
    to do if it exits the `main()` function. If this happens, it is likely that the
    entire device has stopped functioning. For this reason the `main()` function in
    an embedded system never returns. Unlike application programs, which are started
    and stopped by their host OS, most embedded MCU-based applications start at power
    on and end abruptly when the system is powered off. Because of this abrupt shutdown,
    embedded applications typically don't have any of the shutdown tasks normally
    associated with applications, such as freeing memory and resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有嵌入式系统都共享的一个共同特性是——它们没有退出点。由于其本质，嵌入式代码通常预期始终可用——在后台默默运行，处理日常维护任务，并随时准备接收用户输入。与旨在启动和停止程序的桌面环境不同，如果微控制器退出
    `main()` 函数，它就没有任何事情可做。如果发生这种情况，整个设备可能已经停止工作。因此，嵌入式系统中的 `main()` 函数永远不会返回。与应用程序不同，应用程序由其宿主操作系统启动和停止，大多数基于嵌入式
    MCU 的应用程序在电源开启时启动，在系统断电时突然结束。由于这种突然关闭，嵌入式应用程序通常没有与应用程序通常关联的任何关闭任务，例如释放内存和资源。
- en: 'The following code represents the basic idea of a super loop. Take a look at
    this before moving on to the more detailed explanations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码代表了超级循环的基本思想。在继续更详细的解释之前，请先看看这个：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While extremely simple, the preceding code has a number of features worth pointing
    out. The `while` loop never returns – it goes on forever executing the same three
    functions (this is intended). The three innocent-looking function calls can hide
    some nasty surprises in a real-time system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常简单，前面的代码有几个值得注意的特性。`while` 循环永远不会返回——它会永远执行相同的三个函数（这是预期的）。这三个看似无辜的函数调用在实时系统中可能隐藏一些令人惊讶的问题。
- en: The basic super loop
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本超级循环
- en: 'This main loop that never returns is generally referred to as a *super loop*.
    It''s always fun to think *super* because it has control over most things in the
    system – nothing gets done in the following diagram unless the super loop makes
    it happen. This type of setup is perfect for very simple systems that need to
    perform just a few tasks that don''t take a considerable amount of time. Basic
    super loop structures are extremely easy to write and understand; if the problem
    you''re trying to solve can be done with a simple super loop, then use a simple
    super loop. Here is the execution flow of the code presented previously – each
    function is called sequentially and the loop never exits:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个永远不会返回的主循环通常被称为**超级循环**。思考**超级**这个词总是很有趣，因为它控制着系统中的大多数事物——在下图中，除非超级循环使其发生，否则什么都不会完成。这种设置非常适合非常简单的系统，这些系统只需要执行几个耗时不太多的任务。基本的超级循环结构非常容易编写和理解；如果你试图解决的问题可以用简单的超级循环完成，那么就使用简单的超级循环。以下是之前展示的代码的执行流程——每个函数都是顺序调用的，循环永远不会退出：
- en: '![](img/cc1de34f-1936-496b-bdf2-84cbb1d49776.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc1de34f-1936-496b-bdf2-84cbb1d49776.png)'
- en: Now, let's have a look at what this execution looks like in a real-time system
    and some of the drawbacks associated with this approach.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在实时系统中这种执行看起来是什么样子，以及与这种方法相关的一些缺点。
- en: Super loops in real-time systems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时系统中的超级循环
- en: 'When simple super loops are operating quickly (usually because they have limited
    functionality/responsibility), they are quite responsive. However, the simplicity
    of the super loop can be a blessing and a curse. Since each function always follows
    the preceding function, they are always called in the same sequence and fully
    dependent on one another. Any delay introduced by one function propagates to the
    next function, which causes the total amount of time it takes to execute that
    iteration of the loop to increase (as seen in the following diagram). If `func1`
    takes 10 us to execute one time through the loop, and then 100 ms the next, `func2`
    isn''t going to be called nearly as quickly the second time through the loop as
    it was the first time through:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当简单的超级循环快速运行时（通常是因为它们的功能/责任有限），它们非常响应。然而，超级循环的简单性既是祝福也是诅咒。由于每个函数总是跟随前一个函数，它们总是以相同的顺序调用，并且完全依赖于彼此。任何一个函数引入的延迟都会传播到下一个函数，这会导致执行该循环迭代的总时间增加（如下图所示）。如果
    `func1` 在循环中执行一次需要 10 us，而下一次需要 100 ms，那么 `func2` 在第二次通过循环时不会像第一次那样快地被调用：
- en: '![](img/50b20b51-d2ed-46c5-9d06-858b44634a4e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50b20b51-d2ed-46c5-9d06-858b44634a4e.png)'
- en: 'Let''s take a look at this in a little bit more depth. In the preceding diagram,
    `func3` is responsible for checking the state of a flag representing an external
    event (this event signals a rising edge of a signal). The frequency of how often `func3`
    checks the flag is dependent on how long `func1` and `func2` take to execute.
    A well designed and responsive super loop will typically execute very rapidly,
    checking for events more often than they occur (callout B). When an external event
    does occur, the loop doesn''t detect the event until the next time `func3` executes
    (callouts A, C, and D). Notice that there is a delay between when the event is
    generated and when it is detected by `func3`. Also note that the delay isn''t
    always consistent: this difference in time is referred to as jitter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看这个问题。在先前的图中，`func3` 负责检查表示外部事件的标志的状态（此事件表示信号的上升沿）。`func3` 检查标志的频率取决于
    `func1` 和 `func2` 执行所需的时间。设计良好且响应迅速的超级循环通常会非常快速地执行，比事件发生的频率检查得更频繁（见标注 B）。当外部事件发生时，循环直到
    `func3` 下一次执行时才会检测到该事件（见标注 A、C 和 D）。请注意，事件生成和 `func3` 检测到事件之间存在延迟。此外，延迟并不总是恒定的：这种时间差异被称为抖动。
- en: In many super loop-based systems, the execution speed of the super loop is extremely
    high compared to slowly occurring events being polled. We don't have enough room
    on the page to show a loop executing hundreds (or thousands) of iterations between
    detecting an event!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多基于超级循环的系统里，超级循环的执行速度与缓慢发生的事件轮询相比极高。我们无法在页面上展示在检测到事件之间执行数百（或数千）次迭代的循环！
- en: If a system has a known maximum amount of jitter when responding to an event,
    it is considered to be deterministic. That is, it will reliably respond to an
    event within the specified amount of time after that event occurs. A high level
    of determinism is crucial for time-critical components in a real-time system because,
    without it, the system could fail to respond to important events in a timely manner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个系统在响应事件时有一个已知的最大抖动量，那么它被认为是确定的。也就是说，它将在事件发生后的一段时间内可靠地响应事件。在实时系统中，高确定度对于时间关键组件至关重要，因为没有它，系统可能无法及时响应重要事件。
- en: Consider the case of a loop checking a hardware flag repeatedly for an event
    (this is referred to as polling). The tighter the loop, the faster the flag is
    checked – when the flag is checked often, the code will be more responsive to
    the event of interest. If we have an event that needs to be acted upon in a timely
    manner, we could just write a really tight loop and wait for the important event
    to occur. This approach works – but *only* if that event is the only thing of
    interest for the system. If the *only* responsibility the entire system has is
    watching for that event (no background I/O, communication, and so on), then this
    is a valid approach. This type of situation rarely occurs in today's complex real-world
    systems. Poor responsiveness is the limitation of solely polled-based systems.
    Next up, we'll take a look at how to get a bit more parallelism in our super loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个循环不断检查硬件标志以等待事件的情况（这被称为轮询）。循环越紧密，标志检查的速度越快——当标志频繁检查时，代码对感兴趣事件的响应性会更强。如果我们有一个需要及时处理的事件，我们可以编写一个非常紧密的循环并等待重要事件发生。这种方法是可行的——但*仅*当该事件是系统唯一感兴趣的事情时。如果整个系统的唯一责任就是监视该事件（没有后台I/O、通信等），那么这是一种有效的方法。这种类型的情形在当今复杂的现实世界系统中很少见。仅轮询的系统响应性差是其局限性。接下来，我们将探讨如何在超级循环中实现更多的并行性。
- en: Achieving parallel operations with super loops
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级循环实现并行操作
- en: Even though a basic super loop can only step through functions sequentially,
    there are still ways to achieve parallelism. MCUs have a few different types of
    specialized hardware designed to take some of the burden away from the CPU, while
    still enabling a highly responsive system. This section will introduce those systems
    and how they can be used within the context of a super loop style program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使基本超级循环只能按顺序执行函数，仍然有方法实现并行性。微控制器（MCU）有几类专门的硬件，旨在从CPU中分担一些负担，同时仍然使系统保持高度响应。本节将介绍这些系统以及如何在超级循环风格的程序中使用它们。
- en: Introducing interrupts
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍中断
- en: Polling for a single event is not only wasteful in terms of CPU cycles and power
    – it also results in a system that isn't responsive to anything else, which should
    generally be avoided. So then, how can we get a single core processor to do things
    in parallel? Well, we can't – there's only one processor after all. . . but since
    our processor is likely to be running millions of instructions per second, it
    is possible to get it to perform things that are close enough to parallel. MCUs
    also include dedicated hardware for generating interrupts. Interrupts provide
    signals to the MCU that allow it to jump directly to an **interrupt service routine**
    (**ISR**) when the event occurs. This is such a critical piece of functionality
    that ARM Cortex-M cores provide a standardized peripheral for it, called the **nested
    vector in****terrupt controller** (**NVIC**). The NVIC provides a common way of
    dealing with interrupts. The *nested* portion of this term signifies that even
    interrupts can be interrupted by other interrupts with a higher priority. This
    is quite convenient since it allows us to minimize the amount of latency and jitter
    for the most time-critical pieces of the system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对单个事件进行轮询不仅浪费CPU周期和电力，而且还会导致系统对其他任何事情都没有响应，这通常应该避免。那么，我们如何让单核处理器并行处理事情呢？好吧，我们做不到——毕竟能力有限。但是，由于我们的处理器每秒可能运行数百万条指令，因此有可能让它执行接近并行的事情。微控制器还包括用于生成中断的专用硬件。中断向微控制器提供信号，允许它在事件发生时直接跳转到**中断服务例程（ISR**）。这是如此关键的功能，以至于ARM
    Cortex-M核心为此提供了一个标准的外设，称为**嵌套向量中断控制器（NVIC**）。NVIC提供了一种处理中断的通用方式。这个术语中的*嵌套*部分表示即使中断也可以被具有更高优先级的中断中断。这非常方便，因为它允许我们最小化系统中最关键部分延迟和抖动的数量。
- en: So, how do interrupts fit into a super loop in a way that better achieves the
    illusion of parallel activity? The code inside an ISR is generally kept as short
    as possible, in order to minimize the amount of time spent in the interrupt. This
    is important for a few reasons. If the interrupt occurs very often and the ISR
    contains a *lot* of instructions, there is a chance that the ISR won't return
    before being called again. For communication peripherals such as UART or SPI,
    this will mean dropped data (which obviously isn't desirable). Another reason
    to keep the code short is because other interrupts also need to be serviced, which
    is why it's a good idea to push off any responsibility to the code that isn't
    running inside an ISR context.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，中断如何适应超级循环以更好地实现并行活动的错觉呢？ISR内部的代码通常尽可能保持简短，以最小化中断中花费的时间。这有几个原因。如果中断非常频繁，且ISR包含大量指令，ISR可能在没有再次被调用之前就返回。对于UART或SPI等通信外设，这意味着丢失数据（这显然是不希望的）。保持代码简短的另一个原因是其他中断也需要服务，这就是为什么推迟非ISR上下文中的代码执行是一个好主意。
- en: 'To quickly get an idea of how ISRs contribute to jitter, let''s take a look
    at a simple example of an external **analog to digital converter** (**ADC**) signaling
    to an MCU that a reading has been taken and the conversion is ready to be transferred
    to the MCU (refer to the hardware diagram shown here):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速了解ISR如何影响抖动，让我们看看一个简单的例子，外部**模拟到数字转换器**（ADC）向MCU发出信号，表示已读取并准备好将转换传输到MCU（请参考此处所示的硬件图）：
- en: '![](img/ddf5caac-58f0-435e-9286-9efceea5f8e0.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddf5caac-58f0-435e-9286-9efceea5f8e0.png)'
- en: In the ADC hardware, a pin is dedicated to signaling that a reading of an analog
    value has been converted to a digital representation and is ready for transfer
    to the MCU. The MCU would then initiate a transfer over the communication medium
    (COM in the diagram).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在ADC硬件中，一个引脚被专门用于表示已将模拟值转换为数字表示，并准备好传输到MCU。然后MCU将在通信介质（图中为COM）上启动传输。
- en: 'Next, let''s have a look at how the ISR calls might stack up against one another
    over time, relative to the rising edge on the conversion ready line. The following
    diagram shows six different instances of ISR being called in response to a rising
    edge of a signal. The small amount of time between when the rising edge occurs
    in the hardware versus when the ISR in firmware is invoked is the minimum latency.
    The jitter in the response of the ISR is the difference in the latency over many
    different cycles:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看ISR调用如何在时间上相互堆叠，相对于转换就绪线的上升沿。以下图表显示了在响应信号上升沿时被调用的六个不同ISR实例。硬件中上升沿发生时与固件中ISR被调用之间的小段时间是最小延迟。ISR响应的抖动是许多不同周期中延迟的差异：
- en: '![](img/2fe1639a-87e9-4bc4-9a6c-0506b974a644.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fe1639a-87e9-4bc4-9a6c-0506b974a644.png)'
- en: There are different ways to minimize latency and jitter for critical ISRs. In
    ARM Cortex-M-based MCUs, interrupt priorities are flexible – a single interrupt
    source can be assigned different priorities at runtime. The ability to reprioritize
    interrupts is one way of making sure the most important parts of a system get
    the CPU when they need it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键的中断服务例程（ISR），有不同方法来最小化延迟和抖动。在基于ARM Cortex-M的微控制器（MCU）中，中断优先级是灵活的——可以在运行时为单个中断源分配不同的优先级。能够重新排序中断是一种确保系统最重要的部分在需要时获得CPU的方法。
- en: As mentioned before, it is important to keep the amount of code executing in
    interrupts as short as possible, since code that is inside an ISR will take precedence
    over any code that is not in an ISR (for example `main()`). Additionally, lower
    priority ISRs won't be executed until all of the code in a higher priority ISR
    has been executed and the ISR exits – which is why it is important to keep ISRs
    short. It is always a good idea to try and limit how much *responsibility* (and
    therefore code) an ISR has.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，保持中断中执行的代码量尽可能短是很重要的，因为ISR内部的代码将优先于任何非ISR的代码（例如`main()`）。此外，较低优先级的中断只有在所有较高优先级ISR中的代码都已执行且ISR退出后才会执行——这就是为什么保持ISR简短很重要的原因。始终尝试限制ISR的责任（以及因此的代码）是一个好主意。
- en: When multiple interrupts are nested, they don't fully return – there's actually
    a really useful feature of ARM Cortex M processors called interrupt-tail chaining.
    If the processor detects that an interrupt is about to exit, but another one is
    pending, the next ISR will be executed without the processor totally restoring
    the pre-interrupt state, which further reduces latency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个中断嵌套时，它们不会完全返回——实际上，ARM Cortex M 处理器有一个非常有用的特性，称为中断尾链。如果处理器检测到即将退出的中断，但另一个中断正在等待，则下一个
    ISR 将在没有处理器完全恢复中断前的状态的情况下执行，这进一步减少了延迟。
- en: Interrupts and super loops
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和超级循环
- en: One way of achieving minimal instructions and responsibility in the ISR is to
    do the smallest amount of work possible inside the ISR and then set a flag that
    is checked by code running in the super loop. This way, the interrupt can be serviced
    as soon as possible, without the entire system being dedicated to waiting on the
    event. In the following diagram, notice how the interrupt is being generated multiple
    times before finally being dealt with by `func3`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在中断服务例程（ISR）中实现最小指令和责任的一种方法是在 ISR 中完成尽可能少的工作，然后设置一个由超级循环中的代码检查的标志。这样，中断可以尽快得到处理，而无需整个系统都致力于等待该事件。在下面的图中，注意中断是如何被多次生成，最终由
    `func3` 处理的。
- en: 'Depending on what exactly that interrupt is trying to achieve, it will typically
    take a value from the associated peripheral and push it into an array (or take
    a value from an array and feed it to the peripheral registers). In the case of
    our external ADC, the ISR (triggered each time the ADC performs a conversion)
    would go out to the ADC, transfer the digitized reading, and store it in RAM,
    setting a flag indicating that one or more values are ready for processing. This
    allows for the interrupt to be serviced multiple times without involving the higher-level
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据中断试图实现的确切内容，它通常会从一个相关的外设取一个值并将其推入一个数组（或者从一个数组中取一个值并将其馈送到外设寄存器）。在我们的外部 ADC
    的情况下，ISR（每次 ADC 执行转换时都会触发）会输出到 ADC，传输数字读数，并将其存储在 RAM 中，设置一个标志以指示一个或多个值已准备好处理。这允许中断被多次处理，而不涉及高级代码：
- en: '![](img/b0bf6dd0-d0a7-4e8b-9636-245b27bc1f85.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0bf6dd0-d0a7-4e8b-9636-245b27bc1f85.png)'
- en: In the case of a communication peripheral that is transmitting large blocks
    of data, an array can be used as a queue for storing items to be transmitted.
    At the end of the entire transmission, a flag can be set to notify the main loop
    of the completion. There are many examples of situations where queuing values
    are appropriate. For instance, if some processing is required to be performed
    on a block of data, it is often advantageous to collect the data first and then
    process the entire block together outside of the interrupt. An interrupt-driven
    approach isn't the only way to achieve this blocked-data approach. In the next
    section, we'll take a look at a piece of hardware that can make moving large blocks
    of data both easier for the programmer, and more efficient for the processor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在传输大量数据块的通信外设，可以使用数组作为存储要传输项目的队列。在整个传输结束时，可以设置一个标志来通知主循环完成。有许多情况下使用队列值是合适的。例如，如果需要对数据块执行一些处理，通常先收集数据，然后在中断之外一起处理整个块是有利的。中断驱动的方法不是实现这种阻塞数据方法的唯一方式。在下一节中，我们将查看一个可以使移动大量数据对程序员来说更容易，对处理器来说更高效的硬件。
- en: Introducing DMA
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 DMA
- en: 'Remember the assertion that the processor couldn''t *really *do things truly
    in parallel? This is still true. *However *. . . modern MCUs contain more than
    just a processing core. While our processing core is chugging along dealing with
    instructions, there are many other hardware subsystems hard at work inside the
    MCU. One of these hard working subsystems is called a **Direct Memory Access Controller**
    (**DMA**):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那个处理器**真正**不能并行处理事务的断言吗？这依然成立。然而……现代微控制器不仅仅包含一个处理核心。当我们的处理核心正在处理指令时，MCU 内部还有许多其他硬件子系统正在努力工作。其中一个努力工作的子系统被称为**直接内存访问控制器**（**DMA**）：
- en: '![](img/8a6eab36-865d-4565-8043-b8eb88bad6bd.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a6eab36-865d-4565-8043-b8eb88bad6bd.png)'
- en: The preceding diagram presents a very simplified hardware block diagram that
    shows a view of two different data paths available from RAM to a UART peripheral.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了一个非常简化的硬件模块图，展示了从 RAM 到 UART 外设的两种不同数据路径的视图。
- en: 'In the case of receiving a stream of bytes from a UART without DMA, information
    from the UART will move into the UART registers, be read by the CPU, and then
    pushed out to RAM for storage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有DMA的情况下从UART接收字节流的情况下，UART的信息将移动到UART寄存器中，由CPU读取，然后推送到RAM中存储：
- en: The CPU must detect when an individual byte (or word) has been received, either
    by polling the UART register flags, or by setting up an interrupt service routine
    that will be fired when a byte is ready.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU必须检测到单个字节（或字）已被接收，无论是通过轮询UART寄存器标志，还是通过设置一个当字节准备好时会被触发的中断服务例程。
- en: After the byte is transferred from the UART, the CPU can then place it into
    RAM for further processing.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UART传输字节之后，CPU可以将其放入RAM以进行进一步处理。
- en: Steps 1 and 2 are repeated until the entire message is received.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤1和步骤2会重复，直到整个消息接收完成。
- en: 'When DMA is used in the same scenario, the following happens:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同场景下使用DMA时，会发生以下情况：
- en: The CPU configures the DMA controller and peripheral for the transfer.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU配置DMA控制器和外围设备以进行传输。
- en: The DMA controller takes care of ALL transfers between the UART peripheral and
    RAM. This requires no intervention from the CPU.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMA控制器负责处理UART外围设备和RAM之间的所有传输。这不需要CPU的干预。
- en: The CPU will be notified when the entire transfer is complete and it can go
    directly to processing the entire byte stream.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当整个传输完成时，CPU会收到通知，可以直接处理整个字节流。
- en: Most programmers find DMA to be nearly magical if they're accustomed to dealing
    with super loops and ISRs. The controller is configured to transfer a block of
    memory to the peripheral, as the peripheral needs it, and then provide a notification
    (typically via an interrupt) when the transfer is complete – that's it!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员如果习惯了处理超级循环和中断服务例程（ISRs），会发现直接内存访问（DMA）几乎像魔法一样神奇。控制器被配置为在需要时将内存块传输到外围设备，并在传输完成后提供通知（通常是中断）——这就完成了！
- en: This convenience does come at a price, of course. It does take some time to
    set up the DMA transfer initially, so for small transfers, it might actually take
    more CPU time to set up the transfer than if an interrupt or polled method was
    used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种便利性是有代价的。设置DMA传输最初确实需要一些时间，因此对于小传输，实际上可能需要比使用中断或轮询方法更多的时间来设置传输。
- en: 'There are also some caveats to be aware of: each MCU has specific limitations,
    so be sure to read the details of the datasheet, reference manual, and errata
    before counting on the availability of DMA for a critical design component of
    the system:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些需要注意的注意事项：每个MCU都有特定的限制，因此在依赖DMA作为系统关键设计组件的可用性之前，务必阅读数据表、参考手册和勘误表：
- en: The bandwidth of the MCU's internal buses limits the number of bandwidth-hungry
    peripherals that can be reliably placed on a single bus.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MCU内部总线的带宽限制了可以可靠地放置在单个总线上的带宽密集型外围设备的数量。
- en: Occasionally, limited availability of mapped DMA channels to peripherals also
    complicates the design process.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，映射到外围设备的DMA通道的有限可用性也会使设计过程复杂化。
- en: These types of reasons are why it is important to get all team members involved
    with the early-stage design of embedded systems, rather than just *throwing it
    over the wall*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这些原因，让所有团队成员参与嵌入式系统早期阶段的设计非常重要，而不仅仅是“扔过墙”。
- en: DMA is great for accessing a large number of peripherals efficiently, giving
    us the ability to add more and more functionality to the system. However, as we
    start adding more and more modules of code to the super loop, inter-dependencies
    between subsystems become more complex as well. In the next section, we'll discuss
    the challenges of scaling a super loop for complex systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: DMA对于高效访问大量外围设备非常出色，它使我们能够向系统添加更多和更多的功能。然而，当我们开始向超级循环添加越来越多的代码模块时，子系统之间的相互依赖关系也会变得更加复杂。在下一节中，我们将讨论扩展超级循环以适应复杂系统的挑战。
- en: Scaling a super loop
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展超级循环
- en: So, we've now got a responsive system that is able to reliably process interrupts.
    Perhaps we've configured a DMA controller to take care of the heavy lifting for
    the communication peripherals as well. Why do we even need an RTOS? Well, it is
    entirely possible you don't! If the system is dealing with a limited number of
    responsibilities and none of them are especially complicated or time-consuming,
    then there may be no need for anything more sophisticated than a super loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个响应迅速的系统，能够可靠地处理中断。也许我们还配置了一个 DMA 控制器来处理通信外设的繁重工作。我们为什么还需要 RTOS 呢？好吧，完全有可能你不需要！如果系统只处理有限的责任，并且它们都不是特别复杂或耗时，那么可能不需要比超级循环更复杂的东西。
- en: However, if the system is also responsible for generating a **User Interface**
    (**UI**), running complex time-consuming algorithms, or dealing with complex communication
    stacks, it is very likely that these tasks will take a non-trivial amount of time.
    If a glitzy eye-catching UI with lots of animation starts to stutter a little
    bit because the MCU is dealing with collecting data from a critical sensor, that
    is no big deal. Either the animation can be dialed back or eliminated and the
    important part of the real-time system is left intact. But what happens if that
    animation still looks perfectly good, even though there was some missed data from
    the sensor?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果系统还负责生成 **用户界面**（**UI**），运行复杂耗时算法，或处理复杂的通信堆栈，那么这些任务很可能需要相当多的时间。如果因为 MCU
    正在处理从关键传感器收集数据，一个花哨的、引人注目的 UI 开始出现一点卡顿，那也不是什么大问题。动画可以被降低或消除，而实时系统的重要部分仍然保持完好。但如果是动画看起来仍然完美无瑕，尽管传感器有数据丢失呢？
- en: 'There are all sorts of different ways in which this problem plays out every
    day in our industry. Sometimes, if the system was designed well enough, the missing
    data will be detected and flagged (but it can''t be recovered: it is gone forever).
    If the design team is really lucky, it may even have failed in this way during
    in-house testing. However, in many cases, the missed sensor data will go completely
    unnoticed until somebody notices one of the readings seems to be a little bit
    off ... sometimes. If everyone is lucky, the bug report for the sketchy reading
    might include a hint that it only seems to happen when someone is at the front
    panel (playing with those fancy animations). This would at least give the poor
    firmware engineer assigned to debug the issue a hint – but we''re often not even
    that lucky.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的行业中，每天都会以各种不同的方式出现这个问题。有时，如果系统设计得足够好，丢失的数据会被检测并标记（但无法恢复：它永远消失了）。如果设计团队真的很幸运，它甚至可能在内部测试中失败。然而，在许多情况下，丢失的传感器数据可能完全未被注意到，直到有人注意到其中一个读数似乎有点不对……有时候。如果每个人都足够幸运，关于可疑读数的错误报告可能包括一个提示，表明它似乎只在有人在前面板上（玩那些花哨的动画）时发生。这至少会给被分配调试问题的可怜的固件工程师一个提示——但我们通常甚至没有这么幸运。
- en: These are the types of systems where an RTOS is needed. Guaranteeing that the
    most time-critical tasks are always running when necessary and scheduling lower
    priority tasks to run whenever spare time is available is a strong point of preemptive
    schedulers. In this type of setup, the critical sensor readings could be pushed
    into their own task and assigned a high priority – effectively interrupting anything
    else in the system (except ISRs) when it was time to deal with the sensor. That
    complex communication stack could be assigned a lower priority than the critical
    sensor. Finally, the glitzy UI with the fancy animations gets the left-over processor
    cycles. It is free to perform as many sliding alpha-blending animations as it
    wants, but only when the processor doesn't have anything else better to do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是需要 RTOS 的系统类型。确保最关键的任务在必要时始终运行，并将低优先级任务安排在有空闲时间时运行，这是抢占式调度器的优势所在。在这种配置中，关键传感器的读数可以被推入它们自己的任务，并分配高优先级——在处理传感器的时候，实际上会中断系统中的任何其他任务（除了中断服务例程）。那个复杂的通信堆栈可以分配比关键传感器更低的优先级。最后，花哨的
    UI 和那些花哨的动画得到剩余的处理器周期。它可以自由地执行尽可能多的滑动 alpha 混合动画，但只有在处理器没有其他更好的事情可做的时候。
- en: Comparing RTOS tasks to super loops
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RTOS 任务与超级循环进行比较
- en: 'So far, we''ve only mentioned tasks very casually, but what is a task, really?
    An easy way to think about a task is that it is *just another main loop*. In a
    preemptive RTOS, there are two main differences between tasks and super loops:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是非常随意地提到了任务，但任务到底是什么呢？一个简单的方式来思考任务就是，它只是另一个主循环。在抢占式 RTOS 中，任务与超级循环之间有两个主要区别：
- en: Each task receives its own private stack. Unlike a super loop in main, which
    was sharing the system stack, tasks receive their own stack that no other task
    in the system will use. This allows each task to have its own call stack without
    interfering with other tasks.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务都有自己的私有栈。与主循环中的超级循环不同，它共享系统栈，任务拥有自己的栈，系统中的其他任务都不会使用这个栈。这允许每个任务都有自己独立的调用栈，而不会干扰其他任务。
- en: Each task has a priority assigned to it. This priority allows the scheduler
    to make decisions on which task should be running (the goal is to make sure the
    highest priority task in the system is always doing useful work).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务都被分配了一个优先级。这个优先级允许调度器做出决定，确定哪个任务应该运行（目标是确保系统中优先级最高的任务始终在进行有用的工作）。
- en: 'Given these two features, each task may be programmed as if it is the only
    thing the processor has to do. Do you have a single flag you''d like to watch
    AND some calculations for flashy animations to churn through? No problem: simply
    program the task and assign it a reasonable priority, relative to the rest of
    the system''s functionality. The preemptive scheduler will always ensure that
    the most important task is executing when it has work to do. When a higher priority
    task no longer has useful work to perform and it is waiting on something else
    in the system, a lower priority task will be switched into context and allowed
    to run.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这两个特性，每个任务都可以像它是处理器唯一要执行的事情一样进行编程。你有没有一个想监控的单个标志，以及一些用于闪亮动画的计算？没问题：只需编程任务并为其分配一个合理的优先级，相对于系统功能的其余部分。抢占式调度器将始终确保当有工作要做时，最重要的任务正在执行。当一个高优先级任务不再有有用的工作可执行，并且它在等待系统中的其他事情时，一个低优先级任务将被切换到上下文并允许运行。
- en: The FreeRTOS scheduler will be discussed in more detail in [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),
    *The FreeRTOS Scheduler*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 调度器将在第 7 章[FreeRTOS 调度器](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)中更详细地讨论。
- en: Achieving parallel operations with RTOS tasks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RTOS 任务实现并行操作
- en: 'Earlier, we had looked at a super loop that was looping through three functions.
    Now, for a very simple example, let''s move each one of the three functions into
    its own task. We''ll use these three simple tasks to examine the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们查看了一个循环遍历三个函数的超级循环。现在，作为一个非常简单的例子，让我们将这三个函数中的每一个移动到它自己的任务中。我们将使用这三个简单的任务来检查以下内容：
- en: '**Theoretical task programming model**: How the three tasks can be described theoretically'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论任务编程模型**：如何从理论上描述三个任务'
- en: '**Actual round-robin scheduling**: What the tasks look like when executed using
    a round-robin scheduling algorithm'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际的循环调度**：使用循环调度算法执行任务时的样子'
- en: '**Actual preemptive scheduling**: What the tasks look like when executed using
    preemptive scheduling'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际的抢占式调度**：使用抢占式调度执行任务时的样子'
- en: In real-world programs, there is almost never a single function per task; we're
    only using this as an analog to the overly simplistic super loop from earlier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的程序中，几乎每个任务都不是一个单独的函数；我们只是用它作为之前过度简化的超级循环的类比。
- en: Theoretical task programming model
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理论任务编程模型
- en: 'Here''s some pseudo-code that uses a super loop to execute three functions.
    The same three functions are also included in a task-based system – each RTOS
    task (on the right) contains the same functionality as the functions from the
    super loop on the left. This will be used moving forward as we discuss the differences
    in how the code is executed when using a super loop versus using a task-driven
    approach with a scheduler:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用超级循环执行三个函数的伪代码。同样的三个函数也包含在基于任务的系统中——每个 RTOS 任务（在右侧）包含的功能与左侧超级循环中的函数相同。在讨论使用超级循环与使用带有调度器的任务驱动方法执行代码时的差异时，我们将继续使用这一点：
- en: '![](img/ad3dfae0-42ea-4a9f-ad2c-2ca7d38fc3f7.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad3dfae0-42ea-4a9f-ad2c-2ca7d38fc3f7.png)'
- en: One of the immediate differences you might notice between the super loop implementation
    and the RTOS implementation is the number of infinite `while` loops. There is
    only a single infinite `while` loop (in `main()`) for the super loop implementation,
    but each task has its own infinite `while` loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会立即注意到超级循环实现和实时操作系统（RTOS）实现之间的一个区别是无限`while`循环的数量。超级循环实现只有一个无限`while`循环（在`main()`中），但每个任务都有自己的无限`while`循环。
- en: 'In the super loop, the three functions being executed by a super loop are each
    run to completion before the next function is called, and then the cycle continues
    onto the next iteration (illustrated by the following diagram):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在超级循环中，由超级循环执行的三个函数在调用下一个函数之前都会运行到完成，然后循环继续到下一个迭代（以下图所示）：
- en: '![](img/3bb60f4a-fad2-4597-abae-6ca87409c6d4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bb60f4a-fad2-4597-abae-6ca87409c6d4.png)'
- en: 'In the RTOS implementation, each task is essentially its own little infinite
    `while` loop. Whereas functions in the super loop were always sequentially called
    one after the other (orchestrated by the logic in the super loop), tasks can simply
    be thought of as all executing in parallel after the scheduler has been started.
    Here''s a diagram of an RTOS executing three tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在RTOS实现中，每个任务本质上都是一个小的无限`while`循环。而超级循环中的函数总是依次顺序调用（由超级循环中的逻辑编排），任务可以简单地被视为在调度器启动后并行执行。以下是一个RTOS执行三个任务的图示：
- en: '![](img/7a6161d5-f95f-4367-999f-6aabbcb9e90a.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a6161d5-f95f-4367-999f-6aabbcb9e90a.png)'
- en: In the diagram, you'll notice that the size of each `while` loop is not the
    same. This is one of the many benefits of using a scheduler that is executing
    the tasks in *parallel* versus a super loop – the programmer doesn't need to be
    immediately concerned with the length of the longest executing loop slowing down
    the other tighter loops. The diagram depicts `Task 2` having a much longer loop
    than `Task 1`. In a super loop system, this would cause the functionality in `func1`
    to execute less frequently (since the super loop would need to execute `func1`,
    then `func2`, and then `func3`). In a task-based programming model, this isn't
    the case – the loop of each task can be thought of as being isolated from the
    other tasks in the system – and they all run in parallel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，你会注意到每个`while`循环的大小并不相同。这是使用执行任务在*并行*的调度器而不是超级循环的许多好处之一——程序员不需要立即担心最长执行循环的长度会减慢其他更紧密循环的速度。图中显示了`Task
    2`的循环比`Task 1`长得多。在超级循环系统中，这会导致`func1`的功能执行频率降低（因为超级循环需要先执行`func1`，然后是`func2`，最后是`func3`）。在基于任务的编程模型中，情况并非如此——每个任务的循环可以被视为与系统中的其他任务隔离——并且它们都并行运行。
- en: This isolation and perceived parallel execution are some of the benefits of
    using an RTOS; it alleviates some of the complexity for the programmer. So – that's
    the easiest way of conceptualizing tasks – they're simply independent infinite
    `while` loops that all execute in parallel . . . in theory. In reality, things
    aren't quite this simple. In the next two sections, we'll take a glimpse into
    what goes on behind the scenes to make it *seem* like tasks are executing in parallel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隔离和感知到的并行执行是使用RTOS的一些好处；它减轻了程序员的一些复杂性。所以——这是概念化任务的最简单方法——它们只是简单地独立的无穷`while`循环，所有这些循环都并行执行……在理论上。在现实中，事情并不这么简单。在接下来的两个部分中，我们将一瞥幕后发生的事情，以使其看起来像任务正在并行执行。
- en: Round-robin scheduling
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询调度
- en: 'One of the easiest ways to conceptualize actual task execution is with round-robin
    scheduling. In round-robin scheduling, each task gets a small slice of time to
    use the processor, which is controlled by the scheduler. As long as the task has
    work to perform, it will execute. As far as the task is concerned, it has the
    processor entirely to itself. The scheduler takes care of all of the complexity
    of switching in the appropriate context for the next task:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 概念化实际任务执行的最简单方法之一是轮询调度。在轮询调度中，每个任务都会得到一小段时间来使用处理器，这由调度器控制。只要任务有工作要做，它就会执行。对任务来说，它似乎拥有整个处理器。调度器负责处理切换到下一个任务所需的所有上下文复杂性：
- en: '![](img/bf10b772-0a6c-4bef-b257-43d452369a0a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf10b772-0a6c-4bef-b257-43d452369a0a.png)'
- en: This is the same three tasks that were shown previously, except that instead
    of a theoretical conceptualization, each iteration through the tasks' loops are
    enumerated over time. Because the round-robin scheduler assigns equal time slices
    to each task, the shortest task (`Task 1`) has executed nearly six iterations
    of its loop, whereas the task with the slowest loop (`Task 2`) has only made it
    through the first iteration. `Task 3` has executed three iterations of its loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前显示的三个任务相同，只是这次不是理论上的概念化，而是按时间顺序枚举任务循环的每次迭代。因为轮询调度程序为每个任务分配相等的时间片，所以最短的任务（`任务
    1`）几乎执行了其循环的六次迭代，而具有最慢循环的任务（`任务 2`）只完成了第一次迭代。`任务 3` 执行了其循环的三次迭代。
- en: 'An extremely important distinction between a super loop executing the same
    functions versus a round-robin scheduling routine executing them is this: `Task
    3` completed its moderately tight loop before `Task 2`. When the super loop was
    running functions in a serial fashion, `Function 3` wouldn''t even have started
    until `Function 2` had run to completion. So, while the scheduler isn''t providing
    us with true parallelism, each task is getting it''s *fair share* of CPU cycles.
    So, with this scheduling scheme, if a task has a shorter loop, it will execute
    more often than a task with a longer loop.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个超级循环执行相同的功能与一个轮询调度例程执行它们之间有一个极其重要的区别：`任务 3` 在 `任务 2` 完成之前就完成了它相对紧凑的循环。当超级循环以串行方式运行函数时，`函数
    3` 甚至在 `函数 2` 完成之前都不会开始。因此，虽然调度程序没有提供真正的并行性，但每个任务都能获得其应有的CPU周期。因此，在这种调度方案中，如果一个任务的循环较短，它将比循环较长的任务执行得更频繁。
- en: All of this switching does come at a (slight) cost – the scheduler needs to
    be invoked any time there is a context switch. In this example, the tasks are
    not explicitly calling the scheduler to run. In the case of FreeRTOS running on
    an ARM Cortex-M, the scheduler will be called from the SysTick interrupt (more
    details can be found in [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)*, The
    FreeRTOS Scheduler*). A considerable amount of effort is put into making sure
    the scheduler kernel is extremely efficient and takes as little time to run as
    possible. However, the fact remains that it will run at some point and consume
    CPU cycles. On most systems, the small amount of overhead is generally not noticed
    (or significant), but it can become an issue in some systems. For example, if
    a design is on the extreme edge of feasibility because it has extremely tight
    timing requirements and very few spare CPU cycles, the added overhead may not
    be desirable (or completely necessary) if the super loop/interrupt approach has
    been carefully characterized and optimized. However, it is best to avoid this
    type of situation wherever possible, since the likelihood of overlooking a combination
    of interrupt stack-up (or nested conditionals taking longer *every once in a while) *and
    causing the system to miss a deadline is extremely high on even moderately complex
    systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些切换都会带来（轻微的）成本——每当发生上下文切换时，都需要调用调度程序。在这个例子中，任务并没有明确调用调度程序来运行。在FreeRTOS运行在ARM
    Cortex-M上的情况下，调度程序将从SysTick中断中调用（更多细节可以在[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)*，《FreeRTOS调度程序》*中找到）。为了确保调度程序内核非常高效，尽可能减少运行时间，投入了大量的努力。然而，事实仍然是它将运行，并消耗CPU周期。在大多数系统中，这种少量开销通常不会引起注意（或显著），但在某些系统中可能会成为问题。例如，如果一个设计处于可行性的极限边缘，因为它有非常严格的时序要求，并且几乎没有多余的CPU周期，那么如果超级循环/中断方法已经被仔细表征和优化，那么额外的开销可能不是所希望的（或完全必要的）。然而，最好尽可能避免这种情况，因为即使在中等复杂度的系统中，忽略中断堆栈组合（或嵌套条件偶尔需要更长的时间）并导致系统错过截止日期的可能性非常高。
- en: Preemptive-based scheduling
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于抢占的调度
- en: Preemptive scheduling provides a mechanism for ensuring that the system is always
    performing its most important task. A preemptive scheduling algorithm will give
    priority to the most important task, regardless of what else in the system is
    happening – except for interrupts, since they occur *underneath* the scheduler
    and always have a higher priority. This sounds very straightforward – and it is
    – except that there are some details that need to be taken into consideration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 预先调度提供了一种确保系统始终在执行其最重要任务的机制。一个预先调度算法将优先考虑最重要的任务，无论系统中其他部分发生什么情况——除了中断，因为它们发生在调度程序“之下”，并且总是具有更高的优先级。这听起来非常直接——确实如此——但是还有一些细节需要考虑。
- en: 'Let''s take a look at the same three tasks. These three tasks all have the
    same functionality: a simple `while` loop that endlessly increments a volatile
    variable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这三个相同的任务。这三个任务都具有相同的功能：一个简单的`while`循环，不断地增加一个易变的变量。
- en: 'Now, consider the following three scenarios to figure out which of the three
    tasks will get context. The following diagram has the same tasks as previously
    presented with round-robin scheduling. Each of the three tasks has more than enough
    work to do, which will prevent the task from going out of context:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下三种情况，以确定三个任务中哪一个将获得上下文。以下图表具有与之前相同的任务，采用轮询调度。每个任务都有足够多的工作要做，这将防止任务失去上下文：
- en: '![](img/f9f432c6-63c5-4991-8e1b-b43ebe54be13.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f432c6-63c5-4991-8e1b-b43ebe54be13.png)'
- en: So, what happens when three different tasks are set up with three different
    sets of priorities (A, B, and C)?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当设置了三个不同优先级（A、B和C）的三个不同任务时会发生什么呢？
- en: '**A (top left)**: `Task 1` has the highest priority in the system – it gets
    *all* of the processor time! Regardless of how many iterations `Task 1` performs,
    if it is the highest priority task in the system and it has work to do (without
    waiting on anything else in the system), it will be given context and run.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A（左上角）**：`任务1`在系统中具有最高的优先级——它获得了**所有**的处理器时间！无论`任务1`执行多少次迭代，如果它是系统中优先级最高的任务，并且它有工作要做（不需要等待系统中的其他任何东西），它将获得上下文并运行。'
- en: '**B (top right)**: `Task 2` is the highest priority task in the system. Since
    it has more than enough work to do, not needing to wait on anything else in the
    system, `Task 2` will be given context. Since `Task 2` is configured as the highest
    priority in the system, it will execute until it needs to wait on something else
    in the system.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B（右上角）**：`任务2`是系统中优先级最高的任务。由于它有足够多的工作要做，不需要等待系统中的其他任何东西，`任务2`将获得上下文。由于`任务2`被配置为系统中的最高优先级，它将执行，直到它需要等待系统中的其他东西。'
- en: '**C (bottom left)**: `Task 3` is configured as the highest priority task in
    the system. No other tasks run because they are lower priority.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C（左下角）**：`任务3`被配置为系统中优先级最高的任务。没有其他任务运行，因为它们的优先级较低。'
- en: Now, obviously, if you were actually designing a system that required multiple
    tasks to run in parallel, a preemptive scheduler wouldn't be much use if all of
    the tasks in the system required 100% CPU time and didn't need to wait on anything.
    This setup also wouldn't be a great design for a real-time system since it was
    completely overloaded (and ignoring two of the three primary functions the system
    was meant to perform)! The situation presented is referred to as **task starvation**,
    since only the highest priority task in the system is getting CPU time and the
    other tasks are being *starved* of processor time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然，如果你实际上设计了一个需要多个任务并行运行的系统，如果系统中的所有任务都需要100%的CPU时间并且不需要等待任何东西，抢占式调度器就没有什么用处了。这种设置对于实时系统来说也不是一个好的设计，因为它完全超载（并且忽略了系统旨在执行的三项主要功能中的两项）！所描述的情况被称为**任务饥饿**，因为只有系统中优先级最高的任务获得了CPU时间，而其他任务则被**剥夺**了处理器时间。
- en: Another detail worth pointing out is that the scheduler is still running at
    predetermined intervals. No matter what is going on in the system, the scheduler
    will diligently run at its predetermined tick rate.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得指出的是，调度器仍然按照预定的间隔运行。无论系统发生什么，调度器都会勤奋地以预定的滴答速度运行。
- en: There is an exception to this. FreeRTOS has a *tick-less* scheduler mode designed
    for use in extremely low power devices, which prevents the scheduler from running
    on the same predetermined intervals.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个例外。FreeRTOS有一个专为极低功耗设备设计的**无滴答**调度器模式，它防止调度器在相同的预定间隔上运行。
- en: 'A more realistic use case where a preemptive scheduler is used is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了使用抢占式调度器的更实际的使用案例：
- en: '![](img/be80720d-75c8-4919-81b4-ffa20e63c7d6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be80720d-75c8-4919-81b4-ffa20e63c7d6.png)'
- en: In this case, `Task 1` is the highest priority task in the system (it also happens
    to finish executing very quickly) – the only time `Task 1` has context taken from
    it is when the scheduler needs to run; otherwise, it will keep context until it
    doesn't have any additional work to perform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`任务1`是系统中优先级最高的任务（它也恰好执行得非常快）——`任务1`唯一被从上下文中移除的时间是当调度器需要运行时；否则，它将保持上下文直到它没有更多的工作要执行。
- en: '`Task 2` is the next highest priority – you''ll also notice that this task
    is set up to execute once per RTOS scheduler tick (indicated by the downward arrows).
    `Task 3` is the lowest priority task in the system: it only gets context when
    there is nothing else worth doing in the system. There are three main points worth
    looking at in this diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`任务 2` 是下一个最高优先级——你也会注意到这个任务被设置为在 RTOS 调度器滴答时执行一次（由向下箭头表示）。`任务 3` 是系统中的最低优先级任务：它只有在系统中没有其他值得做的事情时才会获得上下文。在这个图中有三个主要点值得注意：'
- en: '**A**: `Task 2` has context. Even though it is interrupted by the scheduler,
    it immediately gets context again after the scheduler has run (because it still
    has work to perform).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**: `任务 2` 有上下文。即使它被调度器中断，但在调度器运行后，它会立即再次获得上下文（因为它仍然有工作要执行）。'
- en: '**B**: `Task 2` has finished its work for iteration 0\. The scheduler has run
    and determined that (since no other tasks in the system are required to run) `Task
    3` could have processor time.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B**: `任务 2` 已经完成了迭代 0 的工作。调度器已经运行并确定（因为系统中没有其他任务需要运行）`任务 3` 可以获得处理器时间。'
- en: '**C**: `Task 2` has started running iteration 4, but `Task 1` now has some
    work to do – even though `Task 2` hasn''t finished the work for that iteration.
    `Task 1` is immediately switched in by the scheduler to perform its higher priority
    work. After `Task 1` is finished with what it needs to do, `Task 2` is switched
    back in to finish iteration 4\. This time, the iteration runs until the next tick
    and `Task 2` runs again (iteration 5). After `Task 2` iteration 5 has completed,
    there is no higher priority work to perform, so the lowest priority task in the
    system (`Task 3`) runs again. It looks as if `Task 3` has finally completed iteration
    0, so it moves on to iteration 1 and chugs along . . .'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**: `任务 2` 已经开始运行第 4 次迭代，但 `任务 1` 现在有一些工作要做——即使 `任务 2` 还未完成该迭代的任务。调度器立即将
    `任务 1` 切换进来执行其更高优先级的工作。在 `任务 1` 完成它需要做的事情后，`任务 2` 被切换回来完成第 4 次迭代。这次，迭代一直运行到下一个滴答，`任务
    2` 再次运行（迭代 5）。在 `任务 2` 完成迭代 5 后，没有更高优先级的工作要做，因此系统中的最低优先级任务（`任务 3`）再次运行。看起来 `任务
    3` 终于完成了迭代 0，因此它继续到迭代 1 并继续前进……'
- en: Hopefully you're still with me! If not, that's OK, given that this is a very
    abstract example. The key takeaway is that the highest priority task in the system
    takes precedence.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你还在这里！如果不在，那也行，鉴于这是一个非常抽象的例子。关键要点是系统中最高优先级的任务具有优先权。
- en: This is only a brief introduction to the relevant scheduling concepts covered
    in detail in [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),* The FreeRTOS
    Scheduler*, to put the concept of tasks into context, showing the different ways
    in which they can be run and scheduled. Many more details and strategies for achieving
    desired system performance are discussed there, along with real-world examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对第 7 章[2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml]中详细介绍的相关的调度概念的简要介绍，*《FreeRTOS
    调度器》*，以将任务的概念置于上下文中，展示它们可以以不同的方式运行和调度。那里讨论了许多更多细节和实现所需系统性能的策略，以及实际世界的例子。
- en: RTOS tasks versus super loops – pros and cons
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS 任务与超级循环——优点和缺点
- en: Super loops are great for simple systems with limited responsibilities. If a
    system is simple enough, they can provide very low jitter in response to an event,
    but only if the loop is tight enough. As a system grows more complex and acquires
    more responsibility, polling rates decrease. This decreased polling rate causes
    much larger jitter in response to events. Interrupts can be introduced into the
    system to combat the increased jitter. As a super loop-based system becomes more
    complex, it becomes harder to track and guarantee responsiveness to events.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 超级循环非常适合具有有限责任的简单系统。如果一个系统足够简单，它们可以提供非常低的响应事件抖动，但前提是循环足够紧凑。随着系统变得更加复杂并承担更多责任，轮询率降低。这种降低的轮询率会导致对事件响应的更大抖动。可以通过引入中断来对抗增加的抖动。随着基于超级循环的系统变得更加复杂，跟踪和保证对事件的响应变得更加困难。
- en: An RTOS becomes very valuable with more complex systems that have not only time-consuming
    tasks, but also require good responsiveness to external events. With an RTOS,
    an increase in system complexity, ROM, RAM, and initial setup time is the trade-off
    for a more easily understood system, which can more easily guarantee responsiveness
    to external events in a timely manner.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有不仅耗时任务，而且需要对外部事件有良好响应的更复杂系统中，RTOS 非常有价值。使用 RTOS，系统复杂性的增加、ROM、RAM 和初始设置时间的增加是换取一个更容易理解的系统，该系统可以更容易地及时保证对外部事件的响应。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered quite a few concepts in this chapter in relation to super loops
    and tasks. At this point, you should have a good understanding of how super loops
    can be combined with interrupts and DMA to provide parallel processing to keep
    a system responsive, without the use of an RTOS. We introduced task-based architectures
    at a theoretical level and the two main types of scheduling you'll encounter when
    using FreeRTOS (round-robin and preemptive). You also had a very brief glimpse
    at how a preemptive scheduler schedules tasks of different priorities. All of
    these concepts are important to grasp, so feel free to refer back to these simplistic
    examples as we move forward and discuss more advanced topics.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涉及了许多与超级循环和任务相关的概念。到现在为止，你应该对如何将超级循环与中断和DMA结合使用以提供并行处理，从而保持系统响应性，而不使用RTOS有很好的理解。我们在理论上介绍了基于任务的架构，以及在使用FreeRTOS时你将遇到的两种主要调度类型（轮询和抢占）。你还非常简要地看到了抢占式调度器如何调度不同优先级的任务。所有这些概念都很重要，所以在我们继续前进并讨论更高级的主题时，请随时参考这些简单的例子。
- en: In the next chapter, you'll be introduced to the various inter-task communication
    mechanisms that will cause context switches like the ones covered in this chapter.
    As we progress through the book and move onto interrupt and task communication
    mechanisms, many real-world examples will be discussed and we'll take a deep dive
    into the code that you'll need to write in order to create reliable real-time
    systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到各种任务间通信机制，这些机制将导致与本章中覆盖的类似上下文切换。随着我们通过本书并转向中断和任务通信机制，我们将讨论许多现实世界的例子，并深入探讨你需要编写的代码，以创建可靠的实时系统。
- en: Questions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结的时候，这里有一份问题列表，供你测试你对本章内容的了解。你将在附录的*评估*部分找到答案：
- en: What is a super loop?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是超级循环？
- en: An infinite `while` loop
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无限`while`循环
- en: A loop that oversees all function calls in an embedded system
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个监控嵌入式系统中所有函数调用的循环
- en: Both of the preceding options
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述两种选项
- en: RTOS tasks should *always *be preferred over super loops.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTOS任务应该*始终*优先于超级循环。
- en: 'True'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Name a drawback to complex super loops.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举复杂超级循环的一个缺点。
- en: How can the responsiveness of a super loop-based application be improved?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何提高基于超级循环的应用的响应性？
- en: List two ways in which super loops differ from RTOS tasks.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举两种超级循环与RTOS任务不同的方式。
- en: What features do RTOS tasks possess to help ensure that the most time-critical
    task gets CPU time before less time-critical tasks?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTOS任务具有哪些特性，可以帮助确保最关键的任务在时间不那么关键的任务之前获得CPU时间？
- en: Time slicing
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间切片
- en: Prioritization
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级
- en: Round-robin scheduling
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询调度
- en: What type of scheduler attempts to execute the most critical tasks before less
    critical tasks?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的调度器试图在执行不那么关键的任务之前先执行最关键的任务？
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If interrupts and DMA are new to you, here are two resources that describe
    their use (relative to MCUs) fairly well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于中断和DMA还不太熟悉，这里有两个资源很好地描述了它们的使用（相对于MCU）：
- en: 'For interrupts: [https://www.renesas.com/eu/en/support/technical-resources/engineer-school/mcu-programming-peripherals-04-interrupts.html](https://www.renesas.com/eu/en/support/technical-resources/engineer-school/mcu-programming-peripherals-04-interrupts.html)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于中断：[https://www.renesas.com/eu/en/support/technical-resources/engineer-school/mcu-programming-peripherals-04-interrupts.html](https://www.renesas.com/eu/en/support/technical-resources/engineer-school/mcu-programming-peripherals-04-interrupts.html)
- en: 'STM application note AN4031 – Using DMA on the STM32F7: [https://www.st.com/content/ccc/resource/technical/document/application_note/27/46/7c/ea/2d/91/40/a9/DM00046011.pdf/files/DM00046011.pdf/jcr:content/translations/en.DM00046011.pdf](https://www.st.com/content/ccc/resource/technical/document/application_note/27/46/7c/ea/2d/91/40/a9/DM00046011.pdf/files/DM00046011.pdf/jcr:content/translations/en.DM00046011.pdf)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'STM应用笔记AN4031 – 在STM32F7上使用DMA: [https://www.st.com/content/ccc/resource/technical/document/application_note/27/46/7c/ea/2d/91/40/a9/DM00046011.pdf/files/DM00046011.pdf/jcr:content/translations/en.DM00046011.pdf](https://www.st.com/content/ccc/resource/technical/document/application_note/27/46/7c/ea/2d/91/40/a9/DM00046011.pdf/files/DM00046011.pdf/jcr:content/translations/en.DM00046011.pdf)'
