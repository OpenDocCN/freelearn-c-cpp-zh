- en: DC Motors and Motor Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this book, all of the projects have been stationary projects. By
    stationary projects I mean the projects had no way to move on their own. In this
    chapter, we will look at how we can add DC motors to any project, giving it the
    ability to move on its own. When using DC motors, I would recommend using a motor
    controller to control them. Motor controllers enable us to very easily connect
    an external power supply to the motor and control the direction and speed of the
    motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How a brushed DC motor works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How an H-bridge works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the L298 and L293D motor controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DC motor is a class of rotary electrical device that converts electrical energy
    into physical motion. There are numerous types of DC motors; however, in this
    chapter, we will look at one specific type, which is the **brushed DC motor**.
  prefs: []
  type: TYPE_NORMAL
- en: Brushed DC motors are used in a wide variety of applications, ranging from toys
    and robotics to powered windows and power tools. Some advantages of brushed DC
    motors are their initial low cost, simple control, and low-speed torque. The disadvantages
    of these motors are their high maintenance costs and low lifespan in high-intensity
    environments. For the prototyping and robotic projects that we normally do with
    the Arduino, the disadvantages of the brushed DC motors are normally not a concern.
  prefs: []
  type: TYPE_NORMAL
- en: At the center of a brushed DC motor is a spinning armature, which contains an
    electromagnet. To the outside of the spinning armature is a permanent, stationary
    magnet. When the electromagnet in the armature is powered, a magnetic field is
    created that attracts and repels the permanent stationary magnets. This causes
    the armature to begin spinning.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the armature spinning, the polarity of the electromagnet needs to be
    reversed. To do this a segmented copper sleeve called a **commutator** is used, which
    resides on the axle of the motor. As the motor turns, brushes slide over the commutator,
    coming in to contact with different parts of the commutator, causing the polarity
    of the magnet to switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the parts of the brushed DC motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c071ff2-14a0-4960-bf0b-d20fe10d6f18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Brushed DC motors come in numerous shapes and sizes. Some of these motors have
    built-in gearboxes that can change the torque and speed that the motor will spin
    at. The following photograph shows some examples of brushed DC motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f38db2a-1e24-463b-bc03-3725bf6ddc0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Powering a DC motor directly from the Arduino for anything other than demonstration
    purposes, is usually not a good idea because the voltage and current provided
    from the pin headers are pretty limited. We can use a motor controller to control
    the direction and speed of a DC motor from the Arduino while still providing an
    external power source to power it. In this chapter, we will look at how we can
    use the L298 dual H-bridge motor driver, shown in the following photograph, and
    also how to use the L293D chip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b123636d-dada-4d2c-badb-a4cef320a8e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The L298 motor driver enables us to control the direction and speed of two
    motors. This driver allows us to control motors from 5V all the way up to 35V
    with a maximum current of 2A. If the supply voltage is 12V or less, we can also
    use the 5V output to power the Arduino. The L298 motor driver has several inputs,
    outputs and power connectors that are labeled. These inputs from left to right
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ENA**: Enables motor A and controls the speed of the motor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IN1 and IN2**: Controls the direction of motor A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IN3 and IN4**: Controls the direction of motor B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENB**: Enables motor B and controls the speed of the motor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ENA and ENB normally have jumpers across the pins. In order to control brushed
    DC motors, we will need to remove these jumpers and connect the pin to a PWM port.
    The outputs are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUT1 and OUT2**: Output power to motor A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OUT3 and OUT4**: Output power to motor B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The power inputs, from left to right, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vmotor**: Power from an external source that will be used to power the motors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Ground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vout**: 5V output that can be used to power the Arduino'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are building a project where we have limited space, rather than using
    a motor controller such as the L298 dual H-bridge motor driver, we can use an
    integrated chip such as the **L293D H-bridge IC**. The L293D chip can drive two
    motors, similar, to the L298 motor driver, and can power motors up to 35V with
    600mA of steady current with a maximum of 1.2A. The following diagram shows the
    pinout for the L293D IC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4aebe63-a6fb-4da4-8a6e-3e715188a2d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the L298 motor controller and the L293D chip are H-bridges. Let''s take
    a quick look at how an H-bridge works. An H-bridge is an electric circuit that
    allows us to apply a voltage to our motors in either direction allowing the motor
    to run forwards or backwards. The term H-bridge comes from the typical graphic
    representation of the circuit, which looks like a capital H. The following diagram
    shows how an H-bridge works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4985c326-ff2e-4764-8d90-173757e2c94f.png)'
  prefs: []
  type: TYPE_IMG
- en: An H-bridge is usually built with four solid state switches. As we see in the
    preceding image, when switches 1 and 3 (**I1** and **I3**) are open and switches
    2 and 4 (**I2** and **I4**) are closed, the right side of the motor is connected
    to the power supply while the left side is connected to ground, spinning the motor
    in one direction. If switches 1 and 3 (**I1** and **I3**) are closed and switches
    2 and 4 (**I2** and **I4**) are open, then the left side of the motor is connected
    to the power supply while the right side is connected to ground, spinning the
    motor in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the parts that we will need for our projects in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will need the following components.
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One L298 motor driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One L293D H-bridge chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two brushed DC motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One external 12V battery (or other external DC power source such as a 9V battery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create two projects. The first project will use the
    L298 motor driver to control a single motor and the second project will use the
    L293D chip to control a single motor. Here is the circuit diagram for the L298
    motor driver project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/885bf7d0-5c9a-411f-a751-385e84cbc5cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we explain this diagram, let''s look at the circuit diagram for the
    L293D chip circuit as well because there are a lot of similarities between these
    two diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0c8c36d-14ce-4cc5-90b5-e201c3690dbd.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to note with these two diagrams is the circuits contain a common
    ground. What this means is the ground connectors on the Arduino, battery and the
    motor controllers (both the L298 and L293D) are all connected together. In projects
    like these, which include multiple power sources, we must have a common ground
    between all devices and power sources.
  prefs: []
  type: TYPE_NORMAL
- en: In both circuits, the PWM out of 10 pins on the Arduino are connected to the
    enable pin on the motor controller. Also, in both circuits, the digital 2 and
    3 pins are connected to the IN1 and IN2 pins on the motor controllers. This enables
    us to use the same code for both projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the code for these projects.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to control the motors only needs to use the standard `digitalWrite()`
    and `analogWrite()` functions from the Arduino standard library, so no external
    libraries are needed for this code. Therefore, our code will start off by defining
    the pins on the Arduino that are connected to the motor controllers. This following
    code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will need to configure the pins for output in the `setup()` function
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to power the motors. Let''s put the following code into the
    `loop()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `loop()` function starts off by using the `digitalWrite()` function to set
    input `1` on the motor controller to `HIGH` and input `2` to `LOW`. The `analogWrite()`
    function is then used to create a duty cycle of 250 to the enable pin on the motor
    controller. Remember the PWM pins have a maximum duty cycle of 255; therefore,
    once the `analogWrite()` function is performed, the motor should start spinning
    at almost full speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a brushed DC motor to spin, one input must be HIGH, and the other
    must be LOW. If the inputs are both HIGH, both LOW or the duty cycle on the enable
    pin is 0, the motor will not spin. The following chart shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| IN1 | IN2 | Enable Duty Cycle | Result |'
  prefs: []
  type: TYPE_TB
- en: '| HIGH | LOW | >0 | Motor spins on direction |'
  prefs: []
  type: TYPE_TB
- en: '| LOW | HIGH | >0 | The motor spins other direction |'
  prefs: []
  type: TYPE_TB
- en: '| HIGH | HIGH |  | Motor stopped |'
  prefs: []
  type: TYPE_TB
- en: '| LOW | LOW |  | Motor stopped |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 0 | Motor stopped |'
  prefs: []
  type: TYPE_TB
- en: After the `analogWrite()` function is called, the `delay` function is used to
    pause the execution of the application for two seconds to let the motor run. The
    `analogWrite()` function is then called again to set the duty cycle to 0, which
    will stop the motor from spinning and delay for one second to give the motor a
    chance to stop.
  prefs: []
  type: TYPE_NORMAL
- en: The `digitalWrite()` functions are then used to input 1 pin `LOW` and the input
    2 pin `HIGH` which is the opposite of how they were originally set which will
    spin the motor in the opposite direction. The `analogWrite()` function is then
    called to set the duty cycle to 125, which will start spinning the motor at half
    speed. The `delay` function is then used to pause the execution of the application
    for two seconds, and then we stop the motor again.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When this code is run, the motor should spin in one direction for two seconds,
    stop for one second, spin in the other direction for two seconds, stop for one
    second and then start over.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter's challenge, try to add second motors to both projects and
    then change the code so both motors will spin at the same time. You could also
    try to wire the motors so they will spin in the same direction if you apply a
    `HIGH` value to the IN1 and IN3 pins with a `LOW` value to the IN2 and IN4 pins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of how a brushed DC motor works and how
    we can use both the L298 motor driver and the L293D chip to control a brushed
    DC motor. We also learned how an H-bridge works.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a different kind of DC motor. This motor
    is called a servo motor and is used in projects where precise positioning is needed,
    such as with robotic arms.
  prefs: []
  type: TYPE_NORMAL
