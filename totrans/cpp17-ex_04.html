<html><head></head><body>
        

                            
                    <h1 class="header-title">Library Management System with Pointers</h1>
                
            
            
                
<p>In this chapter, we will continue to study a system for the management of a library. Similar to <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>, we have three classes—<kbd>Book</kbd>, <kbd>Customer</kbd>, and <kbd>Library</kbd>. However, there is one large difference: we do not work with identity numbers. Instead, we work with pointers; each <kbd>Book</kbd> object holds a pointer to the customer (an object of the <kbd>Customer</kbd> class) that has borrowed the book as well as a list of pointers to the customers that have reserved the book. In the same way, each customer holds sets of pointers for the books (objects of the <kbd>Book</kbd> class) they have borrowed and reserved.</p>
<p>However, this approach gives rise to a problem; we cannot store the values of pointers directly in the file. Instead, when we save the file we need to convert from pointers to indexes in the book and customer lists, and when we load the file we need to transform the indexes back to pointers. This process is called <strong>marshmallowing</strong>.</p>
<p>In this chapter, we are going to dive deeper into the following topics:</p>
<ul>
<li>Just as in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>, we will work with classes for books and customers that constitute a small database. However, in this chapter, we will work directly with pointers instead of integer numbers.</li>
<li>As we work with pointers instead of integer numbers, the file handling becomes more complicated. We need to perform a process called marshmallowing.</li>
<li>Finally, we will work with the generic standard C++ classes, <kbd>set</kbd> and <kbd>list</kbd>. However, in this chapter they hold pointers to book and customer objects instead of objects.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Book class</h1>
                
            
            
                
<p>Similar to the system of the previous chapter, we have three classes: <kbd>Book</kbd>, <kbd>Customer</kbd>, and <kbd>Library</kbd>. The <kbd>Book</kbd> class keeps track of a book, where each book has an author and a title. The <kbd>Customer</kbd> class keeps track of a customer, where each customer has a name and an address. The <kbd>Library</kbd> class keeps track of the library operations, such as borrowing, returning, and reserving. Finally, the <kbd>main</kbd> function simply creates an object of the <kbd>Library</kbd> class.</p>
<p>The <kbd>Book</kbd> class is similar to the <kbd>Book</kbd> class of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. The only real difference is that there are no identity numbers, only pointers.</p>
<p><strong>Book.h:</strong></p>
<pre>    class Customer; 
 <br/>    class Book { 
      public: 
      Book(); 
      Book(const string&amp; author, const string&amp; title); 
 
      const string&amp; author() const { return m_author; } 
      const string&amp; title() const { return m_title; } 
    
      void read(ifstream&amp; inStream); 
      void write(ofstream&amp; outStream) const; 
 
      int reserveBook(Customer* customerPtr); 
      void removeReservation(Customer* customerPtr); 
      void returnBook(); </pre>
<p>We do not have a method returning the identity number of the book, since the books in this chapter do not use identity numbers.</p>
<p>The <kbd>borrowedPtr</kbd> method returns the address of the customer who has borrowed the book, or <kbd>nullptr</kbd> if the book is not borrowed at the moment. It comes in two versions, where the first version returns a reference to a pointer to a <kbd>Customer</kbd> object. In that way, we can assign a new value of the pointer to the customer. The second version is constant, which means that we can call it on constant objects:</p>
<pre>    Customer*&amp; borrowerPtr() { return m_borrowerPtr; } 
    const Customer* borrowerPtr() const { return m_borrowerPtr; } </pre>
<p>Note that we do not have a <kbd>borrowed</kbd> method in this chapter. We do not need it since <kbd>borrowerPtr</kbd> returns <kbd>nullptr</kbd> if the book is not borrowed at the moment.</p>
<p>In this chapter, <kbd>reservationPtrList</kbd> returns a list of customer pointers instead of integer values. It comes in two versions, where the first version returns a reference to the list. In that way, we can add and remove pointers from the list. The second version is constant and returns a constant list, which means it can be called on constant <kbd>Book</kbd> objects and returns a list that cannot be changed:</p>
<pre>    list&lt;Customer*&gt;&amp; reservationPtrList() 
                     { return m_reservationPtrList; } 
    const list&lt;Customer*&gt; reservationPtrList() const 
                          { return m_reservationPtrList; } </pre>
<p>The output stream operator works in the same way as in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>    friend ostream&amp; operator&lt;&lt;(ostream&amp; outStream, 
          const Book&amp; book); </pre>
<p>The <kbd>m_author</kbd> and <kbd>m_title</kbd> fields are strings similar to <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>    private: 
      string m_author, m_title; </pre>
<p>However, we have omitted the <kbd>m_bookId</kbd> field, since we do not use identity numbers in this chapter. We have also replaced the <kbd>m_borrowedId</kbd> and <kbd>m_customerId</kbd> fields with <kbd>m_borrowerPtr</kbd>, which is initialized to <kbd>nullptr</kbd> since the book is not borrowed from the beginning:</p>
<pre>    Customer* m_borrowerPtr = nullptr; </pre>
<p>The <kbd>m_reservationPtrList</kbd> field holds a list of pointers to the customers that have reserved the book, rather than a list of integer identity numbers of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Manageme</em><em>nt System</em>:</p>
<pre>    list&lt;Customer*&gt; m_reservationPtrList; 
      }; </pre>
<p><strong>Book.cpp:</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    #include &lt;Algorithm&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" </pre>
<p>The default constructor is similar to the constructor of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>    Book::Book() { 
      // Empty. 
    } </pre>
<p>The second constructor is also similar to the constructor of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. However, there is no <kbd>m_bookId</kbd> field to initialize:</p>
<pre>    Book::Book(const string&amp; author, const string&amp; title) 
    :m_author(author), 
    m_title(title) { 
      // Empty. 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading and writing the book</h1>
                
            
            
                
<p>The <kbd>read</kbd> and <kbd>write</kbd> methods have been shortened in this chapter. They only read and write the author and title of the book. The potential loan and reservation lists are read and written by the <kbd>save</kbd> and <kbd>write</kbd> methods of the <kbd>Library</kbd> class:</p>
<pre>    void Book::read(ifstream&amp; inStream) { 
      getline(inStream, m_author); 
      getline(inStream, m_title); 
    } 
 
    void Book::write(ofstream&amp; outStream) const { 
      outStream &lt;&lt; m_author &lt;&lt; endl; 
      outStream &lt;&lt; m_title &lt;&lt; endl; 
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing and reserving the book</h1>
                
            
            
                
<p>When a customer reserves a book, the pointer to the <kbd>Customer</kbd> object is added to the reservation pointer list of the book. The size of the list is returned for the customer to be notified of their position in the reservation list:</p>
<pre>    int Book::reserveBook(Customer* borrowerPtr) { 
      m_reservationPtrList.push_back(borrowerPtr); 
      return m_reservationPtrList.size(); 
    } </pre>
<p>When a customer returns a book, we simply set <kbd>m_borrowerPtr</kbd> to <kbd>nullptr</kbd>, which indicates that the book is no longer borrowed:</p>
<pre>    void Book::returnBook() { 
      m_borrowerPtr = nullptr; 
    } </pre>
<p>The <kbd>removeReservation</kbd> method simply removes the customer pointer from the reservation list:</p>
<pre>    void Book::removeReservation(Customer* customerPtr) { 
      m_reservationPtrList.remove(customerPtr); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the book</h1>
                
            
            
                
<p>The output stream operator writes the title and author, the customer that has borrowed the book (if any), and the customers that have reserved the book (if any):</p>
<pre>    ostream&amp; operator&lt;&lt;(ostream&amp; outStream, const Book&amp; book) { 
     outStream &lt;&lt; """ &lt;&lt; book.m_title &lt;&lt; "" by " &lt;&lt; book.m_author; </pre>
<p>If the book is borrowed, we write the borrower to the stream:</p>
<pre>    if (book.m_borrowerPtr != nullptr) { 
        outStream &lt;&lt; endl &lt;&lt; "  Borrowed by: " 
              &lt;&lt; book.m_borrowerPtr-&gt;name() &lt;&lt; "."; 
    } </pre>
<p>If the reservation list of the book is not empty, we iterate through it, and for each reservation, we write the customer:</p>
<pre>    if (!book.m_reservationPtrList.empty()) { 
      outStream &lt;&lt; endl &lt;&lt; "  Reserved by: "; 
     
      bool first = true; 
      for (Customer* customerPtr : book.m_reservationPtrList) { 
        outStream &lt;&lt; (first ? "" : ",") &lt;&lt; customerPtr-&gt;name(); 
        first = false; 
      } 
 
      outStream &lt;&lt; "."; 
    } 
 
    return outStream; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Customer class</h1>
                
            
            
                
<p>The <kbd>Customer</kbd> class of this chapter is similar to the <kbd>Customer</kbd> class of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. Again, in this case, the difference is that we work with pointers instead of integer identity numbers.</p>
<p><strong>Customer.h:</strong></p>
<pre style="padding-left: 30px">class Customer { 
  public: 
    Customer(); 
    Customer(const string&amp; name, const string&amp; address); 
 
    const string&amp; name() const { return m_name; } 
    const string&amp; address() const { return m_address; } 
 
    void read(ifstream&amp; inStream); 
    void write(ofstream&amp; outStream) const; </pre>
<p>The <kbd>borrowBook</kbd>, <kbd>returnBook</kbd>, <kbd>reserveBook</kbd>, and <kbd>unreserveBook</kbd> take a pointer to a <kbd>Book</kbd> object as the parameter:</p>
<pre>    void borrowBook(Book* bookPtr); 
    void returnBook(Book* bookPtr); 
    void reserveBook(Book* bookPtr); 
    void unreserveBook(Book* bookPtr); </pre>
<p>The <kbd>loadPtrSet</kbd> and <kbd>reservationPtrSet</kbd> methods return sets of <kbd>Book</kbd> pointers, rather than sets of integer identity numbers:</p>
<pre>    set&lt;Book*&gt;&amp; loanPtrSet() { return m_loanPtrSet; } 
    const set&lt;Book*&gt; loanPtrSet() const { return m_loanPtrSet; } 
 
    set&lt;Book*&gt;&amp; reservationPtrSet(){ return m_reservationPtrSet; } 
    const set&lt;Book*&gt; reservationPtrSet() const 
                     { return m_reservationPtrSet; } </pre>
<p>The output stream operator is unchanged, compared to <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Managemen</em><em>t System</em>:</p>
<pre>    friend ostream&amp; operator&lt;&lt;(ostream&amp; outStream, 
                               const Customer&amp; customer); </pre>
<p>The <kbd>m_name</kbd> and <kbd>m_address</kbd> fields store the name and address of the customer, just as in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Mana</em><em>gement System</em>:</p>
<pre style="padding-left: 60px">  private: 
    string m_name, m_address; </pre>
<p>The <kbd>m_loanPtrSet</kbd> and <kbd>m_reservationPtrSet</kbd> fields hold pointers to <kbd>Book</kbd> objects, rather than integer identity numbers:</p>
<pre>    set&lt;Book*&gt; m_loanPtrSet, m_reservationPtrSet; 
      }; </pre>
<p><strong>Customer.cpp:</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" </pre>
<p>The constructors are similar to the constructors of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. The first constructor does nothing and is called when the customer list is loaded from a file:</p>
<pre>    Customer::Customer() { 
     // Empty. 
    } </pre>
<p>The second constructor initializes the name and address of the customer. However, compared to the constructor of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>, there is no <kbd>m_customerId</kbd> field to initialize:</p>
<pre>    Customer::Customer(const string&amp; name, const string&amp; address) 
    :m_name(name), 
    m_address(address) { 
       // Empty. 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading and writing the customer</h1>
                
            
            
                
<p>Similar to the preceding <kbd>Book</kbd> case, the <kbd>read</kbd> and <kbd>write</kbd> methods have been shortened. They only read and write the name and address. The loan and reservation sets are read and written in the <kbd>Library</kbd> class, shown as follows:</p>
<pre>    void Customer::read(ifstream&amp; inStream) { 
      getline(inStream, m_name); 
      getline(inStream, m_address); 
    } 
 
    void Customer::write(ofstream&amp; outStream) const { 
     outStream &lt;&lt; m_name &lt;&lt; endl; 
     outStream &lt;&lt; m_address &lt;&lt; endl; 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing and reserving a book</h1>
                
            
            
                
<p>The <kbd>borrowBook</kbd> method adds the book pointer to the loan set and removes it from the reservation set in case it was reserved:</p>
<pre>    void Customer::borrowBook(Book* bookPtr) { 
      m_loanPtrSet.insert(bookPtr); 
      m_reservationPtrSet.erase(bookPtr); 
    } </pre>
<p>The <kbd>reserveBook</kbd> method simply adds the book pointer to the reservation list, and <kbd>returnBook</kbd> and <kbd>unreserveBook</kbd> remove the book pointer from the loan and reservation sets:</p>
<pre>    void Customer::reserveBook(Book* bookPtr) { 
      m_reservationPtrSet.insert(bookPtr); 
    } 
 
    void Customer::returnBook(Book* bookPtr) { 
      m_loanPtrSet.erase(bookPtr); 
    } 
  
    void Customer::unreserveBook(Book* bookPtr) { 
      m_reservationPtrSet.erase(bookPtr); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the customer</h1>
                
            
            
                
<p>The output stream operator works in the same way as in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. It writes the name and address of the customer, as well as the sets of borrowed and reserved books (if any):</p>
<pre>    ostream&amp; operator&lt;&lt;(ostream&amp; outStream, const Customer&amp; customer){ 
      outStream &lt;&lt; customer.m_name &lt;&lt; ", " 
      &lt;&lt; customer.m_address &lt;&lt; "."; </pre>
<p>If the loan list of the customer is not empty, we iterate through it, and for each loan, we write the book:</p>
<pre>    if (!customer.m_loanPtrSet.empty()) { 
      outStream &lt;&lt; endl &lt;&lt; "  Borrowed books: "; 
 
      bool first = true; 
      for (const Book* bookPtr : customer.m_loanPtrSet) { 
        outStream &lt;&lt; (first ? "" : ", ") &lt;&lt; bookPtr-&gt;author(); 
        first = false; 
      } 
    } </pre>
<p>In the same way, if the reservation list of the customer is not empty, we iterate through it, and for each reservation, we write the book:</p>
<pre>    if (!customer.m_reservationPtrSet.empty()) { 
      outStream &lt;&lt; endl &lt;&lt; "  Reserved books: "; 
 
      bool first = true; 
      for (Book* bookPtr : customer.m_reservationPtrSet) { 
        outStream &lt;&lt; (first ? "" : ", ") &lt;&lt; bookPtr-&gt;author(); 
        first = false; 
      } 
    } 
 
    return outStream;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Library class</h1>
                
            
            
                
<p>The <kbd>Library</kbd> class is quite similar to its counterpart in  <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. However, we have added lookup <kbd>methods</kbd> to transform between pointers and list indexes when saving and loading the library information to a file:</p>
<p><strong>Library.h:</strong></p>
<pre>class Library { 
  public: 
    Library(); </pre>
<p>The destructor deallocates all the dynamically allocated memory of this application:</p>
<pre>    ~Library(); 
 
    private: 
      static string s_binaryPath; </pre>
<p>The <kbd>lookupBook</kbd> and <kbd>lookupCustomer</kbd> methods return pointers to <kbd>Book</kbd> and <kbd>Customer</kbd> objects. If the book or customer does not exist, <kbd>nullptr</kbd> is returned:</p>
<pre>    Book* lookupBook(const string&amp; author, const string&amp; title); 
    Customer* lookupCustomer(const string&amp; name, 
                             const string&amp; address); 
 
    void addBook(); 
    void deleteBook(); 
    void listBooks(); 
    void addCustomer(); 
    void deleteCustomer(); 
    void listCustomers(); 
    void borrowBook(); 
    void reserveBook(); 
    void returnBook(); </pre>
<p>The <kbd>lookupBookIndex</kbd> and <kbd>lookupCustomerIndex</kbd> methods take a pointer, search the book and customer lists after the object pointed at, and return its index in the lists:</p>
<pre>    int lookupBookIndex(const Book* bookPtr); 
    int lookupCustomerIndex(const Customer* customerPtr);</pre>
<p>The <kbd>lookupBookPtr</kbd> and <kbd>lookupCustomerPtr</kbd> methods take an index and return a pointer to the object at the position in the book and customer lists:</p>
<pre>    Book* lookupBookPtr(int bookIndex); 
    Customer* lookupCustomerPtr(int customerIndex); </pre>
<p>The <kbd>save</kbd> and <kbd>write</kbd> methods save and load the library information from a file. However, they are more complicated than their counterparts in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>    void save(); 
    void load(); </pre>
<p>The <kbd>m_bookPtrList</kbd> and <kbd>m_customerPtrList</kbd> fields hold pointers to <kbd>Book</kbd> and <kbd>Customer</kbd> objects, rather than the objects themselves, as in  <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=47&amp;action=edit#post_43" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>      list&lt;Book*&gt; m_bookPtrList; 
      list&lt;Customer*&gt; m_customerPtrList; 
      }; </pre>
<p><strong>Library.cpp:</strong></p>
<pre>   #include &lt;Set&gt; 
   #include &lt;Map&gt; 
   #include &lt;List&gt; 
   #include &lt;String&gt; 
   #include &lt;FStream&gt; 
   #include &lt;IOStream&gt; 
   #include &lt;CAssert&gt; 
   using namespace std; 
 
   #include "Book.h" 
   #include "Customer.h" 
   #include "Library.h" 
 
   string Library::s_binaryPath("C:\Users\Stefan\Library.binary"); </pre>
<p>The constructor is identical to the constructor of  <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=47&amp;action=edit#post_43" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>:</p>
<pre>    Library::Library() { 
      load(); 
 
      bool quit = false; 
      while (!quit) { 
        cout &lt;&lt; "1. Add Book" &lt;&lt; endl 
          &lt;&lt; "2. Delete Book" &lt;&lt; endl 
          &lt;&lt; "3. List Books" &lt;&lt; endl 
          &lt;&lt; "4. Add Customer" &lt;&lt; endl 
          &lt;&lt; "5. Delete Customer" &lt;&lt; endl 
          &lt;&lt; "6. List Customers" &lt;&lt; endl 
          &lt;&lt; "7. Borrow Book" &lt;&lt; endl 
          &lt;&lt; "8. Reserve Book" &lt;&lt; endl 
          &lt;&lt; "9. Return Book" &lt;&lt; endl 
          &lt;&lt; "0. Quit" &lt;&lt; endl 
          &lt;&lt; ": "; 
 
        int choice; 
        cin &gt;&gt; choice; 
        cout &lt;&lt; endl; 
 
        switch (choice) { 
          case 1: 
          addBook(); 
          break; 
 
          case 2: 
          deleteBook(); 
          break; 
 
          case 3: 
          listBooks(); 
          break; 
 
          case 4: 
          addCustomer(); 
          break; 
 
          case 5: 
          deleteCustomer(); 
          break; 
 
          case 6: 
          listCustomers(); 
          break; 
 
          case 7: 
          borrowBook(); 
          break; 
 
          case 8: 
          reserveBook(); 
          break; 
 
          case 9: 
          returnBook(); 
          break; 
 
          case 0: 
          quit = true; 
          break; 
        } 
 
       cout &lt;&lt; endl; 
     } 
 
    save(); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Looking up books and customers</h1>
                
            
            
                
<p>The <kbd>lookupBook</kbd> method of this chapter searches for the <kbd>Book</kbd> object with the author and title, in a way similar to <a href="https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=47&amp;action=edit#post_43" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. However, if it finds a <kbd>Book</kbd> object that matches the author and title, it does not copy the information to a given object. Instead, it simply returns a pointer to the object. If it does not find the <kbd>Book</kbd> object, <kbd>nullptr</kbd> is returned:</p>
<pre>    Book* Library::lookupBook(const string&amp; author, 
                          const string&amp; title) { 
    for (Book* bookPtr : m_bookPtrList) { 
      if ((bookPtr-&gt;author() == author) &amp;&amp; 
         (bookPtr-&gt;title() == title)) { 
        return bookPtr; 
      } 
    } 
 
    return nullptr; 
   } </pre>
<p>In the same way, <kbd>lookupCustomer</kbd> tries to find a <kbd>Customer</kbd> object that matches the name and address. If it finds the object, its pointer is returned. If it does not find it, <kbd>nullptr</kbd> is returned:</p>
<pre>    Customer* Library::lookupCustomer(const string&amp; name, 
         const string&amp; address) { 
    for (Customer* customerPtr : m_customerPtrList) { 
      if ((customerPtr-&gt;name() == name) &amp;&amp; 
         (customerPtr-&gt;address() == address)) { 
         return customerPtr; 
      } 
    } 
    return nullptr; </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a book</h1>
                
            
            
                
<p>The <kbd>addBook</kbd> method prompts the user for the author and the title:</p>
<pre>    void Library::addBook() { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
     string title; 
     cout &lt;&lt; "Title: "; 
     cin &gt;&gt; title; </pre>
<p>When checking if the book already exists, we call <kbd>lookupBook</kbd>. If the book exists, a pointer to the <kbd>Book</kbd> object is returned. If the book does not exist, <kbd>nullptr</kbd> is returned. Therefore, we test whether the return value does not equal <kbd>nullptr</kbd>. If it does not equal <kbd>nullptr</kbd>, the book already exists and an error message is displayed:</p>
<pre>      if (lookupBook(author, title) != nullptr) { 
        cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " 
          &lt;&lt; author &lt;&lt; " already exists." &lt;&lt; endl; 
        return; 
      } </pre>
<p>When adding the book, we dynamically create a new <kbd>Book</kbd> object with the <kbd>new</kbd> operator. We use the standard C++ <kbd>assert</kbd> macro to check that the book pointer is not null. If it is null, the execution will be aborted with an error message:</p>
<pre>      Book* bookPtr = new Book(author, title); 
      assert(bookPtr != nullptr); 
      m_bookPtrList.push_back(bookPtr); 
      cout &lt;&lt; endl &lt;&lt; "Added." &lt;&lt; endl; 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a book</h1>
                
            
            
                
<p>The <kbd>deleteBook</kbd> method deletes a book from the library by prompting the user about the author and title of the book. If the book exists, we return, unreserve, and delete it:</p>
<pre>     void Library::deleteBook() { 
       string author; 
       cout &lt;&lt; "Author: "; 
       cin &gt;&gt; author; 
 
       string title; 
       cout &lt;&lt; "Title: "; 
       cin &gt;&gt; title; </pre>
<p>We obtain a pointer to the <kbd>Book</kbd> object by calling <kbd>lookupBook</kbd>:</p>
<pre>     Book* bookPtr = lookupBook(author, title); </pre>
<p>If the pointer is <kbd>nullptr</kbd>, the book does not exist and an error message is displayed:</p>
<pre>       if (bookPtr == nullptr) { 
         cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " 
           &lt;&lt; author &lt;&lt; " does not exist." &lt;&lt; endl; 
         return; 
       } </pre>
<p>We check whether the book has been borrowed by looking up the borrower:</p>
<pre>        Customer* borrowerPtr = bookPtr-&gt;borrowerPtr(); </pre>
<p>If the pointer returned by <kbd>borrowerPtr</kbd> is not <kbd>nullptr</kbd>, we return the book by calling <kbd>returnBook</kbd> of the borrower. In that way, the book is no longer registered as borrowed by the customer:</p>
<pre style="padding-left: 60px">  if (borrowerPtr != nullptr) { 
    borrowerPtr-&gt;returnBook(bookPtr); 
  } </pre>
<p>Moreover, we need to check whether the book has been reserved by any other customer. We do so by obtaining the reservation list of the book and, for every customer in the list, we unreserve the book:</p>
<pre>    list&lt;Customer*&gt; reservationPtrList = 
      bookPtr-&gt;reservationPtrList(); </pre>
<p>Note that we do not check whether the book has actually been reserved by the customer, we simply unreserve the book. Also note that we do not need to put back any object to the list, since we work with pointers to objects and do not copy objects:</p>
<pre>      for (Customer* reserverPtr : reservationPtrList) { 
        reserverPtr-&gt;unreserveBook(bookPtr); 
      }</pre>
<p>When removing the book, we remove the book pointer from the book pointer list, and then deallocate the <kbd>Book</kbd> object. It may seem strange that we first display the message and then delete the book pointer. However, it has to be in that order. After we have deleted the object, we can do nothing with it. We cannot delete the object and then write it, it would cause memory errors:</p>
<pre>      m_bookPtrList.remove(bookPtr); 
        n cout &lt;&lt; endl &lt;&lt; "Deleted:" &lt;&lt; bookPtr &lt;&lt; endl; 
        delete bookPtr; 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the books</h1>
                
            
            
                
<p>When listing the books, we first check whether the list is empty. If it is empty, we simply write <kbd>"No books."</kbd>:</p>
<pre>    void Library::listBooks() { 
      if (m_bookPtrList.empty()) { 
       cout &lt;&lt; "No books." &lt;&lt; endl; 
       return; 
      } <br/>    }</pre>
<p>However, if the list is not empty, we iterate through the book pointer list and, for each book pointer, dereference the pointer and write the information:</p>
<pre>      for (const Book* bookPtr : m_bookPtrList) { 
        cout &lt;&lt; (*bookPtr) &lt;&lt; endl; 
        } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a customer</h1>
                
            
            
                
<p>The <kbd>addCustomer</kbd> method prompts the user for the name and address of the customer:</p>
<pre>    void Library::addCustomer() { 
      string name; 
       cout &lt;&lt; "Name: "; 
       cin &gt;&gt; name; 
 
       string address; 
       cout &lt;&lt; "Address: "; 
       cin &gt;&gt; address;</pre>
<p>If a customer with the name and address already exists, an error message is displayed:</p>
<pre>      if (lookupCustomer(name, address) != nullptr) { 
        cout &lt;&lt; endl &lt;&lt; "A customer with name " &lt;&lt; name 
         &lt;&lt; " and address " &lt;&lt; address &lt;&lt; " already exists." 
         &lt;&lt; endl; 
       return; 
      } </pre>
<p>When adding the customer, we dynamically create a new <kbd>Customer</kbd> object that we add to the customer object pointer list:</p>
<pre>      Customer* customerPtr = new Customer(name, address); 
        assert(customerPtr != nullptr); 
        m_customerPtrList.push_back(customerPtr); 
        cout &lt;&lt; endl &lt;&lt; "Added." &lt;&lt; endl; 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a customer</h1>
                
            
            
                
<p>When deleting a customer, we look them up and display an error message if they do not exist:</p>
<pre>    void Library::deleteCustomer() { 
      string name; 
      cout &lt;&lt; "Customer name: "; 
      cin &gt;&gt; name; 
 
      string address; 
      cout &lt;&lt; "Address: "; 
      cin &gt;&gt; address; 
 
      Customer* customerPtr = lookupCustomer(name, address); </pre>
<p>If the customer with the given name and address does not exist, an error message is displayed. Consider the following code:</p>
<pre>    if (customerPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "Customer " &lt;&lt; name 
         &lt;&lt; " does not exists." &lt;&lt; endl; 
      return; 
    }</pre>
<p>If the customer has borrowed at least one book, they cannot be deleted, and an error message is displayed, which is shown as follows:</p>
<pre>     if (!customerPtr-&gt;loanPtrSet().empty()) { 
      cout &lt;&lt; "The customer " &lt;&lt; customerPtr-&gt;name() 
         &lt;&lt; " has borrowed books and cannot be deleted." &lt;&lt; endl; 
      return; 
     } </pre>
<p>However, if the customer has not borrowed any books, the customer is first removed from the reservation list of every book in the library, shown in the following code:</p>
<pre>     for (Book* bookPtr : m_bookPtrList) { 
       bookPtr-&gt;removeReservation(customerPtr); 
     } </pre>
<p>Then the customer is removed from the customer list, and the <kbd>Customer</kbd> object is deallocated by the <kbd>delete</kbd> operator. Again, note that we first must write the customer information, and then delete its object. The other way around would not have worked since we cannot inspect a deleted object. That would have caused memory errors:</p>
<pre>      m_customerPtrList.remove(customerPtr); 
      cout &lt;&lt; endl &lt;&lt; "Deleted." &lt;&lt; (*customerPtr) &lt;&lt; endl; 
      delete customerPtr; 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the customers</h1>
                
            
            
                
<p>When listing the customer, we go through the customer list and, for each customer, dereference the <kbd>Customer</kbd> object pointer and write the information of the object:</p>
<pre>    void Library::listCustomers() { 
      if (m_customerPtrList.empty()) { 
        cout &lt;&lt; "No customers." &lt;&lt; endl; 
        return; 
      } 
       
      for (const Customer* customerPtr: m_customerPtrList) { 
        cout &lt;&lt; (*customerPtr) &lt;&lt; endl; 
      } 
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing a book</h1>
                
            
            
                
<p>When borrowing a book, we start by prompting the user for the author and title, which is shown in the following code snippet:</p>
<pre>    void Library::borrowBook() { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>We look up the book and if the book does not exist, an error message is displayed, which is shown in the following code:</p>
<pre>     Book* bookPtr = lookupBook(author, title); 
 
     if (bookPtr == nullptr) { 
       cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title 
         &lt;&lt; "" by " &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
       return; 
     } </pre>
<p>If the book has already been borrowed by another customer, it cannot be borrowed again:</p>
<pre>    if (bookPtr-&gt;borrowerPtr() != nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " &lt;&lt; author  
         &lt;&lt; " has already been borrowed." &lt;&lt; endl; 
      return; 
    } </pre>
<p>We prompt the user for the name and address of the customer:</p>
<pre>     string name; 
     cout &lt;&lt; "Customer name: "; 
     cin &gt;&gt; name; 
 
     string address; 
     cout &lt;&lt; "Address: "; 
     cin &gt;&gt; address; 
 
     Customer* customerPtr = lookupCustomer(name, address);</pre>
<p>If there is no customer with the given name and address, an error message is displayed:</p>
<pre>     if (customerPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "No customer with name " &lt;&lt; name 
         &lt;&lt; " and address " &lt;&lt; address &lt;&lt; " exists."  &lt;&lt; endl; 
      return; 
     } </pre>
<p>Finally, we add the book to the customer's loan set and we mark the customer as the borrower of the book:</p>
<pre>     bookPtr-&gt;borrowerPtr() = customerPtr; 
     customerPtr-&gt;borrowBook(bookPtr); 
     cout &lt;&lt; endl &lt;&lt; "Borrowed." &lt;&lt; endl; 
   } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reserving a book</h1>
                
            
            
                
<p>The reservation process is similar to the preceding borrowing process. We prompt the user for the author and title of the book, as well as the name and address of the customer, which is shown as follows:</p>
<pre>    void Library::reserveBook() { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; 
 
    Book* bookPtr = lookupBook(author, title); </pre>
<p>If the book does not exist, an error message is displayed:</p>
<pre>    if (bookPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title 
         &lt;&lt; "" by " &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
      return; 
    } </pre>
<p>If the book has not been borrowed, it is not possible to reserve it. Instead, we encourage the user to borrow the book:</p>
<pre>     if (bookPtr-&gt;borrowerPtr() == nullptr) { 
       cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " 
         &lt;&lt; author &lt;&lt; " has not been not borrowed. " 
         &lt;&lt; "Please borrow the book instead of reserving it." 
         &lt;&lt; endl; 
      return; 
    } </pre>
<p>We prompt the user for the name and address of the customer:</p>
<pre>     string name; 
     cout &lt;&lt; "Customer name: "; 
     cin &gt;&gt; name; 
 
     string address; 
     cout &lt;&lt; "Address: "; 
     cin &gt;&gt; address; 
 
     Customer* customerPtr = lookupCustomer(name, address); </pre>
<p>If the customer does not exist, an error message is displayed:</p>
<pre>     if (customerPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "There is no customer with name " &lt;&lt; name 
         &lt;&lt; " and address " &lt;&lt; address &lt;&lt; "." &lt;&lt; endl; 
      return; 
     } </pre>
<p>If the customer has already borrowed the book, they cannot also reserve the book:</p>
<pre>     if (bookPtr-&gt;borrowerPtr() == customerPtr) { 
      cout &lt;&lt; endl &lt;&lt; "The book has already been borrowed by " 
         &lt;&lt; name &lt;&lt; "." &lt;&lt; endl; 
      return; 
     } </pre>
<p>Finally, we add the customer to the reservation list of the book and we add the book to the reservation set of the customer. Note that there is a list of reservation customers for the book, while there is a set of reserved books for the customer. The reason for this is that when a book is returned, the first customer in the reservation list borrows the book. There are no such restrictions when it comes to a set of reservations for a customer:</p>
<pre>     int position = bookPtr-&gt;reserveBook(customerPtr); 
     customerPtr-&gt;reserveBook(bookPtr); </pre>
<p>We notify the customer of its position on the reservation list:</p>
<pre>     cout &lt;&lt; endl &lt;&lt; position &lt;&lt; "nd reserve." &lt;&lt; endl; 
     }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning a book</h1>
                
            
            
                
<p>When returning a book, we prompt the user for its author and title. However, we do not ask for the customer who has borrowed the book. That information is already stored in the <kbd>Book</kbd> object:</p>
<pre>    void Library::returnBook() { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; 
 
      Book* bookPtr = lookupBook(author, title); </pre>
<p>If the book with the given author and title does not exist, an error message is displayed:</p>
<pre>     if (bookPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title &lt;&lt; "" by " 
         &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
      return; 
     } 
 
     Customer* customerPtr = bookPtr-&gt;borrowerPtr(); </pre>
<p>If the customer with the given name and address does not exist, an error message is displayed:</p>
<pre>     if (customerPtr == nullptr) { 
      cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " 
         &lt;&lt; author &lt;&lt; " has not been borrowed." &lt;&lt; endl; 
      return; 
     } 
 
     bookPtr-&gt;returnBook(); 
     customerPtr-&gt;returnBook(bookPtr); 
     cout &lt;&lt; endl &lt;&lt; "Returned." &lt;&lt; endl; </pre>
<p>When we have returned the book, we need to find out whether any customer has reserved it:</p>
<pre>     list&lt;Customer*&gt;&amp; reservationPtrList = 
       bookPtr-&gt;reservationPtrList();</pre>
<p>If there is at least one customer in the reservation list of the book, we obtain that customer, remove them from the reservation list of the book, mark the customer as the borrower of the book, and add the book to the loan set of the customer:</p>
<pre>     if (!reservationPtrList.empty()) { 
       Customer* newCustomerPtr = reservationPtrList.front(); 
       reservationPtrList.erase(reservationPtrList.begin()); 
 
       bookPtr-&gt;borrowBook(newCustomerPtr); 
       newCustomerPtr-&gt;borrowBook(bookPtr); 
       cout &lt;&lt; endl &lt;&lt; "Borrowed by " 
          &lt;&lt; newCustomerPtr-&gt;name() &lt;&lt; endl; 
       } 
     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Looking up books and customers</h1>
                
            
            
                
<p>When saving and loading the library information from a file, we need to transform between pointers to <kbd>Book</kbd> and <kbd>Customer</kbd> objects and indexes in the book and customer lists. The <kbd>lookupIndex</kbd> method takes a pointer to a <kbd>Book</kbd> object and returns its index in the book list:</p>
<pre>    int Library::lookupBookIndex(const Book* bookPtr) { 
      int index = 0; 
 
      for (Book* testPtr : m_bookPtrList) { 
        if (bookPtr == testPtr) { 
        return index; 
      } 
 
      ++index; 
    } </pre>
<p>If we reach this point, the execution is aborted with an error message by the <kbd>assert</kbd> macro. However, we should not reach this point, since the <kbd>Book</kbd> pointer should be in the book pointer list:</p>
<pre>     assert(false); 
      return -1; 
     }</pre>
<p>The <kbd>lookupBookPtr</kbd> method performs the opposite task. It finds the <kbd>Book</kbd> object pointer at the position given by <kbd>bookIndex</kbd> in the book pointer list. The <kbd>assert</kbd> macro aborts the execution with an error message if the index is outside the scope of the list. However, that should not happen since all indexes shall be within the scope:</p>
<pre>    Book* Library::lookupBookPtr(int bookIndex) { 
      assert((bookIndex &gt;= 0) &amp;&amp; 
       (bookIndex &lt; ((int) m_bookPtrList.size()))); 
 
      auto iterator = m_bookPtrList.begin(); 
      for (int count = 0; count &lt; bookIndex; ++count) { 
        ++iterator; 
      } 
 
      return *iterator; 
    }  </pre>
<p>The <kbd>lookupCustomerIndex</kbd> method gives the index of the <kbd>Customer</kbd> pointer in the customer pointer list, in the same way as shown in the preceding <kbd>lookupBookIndex</kbd> method:</p>
<pre>    int Library::lookupCustomerIndex(const Customer* customerPtr) { 
      int index = 0; 
 
      for (Customer* testPtr : m_customerPtrList) { 
        if (customerPtr == testPtr) { 
        return index; 
      } 
 
      ++index; 
     } 
 
     assert(false); 
     return -1; 
    } </pre>
<p>The <kbd>lookupCustomerPtr</kbd> method looks up the index of the <kbd>Customer</kbd> pointer in the customer pointer list in the same way as shown in the preceding <kbd>lookupBookPtr</kbd> method:</p>
<pre>    Customer* Library::lookupCustomerPtr(int customerIndex) { 
      assert((customerIndex &gt;= 0) &amp;&amp; 
       (customerIndex &lt; ((int) m_customerPtrList.size()))); 
 
      auto iterator = m_customerPtrList.begin(); 
      for (int count = 0; count &lt; customerIndex; ++count) { 
        ++iterator; 
      }  
      
      return *iterator; 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Marshmallowing</h1>
                
            
            
                
<p>The <kbd>save</kbd> and <kbd>load</kbd> methods of the <kbd>Library</kbd> class of this chapter are a bit more complicated than their counterparts in <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. The reason for this is that we cannot save pointers directly, since a pointer holds a memory address that can be changed between executions. Instead, we need to save their indexes to the file. The process of transforming pointers to indexes and indexes to pointers is called <strong>marshmallowing</strong>. When saving the library, we divide the saving process into several steps:</p>
<ul>
<li>Saving the book list:  At this point, we save the author and title only.</li>
<li>Saving the customer list:  At this point, we save the name and address only.</li>
<li>For each book: Save the borrower (if the book is borrowed) and the (possibly empty) reservation list. We save the customer list indexes, rather than the pointers to the customers.</li>
<li>For each customer, we save the loan and reservation sets. We save the book list indexes, rather than the pointers to the books.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving the library information to a file</h1>
                
            
            
                
<p>The <kbd>Save</kbd> method opens the file and, if it was successfully opened, reads the books and customers of the library:</p>
<pre>    void Library::save() { 
      ofstream outStream(s_binaryPath); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the book objects</h1>
                
            
            
                
<p>We save the book objects. We only save the author and title of the books by calling <kbd>write</kbd> for each <kbd>Book</kbd> object. We do not save the potential borrower and reservation list at this point.</p>
<p>We start by writing the number of books in the list to the file:</p>
<pre>    if (outStream) { 
      { int bookPtrListSize = m_bookPtrList.size(); 
         outStream.write((char*) &amp;bookPtrListSize, 
           sizeof bookPtrListSize); </pre>
<p>Then we write the information of each book to the file by calling <kbd>write</kbd> on each <kbd>Book</kbd> object pointer:</p>
<pre>      for (const Book* bookPtr : m_bookPtrList) { 
        bookPtr-&gt;write(outStream); 
    } 
   } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the customer objects</h1>
                
            
            
                
<p>We save the customer objects. Similar to the preceding book case, we only save the name and address of the customers by calling <kbd>write</kbd> for each <kbd>Customer</kbd> object. We do not save sets of borrowed and reserved books at this point.</p>
<p>In the same way, as in the preceding book case, we start by writing the number of customers on the list to the file:</p>
<pre>    { int customerPtrListSize = m_customerPtrList.size(); 
      outStream.write((char*) &amp;customerPtrListSize, 
                      sizeof customerPtrListSize); </pre>
<p>Then we write the information of each customer to the file by calling the <kbd>write</kbd> method on each <kbd>Customer</kbd> object pointer:</p>
<pre>      for (const Customer* customerPtr : m_customerPtrList) { 
        customerPtr-&gt;write(outStream); 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the borrower index</h1>
                
            
            
                
<p>For each <kbd>Book</kbd> object, if the book is borrowed we look up and save the index of the <kbd>Customer</kbd>, rather than the pointer to the object:</p>
<pre>    for (const Book* bookPtr : m_bookPtrList) { 
      { const Customer* borrowerPtr = bookPtr-&gt;borrowerPtr(); </pre>
<p>For each book, we start by checking if it has been borrowed. If it has been borrowed, we write the value <kbd>true</kbd> to the file, to indicate that it is borrowed:</p>
<pre>        if (borrowerPtr != nullptr) { 
          bool borrowed = true; 
          outStream.write((char*) &amp;borrowed, sizeof borrowed); </pre>
<p>Then we look up the index of the customer that has borrowed the book in the customer pointer list and write the index to the file:</p>
<pre>          int loanIndex = lookupCustomerIndex(borrowerPtr); 
          outStream.write((char*) &amp;loanIndex, sizeof loanIndex); 
        } </pre>
<p>If the book is not borrowed, we just write the value <kbd>false</kbd> to the file, to indicate that the book has not been borrowed:</p>
<pre>        else { 
          bool borrowed = false; 
          outStream.write((char*) &amp;borrowed, sizeof borrowed); 
        } 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the reservation indexes</h1>
                
            
            
                
<p>As a book can be reserved for more than one customer, we iterate through the list of reservations and save the index of each customer in the reservation list:</p>
<pre>      { const list&lt;Customer*&gt;&amp; reservationPtrList = 
          bookPtr-&gt;reservationPtrList(); </pre>
<p>For each book, we start by writing the number of reservations of the book to the file:</p>
<pre>        int reserveSetSize = reservationPtrList.size(); 
        outStream.write((char*) &amp;reserveSetSize, 
                        sizeof reserveSetSize); </pre>
<p>Then we iterate through the reservation list and, for each reservation, we look up and write the index of each customer that reserved the book:</p>
<pre>        for (const Customer* customerPtr : reservationPtrList) { 
          int customerIndex = lookupCustomerIndex(customerPtr); 
          outStream.write((char*) &amp;customerIndex, 
                          sizeof customerIndex); 
        } 
      } 
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the loan book indexes</h1>
                
            
            
                
<p>For each customer, we save the indexes of the books they have borrowed. First, we save the size of the loan list and then the book indexes:</p>
<pre>    for (const Customer* customerPtr : m_customerPtrList) { 
      { const set&lt;Book*&gt;&amp; loanPtrSet = 
          customerPtr-&gt;loanPtrSet(); </pre>
<p>For each customer, we start by writing the number of loans to the file:</p>
<pre>        int loanPtrSetSize = loanPtrSet.size(); 
        outStream.write((char*) &amp;loanPtrSetSize, 
                        sizeof loanPtrSetSize); </pre>
<p>Then we iterate through the loan set and, for each loan, we look up and write the index of each book to the file:</p>
<pre>        for (const Book* customerPtr : loanPtrSet) { 
          int customerIndex = lookupBookIndex(customerPtr); 
          outStream.write((char*) &amp;customerIndex, 
                          sizeof customerIndex); 
        } 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the reservation book indexes</h1>
                
            
            
                
<p>In the same way, for each customer, we save the indexes of the books they have reserved. First, we save the size of the reservation list and then the indexes of the books they reserved:</p>
<pre>      { const set&lt;Book*&gt;&amp; reservedPtrSet = 
          customerPtr-&gt;reservationPtrSet(); </pre>
<p>For each customer, we start by writing the number of reserved books to the file:</p>
<pre>        int reservationPtrSetSize = reservationPtrSet.size(); 
        outStream.write((char*) &amp;reservationPtrSetSize, 
                        sizeof reservationPtrSetSize); </pre>
<p>Then we iterate through the reservation set and, for each reservation, we look up and write the index of each book to the file:</p>
<pre>        for (const Book* reservedPtr : reservationPtrSet) { 
          int customerIndex = lookupBookIndex(reservedPtr); 
          outStream.write((char*) &amp;customerIndex, 
                          sizeof customerIndex); 
        } 
      } 
    } 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading the library information from a file</h1>
                
            
            
                
<p>When loading the file, we proceed in the same manner as when we saved the file:</p>
<pre>    void Library::load() { 
      ifstream inStream(s_binaryPath); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the book objects</h1>
                
            
            
                
<p>We read the size of the book list, and then the books themselves. Remember that we have so far read the author and title of the books only:</p>
<pre>    if (inStream) { 
      { int bookPtrListSize; </pre>
<p>We start by reading the number of books:</p>
<pre>        inStream.read((char*) &amp;bookPtrListSize, 
                    sizeof bookPtrListSize); </pre>
<p>Then we read the books themselves. For each book, we dynamically allocate a <kbd>Book</kbd> object, read its information by calling <kbd>read</kbd> on the pointer, and add the pointer to the book pointer list:</p>
<pre>      for (int count = 0; count &lt; bookPtrListSize; ++count) { 
        Book *bookPtr = new Book(); 
        assert(bookPtr != nullptr); 
        bookPtr-&gt;read(inStream); 
        m_bookPtrList.push_back(bookPtr); 
      } 
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the customer objects</h1>
                
            
            
                
<p>In the same way, we read the size of the customer list and then the customers themselves. Up until this point, we read the name and address of the customers only:</p>
<pre>    { int customerPtrListSize; </pre>
<p>We start by reading the number of customers:</p>
<pre>      inStream.read((char*) &amp;customerPtrListSize, 
                    sizeof customerPtrListSize); </pre>
<p>Then we read the customers themselves. For each customer, we dynamically allocate a <kbd>Customer</kbd> object, read its information by calling <kbd>read</kbd> on the pointer, and add the pointer to the book pointer list:</p>
<pre>      for (int count = 0; count &lt; customerPtrListSize; ++count) { 
        Customer *customerPtr = new Customer(); 
        assert(customerPtr != nullptr); 
        customerPtr-&gt;read(inStream); 
        m_customerPtrList.push_back(customerPtr); 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the borrower index</h1>
                
            
            
                
<p>For each book, we read the customers that have borrowed it (if any) and the list of customers that have reserved the book:</p>
<pre>    for (Book* bookPtr : m_bookPtrList) { 
      { bool borrowed; 
        inStream.read((char*) &amp;borrowed, sizeof borrowed); </pre>
<p>If <kbd>borrowed</kbd> is <kbd>true</kbd>, the book has been borrowed. In that case, we read the index of the customer. We then look up the pointer of the <kbd>Customer</kbd> object, which we add to the reservation list of the book:</p>
<pre>        if (borrowed) { 
          int loanIndex; 
          inStream.read((char*) &amp;loanIndex, sizeof loanIndex); 
          bookPtr-&gt;borrowerPtr() = lookupCustomerPtr(loanIndex); 
        }</pre>
<p>If <kbd>borrowed</kbd> is <kbd>false</kbd>, the book has not been borrowed. In that case, we set the pointer to the customer that has borrowed the book to <kbd>nullptr</kbd>:</p>
<pre>        else { 
          bookPtr-&gt;borrowerPtr() = nullptr; 
        } 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the reservation indexes</h1>
                
            
            
                
<p>For each book, we also read the reservation list. First, we read the size of the list and then the customer indexes themselves:</p>
<pre>      { list&lt;Customer*&gt;&amp; reservationPtrList = 
          bookPtr-&gt;reservationPtrList(); 
        int reservationPtrListSize; </pre>
<p>We start by reading the number of reservations of the book:</p>
<pre>        inStream.read((char*) &amp;reservationPtrListSize, 
                      sizeof reservationPtrListSize); </pre>
<p>For each reservation, we read the index of the customer and call <kbd>lookupCustomerPtr</kbd> to obtain the pointer to the <kbd>Customer</kbd> object, which we add to the reservation pointer list of the book:</p>
<pre>        for (int count = 0; count &lt; reservationPtrListSize; 
             ++count) { 
          int customerIndex; 
          inStream.read((char*) &amp;customerIndex, 
                        sizeof customerIndex); 
          Customer* customerPtr = 
            lookupCustomerPtr(customerIndex); 
          reservationPtrList.push_back(customerPtr); 
        } 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the loan book indexes</h1>
                
            
            
                
<p>For each customer, we read the set of borrowed books:</p>
<pre>    for (Customer* customerPtr : m_customerPtrList) { 
      { set&lt;Book*&gt;&amp; loanPtrSet = customerPtr-&gt;loanPtrSet(); 
        int loanPtrSetSize = loanPtrSet.size();</pre>
<p>We start by reading the size of the loan list:</p>
<pre>        inStream.read((char*) &amp;loanPtrSetSize, 
                      sizeof loanPtrSetSize); </pre>
<p>For each loan, we read the index of the book and call <kbd>lookupBookPtr</kbd> to obtain the pointer to the <kbd>Book</kbd> object, which we add to the loan pointer list:</p>
<pre>        for (int count = 0; count &lt; loanPtrSetSize; ++count) { 
          int bookIndex; 
          inStream.read((char*) &amp;bookIndex, sizeof bookIndex); 
          Book* bookPtr = lookupBookPtr(bookIndex); 
          loanPtrSet.insert(bookPtr); 
        } 
      } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the reservation book indexes</h1>
                
            
            
                
<p>In the same way, for each customer, we read the set of reserved books:</p>
<pre>      { set&lt;Book*&gt;&amp; reservationPtrSet = 
          customerPtr-&gt;reservationPtrSet(); </pre>
<p>We start by reading the size of the reservation list:</p>
<pre>        int reservationPtrSetSize = reservationPtrSet.size(); 
        inStream.read((char*) &amp;reservationPtrSetSize, 
                      sizeof reservationPtrSetSize); </pre>
<p>For each reservation, we read the index of the book and call <kbd>lookupBookPtr</kbd> to obtain the pointer to the <kbd>Book</kbd> object, which we add to the reservation pointer list:</p>
<pre>        for (int count = 0; count &lt; reservationPtrSetSize; 
             ++count) { 
          int bookIndex; 
          inStream.read((char*) &amp;bookIndex, sizeof bookIndex); 
          Book* bookPtr = lookupBookPtr(bookIndex); 
          reservationPtrSet.insert(bookPtr); 
        } 
      } 
    } 
  } 
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deallocating memory</h1>
                
            
            
                
<p>Since we have added dynamically allocated <kbd>Book</kbd> and <kbd>Customer</kbd> objects to the lists, we need to deallocate them at the end of the execution. The destructor iterates through the book and customer pointer lists and deallocates all the book and customer pointers:</p>
<pre>    Library::~Library() { 
      for (const Book* bookPtr : m_bookPtrList) { 
        delete bookPtr; 
      } 
  
      for (const Customer* customerPtr : m_customerPtrList) { 
        delete customerPtr; 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>Similar to <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>, the <kbd>main</kbd> function simply creates a <kbd>Library</kbd> object:</p>
<p><strong>Main.cpp</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    #include &lt;IOStream&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" 
 
    void main() { 
      Library(); 
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we built a library management system similar to the system of <a href="6814bf19-e75b-4083-8447-892dd8416f49.xhtml" target="_blank">Chapter 3</a>, <em>Building a Library Management System</em>. However, we omitted all integer identity numbers and replaced them with pointers. This gives us the advantage that we can store loans and reservations more directly, but it also makes it harder for us to save and load them into a file.</p>
<p>In <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em>, we will look at graphical applications.</p>
<p> </p>


            

            
        
    </body></html>