<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-33"><span class="koboSpan" id="kobo.2.1">Challenges in Embedded Systems with Limited Resources</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">If you are reading this book, chances are you have a good grasp of embedded systems. </span><span class="koboSpan" id="kobo.3.2">There are many definitions of embedded systems, and while the following may not be the most common, it captures the essence shared by others. </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Embedded systems</span></strong><span class="koboSpan" id="kobo.5.1"> are specialized computing systems for specific use with a limited set of responsibilities, in contrast to general-purpose </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.6.1">computing systems. </span><span class="koboSpan" id="kobo.6.2">Embedded systems can be embedded in a larger electronic or mechanical system, or act as a standalone device.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">The line between embedded systems and general-purpose computing devices is sometimes blurred. </span><span class="koboSpan" id="kobo.7.2">We can all agree that the system that controls a toaster or a pump in an airplane is an embedded system. </span><span class="koboSpan" id="kobo.7.3">Cellphones and early smartphones were also considered embedded systems. </span><span class="koboSpan" id="kobo.7.4">Nowadays, smartphones are closer to the definition of a general-purpose computing device. </span><span class="koboSpan" id="kobo.7.5">In this book, we will focus on firmware development using modern C++ on small embedded systems or resource-constrained embedded systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">Resource-constrained embedded systems are often employed in safety-critical applications. </span><span class="koboSpan" id="kobo.8.2">They have a responsibility to control a process in a timely manner and they cannot fail, as failure can mean the loss of human lives. </span><span class="koboSpan" id="kobo.8.3">In this chapter, we will cover limitations imposed by regulations on software development for safety-critical devices and implications for the usage of C++. </span><span class="koboSpan" id="kobo.8.4">We will learn how to mitigate these concerns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Safety-critical and hard real-time embedded systems</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Dynamic memory management</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Disabling unwanted C++ features</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-34"><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.14.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.15.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.16.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.16.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.16.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.16.4">As we are using a lot of modern C++ features, make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">-std=c++23</span></code><span class="koboSpan" id="kobo.18.1"> in compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02"><span class="url"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter02</span></span></a><span class="koboSpan" id="kobo.21.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-35"><span class="koboSpan" id="kobo.22.1">Safety-critical and hard real-time embedded systems</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.23.1">Safety-critical embedded systems</span></strong><span class="koboSpan" id="kobo.24.1"> are systems whose failure may result in damage to property </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.25.1">or environment, injury to people, or even a loss of life. </span><span class="koboSpan" id="kobo.25.2">Failure of these systems is not acceptable. </span><span class="koboSpan" id="kobo.25.3">Brakes, steering systems, and airbags in cars are good examples of safety-critical systems. </span><span class="koboSpan" id="kobo.25.4">The correct functioning of these systems is essential for the safe operation of a vehicle.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">Next, we will analyze the real-time requirements of an airbag control unit in a car.</span></p>
<h2 class="heading-2" id="_idParaDest-36"><span class="koboSpan" id="kobo.27.1">Airbag control unit and real-time requirements</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Safety-critical </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.29.1">embedded systems often impose hard real-time requirements, meaning that any missed deadline results in </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.30.1">system failure. </span><span class="koboSpan" id="kobo.30.2">An </span><strong class="keyWord"><span class="koboSpan" id="kobo.31.1">A</span></strong><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">irbag Control Unit</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">ACU</span></strong><span class="koboSpan" id="kobo.35.1">) collects data from accelerometers and pressure sensors, runs an algorithm that processes the collected data, and detects side, front, and rear-end crashes. </span><span class="koboSpan" id="kobo.35.2">Upon the crash detection, the ACU controls the deployment of different restraint systems, including airbags and seat belt tensioners.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.36.1">ACU implementations </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.37.1">must be resilient to different scenarios, such as malfunctioning sensors and electronics. </span><span class="koboSpan" id="kobo.37.2">These are mitigated by redundant sensors, comparing data from sensors, comparing data against thresholds, and self-tests. </span><span class="koboSpan" id="kobo.37.3">Most importantly, ACUs need to meet timing requirements, as they have only a couple of milliseconds to collect data, make decisions, and initiate deployment of restraint systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.38.1">The ACU fails if it doesn’t detect a crash on time, but it also fails if it deploys restraint systems just a bit too late, as this can do more harm to a driver and passengers than if the ACU hadn’t initiated a deployment at all. </span><span class="koboSpan" id="kobo.38.2">This is why an ACU must meet hard real-time requirements, and when it comes to firmware, this means all the worst-case execution times must be predictable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.39.1">The effect of delayed airbag deployment is the subject of many studies concerned with injuries </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.40.1">caused to occupants. </span><span class="koboSpan" id="kobo.40.2">The following extract is part of the conclusion from the paper </span><em class="italic"><span class="koboSpan" id="kobo.41.1">Study regarding the influence of airbag deployment time on the occupant injury level during a frontal vehicle collision</span></em><span class="koboSpan" id="kobo.42.1">, published at MATEC Web of Conferences 184(1):01007, by authors Alexandru Ionut Radu, Corneliu Cofaru, Bogdan Tolea, and Dragoș Sorin Dima, outlining results of simulations of delayed airbag deployment:</span></p>
<blockquote class="packt_quote">
<p class="quote"><em class="italic"><span class="koboSpan" id="kobo.43.1">“It has been found that by increasing the delay of the airbag deployment time in the event of a frontal impact, the probability of injury to the occupant’s head increases by up to 46%. </span><span class="koboSpan" id="kobo.43.2">Reducing the distance between the occupant’s head and the dashboard / steering wheel when the airbag ignites would result in a force expansion of the gas that is transmitted to the occupant’s head generating an extra acceleration and also throws back the occupant increasing the injury potential due to the impact between the head and headrest. </span><span class="koboSpan" id="kobo.43.3">Thus, an increase in injury probability of 8% was observed in the 0 ms delay of the airbag deployment, while a 100 ms delay resulted in a 54% increase in the head acceleration value. </span><span class="koboSpan" id="kobo.43.4">So, the role of the airbag is reversed, it no longer has the role of cushioning the collision, but to generate injuries.”</span></em></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.44.1">A graphic illustration of collision and delayed airbag deployment is shown in the following figure (source: </span><a href="https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision"><span class="url"><span class="koboSpan" id="kobo.45.1">https://www.researchgate.net/publication/326715516_Study_regarding_the_influence_of_airbag_deployment_time_on_the_occupant_injury_level_during_a_frontal_vehicle_collision</span></span></a><span class="koboSpan" id="kobo.46.1">):</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.47.1"><img alt="Figure 2.1 – Crash simulation with delayed restraint system deployment" src="../Images/B22402_2_1.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Figure 2</span></span><span class="koboSpan" id="kobo.49.1">.1 – Crash simulation with delayed restraint system deployment</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.51.1">.1</span></em><span class="koboSpan" id="kobo.52.1"> effectively illustrates what happens if an ACU doesn’t meet hard real-time requirements </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.53.1">and produces delayed results. </span><span class="koboSpan" id="kobo.53.2">The figure is taken from the paper </span><em class="italic"><span class="koboSpan" id="kobo.54.1">Study regarding the influence of airbag deployment time on the occupant injury level during a frontal vehicle collision</span></em><span class="koboSpan" id="kobo.55.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.56.1"> There are multiple reasons why an ACU may fail and cause no or a delayed deployment:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.57.1">Sensor malfunctioning</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.58.1">Electronics malfunctioning</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.59.1">Crash detection algorithm failure</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.60.1">Firmware failure to meet a deadline</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.61.1">Sensors and electronics malfunctioning are mitigated by redundancy, data sanity checks, cross-comparison, and startup and runtime self-tests. </span><span class="koboSpan" id="kobo.61.2">This puts additional stress on firmware and its correct functioning. </span><span class="koboSpan" id="kobo.61.3">A crash detection algorithm may fail due to a bad model that was built upon, or other factors that are out of firmware responsibilities. </span><span class="koboSpan" id="kobo.61.4">The firmware’s job is to feed the algorithm with sensors’ data on time, execute it in a timely manner within a set time window, and act based on the output of the algorithm.</span></p>
<h2 class="heading-2" id="_idParaDest-37"><span class="koboSpan" id="kobo.62.1">Measuring firmware performance and non-determinism</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.63.1">How do </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.64.1">we ensure </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.65.1">that the firmware will run all functions within imposed real-time requirements? </span><span class="koboSpan" id="kobo.65.2">We measure it. </span><span class="koboSpan" id="kobo.65.3">We can measure different metrics, such as performance profiling, response to external events, and A-B timing. </span><span class="koboSpan" id="kobo.65.4">Performance profiling will tell us in which functions the program spends the most time. </span><span class="koboSpan" id="kobo.65.5">Response to external events will indicate how much time it takes for a system to respond to an external event, such as an interrupt or a message on a communication bus.</span></p>
<h3 class="heading-3" id="_idParaDest-38"><span class="koboSpan" id="kobo.66.1">A-B timing and real-time execution</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.67.1">The most important metric when dealing with real-time requirements is </span><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">A-B timing</span></strong><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">We measure how </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.70.1">long it takes for firmware to execute a program from point A to point B. </span><span class="koboSpan" id="kobo.70.2">A-B timing can measure a function’s duration, but not necessarily. </span><span class="koboSpan" id="kobo.70.3">We can use it to measure different things. </span><span class="koboSpan" id="kobo.70.4">Going from A to B can take different times, based on the state of the system and inputs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.71.1">A simple way </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.72.1">to make an A-B measurement is toggling a </span><strong class="keyWord"><span class="koboSpan" id="kobo.73.1">General Purpose Input Output</span></strong><span class="koboSpan" id="kobo.74.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.75.1">GPIO</span></strong><span class="koboSpan" id="kobo.76.1">) and using an oscilloscope to measure the time between changes of a GPIO. </span><span class="koboSpan" id="kobo.76.2">It’s a simple solution that works well but doesn’t scale, as we would need a GPIO for every function we want to measure or we’d need to measure one function at </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.77.1">a time. </span><span class="koboSpan" id="kobo.77.2">We could also use the internal timer of a </span><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">Microcontroller Unit (MCU)</span></strong><span class="koboSpan" id="kobo.79.1">to make precise measurements and output that information over a UART port. </span><span class="koboSpan" id="kobo.79.2">This would require us to utilize a general-purpose timer just for the sake of measuring. </span><span class="koboSpan" id="kobo.79.3">Most microcontrollers have specialized units for instrumentation and profiling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Some ARM-based </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.81.1">microcontrollers have a </span><strong class="keyWord"><span class="koboSpan" id="kobo.82.1">Data Watchpoint and Trace</span></strong><span class="koboSpan" id="kobo.83.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.84.1">DWT</span></strong><span class="koboSpan" id="kobo.85.1">) unit. </span><span class="koboSpan" id="kobo.85.2">DWT is used for data tracing and system profiling, including </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.86.1">the following:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.87.1">Program Counter</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.89.1">PC</span></strong><span class="koboSpan" id="kobo.90.1">) sampling</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.91.1">Cycle counting</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.92.1">DWT generates </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.93.1">events and outputs them using an </span><strong class="keyWord"><span class="koboSpan" id="kobo.94.1">Instrumentation Trace Macrocell</span></strong><span class="koboSpan" id="kobo.95.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.96.1">ITM</span></strong><span class="koboSpan" id="kobo.97.1">) unit. </span><span class="koboSpan" id="kobo.97.2">The ITM unit can also be used to output data generated from the firmware itself, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">printf</span></code><span class="koboSpan" id="kobo.99.1"> style. </span><span class="koboSpan" id="kobo.99.2">ITM buffers data and sends it </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.100.1">over to an ITM sink. </span><strong class="keyWord"><span class="koboSpan" id="kobo.101.1">Single Wire Output</span></strong><span class="koboSpan" id="kobo.102.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.103.1">SWO</span></strong><span class="koboSpan" id="kobo.104.1">) can be used as an ITM sink.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.105.1">We can utilize DWT and ITM for profiling as follows:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.106.1">DWT can generate periodic sampling of the PC and use ITM to send them over SWO.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.107.1">On a host machine, we capture and analyze the received data.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.108.1">By using a linker map file for our firmware, we can generate the distribution of time spent in each of the functions in our program.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.109.1">This can help us to see which function takes the most time. </span><span class="koboSpan" id="kobo.109.2">It’s not particularly useful for A-B timing measurements, but it allows us to see where the program spends most of the time without any </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.110.1">direct software instrumentation except setting up DWT and ITM units.</span></p>
<h3 class="heading-3" id="_idParaDest-39"><span class="koboSpan" id="kobo.111.1">Sotware instrumentation with GCC</span></h3>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.112.1">GNU Compiler Collection </span></strong><span class="koboSpan" id="kobo.113.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.114.1">GCC</span></strong><span class="koboSpan" id="kobo.115.1">) supports software instrumentation by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">-finstrument-functions</span></code><span class="koboSpan" id="kobo.117.1"> flag to instrument functions’ entries and exists. </span><span class="koboSpan" id="kobo.117.2">This inserts </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">entry</span></code><span class="koboSpan" id="kobo.119.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.120.1">exit</span></code><span class="koboSpan" id="kobo.121.1"> calls to each function with the following signature:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.122.1">__attribute__((no_instrument_function))
</span><span class="hljs-type"><span class="koboSpan" id="kobo.123.1">void</span></span><span class="koboSpan" id="kobo.124.1"> __cyg_profile_func_enter(</span><span class="hljs-type"><span class="koboSpan" id="kobo.125.1">void</span></span><span class="koboSpan" id="kobo.126.1"> *this_fn, </span><span class="hljs-type"><span class="koboSpan" id="kobo.127.1">void</span></span><span class="koboSpan" id="kobo.128.1"> *call_site)
{
}
__attribute__((no_instrument_function))
</span><span class="hljs-type"><span class="koboSpan" id="kobo.129.1">void</span></span><span class="koboSpan" id="kobo.130.1"> __cyg_profile_func_exit(</span><span class="hljs-type"><span class="koboSpan" id="kobo.131.1">void</span></span><span class="koboSpan" id="kobo.132.1"> *this_fn, </span><span class="hljs-type"><span class="koboSpan" id="kobo.133.1">void</span></span><span class="koboSpan" id="kobo.134.1"> *call_site)
{
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.135.1">We can utilize DWT and ITM in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">__cyg_profile_func_enter</span></code><span class="koboSpan" id="kobo.137.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">__cyg_profile_func_exit</span></code><span class="koboSpan" id="kobo.139.1"> functions to send the clock cycle count and analyze it on the host machine to make A-B timing measurements. </span><span class="koboSpan" id="kobo.139.2">The following is an example of a simplified implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">entry</span></code><span class="koboSpan" id="kobo.141.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">exit</span></code><span class="koboSpan" id="kobo.143.1"> functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.144.1">extern</span></span><span class="koboSpan" id="kobo.145.1"> "C" {
__attribute__((no_instrument_function))
</span><span class="hljs-type"><span class="koboSpan" id="kobo.146.1">void</span></span><span class="koboSpan" id="kobo.147.1"> __cyg_profile_func_enter(</span><span class="hljs-type"><span class="koboSpan" id="kobo.148.1">void</span></span><span class="koboSpan" id="kobo.149.1"> *this_fn, </span><span class="hljs-type"><span class="koboSpan" id="kobo.150.1">void</span></span><span class="koboSpan" id="kobo.151.1"> *call_site)
{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.152.1">printf</span></span><span class="koboSpan" id="kobo.153.1">("entry, %p, %d", this_fn, DWT_CYCCNT);
}
__attribute__((no_instrument_function))
</span><span class="hljs-type"><span class="koboSpan" id="kobo.154.1">void</span></span><span class="koboSpan" id="kobo.155.1"> __cyg_profile_func_exit(</span><span class="hljs-type"><span class="koboSpan" id="kobo.156.1">void</span></span><span class="koboSpan" id="kobo.157.1"> *this_fn, </span><span class="hljs-type"><span class="koboSpan" id="kobo.158.1">void</span></span><span class="koboSpan" id="kobo.159.1"> *call_site)
{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.160.1">printf</span></span><span class="koboSpan" id="kobo.161.1">("</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.162.1">exit</span></span><span class="koboSpan" id="kobo.163.1">, %p, %d", this_fn, DWT_CYCCNT);
}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.164.1">The preceding implementation uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">extern</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.166.1">"C"</span></code><span class="koboSpan" id="kobo.167.1"> as a linkage language specifier for </span><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">entry</span></code><span class="koboSpan" id="kobo.169.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">exit</span></code><span class="koboSpan" id="kobo.171.1"> instrumentation functions as they are linked with C libraries by the compiler. </span><span class="koboSpan" id="kobo.171.2">The example also assumes that </span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">printf</span></code><span class="koboSpan" id="kobo.173.1"> is redirected to use ITM as output and that the cycle counter register in DWT is started.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.174.1">Another option is to use ITM’s timestamping and send both timestamps and function addresses from </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">entry</span></code><span class="koboSpan" id="kobo.176.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">exit</span></code><span class="koboSpan" id="kobo.178.1"> instrumentation functions. </span><span class="koboSpan" id="kobo.178.2">With the help of a linker map file, we can then </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.179.1">reconstruct the sequence of function calls and returns. </span><span class="koboSpan" id="kobo.179.2">There are specialized </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.180.1">formats for sending traces, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">Common Trace Format</span></strong><span class="koboSpan" id="kobo.182.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.183.1">CTF</span></strong><span class="koboSpan" id="kobo.184.1">), and desktop </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.185.1">tools called </span><strong class="keyWord"><span class="koboSpan" id="kobo.186.1">trace viewers</span></strong><span class="koboSpan" id="kobo.187.1"> that can allow us to streamline software instrumentation. </span><span class="koboSpan" id="kobo.187.2">CTF is an open format used to serialize an event </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.188.1">in a packet with one or more fields. </span><span class="koboSpan" id="kobo.188.2">Specialized tools, such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">barectf</span></strong><span class="koboSpan" id="kobo.190.1"> (</span><a href="https://barectf.org/docs/barectf/3.1/index.html"><span class="url"><span class="koboSpan" id="kobo.191.1">https://barectf.org/docs/barectf/3.1/index.html</span></span></a><span class="koboSpan" id="kobo.192.1">) are used to facilitate CTF packet generation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Events are </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.194.1">described using a </span><strong class="keyWord"><span class="koboSpan" id="kobo.195.1">YAML Ain’t Markup Language</span></strong><span class="koboSpan" id="kobo.196.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.197.1">YAML</span></strong><span class="koboSpan" id="kobo.198.1">) configuration file. </span><span class="koboSpan" id="kobo.198.2">A simple C library containing trace functions is generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">barectf</span></code><span class="koboSpan" id="kobo.200.1"> using the configuration file. </span><span class="koboSpan" id="kobo.200.2">These functions are used in source code in places where we want to emit traces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">CTF traces can be sent over different transport layers such as ITM or serial. </span><span class="koboSpan" id="kobo.201.2">Traces can be analyzed using tools such as Babeltrace (</span><a href="https://babeltrace.org"><span class="url"><span class="koboSpan" id="kobo.202.1">https://babeltrace.org</span></span></a><span class="koboSpan" id="kobo.203.1">) and TraceCompass (</span><a href="https://eclipse.dev/tracecompass"><span class="url"><span class="koboSpan" id="kobo.204.1">https://eclipse.dev/tracecompass</span></span></a><span class="koboSpan" id="kobo.205.1">). </span><span class="koboSpan" id="kobo.205.2">There are other tools that facilitate trace generation, transfer, and viewing such as SEGGER SystemView. </span><span class="koboSpan" id="kobo.205.3">On the target side, a small software module provided by SEGGER is included to make calls to tracing functions. </span><span class="koboSpan" id="kobo.205.4">Traces are sent </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.206.1">over SEGGER’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.207.1">Real Time Transfer</span></strong><span class="koboSpan" id="kobo.208.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.209.1">RTT</span></strong><span class="koboSpan" id="kobo.210.1">) protocol using SWD and analyzed in SystemView.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.211.1">We covered some basic approaches to A-B timing. </span><span class="koboSpan" id="kobo.211.2">There are more advanced techniques, and they often depend on the target capabilities, as there are some more advanced tracing units that can be utilized for A-B measurements.</span></p>
<h3 class="heading-3" id="_idParaDest-40"><span class="koboSpan" id="kobo.212.1">Determinism vs. </span><span class="koboSpan" id="kobo.212.2">Non-Determinism in Firmware</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.213.1">If we measure the duration of a function using the A-B timing approach and have the same duration and </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.214.1">function output for the same inputs, we say </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.215.1">that the function is </span><strong class="keyWord"><span class="koboSpan" id="kobo.216.1">deterministic</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">If a function </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.218.1">depends on a global state and the measured duration </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.219.1">is different for the same inputs, we say it is </span><strong class="keyWord"><span class="koboSpan" id="kobo.220.1">non-deterministic</span></strong><span class="koboSpan" id="kobo.221.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.222.1">Default dynamic memory allocators in C++ tend to be non-deterministic. </span><span class="koboSpan" id="kobo.222.2">The duration of allocation depends on the current global state of the allocator and the complexity of the allocating algorithm. </span><span class="koboSpan" id="kobo.222.3">We can measure duration for the same inputs with different global states, but it is hard to evaluate all possible global states and to guarantee the </span><strong class="keyWord"><span class="koboSpan" id="kobo.223.1">Worst-Case Execution Time</span></strong><span class="koboSpan" id="kobo.224.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.225.1">WCET</span></strong><span class="koboSpan" id="kobo.226.1">) with default allocators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.227.1">The non-deterministic </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.228.1">behavior of dynamic memory allocation is just one problem for safety-critical systems. </span><span class="koboSpan" id="kobo.228.2">The other problem is that it can fail. </span><span class="koboSpan" id="kobo.228.3">If there is no more available memory or if the memory is fragmented, then the allocation </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.229.1">can fail. </span><span class="koboSpan" id="kobo.229.2">This is why many </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.230.1">safety coding standards such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.231.1">Motor Industry Software Reliability Association</span></strong><span class="koboSpan" id="kobo.232.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.233.1">MISRA</span></strong><span class="koboSpan" id="kobo.234.1">) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.235.1">Automotive Open System Architecture</span></strong><span class="koboSpan" id="kobo.236.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.237.1">AUTOSAR</span></strong><span class="koboSpan" id="kobo.238.1">) discourage dynamic memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.239.1">We will explore dynamic memory management implications and safety-critical concerns next.</span></p>
<h1 class="heading-1" id="_idParaDest-41"><span class="koboSpan" id="kobo.240.1">Dynamic memory management</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.241.1">The C++ standard </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.242.1">defines the following storage durations for objects:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.243.1">Automatic storage duration</span></strong><span class="koboSpan" id="kobo.244.1">: Objects with automatic storage duration are automatically </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.245.1">created and </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.246.1">destroyed as the program enters and exits the block in which they are defined. </span><span class="koboSpan" id="kobo.246.2">These are typically local variables within functions, except those declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">static</span></code><span class="koboSpan" id="kobo.248.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">extern</span></code><span class="koboSpan" id="kobo.250.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">thread_local</span></code><span class="koboSpan" id="kobo.252.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.253.1">Static storage duration</span></strong><span class="koboSpan" id="kobo.254.1">: Objects with static storage duration are allocated when the program </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.255.1">starts and deallocated </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.256.1">when the program ends. </span><span class="koboSpan" id="kobo.256.2">All objects declared at the namespace scope (including the global namespace) have this static duration, plus those declared with </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">static</span></code><span class="koboSpan" id="kobo.258.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">extern</span></code><span class="koboSpan" id="kobo.260.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.261.1">Thread storage duration</span></strong><span class="koboSpan" id="kobo.262.1">: Introduced in C++11, objects with thread storage duration </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.263.1">are created and </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.264.1">destroyed with the thread in which they are defined, allowing each thread to have its own instance of a variable. </span><span class="koboSpan" id="kobo.264.2">They are declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">thread_local</span></code><span class="koboSpan" id="kobo.266.1"> specifier.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.267.1">Dynamic storage duration</span></strong><span class="koboSpan" id="kobo.268.1">: Objects </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.269.1">with dynamic </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.270.1">storage duration are explicitly created and destroyed using dynamic memory allocation functions (</span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">new</span></code><span class="koboSpan" id="kobo.272.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">delete</span></code><span class="koboSpan" id="kobo.274.1"> in C++), giving the software developer control over the lifetime of these objects.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.275.1">Dynamic storage gives great flexibility to a software developer, providing full control over an object’s lifetime. </span><span class="koboSpan" id="kobo.275.2">With great power comes great responsibility. </span><span class="koboSpan" id="kobo.275.3">Objects are dynamically allocated using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">new</span></code><span class="koboSpan" id="kobo.277.1"> operator and freed using </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">delete</span></code><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">Every object that is allocated dynamically </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.280.1">must be freed exactly once and should never be accessed after it has been freed. </span><span class="koboSpan" id="kobo.280.2">This is a straightforward rule but failing to follow it causes a range of problems, such as the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.281.1">Memory leaks occur when dynamically allocated memory is not freed properly. </span><span class="koboSpan" id="kobo.281.2">Over time, this unused memory accumulates potentially exhausting system resources.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.282.1">Dangling pointers happen when a pointer still references a memory location that has been freed. </span><span class="koboSpan" id="kobo.282.2">Accessing such a pointer leads to undefined behavior.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.283.1">Double free errors occur when memory that has already been freed is deleted again, leading to undefined behavior.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.284.1">Another problem with dynamic memory management is memory fragmentation.</span></p>
<h2 class="heading-2" id="_idParaDest-42"><span class="koboSpan" id="kobo.285.1">Memory fragmentation</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.286.1">Memory fragmentation</span></strong><span class="koboSpan" id="kobo.287.1"> occurs when free memory is divided into small, non-contiguous blocks </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.288.1">over time, making it difficult or impossible to allocate large blocks of </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.289.1">memory even when there is enough free memory available in total. </span><span class="koboSpan" id="kobo.289.2">There are two main types:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.290.1">External fragmentation</span></strong><span class="koboSpan" id="kobo.291.1">: This happens when there is enough total memory available </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.292.1">to satisfy an allocation </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.293.1">request but no single continuous block is large enough due to fragmentation. </span><span class="koboSpan" id="kobo.293.2">It’s common in systems where memory allocation and deallocation occur frequently, and sizes vary significantly.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.294.1">Internal fragmentation</span></strong><span class="koboSpan" id="kobo.295.1">: This occurs when allocated memory blocks are larger than the </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.296.1">requested memory, leading </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.297.1">to wasted space within allocated blocks. </span><span class="koboSpan" id="kobo.297.2">It happens when using allocators that have fixed-size memory blocks or memory pools and with allocators designed to give WCET.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.298.1">Memory fragmentation leads to inefficient memory use, reducing the performance or preventing further allocations resulting in out-of-memory scenarios, even when it appears that sufficient memory is available. </span><span class="koboSpan" id="kobo.298.2">Let’s visualize the memory region reserved for dynamic memory allocation in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.299.1"><img alt="Figure 2.2 – Memory region used for dynamic allocation" src="../Images/B22402_2_2.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.300.1">Figure 2</span></span><span class="koboSpan" id="kobo.301.1">.2 – Memory region used for dynamic allocation</span></p>
<p class="normal"><span class="koboSpan" id="kobo.302.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.303.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.304.1">.2</span></em><span class="koboSpan" id="kobo.305.1">, each block represents a memory unit allocated during the allocation process. </span><span class="koboSpan" id="kobo.305.2">Empty regions were not allocated, or they were freed using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">delete</span></code><span class="koboSpan" id="kobo.307.1"> operator. </span><span class="koboSpan" id="kobo.307.2">Even though there </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.308.1">is plenty of memory available, if there were a request for the allocation of four memory units, the allocation would fail, as there are not four continuous </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.309.1">memory blocks available due to memory fragmentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.310.1">Non-deterministic behavior of default memory allocators and out-of-memory scenarios are major concerns for safety-critical systems. </span><span class="koboSpan" id="kobo.310.2">MISRA and AUTOSAR provide coding guidelines for the use of C++ in safety-critical systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.311.1">MISRA is an organization that provides guidelines for the software developed for electronic components used in the automotive industry. </span><span class="koboSpan" id="kobo.311.2">It is a collaboration between vehicle manufacturers, component suppliers, and engineering consultancies. </span><span class="koboSpan" id="kobo.311.3">Standards produced by MISRA are also used in aerospace, defense, space, medical, and other industries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">AUTOSAR </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.313.1">is a global development partnership by automotive manufacturers, suppliers, and other companies from the </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.314.1">electronics, semiconductor, and software industries. </span><span class="koboSpan" id="kobo.314.2">AUTOSAR also produces guidelines for the use of C++ in critical and safety-related systems.</span></p>
<h2 class="heading-2" id="_idParaDest-43"><span class="koboSpan" id="kobo.315.1">Safety-critical guidelines for dynamic memory management in C++</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.316.1">MISRA </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.317.1">C++ 2008, which covers the C++03 standard, prohibits the usage of dynamic memory allocation, while AUTOSAR’s </span><em class="italic"><span class="koboSpan" id="kobo.318.1">Guidelines for the use of the C++14 language in critical and safety-related systems</span></em><span class="koboSpan" id="kobo.319.1"> specifies, among others, the following rules:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.320.1">Rule A18-5-5 (required, toolchain, partially automated)</span></li>
</ul>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.321.1">“Memory management functions shall ensure the following: (a) deterministic behavior resulting with the existence of worst-case execution time, (b) avoiding memory fragmentation, (c) avoid running out of memory, (d) avoiding mismatched allocations or deallocations, (e) no dependence on non-deterministic calls to kernel.”</span></p>
</blockquote>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.322.1">Rule A18-5-6 (required, verification / toolchain, non-automated)</span></li>
</ul>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.323.1"> “An analysis shall be performed to analyze the failure modes of dynamic memory management. </span><span class="koboSpan" id="kobo.323.2">In particular, the following failure modes shall be analyzed: (a) non-deterministic behavior resulting with nonexistence of worst-case execution time, (b) memory fragmentation, (c) running out of memory, (d) mismatched allocations and deallocations, (e) dependence on non-deterministic calls to kernel.”</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.324.1">Now, following these two rules to the letter is an extremely hard task. </span><span class="koboSpan" id="kobo.324.2">We can write a custom allocator that has deterministic WCET and minimizes fragmentation, but how do we write an allocator that avoids running out of memory? </span><span class="koboSpan" id="kobo.324.3">Or, in case it happens, how do we ensure the non-failure of the system? </span><span class="koboSpan" id="kobo.324.4">Every call to the allocator would need to verify the success of the operation and, in case of failure, somehow mitigate it. </span><span class="koboSpan" id="kobo.324.5">Or we would need to be able to estimate the amount of memory needed for an allocator accurately, so it doesn’t run out of memory in runtime under any circumstances. </span><span class="koboSpan" id="kobo.324.6">This adds a whole new layer of complexity to our software design and adds more complexity than we would add value by allowing dynamic memory allocation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.325.1">An in-between approach to dynamic memory allocation policy is to allow it on startup, but not when the system is running. </span><span class="koboSpan" id="kobo.325.2">This is the policy used by </span><strong class="keyWord"><span class="koboSpan" id="kobo.326.1">Joint Strike Fighter Air Vehicle C++ Coding Standards</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">MISRA C++ 2023 also advises against the usage of dynamic memory allocation when the system is running, and as a mitigation policy, recommends using it at startup.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.328.1">The C++ standard library uses dynamic memory allocation heavily. </span><span class="koboSpan" id="kobo.328.2">Exception handling mechanism implementations also often use dynamic allocation. </span><span class="koboSpan" id="kobo.328.3">Before dismissing the idea of using the standard library in embedded projects, let’s discover the internal workings of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">std::vector</span></code><span class="koboSpan" id="kobo.330.1"> container and see what C++ offers to mitigate our concerns.</span></p>
<h2 class="heading-2" id="_idParaDest-44"><span class="koboSpan" id="kobo.331.1">Dynamic memory management in the C++ standard library</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.332.1">We introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">std::vector</span></code><span class="koboSpan" id="kobo.334.1"> as a container from the standard library that uses dynamic memory </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.335.1">allocation. </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">vector</span></code><span class="koboSpan" id="kobo.337.1"> is a template class, and we can specify the underlying type. </span><span class="koboSpan" id="kobo.337.2">It stores the elements contiguously, and we can get direct access to the underlying contiguous storage using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">data</span></code><span class="koboSpan" id="kobo.339.1"> method. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.340.1">The following code example demonstrates the usage of a vector:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.341.1">  std::vector&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.342.1">uint8_t</span></span><span class="koboSpan" id="kobo.343.1">&gt; vec;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">constexpr</span></span><span class="koboSpan" id="kobo.345.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.346.1">size_t</span></span><span class="koboSpan" id="kobo.347.1"> n_elem = </span><span class="hljs-number"><span class="koboSpan" id="kobo.348.1">8</span></span><span class="koboSpan" id="kobo.349.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.350.1">for</span></span><span class="koboSpan" id="kobo.351.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.352.1">uint8_t</span></span><span class="koboSpan" id="kobo.353.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.354.1">0</span></span><span class="koboSpan" id="kobo.355.1">; i &lt; n_elem; i++) {
    vec.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.356.1">push_back</span></span><span class="koboSpan" id="kobo.357.1">(i);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.358.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.359.1">auto</span></span><span class="koboSpan" id="kobo.360.1"> print_array = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.361.1">uint8_t</span></span><span class="koboSpan" id="kobo.362.1"> *arr, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.363.1">size_t</span></span><span class="koboSpan" id="kobo.364.1"> n) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.365.1">for</span></span><span class="koboSpan" id="kobo.366.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.367.1">size_t</span></span><span class="koboSpan" id="kobo.368.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.369.1">0</span></span><span class="koboSpan" id="kobo.370.1">; i &lt; n; i++) {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.371.1">printf</span></span><span class="koboSpan" id="kobo.372.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.373.1">"%d "</span></span><span class="koboSpan" id="kobo.374.1">, arr[i]);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.375.1">printf</span></span><span class="koboSpan" id="kobo.376.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.377.1">"\r\n"</span></span><span class="koboSpan" id="kobo.378.1">);
  };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.379.1">print_array</span></span><span class="koboSpan" id="kobo.380.1">(vec.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.381.1">data</span></span><span class="koboSpan" id="kobo.382.1">(), n_elem);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.383.1">We created a vector with the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">uint8_t</span></code><span class="koboSpan" id="kobo.385.1"> type and added values from </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">0</span></code><span class="koboSpan" id="kobo.387.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">8</span></code><span class="koboSpan" id="kobo.389.1"> using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">push_back</span></code><span class="koboSpan" id="kobo.391.1"> method. </span><span class="koboSpan" id="kobo.391.2">The example also demonstrates access to a pointer to the underlying contiguous storage, which we provided as an argument to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">print_array</span></code><span class="koboSpan" id="kobo.393.1"> lambda.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">The usual allocation strategy of </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">vector</span></code><span class="koboSpan" id="kobo.396.1"> is to allocate one element on the first insertion, then double it each time it reaches its capacity. </span><span class="koboSpan" id="kobo.396.2">Storing values for </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">0</span></code><span class="koboSpan" id="kobo.398.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">8</span></code><span class="koboSpan" id="kobo.400.1"> would result in 4 allocation requests, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.401.1"><img alt="Figure 2.3 – Vector allocation requests" src="../Images/B22402_2_3.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.402.1">Figure 2</span></span><span class="koboSpan" id="kobo.403.1">.3 – Vector allocation requests</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.404.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.405.1">.3</span></em><span class="koboSpan" id="kobo.406.1"> depicts the vector’s allocation requests. </span><span class="koboSpan" id="kobo.406.2">In order to inspect vector implementation on any </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.407.1">platform, we can overload the </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">new</span></code><span class="koboSpan" id="kobo.409.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">delete</span></code><span class="koboSpan" id="kobo.411.1"> operators and monitor the allocation requests:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.412.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.413.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.415.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.416.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.417.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.418.1"> count)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.419.1">{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.420.1">printf</span></span><span class="koboSpan" id="kobo.421.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.422.1">"%s, size = %ld\r\n"</span></span><span class="koboSpan" id="kobo.423.1">, __PRETTY_FUNCTION__, count);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.424.1">return</span></span><span class="koboSpan" id="kobo.425.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.426.1">malloc</span></span><span class="koboSpan" id="kobo.427.1">(count);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.428.1">void</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.429.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.430.1">delete</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.431.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.432.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1"> *ptr)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.434.1">noexcept</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.435.1">{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.436.1">printf</span></span><span class="koboSpan" id="kobo.437.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.438.1">"%s\r\n"</span></span><span class="koboSpan" id="kobo.439.1">, __PRETTY_FUNCTION__);
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.440.1">free</span></span><span class="koboSpan" id="kobo.441.1">(ptr);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.442.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">new</span></code><span class="koboSpan" id="kobo.444.1"> overloaded operator passes allocation calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">malloc</span></code><span class="koboSpan" id="kobo.446.1">, and it prints out the size requested by the caller. </span><span class="koboSpan" id="kobo.446.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">delete</span></code><span class="koboSpan" id="kobo.448.1"> overloaded operator just prints out the function signature so we can see when it is called. </span><span class="koboSpan" id="kobo.448.2">Some standard library implementations using GCC implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">new</span></code><span class="koboSpan" id="kobo.450.1"> operator using </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">malloc</span></code><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">Our vector allocation calls will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.453.1">void* operator new(std::size_t), size = 1
void* operator new(std::size_t), size = 2
void operator delete(void*)
void* operator new(std::size_t), size = 4
void operator delete(void*)
void* operator new(std::size_t), size = 8
void operator delete(void*)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.454.1">The preceding results are obtained using the GCC compiler, and they are the same both for x86_64 and Arm Cortex-M4 platforms. </span><span class="koboSpan" id="kobo.454.2">When the vector fills the available memory, it requests allocation of the doubled amount of currently used memory. </span><span class="koboSpan" id="kobo.454.3">It then copies data from the original storage to newly acquired memory. </span><span class="koboSpan" id="kobo.454.4">Afterward, it deletes previously used storage, as we </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.455.1">can see from the preceding generated output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.456.1">Overloading the </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">new</span></code><span class="koboSpan" id="kobo.458.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">delete</span></code><span class="koboSpan" id="kobo.460.1"> operators would allow us to change the allocation mechanism globally, in order to meet the safety-critical guidelines requesting for deterministic WTEC and avoiding out-of-memory scenarios, which is quite challenging.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.461.1">The allocation requests from the vector can be optimized by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">reserve</span></code><span class="koboSpan" id="kobo.463.1"> method if the number of elements is known beforehand:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.464.1">  vec.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.465.1">reserve</span></span><span class="koboSpan" id="kobo.466.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.467.1">8</span></span><span class="koboSpan" id="kobo.468.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.469.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">reserve</span></code><span class="koboSpan" id="kobo.471.1"> method will make the vector request eight elements, and it will ask for more memory only if we go beyond eight elements. </span><span class="koboSpan" id="kobo.471.2">This makes it useful for projects that allow dynamic allocation at startup if we can guarantee that the number of elements at any point will stay within reserved memory. </span><span class="koboSpan" id="kobo.471.3">If we add a ninth element to the vector, it will make another allocation request, requesting the memory to fit 16 elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.472.1">The C++ standard library also makes possible usage of local allocators for containers. </span><span class="koboSpan" id="kobo.472.2">Let’s take a look at the vector’s declaration:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.473.1">template</span></span><span class="koboSpan" id="kobo.474.1">&lt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.475.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.476.1">T</span></span><span class="koboSpan" id="kobo.477.1">,
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.478.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.479.1">Allocator</span></span><span class="koboSpan" id="kobo.480.1"> = std::allocator&lt;T&gt;
&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.481.1">class</span></span><span class="koboSpan" id="kobo.482.1"> vector;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.483.1">We can see that the second template parameter is </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">Allocator</span></code><span class="koboSpan" id="kobo.485.1">, and the default argument is </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">std::allocator</span></code><span class="koboSpan" id="kobo.487.1">, which uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">new</span></code><span class="koboSpan" id="kobo.489.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">delete</span></code><span class="koboSpan" id="kobo.491.1"> operators. </span><span class="koboSpan" id="kobo.491.2">C++17 introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">std::pmr::polymorphic_allocator</span></code><span class="koboSpan" id="kobo.493.1">, an allocator that exhibits different allocation behavior depending upon the </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">std::pmr::memory_resource</span></code><span class="koboSpan" id="kobo.495.1"> type from which it is constructed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.496.1">There is a memory resource that can be constructed by providing it with an initial, statically allocated buffer, and it’s called </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">std::pmr::monotonic_buffer_resource</span></code><span class="koboSpan" id="kobo.498.1">. </span><span class="koboSpan" id="kobo.498.2">The monotonic buffer is built for performance, and it releases memory only when it is destroyed. </span><span class="koboSpan" id="kobo.498.3">Initializing it with a statically allocated buffer makes it suitable for embedded applications. </span><span class="koboSpan" id="kobo.498.4">Let’s see how we can use it for a vector:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.499.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.500.1">namespace</span></span><span class="koboSpan" id="kobo.501.1"> std;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.502.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.503.1">namespace</span></span><span class="koboSpan" id="kobo.504.1"> std::pmr;
  array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.505.1">uint8_t</span></span><span class="koboSpan" id="kobo.506.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.507.1">sizeof</span></span><span class="koboSpan" id="kobo.508.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.509.1">uint8_t</span></span><span class="koboSpan" id="kobo.510.1">) * 8&gt; buffer{</span><span class="hljs-number"><span class="koboSpan" id="kobo.511.1">0</span></span><span class="koboSpan" id="kobo.512.1">};
  monotonic_buffer_resource mbr{buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.513.1">data</span></span><span class="koboSpan" id="kobo.514.1">(), buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">size</span></span><span class="koboSpan" id="kobo.516.1">()};
  polymorphic_allocator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.517.1">uint8_t</span></span><span class="koboSpan" id="kobo.518.1">&gt; pa{&amp;mbr};
  std::pmr::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.519.1">uint8_t</span></span><span class="koboSpan" id="kobo.520.1">&gt; vec{pa};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.521.1">In the preceding example, we do the following:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.522.1">Create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">std::array</span></code><span class="koboSpan" id="kobo.524.1"> container, with an underlying type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">uint8_t</span></code><span class="koboSpan" id="kobo.526.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.527.1">Construct a monotonic buffer and provide it with the array we just created as the initial buffer.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.528.1">Use the monotonic buffer to create a polymorphic allocator, which we use to create a vector.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.529.1">Please note </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.530.1">that the vector is from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">std::pmr</span></code><span class="koboSpan" id="kobo.532.1"> namespace, and it’s just a partial specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">std::vector</span></code><span class="koboSpan" id="kobo.534.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.535.1">namespace</span></span><span class="koboSpan" id="kobo.536.1"> pmr {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.537.1">template</span></span><span class="koboSpan" id="kobo.538.1">&lt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.540.1">T</span></span><span class="koboSpan" id="kobo.541.1"> &gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.542.1">using</span></span><span class="koboSpan" id="kobo.543.1"> vector = std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.544.1">A vector created by utilizing a monotonic buffer will allocate memory in the space provided by the buffer. </span><span class="koboSpan" id="kobo.544.2">Let’s examine the behavior of such a vector in the following example built from the previously explained code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.545.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.546.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.547.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.548.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.550.1">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.551.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.552.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.553.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.554.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.555.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.556.1">&lt;memory_resource&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.557.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.559.1">&lt;vector&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.560.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.562.1">&lt;new&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.563.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.564.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.566.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.567.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.568.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.569.1"> count, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.570.1">align_val_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.571.1"> al)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.572.1">{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.573.1">printf</span></span><span class="koboSpan" id="kobo.574.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.575.1">"%s, size = %ld\r\n"</span></span><span class="koboSpan" id="kobo.576.1">, __PRETTY_FUNCTION__, count);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.577.1">return</span></span><span class="koboSpan" id="kobo.578.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.579.1">malloc</span></span><span class="koboSpan" id="kobo.580.1">(count);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.581.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.582.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.583.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.584.1">{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.585.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">namespace</span></span><span class="koboSpan" id="kobo.587.1"> std;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">namespace</span></span><span class="koboSpan" id="kobo.590.1"> std::pmr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.592.1">size_t</span></span><span class="koboSpan" id="kobo.593.1"> n_elem = </span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">8</span></span><span class="koboSpan" id="kobo.595.1">;
  array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.596.1">uint8_t</span></span><span class="koboSpan" id="kobo.597.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">sizeof</span></span><span class="koboSpan" id="kobo.599.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.600.1">uint8_t</span></span><span class="koboSpan" id="kobo.601.1">) * 8&gt; buffer{</span><span class="hljs-number"><span class="koboSpan" id="kobo.602.1">0</span></span><span class="koboSpan" id="kobo.603.1">};
  monotonic_buffer_resource mbr{buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.604.1">data</span></span><span class="koboSpan" id="kobo.605.1">(), buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.606.1">size</span></span><span class="koboSpan" id="kobo.607.1">()};
  polymorphic_allocator&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.608.1">uint8_t</span></span><span class="koboSpan" id="kobo.609.1">&gt; pa{&amp;mbr};
  std::pmr::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.610.1">uint8_t</span></span><span class="koboSpan" id="kobo.611.1">&gt; vec{pa};
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.612.1">//vec.reserve(n_elem);</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.613.1">for</span></span><span class="koboSpan" id="kobo.614.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.615.1">uint8_t</span></span><span class="koboSpan" id="kobo.616.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.617.1">0</span></span><span class="koboSpan" id="kobo.618.1">; i &lt; n_elem; i++) {
    vec.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.619.1">push_back</span></span><span class="koboSpan" id="kobo.620.1">(i);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.621.1">for</span></span><span class="koboSpan" id="kobo.622.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.623.1">uint8_t</span></span><span class="koboSpan" id="kobo.624.1"> data : buffer) {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.625.1">printf</span></span><span class="koboSpan" id="kobo.626.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.627.1">"%d "</span></span><span class="koboSpan" id="kobo.628.1">, data);
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.629.1">printf</span></span><span class="koboSpan" id="kobo.630.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.631.1">"\r\n"</span></span><span class="koboSpan" id="kobo.632.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.634.1">0</span></span><span class="koboSpan" id="kobo.635.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.636.1">The preceding </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.637.1">program will provide the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.638.1">void* operator new(std::size_t, std::align_val_t), size = 64
0 0 1 0 1 2 3 0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.639.1">We see that even though we used the monotonic buffer, the program called the </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">new</span></code><span class="koboSpan" id="kobo.641.1"> operator. </span><span class="koboSpan" id="kobo.641.2">You can notice that the call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">reserve</span></code><span class="koboSpan" id="kobo.643.1"> method is commented. </span><span class="koboSpan" id="kobo.643.2">This will result in a vector-expanding strategy, as described previously. </span><span class="koboSpan" id="kobo.643.3">When the monotonic buffer initial memory is used, it will fall to the upstream memory resource pointer. </span><span class="koboSpan" id="kobo.643.4">The default upstream memory resource will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">new</span></code><span class="koboSpan" id="kobo.645.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">delete</span></code><span class="koboSpan" id="kobo.647.1"> operators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.648.1">If we print the buffer used as initial storage for </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">monotonic_buffer_resource</span></code><span class="koboSpan" id="kobo.650.1">, we can see that the vector is allocating the first element and storing </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">0</span></code><span class="koboSpan" id="kobo.652.1"> to it, then it doubles it and stores </span><code class="inlineCode"><span class="koboSpan" id="kobo.653.1">0</span></code><span class="koboSpan" id="kobo.654.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">1</span></code><span class="koboSpan" id="kobo.656.1">, and then doubles it again, storing </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">0</span></code><span class="koboSpan" id="kobo.658.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">1</span></code><span class="koboSpan" id="kobo.660.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">2</span></code><span class="koboSpan" id="kobo.662.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">3</span></code><span class="koboSpan" id="kobo.664.1">. </span><span class="koboSpan" id="kobo.664.2">When it tries to double it again, the monotonic buffer will not be able to meet the allocation request and will fall to using the default allocator, which relies on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">new</span></code><span class="koboSpan" id="kobo.666.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">delete</span></code><span class="koboSpan" id="kobo.668.1"> operators. </span><span class="koboSpan" id="kobo.668.2">We can visualize this in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.669.1"><img alt="Figure 2.4 – State of the buffer used by the monotonic buffer resource" src="../Images/B22402_2_4.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.670.1">Figure 2</span></span><span class="koboSpan" id="kobo.671.1">.4 – State of the buffer used by the monotonic buffer resource</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.672.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.673.1">.4</span></em><span class="koboSpan" id="kobo.674.1"> depicts the internal state of the used by the monotonic buffer resource. </span><span class="koboSpan" id="kobo.674.2">We can see that the monotonic buffer resource is not deallocating memory in any way. </span><span class="koboSpan" id="kobo.674.3">On an allocation buffer request, it returns a pointer to the last available element in the initial buffer if there is enough space in the buffer to fit the requested number of elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">You will notice </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.676.1">that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">new</span></code><span class="koboSpan" id="kobo.678.1"> operator used in this example has a different signature from the one previously used. </span><span class="koboSpan" id="kobo.678.2">Actually, the standard library defines different versions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">new</span></code><span class="koboSpan" id="kobo.680.1"> and matching </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">delete</span></code><span class="koboSpan" id="kobo.682.1"> operators, and it’s hard to tell which version is used by a container from the standard library without inspection. </span><span class="koboSpan" id="kobo.682.2">This makes overloading them globally and replacing implementation with a custom one even more challenging, making a local allocator usually a better choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.683.1">The polymorphic allocator utilizing a monotonic buffer initialized with a buffer on the stack may be a good option to mitigate some of the issues imposed by the dynamic memory management when working with containers from the standard C++ library. </span><span class="koboSpan" id="kobo.683.2">The approach we demonstrated on the vector can be used on other containers from standard libraries, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">list</span></code><span class="koboSpan" id="kobo.685.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">map</span></code><span class="koboSpan" id="kobo.687.1">, but also other types from the library, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.688.1">basic_string</span></code><span class="koboSpan" id="kobo.689.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.690.1">Mitigating concerns of dynamic memory allocation is possible but it still poses some challenges. </span><span class="koboSpan" id="kobo.690.2">If you want to be absolutely sure that your C++ program is not calling a </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">new</span></code><span class="koboSpan" id="kobo.692.1"> operator, there are means to ensure it. </span><span class="koboSpan" id="kobo.692.2">Let us explore how we can disable unwanted C++ features.</span></p>
<h1 class="heading-1" id="_idParaDest-45"><span class="koboSpan" id="kobo.693.1">Disabling unwanted C++ features</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.694.1">You may have noticed that we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">printf</span></code><span class="koboSpan" id="kobo.696.1"> from the C standard library for printing debug information on </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.697.1">standard output instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.698.1">std::cout</span></code><span class="koboSpan" id="kobo.699.1"> from the C++ standard library. </span><span class="koboSpan" id="kobo.699.2">The reason is twofold – the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">std::cout</span></code><span class="koboSpan" id="kobo.701.1"> global object from </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">ostream</span></code><span class="koboSpan" id="kobo.703.1"> has a large memory footprint and it uses dynamic memory allocation. </span><span class="koboSpan" id="kobo.703.2">C++ works well with the C standard library, and using </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">printf</span></code><span class="koboSpan" id="kobo.705.1"> is a good alternative for resource-constrained systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.706.1">We already discussed the exception handling mechanism, which often relies on dynamic memory allocation. </span><span class="koboSpan" id="kobo.706.2">Disabling exceptions in C++ is as easy as passing the appropriate flag to the compiler. </span><span class="koboSpan" id="kobo.706.3">In the </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.707.1">case of GCC, that flag is </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">–fno-exceptions</span></code><span class="koboSpan" id="kobo.709.1">. </span><span class="koboSpan" id="kobo.709.2">The same goes for </span><strong class="keyWord"><span class="koboSpan" id="kobo.710.1">Run-Time Type Information</span></strong><span class="koboSpan" id="kobo.711.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.712.1">RTTI</span></strong><span class="koboSpan" id="kobo.713.1">). </span><span class="koboSpan" id="kobo.713.2">We can disable it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">–fno-rtti</span></code><span class="koboSpan" id="kobo.715.1"> flag.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.716.1">Disabling exceptions will result in calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">std::terminate</span></code><span class="koboSpan" id="kobo.718.1"> when an exception is thrown. </span><span class="koboSpan" id="kobo.718.2">We can replace </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.719.1">the default terminate handler with our own implementation and handle it appropriately, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.720.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.722.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.723.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.724.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.725.1">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.726.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.727.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.728.1">&lt;exception&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.729.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.730.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.731.1">&lt;array&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.732.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.733.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.734.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.735.1">{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">auto</span></span><span class="koboSpan" id="kobo.738.1"> my_terminate_handler = []() {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.739.1">printf</span></span><span class="koboSpan" id="kobo.740.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.741.1">"This is my_terminate_handler\r\n"</span></span><span class="koboSpan" id="kobo.742.1">);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.743.1">abort</span></span><span class="koboSpan" id="kobo.744.1">();
  };
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.745.1">set_terminate</span></span><span class="koboSpan" id="kobo.746.1">(my_terminate_handler);
  std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.747.1">int</span></span><span class="koboSpan" id="kobo.748.1">, 4&gt; arr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.749.1">for</span></span><span class="koboSpan" id="kobo.750.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.751.1">int</span></span><span class="koboSpan" id="kobo.752.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.753.1">0</span></span><span class="koboSpan" id="kobo.754.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.755.1">5</span></span><span class="koboSpan" id="kobo.756.1">; i++) {
   arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.757.1">at</span></span><span class="koboSpan" id="kobo.758.1">(i) = i;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.760.1">0</span></span><span class="koboSpan" id="kobo.761.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.762.1">The preceding example demonstrates setting the terminate handler using </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">std::set_terminate</span></code><span class="koboSpan" id="kobo.764.1"> by our own implementation. </span><span class="koboSpan" id="kobo.764.2">This allows us to handle cases that shouldn’t happen in runtime and try to recover from them or gracefully terminate them. </span><span class="koboSpan" id="kobo.764.3">Some features or behaviors in C++ can’t be disabled by compiler flags, but there are other means to handle them,</span></p>
<p class="normal"><span class="koboSpan" id="kobo.765.1">As we saw previously, we can redefine global </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">new</span></code><span class="koboSpan" id="kobo.767.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">delete</span></code><span class="koboSpan" id="kobo.769.1"> operators. </span><span class="koboSpan" id="kobo.769.2">We can also delete them, which will make the compilation fail if we use a software component that calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">new</span></code><span class="koboSpan" id="kobo.771.1">, effectively allowing us to prevent any attempts of dynamic memory allocation if needed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.772.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.773.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.774.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.775.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.777.1">&lt;vector&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.778.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.779.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.780.1">&lt;new&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.781.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.782.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.783.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.784.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.785.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.786.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.787.1"> count)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.788.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">delete</span></span><span class="koboSpan" id="kobo.790.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.791.1">void</span></span><span class="koboSpan" id="kobo.792.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.793.1">operator</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.794.1">new</span></span><span class="koboSpan" id="kobo.795.1">[](std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.796.1">size_t</span></span><span class="koboSpan" id="kobo.797.1"> count) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.798.1">delete</span></span><span class="koboSpan" id="kobo.799.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.800.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.801.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.802.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.803.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.804.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.805.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.806.1"> count, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.807.1">align_val_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.808.1"> al)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.809.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.810.1">delete</span></span><span class="koboSpan" id="kobo.811.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.812.1">void</span></span><span class="koboSpan" id="kobo.813.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">operator</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.815.1">new</span></span><span class="koboSpan" id="kobo.816.1">[](std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.817.1">size_t</span></span><span class="koboSpan" id="kobo.818.1"> count, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.819.1">align_val_t</span></span><span class="koboSpan" id="kobo.820.1"> al) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.821.1">delete</span></span><span class="koboSpan" id="kobo.822.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.823.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.824.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.826.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.827.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.828.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.829.1"> count, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.830.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.831.1"> std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.832.1">nothrow_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.833.1"> &amp;tag)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.834.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">delete</span></span><span class="koboSpan" id="kobo.836.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.837.1">void</span></span><span class="koboSpan" id="kobo.838.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">operator</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.840.1">new</span></span><span class="koboSpan" id="kobo.841.1">[](std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.842.1">size_t</span></span><span class="koboSpan" id="kobo.843.1"> count, </span><span class="hljs-type"><span class="koboSpan" id="kobo.844.1">const</span></span><span class="koboSpan" id="kobo.845.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.846.1">nothrow_t</span></span><span class="koboSpan" id="kobo.847.1"> &amp;tag) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.848.1">delete</span></span><span class="koboSpan" id="kobo.849.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.850.1">void</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.851.1"> *</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.852.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.853.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.854.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.855.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.856.1"> count, std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.857.1">align_val_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.858.1"> al, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.859.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.860.1"> std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.861.1">nothrow_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.862.1"> &amp;)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.863.1">= </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.864.1">delete</span></span><span class="koboSpan" id="kobo.865.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.866.1">void</span></span><span class="koboSpan" id="kobo.867.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">operator</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.869.1">new</span></span><span class="koboSpan" id="kobo.870.1">[](std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.871.1">size_t</span></span><span class="koboSpan" id="kobo.872.1"> count, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.873.1">align_val_t</span></span><span class="koboSpan" id="kobo.874.1"> al,</span><span class="hljs-type"><span class="koboSpan" id="kobo.875.1">const</span></span><span class="koboSpan" id="kobo.876.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.877.1">nothrow_t</span></span><span class="koboSpan" id="kobo.878.1"> &amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.879.1">delete</span></span><span class="koboSpan" id="kobo.880.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.881.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.882.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.883.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.884.1">{
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.885.1">int</span></span><span class="koboSpan" id="kobo.886.1">&gt; vec;
  vec.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.887.1">push_back</span></span><span class="koboSpan" id="kobo.888.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.889.1">123</span></span><span class="koboSpan" id="kobo.890.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.891.1">printf</span></span><span class="koboSpan" id="kobo.892.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.893.1">"vec[0] = %d\r\n"</span></span><span class="koboSpan" id="kobo.894.1">, vec[</span><span class="hljs-number"><span class="koboSpan" id="kobo.895.1">0</span></span><span class="koboSpan" id="kobo.896.1">]);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.897.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.898.1">0</span></span><span class="koboSpan" id="kobo.899.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.900.1">The preceding </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.901.1">example will fail with the following compiler message (among others):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.902.1">/usr/include/c++/13/bits/new_allocator.h:143:59: error: use of deleted function 'void* operator new(std::size_t, std::align_val_t)'
  143 |             return static_cast&lt;_Tp*&gt;(_GLIBCXX_OPERATOR_NEW (__n * sizeof(_Tp),
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.903.1">By deleting </span><code class="inlineCode"><span class="koboSpan" id="kobo.904.1">new</span></code><span class="koboSpan" id="kobo.905.1"> operators, we can make the compilation of a C++ program that is trying to use dynamic memory management fail. </span><span class="koboSpan" id="kobo.905.2">This is useful if we want to be sure our program is not using dynamic memory management.</span></p>
<h1 class="heading-1" id="_idParaDest-46"><span class="koboSpan" id="kobo.906.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.907.1">C++ allows a great degree of flexibility. </span><span class="koboSpan" id="kobo.907.2">Resource-constrained embedded systems and safety-critical guidelines can impose some limitations on the usage of certain C++ features, such as exception handling, RTTI, and the usage of dynamic memory allocation by containers and other modules from the standard C++ library. </span><span class="koboSpan" id="kobo.907.3">C++ acknowledges those concerns and provides mechanisms for disabling unwanted features. </span><span class="koboSpan" id="kobo.907.4">In this chapter, we learned about different strategies for mitigating concerns of dynamic memory allocation by means of local allocators and overloading global </span><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">new</span></code><span class="koboSpan" id="kobo.909.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.910.1">delete</span></code><span class="koboSpan" id="kobo.911.1"> operators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.912.1">The learning curve is steep but worth the effort, so let’s continue our journey of discovering C++ in embedded systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">In the next chapter, we will explore the C++ ecosystem for embedded development.</span></p>
</div>
</body></html>