<html><head></head><body>
        

                            
                    <h1 class="header-title">Inventory and Weapons for the Player</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Welcome to our next chapter. In this chapter, we will build upon the Mastering project as it stands so far with a brand new system for handling the inventory and changing weapons. Wherever possible, any hardcoded types of systems will also be removed at this point, such as referencing assets by name from C++. When making such changes, there will typically be an accompanying discussion of why this is important to a given project. By the end of this chapter, though, we should be referencing all of our classes and assets in an easy-to-modify way, and have a very fast iteration time, changing things like adding new weapons and weapon pick-ups. In order, we will cover the following topics:</p>
<ul>
<li>Adding a <kbd>Weapon</kbd> class</li>
<li>Inventory for weapons in C++</li>
<li>Creating and using a <kbd>WeaponPickup</kbd> class</li>
<li>Cycling weapons with new control bindings</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>All requirements found in <a href="dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml">Chapter 1</a>, <em>Making a C++ Project for a First-Person Shooter</em>, including its output Mastering project or one at a similar point of development, are required for this chapter.</p>
<p>Following our chapter progress branching theme, the GitHub work done in this chapter can be found here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-2</a></p>
<p>Engine Version used: 4.19.0.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the Weapon and Inventory classes</h1>
                
            
            
                
<p>Our goal for this section is to add these two new classes to our game and convert the hardcoded weapon template made for us into the new weapon class and add it to our new inventory class for our player. We will start with the editor running and take a moment to examine the existing weapon and see how it was made in the template, as a means to gather the information needed for designing and implementing this new weapon class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our Weapon class</h1>
                
            
            
                
<p>While the FPS template gives a great jump-start to a project like this, it's very limited in a number of ways. It is intended to be the most minimal and agnostic implementation allowing us, the developers, to build in whatever direction is needed. As a theme throughout our improvements and expansion of this game project, as our needs for new systems and features arise, this is the motivation for our work. While the very simple weapon the template implements demonstrates all the core pieces of an FPS weapon, it is not at all easily modified, so thus, we need a new class. In a typical FPS game you are often switching between multiple unique weapons on a character, so we will make that possible step-by-step here.</p>
<p>To first see how the existing weapon was made, we need to open up Content | FirstPersonCPP | Blueprints | FirstPersonCharacter again in the Content Browser, and if you are re-opening it, click on the Open Full Blueprint Editor option again. In the main window, click the Viewport tab and as you click on some of these other items, you can see how they are shown or represented currently in the blueprint as it stands. The first thing to click, however, is in the Components tab, the very first item you can select, FirstPersonCharacter(self). This is the overall class used for our player currently, and if you picked up where we left off in the previous chapter, is currently set to the <kbd>StealthCaracter</kbd> class, which is derived from our <kbd>MasteringCharacter</kbd> of course. Upon selecting that in the Components tab, you can see on the right in the Details tab you can see several variables under the Gameplay and Projectile fly-outs that we are going to want to move to the new weapon class:</p>
<div><img src="img/d942fe01-f40c-424c-849e-cf19799a4d32.png"/></div>
<p>The Gun Offset, Fire Sound, Fire Animation, and the Projectile Class should all be moved into our new class as, of course, these will naturally vary from weapon to weapon. Looking back to the Components tab, you can also see there is an FP_Gun (Inherited) component, and under it, an FPMuzzleLocation (Inherited) component. These are a Skeletal Mesh Component and simple Scene Component, respectively, but also belong with the weapon and not with our character here directly.</p>
<p>So, back to the main editor window and the Content Browser, let's use the shortcut mentioned in <a href="dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml" target="_blank">Chapter 1</a>, <em>Making a C++ Project for a First-Person Shooter</em>, and right-click in the main window to get the popup with New C++ Class near the top and add one. In this case, we want the parent class to simply be Actor, so for once we don't need to click the Show all classes option. Select it and then click Next as before. Here, we'll name the class <kbd>MasteringWeapon</kbd>, and click Create Class. And once more we'll get a hot-reload. Once that finishes, it's back to Visual Studio to add all the variables mentioned earlier that our new weapons will need.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting the existing gun</h1>
                
            
            
                
<p>Opening up <kbd>MasteringWeapon.h</kbd> and <kbd>.cpp</kbd>, let's add some variables as <kbd>UPROPERTY</kbd> items again, and our goal now is to replicate what is currently done in <kbd>MasteringCharacter</kbd> in our weapon and then remove those items from the character class. As a reminder, the things our weapon needs to contain are as follows:</p>
<ul>
<li>Gun Offset (<kbd>FVector</kbd>)</li>
<li>Fire Sound (<kbd>USoundBase</kbd>)</li>
<li>Fire Animation (<kbd>UAnimMontage</kbd>)</li>
<li>Projectile Class (<kbd>TSubclassOf&lt;class AMasteringProjectile&gt;</kbd>)</li>
<li>Weapon Mesh (<kbd>USkeletalMeshComponent</kbd>)</li>
<li>Muzzle Location (<kbd>USceneComponent</kbd>)</li>
</ul>
<p>At this point, as we have a bit of code work to do and don't want to be hot-reloading a lot, I recommend shutting down the editor until we're ready to add a new instance of <kbd>MasteringWeapon</kbd> to the game. So, let's get to adding those variables to our new <kbd>.h</kbd> file. These first four you can literally cut (not copy, as we're removing them) and paste from the <kbd>MasteringCharacter.h</kbd> file after making a public section under <kbd>GENERATED_BODY()</kbd>, and add the declaration of the constructor while we are here:</p>
<pre>public:
        AMasteringWeapon();
 
        /** Gun muzzle's offset from the characters location */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        FVector GunOffset = FVector(100.0f, 0.0f, 10.0f);
 
        /** Projectile class to spawn */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Projectile)
        TSubclassOf&lt;class AMasteringProjectile&gt; ProjectileClass;
 
        /** Sound to play each time we fire */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        class USoundBase* FireSound;
 
        /** AnimMontage to play each time we fire */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        class UAnimMontage* FireAnimation;</pre>
<p>Do note, however, that the <kbd>ProjectileClass'</kbd> <kbd>UPROPERTY</kbd> line has been set to match the others, and it did not previously in <kbd>MasteringCharacter.h</kbd>. Now all we need is our Skeletal Mesh and Muzzle Location; we'll add the following:</p>
<pre>/** Muzzle offset */
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Projectile)
class USceneComponent* MuzzleLocation;</pre>
<p>Now, keep in mind that we are departing from the template's hardcore C++ implementation of all of these game objects so that we can move to a more logical and helpful hybrid using blueprints. So, since all of our weapons will be instances of this class, for now let's just give the <kbd>GunOffset</kbd> the same default value it currently has (this variable is not very important right now) by changing its line in the <kbd>.h</kbd> file to the following:</p>
<pre>FVector GunOffset = FVector(100.0f, 0.0f, 10.0f);</pre>
<p>There will be a more in-depth discussion of the topic of blueprint/C++ balance in <a href="267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml" target="_blank">Chapter 3</a>, <em>Blueprint Review and When to Use BP Scripting</em>, but for now you can always at least think of blueprint instances of classes as great containers for data, especially things that will be tuned during game design, such as weapon properties here. We now have all the variables we will be using in our weapon and could add a blueprint for our new gun, but it won't do anything yet, and also, by removing these variables from our <kbd>MasteringCharacter</kbd> class, of course, it won't compile now. Thus, our best course is to carry on a bit more and have our code in a better position. Back in <kbd>MasteringCharacter.h</kbd>, find and remove the <kbd>FP_Gun</kbd> and <kbd>FP_MuzzleLocation</kbd> variables. Then, search and remove all references to them <em>and</em><strong> </strong>the four variables that we migrated to <kbd>MasteringWeapon.h</kbd> from the <kbd>MasteringCharacter.cpp</kbd> file. We can also remove the <kbd>VR_Gun</kbd> and <kbd>VR_MuzzleLocation</kbd> variables now as we'll make a whole new project when finally tackling a VR game later, so these are currently unimportant (but you can imagine otherwise converting them similarly in such a VR game).</p>
<div><p>As a tip for how I work here, as I know I need to replicate the same functionality later in my weapon class that's currently in our character class, I just commented out those sections currently used in the character and then will remove them entirely as each is now handled by the weapon as we continue.</p>
</div>
<p>We can now also remove this line from <kbd>MasteringCharacter.cpp</kbd>, and we can be sure that we will need this in <kbd>MasteringWeapon.cpp</kbd>. Also cut and paste the line to there after <kbd>MasteringWeapon.h</kbd> <kbd>include</kbd>:</p>
<pre>#include "MasteringProjectile.h"</pre>
<p>Next, to get our components to show up in our blueprint instance, we need to add them in the constructor like so in our <kbd>.cpp</kbd> file (similar to how they were made in the character's constructor), and we also need to add some required headers, starting right after the preceding line:</p>
<pre>#include "Runtime/Engine/Classes/Components/SkeletalMeshComponent.h"
#include "Runtime/Engine/Classes/Animation/AnimInstance.h"
#include "Kismet/GameplayStatics.h"
 
 
AMasteringWeapon::AMasteringWeapon()
{
        // Create a gun mesh component
        WeaponMesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT("WeaponMesh"));
        WeaponMesh-&gt;SetOnlyOwnerSee(true); // only the owning player will see this mesh
        WeaponMesh-&gt;bCastDynamicShadow = false;
        WeaponMesh-&gt;CastShadow = false;
        WeaponMesh-&gt;SetupAttachment(RootComponent);
 
        // Our muzzle offset object
        MuzzleLocation = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("MuzzleLocation"));
        MuzzleLocation-&gt;SetupAttachment(WeaponMesh);
}</pre>
<p>At this point, our character will be pretty broken if we play the game as they'll have no weapon, but as we need to do some editor work (adding a blueprint instance and another new class), this is a good time to build the game and start the editor back up. At this point, there is an intermediate commit submitted to GitHub's <kbd>Chapter 2</kbd> branch available if you need to check that things match.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an inventory and adding a default gun</h1>
                
            
            
                
<p>Back in the editor once more, we can work on the two remaining pieces needed to get back to the level of weapon functionality we began with, while having abstracted out the functionality to the new class: a rudimentary inventory system, and an actual blueprint instance of a weapon like the one we just removed from our <kbd>MasteringCharacter</kbd> class.</p>
<p class="mce-root"/>
<p>First, let's add the new <kbd>MasteringWeapon</kbd> to the Content Browser. Right-click in the browser's main window again and select Blueprint Class:</p>
<div><img src="img/964a1ada-fa55-442a-a0b3-96b5eac6d9ff.png"/></div>
<p>Much like when we are creating a new C++ class, here, we need to click the All Classes flyout at the bottom and search for and click MasteringWeapon, and then the Select button at the bottom. Rename the item in the content browser to BallGun and open it in the BP editor. Once again, I find it best here to click the full blueprint editor to view the changes in the viewport tab as we edit. In the Components tab, select WeaponMesh (Inherited) and in its details, open the Weapon Mesh fly-out, go down to the Mesh fly-out, and there the Skeletal Mesh variable has a drop-down we can click. There are so few to choose from, so simply pick the <kbd>SK_FPGun</kbd> asset here. Back to the Components tab, select next the MuzzleLocation (Inherited) under the WeaponMesh and in the Muzzle Location and Transform flyouts, edit the Relative Location vector to be the same values we hardcoded previously: <kbd>0.2</kbd>, <kbd>48.4</kbd>, <kbd>-10.6</kbd>.</p>
<p>Now, back to the Components tab, and above the two components we were just editing, let's select the base class again, BallGun(self), at the top. On the right, we have our Gameplay fly-out with our sound and animation variables. Select them from the drop-downs as the only assets we can, FirstPersonTemplateWeaponFire02 and FirstPersonFire_Montage. Under the Projectile fly-out, select FirstPersonProjectile from its drop-down, and building our blueprint for this gun is now done! Click on the compile button and then save it:</p>
<div><img src="img/41a7955f-4e22-4a16-8259-738d33d1f52d.png"/></div>
<p>Lastly, we just need to get this very minimal inventory set up and we can return to code up the use of our weapon. Right-click in the Content Browser again and click New C++ Class. We'll make this one a very simple <kbd>UActorComponent</kbd> by choosing ActorComponent for the parent class, either in the filtered group or typing into the search in all classes. For the name, use MasteringInventory, click Create Class, and we will rebuild once more. In <kbd>MasteringInventory.h</kbd>, first we can this function as it will be unused (and remove the implementation in the <kbd>.cpp</kbd> file):</p>
<pre>public:  
        // Called every frame
        virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;</pre>
<p>We will need two variables and a couple of functions like so added after <kbd>BeginPlay()</kbd>:</p>
<pre>protected:
        // Called when the game starts
        virtual void BeginPlay() override;
 
public:
        UPROPERTY(EditAnywhere, BlueprintReadWrite)
        TSubclassOf&lt;class AMasteringWeapon&gt; DefaultWeapon;
        
        /** Choose the best weapon we can of those available */
        void SelectBestWeapon(class AMasteringCharacter *Player);
 
        /** Select a weapon from inventory */
        void SelectWeapon(class AMasteringCharacter *Player, TSubclassOf&lt;class AMasteringWeapon&gt; Weapon);
 
        /** Add a weapon to the inventory list */
        void AddWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon);
 
        /** Add any default weapon we may have been set with */
        void AddDefaultWeapon();
 
        /** Get the currently selected weapon */
        FORCEINLINE TSubclassOf&lt;class AMasteringWeapon&gt; GetCurrentWeapon() const { return CurrentWeapon; }
 
protected:
        TArray&lt;TSubclassOf&lt;class AMasteringWeapon&gt; &gt; WeaponsArray;
        TSubclassOf&lt;class AMasteringWeapon&gt; CurrentWeapon;</pre>
<p>Notice here that our inventory component is only going to be dealing with class types, not with actual in-game actors. They will still be spawned by the <kbd>MasteringCharacter</kbd> class as they are equipped. We'll do that right after the implementations for the preceding functions are added to <kbd>MasteringInventory.cpp</kbd>, beginning directly after the <kbd>#include MasteringInventory.h</kbd> line:</p>
<pre>#include "MasteringCharacter.h"
 
 
// Sets default values for this component's properties
UMasteringInventory::UMasteringInventory()
{
        PrimaryComponentTick.bCanEverTick = true;
}
 
// Called when the game starts
void UMasteringInventory::BeginPlay()
{
        Super::BeginPlay();
 
        if (DefaultWeapon != nullptr)
        {
                AddWeapon(DefaultWeapon);
        }
}
 
void UMasteringInventory::SelectBestWeapon(class AMasteringCharacter *Player)
{
        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)
        {
                //TODO: add criteria for selecting a weapon
                {
                        SelectWeapon(Player, *WeaponIt);
                        break;
                }
        }
}
 
void UMasteringInventory::SelectWeapon(class AMasteringCharacter *Player, TSubclassOf&lt;class AMasteringWeapon&gt; Weapon)
{
        Player-&gt;EquipWeapon(Weapon);
}
 
void UMasteringInventory::AddWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon)
{
        WeaponsArray.AddUnique(Weapon);
}</pre>
<p>In <kbd>MasteringCharacter.h</kbd>, we need to add three things. In each of the following additions, I have also included the line of code that currently exists above where I placed the new line, so you can find where to place them. For the first, add <kbd>UPROPERTY</kbd> after <kbd>uint32 bUsingMotionControllers : 1</kbd>, which already exists in the <kbd>.h</kbd> file. Then, add the <kbd>AMasteringWeapon</kbd> pointer after <kbd>TouchItem</kbd>. And lastly, add the two function prototypes at the end of the third block after <kbd>GetFirstPersonCameraComponent()</kbd>:</p>
<pre>uint32 bUsingMotionControllers : 1;
 
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
class UMasteringInventory *Inventory;<br/>
class AMasteringWeapon* EquippedWeaponActor;<br/><br/>FORCEINLINE class UCameraComponent* GetFirstPersonCameraComponent() const { return FirstPersonCameraComponent; }
FORCEINLINE class UCameraComponent* GetFirstPersonCameraComponent() const { return FirstPersonCameraComponent; }
 
/** Equip a weapon */
void EquipWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon);
 
/** Get the currently equipped weapon */
FORCEINLINE class AMasteringWeapon* GetEquippedWeapon() const { return EquippedWeaponActor; };</pre>
<p>Now, in the <kbd>.cpp</kbd> file, we'll need the new headers:</p>
<pre>#include "XRMotionControllerBase.h" // for FXRMotionControllerBase::RightHandSourceId
#include "MasteringInventory.h"
#include "MasteringWeapon.h"</pre>
<p>We need one line added to the bottom of the constructor, and we can now delete all the previously commented-out code for equipping and firing the old gun:</p>
<pre>Inventory = CreateDefaultSubobject&lt;UMasteringInventory&gt;(TEXT("Inventory"));</pre>
<p>Our <kbd>BeginPlay()</kbd> is now very simple as well:</p>
<pre>void AMasteringCharacter::BeginPlay()
{
        // Call the base class  
        Super::BeginPlay();
 
        // Equip our best weapon on startup
        if (Inventory != nullptr)
        {
                Inventory-&gt;SelectBestWeapon(this);
        }
}</pre>
<p><kbd>OnFire()</kbd> is also much nicer looking; as you can see here, it is very compact and readable:</p>
<pre>void AMasteringCharacter::OnFire()
{
        // try and fire a projectile
        if (GetEquippedWeapon() != nullptr)
        {
                UAnimInstance* AnimInstance = Mesh1P-&gt;GetAnimInstance();
                GetEquippedWeapon()-&gt;Fire(GetControlRotation(), AnimInstance);
        }
}</pre>
<p>And lastly, at the bottom of the file is the implementation for equipping a weapon:</p>
<pre>void AMasteringCharacter::EquipWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon)
{
        UWorld *World = GetWorld();
        if (World == nullptr)
                return;
 
        if (EquippedWeaponActor != nullptr)
        {
                World-&gt;DestroyActor(EquippedWeaponActor);
        }
 
        const FRotator SpawnRotation = GetActorRotation();
        const FVector SpawnLocation = GetActorLocation();
        FActorSpawnParameters ActorSpawnParams;
        ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
        ActorSpawnParams.Owner = this;
 
        EquippedWeaponActor = Cast&lt;AMasteringWeapon&gt;(World-&gt;SpawnActor(Weapon, &amp;SpawnLocation, &amp;SpawnRotation, ActorSpawnParams));
        if (EquippedWeaponActor != nullptr)
        {
                //Attach gun mesh component to skeleton
                EquippedWeaponActor-&gt;AttachToComponent(Mesh1P, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true), TEXT("GripPoint"));
        }
}</pre>
<p>Note that the actual spawn location and rotation are not really significant as we immediately attach a successfully spawned weapon to our mesh, but it's usually a good idea to have some reasonable defaults there to be safe.</p>
<p>At this point, we return to our <kbd>MasteringWeapon</kbd> files, first the .h file where we add this line near the bottom of the class:</p>
<pre>public:
        /** Fire the weapon */
        void Fire(FRotator ControlRotation, class UAnimInstance* AnimInst);</pre>
<p>And then implement it like so in the <kbd>.cpp</kbd> file to do all the work we were previously doing in the character:</p>
<pre>void AMasteringWeapon::Fire(FRotator ControlRotation, class UAnimInstance* AnimInst)
{
        // try and fire a projectile
        if (ProjectileClass != nullptr)
        {
                UWorld* const World = GetWorld();
                if (World != nullptr)
                {
                        // MuzzleOffset is in camera space, so transform it to world space before offsetting from the character location to find the final muzzle position
                        const FVector SpawnLocation = ((MuzzleLocation != nullptr) ? MuzzleLocation-&gt;GetComponentLocation() : GetActorLocation()) + ControlRotation.RotateVector(GunOffset);
 
                        //Set Spawn Collision Handling Override
                        FActorSpawnParameters ActorSpawnParams;
                        ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;
 
                        // spawn the projectile at the muzzle
                        World-&gt;SpawnActor&lt;AMasteringProjectile&gt;(ProjectileClass, SpawnLocation, ControlRotation, ActorSpawnParams);
                }
        }
 
        // try and play the sound if specified
        if (FireSound != nullptr)
        {
                UGameplayStatics::PlaySoundAtLocation(this, FireSound, GetActorLocation());
        }
 
        // try and play a firing animation if specified
        if (FireAnimation != nullptr)
        {
                // Get the animation object for the arms mesh
                if (AnimInst != nullptr)
                {
                        AnimInst-&gt;Montage_Play(FireAnimation, 1.f);
                }
        }
}</pre>
<p>Now, all that's left to do is add a default weapon to our particular player's inventory component and we're back in business. Open the FirstPersonCharacter BP again in the editor. At the bottom of its Components tab now is our Inventory (Inherited). Select it, and in the Details tab, under the Gameplay, Inventory, and Mastering Inventory fly-outs, click the Default Weapon drop-down and select BallGun. Now, playing the game should have everything looking just like it was before, but with a system in place that can accept all manner of new weapons for our character, simply by adding more MasteringWeapon blueprint assets and adding them to our inventory for selection, which is what our next section focuses on.</p>
<p>This is a great time to take a moment and set some breakpoints in these new functions and step through, making sure everything looks right in the debugger. Note that if you try to step through some functions and it steps right over them, check whether you're building the game in the Development Editor and set it to DebugGame Editor instead. Oftentimes, these smaller functions are simply optimized away in development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a WeaponPickup class</h1>
                
            
            
                
<p>Now that we have a working inventory, if minimal, and a weapon class for creating new weapons, we need one more key piece: a way to add these new items to that inventory. There are functions now ready to receive this, but how do we get that into the game in a meaningful way? Well, there are a number of approaches here based on the type of game and its design needs. In the following case, we'll stick to a fairly traditional FPS-style game and add a weapon pickup that can be dropped into our game world either during level design or dynamically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a new actor class</h1>
                
            
            
                
<p>As noted already, different games have different design needs in this area. If your game only ever had, for example, slots for weapon items (as many popular 3D action games do), then we wouldn't really need an inventory class, nor a weapon pickup class. You could save yourself some trouble by just adding a couple of <kbd>AMasteringWeapon</kbd> pointers to your player class and in that weapon, override the <kbd>AAcotr's Tick(float DeltaSeconds)</kbd> function to give it a behavior when on the ground, and stop that behavior while it is stored and hidden or shown when equipped by the player. In this case, we have a very flexible and open-ended system that can be used for a large variety of weapons all being stored at the same time. The reason for adding a pick-up here is to demonstrate a different behavior when the item is on the ground, and add some additional data that helps us expand the usefulness of our inventory. As in many action FPS games, we will give the item pickup a visibly noticeable rotation while it sits at the proper height on the ground, set up its collision settings so the player can pick it up, and add an ammo count and power level to our weapons so that we can automatically equip the best item we have when one is available or our equipped one becomes unusable. Of course, the pickup item will also reference the MasteringWeapon it represents, so we will quickly build a new one here with a new MasteringProjectile to differentiate it since we're currently working with limited assets.</p>
<p>For the curious, yes, this book will delve into some of the wonderful, but free, UE4 assets from the marketplace in future sections to address advanced visuals and give us some variety in the characters and more in our sample game. At the moment, however, we will simply work with what we have in the FPS template to quickly establish these core game concepts.</p>
<p>At this point, creating a new class is quite familiar, so hopefully we can speed through the steps a bit. If anything seems incorrect or not what is expected, naturally it is a good idea to skim through the steps previously presented regarding making a new class and begin work on its functionality. So, back in the editor, let's add yet another new C++ class, with the parent as a simple Actor. We'll name it <kbd>MasteringWeaponPickup</kbd>, and its implementation should actually go rather quickly compared to the more complicated classes we have been working on.</p>
<p>We have a decision to make on where the actual pick-up functionality is implemented. At this point, let's take a moment to revisit encapsulation. For any readers who may have been around to experience Unreal Engine 3, most have a similar story about looking at Actor.h and Actor.cpp and thinking their eyes were going to fall out. These were, no pun intended, epic files, with tens of thousands of lines of code that implemented a myriad of possible in-game behaviors for every single actor (no matter how simple) in the game. Those files are still a bit large, but thanks to massive efforts by Epic between UE3 and UE4, they managed to move huge amounts of specialized code into components and specific plugins, greatly reducing the volume of code and number of variables on such a widely used class. The easiest way to get this pickup working would be to simply drop it into our <kbd>MasteringCharacter</kbd> class and let our character colliding with a pickup do all the work. However, if you begin doing this for all the systems you add to a medium or large project, your character class will find itself in a state like UE3's actor files, and new team members will have a hard time figuring out where functionality is and will have to familiarize themselves often with the entire voluminous class to competently make changes. If we encapsulate the functionality needed into the items that generally "own" that game behavior, it makes learning the project much easier and modifications become less risky and more manageable in scope for newer developers on the team.</p>
<p>So in this case, let's start early with this practice, and put the pickup functionality as much as possible into our <kbd>MasteringWeaponPickup</kbd> class itself. Here are the set of functions and variables we will need in the body of the header:</p>
<pre>public:  
        // Sets default values for this actor's properties
        AMasteringWeaponPickup();
 
protected:
        // Called when the game starts or when spawned
        virtual void BeginPlay() override;
 
        virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;
 
public:       
        // Called every frame
        virtual void Tick(float DeltaTime) override;
 
        UPROPERTY(EditAnywhere, BlueprintReadWrite)
        TSubclassOf&lt;class AMasteringWeapon&gt; WeaponClass;
 
        /** How fast the pickup spins while on the ground, degress/second */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        float RotationSpeed = 30.0f;
 
        /** How much ammunition is provided for this weapon on pick-up */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        uint8 Ammunition = 10;
 
        /** This weapon's relative weapon power to compare it to others */
        UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Gameplay)
        uint8 WeaponPower = 1;</pre>
<p>A quick note on the <kbd>uint8</kbd> items at the end: it has been a known issue for some time that only this one is supported by classes exposed in blueprint. Adding <kbd>uint16</kbd> and <kbd>uint32</kbd> types would require a massive amount of work for several systems on Epic's part, so it is not ever a high priority on their list of features (the amount of work versus the benefit to developers isn't very high). In this case, it's no problem, so we can take the benefit of the 8-bit version to force all values in our blueprint instances to always be between 0-255. If you need a larger range, you're forced to use a normal full-sized (but signed) <kbd>int</kbd> and then the burden is on the code side for you to check that designers modifying these blueprints don't enter a value that's not valid. So, an ongoing theme through all the work done in this book will be to tailor your needs to your design. Weapon power here is just an arbitrary value, so we can differentiate which weapons are better than others. Something this basic and abstract may be perfect for your game, depending on the number of weapons, or maybe should be computed from various damage and speed types of factors.</p>
<p>An important part of being a top-level developer is good communication, and sitting with a designer to discuss a system, and (depending on the project size) putting this into a wiki page or another source of document storage, is key. An exaggerated example would be: if we knew with certainty that our game was never going to use more than one weapon, all of this inventory and weapon abstraction is largely unnecessary. Since I want to demonstrate how we can make it scale to a large number of weapons, that is the motivation for getting these systems in place early and as encapsulated as possible as we go.</p>
<p>So next, here are the implementations in the pickup's <kbd>.cpp</kbd> file:</p>
<pre>#include "MasteringCharacter.h"
#include "MasteringInventory.h"
 
 
// Sets default values
AMasteringWeaponPickup::AMasteringWeaponPickup()
{
   // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
        PrimaryActorTick.bCanEverTick = true;
 
}
 
// Called when the game starts or when spawned
void AMasteringWeaponPickup::BeginPlay()
{
        Super::BeginPlay();
        
}
 
void AMasteringWeaponPickup::NotifyActorBeginOverlap(AActor* OtherActor)
{
        AMasteringCharacter *player = Cast&lt;AMasteringCharacter&gt;(OtherActor);
 
        if (player == nullptr)
        {
                return;
        }
 
        UMasteringInventory *Inventory = player-&gt;GetInventory();
        
        Inventory-&gt;AddWeapon(WeaponClass, Ammunition, WeaponPower);
 
        // here we automatically select the best weapon which may have changed after adding the above,
        // NOTE: this should probably be an option the player can turn on and off via UI
        Inventory-&gt;SelectBestWeapon();
 
        // and now that we've done our job, destroy ourselves
        Destroy();
}
 
// Called every frame
void AMasteringWeaponPickup::Tick(float DeltaTime)
{
        Super::Tick(DeltaTime);
 
        FRotator rotationAmount(0.0f, DeltaTime * RotationSpeed, 0.0f);
 
        AddActorLocalRotation(rotationAmount);
}</pre>
<p>So, you can see, it's fairly simple. Most of what it does is spin around on the ground at the speed specified by <kbd>RotationSpeed</kbd>, allows itself to be picked up by a player, and then destroys itself. We'll talk about its collision filtering when we set up an instance, but notice that we cast the OtherActor pointer to a mastering character type: this of course works for subtypes (such as our <kbd>StealthCharacter</kbd> class), but any other <kbd>Pawn</kbd> classes will fail to cast there, returning null, so (as seen in that next line) we can ignore them now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up our blueprints</h1>
                
            
            
                
<p>Next, we need an actual new weapon. This will be very quick as again, right now we have very little to work with in the way of art assets, so we will demonstrate things creatively using those same art assets. Right-click on our BallGun weapon blueprint and click Duplicate. Rename the duplicated one BigBallGun and do the same trick, duplicating the FirstPersonProjectile blueprint and renaming it BigFirstPersonProjectile. We'll edit each of these quickly to get them ready to be pickups that can be added to our inventory and used by the player.</p>
<p>Open their full blueprints. In the projectile's components, pick ProjectileMovement (Inherited) and on the right you'll see the Projectile fly-out. Set the speeds to about double their current values, so to 6,000 to really give this one some punch compared to the other. In its CollisionComp (Inherited) under the Transform fly-out, set its scale to 2. I prefer when possible to click the lock icon on the right since we're doing universal scaling here, so you only have to type in the number once rather than in all three components. Then, click on its StaticMesh1 component under its CollisionComp (Inherited), and here we make one small visual change: under its Static Mesh's Materials fly-out, pick the drop-down and set it to M_FPGun. This material's texture is obviously set up for the gun and not a ball, but it makes our new bullet silver to really help differentiate it and let us know which gun we're firing (since the guns themselves otherwise look identical at this point). With both of these made, now go back to the BigBallGun blueprint's window and click its class (BigBallGun(self)), under components. Now, under the Projectile fly-out, we naturally set it to our new BigFirstPersonProjectile.</p>
<p>With the weapon and projectile done, now we can finally set up our weapon pickup. In the Content Browser, make a new blueprint class, show all classes, and select our MasteringWeaponPickup. Name this BigBallGunPickup and double-click it to check it out. Click BigBallGunPickup(self), and under Gameplay you're welcome to change the rotation speed or amount of ammo in this pickup; however, be sure to at least change the weapon power to 1 or greater so it can "sort" above our default gun we'll still add from code.</p>
<p>The only components at the moment should be the (self) one and a scene component. We'll leave the scene component, and now use a bit of blueprint work directly as preparation for further blueprint discussions in the next chapter. We could of course add these components that we're about to use in the constructor in C++ like the template has done to date, but it's much quicker and easier to customize here in the blueprint. But again, depending on your project's needs, the C++ way might be the better choice. Doing it the way it is done here requires no code, but would require adding the components manually every time a new pick-up is made.</p>
<p>This is another area of managing a project an expert developer will know how to balance: what is the bandwidth of the team compared to the project's goals? If, for example, the game had many systems designers who were comfortable working in blueprint, it might make sense to simply allow them to do the duplicated work a number of times, adding these components in blueprint and require no coding help. On the other hand, if programmers themselves may have to set these up and their time is limited (hint: it always is!), it's probably best to add the components into the constructor to reduce the setup time needed to make these pick-ups. Always keep in mind your team's capabilities before committing to a workflow such as this.</p>
<p>Back to the pick-up, I renamed the scene component here so that I know it's really only for making an offset from the ground. Click on that scene component now (top component) and click the Add Component button at the top. Pick skeletal mesh as the type (you can rename it BallGunMesh).</p>
<p>Note: In all likelihood in a major game, you would have separate art assets here, so you would use a static mesh on the pickup that is a simplified version and not an animated character such as the gun that is held and equipped; but again, we work with what we have.</p>
<p>On the mesh's details pane, find its mesh fly-out and set it to <kbd>SK_FPGun</kbd>. Similarly, set its material to <kbd>M_FPGun</kbd>. So that when placed on the ground it doesn't actually sit flat on the ground, under its Transformation flyout, set the Location to be about 50.0 in Z so that it's half a meter in the air. Now, we need to click the mesh and add a child component to it so that the whole pickup can be, well, picked up! Click the green add button again, and this time add a Sphere Collision component. We need to change only one thing out of good practice: under its Collision fly-out, change its Collision Preset in the drop-down to OverlapOnlyPawn:</p>
<div><img src="img/858d6074-03cb-4503-9d4d-2835aae15a88.png"/></div>
<p>What this does is allow the collision system to ignore all objects when deciding whether one has collided (or, specifically in our case, overlapped, which means items can pass through it), but will get this event that overlapping is happening, "hit" events are the ones that stop movement. This way, things like our projectiles won't have to be considered by the collision system, only pawns walking around, which is always important to limit these interactions as much as possible to keep performance high. Lastly, click and drag our BigBallGunPickup (the icon in the content browser) into the main level editor window where the environment is shown (the boxes and walls) and place it on the ground. Place a few if you like, so we can walk around and pick them up.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Back to code to finish up</h1>
                
            
            
                
<p>Having everything set in the editor and level, we have a few more code changes to make. First, we make some changes in <kbd>MasteringInventory.h</kbd>:</p>
<pre>USTRUCT()
struct FWeaponProperties
{
        GENERATED_USTRUCT_BODY()
 
public:
 
        UPROPERTY()
        TSubclassOf&lt;class AMasteringWeapon&gt; WeaponClass;
 
        UPROPERTY()
        int WeaponPower;
 
        UPROPERTY()
        int Ammo;
};</pre>
<p>We add this <kbd>struct</kbd> to the very top of the file, just after the <kbd>#include</kbd> header section. We will use this in the inventory list to reference weapons from now on, instead of referencing the <kbd>MasteringWeapon</kbd> class itself directly (but, of course, this is now a member in the <kbd>struct</kbd> for our use). We use the <kbd>struct</kbd> to track two new properties we associate with weapons: ammo and weapon power.</p>
<p>Next, after the <kbd>DefaultWeapon</kbd> variable, modify the first three functions (we remove passing the player for selecting weapons, and add ammo and power to the adding of weapons):</p>
<pre>   /** Choose the best weapon we can of those available */
        void SelectBestWeapon();
 
        /** Select a weapon from inventory */
        void SelectWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon);
 
        /** Add a weapon to the inventory list */
        void AddWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon, int AmmoCount, uint8 WeaponPower);
 
        /** Get the currently selected weapon */
        FORCEINLINE TSubclassOf&lt;class AMasteringWeapon&gt; GetCurrentWeapon() const { return CurrentWeapon; }
 
        /** Change a weapon's ammo count, can't go below 0 or over 999 */
        void ChangeAmmo(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon, const int ChangeAmount);
 
protected:
        TArray&lt;FWeaponProperties&gt; WeaponsArray;
        TSubclassOf&lt;class AMasteringWeapon&gt; CurrentWeapon;
        int CurrentWeaponPower = -1;
        class AMasteringCharacter* MyOwner;</pre>
<p>In the <kbd>MasteringInventory.cpp</kbd> file, add this:</p>
<pre>#define UNLIMITED_AMMO -1
 
// Sets default values for this component's properties
UMasteringInventory::UMasteringInventory()
{
        PrimaryComponentTick.bCanEverTick = true;
 
        MyOwner = Cast&lt;AMasteringCharacter&gt;(GetOwner());
        check(GetOwner() == nullptr || MyOwner != nullptr);
}
 
// Called when the game starts
void UMasteringInventory::BeginPlay()
{
        Super::BeginPlay();
 
        if (DefaultWeapon != nullptr)
        {
                // NOTE: since we don't use a pick-up for the default weapon, we always give it a power of 0
                AddWeapon(DefaultWeapon, UNLIMITED_AMMO, 0);
        }
}</pre>
<p>At the top, right under our <kbd>#include</kbd> section, notice the <kbd>#define</kbd> used to show clearly that when we see this, a weapon has unlimited ammo. This is much safer than using -1 directly, as new team-members might not understand seeing the magical properties of -1 in other areas of the code. In the constructor, notice also that we do a trick because we know this object is a component, and thus has to have (when used) an owning actor, and we save this as <kbd>MyOwner</kbd>. If you set a breakpoint there, you'll notice as the level editor starts, you get one instance with a null owner. This is the default object being constructed and thus is nothing to worry about. However, notice the <kbd>check</kbd>. It, well, checks for that case, but then will assert whether someone tried to add an inventory component to anything that isn't <kbd>MasteringCharacter</kbd>, just to be safe. This check is done very rarely (once each time an inventory is created), so is fine being a normal <kbd>check</kbd>. Below, there's a <kbd>checkSlow</kbd> I'll explain just for contrast. This line of saving a pointer already cast to the right type of our owner saves us some time later when adding weapons, and then we also don't have to keep passing a <kbd>MasteringCharacter</kbd> pointer through all these functions since, once again, we know that every player has one and only one inventory, and every inventory exists as part of a player. We also add the default weapon with unlimited ammo and a weapon power of 0. After this, we basically replace the old <kbd>SelectBestWeapon</kbd>, <kbd>SelectWeapon</kbd>, and <kbd>AddWeapon</kbd> so that they now look like this:</p>
<pre>void UMasteringInventory::SelectWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon)
{
        MyOwner-&gt;EquipWeapon(Weapon);
}
 
void UMasteringInventory::AddWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon, int AmmoCount, uint8 WeaponPower)
{
        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)
        {
                FWeaponProperties &amp;currentProps = *WeaponIt;
                if (currentProps.WeaponClass == Weapon)
                {
                        checkSlow(AmmoCount &gt;= 0);
                        currentProps.Ammo += AmmoCount;
                        return; // our work is done if we found the gun already in inventory, just update ammo
                }
        }
 
        FWeaponProperties weaponProps;
        weaponProps.WeaponClass = Weapon;
        weaponProps.WeaponPower = WeaponPower;
        weaponProps.Ammo = AmmoCount;
 
        WeaponsArray.Add(weaponProps);
}
 
void UMasteringInventory::ChangeAmmo(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon, const int ChangeAmount)
{
        for (auto WeaponIt = WeaponsArray.CreateIterator(); WeaponIt; ++WeaponIt)
        {
                FWeaponProperties &amp;currentProps = *WeaponIt;
                if (currentProps.WeaponClass == Weapon)
                {
                        if (currentProps.Ammo == UNLIMITED_AMMO) // unlimited ammo gun, we're done
                                return;
 
                        currentProps.Ammo = FMath::Clamp(currentProps.Ammo + ChangeAmount, 0, 999);
                        if (currentProps.Ammo == 0) // gun is now empty!
                        {
                                CurrentWeaponPower = -1; // force us to select any better weapon that does have ammo
                                SelectBestWeapon();
                        }
                        return; // our work is done if we found the gun already in inventory, just update ammo
                }
        }
}</pre>
<p>Notice that changing ammo uses a non-const iterator and a reference to the structs it is iterating. This way, we can simply directly modify the ammo count in the struct that exists in the array. Always be careful as it's very easy to simply use a local variable in the iterator, make a change, and not have that saved as you'd like in the array! Also notice <kbd>checkSlow</kbd>. Adding weapons doesn't happen very often either, so it is perfectly fine being a normal <kbd>check</kbd> for performance. I just put it there to remind myself to discuss them. <kbd>checkSlow</kbd> is only used in debug builds, so if content developers use a development build, they would never have it assert on them (which can be annoying for artists and designers if it were to happen, because it basically causes a crash that they can do nothing about). So use these wisely.</p>
<p>In any case where a check is used that could happen in a live build and could be very severe, always use the <kbd>checkf</kbd> variants instead because this will also output whatever you format into its string output into the game's .log file. This way, if a player with a live version of the game has a problem, or a release build crashes, you can look at that log and it may immediately give you a clue as to what happened.</p>
<p>Lastly, keeping with our theme of encapsulation, we'll have the weapon inform the inventory as it spends ammo (as the gun does the firing and the inventory does the ammo-tracking in our game). When a gun runs out of ammo, the inventory will automatically try to pick the next best option, and since our default weapon has unlimited ammo, we always know at least something will be available. This, of course, can vary wildly in different styles of games, with a "dry fire" sound when out of ammo and trying to fire, or switching from a gun to a melee attack when out of ammo. Here, we'll add this parameter to our firing function:</p>
<pre>void Fire(FRotator ControlRotation, class UAnimInstance* AnimInst, class UMasteringInventory* Inventory);</pre>
<p>And we'll implement it in the .cpp like so at the bottom of the <kbd>Fire</kbd> function:</p>
<pre>// reduce ammo by one
Inventory-&gt;ChangeAmmo(GetClass(), -1);</pre>
<p>That's it! We can now run around our level, pick up the big gun, and watch its projectiles really make those boxes fly... until it's out of ammo and we're back to the default gun.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Putting our inventory to use</h1>
                
            
            
                
<p>Don't worry, all the hard parts are done! But we do still have one last important, if less challenging, thing to do to make this more like a viable normal inventory in a game: swapping weapons. We'll need an input for cycling them, and keep in mind that we currently auto-equip the best weapon you pick up at the time of pick-up, and at the moment have no way to choose anything else.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding controls to cycle weapons</h1>
                
            
            
                
<p>Much like before, when we added an input for stealth and bound it to left-shift, let's head back to the editor's project properties and engine/input/bindings fly-outs. Here, we'll add two Action Mappings with the + button, and name them InventoryUp and InventoryDown. I like to bind these to Mouse Wheel Up and Mouse Wheel Down, respectively, but you're free to choose any inputs you prefer. We now have our means of cycling, and just need to set it up like our stealth mechanic once more in our character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding swapping of weapons to our character</h1>
                
            
            
                
<p>First, we need to add cycling to our inventory. There are a number of ways to do this, and with a plan, you could, for example, simply sort the array based on the power of the items going in and store the current weapon's array entry. There are dangers to this, but it would make for very fast and clear switching of weapons. The implementation here will be a bit rough, but is not critically important. Knowing ahead of time how extensively a system will get used is very important to long-term healthy development as well. If a system has a very rough but fully functional implementation, and will never likely change or be reused by other areas of code in the life of the project, just leave it be. We all want to always write perfect code, but code oftentimes comes from outside contributors or less experienced developers. While keeping to best practices ourselves is always encouraged, it's also important to know when you don't need to over-engineer something of limited scope or use; just get it working and move on. Game development relies on speed, and there is nothing wrong with revisiting code that was written under one set of requirements (such as "the game will only ever have at most two weapons" changes to "we now need 10 or more weapons for the player!"). Clean up and build things the best you can for the job they do. It's just a classic downfall of many developers to not realize when something is good enough, even if it's not perfect or the way we'd ideally like it. So, with that huge disclaimer, here's the rough inventory cycling code to finish up this section:</p>
<pre>int UMasteringInventory::FindCurrentWeaponIndex() const
{
        int currentIndex = 0;
        for (auto WeaponIt = WeaponsArray.CreateConstIterator(); WeaponIt; ++WeaponIt, ++currentIndex)
        {
                const FWeaponProperties &amp;currentProps = *WeaponIt;
                if (currentProps.WeaponClass == CurrentWeapon)
                        break;
        }
 
        checkSlow(currentIndex &lt; WeaponsArray.Num());
 
        return currentIndex;
}
 
void UMasteringInventory::SelectNextWeapon()
{
        int currentIndex = FindCurrentWeaponIndex();
 
        if (currentIndex == WeaponsArray.Num() - 1) // we're at the end
        {
                SelectWeapon(WeaponsArray[0].WeaponClass);
        }
        else
        {
                SelectWeapon(WeaponsArray[currentIndex + 1].WeaponClass);
        }
}
 
void UMasteringInventory::SelectPreviousWeapon()
{
        int currentIndex = FindCurrentWeaponIndex();
 
        if (currentIndex &gt; 0) // we're not at the start
        {
                SelectWeapon(WeaponsArray[currentIndex - 1].WeaponClass);
        }
        else
        {
                SelectWeapon(WeaponsArray[WeaponsArray.Num() - 1].WeaponClass); // select the last
        }
}</pre>
<p>Add the prototypes for the functions to your <kbd>.h</kbd> file. Then, add these lines below all of our previous input binding in <kbd>AMasteringCharacter::SetupPlayerInputComponent</kbd>:</p>
<pre>// Cycling inventory
PlayerInputComponent-&gt;BindAction("InventoryUp", IE_Pressed, this, &amp;AMasteringCharacter::SelectNextWeapon);
PlayerInputComponent-&gt;BindAction("InventoryDown", IE_Pressed, this, &amp;AMasteringCharacter::SelectPreviousWeapon);</pre>
<p>And in the character, add these functions (with their prototypes near the other control handling functions in the header):</p>
<pre>void AMasteringCharacter::SelectNextWeapon()
{
        Inventory-&gt;SelectNextWeapon();
}
 
void AMasteringCharacter::SelectPreviousWeapon()
{
        Inventory-&gt;SelectPreviousWeapon();
}</pre>
<p>And if you were to test things like this, it would look like it's partly working and then breaks. Stepping through the code, a line that wasn't important before was missing, but seeing that CurrentWeapon was always null, it was very easy to add this last line to <kbd>SelectWeapon</kbd>. It's always great to keep those debugging skills up!</p>
<pre>void UMasteringInventory::SelectWeapon(TSubclassOf&lt;class AMasteringWeapon&gt; Weapon)
{
        MyOwner-&gt;EquipWeapon(Weapon);
        CurrentWeapon = Weapon;
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Bringing it all together</h1>
                
            
            
                
<p>Now, our inventory and pickups are all complete. If you launch the editor, you can step through the cycling up and down code to make sure everything is working correctly. We redundantly re-equip the default weapon if that's our only one, but the real work in the character's <kbd>EquipWeapon</kbd> already handles trying to switch from a weapon to that same weapon class and returns to the top. We now have a fully functional inventory that we can use to cycle through our, albeit only two, weapons, both up and down. Mission accomplished!</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We started this section with a hardcoded weapon made by bolting some components and input onto a character. We now have a system to make infinite unique weapon types, make a cool pick-up item for them, add them to the inventory, switch to the best weapon, track ammo, switch to another weapon automatically when one runs out of ammo, and cycle those weapons as we want with input. This is just one example of many game systems that will be implemented over the course of even small game projects, but it has shown several fundamentals of design (in the coding sense) as well as game design and how they mesh together. Never over-engineer what you won't need, but always plan for the future and make sure that your requirements are all there. We've also done a bit more work directly with blueprints and its editor. In the next chapter, we will go in depth into what blueprints can do and understand a bit deeper about how it works. A major point of discussion will be how games can (and are!) built only using blueprint scripting and no project C++ code. This approach has many risks, but for smaller projects or working with limited resources to get something demonstrated, it can be a huge benefit, and those benefits are there even for a C++ project such as ours if you know when to use them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Is there any reasonable way we could have swapped weapons on the character the way the template originally set it up?</li>
<li>Why move firing functionality out of the character and into our weapon class?</li>
<li>Why do we only store actor classes, and not actors, in the inventory?</li>
<li>What is the purpose of a weapon pickup class? Why not just use the weapon directly as the pickup?</li>
<li>What advantages are there to adding components to a class in code versus adding them to an instance in blueprint?</li>
<li>What are the differences between <kbd>check</kbd>, <kbd>checkSlow</kbd>, and the <kbd>checkf</kbd> variants?</li>
<li>Which one should always be used for live game builds checking critical code?</li>
<li>Why is finding the current weapon index in its own function?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><a href="https://docs.unrealengine.com/en-us/Programming/Assertions">https://docs.unrealengine.com/en-us/Programming/Assertions</a></p>


            

            
        
    </body></html>