- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Independent Watchdog (IWDG)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about the **Independent Watchdog** (**IWDG**) timer,
    a unique component for enhancing the reliability of embedded systems. IWDG is
    essential for monitoring the system’s operation and ensuring it can recover from
    unexpected faults or malfunctions.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by exploring the general concept of **watchdog timers** (**WDTs**)
    and their importance in embedded systems. Following this, we will examine how
    WDTs function and the unique features of IWDG. Next, we will focus specifically
    on the STM32 implementation of the IWDG, looking at its key registers and configuration.
    Finally, we will apply this knowledge to develop a bare-metal IWDG driver, providing
    practical code examples to solidify our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WDTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of WDTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32 IWDG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the IWDG driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of IWDG
    timers and their critical role in embedded systems. You will also gain skills
    to develop and implement IWDG drivers for STM32 microcontrollers, ensuring your
    systems can maintain robustness and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All code examples for this chapter can be found on GitHub at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WDTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WDTs are one of the unsung heroes of embedded systems. They quietly monitor
    the system’s health, ensuring it can recover gracefully from unexpected hitches.
    Imagine them as vigilant guards, always on the lookout for system malfunctions,
    ready to reset the microcontroller if something goes wrong. In this section, we’ll
    explore what WDTs are and how they function, and dive into some common use cases
    to illustrate their importance.
  prefs: []
  type: TYPE_NORMAL
- en: What are WDTs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WDTs are like guardians for your microcontroller. Imagine you’re using a device,
    and something goes wrong—a bug in the developer’s code causes an infinite loop,
    or a hardware glitch freezes the system. Without a watchdog, your device would
    be stuck, potentially causing significant problems, especially in critical applications
    such as medical devices or automotive systems.
  prefs: []
  type: TYPE_NORMAL
- en: A WDT is a hardware or software timer that resets the system if the main program
    fails to reset the timer before it expires. It’s a simple yet powerful mechanism
    to ensure that your system can recover from unexpected issues. Let’s see how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How WDTs work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think of a WDT as an hourglass that you need to turn over regularly to prevent
    it from running out of sand. Here’s a step-by-step breakdown of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: When your system starts, you initialize the WDT with a
    specific timeout period. This period is the maximum time your system can run without
    resetting the timer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Countdown**: The WDT starts counting down from the set timeout value. If
    it reaches zero, it assumes something went wrong and triggers a system reset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resetting the timer**: Your main program needs to periodically reset the
    WDT before it reaches zero. This action is often called **feeding the watchdog**
    or **kicking the dog**. If the program is running correctly, it will continue
    to reset the timer, preventing a reset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**System reset**: If your program fails to reset the WDT in time—perhaps because
    it got stuck in an infinite loop or encountered a critical error—the WDT will
    expire and reset the system, bringing it back to a known state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand the basics, let’s look at some real-world applications
    where WDTs play a crucial role.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following is a list of some real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Industrial automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In industrial automation, reliability is paramount. Machines and processes need
    to run continuously and without failure. WDTs ensure that if a **Programmable
    Logic Controller** (**PLC**) or other control systems hang or crash, they can
    quickly recover.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: Imagine a conveyor belt system in a manufacturing plant. The PLC
    controlling the conveyor belt has a WDT set to 1 second. If the PLC software fails
    to reset the watchdog within 1 second due to a software bug or external interference,
    the WDT will reset the PLC. This reset ensures that the conveyor belt can resume
    operation with minimal downtime, preventing potential production losses.'
  prefs: []
  type: TYPE_NORMAL
- en: Automotive systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern vehicles rely heavily on embedded systems for various functions, from
    engine control to infotainment. WDTs are vital in ensuring these systems operate
    reliably.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: Consider an **engine control unit** (**ECU**) in a car. The ECU
    monitors and controls critical engine parameters. A WDT in the ECU might be set
    to 500 milliseconds. If the ECU software fails to reset the watchdog due to a
    fault, the WDT resets the ECU. This reset can prevent engine misbehavior, ensuring
    the vehicle operates safely.'
  prefs: []
  type: TYPE_NORMAL
- en: Medical devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In medical devices, WDTs can be life-saving. Devices such as pacemakers, infusion
    pumps, and patient monitors must operate without failure.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: Take a patient monitor that tracks vital signs such as heart rate
    and blood pressure. The monitor’s software includes a WDT set to 2 seconds. If
    the software encounters a problem and fails to reset the watchdog, the device
    will reset. This reset ensures the monitor can quickly recover and continue providing
    accurate, real-time data, which is crucial for patient care.'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer electronics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even in consumer electronics, WDTs help maintain system reliability and enhance
    user experience. Think of smartphones, smart home devices, and gaming consoles.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: In a smart thermostat, the software manages temperature settings
    and connectivity. A WDT ensures that if the software freezes, the system resets
    and continues operating. This functionality prevents users from experiencing extended
    downtime, maintaining comfort and convenience in their homes.'
  prefs: []
  type: TYPE_NORMAL
- en: These examples illustrate the crucial role that WDTs play in modern systems.
    When implementing WDTs, it’s essential to consider several key factors to ensure
    their effectiveness. Let’s see some of these factors.
  prefs: []
  type: TYPE_NORMAL
- en: Practical considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When implementing WDTs, you must consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeout period**: Choose an appropriate timeout period based on your application’s
    needs. Too short, and you risk unnecessary resets; too long, and you might not
    recover quickly enough from faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reset mechanism**: Ensure that resetting the WDT (feeding the dog) is done
    in a part of your code that runs regularly and indicates the system is operating
    correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recovery strategy**: Plan how your system should recover after a watchdog
    reset. Ensure critical data is preserved and the system returns to a safe state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Thoroughly test your WDT implementation to ensure it behaves as
    expected under various fault conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s see the types of WDTs available.
  prefs: []
  type: TYPE_NORMAL
- en: Types of WDTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WDTs can be categorized into several types based on their functionality and
    integration. Let’s explore the most common types.
  prefs: []
  type: TYPE_NORMAL
- en: Internal WDTs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internal WDTs are built into the microcontroller. They are a convenient option
    because they don’t require additional external components. These timers are directly
    integrated into the microcontroller’s architecture and can be configured through
    software.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration**: No need for external circuitry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: Typically configured using the microcontroller’s registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power**: They can continue to operate in low-power modes, making them suitable
    for battery-powered applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: In a small IoT device, an internal WDT can monitor the
    microcontroller’s operation without adding extra hardware, ensuring the device
    can reset itself if it encounters an error.'
  prefs: []
  type: TYPE_NORMAL
- en: External WDTs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External WDTs are separate components connected to the microcontroller. These
    timers provide additional flexibility and can be used when the internal WDT isn’t
    sufficient or if redundancy is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of their features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: Can be chosen based on specific requirements (for example,
    longer timeout periods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redundancy**: Adding an external watchdog provides an extra layer of safety'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independence**: Operate independently of the microcontroller’s clock and
    power'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: In a critical automotive system, an external WDT can provide
    an additional safeguard, ensuring the system resets even if the internal timer
    fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Windowed WDTs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Windowed WDTs** (**WWDTs**) add an extra layer of control by introducing
    a *window* period. The system must reset the timer within a specific window period;
    too early or too late resets the system. This prevents scenarios where the software
    gets stuck in a loop resetting the watchdog too frequently (which could mask a
    malfunction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Their features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precision**: Require the timer to be reset within a specific time window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault detection**: Can detect both early and late watchdog resets, offering
    improved fault detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Enhance system security by ensuring the timer is reset at appropriate
    intervals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: In a medical device, a WWDT ensures the control software
    operates correctly within defined time intervals, adding an extra layer of reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: IWDGs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IWDGs are designed to be robust and reliable. They run from a separate clock
    source, usually a **low-speed internal** (**LSI**) clock, and operate independently
    of the main system clock. This independence ensures they continue to function
    even if the main clock fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independence**: Operate from a separate clock source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robustness**: Continue functioning even if the main system clock fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal configuration**: Typically simple to configure and use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: In an **industrial control system** (**ICS**), an IWDG
    ensures the system can recover from malfunctions, even if the main clock source
    is disrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the appropriate WDT depends on several factors, including the criticality
    of the application, power constraints, and required reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right WDT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s a quick guide to help you choose the right WDT:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For low-power applications**: Consider internal WDTs due to their integration
    and low power consumption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For high-reliability systems**: Use external WDTs for redundancy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For applications requiring precise timing**: WWDTs provide enhanced fault
    detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For systems needing robust operation**: IWDGs offer continued functionality
    even if the main clock fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different types of WDTs and their features allows us to choose
    the right one for our applications. Whether it’s an internal WDT for simplicity,
    an external one for redundancy, a WWDT for precise control, or an IWDG for robustness,
    there’s a WDT suited for every need.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will delve into the IWDG embedded within the STM32F411
    microcontroller, examining its features and how to leverage it for enhanced system
    reliability.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 IWDG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll analyze the STM32 IWDG module, exploring its main features
    and other relevant information to help you understand how to leverage this powerful
    feature in your embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'STM32 microcontrollers feature two types of WDTs: the IWDG and the **Window
    Watchdog** (**WWDG**). Both are essential for detecting and correcting software
    malfunctions by initiating a system reset, but they each have unique characteristics
    and applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The IWDG operates using a dedicated LSI clock, ensuring it continues to function
    even if the main system clock fails. This makes it highly reliable for applications
    that require continuous monitoring, regardless of the main clock’s state. In contrast,
    the WWDG derives its clock from the APB1 clock and features a configurable time
    window. The system must refresh the WWDG within this time window; failing to do
    so, either too early or too late, will trigger a system reset.
  prefs: []
  type: TYPE_NORMAL
- en: The IWDG is best suited for applications needing an independent watchdog process
    with lower timing accuracy constraints, while the WWDG is ideal for applications
    requiring precise timing windows. Let’s see some key features of the IWDG.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of the IWDG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IWDG in STM32 microcontrollers boasts several key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Free-running downcounter**: The IWDG operates as a free-running downcounter,
    continuously counting down from a preset value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent clock source**: It uses an independent **resistor-capacitor**
    (**RC**) oscillator, allowing it to function in low-power modes such as Standby
    and Stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System reset on timeout**: If the WDT is activated and the downcounter reaches
    zero (0x000), a system reset is triggered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write access protection**: To modify critical registers, a specific sequence
    of operations is required, ensuring protection against accidental or malicious
    modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How the IWDG works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IWDG module operates as an independent safeguard for the microcontroller,
    ensuring the system can recover from software malfunctions. *Figure 16**.1* presents
    a block diagram of the IWDG, sourced from the reference manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1: IWDG block diagram](img/B21914_16_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: IWDG block diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down its functional blocks and how it operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0xCCCC` to the Key Register (`IWDG_KR`). This action initiates the downcounter,
    which begins counting down from the reset value of `0xFFF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xAAAA` to the `IWDG_KR` register, which reloads the counter with the value
    from the Reload Register (`IWDG_RLR`) and prevents a reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware watchdog feature**: If enabled, the IWDG is automatically activated
    at power-on. In this mode, the WDT will generate a reset unless the Key Register
    is written with the appropriate value before the counter reaches zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWDG_PR`) and reload (`IWDG_RLR`) registers, we must temporarily disable write
    access protection by writing the code `0x5555` to the `IWDG_KR` register. After
    doing this, any changes to these registers must be made immediately; otherwise,
    access protection will be re-enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this general overview of the IWDG block in mind, let’s analyze the key
    registers one by one.
  prefs: []
  type: TYPE_NORMAL
- en: IWDG registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the crucial registers within the IWDG peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the `IWDG_KR`).
  prefs: []
  type: TYPE_NORMAL
- en: IWDG Key Register (IWDG_KR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IWDG_KR` register is a key register used to control the IWDG’s operations,
    including starting the watchdog, reloading the counter, and disabling write access
    to other registers. This register is pivotal in managing the IWDG’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key operations in this register include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0xCCCC`: Start the IWDG. Writing this value to `IWDG_KR` starts the IWDG timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xAAAA`: Reload the counter. Writing this value reloads the IWDG counter,
    preventing it from reaching zero and triggering a system reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x5555`: Disable write protection. This value allows modifications to the
    prescaler and reload registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s discuss the `IWDG_PR`).
  prefs: []
  type: TYPE_NORMAL
- en: IWDG Prescaler Register (IWDG_PR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IWDG_PR` register is used to set the prescaler value, which determines
    the frequency of the IWDG clock by dividing the LSI clock. Adjusting this register
    helps configure the countdown speed of the WDT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key bits in this register is `PR[2:0]`: Prescaler value. These bits can be
    set to divide the LSI clock by 4, 8, 16, 32, 64, 128, or 256, allowing flexibility
    in setting the WDT interval.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move on to the `IWDG_RLR`).
  prefs: []
  type: TYPE_NORMAL
- en: IWDG Reload Register (IWDG_RLR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IWDG_RLR` register defines the reload value for the IWDG counter. This
    value determines the timeout period before the watchdog triggers a system reset
    if not reloaded in time.
  prefs: []
  type: TYPE_NORMAL
- en: The key field in this register is `RL[11:0]`; this means reload value. It is
    a 12-bit value that sets the counter’s reload value, which can range from 0x000
    to 0xFFF.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examine the `IWDG_SR`).
  prefs: []
  type: TYPE_NORMAL
- en: IWDG Status Register (IWDG_SR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IWDG_SR` register provides status information about the IWDG, indicating
    whether updates to the prescaler or reload registers are ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key bits in this register include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PVU`: **Prescaler value update** (**PVU**). This bit indicates that the prescaler
    value is being updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RVU`: **Reload value update** (**RVU**). This bit indicates that the reload
    value is being updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a clear understanding of the IWDG’s functionality and its registers, we
    can now move on to the next section, where we will develop the IWDG driver.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the IWDG driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll use what we’ve learned so far in this chapter to develop
    the IWDG driver.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by setting up the project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a copy of your previous project in your IDE, following the steps outlined
    in earlier chapters. Rename this copied project to `IWDG`. Next, create a new
    file named `iwdg.c` in the `Src` folder and another file named `iwdg.h` in the
    `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The IWDG implementation file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Populate your `iwdg.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down. Let’s look at the **macro** **definitions** first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`IWDG_KEY_ENABLE`: This macro defines the key to enable the IWDG'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWDG_KEY_WR_ACCESS_ENABLE`: This macro defines the key to enable write access
    to IWDG registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWDG_PRESCALER_4`: This macro defines the prescaler value for the IWDG'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IWDG_RELOAD_VAL`: This macro sets the reload value to the maximum, 0xFFF,
    providing the longest timeout period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `iwdg_init()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This line writes `0x0000CCCC` to the IWDG **Key Register** (**KR**) to enable
    the IWDG.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This line writes `0x00005555` to the IWDG Key Register to enable write access
    to the prescaler and reload registers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line sets the prescaler register to divide the clock by 4, as defined by
    `IWDG_PRESCALER_4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This sets the reload register to the maximum value of 0xFFF to get the longest
    possible timeout period.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This waits until the IWDG **status register** (**SR**) indicates that the prescaler
    and reload registers have been updated and are ready.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This writes `0x0000AAAA` to the IWDG Key Register to reload the counter and
    prevent the IWDG from resetting the system.
  prefs: []
  type: TYPE_NORMAL
- en: The `isIwdg_ready()` function checks the Status Register to see if the `PVU`
    and `RVU` bits are cleared. It returns 1 if both bits are cleared, indicating
    that the IWDG is ready, or 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to test inside `main.c`.
  prefs: []
  type: TYPE_NORMAL
- en: The main file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update your `main.c` file as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function kicks off by setting up the `EXTI`) on pin `PC13`, which
    is connected to the blue push button. The function then calls `check_reset_source`
    to determine if the last reset was caused by the IWDG. After that, it initializes
    the IWDG itself, ensuring that the system can recover from software malfunctions.
    The `main` loop continually checks the state of `g_btn_press`; if the button hasn’t
    been pressed, it refreshes the IWDG to prevent a system reset and toggles the
    LED, providing a visual indicator of system activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the next part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `check_reset_source` function determines if the most recent system reset
    was triggered by the IWDG. It begins by checking the `CSR`) for the IWDG reset
    flag (`RCC_CSR_IWDGRSTF`). If this flag is set, it confirms that the watchdog
    initiated the reset. The function then clears this flag by writing to the `RCC_CSR_RMVF`
    bit, ensuring the flag is reset for future detection. As a visual indication of
    the IWDG-triggered reset, the LED is turned on, and a message is printed to the
    UART. The function enters a loop, waiting for the user to press the button (detected
    by the `g_btn_press` variable) before clearing the button press state and exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the interrupt handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `exti_callback` function is a simple yet vital part of our interrupt-handling
    mechanism. Its sole purpose is to set the `g_btn_press` flag to `1`, indicating
    that a button press has been detected. This flag is later used in the main loop
    to control the program flow. The `EXTI15_10_IRQHandler` function is the interrupt
    handler for external interrupts on lines 10 to 15\. When an interrupt is triggered
    on *line 13*, this handler first checks the pending register (`PR`) to confirm
    the interrupt source. Once verified, it clears the pending flag by writing back
    to the `PR` register. After clearing the interrupt, the handler calls `exti_callback`
    to update the `g_btn_press` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the project on the microcontroller, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build and run the project**: Compile the code and upload it to your microcontroller.
    Once running, you should observe the green LED blinking, indicating that the system
    is functioning correctly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitor the serial output**: Open RealTerm or any other serial terminal application.
    Configure it with the appropriate port and baud rate to view the debug messages.
    This will allow you to confirm when the system restarts due to the IWDG.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger a watchdog reset**: Press the blue push button to stop the IWDG timer
    from being refreshed. After the IWDG timeout period elapses, the system will reset,
    and you should see a corresponding message in the serial terminal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the IWDG timer, an important component for enhancing
    the reliability of embedded systems. We began by discussing the general concept
    of WDTs, emphasizing their role in ensuring systems can recover from unexpected
    faults or malfunctions. We explored how WDTs function and highlighted the unique
    features of the IWDG.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we focused on the STM32 implementation of the IWDG, examining its key
    registers and configuration options. We detailed the purpose and usage of essential
    registers such as the Key Register (`IWDG_KR`), Prescaler Register (`IWDG_PR`),
    Reload Register (`IWDG_RLR`), and Status Register (`IWDG_SR`). This provided a
    comprehensive understanding of how to configure and control the IWDG for robust
    system operation.
  prefs: []
  type: TYPE_NORMAL
- en: We also provided practical examples to solidify our understanding, including
    the development of a bare-metal IWDG driver. This involved initializing the IWDG,
    configuring its prescaler and reload values, and implementing the necessary functions
    to ensure the system can recover from software malfunctions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the **Direct Memory Access** (**DMA**)
    module, an advanced feature for transferring data.
  prefs: []
  type: TYPE_NORMAL
