- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDE Support and Clangd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the **Language Server Protocol (LSP)** and how you can
    utilize it to enhance your **Integrated Development Environment** **(IDE)**. Our
    primary IDE of choice is **Visual Studio Code (VS Code)**. LLVM has its own implementation
    of LSP known as **Clangd**. We will begin by describing LSP and exploring how
    Clangd leverages it to extend the capabilities provided by the IDE. Finally, we
    will conclude with examples of how various Clang tools, such as Clang-Tidy and
    Clang-Format, can be seamlessly integrated into the IDE through Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Language Server Protocol (LSP) and how does it improve an IDE’s capabilities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How VS Code and Clangd (the Clang LSP server) can be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How LSP is used to connect VS Code and Clangd, through an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Clangd is integrated with other Clang tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why performance matters for Clangd and what optimizations were made to make
    Clangd fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located in the `chapter8` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8)'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Language Server Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IDE is a software application or platform that provides a comprehensive set
    of tools and features to assist developers in creating, editing, debugging, and
    managing software code. An IDE typically includes a code editor with syntax highlighting,
    debugging capabilities, project management features, version control integration,
    and, often, plugins or extensions to support various programming languages and
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Popular examples of IDEs are Visual Studio/VS Code, IntelliJ IDEA, Emacs, and
    Vim. These tools are designed to streamline the development process, making it
    easier for developers to write, test, and maintain their code efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A typical IDE supports multiple languages, and integrating each language can
    be a challenging task. Each language requires specific support, which can be visualized
    in [Figure 8.1](#Figure8.1). It’s worth noting that there are many similarities
    in the development process of different programming languages. For example, the
    languages shown in [Figure 8.1](#Figure8.1) have a code navigation feature that
    allows developers to quickly locate and view the definition of a symbol or identifier
    within their code base.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Programming languages integration in IDEs ](img/Figure8.1_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.1**: Programming languages integration in IDEs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature will be referred to as **go-to definition** in this chapter. Such
    similarities suggest a way to simplify the relationships shown in [Figure 8.1](#Figure8.1)
    by introducing an intermediate level called the **Language Server Protocol**,
    or **LSP**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Programming languages integration in IDEs using LSP ](img/Figure8.2_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.2**: Programming languages integration in IDEs using LSP'
  prefs: []
  type: TYPE_NORMAL
- en: The **LSP** project was initiated by Microsoft in 2015 as part of its efforts
    to improve VS Code, a lightweight, open source code editor. Microsoft recognized
    the need for a standardized way to provide rich language services across different
    programming languages within VS Code and other code editors.
  prefs: []
  type: TYPE_NORMAL
- en: LSP quickly gained popularity and adoption in the developer community. Many
    code editors and IDEs, including VS Code, Emacs, and Eclipse, began implementing
    support for LSP.
  prefs: []
  type: TYPE_NORMAL
- en: Language server implementations emerged for various programming languages. These
    language servers, developed by both Microsoft and the open source community, offered
    language-specific intelligence and services, making it easier to integrate language
    features into different editors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore **Clangd**, a language server that is part
    of clang-tools-extra. Clangd leverages the Clang compiler frontend and offers
    a comprehensive suite of code analysis and language support features. Clangd assists
    developers with intelligent code completion, semantic analysis, and real-time
    diagnostics, helping them to write code more efficiently and catch errors early
    in the development process. We will delve into Clangd in detail here, starting
    with a real example of the interaction between the IDE (VS Code) and Clangd. We
    will begin with the environment setup, including the Clangd build and VS Code
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin our environment setup by building Clangd. Then, we will install
    VS Code, set up the Clangd extension, and configure Clangd within it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Clangd build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s worth building Clangd in release mode, as we did for LLDB in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,*
    *The LLVM debugger, its build, and usage*. This is because performance is crucial
    in IDEs. For instance, Clangd requires building an AST to provide code navigation
    functionality. If a user modifies a document, the document should be rebuilt,
    and the navigation functionality will not be available until the rebuild process
    is completed. This can result in delays in IDE responses. To prevent IDE slowness
    in responses, we should ensure that Clangd is built with all the required optimizations.
    You can use the following project configuration command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.3**: Release configuration for Clangd build'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command has to be run from the `release` folder that we created in [*Section** 1.3.3*](B19722_01.xhtml#x1-290003)*,
    The LLVM debugger, its build, and usage*, as shown in [Figure 1.8](B19722_01.xhtml#x1-29011r8).
    As you can see, we have enabled two projects in [Figure 8.3](#x1-156003r3): `clang`
    and `clang-tools-extra` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to build and install Clangd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will utilize the maximum available threads on the system and install
    the binary into the folder specified in our CMake command in [Figure 8.3](#x1-156003r3),
    which is the `install` folder under the LLVM source tree.
  prefs: []
  type: TYPE_NORMAL
- en: After building the Clangd binary, our next step will include installing VS Code
    and configuring it to work with Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 VS Code installation and setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can download and install VS Code from the VS Code website: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step after running VS Code is to install the **Clangd** extension.
    An open source extension is available to work with Clangd via LSP. The extension’s
    source code can be found on GitHub: [https://github.com/clangd/vscode-clangd](https://github.com/clangd/vscode-clangd).
    However, we can easily install the latest version of the extension directly from
    within VS Code.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, press *Ctrl+Shift+X* (or ![The Apple Key](img/Mac_icon.png) *+Shift+X*
    for macOS) to open the extensions panel. Search for `Clangd` and click the **Install**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Installing the Clangd extension ](img/file4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.4**: Installing the Clangd extension'
  prefs: []
  type: TYPE_NORMAL
- en: After installing the extension, we need to set it up. The main step is to specify
    the path to the Clangd executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access this setting via the **File — Preferences — Settings** menu
    or by pressing *Ctrl + ,* (or ![The Apple Key](img/Mac_icon.png) *+,* for macOS),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Setting up the Clangd extension ](img/file5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.5**: Setting up the Clangd extension'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 8.5](#Figure8.5), we have configured the Clangd path to
    be `/home/ivanmurashko` `/clangbook/llvm-project/install/bin/clangd` . This path
    was used during the installation of the Clangd binary in [*Section** 8.3.1*](#x1-1560001)*,
    Clangd build*.
  prefs: []
  type: TYPE_NORMAL
- en: You can open your favorite C/C++ source file and try to navigate through it.
    For instance, you can search for a definition for a token, switch between a source
    and a header, and so on. In our next example, we will investigate how navigation,
    and especially go-to definition, works through LSP.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Our setup works only for simple projects that do not require special compilation
    flags. If your project requires special configuration to build, then you have
    to use a generated `compile``_commands.json` file that should be placed at the
    root of your project. This file should contain a **Compilation Database** (**CDB**)
    in JSON format, specifying compilation flags for each file in your project. For
    more information about the setup, please refer to [*Figure** 9.5*](B19722_09.xhtml#x1-1880003)*,
    Clangd* *Setup for Large Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: With the required components installed, we are now ready for an LSP demo where
    we will emulate typical development activities in an IDE (open and modify a document,
    jump to a token definition, etc.) and explore how it’s represented via LSP.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 LSP demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this brief LSP demo, we will demonstrate how Clangd opens a file and finds
    a symbol’s definition. Clangd features a comprehensive logging subsystem that
    offers valuable insights into its interaction with the IDE. We will use the log
    subsystem to obtain the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Demo description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, we open a test file as shown in the following screenshot and
    retrieve the definition of the `doPrivateWork` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Go-to definition and hover for the doPrivateWork token ](img/file6.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.6**: Go-to definition and hover for the `doPrivateWork` token'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code communicates with Clangd via standard input/output, and we will use
    Clangd logs to capture the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved by setting up a wrapper shell script instead of using
    the actual clangd binary in the VS Code settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Wrapper shell script setup in VS Code ](img/file7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.7**: Wrapper shell script setup in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following script, `clangd.sh` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.8**: Wrapper shell script for clangd'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 8.8](#x1-159010r8), we use two log options:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one, `-log verbose` , activates verbose logging to ensure that actual
    LSP messages from and to Clangd will be logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option, `-pretty` , is used to provide nicely formatted JSON messages.
    We also redirect stderr output to the log file, `/tmp/clangd.log` , in our case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result, the file will contain logs from our example session. We can view
    these logs using the following command::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs, we can find `"textDocument/definition"` that was sent by VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.9**: The ”textDocument/definition” request sent by the IDE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The request sent by the IDE is received and processed by Clangd. The corresponding
    log is recorded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.10**: Handling of the ”textDocument/definition” request in Clangd'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Clangd creates the response and sends it to the IDE. The corresponding
    log record shows that the reply was sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.11**: The ”textDocument/definition” reply from Clangd'
  prefs: []
  type: TYPE_NORMAL
- en: The logs will be our primary tool to investigate LSP internals. Let’s dive into
    more complex examples.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 LSP session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An LSP session consists of several requests to and responses from the Clangd
    server. It starts with an `"initialize"` request. Then, we open a document, and
    VS Code sends a `"textDocument/didOpen"` notification. After the request, Clangd
    will periodically respond with `"textDocument/publishDiagnostics"` notifications
    when the state of the opened file changes. For example, this occurs when compilation
    is finished and its ready to process navigation requests. Next, we initiate a
    go-to definition request for a token, and Clangd responds with the location information
    for the found definition. We also investigate how Clangd processes file modifications
    that are notified by the client via `"textDocument` `/didChange"` notifications.
    We finish our session with a `"textDocument/didClose"` request when we close the
    opened file. A diagram depicting the interaction is presented in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: LSP session example ](img/Figure8.12_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.12**: LSP session example'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the example in detail. We will start with the `"initialize"` request.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To establish communication, the client (code editor or IDE) and the language
    server exchange JSON-RPC messages. The initialization process begins with the
    client sending an `"initialize"` request to the language server, specifying the
    capabilities it supports. The actual request sent by VS Code is quite large, and
    a simplified version, where some parts of the request are replaced with `"..."`
    , is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.13**: VS Code to Clangd (initialize request)'
  prefs: []
  type: TYPE_NORMAL
- en: In the request, the client (VS Code) tells the server (Clangd) what capabilities
    are supported on the client side; for example, at *Lines 10-13* in [Figure 8.13](#x1-161024r13),
    the client says that it supports the `"textDocument/definition"` request type
    that is used for go-to definition requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language server replies to the request with a response that contains capabilities
    supported by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.14**: Clangd to VS Code (initialize reply)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the same `id` is used to connect the request with its reply.
    Clangd replied that it supports go-to definition requests as specified in *Line*
    *7* in [Figure 8.14](#x1-161042r14). Thus our client (VS Code) can send the navigation
    request to the server, which we will explore later in [*Figure** 8.19*](#x1-1630002)*,
    Go-to* *definition*.
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code acknowledges the initialization by sending an `"initialized"` notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to the `"initialize"` request, there is a notification, and it does
    not expect any response from the server. As a result, it does not have an `"id"`
    field. The `"initialized"` notification can be sent only once, and it should be
    received before any other requests or notifications are sent from the client side.
    After the initialization, we are ready to open a document and send the corresponding
    `"textDocument/didOpen"` notification.
  prefs: []
  type: TYPE_NORMAL
- en: Open document
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a developer opens a C++ source file, the client sends a `"textDocument/didOpen"`
    notification to inform the language server about the newly opened file. In our
    example, the opened file is located at `/home/ivanmurashko/clangbook/helper.hpp`
    , and the corresponding notification sent by VS Code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.15**: VS Code to Clangd (didOpen notification)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, VS Code sends the notification with parameters included in the
    `"params/` `textDocument"` field. These parameters consist of the filename in
    the `"uri"` field and the source file text within the `"text"` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clangd starts compiling the file upon receiving the ’didOpen’ notification.
    It builds an AST and extracts semantic information about different tokens from
    it. The server uses this information to distinguish between different tokens with
    the same name. For example, we can use a token named ’foo’ that may serve as a
    class member or a local variable depending on the scope in which it is used, as
    shown in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.16**: Occurrences of the ’foo’ token in foo.hpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in *Line 8*, we use the `’foo’` token two times: as a function
    call and in a local variable definition.'
  prefs: []
  type: TYPE_NORMAL
- en: The go-to definition request will be delayed until the compilation process is
    finished. It’s worth noting that the majority of requests are put in a queue and
    wait until the compilation process is finished. The rule has some exemptions,
    and some requests can be executed without an AST with a limited provided functionality.
    One of the examples is the code-formatting requests. The code formatting does
    not require an AST and therefore the formatting functionality can be provided
    before the AST is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the state of the file is changed, then Clangd will notify VS Code with the
    `"textDocument/publishDiagnostics"` notification. For example, when the compilation
    process is finished, then Clangd will send the notification to VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.17**: Clangd to VS Code (publishDiagnostics notification)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are no compilation errors; `params/diagnostics` is empty.
    It will contain errors or warning descriptions if our code contains a compilation
    error or warning, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.18**: Clangd to VS Code (publishDiagnostics with compilation error)'
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code processes the diagnostics and displays it, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Compilation error in helper.hpp ](img/file8.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.19**: Compilation error in helper.hpp'
  prefs: []
  type: TYPE_NORMAL
- en: After the compilation finished and we got `"textDocument/publishDiagnostics"`
    , Clangd is ready to process navigation requests, such as `"textDocument/definition"`
    (go-to definition).
  prefs: []
  type: TYPE_NORMAL
- en: Go-to definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find the definition of a symbol in a C++ file, the client sends a `"textDocument/`
    `definition"` request to the language server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.20**: VS Code to Clangd (textDocument/definition request)'
  prefs: []
  type: TYPE_NORMAL
- en: The line position is specified as 7 instead of the actual line 8 in the editor,
    as shown in [Figure 8.6](#Figure8.6). This is because line numbering starts at
    0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language server responds with the definition location in the C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.21**: Clangd to VS Code (textDocument/definition response)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the server responded with the actual position of the definition.
    Another popular action in the IDE is document modification. This functionality
    is served by the `"textDocument/didChange"` notification. Let’s look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Change document
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As part of the document modification, let’s insert a comment, `//` `Constructor`,
    at *Line 6*, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22: Change document ](img/file9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.22**: Change document'
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code will detect that the document has been modified and notify the LSP
    server (Clangd) using the following notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.23**: VS Code to Clangd (didChange notification)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the notification contains the range specification and the text
    for replacing the specified range in the document. One important part of the notification
    is the `"version"` field, which specifies the version of the document.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that `version` changed from 1, as used in the document open (see
    *Line 9* in [Figure 8.15](#x1-162014r15)), to 2 for the document modification
    (see *Line 23* in [Figure 8.23](#x1-164030r23)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clangd starts the document compilation because the document modification can
    cause a significant change in the resulting AST, which is used for navigation
    requests. Once the compilation is finished, the server will respond with the corresponding
    `"textDocument/publishDiagnostics"` notification, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.24**: Clangd to VS Code (publishDiagnostics notification)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the diagnostic was sent for the modified document because it
    contains the version field pointing to version 2, which corresponds to the modified
    document, as seen in *Line 7* of [Figure 8.24](#x1-164042r24).
  prefs: []
  type: TYPE_NORMAL
- en: Our last action in the example is to close the document. Let’s take a closer
    look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a document
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we finish our work with the document and close it, VS Code sends a `"textDocument/didClose"`
    notification to the language server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.25**: VS Code to Clangd (textDocument/didClose request)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After receiving the request, Clangd will remove the document from its internal
    structures. Clangd will not send any updates for the document anymore, thus it
    will empty out the list of diagnostics shown on the client (e.g., in the **Problems**
    pane of VS Code) by sending the final empty `"textDocument/publishDiagnostics"`
    message, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.26**: Clangd to VS Code (textDocument/didClose request)'
  prefs: []
  type: TYPE_NORMAL
- en: The shown example demonstrates the typical interactions between Clangd and VS
    Code. The provided example utilizes functionality from the Clang frontend, that
    is, basic Clang functionality. On the other hand, Clangd has a strong connection
    with other Clang tools, such as Clang-Format and Clang-Tidy, and can reuse the
    functionality provided by these tools. Let’s take a closer look at this.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Integration with Clang tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clangd takes advantage of the LLVM module architecture and has a very strong
    integration with other Clang tools. In particular, Clangd uses Clang-Format libraries
    to provide formatting functionality and Clang-Tidy libraries (such as libraries
    with clang-tidy checks) to support linters in the IDE. The integration is schematically
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27: VS Code with LSP extension and Clangd server for C++ ](img/Figure8.27_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.27**: VS Code with LSP extension and Clangd server for C++'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration from `.clang-format` (see [*Section** 7.4.1*](B19722_07.xhtml#x1-1470001)*,
    Clang-Format* *configuration and usage examples*) is used for formatting, and
    from `.clang-tidy` (see [*Figure** 5.12*](B19722_05.xhtml#x1-1080002)*, Clang-Tidy
    configuration*) for linters. Let’s see how the formatting works in Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Clangd support for code formatting using LSP messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clangd provides robust support for code formatting. This feature is essential
    for developers to maintain consistent code styles and readability in their C and
    C++ projects. Clangd leverages LSP messages, primarily the `"textDocument/formatting"`
    and `"textDocument/rangeFormatting"` requests, to achieve this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting entire documents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `"textDocument/formatting"` request is used when a developer wants to format
    the entire content of a document. This request is typically initiated by the user
    in VS Code by pressing *Ctrl + Shift + I* (or ![The Apple Key](img/Mac_icon.png)
    *+ Shift + I* for macOS); the IDE sends a `"textDocument/formatting"` request
    to Clangd for the entire document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.28**: VS Code to Clangd (textDocument/formatting request)'
  prefs: []
  type: TYPE_NORMAL
- en: Clangd processes this request by utilizing the code style configuration specified
    in the project’s `.clang-format` file. The `.clang-format` file contains formatting
    rules and preferences, allowing developers to define their desired code style;
    see [*Section** 7.4.1*](B19722_07.xhtml#x1-1470001)*, Clang-Format configuration
    and usage* *examples*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response contains the list of modifications to be applied to the opened
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.29**: Clangd to VS Code (textDocument/formatting response)'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we should replace the text at the specified range at *Lines
    7-16* in [Figure 8.29](#x1-168038r29) with new text specified at *Line 6*.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting specific code ranges
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to formatting entire documents, Clangd also supports formatting
    specific code ranges within a document. This is achieved using the `"textDocument/rangeFormatting"`
    request. Developers can select a range within the code, such as a function, a
    block of code, or even just a few lines, and request formatting for that specific
    range, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30: Reformatting a specific code range in helper.hpp ](img/file10.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.30**: Reformatting a specific code range in helper.hpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'When selecting the menu item or pressing *Ctrl + K* and then *Ctrl + F* (or
    ![The Apple Key](img/Mac_icon.png) *+ K* and then ![The Apple Key](img/Mac_icon.png)
    *+ F* for macOS), VS Code will send the following request to Clangd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.31**: VS Code to Clangd (textDocument/rangeFormatting request)'
  prefs: []
  type: TYPE_NORMAL
- en: The `"textDocument/rangeFormatting"` request specifies the range to be formatted
    within the document, and Clangd applies the same formatting rules from the `.clang-format`
    file to this specific code segment. The response will be similar to the one used
    for the formatting request and will contain the modification that should be applied
    to the original text, as shown in [Figure 8.29](#x1-168038r29). The only difference
    will be the method name, which should be `"textDocument/rangeFormatting"` in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that is integrated via Clangd is Clang-Tidy, and it utilizes the
    LSP protocol in a different manner compared to the formatting functionality that
    we just described.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2 Clang-Tidy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we can see, Clangd uses specific LSP methods to implement integration with
    Clang-Format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"textDocument/formatting"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"textDocument/rangeFormatting"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the integration with Clang-Tidy is implemented differently,
    and it reuses the `"publishDiagnostics"` notification to report linter warnings
    and errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate how it works and create a custom Clang-Tidy configuration
    as the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy integration with LSP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will run the misc-methodrename check that we recently created for testing
    method renaming, see [*Section** 7.3*](B19722_07.xhtml#x1-1410003)*, Clang-Tidy
    as a code modification tool*. Our Clang-Tidy configuration will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.32**: .clang-tidy config for IDE integration'
  prefs: []
  type: TYPE_NORMAL
- en: The `.clang-tidy` file with the configuration should be placed in the folder
    with our test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rename our helper class to `TestHelper`, we will be able to observe that
    the lint check we created in [*Section** 7.3*](B19722_07.xhtml#x1-1410003)*, Clang-Tidy
    as a code modification* *tool* will start reporting diagnostics about the incorrect
    method name used for the test class. The corresponding diagnostic is displayed
    in the drop-down pane and in the **PROBLEMS** tab, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.33: Clang-Tidy integration ](img/file11.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 8.33**: Clang-Tidy integration'
  prefs: []
  type: TYPE_NORMAL
- en: 'The message is displayed as part of diagnostics. Specifically, the following
    notification is sent from Clang to VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.34**: Clangd to VS Code (publishDiagnostics notification)'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the figure (*Line 11*), a fix for the problem is also available.
    There is an amazing opportunity to apply Clang-Tidy fixes in the IDE. Let’s explore
    how the functionality is implemented with LSP.
  prefs: []
  type: TYPE_NORMAL
- en: Applying fixes in the IDE
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The fixes can be applied in the IDE and the functionality is provided via the
    `"textDocument/codeAction"` method. The method is used by VS Code to prompt Clangd
    to compute commands for the specific document and range. The most important parts
    of the command are provided in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.35**: VS Code to Clangd (textDocument/codeAction request)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the request is at *Lines 7-11*, where we can see
    a copy of the original diagnostics notification. This information will be used
    to retrieve the necessary document modifications provided by `clang``::``FixItHint`
    in the activated check. Consequently, Clangd can respond with the action that
    describes the required modification to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.36**: Clangd to VS Code (codeAction response)'
  prefs: []
  type: TYPE_NORMAL
- en: The `"edit"` field in [Figure 8.36](#x1-172049r36) is the most important part
    of the response, as it describes the changes to be applied to the original text.
  prefs: []
  type: TYPE_NORMAL
- en: The integration with Clang-Tidy is possible without extra computation because
    the AST is built for navigation and diagnostics purposes by Clangd core. The AST
    can be used as the seed for Clang-Tidy checks, eliminating the need to run a separate
    Clang-Tidy executable to retrieve messages from the linter. This is not the only
    optimization made in Clangd; let’s now look at another example of performance
    optimizations in Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Performance optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtaining a smooth IDE experience with accurate results provided without visible
    delays is a challenging task. One of the ways to achieve this experience is through
    compiler performance optimization, as good navigation can be provided with well-parsed
    source code. Clangd offers excellent examples of performance optimization, which
    we will explore in some detail. We will start with the optimizations for code
    modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.1 Optimizations for modified documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in [*Line** 4*](#x1-1620002)*, Open document*, navigation support
    requires the AST as the basic data structure, so we have to use the Clang frontend
    to obtain it. Additionally, we have to rebuild the AST when there are document
    modifications. Document modification is a common activity for developers, and
    we won’t be able to provide a good IDE experience if we always start the build
    process from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Source code preamble
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To gain insights into the ideas used to speed up AST building for modified
    documents, let’s examine a simple C++ program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.37**: C++ program: helloworld.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program has six lines of code, but the conclusion can be deceptive. The
    `#``include` directive inserts a lot of additional code. We can estimate the amount
    of code inserted by the preprocessor if we run Clang with the `-E` command-line
    option and calculate the number of lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.38**: Number of lines in the post-processed program'
  prefs: []
  type: TYPE_NORMAL
- en: where `<...>` is the folder where llvm-project was cloned; see [Figure 1.1](B19722_01.xhtml#x1-25005r1).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the code that should be parsed contains more than 36,000 lines
    of code. This is a common pattern, and the majority of the code to be compiled
    is inserted from included headers. The part of the document located at the beginning
    of the source file and containing the include directives is called the **preamble**.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that preamble modifications are possible but rare, for instance,
    when we insert a new header. The majority of the modifications are located in
    the code outside the preamble.
  prefs: []
  type: TYPE_NORMAL
- en: The primary idea for performance optimization is to cache the preamble AST and
    reuse it for any compilation of a modified document.
  prefs: []
  type: TYPE_NORMAL
- en: AST build at Clangd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The performance optimization made in Clangd involves a two-part compilation
    process. In the first part, the preamble that contains all included header files
    is compiled into a precompiled header; see [*Section** 10.2*](B19722_10.xhtml#x1-1920002)*,
    Precompiled headers*. This precompiled header is then used in the second stage
    of the compilation process to build the AST.
  prefs: []
  type: TYPE_NORMAL
- en: This complex process serves as a performance optimization, especially when a
    user makes changes to a file that requires recompilation. Although a significant
    portion of compilation time is spent on header files, these files are typically
    not modified frequently. To address this, Clangd caches the AST for header files
    within the precompiled header file.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when modifications are made outside header files, Clangd does not
    need to rebuild them from scratch. Instead, it can reuse the cached AST for headers,
    significantly improving compilation performance and reducing the time needed for
    recompilation when working with header files. If a user modification affects header
    files, then the entire AST should be rebuilt, resulting in a cache miss in such
    cases. It’s worth noting that modifications to headers are not as common as modifications
    to the primary source code (outside the included headers). Therefore, we can expect
    a pretty good cache hit rate for ordinary document modifications.
  prefs: []
  type: TYPE_NORMAL
- en: The precompiled header can be stored on a disk as a temporary file but can also
    reside in memory, which can also be considered a performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cached preamble is a powerful tool that significantly improves Clangd’s
    performance in processing document changes made by a user. On the other hand,
    we should always consider edge cases that involve preamble modification. The preamble
    can be modified in two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicitly**: When the user explicitly modifies the preamble, for instance,
    by inserting a new header into it or deleting an existing one'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicitly**: When the user implicitly modifies the preamble, for instance,
    by modifying the headers that are included in the preamble'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one can be easily detected via a `"textDocument/didChange"` notification
    that affects the range where the preamble is located. The second one is tricky,
    and Clangd should monitor the modifications in the included headers to correctly
    process navigation requests.
  prefs: []
  type: TYPE_NORMAL
- en: Clangd also has some modifications aimed at making preamble compilation faster.
    Some of these modifications required specific processing in Clang. Let’s delve
    into it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2 Building preamble optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An interesting optimization can be applied to function bodies. A function body
    can be considered an essential part of primary indexing because it contains symbols
    that a user can click on, such as getting a definition for the symbol. This primarily
    applies to function bodies that are visible to the user in the IDE. On the other
    hand, many functions and their implementations (bodies) are hidden from the user
    in included headers. As a result, the user cannot request information about symbols
    from such function bodies. However, these bodies are visible to the compiler because
    it resolves include directives and parses the header files from the directives.
    The time spent by the compiler can be significant, considering that a complex
    project can have numerous dependencies, resulting in many header files being included
    in the document opened by the user. One obvious optimization is to skip function
    bodies when parsing header files from the preamble. This can be achieved using
    a special frontend option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.39**: The FrontendOptions class from clang/Frontend/FrontendOptions.h'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clangd utilizes this option when building the preamble in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 8.40**: buildPreamble from clang-tools-extra/clangd/Preamble.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Clangd uses the frontend option to skip function bodies in headers
    but disables it just before building the AST for the main document; see *Lines
    10* *and 16* in [Figure 8.40](#x1-177033r40).
  prefs: []
  type: TYPE_NORMAL
- en: Such optimization can significantly improve the document readiness time (when
    the opened document is ready for navigation requests from the user) for complex
    C++ source files.
  prefs: []
  type: TYPE_NORMAL
- en: While the performance optimizations discussed here offer valuable insights into
    Clangd’s efficiency, it’s important to note that Clangd employs a multitude of
    other techniques to ensure its reliability and speed. Clangd serves as an excellent
    platform for experimenting with and implementing various optimization strategies,
    making it a versatile environment for performance enhancements and innovations.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we acquired knowledge of LSP, a protocol used to provide developer
    tools integration with IDEs. We explored Clangd, an LSP server that is part of
    LLVM and can be considered as a prime example of how it integrates various tools
    discussed in the book. Clangd utilizes the Clang frontend to display compilation
    errors and leverages the AST as a fundamental data structure that provides information
    for navigation requests, such as go-to definition requests. Additionally, Clangd
    is seamlessly integrated with other tools covered in previous chapters, such as
    Clang-Tidy and Clang-Format. This integration showcases the significant benefits
    of the LLVM/Clang module structure.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Language Server Protocol specification: [https://microsoft.github.io/language-server-protocol/](https://microsoft.github.io/language-server-protocol/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clangd documentation: [https://clangd.llvm.org/](https://clangd.llvm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
