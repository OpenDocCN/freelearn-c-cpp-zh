- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using Standard Smart Pointers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准智能指针
- en: C++ emphasizes programming with values. By default, your code uses objects,
    not indirections (references and pointers) to objects. Indirect access to objects
    is, of course, allowed, and rare is the program that never uses such semantics,
    but it is an opt-in and requires additional syntax. [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062)
    explored the association of resource management with object lifetime through destructors
    and the RAII idiom, demonstrating one of C++’s main strengths in that essentially
    all resources (including memory) can be handled implicitly through the very mechanics
    of the language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 强调使用值进行编程。默认情况下，你的代码使用对象，而不是对象的间接引用（引用和指针）。当然，对象的间接访问是允许的，而且很少有程序从不使用这种语义，但这是一种可选的，并且需要额外的语法。[*第4章*](B21071_04.xhtml#_idTextAnchor062)
    探讨了通过析构函数和RAII习语将资源管理与对象生命周期相关联，展示了C++在该方面的主要优势，即基本上所有资源（包括内存）都可以通过语言的机制隐式地处理。
- en: C++ allows the use of raw pointers in code but does not actively encourage it.
    Quite the contrary, in fact – raw pointers are a low-level facility, extremely
    efficient but easy to misuse, and for which it is not easy to infer responsibility
    about the *pointee* directly from the source code. Starting with the (now-removed)
    `auto_ptr<T>` facility of decades past, there has been an effort in the C++ community
    to define abstractions around lower-level facilities, such as raw pointers, through
    types that provide clear, well-defined semantics and reduce the risk of programming
    errors. This effort has met with significant success, in large part due to the
    expressiveness of the C++ language and its ability to create powerful and efficient
    abstractions, without losing speed or using more memory at runtime. For this reason,
    in contemporary C++, raw pointers are usually encapsulated underneath harder-to-misuse
    abstractions, examples of which include standard containers and smart pointers,
    such as the ones we will explore in this chapter; raw pointers that are not encapsulated
    are mostly used to mean “*Here’s a resource you can use but do* *not own*.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许在代码中使用原始指针，但并不积极鼓励这样做。事实上，恰恰相反——原始指针是一种低级设施，效率极高但容易误用，并且从源代码中直接推断出对*指针所指内容*的责任并不容易。从几十年前的（现在已移除的）`auto_ptr<T>`设施开始，C++社区一直在努力定义围绕低级设施（如原始指针）的抽象，通过提供清晰、定义良好的语义的类型来减少编程错误的风险。这一努力取得了显著的成功，这在很大程度上得益于C++语言的丰富性和其创建强大且高效的抽象的能力，而不会在运行时损失速度或使用更多内存。因此，在当代C++中，原始指针通常封装在更难误用的抽象之下，例如标准容器和智能指针，这些内容我们将在本章中探讨；未封装的原始指针主要用于表示“*这里有一个你可以使用但*
    *不拥有*的资源。”
- en: This chapter will look at how to use the standard smart pointer types of C++.
    We will first look at what they are, and then delve into ways to use the main
    smart pointer types efficiently. Finally, we will look at those moments where
    we need to “get our hands dirty” (so to speak) and use raw pointers, ideally (but
    not only) through the mediation of smart pointers. This should lead us to learn
    how to choose standard smart pointers for a given use case, how to use them appropriately,
    and how to handle resources that have to be freed through custom mechanisms. Throughout
    this journey, we will keep in mind and explain the costs of the choices we make.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何使用C++的标准智能指针类型。我们首先将了解它们是什么，然后深入探讨如何有效地使用主要智能指针类型。最后，我们将探讨那些需要“亲自动手”（如此说法）并使用原始指针的时刻，理想情况下（但不仅限于此）通过智能指针的介来实现。这应该会引导我们学习如何为特定用例选择标准智能指针，如何适当地使用它们，以及如何处理必须通过自定义机制释放的资源。在整个过程中，我们将牢记并解释我们所做选择的开销。
- en: 'In this chapter, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Take a quick look at the general idea of standard smart pointers to develop
    an idea of their reason for being
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速了解一下标准智能指针的一般概念，以形成它们存在原因的认识
- en: Look more closely at `std::unique_ptr`, including how it can be used to handle
    scalars, arrays, and release resources that are allocated in atypical ways
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更仔细地看看 `std::unique_ptr`，包括它是如何被用来处理标量、数组和以非典型方式分配的资源
- en: Look at `std::shared_ptr` and the use cases for this essential but more costly
    type, in order to grasp when alternatives should be preferred
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 `std::shared_ptr` 以及这种基本但成本更高的类型的用例，以便了解何时应优先考虑替代方案
- en: Take a quick look at `std::weak_ptr`, a companion to `std::shared_ptr` that
    is useful when there is a need to model temporary shared ownership
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速看一下`std::weak_ptr`，它是`std::shared_ptr`的伴侣，当需要模拟临时共享所有权时非常有用
- en: Look at cases where raw pointers should be used, as they still have their place
    in the C++ ecosystem
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看哪些情况下应该使用原始指针，因为它们在C++生态系统中仍有其位置
- en: Ready? Let’s dive in!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们深入探讨！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter5).
- en: The standard smart pointers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准智能指针
- en: C++ has a relatively small *zoo* of smart pointers. Before looking at the set
    of options provided by the standard, let’s take a moment to show the problem we
    are trying to solve. Consider the following (deliberately incomplete) program.
    Do you see anything wrong with it?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++的智能指针种类相对较少。在查看标准提供的选项集之前，让我们花点时间展示我们试图解决的问题。考虑以下（故意不完整）的程序。你看到它有什么问题吗？
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is code that is legal but not something you want to see in a contemporary
    program. There’s just so much that can go wrong here, such as the following from
    a non-exhaustive list of potential problems:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在语法上是合法的，但你不希望在当代程序中看到它。这里可能出错的地方太多了，以下是一个潜在问题的非详尽列表：
- en: We don’t know whether `g()` will call `delete p`, leading to a second `delete`
    (on a destroyed object!) in `h()` afterward
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道`g()`是否会调用`delete p`，这可能导致在`h()`之后的第二次`delete`（在已销毁的对象上！）
- en: We don’t know whether `g()` might throw, in which case the `delete p;` instruction
    in `h()` will never be reached
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道`g()`是否可能会抛出异常，在这种情况下，`h()`中的`delete p;`指令将永远不会被执行
- en: We don’t know whether `h()` should be assumed to own `p`, in the sense that
    we do not know whether it should be responsible for calling `operator delete()`
    on `p` (maybe it’s meant to be the responsibility of `g()`, or some other function)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道是否应该假设`h()`拥有`p`，也就是说，我们不知道它是否应该负责在`p`上调用`operator delete()`（也许它应该是`g()`或其他函数的责任）
- en: We do not know whether what `p` points to has been allocated with `new`, `new[]`,
    or something else (`malloc()`, some facility from another language, some custom
    utility in your code base, etc.)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不知道`p`指向的内容是否是用`new`、`new[]`或其他方式（如`malloc()`、来自其他语言的某些设施、代码库中的某些自定义实用工具等）分配的
- en: We don’t even know whether what `p` points to has been dynamically allocated
    at all; `p` could point to a global or a `static` variable declared in `f()`,
    for example (a bad idea, but some people do that – for example, when implementing
    the singleton design pattern in a non-idiomatic way for C++)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至不知道`p`指向的内容是否已经动态分配；例如，`p`可能指向在`f()`中声明的全局或`static`变量（这是一个坏主意，但有些人确实这样做——例如，以非惯用方式在C++中实现单例设计模式）
- en: 'Compare, for example, two possible implementations of `f()` (there are many,
    many more we could consider, but these will suffice for now):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，比较`f()`的两种可能实现（我们可以考虑的还有很多，但这里这些就足够了）：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first case, it *might* make sense to call `delete` on the returned pointer,
    but in the second case, it would be disastrous to do so. Nothing in the function’s
    signature clearly informs the client code whether we are facing one situation
    or the other, or even something else entirely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，调用返回指针上的`delete`可能是有意义的，但在第二种情况下，这样做将是灾难性的。函数签名中没有任何内容明确告知客户端代码我们面临的是这种情况，还是另一种情况，甚至完全是其他情况。
- en: As a “bonus” of sorts, what happens if someone calls `f()` without using the
    returned value? If `f()` is implemented as `return new X;` or something similar,
    then the code will leak – an unpleasant perspective indeed. Note that since C++17,
    you can mitigate this specific problem by annotating the return type of `f()`
    with the `[[nodiscard]]` attribute, but it’s still something you should be aware
    of. Returning raw pointers from a function is something we mostly try to avoid,
    even though we sometimes have to do so.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为某种“奖励”，如果有人调用`f()`而没有使用返回值会怎样？如果`f()`实现为`return new X;`或类似的内容，那么代码将发生泄漏——这确实是一个不愉快的视角。请注意，自C++17以来，您可以通过在`f()`的返回类型上使用`[[nodiscard]]`属性来减轻这个问题，但您仍然应该注意。从函数返回原始指针是我们主要试图避免的，尽管有时我们不得不这样做。
- en: There are other possible pitfalls here, and they all have a common theme – using
    raw pointers, we traditionally cannot tell from the source code what the semantics
    are. More specifically, we cannot say for sure who is responsible for both the
    pointer and what it points to. The fact that raw pointers do not provide clear
    ownership information has been a recurring source of bugs in C++ over the years.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有其他可能的陷阱，它们都有一个共同的主题——使用原始指针，我们传统上无法从源代码中知道语义是什么。更具体地说，我们无法确定谁负责指针及其指向的对象。原始指针不提供清晰的所有权信息，这多年来一直是C++中bug的反复来源。
- en: 'Now, for a different situation, consider the following code excerpt:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一种情况，以下代码片段：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, `f()` allocates an `X` object pointed to by `p`, after which two
    threads, `th0` and `th1`, copy `p` (thus sharing the `X` object that `p` points
    to). Finally, `th0` and `th1` are detached, meaning that the threads will run
    until completion, even after `f()` is done. If we do not know in what order `th0`
    and `th1` will conclude, we cannot clearly state which one should be responsible
    for calling `operator delete()` on `p`. This is yet another issue of unclear responsibility
    over the *pointee* but of a different kind than our first example, and as such,
    it needs a different solution.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`f()` 分配了一个由`p`指向的`X`对象，之后两个线程`th0`和`th1`复制`p`（从而共享`p`指向的`X`对象）。最后，`th0`和`th1`被分离，这意味着线程将一直运行到完成，即使`f()`已经执行完毕。如果我们不知道`th0`和`th1`将如何结束，我们就不能明确地说哪个线程应该负责在`p`上调用`operator
    delete()`。这是关于指针所指对象责任不明确的问题，但与我们的第一个例子不同，因此需要不同的解决方案。
- en: For the cases where there is a clearly identified last owner of a pointed-to
    object, regardless of whether the *pointee* is shared or not between pointers,
    you probably want to use `std::unique_ptr`. In the (more niche, but very real
    and quite subtle) case where the pointed-to object is shared by at least two “co-owners”
    and the order in which these owners will be destroyed is a priori unknown, `std::shared_ptr`
    is the tool of choice. The following sections go into the roles and meaning of
    these types in more detail, hopefully helping you make an informed choice when
    choosing a smart pointer type for a given use case.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有明确标识的最后所有者的指针所指对象的情况，无论指针之间是否共享指针所指对象，你可能希望使用`std::unique_ptr`。在（更专业，但非常真实且相当微妙）指针所指对象至少由两个“共同所有者”共享，并且这些所有者将销毁的顺序是先验未知的情况下，`std::shared_ptr`是首选工具。以下几节将更详细地介绍这些类型的作用和意义，希望有助于你在选择智能指针类型时做出明智的选择。
- en: On the exposition of intent through function signatures
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在通过函数签名表达意图的解释中
- en: Even though we have not looked in detail at the standard smart pointers yet,
    it might be appropriate to offer a few words on what they mean, in particular
    for `std::unique_ptr` and `std::shared_ptr`. These two types convey *ownership
    semantics* – `std::unique_ptr` represents *sole ownership* of the pointee, and
    `std::shared_ptr` represents *co-ownership* (or *shared ownership*) of the pointee.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有详细研究标准智能指针，但可能适当地提供一些关于它们含义的说明，特别是对于`std::unique_ptr`和`std::shared_ptr`。这两种类型传达*所有权语义*——`std::unique_ptr`代表*唯一所有权*，而`std::shared_ptr`代表*共同所有权*（或*共享所有权*）。
- en: 'It’s important to understand the difference between *owning* (in particular,
    *co-owning*) a pointee and *sharing* a pointee. Consider the following example,
    which uses `std::unique_ptr` (even though we have not covered it yet, but we’re
    getting there) and raw pointers *together* in order to inscribe ownership semantics
    in the type system:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理解拥有（特别是共同拥有）指针所指对象与共享指针所指对象之间的区别非常重要。考虑以下示例，该示例使用`std::unique_ptr`（尽管我们尚未介绍它，但我们正在接近这个目标）和原始指针*一起*来在类型系统中记录所有权语义：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As mentioned when introducing this example, we used a `std::unique_ptr` object
    to model ownership – `make_one()` constructs `std::unique_ptr<T>` and transfers
    ownership to the caller; then, that caller keeps ownership of that object and
    shares the underlying pointer with others (here, `print_pointee()`) but does not
    relinquish ownership of the pointee. Using yet not owning is modeled by a raw
    pointer. This shows us in a highly simplified setting that there is a difference
    between owning and sharing a resource – `p` in `main()` owns the resource, yet
    it shares it with the non-owner, `p`, in `print_pointee()`. This is all safe and
    idiomatic C++ code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如在介绍此示例时提到的，我们使用 `std::unique_ptr` 对象来表示所有权——`make_one()` 构造 `std::unique_ptr<T>`
    并将所有权转让给调用者；然后，该调用者保持对该对象的所有权，并与他人（此处为 `print_pointee()`）共享基础指针，但不放弃对指向对象的所有权。使用但不拥有是通过原始指针来模拟的。这在一个高度简化的设置中向我们展示了拥有和共享资源之间的区别——`main()`
    中的 `p` 拥有资源，但与非所有者 `p` 在 `print_pointee()` 中共享资源。这全部都是安全且符合 C++ 习惯的代码。
- en: Knowing that the standard smart pointer types model represents ownership, we
    know that as long as there is a single, clear last user of a resource, `std::unique_ptr`
    tends to be the type of choice; it is much more lightweight than `std::shared_ptr`
    (as we will see), and it provides the appropriate ownership semantics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 了解标准智能指针类型模型表示所有权的知识，我们知道只要有一个明确的最后用户使用资源，`std::unique_ptr` 往往是首选类型；它比 `std::shared_ptr`（我们将会看到）轻量得多，并且提供了适当的所有权语义。
- en: 'There are, of course, use cases where `std::unique_ptr` is not a good choice.
    Consider this simplified, not thread-safe, and incomplete code excerpt:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些情况下 `std::unique_ptr` 不是一个好的选择。考虑以下简化、非线程安全且不完整的代码片段：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that `borrow_one()` shares a pointer with the calling code but does not
    share *ownership* of that pointer – the provider of the `entity` objects remains
    solely responsible for the lifetime of these objects in this case. This would
    neither be a case for `std::unique_ptr` (the sole owner of the resource) nor `std::shared_ptr`
    (the co-owner of the resource). There are alternatives to using raw pointers to
    express a non-owning pointer, as we will see in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`borrow_one()` 与调用代码共享一个指针，但不共享 *所有权* ——在这种情况下，`entity` 对象的提供者仍然对这些对象的生存期负责。这既不是
    `std::unique_ptr`（资源的唯一所有者）的情况，也不是 `std::shared_ptr`（资源的共同所有者）的情况。我们将看到，有其他方法可以使用原始指针来表示非所有权的指针，正如我们在
    [*第 6 章*](B21071_06.xhtml#_idTextAnchor096) 中将看到的那样。
- en: The important point here is that *function signatures convey meaning*, and it’s
    important to use the types that convey our intent. To do so, we have to understand
    that intent. Let’s keep that in mind as we explore how to use the standard smart
    pointers to our advantage in the following sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要点是 *函数签名传达了意义*，并且使用传达我们意图的类型是很重要的。为了做到这一点，我们必须理解这个意图。让我们在以下章节中探索如何使用标准智能指针来发挥优势时记住这一点。
- en: Type unique_ptr
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入 unique_ptr
- en: As its name suggests, a `unique_ptr<T>` object represents sole (unique) ownership
    of a pointed-to object. That happens to be a common case – maybe even the most
    common case – of ownership semantics when dealing with dynamically allocated memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`unique_ptr<T>` 对象表示对指向对象的唯一（独特）所有权。这恰好是处理动态分配内存时所有权语义的常见情况——甚至可能是最常见的情况。
- en: 'Consider our first (still deliberately incomplete) example in this chapter,
    where ownership of the *pointee* was not something we could determine from the
    source code, and let’s rewrite it with `unique_ptr` objects instead of raw pointers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑本章的第一个（仍然故意不完整）示例，其中我们无法从源代码中确定 *指向对象的所有权，并让我们用 `unique_ptr` 对象而不是原始指针来重写它：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: // ...
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: // dynamically create an X or something derived from
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: // 动态创建一个 X 或其派生类
- en: // X and return it without risk of a leak
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: // X 并返回它，而不会存在泄漏的风险
- en: unique_ptr<X> factory(args);
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: unique_ptr<X> factory(args);
- en: // pass-by-value which means in practice pass-by-movement
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: // 值传递，这在实践中意味着移动传递
- en: // since unique_ptr is uncopiable
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: // 由于 unique_ptr 不可复制
- en: unique_ptr<X> borrowing(unique_ptr<X>);
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: unique_ptr<X> borrowing(unique_ptr<X>);
- en: // pass-by-reference to allow mutating the pointee. In
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过引用传递以允许修改指向对象。在
- en: // practice, X* would be a better choice here
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: // 实践中，X* 会是一个更好的选择
- en: void possible_mutation(unique_ptr<X>&);
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: void possible_mutation(unique_ptr<X>&);
- en: // pass by reference-to-const to consult the pointee but
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: // 通过引用到 const 传递以查询指向对象，但
- en: // not mutate it. In practice, prefer const X* here
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: // 不要修改它。在实践中，这里更喜欢 const X*
- en: void consult(const unique_ptr<X>&);
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: void consult(const unique_ptr<X>&);
- en: '// sink() consumes the object passed as argument : gets'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '// sink() 消耗作为参数传递的对象 : 获取'
- en: // in, never gets out. This could use pass-by-value but
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: // in, never gets out. This could use pass-by-value but
- en: // intent is probably clearer with a rvalue-reference
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: // 用右值引用可能更清晰
- en: void sink(unique_ptr<X> &&);
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: void sink(unique_ptr<X> &&);
- en: // ...
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#include <memory>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: class X {
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: class X {
- en: // ...
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: std::unique_ptr<X> f();
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<X> f();
- en: void g(X*);
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: void g(X*);
- en: void h() {
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: void h() {
- en: // we could write std::unique_ptr<X> instead of auto
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: // 我们可以写 std::unique_ptr<X> 而不是 auto
- en: auto p = f();
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = f();
- en: g(p.get());
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: g(p.get());
- en: '} // p implicitly releases the pointed-to X object here'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '} // p 在这里隐式释放了指向的 X 对象'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#include “planet.h”'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '#include “planet.h”'
- en: '#include <memory>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: '#include <string>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <string>'
- en: '#include <vector>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <vector>'
- en: std::unique_ptr<Planet>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<Planet>
- en: create_planet(std::string_view name);
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: create_planet(std::string_view name);
- en: class solar_system {
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: class solar_system {
- en: std::vector<std::unique_ptr<Planet>> planets {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: std::vector<std::unique_ptr<Planet>> planets {
- en: create_planet(“mercury.data”),
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: create_planet(“mercury.data”),
- en: create_planet(“venus.data”), // etc.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: create_planet(“venus.data”), // 等。
- en: '};'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'public:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: // solar_system is uncopyable by default
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: // solar_system 默认是不可复制的
- en: // solar_system is movable by default
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: // solar_system 默认是可移动的
- en: // no need to write ~solar_system as planets
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: // 无需写 ~solar_system，因为行星
- en: // manages its resources implicitly
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: // 管理其资源隐式
- en: '};'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#include <memory>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: template <class T>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: bool point_to_same(const std::unique_ptr<T> &p0,
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: bool point_to_same(const std::unique_ptr<T> &p0,
- en: const std::unique_ptr<T> &p1) {
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: const std::unique_ptr<T> &p1) {
- en: return p0 == p1;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: return p0 == p1;
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: template <class T>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: bool have_same_value(const std::unique_ptr<T> &p0,
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: bool have_same_value(const std::unique_ptr<T> &p0,
- en: const std::unique_ptr<T> &p1) {
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: const std::unique_ptr<T> &p1) {
- en: return p0 && p1 && *p0 == *p1;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: return p0 && p1 && *p0 == *p1;
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '#include <cassert>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <cassert>'
- en: int main() {
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: // two distinct pointers to objects with same value
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: // 两个指向具有相同值的对象的独立指针
- en: std::unique_ptr<int> a{ new int { 3 } };
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<int> a{ new int { 3 } };
- en: std::unique_ptr<int> b{ new int { 3 } };
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<int> b{ new int { 3 } };
- en: assert(point_to_same(a, a) && have_same_value(a, a));
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: assert(point_to_same(a, a) && have_same_value(a, a));
- en: assert(!point_to_same(a, b) && have_same_value(a, b));
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: assert(!point_to_same(a, b) && have_same_value(a, b));
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: void f(int n) {
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: void f(int n) {
- en: // p points to an int of value 3
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: // p 指向一个值为 3 的 int
- en: std::unique_ptr<int> p{ new int{ 3 } };
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<int> p{ new int{ 3 } };
- en: // q points to an array of n int objects
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: // q 指向一个 n 个 int 对象的数组
- en: // initialized to zero
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: // 初始化为零
- en: std::unique_ptr<int[]> q{ new int[n] {} };
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<int[]> q{ new int[n] {} };
- en: // example usage
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: // 示例用法
- en: std::cout << *p << ‘\n’; // displays 3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << *p << ‘\n’; // 显示 3
- en: for(int i = 0; i != n; ++i) {
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i != n; ++i) {
- en: // operator[] supported for unique_ptr<T[]>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: // operator[] 对 unique_ptr<T[]> 支持操作
- en: q[i] = i + 1;
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: q[i] = i + 1;
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '} // the destructor of q calls delete [] on its pointee'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '} // q 的析构函数在其指针上调用 delete []'
- en: // the destructor of p calls delete on its pointee
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: // p 的析构函数在其指针上调用 delete
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#include <cstddef>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <cstddef>'
- en: '#include <memory>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: template <class T>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: class fixed_size_array {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: class fixed_size_array {
- en: std::size_t nelems{};
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: std::size_t nelems{};
- en: std::unique_ptr<T[]> elems {};
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<T[]> elems {};
- en: 'public:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: fixed_size_array() = default;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: fixed_size_array() = default;
- en: auto size() const { return nelems; }
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: auto size() const { return nelems; }
- en: bool empty() const { return size() == 0; }
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: bool empty() const { return size() == 0; }
- en: fixed_size_array(std::size_t n)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: fixed_size_array(std::size_t n)
- en: ': nelems { n }, elems{ new T[n] {} } {'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ': nelems { n }, elems{ new T[n] {} } {'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: T& operator[](int n) { return elems[n]; }
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: T& operator[](int n) { return elems[n]; }
- en: const T& operator[](int n) const { return elems[n]; }
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: const T& operator[](int n) const { return elems[n]; }
- en: // etc.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: // 等。
- en: '};'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: template<class T, class D = std::default_delete<T>>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: template<class T, class D = std::default_delete<T>>
- en: class unique_ptr {
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: class unique_ptr {
- en: // ...
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: template<class T> struct default_delete {
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: template<class T> struct default_delete {
- en: constexpr default_delete() noexcept = default;
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: constexpr default_delete() noexcept = default;
- en: // ...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: constexpr void operator()(T *p) const { delete p; }
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: constexpr void operator()(T *p) const { delete p; }
- en: '};'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#include <memory>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: class requires_dynamic_alloc {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: class requires_dynamic_alloc {
- en: ~requires_dynamic_alloc() = default; // private
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ~requires_dynamic_alloc() = default; // 私有
- en: // ...
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: friend struct cleaner;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: friend struct cleaner;
- en: '};'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // ...
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: struct cleaner {
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: struct cleaner {
- en: template <class T>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: void operator()(T *p) const { delete p; }
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: void operator()(T *p) const { delete p; }
- en: '};'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: int main() {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using namespace std;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: // requires_dynamic_alloc r0; // no
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: // requires_dynamic_alloc r0; // 不行
- en: //auto p0 = unique_ptr<requires_dynamic_alloc>{
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: //auto p0 = unique_ptr<requires_dynamic_alloc>{
- en: //   new requires_dynamic_alloc
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: //   new requires_dynamic_alloc
- en: //}; // no, as delete not available to default deleter
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: //}; // 不行，因为默认删除器无法访问 delete
- en: auto p1 = unique_ptr<requires_dynamic_alloc, cleaner>{
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: auto p1 = unique_ptr<requires_dynamic_alloc, cleaner>{
- en: new requires_dynamic_alloc
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: new requires_dynamic_alloc
- en: '}; // ok, will use cleaner::operator() to delete pointee'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '}; // 好的，将使用 cleaner::operator() 来删除指针'
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#include <memory>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: struct releasable {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: struct releasable {
- en: void release() {
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: void release() {
- en: // overly simplified for the sake of this example
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: // 为了本例简化过度
- en: delete this;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: delete this;
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'protected:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'protected:'
- en: ~releasable() = default;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ~releasable() = default;
- en: '};'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'class important_resource : public releasable {'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'class important_resource : public releasable {'
- en: // ...
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: void release(releasable *p) {
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: void release(releasable *p) {
- en: if(p) p->release();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: if(p) p->release();
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using namespace std;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: auto p = unique_ptr<important_resource,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = unique_ptr<important_resource,
- en: void(*)(releasable*)>{
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: void(*)(releasable*)>{
- en: new important_resource, release
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: new important_resource, release
- en: '}; // ok, will use release() to delete pointee'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}; // 好的，将使用 release() 来删除指针'
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#include <memory>'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: struct releasable {
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: struct releasable {
- en: void release() {
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: void release() {
- en: // overly simplified for the sake of this example
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: // 为了本例简化过度
- en: delete this;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: delete this;
- en: '}'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'protected:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'protected:'
- en: ~releasable() = default;
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ~releasable() = default;
- en: '};'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'class important_resource : public releasable {'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'class important_resource : public releasable {'
- en: // ...
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: void release(releasable *p) {
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: void release(releasable *p) {
- en: if(p) p->release();
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: if(p) p->release();
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using namespace std;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: auto p = unique_ptr<important_resource,
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = unique_ptr<important_resource,
- en: void(*)(releasable*)>{
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: void(*)(releasable*)>{
- en: new important_resource, release
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: new important_resource, release
- en: '}; // ok, will use release() to delete pointee'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}; // 好的，将使用 release() 来删除指针'
- en: static_assert(sizeof(p) > sizeof(void*));
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: static_assert(sizeof(p) > sizeof(void*));
- en: auto q = unique_ptr<
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = unique_ptr<
- en: important_resource,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: important_resource,
- en: decltype([](auto p) { release(p); })>{
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: decltype([](auto p) { release(p); })}{
- en: new important_resource
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: new important_resource
- en: '};'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: static_assert(sizeof(q) == sizeof(void*));
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: static_assert(sizeof(q) == sizeof(void*));
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: template <class T, class ... Args>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T, class ... Args>
- en: std::unique_ptr<T> make_unique(Args &&... args) {
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<T> make_unique(Args &&... args) {
- en: return std::unique_ptr<T>{
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: return std::unique_ptr<T>{
- en: new T(std::forward<Args>(args)...);
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: new T(std::forward<Args>(args)...);
- en: '}'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: template <class T>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: class pair_with_alloc {
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: class pair_with_alloc {
- en: T *p0, *p1;
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: T *p0, *p1;
- en: 'public:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: pair_with_alloc(const T &val0, const T &val1)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc(const T &val0, const T &val1)
- en: ': p0{ new T(val0) }, p1{ new T(val1) } {'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ': p0{ new T(val0) }, p1{ new T(val1) } {'
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~pair_with_alloc() {
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ~pair_with_alloc() {
- en: delete p1; delete p0;
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: delete p1; delete p0;
- en: '}'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // copy and move operations left to your imagination
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: // 复制和移动操作留给你的想象
- en: '};'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: // ...
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: T *p0, *p1; // p0 declared before p1
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: T *p0, *p1; // p0 在 p1 之前声明
- en: 'public:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: '// below:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: // 下面：
- en: // - new T(val0) will occur before construction of p0
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: // - new T(val0) 将在 p0 构造之前发生
- en: // - new T(val1) will occur before construction of p1
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: // - new T(val1) 将在 p1 构造之前发生
- en: // - construction of p0 will precede construction of p1
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: // - p0 的构造将在 p1 的构造之前发生
- en: pair_with_alloc(const T &val0, const T &val1)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc(const T &val0, const T &val1)
- en: ': p0{ new T(val0) }, p1{ new T(val1) } {'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ': p0{ new T(val0) }, p1{ new T(val1) } {'
- en: '}'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE19]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#include <memory>'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: template <class T>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: class pair_with_alloc {
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: class pair_with_alloc {
- en: std::unique_ptr<T> p0, p1;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<T> p0, p1;
- en: 'public:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: pair_with_alloc(const T &val0, const T &val1)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc(const T &val0, const T &val1)
- en: ': p0{ new T(val0) }, p1{ new T(val1) } {'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ': p0{ new T(val0) }, p1{ new T(val1) } {'
- en: '}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // destructor implicitly correct
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: // 析构函数隐式正确
- en: // copy and move operations implicitly work
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: // 复制和移动操作隐式工作
- en: // or are left to your imagination
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: // 或留给你的想象
- en: '};'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: // ...
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: std::unique_ptr<T> p0, p1; // p0 declared before p1
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<T> p0, p1; // p0 在 p1 之前声明
- en: 'public:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: '// below, suppose we identify the operations as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: // 下面，假设我们按照以下方式识别操作：
- en: '// A: new T(val0)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '// A: new T(val0)'
- en: '// B: construction of p0'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '// B: p0 的构造'
- en: '// C: new T(val1)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '// C: new T(val1)'
- en: '// D: construction of p1'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '// D: p1 的构造'
- en: '// We know that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: // 我们知道：
- en: // - A precedes B
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: // - A 在 B 之前
- en: // - C precedes D
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: // - C 在 D 之前
- en: // - B precedes D
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: // - B 在 D 之前
- en: pair_with_alloc(const T &val0, const T &val1)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc(const T &val0, const T &val1)
- en: ': p0{ new T(val0) }, p1{ new T(val1) } {'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ': p0{ new T(val0) }, p1{ new T(val1) } {'
- en: '}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE21]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#include <memory>'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: template <class T>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T>
- en: class pair_with_alloc {
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: class pair_with_alloc {
- en: std::unique_ptr<T> p0, p1;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: std::unique_ptr<T> p0, p1;
- en: 'public:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: pair_with_alloc(const T &val0, const T &val1)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc(const T &val0, const T &val1)
- en: ': p0{ std::make_unique<T>(val0) },'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ': p0{ std::make_unique<T>(val0) },'
- en: p1{ std::make_unique<T>(val1) } {
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: p1{ std::make_unique<T>(val1) } {
- en: '}'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // destructor implicitly correct
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: // 析构函数隐式正确
- en: // copy and move operations implicitly work
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: // 复制和移动操作隐式工作
- en: // or are left to your imagination
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: // 或留给你的想象
- en: '};'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '#include <string>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <string>'
- en: '#include <random>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <random>'
- en: '#include <iostream>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: class risky {
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: class risky {
- en: std::mt19937 prng{ std::random_device{}() };
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: shared_ptr<X> p{ new X };
- en: std::uniform_int_distribution<int> penny{ 0,1 };
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: std::uniform_int_distribution<int> penny{ 0,1 };
- en: 'public:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: risky() = default;
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: risky() = default;
- en: risky(const risky &) {
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: if(full()) {
- en: if(penny(prng)) throw 3; // throws 50% of the time
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: if(penny(prng)) throw 3; // throws 50% of the time
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~risky() {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ~risky() {
- en: std::cout << “~risky()\n”;
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << “~risky()\n”;
- en: '}'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: int main() {
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: std::begin(resources), std::end(resources),
- en: // the following objects do not leak even if
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc a{ s0, s1 };
- en: // an exception is thrown
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: // an exception is thrown
- en: if(std::string s0, s1; std::cin >> s0 >> s1)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: std::weak_ptr<Resource> obtain(Resource::id_type id){
- en: try {
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: class Cache {
- en: pair_with_alloc a{ s0, s1 };
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: shared_ptr<X> p{ new X(args) };
- en: pair_with_alloc b{ risky{}, risky{} };
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: pair_with_alloc b{ risky{}, risky{} };
- en: '} catch(...) {'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch(...) {'
- en: std::cerr << “Something was thrown...\n”;
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << std::format(“*sh == {}\n”, *sh);
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE22]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: unique_ptr<some_type> p0 { new some_type{ args } };
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: auto p1 = unique_ptr<some_type> { new some_type{ args } };
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: auto p1 = unique_ptr<some_type> { new some_type{ args } };
- en: auto p2 = make_unique<some_type>(args);
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: auto p2 = make_unique<some_type>(args);
- en: '[PRE23]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: // ...
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << “Using resource “ << q->id() << ‘\n’;
- en: void f() {
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: void f() {
- en: X *p = new X;
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[](auto && a, auto && b) {'
- en: thread th0{ [p] { /* use *p */ };
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: thread th1{ [p] { /* use *p */ };
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: thread th1{ [p] { /* use *p */ };
- en: th0.detach();
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: // w points to an expired shared_ptr<int> here
- en: th1.detach();
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: t, std::shared_ptr<Resource>{ p }
- en: '[PRE24]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: // ...
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: thread th0{ [p] { /* use *p */ };
- en: void f() {
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: void f() {
- en: std::shared_ptr<X> p { new X };
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: std::shared_ptr<X> p { new X };
- en: thread th0{ [p] { /* use *p */ };
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: thread th1{ [p] { /* use *p */ };
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: thread th1{ [p] { /* use *p */ };
- en: th0.detach();
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: th0.detach();
- en: th1.detach();
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: shared_ptr<X> p{ new X };
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: void observe(std::weak_ptr<int> w) {
- en: '[PRE26]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: shared_ptr<X> p{ new X(args) };
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: assert(p != std::end(resources));
- en: auto q = make_shared<X>(args);
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = make_shared<X>(args);
- en: '[PRE27]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: // inspired from a cppreference example
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: // inspired from a cppreference example
- en: '#include <iostream>'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: risky(const risky &) {
- en: '#include <memory>'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: '#include <format>'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <format>'
- en: void observe(std::weak_ptr<int> w) {
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: return p.second->id() == id;
- en: if (std::shared_ptr<int> sh = w.lock())
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: X *p = new X;
- en: std::cout << std::format(“*sh == {}\n”, *sh);
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: th1.detach();
- en: else
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: std::cout << “w is expired\n”;
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << “w is expired\n”;
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: std::weak_ptr<int> w;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: std::weak_ptr<int> w;
- en: '{'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: auto sh = std::make_shared<int>(3);
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: auto sh = std::make_shared<int>(3);
- en: w = sh; // weak_ptr made from shared_ptr
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: thread th0{ [p] { /* use *p */ };
- en: // w points to a live shared_ptr<int> here
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: // w points to a live shared_ptr<int> here
- en: observe(w);
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: unique_ptr<some_type> p0 { new some_type{ args } };
- en: '}'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '>> resources;'
- en: // w points to an expired shared_ptr<int> here
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: if(auto q = p.lock(); q)
- en: observe(w);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: observe(w);
- en: '}'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: // ...
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: template <auto Cap>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: template <auto Cap>
- en: class Cache {
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 0; i != 5; ++i)
- en: using clock = std::chrono::system_clock;
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: // a cache of capacity Cap that keeps the
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: // a cache of capacity Cap that keeps the
- en: // most recently used Resource objects
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // most recently used Resource objects
- en: std::vector<std::pair<
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: std::cerr << “Something was thrown...\n”;
- en: decltype(clock::now()),
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: decltype(clock::now()),
- en: std::shared_ptr<Resource>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: std::shared_ptr<Resource>
- en: '>> resources;'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: cache.add(new Resource{ i + 1 });
- en: bool full() const { return resources.size() == Cap; }
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: bool full() const { return resources.size() == Cap; }
- en: '// precondition: !resources.empty()'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '// precondition: !resources.empty()'
- en: void expunge_one() {
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: void expunge_one() {
- en: auto p = std::min_element(
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = std::min_element(
- en: std::begin(resources), std::end(resources),
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: return p->second; // make weak_ptr from shared_ptr
- en: '[](auto && a, auto && b) {'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: if(std::string s0, s1; std::cin >> s0 >> s1)
- en: return a.first < b.first;
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: return a.first < b.first;
- en: '}'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: );
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: th1.detach();
- en: assert(p != std::end(resources));
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: p->second.reset(); // relinquish ownership
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: p->second.reset(); // relinquish ownership
- en: resources.erase(p);
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: resources.erase(p);
- en: '}'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: using clock = std::chrono::system_clock;
- en: 'public:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void add(Resource *p) {
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: void add(Resource *p) {
- en: const auto t = clock::now();
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: const auto t = clock::now();
- en: if(full()) {
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: expunge_one();
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: expunge_one();
- en: '}'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: resources.emplace_back(
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: resources.emplace_back(
- en: t, std::shared_ptr<Resource>{ p }
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[id](auto && p) {'
- en: );
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: std::vector<std::pair<
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: std::weak_ptr<Resource> obtain(Resource::id_type id){
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: const auto t = clock::now();
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: const auto t = clock::now();
- en: auto p = std::find_if(
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = std::find_if(
- en: std::begin(resources),
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: std::begin(resources),
- en: std::end(resources),
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: std::end(resources),
- en: '[id](auto && p) {'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return p.second->id() == id;
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: // the following objects do not leak even if
- en: '}'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: );
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: th0.detach();
- en: if(p == std::end(resources))
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: if(p == std::end(resources))
- en: return {};
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: if (std::shared_ptr<int> sh = w.lock())
- en: p->first = t;
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: p->first = t;
- en: return p->second; // make weak_ptr from shared_ptr
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: std::mt19937 prng{ std::random_device{}() };
- en: int main() {
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: Cache<5> cache;
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Cache<5> cache;
- en: for(int i = 0; i != 5; ++i)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: return {};
- en: cache.add(new Resource{ i + 1 });
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: cache.add(new Resource{ i + 1 });
- en: // let’s take a pointer to resource 3
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: // let’s take a pointer to resource 3
- en: auto p = cache.obtain(3);
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = cache.obtain(3);
- en: if(auto q = p.lock(); q)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: w = sh; // weak_ptr made from shared_ptr
- en: std::cout << “Using resource “ << q->id() << ‘\n’;
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: observe(w);
- en: // things happen, resources get added, used, etc.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: // things happen, resources get added, used, etc.
- en: for(int i = 6; i != 15; ++i)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: for(int i = 6; i != 15; ++i)
- en: cache.add(new Resource{ i + 1 });
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: if(auto q = p.lock(); q)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: if(auto q = p.lock(); q)
- en: std::cout << “Using resource “ << q->id() << ‘\n’;
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: else
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << “Resource not available ...\n”;
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#include <memory>'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: struct Y;
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: struct X {
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: std::shared_ptr<Y> p;
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ~X() { std::cout << “~X()\n”; }
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: struct Y {
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: std::shared_ptr<X> p;
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: ~Y() { std::cout << “~Y()\n”; }
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: void oops() {
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: auto x = std::make_shared<X>();
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: auto y = std::make_shared<Y>();
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: x->p = y;
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: y->p = x;
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: oops();
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << “Done\n”;
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#include <memory>'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: struct Y;
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: struct X {
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: std::weak_ptr<Y> p;
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: ~X() { std::cout << “~X()\n”; }
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: struct Y {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: std::shared_ptr<X> p;
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: ~Y() { std::cout << “~Y()\n”; }
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: void oops() {
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: auto x = std::make_shared<X>();
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: auto y = std::make_shared<Y>();
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: x->p = y;
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: y->p = x;
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: oops();
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << “Done\n”;
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: template <class T>
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: class single_linked_list {
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: struct node {
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: T value;
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: node *next = nullptr;
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'node(const T &val) : value { val } {'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: node *head = nullptr;
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: ~single_linked_list() {
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: for(auto p = head; p;) {
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: auto q = p->next;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: delete p;
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: p = q;
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: template <class T>
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: class single_linked_list {
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: struct node {
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: T value;
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: unique_ptr<node> next; // good idea?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'node(const T &val) : value { val } {'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: unique_ptr<node> head; // good idea?
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: ~single_linked_list() = default;
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
