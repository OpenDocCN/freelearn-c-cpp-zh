["```cpp\nvoid BM_malloc(benchmark::State& state) {\n  for (auto _ : state) {\n    void* p = malloc(64);\n    benchmark::DoNotOptimize(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nBENCHMARK(BM_malloc_free);\n```", "```cpp\n// Example 01\nvoid BM_malloc_free(benchmark::State& state) {\n  const size_t S = state.range(0);\n  for (auto _ : state) {\n    void* p = malloc(S);\n    benchmark::DoNotOptimize(p); free(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nBENCHMARK(BM_malloc_free)->Arg(64);\n```", "```cpp\nBenchmark                 Time   Items per second\nBM_malloc_free/64        19.2 ns 52.2041M/s\n```", "```cpp\nvoid BM_malloc_free(benchmark::State& state) {\n  const size_t S = state.range(0);\n  for (auto _ : state) {\n    void* p = malloc(S);\n    benchmark::DoNotOptimize(p); free(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nBENCHMARK(BM_malloc_free)->\n  RangeMultiplier(2)->Range(32,   256);\n```", "```cpp\n// Example 02\n#define REPEAT2(x) x x\n#define REPEAT4(x) REPEAT2(x) REPEAT2(x)\n#define REPEAT8(x) REPEAT4(x) REPEAT4(x)\n#define REPEAT16(x) REPEAT8(x) REPEAT8(x)\n#define REPEAT32(x) REPEAT16(x) REPEAT16(x)\n#define REPEAT(x) REPEAT32(x)\nvoid BM_malloc_free(benchmark::State& state) {\n  const size_t S = state.range(0);\n  const size_t N = state.range(1);\n  std::vector<void*> v(N);\n  for (size_t i = 0; i < N; ++i) v[i] = malloc(S);\n  for (auto _ : state) {\n    REPEAT({\n      void* p = malloc(S);\n      benchmark::DoNotOptimize(p);\n      free(p);\n    });\n  }\n  state.SetItemsProcessed(32*state.iterations());\n  for (size_t i = 0; i < N; ++i) free(v[i]);\n}\nBENCHMARK(BM_malloc_free)->\n  RangeMultiplier(2)->Ranges({{32, 256}, {1<<15, 1<<15}});\n```", "```cpp\n// Example 03\nvoid BM_malloc_free(benchmark::State& state) {\n  const size_t S = state.range(0);\n  const size_t N = state.range(1);\n  std::vector<void*> v(N);\n  for (size_t i = 0; i < N; ++i) v[i] = malloc(S);\n  for (auto _ : state) {\n    REPEAT({\n      void* p = malloc(S);\n      benchmark::DoNotOptimize(p);\n      free(p);\n    });\n  }\n  state.SetItemsProcessed(32*state.iterations());\n  for (size_t i = 0; i < N; ++i) free(v[i]);\n}\nBENCHMARK(BM_malloc_free)->\n  RangeMultiplier(2)->Ranges({{32, 256}, {1<<15, 1<<15}})\n  ->ThreadRange(1, 2);\n```", "```cpp\nBenchmark                          Time   Items per second\nBM_malloc_free/32/32768/threads:1  778 ns 41.1468M/s\nBM_malloc_free/32/32768/threads:2  657 ns 24.3749M/s\nBM_malloc_free/32/32768/threads:4  328 ns 24.3854M/s\nBM_malloc_free/32/32768/threads:8  242 ns 16.5146M/s\n```", "```cpp\n// Example 04\nclass simple_string {\n  public:\n  simple_string() = default;\n  explicit simple_string(const char* s) : s_(strdup(s)) {}\n  simple_string(const simple_string& s)\n    : s_(strdup(s.s_)) {}\n  simple_string& operator=(const char* s) {\n    free(s_);\n    s_ = strdup(s);\n    return *this;\n  }\n  simple_string& operator=(const simple_string& s) {\n    if (this == &s) return *this;\n    free(s_);\n    s_ = strdup(s.s_);\n    return *this;\n  }\n  bool operator==(const simple_string& rhs) const {\n    return strcmp(s_, rhs.s_) == 0;\n  }\n  ~simple_string() { free(s_); }\n  private:\n  char* s_ = nullptr;\n};\n```", "```cpp\n// Example 04\nclass small_string {\n  public:\n  small_string() = default;\n  explicit small_string(const char* s) :\n    s_((strlen(s) + 1 < sizeof(buf_)) ? strcpy(buf_, s)\n                                      : strdup(s)) {}\n  small_string(const small_string& s) :\n    s_((s.s_ == s.buf_) ? strcpy(buf_, s.buf_)\n                        : strdup(s.s_)) {}\n  small_string& operator=(const char* s) {\n    if (s_ != buf_) free(s_);\n    s_ = (strlen(s) + 1 < sizeof(buf_)) ? strcpy(buf_, s)\n                                        : strdup(s);\n    return *this;\n  }\n  small_string& operator=(const small_string& s) {\n    if (this == &s) return *this;\n    if (s_ != buf_) free(s_);\n    s_ = (s.s_ == s.buf_) ? strcpy(buf_, s.buf_)\n                          : strdup(s.s_);\n    return *this;\n  }\n  bool operator==(const small_string& rhs) const {\n    return strcmp(s_, rhs.s_) == 0;\n  }\n  ~small_string() {\n    if (s_ != buf_) free(s_);\n  }\n  private:\n  char* s_ = nullptr;\n  char buf_[16];\n};\n```", "```cpp\n// Example 04\ntemplate <typename T>\nvoid BM_string_create_short(benchmark::State& state) {\n  const char* s = \"Simple string\";\n  for (auto _ : state) {\n    REPEAT({\n      T S(s);\n      benchmark::DoNotOptimize(S);\n    })\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\nBENCHMARK_TEMPLATE1(BM_string_create_short, simple_string);\nBENCHMARK_TEMPLATE1(BM_string_create_short, small_string);\n```", "```cpp\nBenchmark                                Time Items per sec\nBM_string_create_short<simple_string>     835 ns 38.34M/s\nBM_string_create_short<small_string>     18.7 ns 1.71658G/s\n```", "```cpp\nBenchmark                                Time Items per sec\nBM_create<simple_string>/threads:2        743 ns 21.5644M/s\nBM_create<simple_string>/threads:4        435 ns 18.4288M/s\nBM_create<small_string>/threads:2        9.34 ns 1.71508G/s\nBM_create<small_string>/threads:4        4.77 ns 1.67998G/s\n```", "```cpp\ntemplate <typename T>\nvoid BM_string_copy_short(benchmark::State& state) {\n  const T s(\"Simple string\");\n  for (auto _ : state) {\n    REPEAT({\n      T S(s);\n      benchmark::DoNotOptimize(S);\n    })\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\ntemplate <typename T>\nvoid BM_string_assign_short(benchmark::State& state) {\n  const T s(\"Simple string\");\n  T S;\n  for (auto _ : state) {\n    REPEAT({ benchmark::DoNotOptimize(S = s); })\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\nBENCHMARK_TEMPLATE1(BM_string_copy_short, simple_string);\nBENCHMARK_TEMPLATE1(BM_string_copy_short, small_string);\nBENCHMARK_TEMPLATE1(BM_string_assign_short, simple_string);\nBENCHMARK_TEMPLATE1(BM_string_assign_short, small_string);\n```", "```cpp\nBenchmark                                Time Items per sec\nBM_string_copy_short<simple_string>       786 ns 40.725M/s\nBM_string_copy_short<small_string>       53.5 ns 598.847M/s\nBM_string_assign_short<simple_string>     770 ns 41.5977M/s\nBM_string_assign_short<small_string>     46.9 ns 683.182M/s\n```", "```cpp\ntemplate <typename T>\nvoid BM_string_compare_short(benchmark::State& state) {\n  const size_t N = state.range(0);\n  const T s(\"Simple string\");\n  std::vector<T> v1, v2;\n  ... populate the vectors with strings ...\n  for (auto _ : state) {\n    for (size_t i = 0; i < N; ++i) {\n      benchmark::DoNotOptimize(v1[i] == v2[i]);\n    }\n  }\n  state.SetItemsProcessed(N*state.iterations());\n}\nBENCHMARK_TEMPLATE1(BM_string_compare_short,\n                    simple_string)->Arg(1<<22);\nBENCHMARK_TEMPLATE1(BM_string_compare_short,\n                    small_string)->Arg(1<<22);\n```", "```cpp\nBenchmark                                Time Items per sec\nBM_compare<simple_string>/4194304    30230749 ns 138.855M/s\nBM_compare<small_string>/4194304     15062582 ns 278.684M/s\n```", "```cpp\n// Example 05\nclass small_string {\n  ...\n  private:\n  union {\n    char* s_;\n    struct {\n      char buf[15];\n      char tag;\n    } b_;\n  };\n};\n```", "```cpp\n// Example 06\nclass simple_vector {\n  public:\n  simple_vector() = default;\n  simple_vector(std::initializer_list<int> il) :\n    n_(il.size()),\n    p_(static_cast<int*>(malloc(sizeof(int)*n_)))\n  {\n    int* p = p_;\n    for (auto x : il) *p++ = x;\n  }\n  ~simple_vector() { free(p_); }\n  size_t size() const { return n_; }\n  private:\n  size_t n_ = 0;\n  int* p_ = nullptr;\n};\n```", "```cpp\n// Example 06\nclass small_vector {\n  public:\n  small_vector() = default;\n  small_vector(std::initializer_list<int> il) :\n    n_(il.size()), p_((n_ < sizeof(buf_)/sizeof(buf_[0]))\n      ? buf_ : static_cast<int*>(malloc(sizeof(int)*n_)))\n  {\n    int* p = p_;\n    for (auto x : il) *p++ = x;\n  }\n  ~small_vector() {\n    if (p_ != buf_) free(p_);\n  }\n  private:\n  size_t n_ = nullptr;\n  int* p_ = nullptr;\n  int buf_[16];\n};\n```", "```cpp\n// Example 07\nclass small_vector {\n  public:\n  small_vector() = default;\n  small_vector(std::initializer_list<int> il) {\n    int* p;\n    if (il.size() < sizeof(short_.buf)/\n                    sizeof(short_.buf[0])) {\n      short_.n = il.size();\n      p = short_.buf;\n    } else {\n      short_.n = UCHAR_MAX;\n      long_.n = il.size();\n      p = long_.p = static_cast<int*>(\n        malloc(sizeof(int)*long_.n));\n    }\n    for (auto x : il) *p++ = x;\n  }\n  ~small_vector() {\n    if (short_.n == UCHAR_MAX) free(long_.p);\n  }\n  private:\n  union {\n    struct {\n      int buf[15];\n      unsigned char n;\n    } short_ = { {}, '\\0' };\n    struct {\n      size_t n;\n      int* p;\n    } long_;\n  };\n};\n```", "```cpp\n// Example 08\nclass small_queue {\n  public:\n  bool push(int i) {\n    if (front_ - tail_ > buf_size_) return false;\n    buf_[(++front_) & (buf_size_ - 1)] = i;\n    return true;\n  }\n  int front() const {\n    return buf_[tail_ & (buf_size_ - 1)];\n  }\n  void pop() { ++tail_; }\n  size_t size() const { return front_ - tail_; }\n  bool empty() const { return front_ == tail_; }\n  private:\n  static constexpr size_t buf_size_ = 16;\n  static_assert((buf_size_ & (buf_size_ - 1)) == 0,\n                \"Buffer size must be a power of 2\");\n  int buf_[buf_size_];\n  size_t front_ = 0;\n  size_t tail_ = 0;\n};\n```", "```cpp\nBenchmark                         Time   items_per_second\nBM_queue<std::queue<int>>       472 ns          67.787M/s\nBM_queue<small_queue>           100 ns         319.857M/s\n```", "```cpp\n// Example 09\ntemplate <typename T, typename Deleter> class smartptr {\n  public:\n  smartptr(T* p, Deleter d) : p_(p), d_(d) {}\n  ~smartptr() { d_(p_); }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; } private:\n  T* p_;\n  Deleter d_;\n};\n```", "```cpp\n// Example 09\ntemplate <typename T> class smartptr_te {\n  struct deleter_base {\n    virtual void apply(void*) = 0;\n    virtual ~deleter_base() {}\n  };\n  template <typename Deleter>\n  struct deleter : public deleter_base {\n    deleter(Deleter d) : d_(d) {}\n    void apply(void* p) override {\n      d_(static_cast<T*>(p));\n    }\n    Deleter d_;\n  };\n  public:\n  template <typename Deleter>\n  smartptr_te(T* p, Deleter d) : p_(p),\n    d_(new deleter<Deleter>(d)) {}\n  ~smartptr_te() {\n    d_->apply(p_);\n    delete d_;\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  private:\n  T* p_;\n  deleter_base* d_;\n};\n```", "```cpp\n// Example 09\nstruct deleter {    // Very simple deleter for operator new\n  template <typename T> void operator()(T* p) { delete p; }\n};\nvoid BM_smartptr(benchmark::State& state) {\n  deleter d;\n  for (auto _ : state) {\n    smartptr<int, deleter> p(new int, d);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nvoid BM_smartptr_te(benchmark::State& state) {\n  deleter d;\n  for (auto _ : state) {\n    smartptr_te<int> p(new int, d);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nBENCHMARK(BM_smartptr);\nBENCHMARK(BM_smartptr_te);\nBENCHMARK_MAIN();\n```", "```cpp\nBenchmark                  Time Items per second\nBM_smartptr             21.0 ns 47.5732M/s\nBM_smartptr_te          44.2 ns 22.6608M/s\n```", "```cpp\n// Example 09\ntemplate <typename T> class smartptr_te_lb {\n  struct deleter_base {\n    virtual void apply(void*) = 0;\n    virtual ~deleter_base() {}\n  };\n  template <typename Deleter>\n    struct deleter : public deleter_base {\n    deleter(Deleter d) : d_(d) {}\n    void apply(void* p) override {\n      d_(static_cast<T*>(p));\n    }\n    Deleter d_;\n  };\n  public:\n  template <typename Deleter>\n    smartptr_te_lb(T* p, Deleter d) : p_(p),\n      d_((sizeof(Deleter) > sizeof(buf_))\n         ? new deleter<Deleter>(d)\n         : new (buf_) deleter<Deleter>(d)) {}\n  ~smartptr_te_lb() {\n    d_->apply(p_);\n    if ((void*)(d_) == (void*)(buf_)) {\n      d_->~deleter_base();\n    } else {\n      delete d_;\n    }\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  private:\n  T* p_;\n  deleter_base* d_;\n  char buf_[16];\n};\n```", "```cpp\nBenchmark                  Time Items per second\nBM_smartptr             21.0 ns 47.5732M/s\nBM_smartptr_te          44.2 ns 22.6608M/s\nBM_smartptr_te_lb       22.3 ns 44.8747M/s\n```", "```cpp\ntemplate <typename T>\nclass small_vector {\n  alignas(T) char buffer_[buffer_size_];\n  …\n};\n```", "```cpp\n// Example 10\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  constexpr static auto size = S, alignment = A;\n  alignas(alignment) char space_[size];\n  …\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  template <typename T> static constexpr bool valid_type()\n  {\n    return sizeof(T) <= S && (A % alignof(T)) == 0;\n  }\n  …\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  template <typename T> requires(valid_type<T>())\n    T* as() noexcept {\n    return reinterpret_cast<T*>(&space_);\n  }\n  template <typename T> requires(valid_type<T>())\n    const T* as() const noexcept {\n    return const_cast<Buffer*>(this)->as<T>();\n  }\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  Buffer() = default;\n  template <typename T, typename... Args>\n    requires(valid_type<T>() &&\n             std::constructible_from<T, Args...>)\n  Buffer(std::in_place_type_t<T>, Args&& ...args)\n    noexcept(std::is_nothrow_constructible_v<T, Args...>)\n  {\n    ::new (static_cast<void*>(as<T>()))\n      T(std::forward<Args>(args)...);\n  }\n  template<typename T, typename... Args>\n    requires(valid_type<T>() &&\n             std::constructible_from<T, Args...>)\n  T* emplace(Args&& ...args)\n    noexcept(std::is_nothrow_constructible_v<T, Args...>)\n  {\n    return ::new (static_cast<void*>(as<T>()))\n      T(std::forward<Args>(args)...);\n  }\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  template <typename T>\n  Buffer(std::in_place_type_t<T>, Args&& ...args) … {\n    static_assert(std::is_trivially_destructible_v<T>, \"\");\n    static_assert(std::is_trivially_copyable_v<T>, \"\");\n    …\n  }\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  void swap(Buffer& that) noexcept {\n    alignas(alignment) char tmp[size];\n    ::memcpy(tmp, this->space_, size);\n    ::memcpy(this->space_, that.space_, size);\n    ::memcpy(that.space_, tmp, size);\n  }\n};\n```", "```cpp\nbuffer_.as<T>()->~T();\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  template <typename T> void destroy() {\n    this->as<T>()->~T();\n  }\n};\n```", "```cpp\n// Example 11\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  struct vtable_t {\n    using deleter_t = void(Buffer*);\n    using copy_construct_t = void(Buffer*, const Buffer*);\n    using move_construct_t = void(Buffer*, Buffer*);\n    deleter_t*  deleter_;\n    copy_construct_t* copy_construct_;\n    move_construct_t* move_construct_;\n  };\n  const vtable_t* vtable_ = nullptr;\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  template <typename U, typename T>\n  constexpr static vtable_t vtable = {\n    U::template deleter<T>,\n    U::template copy_construct<T>,\n    U::template move_construct<T>\n  };\n  template <typename T>\n    requires(valid_type<T>() &&\n    std::is_nothrow_destructible_v<T>)\n  static void deleter(Buffer* space) {\n    space->as<T>()->~T();\n  }\n  template <typename T>\n    requires(valid_type<T>())\n  static void copy_construct(Buffer* to,\n                             const Buffer* from)\n    noexcept(std::is_nothrow_copy_constructible_v<T>)\n  {\n    ::new (static_cast<void*>(to->as<T>()))\n      T(*from->as<T>());\n    to->vtable_ = from->vtable_;\n  }\n  template <typename T>\n    requires(valid_type<T>())\n    static void move_construct(Buffer* to, Buffer* from)\n    noexcept(std::is_nothrow_move_constructible_v<T>)\n  {\n    ::new (static_cast<void*>(to->as<T>()))\n      T(std::move(*from->as<T>()));\n    to->vtable_ = from->vtable_;\n  }\n};\n```", "```cpp\n// Example 11\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  template <typename T, typename... Args>\n    requires(valid_type<T>() &&\n    std::constructible_from<T, Args...>)\n  Buffer(std::in_place_type_t<T>, Args&& ...args)\n    noexcept(std::is_nothrow_constructible_v<T, Args...>)\n    : vtable_(&vtable<Buffer, T>)\n  {\n    ::new (static_cast<void*>(as<T>()))\n      T(std::forward<Args>(args)...);\n  }\n  template<typename T, typename... Args>\n    requires(valid_type<T>() &&\n    std::constructible_from<T, Args...>)\n  T* emplace(Args&& ...args)\n    noexcept(std::is_nothrow_constructible_v<T, Args...>)\n  {\n    if (this->vtable_) this->vtable_->deleter_(this);\n    this->vtable_ = &vtable<Buffer, T>;\n    return ::new (static_cast<void*>(as<T>()))\n      T(std::forward<Args>(args)...);\n  }\n  …\n};\n```", "```cpp\n// Example 11\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  Buffer(const Buffer& that) {\n    if (that.vtable_)\n      that.vtable_->copy_construct_(this, &that);\n  }\n  Buffer& operator=(const Buffer& that) {\n    if (this == &that) return *this;\n    if (this->vtable_) this->vtable_->deleter_(this);\n    if (that.vtable_)\n      that.vtable_->copy_construct_(this, &that);\n    else this->vtable_ = nullptr;\n    return *this;\n  }\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  Buffer(Buffer&& that) {\n    if (that.vtable_)\n      that.vtable_->move_construct_(this, &that);\n  }\n  Buffer& operator=(Buffer&& that) {\n    if (this == &that) return *this;\n    if (this->vtable_) this->vtable_->deleter_(this);\n    if (that.vtable_)\n      that.vtable_->move_construct_(this, &that);\n    else this->vtable_ = nullptr;\n    return *this;\n  }\n};\n```", "```cpp\ntemplate<size_t S, size_t A = alignof(void*)>\nstruct Buffer {\n  …\n  ~Buffer() noexcept {\n    if (this->vtable_) this->vtable_->deleter_(this);\n  }\n  // Destroy the object stored in the aligned space.\n  void destroy() noexcept {\n    if (this->vtable_) this->vtable_->deleter_(this);\n    this->vtable_ = nullptr;\n  }\n};\n```", "```cpp\nBenchmark                        Time\nBM_lambda_copy_trivial          5.45 ns\nBM_lambda_copy_typeerased       4.02 ns\n```"]