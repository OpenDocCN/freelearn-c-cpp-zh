- en: '*Chapter 1*: An Introduction to Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a C++ developer, you should be at least familiar if not well versed in **template
    metaprogramming**, in general, referred to in short as **templates**. Template
    metaprogramming is a programming technique that uses templates as blueprints for
    the compiler to generate code and help developers avoid writing repetitive code.
    Although general-purpose libraries use templates heavily, the syntax and the inner
    workings of templates in the C++ language can be discouraging. Even *C++ Core
    Guidelines*, which is a collection of dos and don'ts edited by *Bjarne Stroustrup*,
    the creator of the C++ language, and *Herb Sutter*, the chair of the C++ standardization
    committee, calls templates *pretty horrendous*.
  prefs: []
  type: TYPE_NORMAL
- en: This book is intended to shed light on this area of the C++ language and help
    you become prolific in template metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding template terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief history of templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step in learning how to use templates is to understand what problem
    they actually solve. Let's start with that.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each language feature is designed to help with a problem or task that developers
    face when using that language. The purpose of templates is to help us avoid writing
    repetitive code that only differs slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify this, let''s take the classical example of a `max` function. Such
    a function takes two numerical arguments and returns the largest of the two. We
    can easily implement this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This works pretty well, but as you can see, it will only work for values of
    the type `int` (or those that are convertible to `int`). What if we need the same
    function but with arguments of the type `double`? Then, we can overload this function
    (create a function with the same name but a different number or type of arguments)
    for the `double` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, `int` and `double` are not the only numeric types. There is `char`,
    `short`, `long`, `long` and their unsigned counterparts, `unsigned char`, `unsigned
    short`, `unsigned long`, and `unsigned long`. There are also the types `float`
    and `long double`. And other types, such as `int8_t`, `int16_t`, `int32_t`, and
    `int64_t`. And there could be other types that can be compared, such as `bigint`,
    `Matrix`, `point2d`, and any user-defined type that overloads `operator>`. How
    can a general-purpose library provide a general-purpose function such as `max`
    for all these types? It can overload the function for all the built-in types and
    perhaps other library types but cannot do so for any user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to overloading functions with different parameters is to use
    `void*` to pass arguments of different types. Keep in mind this is a bad practice
    and the following example is shown only as a possible alternative in a world without
    templates. However, for the sake of discussion, we can design a sorting function
    that will run the quick sort algorithm on an array of elements of any possible
    type that provides a strict weak ordering. The details of the quicksort algorithm
    can be looked up online, such as on Wikipedia at [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort).
  prefs: []
  type: TYPE_NORMAL
- en: 'The quicksort algorithm needs to compare and swap any two elements. However,
    since we don''t know their type, the implementation cannot do this directly. The
    solution is to rely on **callbacks**, which are functions passed as arguments
    that will be invoked when necessary. A possible implementation can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to invoke the `quicksort` function, we need to provide implementations
    for these comparisons and swapping functions for each type of array that we pass
    to the function. The following are implementations for the `int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these defined, we can write code that sorts arrays of integers as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples focused on functions but the same problem applies to classes.
    Consider that you want to write a class that models a collection of numerical
    values that has variable size and stores the elements contiguously in memory.
    You could provide the following implementation (only the declaration is sketched
    here) for storing integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This all looks good but the moment you need to store values of the type `double`,
    or `std::string`, or any user-defined type you'll have to write the same code,
    each time only changing the type of the elements. This is something nobody wants
    to do because it is repetitive work and because when something needs to change
    (such as adding a new feature or fixing a bug) you need to apply the same change
    in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, a similar problem can be encountered, although less often, when you
    need to define variables. Let''s consider the case of a variable that holds the
    new line character. You can declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you need the same constant but for a different encoding, such as wide
    string literals, UTF-8, and so on? You can have multiple variables, having different
    names, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Templates are a technique that allows developers to write blueprints that enable
    the compiler to generate all this repetitive code for us. In the following section,
    we will see how to transform the preceding snippets into C++ templates.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to see how templates are written in the C++ language. In this
    section, we will start with three simple examples, one for each of the snippets
    presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'A template version of the `max` function discussed previously would look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You will notice here that the type name (such as `int` or `double`) has been
    replaced with `T` (which stands for *type*). `T` is called a `template<typename
    T> or typename<class T>`. Keep in mind that `T` is a parameter, therefore it can
    have any name. We will learn more about template parameters in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, this template that you put in the source code is only a blueprint.
    The compiler will generate code from it based on its use. More precisely, it will
    instantiate a function overload for each type the template is used with. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we are first calling `max` with two integers, which is OK because
    `operator>` is available for the type `int`. This will generate an overload `int
    max(int const a, int const b)`. Second, we are calling `max` with two doubles,
    which again is all right since `operator>` works for doubles. Therefore, the compiler
    will generate another overload, `double max(double const a, double const b)`.
    However, the third call to `max` will generate a compiler error, because the `foo`
    type does not have the `operator>` overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without getting into too many details at this point, it should be mentioned
    that the complete syntax for calling the `max` function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is able to deduce the type of the template parameter, making it
    redundant to write it. There are cases, however, when that is not possible; in
    those situations, you need to specify the type explicitly, using this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example involving functions from the previous section, *Understanding
    the need for templates*, was the `quicksort()` implementation that dealt with
    `void*` arguments. The implementation can be easily transformed into a template
    version with very few changes. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the `quicksort` function template is very similar to what we have
    seen earlier, except there is no need to pass pointers to callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The third example we looked at in the previous section was the `vector` class.
    A template version of it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the case of the `max` function, the changes are minimal. There is the
    template declaration on the line above the class and the type `int` of the elements
    has been replaced with the type template parameter `T`. This implementation can
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: One thing to notice here is that we have to specify the type of the elements
    when declaring the variable `v`, which is `int` in our snippet because the compiler
    would not be able to infer their type otherwise. There are cases when this is
    possible, in C++17, and this topic, called **class template argument deduction**,
    will be discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced
    Template Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth and last example concerned the declaration of several variables
    when only the type was different. We could replace all those variables with a
    template, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'This template can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The examples in this section show that the syntax for declaring and using templates
    is the same whether they represent functions, classes, or variables. This leads
    us to the next section where we will discuss the types of templates and template
    terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, we have used the general term templates. However, there
    are four different terms describing the kind of templates we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max` template seen previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`, `struct`, or `union` keyword). An example is the `vector` class we
    wrote in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewLine` template from the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alias template** is the term used for templated type aliases. We will see
    examples for alias templates in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Templates are parameterized with one or more parameters (in the examples we
    have seen so far, there was a single parameter). These are called **template parameters**
    and can be of three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template<typename T>`, where the parameter represents a type specified when
    the template is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template<size_t N>` or `template<auto n>`, where each parameter must have
    a structural type, which includes integral types, floating-point types (as for
    C++20), pointer types, enumeration types, lvalue reference types, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template<typename K, typename V, template<typename> typename C>`, where the
    type of a parameter is another template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Templates can be specialized by providing alternative implementations. These
    implementations can depend on the characteristics of the template parameters.
    The purpose of specialization is to enable optimizations or reduce code bloat.
    There are two forms of specialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial specialization**: This is an alternative implementation provided
    for only some of the template parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(Explicit) full specialization**: This is a specialization of a template
    when all the template arguments are provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of generating code from a template by the compiler is called `vector<int>`,
    the compiler substituted the `int` type in every place where `T` appeared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template instantiation can have two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector<int>` and `vector<double>`, it will instantiate the `vector` class
    template for the types `int` and `double` and nothing more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit instantiation**: This is a way to explicitly tell the compiler what
    instantiations of a template to create, even if those instantiations are not explicitly
    used in your code. This is useful, for instance, when creating library files,
    because uninstantiated templates are not put into object files. They also help
    reduce compile times and object sizes, in ways that we will see at a later time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the terms and topics mentioned in this section will be detailed in other
    chapters of the book. This section is intended as a short reference guide to template
    terminology. Keep in mind though that there are many other terms related to templates
    that will be introduced at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template metaprogramming is the C++ implementation of generic programming.
    This paradigm was first explored in the 1970s and the first major languages to
    support it were Ada and Eiffel in the first half of the 1980s. David Musser and
    Alexander Stepanov defined generic programming, in a paper called *Generic Programming*,
    in 1989, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic programming centers around the idea of abstracting from concrete, efficient
    algorithms to obtain generic algorithms that can be combined with different data
    representations to produce a wide variety of useful software.
  prefs: []
  type: TYPE_NORMAL
- en: This defines a paradigm of programming where algorithms are defined in terms
    of types that are specified later and instantiated based on their use.
  prefs: []
  type: TYPE_NORMAL
- en: Templates were not part of the initial **C with Classes** language developed
    by Bjarne Stroustrup. Stroustrup's first papers describing templates in C++ appeared
    in 1986, one year after the publication of his book, *The C++ Programming Language,
    First Edition*. Templates became available in the C++ language in 1990, before
    the ANSI and ISO C++ committees for standardization were founded.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1990s, Alexander Stepanov, David Musser, and Meng Lee experimented
    with the implementation in C++ of various generic concepts. This led to the first
    implementation of the **Standard Template Library** (**STL**). When the ANSI/ISO
    committee became aware of the library in 1994, it quickly added it to the drafted
    specifications. STL was standardized along with the C++ language in 1998 in what
    became known as C++98.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newer versions of the C++ standard, collectively referred to as **modern C++**,
    have introduced various improvements to template metaprogramming. The following
    table lists them briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_Table_1.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1
  prefs: []
  type: TYPE_NORMAL
- en: All these features, along with other aspects of template metaprogramming, will
    make the sole subject of this book and will be presented in detail in the following
    chapters. For now, let's see what the advantages and disadvantages are of using
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start using templates, it's important to understand the benefits
    of using them as well as the disadvantages they may incur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by pointing out the advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates help us avoid writing repetitive code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates foster the creation of generic libraries providing algorithms and
    types, such as the standard C++ library (sometimes incorrectly referred to as
    the STL), which can be used in many applications, regardless of their type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of templates can result in less and better code. For instance, using
    algorithms from the standard library can help write less code that is likely easier
    to understand and maintain and also probably more robust because of the effort
    put into the development and testing of these algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to disadvantages, the following are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is considered complex and cumbersome, although with a little practice
    this should not really pose a real hurdle in the development and use of templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler errors related to template code can often be long and cryptic, making
    it very hard to identify their cause. Newer versions of the C++ compilers have
    made progress in simplifying these kinds of errors, although they generally remain
    an important issue. The inclusion of concepts in the C++20 standard has been seen
    as an attempt, among others, to help provide better diagnostics for compiling
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They increase the compilation times because they are implemented entirely in
    headers. Whenever a change to a template is made, all the translation units in
    which that header is included must be recompiled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template libraries are provided as a collection of one or more headers that
    must be compiled together with the code that uses them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another disadvantage that results from the implementation of templates in headers
    is that there is no information hiding. The entire template code is available
    in headers for anyone to read. Library developers often resort to the use of namespaces
    with names such as `detail` or `details` to contain code that is supposed to be
    internal for a library and should not be called directly by those using the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They could be harder to validate since code that is not used is not instantiated
    by the compiler. It is, therefore, important that when writing unit tests, good
    code coverage must be ensured. This is especially the case for libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the list of disadvantages may seem longer, the use of templates is
    not a bad thing or something to be avoided. On the contrary, templates are a powerful
    feature of the C++ language. Templates are not always properly understood and
    sometimes are misused or overused. However, the judicious use of templates has
    unquestionable advantages. This book will try to provide a better understanding
    of templates and their use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of templates in the C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We started by learning about the problems for which the solution is the use
    of templates. We then saw how templates look with simple examples of function
    templates, class templates, and variable templates. We introduced the basic terminology
    for templates, which we will discuss more in the forthcoming chapters. Toward
    the end of the chapter, we saw a brief history of templates in the C++ programming
    language. We ended the chapter with a discussion on the advantages and disadvantages
    of using templates. All these topics will lead us to understand the next chapters
    better.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the fundamentals of templates in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need templates? What advantages do they provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you call a function that is a template? What about a class that is a
    template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many kinds of template parameters exist and what are they?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is partial specialization? What about full specialization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main disadvantages of using templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Generic Programming, David Musser, Alexander Stepanov*, [http://stepanovpapers.com/genprog.pdf](http://stepanovpapers.com/genprog.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A History of C++: 1979âˆ’1991, Bjarne Stroustrup*, [https://www.stroustrup.com/hopl2.pdf](https://www.stroustrup.com/hopl2.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*History of C++*, [https://en.cppreference.com/w/cpp/language/history](https://en.cppreference.com/w/cpp/language/history)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templates in C++ - Pros and Cons, Sergey Chepurin*, [https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons](https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
