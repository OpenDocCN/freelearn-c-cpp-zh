<html><head></head><body>
		<div><h1 id="_idParaDest-103" class="chapter-number"><a id="_idTextAnchor102"/>4</h1>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Jungle Jump – Running and Jumping in a 2D Platformer</h1>
			<p>In this chapter, you’ll build a <em class="italic">platformer</em> game in the tradition of classics such as <em class="italic">Super Mario Bros</em>. Platform games are a very popular genre, and understanding how they work can help you make a variety of different game styles. If you’ve never attempted making one before, the player movement in platformers can be surprisingly complex to implement, and you’ll see how Godot’s <code>CharacterBody2D</code> node has features to help you in that process.</p>
			<p>In this project, you will learn about the following:</p>
			<ul>
				<li>Using the <code>CharacterBody2D</code> node</li>
				<li>Using the <code>Camera2D</code> node</li>
				<li>Combining animations and user input to produce complex character behavior</li>
				<li>Designing levels using <code>TileMap</code></li>
				<li>Creating an infinitely scrolling background using <code>ParallaxLayer</code></li>
				<li>Transitioning between scenes</li>
				<li>Organizing your project and planning for expansion</li>
			</ul>
			<p>Here is a screenshot of the completed game:</p>
			<div><div><img src="img/B19289_04_01.jpg" alt="Figure 4.1: Completed game screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Completed game screenshot</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>As with the previous projects, you’ll start by downloading the art assets for the game, which can be found here: <a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads</a></p>
			<p>You can also find the complete code for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump</a></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Setting up the project</h1>
			<p>To create a new<a id="_idIndexMarker236"/> project, start by opening <strong class="bold">Project Settings</strong> so that you can configure the defaults that you’ll need.</p>
			<p>The art assets for this <a id="_idIndexMarker237"/>game use a <strong class="bold">pixel art</strong> style, which means they look best when the images are not <a id="_idIndexMarker238"/>smoothed, which is Godot’s default setting for <strong class="bold">texture filtering</strong>:</p>
			<div><div><img src="img/B19289_04_02.jpg" alt="Figure 4.2: Texture filtering"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Texture filtering</p>
			<p>While it’s possible to set this on each <code>Sprite2D</code>, it’s more convenient to specify the default setting. Click the <strong class="bold">Advanced</strong> toggle in the top right and find the <strong class="bold">Rendering/Textures</strong> section on the left. In the settings list, scroll to the bottom and find the <strong class="bold">Canvas Textures/Default Texture Filter</strong> setting. Change it from <strong class="bold">Linear</strong> to <strong class="bold">Nearest</strong>.</p>
			<p>Then, under <strong class="bold">Display/Window</strong>, change <strong class="bold">Stretch/Mode</strong> to <strong class="bold">canvas items</strong> and <strong class="bold">Aspect</strong> to <strong class="bold">expand</strong>. These settings<a id="_idIndexMarker239"/> will allow the user to resize the game window while preserving the image’s quality. Once the project is complete, you’ll be able to see the effects of this setting.</p>
			<p>Next, you can set up the collision layers. Because this game will have several different types of collision objects that need to interact in different ways, you’ll use Godot’s <strong class="bold">collision layer</strong> system to help organize them. The layers will be more convenient to use if they’re assigned names, so go to the <strong class="bold">Layer Names | 2D Physics</strong> section and name the first four layers like this (by typing directly in the box next to the layer number):</p>
			<div><div><img src="img/B19289_04_03.jpg" alt="Figure 4.3: Setting physics layer names"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Setting physics layer names</p>
			<p>Finally, add the <a id="_idIndexMarker240"/>following actions for the player controls to the <strong class="bold">Input </strong><strong class="bold">Map</strong> area:</p>
			<table id="table001" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Action name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Key(s)</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>right</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">D</em>, →</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>left</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">A</em>, ←</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>jump</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Space</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>up</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">S</em>, ↑</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>down</code></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">W</em>, ↓</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Make sure you use the exact names for the input actions since you’ll be referencing them in code later.</p>
			<p>That’s all you need<a id="_idIndexMarker241"/> to set in <strong class="bold">Project Settings</strong>. But before you start making the player scene, you need to learn about a different type of physics node.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Introducing kinematic bodies</h1>
			<p>A platformer requires gravity, collisions, jumping, and other physics behavior, so you might think that <code>RigidBody2D</code> would be<a id="_idIndexMarker242"/> the perfect choice to implement the character’s movement. In practice, you’ll find that the more realistic physics of the rigid body are not desirable for a platform character. To the player, realism is less<a id="_idIndexMarker243"/> important than responsive control and an action feel. So, as the developer, you want to have precise control over the character’s movements and collision response. For this reason, a <strong class="bold">kinematic</strong> style of physics is usually the better choice for a platform character.</p>
			<p>The <code>CharacterBody2D</code> node is designed for implementing physics bodies that are to be controlled directly via code. These nodes detect collisions with other bodies when they move but are not affected by global physics properties such as gravity or friction. This doesn’t mean that they can’t be affected by gravity and other forces – just that you must calculate those forces and their effects in code; the physics engine will not move a <code>CharacterBody2D</code> node automatically.</p>
			<p>When moving a <code>CharacterBody2D</code> node as with <code>RigidBody2D</code>, you should not set its <code>position</code> property directly. Instead, you must use the <code>move_and_collide()</code> or <code>move_and_slide()</code> methods provided by the body. These methods move the body along a given vector and instantly stop it if a collision is detected with another body. It’s then up to you to decide on any <strong class="bold">collision response</strong>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Collision response</h2>
			<p>After a collision, you <a id="_idIndexMarker244"/>may want the <a id="_idIndexMarker245"/>body to bounce, slide along a wall, or alter the properties of the object it hit. The way you handle collision response depends on which method you use to move the body:</p>
			<h3>move_and_collide()</h3>
			<p>When using this method, the function returns a <code>KinematicCollision2D</code> object upon collision. This object contains information about the collision and the colliding body. You can use this information to determine the response. Note that the function returns <code>null</code> when movement is completed successfully with no collision.</p>
			<p>For example, if you want the<a id="_idIndexMarker246"/> body to bounce off the colliding object, you could use the following script:</p>
			<pre class="source-code">
extends CharacterBody2D
velocity = Vector2(250, 250)
func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())</pre>
			<h3>move_and_slide()</h3>
			<p>Sliding is a very common option for collision response. Imagine a player moving along a wall in a top-down game, or<a id="_idIndexMarker247"/> running along the ground in a platformer. While it’s possible to code the response yourself after using <code>move_and_collide()</code>, <code>move_and_slide()</code> provides a convenient way to implement sliding movement. When using this method, the body will automatically slide along the surface of a colliding object. In addition, sliding collisions will allow you to detect the orientation of the surface using methods such as <code>is_on_floor()</code>.</p>
			<p>Since this project will require you to allow the player character to run along the ground and up/down slopes, <code>move_and_slide()</code> is going to play a large role in your player’s movement.</p>
			<p>Now that you have an understanding of what kinematic bodies are, you’ll use one to make the character for this game.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Creating the player scene</h1>
			<p>The Godot node that implements<a id="_idIndexMarker248"/> kinematic movement and collision is called <code>CharacterBody</code> <code>2D</code>.</p>
			<p>Open a new scene and add a <code>CharacterBody2D</code> node named <code>Player</code> as the root and save the scene. Don’t forget to click the <code>Player</code> scene, you should also create a new folder to contain it. This will help keep your project folder <a id="_idIndexMarker249"/>organized as you add more scenes and scripts.</p>
			<p>Look at the properties of <code>CharacterBody2D</code> in the Inspector. Notice the default values of <strong class="bold">Motion Mode</strong> and <strong class="bold">Up Direction</strong>. “Grounded” mode means the body will consider one collision direction as the “floor,” the opposite wall as the “ceiling,” and any others as “walls” – which one is determined by <strong class="bold">Up Direction</strong>.</p>
			<p>As you’ve done in previous projects, you’ll include all the nodes the player character needs to function in the Player scene. For this game, that means handling collisions with various game objects, including<a id="_idIndexMarker250"/> platforms, enemies, and collectibles; displaying animations for actions, such as running or jumping; and attaching a camera to follow the player around the level.</p>
			<p>Scripting the various animations can quickly become unmanageable, so you’ll need to use a <strong class="bold">finite-state machine</strong> (<strong class="bold">FSM</strong>) to manage <a id="_idIndexMarker251"/>and track the player’s state. See <a href="B19289_03.xhtml#_idTextAnchor066"><em class="italic">Chapter </em><em class="italic">3</em></a> to review how a simplified FSM can be built. You’ll follow a similar pattern for this project.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Collision layers and masks</h2>
			<p>A body’s <code>Player</code> needs to be assigned to the “player” layer (which you named in <strong class="bold">Project Settings</strong>). Similarly, <strong class="bold">Collision/Mask</strong> sets which layers the body can “see” or interact with. If an object is on a layer that is not in the player’s <strong class="bold">Mask</strong>, then the <a id="_idIndexMarker253"/>player won’t interact with it at all.</p>
			<p>Set the player’s <strong class="bold">Layer</strong> to <strong class="bold">player</strong> and <strong class="bold">Mask</strong> to <strong class="bold">environment</strong>, <strong class="bold">enemies</strong>, and <strong class="bold">items</strong>. Click the three dots to the right to open a list of checkboxes showing the names you’ve assigned to the layers:</p>
			<div><div><img src="img/B19289_04_04.jpg" alt="Figure 4.4: Setting collision layers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Setting collision layers</p>
			<p>This will ensure that the player is on the “player” layer so that other objects can be configured to detect the <a id="_idIndexMarker254"/>player or not. Setting the <strong class="bold">Mask</strong> value to <a id="_idIndexMarker255"/>all three layers means the player will be able to interact with objects on any of those layers.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>About AnimationPlayer</h2>
			<p>Earlier in this book, you used <code>AnimatedSprite2D</code> to display the frame-based animations of your characters. This is a great tool, but it’s only useful for animating the visual texture of a <a id="_idIndexMarker256"/>node. What if you want to also animate any of a node’s other properties?</p>
			<p>This is where <code>AnimationPlayer</code> comes in. This node is a very powerful tool for creating animations that can affect multiple nodes at once; you can modify any of their properties.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Animations</h2>
			<p>To set up the <a id="_idIndexMarker257"/>character’s animations, follow these steps:</p>
			<ol>
				<li>Add a <code>Sprite2D</code> node to <code>Player</code>. Drag the <code>res://assets/player_sheet.png</code> file from the <strong class="bold">FileSystem</strong> dock and drop it into the <strong class="bold">Texture</strong> property. The player animation will be saved in the form of a sprite sheet:</li>
			</ol>
			<div><div><img src="img/B19289_04_05.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Sprite sheet</p>
			<ol>
				<li value="2">You’ll use <code>AnimationPlayer</code> to handle the animations, so, in the <code>Sprite2D</code>, set <code>19</code>. Then, set <code>7</code> to see the player standing. Finally, move <code>Sprite2D</code> upward until its feet are standing on the ground by setting <code>(0, -16)</code>. This will make it easier to code the player’s<a id="_idIndexMarker258"/> interactions later because you will know that the player’s <code>position</code> property represents the location of its feet.</li>
				<li>Add an <code>AnimationPlayer</code> node to the scene. You’ll use this node to change the <code>Sprite2D</code> to the appropriate values for each animation.</li>
				<li>Before you start, review the different parts of the <strong class="bold">Animation</strong> panel:</li>
			</ol>
			<div><div><img src="img/B19289_04_06.jpg" alt="Figure 4.6: The Animation panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: The Animation panel</p>
			<ol>
				<li value="5">Click the <code>idle</code>.</li>
				<li>Set its <code>0.4</code> seconds. Click the <strong class="bold">Loop</strong> icon to make the animation loop, and set the track’s <strong class="bold">Update Mode</strong> to <strong class="bold">Continuous</strong>.</li>
			</ol>
			<p>Change the <code>Sprite2D</code> to <code>7</code>, which is the first frame of the idle animation, and click the <strong class="bold">keyframe</strong> icon next to the property to add an animation track with <a id="_idIndexMarker259"/>a new keyframe:</p>
			<div><div><img src="img/B19289_04_07.jpg" alt="Figure 4.7: Adding a keyframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Adding a keyframe</p>
			<ol>
				<li value="7">Slide the play scrubber to <code>0.3</code> (you can adjust the zoom slider in the bottom right to make it easier to find). Add a keyframe for frame <code>10</code>, which is the last frame of <strong class="bold">idle</strong>.</li>
				<li>Press the <code>7</code> and ended on frame <code>10</code>.</li>
			</ol>
			<p>Now, repeat this process for the other animations. See the following table for a list of their settings:</p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Length</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Frames</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Looping</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>idle</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.4</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>7 </code>→ <code>10</code></p>
						</td>
						<td class="No-Table-Style">
							<p>On</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>run</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.5</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>13 </code>→<code> </code><code>18</code></p>
						</td>
						<td class="No-Table-Style">
							<p>On</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>hurt</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.2</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>5 </code>→ <code>6</code></p>
						</td>
						<td class="No-Table-Style">
							<p>On</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>jump_up</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.1</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>11</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Off</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>jump_down</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.1</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>12</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Off</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>There are also<a id="_idIndexMarker260"/> animations in the sprite sheet for crouching and climbing, but you can add those later, once the basic movement is completed.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Collision shape</h2>
			<p>As with other bodies, <code>CharacterBody2D</code> needs a shape assigned to define its collision bounds. Add a <code>CollisionShape2D</code> node and create a new <code>RectangleShape2D</code> inside it. When sizing the shape, you want it to reach the bottom of the image (the player’s feet) but be <a id="_idIndexMarker261"/>a little bit narrower than the player’s image. In general, making the shape a bit smaller than the image will result in a better feel when playing, avoiding the experience of hitting something that looks like it wouldn’t result in a collision.</p>
			<p>You’ll also need to offset the shape a small amount to make it fit. Setting the <code>CollisionShape2D</code> node’s <code>(0, -10)</code> works well. When you’re done, it should look approximately like this:</p>
			<div><div><img src="img/B19289_04_08.jpg" alt="Figure 4.8: Player collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Player collision shape</p>
			<p class="callout-heading">Multiple shapes</p>
			<p class="callout">In some cases, depending on the complexity of your character and its interactions with other objects, you may want to add multiple shapes to the same object. You might have one shape at the player’s feet to detect ground collisions, another on its body to detect damage, and yet another <a id="_idIndexMarker262"/>covering the player’s front to detect contact with walls.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Finishing the player scene</h2>
			<p>Add a <code>Camera2D</code> node to the <code>Player</code> scene. This node will keep the game window centered on the player as it moves around the level. You can also use it to zoom in on the player since pixel art is<a id="_idIndexMarker263"/> relatively small compared to the game window’s size. Remember, since you set the filtering option in <strong class="bold">Project Settings</strong>, the player’s texture will remain pixelated and blocky when zoomed in.</p>
			<p>To enable the camera, set the <code>(2.5, 2.5)</code>. Values smaller than 1 zoom the camera out, while larger values zoom it in.</p>
			<p>You’ll see a pinkish-purple rectangle surrounding the player. That’s the camera’s <strong class="bold">screen rectangle</strong> and it shows what the camera will see. You can adjust the <strong class="bold">Zoom</strong> property to increase or decrease its size to see more or less of the world around the player.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Player states</h2>
			<p>The player character has a wide<a id="_idIndexMarker264"/> variety of behaviors, such as jumping, running, and crouching. Coding such behaviors can become very complex and hard to manage. One solution is to use Boolean variables (<code>is_jumping</code> or <code>is_running</code>, for example), but this leads to possibly confusing states (what if <code>is_crouching</code> and <code>is_jumping</code> are both <code>true</code>?) and quickly leads to <code>_spaghetti_ code</code>.</p>
			<p>A better solution to this problem is to use a state machine to handle the player’s current state and control the transition to other states. This concept was introduced in <a href="B19289_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, and you’ll expand on it in this project.</p>
			<p>Here is a diagram of the player’s states and the transitions between them:</p>
			<div><div><img src="img/B19289_04_09.jpg" alt="Figure 4.9: Player state diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Player state diagram</p>
			<p>As you can see, state<a id="_idIndexMarker265"/> diagrams can become quite complex, even with a relatively small number of states.</p>
			<p class="callout-heading">Other states</p>
			<p class="callout">Note that while the sprite sheet contains animations for them, the <code>CROUCH</code> and <code>CLIMB</code> states are not included here. This is to keep the number of states manageable at the beginning of the project. Later, you’ll have the opportunity to add them.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Player script</h2>
			<p>Attach a new script to the <code>Player</code> node. Note that the dialog shows a <strong class="bold">Template</strong> property with Godot’s default <strong class="bold">Basic Movement </strong>for this node type. Uncheck the <strong class="bold">Template</strong> box – you won’t need that example code for this project.</p>
			<p>Add the following code to<a id="_idIndexMarker266"/> start setting up the player’s state machine. As in the <em class="italic">Space Rocks</em> game, you can use an <code>enum</code> type to define the allowed states for the system. When you want to change the player’s state, you can call <code>change_state()</code>:</p>
			<pre class="source-code">
extends CharacterBody2D
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            hide()</pre>
			<p>For now, the script <a id="_idIndexMarker267"/>only changes which animation is playing, but you’ll add more state functionality later.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Player movement</h2>
			<p>The player needs three controls: left, right, and jump. Comparing the current state to which keys are pressed will trigger a state change if the<a id="_idIndexMarker268"/> transition is allowed by the state diagram’s rules. Add the <code>get_input()</code> function to process the inputs and determine the result. Each <code>if</code> condition represents one of the transitions in the state diagram:</p>
			<pre class="source-code">
func get_input():
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")
    # movement occurs in all states
    velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false
    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true
    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)</pre>
			<p>Note that the jump check is using <code>is_action_just_pressed()</code> rather than <code>is_action_pressed()</code>. While the latter returns <code>true</code> so long as the key is held down, the former is only <code>true</code> in the<a id="_idIndexMarker269"/> frame after the key was pressed. This means that the player must press the jump key each time they want to jump.</p>
			<p>Call this function from <code>_physics_process()</code>, add the pull of gravity to the player’s <code>velocity</code>, and call the <code>move_and_slide()</code> method to move:</p>
			<pre class="source-code">
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()</pre>
			<p>Remember, since the <code>(0, -1)</code>, any collision below the player’s feet will be considered the “floor,” and <code>is_on_floor()</code> will be set to <code>true</code> by <code>move_and_slide()</code>. You can <a id="_idIndexMarker270"/>use this fact to detect when the jump ends by adding this right after <code>move_and_slide()</code>:</p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)</pre>
			<p>The jump will look better if the animation switches from <code>jump_up</code> to <code>jump_down</code> when falling:</p>
			<pre class="source-code">
if state == JUMP and velocity.y &gt; 0:
    $AnimationPlayer.play("jump_down")</pre>
			<p>Later, once the level is complete, the player will be passed a spawn location. To handle this, add this function to the script:</p>
			<pre class="source-code">
func reset(_position):
    position = _position
    show()
    change_state(IDLE)</pre>
			<p>With that, you have finished adding movement, and the correct animation should play for each situation. This would be a good point to stop and test the player to make sure everything is working. You can’t just run the scene, though, because the player will just start falling without any surface to stand on.</p>
			<h3>Testing the movement</h3>
			<p>Create a new scene and add a <code>Node</code> object called <code>Main</code> (later, this will become your main scene). Add an instance of <code>Player</code>, then add a <code>StaticBody2D</code> node with a rectangular collision <a id="_idIndexMarker271"/>shape. Stretch the collision shape horizontally so that it’s wide enough to walk back and forth on, and place it below the character:</p>
			<div><div><img src="img/B19289_04_10.jpg" alt="Figure 4.10: Test scene with a platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Test scene with a platform</p>
			<p>Since it doesn’t have a <code>Sprite2D</code> node, the static body will be invisible if you run the game. In the menu, choose <strong class="bold">Debug</strong> &gt; <strong class="bold">Visible Collision Shapes</strong>. This is a useful debug setting that will draw the collision shapes while the game is running. You can turn it on whenever you need to test or troubleshoot collisions.</p>
			<p>Press <code>idle</code> animation when it hits the static body.</p>
			<p>Before moving on, make <a id="_idIndexMarker272"/>sure that all the movements and animations are working correctly. Run and jump in all directions and check that the correct animations are playing whenever the state changes. If you find any problems, review the previous sections and make sure you didn’t miss a step.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Player health</h2>
			<p>Eventually, the player is going to<a id="_idIndexMarker273"/> encounter danger, so you should add a damage system. The player will start with three hearts and lose one each time they are damaged.</p>
			<p>Add the following to the top of the script (just after the <code>extends</code> line):</p>
			<pre class="source-code">
signal life_changed
signal died
var life = 3: set = set_life
func set_life(value):
    life = value
    life_changed.emit(life)
    if life &lt;= 0:
        change_state(DEAD)</pre>
			<p>You’ll emit the <code>life_changed</code> signal whenever the value of <code>life</code> changes, notifying the display to update. <code>dead</code> will be emitted when <code>life</code> reaches <code>0</code>.</p>
			<p>Add <code>life = 3</code> to the <code>reset()</code> function.</p>
			<p>There are two possible <a id="_idIndexMarker274"/>ways for the player to be hurt: running into a spike object in the environment or being hit by an enemy. In either event, the following function can be called:</p>
			<pre class="source-code">
func hurt():
    if state != HURT:
        change_state(HURT)</pre>
			<p>This code is being nice to the player: if they’re already hurt, they can’t get hurt again (at least for a brief time until the <code>hurt</code> animation has stopped playing). Without this, it’s easy to get stuck in a loop of getting hurt, resulting in a quick death.</p>
			<p>There are a few things to do when the state changes to <code>HURT</code> in the <code>change_state()</code> function you created earlier:</p>
			<pre class="source-code">
HURT:
    $AnimationPlayer.play("hurt")
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x)
    life -= 1
    await get_tree().create_timer(0.5).timeout
    change_state(IDLE)
DEAD:
    died.emit()
    hide()</pre>
			<p>When they’re hurt, not only do they lose one <code>life</code>, but they are also bounced up and away from the damaging object. After a short time, the state changes back to <code>IDLE</code>.</p>
			<p>Also, the input should be <a id="_idIndexMarker275"/>disabled during the <code>HURT</code> state. Add this to the beginning of <code>get_input()</code>:</p>
			<pre class="source-code">
if state == HURT:
    return</pre>
			<p>Now, the player is ready to take damage once the rest of the game has been set up. Next, you will create the objects that the player will collect in the game.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Collectible items</h1>
			<p>Before you start <a id="_idIndexMarker276"/>making the level, you need to create some items that the player can collect, since those will be part of the level as well. The <code>assets/sprites</code> folder contains sprite sheets for two types of collectibles: cherries and gems.</p>
			<p>Rather than make a separate scene for<a id="_idIndexMarker277"/> each type of item, you can use a single scene and swap out the <code>texture</code> property in the script. Both objects have the same behavior: animating in place and disappearing when collected by the player. You can also add a <code>tween</code> effect for the collection (see <a href="B19289_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>).</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Scene setup</h2>
			<p>Start the new scene with <code>Area2D</code> and name it <code>Item</code>. Save the scene in a new <code>items</code> folder.</p>
			<p>An area is a good choice for these<a id="_idIndexMarker278"/> objects because you want to detect when the player contacts them, but you don’t need a collision response from them. In the Inspector, set <code>collectibles</code> (layer 4) and <code>player</code> (layer 2). This will ensure that only the <code>Player</code> node will be able to collect them, while the enemies will pass right through.</p>
			<p>Add three child nodes: <code>Sprite2D</code>, <code>CollisionShape2D</code>, and <code>AnimationPlayer</code>. Drag <code>res://assets/sprites/cherry.png</code> into the <code>Sprite2D</code> node’s <code>5</code>. Then, add a circle shape to <code>CollisionShape2D</code> and size it appropriately:</p>
			<div><div><img src="img/B19289_04_11.jpg" alt="Figure 4.11: Item with collision"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Item with collision</p>
			<p class="callout-heading">Choosing a collision size</p>
			<p class="callout">As a general rule, you should size your collision shapes so that they benefit the player. This means that enemy hitboxes should be a little smaller than the image, while the hitboxes of beneficial items should be slightly oversized. This reduces player frustration and results in a better gameplay experience.</p>
			<p>Add a new animation to <code>AnimationPlayer</code> (you only need one, so you can name it anything you like). Set <code>1.6</code> seconds, <code>0.2</code> seconds, and <strong class="bold">Looping</strong> to <strong class="bold">on</strong>. Click the <strong class="bold">Autoplay on Load</strong> button <a id="_idIndexMarker279"/>so that the animation will start automatically.</p>
			<p>Set the <code>Sprite2D</code> node’s <code>0</code> and click the key button to create the track. This sprite sheet only contains half the animation, so the animation needs to play the frames in the following order:</p>
			<p class="author-quote"><em class="italic">0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</em></p>
			<p>Drag the scrubber to time <code>0.8</code> and key <code>4</code>. Then, key <code>1</code> at time <code>1.4</code>. Set <code>res://assets/sprites/coin.png</code> image into <strong class="bold">Texture</strong> and it will work just the same since it has the same number of frames. This will make it easy to spawn both cherries and gems in your game.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Collectible script</h2>
			<p>The <code>Item</code> script needs to do two things:</p>
			<ul>
				<li>Set the start <a id="_idIndexMarker280"/>conditions (which <code>texture</code> and <code>position</code>)</li>
				<li>Detect when the player overlaps</li>
			</ul>
			<p>For the first part, add the following code to your new item script:</p>
			<pre class="source-code">
extends Area2D
signal picked_up
var textures = {
    "cherry": "res://assets/sprites/cherry.png",
    "gem": "res://assets/sprites/gem.png"
}
func init(type, _position):
    $Sprite2D.texture = load(textures[type])
    position = _position</pre>
			<p>You’ll emit the <code>picked_up</code> signal when the player collects the item. In the <code>textures</code> dictionary, you will find a list of the item types and their corresponding image files. Note that you can quickly paste those paths into the script by dragging the file from <strong class="bold">FileSystem</strong> and dropping it into the script editor.</p>
			<p>Next, the <code>init()</code> function sets <code>texture</code> and <code>position</code>. Your level script will use this to spawn all the items that you’ve placed in your level map.</p>
			<p>Finally, connect the <code>body_entered</code> signal of <code>Item</code> and add this code:</p>
			<pre class="source-code">
func _on_item_body_entered(body):
    picked_up.emit()
    queue_free()</pre>
			<p>This signal will allow the game’s main script to react to the item being picked up. It can add to the score, increase<a id="_idIndexMarker281"/> the player’s health, or any other effect you want the item to apply.</p>
			<p>You might have noticed that these collectible items are set up very much like the coins from <em class="italic">Coin Dash</em> were. Areas are very useful for any type of item where you need to know when it’s been touched. In the next section, you’ll start laying out the level scene so that you can place these collectibles.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Designing the level</h1>
			<p>For most of you, this <a id="_idIndexMarker282"/>section will take up the largest chunk of your time. Once you start designing a level, you’ll find it’s a lot of fun to lay out all the pieces and create challenging jumps, secret paths, and dangerous encounters.</p>
			<p>First, you’ll create a generic <code>Level</code> scene containing all the nodes and code that is common to all levels. You<a id="_idIndexMarker283"/> can then create any number of <code>Level</code> scenes that inherit from this master level.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Using TileMaps</h2>
			<p>Create a new scene and add a <code>Node2D</code> node named <code>LevelBase</code>. Save the scene in a new folder called <code>levels</code>. This is where you’ll save all the levels you create, and they will all inherit<a id="_idIndexMarker284"/> functionality from this <code>level_base.tscn</code> scene. They’ll all have the same node hierarchy – only the layout will be different.</p>
			<p>A tilemap is a common tool for <a id="_idIndexMarker285"/>designing game environments using a grid of tiles. They allow you to draw a level layout by painting the tiles onto the grid rather than placing many individual nodes one at a time. They are also more efficient because they batch all the individual tile textures and collision shapes into a single game object.</p>
			<p>Add a <code>TileMap</code> node; a new <strong class="bold">TileMap</strong> panel will appear at the bottom of the editor window. Note that it says <strong class="bold">The edited TileMap has no </strong><strong class="bold">TileSet resource</strong>.</p>
			<h3>About TileSets</h3>
			<p>To draw a map using <code>TileMap</code>, it must have <code>TileSet</code> assigned. This <code>TileSet</code> contains all the individual tile textures, along with any collision shapes they may have.</p>
			<p>Depending on how many tiles <a id="_idIndexMarker286"/>you may have, it can be time-consuming to create <code>TileSet</code>, especially for the first time. For that reason, some pre-generated tilesets have been included in the <code>assets</code> folder. Feel free to use those instead, but <a id="_idIndexMarker287"/>do read through the following section. It contains useful information to help you understand how <code>TileSet</code> works. If you’d rather use the provided tilesets, skip to the <em class="italic">Using the provided </em><em class="italic">TileSets</em> section.</p>
			<h4>Creating a TileSet</h4>
			<p>In Godot, <code>TileSet</code> is a type of <code>Resource</code>. Examples of other resources include <code>Texture</code>, <code>Animation</code>, and <code>RectangleShape2D</code>. They are not nodes; instead, they are containers that hold a certain type of data and are usually saved as <code>.</code><code>tres</code> files.</p>
			<p>These are the steps for <a id="_idIndexMarker288"/>creating a <code>TileSet</code> container:</p>
			<ol>
				<li>Click <code>TileMap</code>. You’ll see that you now have a <strong class="bold">TileSet</strong> panel available, which you can select at the bottom of the editor window. You can click the two upward arrows, <img src="img/B19289_04_12.png" alt=""/>, to make the panel fill the editor screen. Click it again to shrink the panel.</li>
				<li>The <code>TileSet</code> panel is where you can place the textures that you want to slice up into tiles. Drag <code>res://assets/environment/tileset.png</code> into this box. A popup will appear, asking if you’d like to automatically create tiles. Select <code>16x16</code> pixel tiles in the image:</li>
			</ol>
			<div><div><img src="img/B19289_04_13.jpg" alt="Figure 4.12: Adding a TileSet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: Adding a TileSet</p>
			<ol>
				<li value="3">Try selecting the <strong class="bold">TileMap</strong> panel at the bottom and then select the grass block image in the top left of the tiles. Then, click in<a id="_idIndexMarker289"/> the editor window to draw some tiles by left-clicking in the editor window. You can right-click on a tile to clear it:</li>
			</ol>
			<div><div><img src="img/B19289_04_14.jpg" alt="Figure 4.13: Drawing with TileMaps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13: Drawing with TileMaps</p>
			<p>If all you wanted to do was draw a background, you’d be done. However, you also need to add collisions<a id="_idIndexMarker290"/> to these tiles so that the player can stand on them.</p>
			<ol>
				<li value="4">Open the <strong class="bold">TileSet</strong> panel again and, in the Inspector, find the <strong class="bold">PhysicsLayers</strong> property and click <strong class="bold">Add Element</strong>:</li>
			</ol>
			<div><div><img src="img/B19289_04_15.jpg" alt="Figure 4.14: Adding a physics layer to TileSet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14: Adding a physics layer to TileSet</p>
			<p>Since these tiles will be in the <code>environment</code> layer, you don’t need to change the layer/mask settings.</p>
			<ol>
				<li value="5">Click <code>Physics </code><code>Layer 0</code>:</li>
			</ol>
			<div><div><img src="img/B19289_04_16.jpg" alt="Figure 4.15: Adding collisions to tiles"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15: Adding collisions to tiles</p>
			<ol>
				<li value="6">Start clicking on the tiles to add the default square collision shape to them. If you want to edit a tile’s collision shape, you can do so – click the tile again to apply the changes. If you get stuck with a shape you don’t like, click the three dots and choose <strong class="bold">Reset to default </strong><strong class="bold">tile shape</strong>.</li>
			</ol>
			<p>You can also <a id="_idIndexMarker292"/>drag the <code>props.png</code> image into the texture list for some decorative items to spice up your level.</p>
			<h3>Using the provided TileSets</h3>
			<p>Pre-configured tilesets have been included in the <code>assets</code> download for this project. There are three to be <a id="_idIndexMarker293"/>added to three different <code>TileMap</code> nodes:</p>
			<ul>
				<li> <code>World</code> – <code>tiles_world.tres</code>: Ground and platform tiles</li>
				<li> <code>Items</code> – <code>tiles_items.tres</code>: Markers for spawning collectibles</li>
				<li> <code>Danger</code> – <code>tiles_spikes.tres</code>: Items that cause damage on collision</li>
			</ul>
			<p>Create the <code>Items</code> and <code>Danger</code> tilemaps and add the associated tileset to the <strong class="bold">Tile </strong><strong class="bold">Set</strong> property.</p>
			<p>Add an instance of the <code>Player</code> scene and a <code>Marker2D</code> node named <code>SpawnPoint</code>. You can use this node to mark where in your level you want the player to start.</p>
			<p>Attach a script to the <code>Level</code> node:</p>
			<pre class="source-code">
extends Node2D
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)</pre>
			<p>Later, you’ll be scanning the <code>Items</code> map to spawn collectibles in the designated locations. This map layer shouldn’t be seen, so you could set it as hidden in the scene. However, this is easy to forget, so <code>_ready()</code> ensures that it’s not visible during gameplay.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Designing the first level</h2>
			<p>Now, you’re ready to start drawing the level! Click <code>level_base.tscn</code>. Name the root node <code>Level01</code> and save it (in the <code>levels</code> folder). Notice that the child <a id="_idIndexMarker294"/>nodes are colored yellow, indicating that they are <code>level_base.tscn</code>. If you make changes to that original scene, those changes will also appear in this scene.</p>
			<p>Start with the <code>World</code> map and be creative. Do you like lots of jumps, or twisty tunnels to explore? Long runs or careful upward climbs?</p>
			<p>Before going too far with your level design, make sure you experiment with jump distance. You can change the player’s <code>jump_speed</code>, <code>run_speed</code>, and <code>gravity</code> properties to alter how high and how far they can jump. Set up some different gap sizes and run the scene to try them out. Don’t forget to drag the <code>SpawnPoint</code> node to the place you want the player to start.</p>
			<p>How you set the player’s movement properties will have a big impact on how your level should be laid out. Make sure you’re happy with your settings before spending too much time on the full design.</p>
			<p>Once you have the <code>World</code> map set up, use the <code>Items</code> map to mark the locations where you’d like to spawn the cherries and gems. The tiles that mark the spawn locations are drawn with a magenta background to make them stand out. Remember, they’ll be replaced at runtime and the tiles themselves won’t be seen.</p>
			<p>Once you have your level laid out, you can limit the horizontal scrolling of the player camera to match the size of the map (plus a small buffer on each end). Add this code to <code>level_base.gd</code>:</p>
			<pre class="source-code">
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
    set_camera_limits()
func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.tile_set.tile_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5)
        * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) *
        cell_size.x</pre>
			<p>The script also needs to scan the <code>Items</code> map and look for the item markers. Collecting items will add to the <a id="_idIndexMarker295"/>player’s score, so you can add a variable to track that as well:</p>
			<pre class="source-code">
signal score_changed
var item_scene = load("res://items/item.tscn")
var score = 0: set = set_score
func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        var item = item_scene.instantiate()
        add_child(item)
        item.init(type, $Items.map_to_local(cell))
        item.picked_up.connect(self._on_item_picked_up)
func _on_item_picked_up():
    score += 1
func set_score(value):
    score = value
    score_changed.emit(score)</pre>
			<p>The <code>spawn_items()</code> function uses <code>get_used_cells()</code> to get a list of which cells in <code>TileMap</code> are not empty. These cells are in <code>_map coordinates_</code>, not pixel coordinates, so later, when you<a id="_idIndexMarker296"/> spawn the item, you can use <code>map_to_local()</code> to convert the values.</p>
			<p>The marker tiles<a id="_idIndexMarker297"/> have a <code>gem</code> or <code>cherry</code>. That’s then used to tell the new instance which type of item it should be.</p>
			<p>The <code>score</code> variable is there to keep track of how many items the player has collected. You could have this trigger completion of the level, give a bonus, and so on.</p>
			<p>Add <code>spawn_items()</code> to <code>_ready()</code> and try running the level. You should see gems and cherries appear wherever you’ve added them. Also, check that they disappear when you collect them.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Adding dangerous objects</h2>
			<p>The <code>Danger</code> map layer is<a id="_idIndexMarker298"/> designed to hold the spike objects that will harm the player when touched. Any tile on this <code>TileMap</code> will cause damage to the player! Try placing a few of them where you can easily test running into them.</p>
			<p>In the <code>Danger</code> tilemap to a group called <code>danger</code> so that you can easily identify it when colliding. This will also allow you to make other harmful objects upon adding them to the same group.</p>
			<h3>About slide collisions</h3>
			<p>When a <code>CharacterBody2D</code> node is moved with <code>move_and_slide()</code>, it may collide with more than one object in the same frame’s movement. For example, when running into a corner, the body may hit the wall and the floor at the same time. You can use the <code>get_slide_collision_count()</code> function to find out how many collisions occurred; then, you can get information about each collision using <code>get_slide_collision()</code>.</p>
			<p>In the case of <code>Player</code>, you <a id="_idIndexMarker299"/>want to detect when a collision occurs against the <code>Danger</code> tilemap. You can do this just after using <code>move_and_slide()</code> in <code>player.gd</code>:</p>
			<pre class="source-code">
if state == HURT:
    return
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()</pre>
			<p>Note that before checking for a collision with the <code>danger</code> group, you can first check if the player is already in the <code>HURT</code> state. If they are, you can skip checking to see if they are colliding with a dangerous object.</p>
			<p>The <code>for</code> loop iterates through the number of collisions given by <code>get_slide_collision_count()</code> to check each one for an object in the danger group.</p>
			<p>Play your scene and try running into one of the spikes. You should see the player change to the <code>HURT</code> state (playing the animation) for a brief time before returning to <code>IDLE</code>. After three hits, the player will enter the <code>DEAD</code> state, which currently only hides the player.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Scrolling background</h2>
			<p>There are two background images in the <code>res://assets/environment/</code> folder: <code>back.png</code> and <code>middle.png</code>, for the far and near background, respectively. By placing these images behind the tilemap <a id="_idIndexMarker300"/>and scrolling them at different speeds relative to the camera, you can create an attractive illusion of depth in the background:</p>
			<ol>
				<li>Add a <code>ParallaxBackground</code> node to the <code>LevelBase</code> scene (so that it will be present on all inherited levels). This node works with the camera to create a scrolling effect. Drag this node to the top of the scene tree so that it will be drawn behind the rest of the nodes. Next, add a <code>ParallaxLayer</code> node as its child. <code>ParallaxBackground</code> can have any number of <code>ParallaxLayer</code> children, allowing you to make multiple independently scrolling layers.</li>
				<li>Add a <code>Sprite2D</code> node as a child of <code>ParallaxLayer</code> and drag the <code>back.png</code> image into its <code>Sprite2D</code> node’s <code>(</code><code>1.5, 1.5)</code>.</li>
				<li>On <code>ParallaxLayer</code>, set <code>(0.2, 1)</code> (you’ll need to click the <code>x</code> and <code>y</code> values to be set separately). This setting controls how fast the background scrolls concerning the camera movement. By setting it to a number less than <code>1</code>, the image will only move a small amount as the player moves<a id="_idIndexMarker301"/> left and right.</li>
				<li>You need to be sure the image repeats if your level is wider than the size of the image, so set <code>(576, 0)</code>. This is exactly the width of the image (<code>384</code> times <code>1.5</code>), so the image will be repeated when it has moved by that number of pixels.</li>
				<li>Note that this background image is designed for levels that are wide rather than tall. If you jump too high, you’ll see the top of the image. You can fix this by setting the top limit of the camera. If you haven’t moved the background’s position, its top-left corner will still be at (<code>0, 0)</code>, so you can set the <code>0</code>. If you have moved <code>ParallaxLayer</code> or its <code>Sprite2D</code> node, you can find the correct value to use by looking at the <code>y</code> value of the node’s <strong class="bold">Position</strong>.</li>
				<li>Try playing the level and running left and right. You should see the background moving by a small amount compared to how far you run.</li>
				<li>Add another <code>ParallaxLayer</code> (also as a child of <code>ParallaxBackground</code>) and give it a <code>Sprite2D</code> child. This time, use the <code>middle.png</code> image. This image is much narrower than the sky image, so you’ll need to adjust some settings to make it repeat properly. This is because <code>ParallaxBackground</code> needs to have images<a id="_idIndexMarker302"/> that are at least as big as the viewport area.</li>
				<li>Find the <code>Sprite2D</code> node’s <code>Mirror</code>. Then, expand the <code>(880, 368)</code>. <code>880</code> is the width of the image (<code>176</code>) multiplied by <code>5</code>, so you will now see five repetitions of the image, each one a mirror of the last.</li>
				<li>Move the <code>Sprite2D</code> node so that the image overlaps the bottom half of the ocean/sky image:</li>
			</ol>
			<div><div><img src="img/B19289_04_17.jpg" alt="Figure 4.16: Parallax background setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16: Parallax background setup</p>
			<ol>
				<li value="10">Set the second <code>ParallaxLayer</code> node’s <code>(0.6, 1)</code> and <code>880, 0)</code>. Using a higher scale factor means that this layer will scroll a little bit<a id="_idIndexMarker303"/> faster than the cloud layer behind it. Play the scene to test the effect.</li>
			</ol>
			<p>Your <code>Level</code> scene’s node tree should now look like this:</p>
			<div><div><img src="img/B19289_04_18.jpg" alt="Figure 4.17: Level scene nodes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17: Level scene nodes</p>
			<p>Your level scene now has all the pieces you need to create your level design. Do you want your player to have to make very precise jumps (a parkour level), run through a series of winding passages trying to find all the items (a maze level), or some combination of the two? This is your chance to try out some creative ideas, but make sure you leave some room for the next object you’ll make: enemies.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Adding enemies</h1>
			<p>There are many<a id="_idIndexMarker304"/> different behaviors you could add for an enemy. For this game, the <a id="_idIndexMarker305"/>enemy will walk along a platform in a straight line and change direction when hitting an obstacle.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Scene setup</h2>
			<p>As before, you’ll need to<a id="_idIndexMarker306"/> create a new scene to represent the enemy:</p>
			<ol>
				<li>Start with a <code>CharacterBody2D</code> node named <code>Enemy</code> and give it three children: <code>Sprite2D</code>, <code>CollisionShape2D</code>, and <code>AnimationPlayer</code>.</li>
				<li>Save the scene in a folder called <code>enemies</code>. If you decide to add more enemy types to the game, you can save them all here.</li>
				<li>Set the body’s collision <strong class="bold">Layer</strong> to <strong class="bold">enemies</strong> and its <strong class="bold">Mask</strong> to <strong class="bold">environment</strong>, <strong class="bold">player</strong>, and <strong class="bold">enemies</strong>. As with the player, this determines which types of objects the enemy will collide with.</li>
				<li>It’s also useful to group enemies together, so click the <code>enemies</code>.</li>
				<li>Add <code>res://assets/sprites/opossum.png</code> to <code>6</code>.</li>
				<li>Add a rectangular collision shape that covers most (but not all) of the image, making sure that the bottom of the collision shape is aligned with the bottom of the opossum’s feet:</li>
			</ol>
			<div><div><img src="img/B19289_04_19.jpg" alt="Figure 4.18: Enemy collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18: Enemy collision shape</p>
			<ol>
				<li value="7">Add a new animation to <code>AnimationPlayer</code> called <code>walk</code>. Set <code>0.6</code> seconds and turn <strong class="bold">Looping</strong> and <strong class="bold">Autoplay on </strong><strong class="bold">Load</strong> on.</li>
				<li>The <code>walk</code> animation needs to have two tracks: one that sets the <code>Sprite2D</code> node and one that changes its <code>0</code> at time<a id="_idIndexMarker307"/> zero, and <code>5</code> at time <code>0.5</code>. Don’t forget to change <strong class="bold">Update Mode</strong> to <strong class="bold">Continuous</strong>.</li>
			</ol>
			<p>When finished, your animation should look like this:</p>
			<div><div><img src="img/B19289_04_20.jpg" alt="Figure 4.19: Enemy animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19: Enemy animations</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Scripting the enemy</h2>
			<p>By now, moving a <code>CharacterBody2D</code> node be familiar to you. Look at this script and try to understand what it’s <a id="_idIndexMarker308"/>doing before reading the explanation provided after:</p>
			<pre class="source-code">
extends CharacterBody2D
@export var speed = 50
@export var gravity = 900
var facing = 1
func _physics_process(delta):
    velocity.y += gravity * delta
    velocity.x = facing * speed
    $Sprite2D.flip_h = velocity.x &gt; 0
    move_and_slide()
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().name == "Player":
            collision.get_collider().hurt()
        if collision.get_normal().x != 0:
            facing = sign(collision.get_normal().x)
            velocity.y = -100
    if position.y &gt; 10000:
        queue_free()</pre>
			<p>In this script, the <code>facing</code> variable keeps track of the movement in the <code>x</code> direction, either <code>1</code> or <code>-1</code>. As with the player, after moving, you must check the slide collisions. If the colliding object is the player, you must call its <code>hurt()</code> function.</p>
			<p>Next, you must check whether the colliding body’s <code>x</code> component that isn’t <code>0</code>. This means it points to<a id="_idIndexMarker309"/> the left or right, which means it is a wall or other obstacle. The direction of the normal is then used to set the new facing. Giving the body a small upward velocity will give the enemy a small bounce effect when turning around, which will look more appealing.</p>
			<p>Lastly, if for some reason the enemy falls off a platform, you don’t want the game to have to track it falling forever, so you must delete any enemy whose <code>y</code> coordinate becomes too large.</p>
			<p>Add an instance of <code>Enemy</code> to your level scene. Make sure it has some obstacles on either side and play the scene. Check that the enemy walks back and forth between the obstacles. Try putting the player in<a id="_idIndexMarker310"/> its path and verify that the player’s <code>hurt()</code> function is called.</p>
			<p>You may notice that if you jump on top of the enemy, nothing happens. We will handle that part next.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Damaging the enemy</h2>
			<p>It’s not fair if the player can’t hit back, so<a id="_idIndexMarker311"/> in the tradition of Mario, jumping on top of the enemy will defeat it.</p>
			<p>Start by adding a new animation to the enemy’s <code>AnimationPlayer</code> node called <code>death</code>. Set <code>0.3</code> and <code>0.05</code>. Don’t turn on looping for this animation.</p>
			<p>The <code>death</code> animation will also set both <code>res://assets/sprites/enemy_death.png</code> image into the sprite’s <code>0</code> and <code>5</code> values of <strong class="bold">Frame</strong> at the start and end of the animation. Remember to set <strong class="bold">Update Mode</strong> to <strong class="bold">Continuous</strong>.</p>
			<p>Add the following code to <code>enemy.gd</code> so that you have a way to trigger the death animation on the enemy:</p>
			<pre class="source-code">
func take_damage():
    $AnimationPlayer.play("death")
    $CollisionShape2D.set_deferred("disabled", true)
    set_physics_process(false)</pre>
			<p>When the player hits the enemy under the right conditions, it will call <code>take_damage()</code>, which plays the <code>death</code> animation, disables collision, and halts movement.</p>
			<p>When the death animation finishes playing, it’s OK to remove the enemy, so connect the <code>animation_finished</code> signal of <code>AnimationPlayer</code>:</p>
			<div><div><img src="img/B19289_04_21.jpg" alt="Figure 4.20: AnimationPlayer’s signals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20: AnimationPlayer’s signals</p>
			<p>This signal is called every time <a id="_idIndexMarker312"/>any animation finishes, so you need to check if it’s the correct one:</p>
			<pre class="source-code">
func _on_animation_player_animation_finished(anim_name):
    if anim_name == "death":
        queue_free()</pre>
			<p>To complete this process, go to the <code>player.gd</code> script and add the following code to the section of <code>_physics_process()</code> where you check the collisions. This code will check if the player hit an enemy from above:</p>
			<pre class="source-code">
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
    if collision.get_collider().is_in_group("enemies"):
        if position.y &lt; collision.get_collider().position.y:
            collision.get_collider().take_damage()
            velocity.y = -200
        else:
            hurt()</pre>
			<p>This code compares the <code>y</code> position of the player’s feet to the enemy’s <code>y</code> position to see if the player is above the enemy. If they <a id="_idIndexMarker313"/>are, the enemy should be hurt; otherwise, the player should be.</p>
			<p>Run the level again and try jumping on the enemy to check that everything is working as expected.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Player script</h2>
			<p>You’ve made <a id="_idIndexMarker314"/>several additions to the player’s script. Here’s what the full script should look like now:</p>
			<pre class="source-code">
extends CharacterBody2D
signal life_changed
signal died
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
var life = 3: set = set_life
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
            velocity.y = -200
            velocity.x = -100 * sign(velocity.x)
            life -= 1
            await get_tree().create_timer(0.5).timeout
            change_state(IDLE)
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            died.emit()
            hide()
func get_input():
    if state == HURT:
        return
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")
    # movement occurs in all states
    velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false
    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true
    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
    if state == HURT:
        return
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().is_in_group("danger"):
            hurt()
        if collision.get_collider().is_in_group("enemies"):
            if position.y &lt;
            collision.get_collider().position.y:
                collision.get_collider().take_damage()
                velocity.y = -200
            else:
                hurt()
    if state == JUMP and is_on_floor():
        change_state(IDLE)
    if state == JUMP and velocity.y &gt; 0:
        $AnimationPlayer.play("jump_down")
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
    life = 3
func set_life(value):
    life = value
    life_changed.emit(life)
    if life &lt;= 0:
        change_state(DEAD)
func hurt():
    if state != HURT:
        change_state(HURT)</pre>
			<p>If you’re having any trouble with the player code, try to think about what part could be the problem. Is it the<a id="_idIndexMarker315"/> movement? The hit detection when running into an enemy? If you can narrow down the problem, it’ll help you determine which part of the script you should be focusing on.</p>
			<p>Make sure you’re satisfied with how the player is behaving before moving on to the next section.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Game UI</h1>
			<p>As in the previous <a id="_idIndexMarker316"/>projects you’ve worked on, you’ll need a HUD to display information during gameplay. Collecting items will increase the player’s score, so that number should be displayed, as well as the player’s remaining life value, which will be shown as a series of hearts.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Scene setup</h2>
			<p>Create a new scene with a <code>MarginContainer</code> root node named <code>HUD</code> and save it in a new <code>ui</code> folder. Set <code>50</code> and the top/bottom margins to <code>20</code>.</p>
			<p>Add an <code>HBoxContainer</code> node to keep things aligned and give it two children, <code>Label</code> and <code>HBoxContainer</code>, named <code>Score</code> and <code>LifeCounter</code>, respectively.</p>
			<p>On the <code>Score</code> label, set the <code>100</code> and in the Inspector, under <code>res://assets/Kenney Thick.ttf</code> into the <code>48</code>. Under <code>16</code> and <code>100</code> displayed in white with a black outline.</p>
			<p>For <code>LifeCounter</code>, add a <code>TextureRect</code> child and name it <code>L1</code>. Drag <code>res://assets/heart.png</code> into its <code>L1</code> and duplicate (<em class="italic">Ctrl</em> + <em class="italic">D</em>) it four times so that you have a row of five hearts:</p>
			<div><div><img src="img/B19289_04_22.jpg" alt="Figure 4.21: HUD node setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21: HUD node setup</p>
			<p>When you’re finished, your HUD should look like this:</p>
			<div><div><img src="img/B19289_04_23.jpg" alt="Figure 4.22: HUD preview"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22: HUD preview</p>
			<p>The next step will be<a id="_idIndexMarker318"/> to add a script so that the HUD can update during the game.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Scripting the HUD</h2>
			<p>This script needs two <a id="_idIndexMarker319"/>functions that can be called to update the two values being displayed:</p>
			<pre class="source-code">
extends MarginContainer
@onready var life_counter = $HBoxContainer/LifeCounter.get_children()
func update_life(value):
    for heart in life_counter.size():
        life_counter[heart].visible = value &gt; heart
func update_score(value):
    $HBoxContainer/Score.text = str(value)</pre>
			<p>Note that, in <code>update_life()</code>, you calculate how many hearts to display by setting <code>visible</code> to <code>false</code> if the number of that <a id="_idIndexMarker320"/>heart is less than the life amount.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Attaching the HUD</h2>
			<p>Open <code>level_base.tscn</code> (the base level <a id="_idIndexMarker321"/>scene, not your <code>Level01</code> scene) and add <code>CanvasLayer</code>. Add an instance of <code>HUD</code> as a child of this <code>Canvaslayer</code>.</p>
			<p>Select the level’s <code>Player</code> instance and connect its <code>life_changed</code> signal to the HUD’s <code>update_life()</code> method:</p>
			<div><div><img src="img/B19289_04_24.jpg" alt="Figure 4.23: Connecting a signal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23: Connecting a signal</p>
			<p>Do the same with the <code>score_changed</code> signal of the <code>Level</code> node, connecting it to the HUD’s <code>update_score()</code> method.</p>
			<p>Note that if you don’t want to use the scene tree to connect the signals, or if you find the signal connection window confusing or difficult to use, you can accomplish the same thing in your script by adding<a id="_idIndexMarker322"/> these lines to the <code>_ready()</code> function of <code>level.gd</code>:</p>
			<pre class="source-code">
$Player.life_changed.connect($CanvasLayer/HUD.update_life)
score_changed.connect($CanvasLayer/HUD.update_score)</pre>
			<p>Play the game and verify that you can see the HUD and that it updates correctly. Make sure you collect some items and let the enemy hit you. Is your score increasing? When you’re hit, do you lose one heart? Once you’ve checked this, you can continue to the next section and make the title screen.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Title screen</h1>
			<p>The title <a id="_idIndexMarker323"/>screen is the first thing the player will see, and the game will return to this screen when the player dies and the game ends.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Scene setup</h2>
			<p>Start with a <code>Control</code> node <a id="_idIndexMarker324"/>and set <code>TextureRect</code> node using the <code>back.png</code> image. Set <strong class="bold">Layout</strong> to <strong class="bold">Full Rect</strong> and <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep </strong><strong class="bold">Aspect Covered</strong>.</p>
			<p>Add another <code>TextureRect</code>, this time using <code>middle.png</code> and setting <strong class="bold">Stretch Mode</strong> to <strong class="bold">Tile</strong>. Drag the width of the rectangle until it’s wider than the screen and arrange it so that it covers the bottom half.</p>
			<p>Add two <code>Label</code> nodes named <code>Title</code> and <code>Message</code> and set their <code>Jungle Jump</code> and <code>Press Space to Play</code>, respectively. Add the font to each one as you’ve done before, setting the title to size <code>72</code> and the message to size <code>48</code>. Set the title’s layout to <strong class="bold">Centered</strong> and the message’s layout to <strong class="bold">Center Bottom</strong>.</p>
			<p>When you’re finished, the scene should look like this:</p>
			<div><div><img src="img/B19289_04_25.jpg" alt="Figure 4.24: Title screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24: Title screen</p>
			<p>To make the title screen more interesting, add an <code>AnimationPlayer</code> node to it. Create a new animation named <code>intro</code> and set it to autoplay. In this animation, you can animate the elements of the screen to make them move, appear, fade in, or any other effect you like.</p>
			<p>For example, keyframe the current <code>Title</code> at time <code>0.5</code>. Then, at time <code>0</code>, drag <code>Title</code> off the top of the screen and add another keyframe. Now, the title will drop onto the screen when you play the scene.</p>
			<p>Feel free to add tracks that <a id="_idIndexMarker325"/>animate the other nodes’ properties. For example, here is an animation that drops the title down, fades in the two textures, and then makes the message appear:</p>
			<div><div><img src="img/B19289_04_26.jpg" alt="Figure 4.25: Title screen animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25: Title screen animations</p>
			<p>This title screen has been kept simple, but you should feel free to add to it if you’d like. You could show an example of some platforms, add an animation of the character running across the screen, or some other game art. But what happens when the player hits “start”? For this, you need to load the first level in the main scene.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Setting up the main scene</h1>
			<p>You’ve made<a id="_idIndexMarker326"/> some level scenes, but eventually, you’re going to want to make more than one. How does the game know which one to load? Your <code>Main</code> scene is going to take care of that.</p>
			<p>Delete any extra nodes you added to <code>main.tscn</code> when you were testing the player’s movement. This scene will now be responsible for loading the current level. Before it can do that, however, you need a way to keep track of the current level. You can’t keep track of that variable in the level scene because that will be replaced with a newly loaded level when it ends. To keep track of data that needs to be carried from scene to scene, you can<a id="_idIndexMarker327"/> use an <strong class="bold">autoload</strong>.</p>
			<p class="callout-heading">About autoloads</p>
			<p class="callout">In Godot, you can configure a script or scene as an autoload. This means that the engine will automatically load it at all times. Even if you change the current scene in <code>SceneTree</code>, the autoloaded node will remain. You can also refer to that autoloaded scene by name from any other node in your game.</p>
			<p>In the <code>game_state.gd</code> and add the following code:</p>
			<pre class="source-code">
extends Node
var num_levels = 2
var current_level = 0
var game_scene = "res://main.tscn"
var title_screen = "res://ui/title.tscn"
func restart():
    current_level = 0
    get_tree().change_scene_to_file(title_screen)
func next_level():
    current_level += 1
    if current_level &lt;= num_levels:
        get_tree().change_scene_to_file(game_scene)</pre>
			<p>You should set <code>num_levels</code> to the number of levels you’ve created in the <code>levels</code> folder. Make sure you name them consistently as <code>level_01.tscn</code>, <code>level_02.tscn</code>, and so on so that they can be found easily.</p>
			<p>To add this script as an autoload, open <code>game_state.gd</code> and then click the <strong class="bold">Add</strong> button.</p>
			<p>Next, add this script to your <code>Main</code> scene:</p>
			<pre class="source-code">
extends Node
func _ready():
    var level_num = str(GameState.current_level).pad_zeros(2)
    var path = "res://levels/level_%s.tscn" % level_num
    var level = load(path).instantiate()
    add_child(level)</pre>
			<p>Now, whenever the <code>Main</code> scene is loaded, it will include the level scene that corresponds to the current level.</p>
			<p>The title screen needs to transition to the game scene, so attach this script to the <code>Title</code> node:</p>
			<pre class="source-code">
extends Control
func _input(event):
    if event.is_action_pressed("ui_select"):
        GameState.next_level()</pre>
			<p>Finally, you can call the <code>restart()</code> function when the player dies by adding it to <code>level.gd</code>. In the <code>Level</code> scene, connect the <code>Player</code> instance’s <code>died</code> signal:</p>
			<pre class="source-code">
func _on_player_died():
    GameState.restart()</pre>
			<p>You should now be able to play through the game fully. Make sure <code>title.tscn</code> is set as the game’s main scene (that is, the <a id="_idIndexMarker330"/>one that runs first). If you’ve previously set a different scene to be the “main” scene, you can change this in <strong class="bold">Projects Settings</strong> under <strong class="bold">Application/Run</strong>:</p>
			<div><div><img src="img/B19289_04_27.jpg" alt="Figure 4.26: Choosing a main scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26: Choosing a main scene</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Transitioning between levels</h1>
			<p>Your levels now need <a id="_idIndexMarker331"/>a way to transition from one to the next. In the <code>res://assets/environment/props.png</code> sprite sheet, there is an image of a door that you can use for your level’s exit. Finding and walking into the door will take the player to the next level.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Door scene</h2>
			<p>Make a new scene with an <code>Area2D</code> node <a id="_idIndexMarker332"/>named <code>Door</code> and save it in the <code>items</code> folder. Add a <code>Sprite2D</code> node and use the <code>props.png</code> image as <code>-8</code>. This will ensure that when the door is placed at the tile location, it will be positioned correctly.</p>
			<p>Add a <code>CollisionShape2D</code> node and give it a rectangular shape that covers the door. Put the door on the <code>items</code> layer and set its mask so that it only scans the <code>player</code> layer.</p>
			<p>This scene doesn’t need a script because you’re just going to use its <code>body_entered</code> signal in the level script.</p>
			<p>To place the door in the level, you <a id="_idIndexMarker333"/>can use the door object from the <code>tiles_items</code> tileset, which you are using in your <code>Items</code> tilemap to place the cherries and gems. Place a door in your level and open <code>level.gd</code>.</p>
			<p>At the top of <code>level.gd</code>, define the door scene:</p>
			<pre class="source-code">
var door_scene = load("res://items/door.tscn")</pre>
			<p>Then, update <code>spawn_items()</code> so that it also instantiates doors:</p>
			<pre class="source-code">
func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        if type == "door":
            var door = door_scene.instantiate()
            add_child(door)
            door.position = $Items.map_to_local(cell)
            door.body_entered.connect(_on_door_entered)
        else:
            var item = item_scene.instantiate()
            add_child(item)
            item.init(type, $Items.map_to_local(cell))
            item.picked_up.connect(self._on_item_picked_up)</pre>
			<p>Add the function that will be called when the player touches the door:</p>
			<pre class="source-code">
func _on_door_entered(body):
    GameState.next_level()</pre>
			<p>Play the game and try walking into the door. If you’ve set <code>num_levels</code> in <code>game_state.gd</code> to a number greater than 1, the game will attempt to load <code>level_02.tscn</code> when you<a id="_idIndexMarker334"/> touch the door.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Screen settings</h2>
			<p>Recall that at the beginning of this chapter, you set <code>canvas_items</code> and <code>expand</code>, respectively. Run the game, and then try resizing the game window. Notice that if you make the window wider, you can see more of the game<a id="_idIndexMarker335"/> world to the player’s left/right. This is what the <code>expand</code> value is doing.</p>
			<p>If you want to prevent this, you can set it to <code>keep</code> instead, which will always show the same amount of the game world as shown by the camera. However, it also means that if you make your window a different shape than the game, you’ll get black bars to fill in the extra space.</p>
			<p>Alternatively, setting <code>ignore</code> will not display the black bars, but the game content will be stretched to fill the space, distorting the image.</p>
			<p>Take some time to experiment with the various settings and decide which one you prefer.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Finishing touches</h1>
			<p>Now that you’ve completed the main structure of the game, and hopefully designed a few levels for the<a id="_idIndexMarker336"/> player to enjoy, you can consider making some additions to improve the gameplay. In this section, you’ll find a few more suggested features – add them as-is or adjust them to your liking.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Sound effects</h2>
			<p>As with the previous projects, you can add audio effects and music to improve the experience. In <code>res://assets/audio/</code>, you’ll find audio files you can use for different game<a id="_idIndexMarker337"/> events, such as player jump, enemy hit, and item pickup. There are also two music files: <code>Intro Theme</code> for the title screen and <code>Grasslands Theme</code> for the level scene.</p>
			<p>Adding these to the game will be left to you, but here are a few tips:</p>
			<ul>
				<li>You may find it helpful to adjust the volume of individual sounds. This can be set with the <strong class="bold">Volume dB</strong> property. Setting a negative value will reduce the sound’s volume.</li>
				<li>You can attach the music to the master <code>level.tscn</code> scene; that music will be used for all levels. You could also attach separate music to individual levels if you want to set a certain mood.</li>
				<li>Your first thought might be to put <code>AudioStreamPlayer</code> on the <code>Item</code> scene to play the pickup sound. However, since the pickup is deleted when the player touches it, that won’t work well. Instead, put the audio player in the <code>Level</code> scene, since that’s where the result of the pickup is handled (increasing the score).</li>
			</ul>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Double jumping</h2>
			<p>Double jumps are a popular <a id="_idIndexMarker338"/>platforming feature. The player gets a second, usually smaller, upwards boost if they press the jump key a second time while in the air. To implement this feature, you need to add a few things to the player script.</p>
			<p>First, you will need variables to track the number of jumps and determine how big the second boost will be:</p>
			<pre class="source-code">
@export var max_jumps = 2
@export var double_jump_factor = 1.5
var jump_count = 0</pre>
			<p>When entering the <code>JUMP</code> state, reset the number of jumps:</p>
			<pre class="source-code">
JUMP:
    $AnimationPlayer.play("jump_up")
    jump_count = 1</pre>
			<p>In <code>get_input()</code>, allow the jump if it meets the conditions that have been. Put this before the <code>if</code> statement where <a id="_idIndexMarker339"/>you check if the player is on the floor:</p>
			<pre class="source-code">
if jump and state == JUMP and jump_count &lt; max_jumps and jump_count &gt; 0:
    $JumpSound.play()
    $AnimationPlayer.play("jump_up")
    velocity.y = jump_speed / double_jump_factor
    jump_count += 1</pre>
			<p>In <code>_physics_process()</code>, when you land on the ground, reset the jump count:</p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)
    jump_count = 0</pre>
			<p>Play your game and try out the double jumps. Note that this code makes the second jump 2/3rds the size of the upward speed of the initial jump. You can adjust this according to your preferences.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Dust particles</h2>
			<p>Spawning dust particles at the <a id="_idIndexMarker340"/>character’s feet is a low-effort effect that can add a lot of character to your player’s movements. In this section, you’ll add a small puff of dust to the player’s feet that is emitted whenever they land on the ground. This adds a sense of weight and impact to the player’s jumps.</p>
			<p>Add a <code>CPUParticles2D</code> node to the <code>Player</code> scene and name it <code>Dust</code>. Set the following properties:</p>
			<table id="table003" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Amount</p>
						</td>
						<td class="No-Table-Style">
							<p><code>20</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Lifetime</p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.45</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>One Shot</p>
						</td>
						<td class="No-Table-Style">
							<p><code>On</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Speed Scale</p>
						</td>
						<td class="No-Table-Style">
							<p><code>2</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Explosiveness</p>
						</td>
						<td class="No-Table-Style">
							<p><code>0.7</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Emission Shape</p>
						</td>
						<td class="No-Table-Style">
							<p><code>Rectangle</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Rect Extents</p>
						</td>
						<td class="No-Table-Style">
							<p><code>1, 6</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Initial Velocity Max</p>
						</td>
						<td class="No-Table-Style">
							<p><code>10</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Scale Amount Max</p>
						</td>
						<td class="No-Table-Style">
							<p><code>3</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Position</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>2, 0</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Rotation</p>
						</td>
						<td class="No-Table-Style">
							<p><code>-</code><code>90</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>The default particle color is white, but the dust effect will look better in a tan shade. It should also fade away so that it appears to dissipate. This can be accomplished with <code>Gradient</code>. In the <strong class="bold">Color/Color Ramp</strong> area, select <strong class="bold">New Gradient</strong>.</p>
			<p><code>Gradient</code> has two colors: a start<a id="_idIndexMarker341"/> color on the left and an end color on the right. These can be selected using the small rectangles at either end of the gradient. Clicking on the large square on the right allows you to set the color for the selected rectangle:</p>
			<div><div><img src="img/B19289_04_28.jpg" alt="Figure 4.27: Color Ramp"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27: Color Ramp</p>
			<p>Set the start color to a tan shade, and set the end to the same color, but with the alpha value set to <code>0</code>. You should see a continuously puffing smoke effect. In the Inspector, set <strong class="bold">One Shot</strong> to on. Now, the particles will only emit once, each time you check the <strong class="bold">Emitting</strong> box.</p>
			<p>Feel free to alter the <a id="_idIndexMarker342"/>properties that have been provided here. Experimenting with particle effects can be great fun, and often, you’ll stumble upon a very nice effect just by tinkering.</p>
			<p>Once you’re happy with its appearance, add the following to the player’s <code>_physics_process()</code> code:</p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)
    $Dust.emitting = true</pre>
			<p>Run the game and observe the puff of dust every time your character lands on the ground.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Ladders</h2>
			<p>The player sprite sheet includes<a id="_idIndexMarker343"/> frames for a climbing animation, and the tileset contains<a id="_idIndexMarker344"/> ladder images. Currently, the ladder tiles do nothing – in <code>TileSet</code>, they do not have any collision shape assigned. That’s OK because you don’t want the player to collide with the ladders – you want them to be able to move up and down on them.</p>
			<h3>Player code</h3>
			<p>Start by selecting the player’s <code>AnimationPlayer</code> node <a id="_idIndexMarker345"/>and adding a new animation called <code>climb</code>. Its <code>0.4</code> and it should be set to <code>Sprite2D</code> are <em class="italic">0 -&gt; 1 -&gt; 0 -&gt; </em><em class="italic">2</em>.</p>
			<p>Go to <code>player.gd</code> and add a new state, <code>CLIMB</code>, to the <code>state</code> enum. In addition, add two new variable declarations at the top of the script:</p>
			<pre class="source-code">
@export var climb_speed = 50
var is_on_ladder = false</pre>
			<p>You’ll use <code>is_on_ladder</code> to keep track of whether the player is on a ladder or not. Using this, you can decide whether the up and down actions should have any effect.</p>
			<p>In <code>change_state()</code>, add a condition for the new state:</p>
			<pre class="source-code">
CLIMB:
    $AnimationPlayer.play("climb")</pre>
			<p>In <code>get_input()</code>, you need to check for the input actions and then determine if they change the state:</p>
			<pre class="source-code">
var up = Input.is_action_pressed("climb")
var down = Input.is_action_pressed("crouch")
if up and state != CLIMB and is_on_ladder:
    change_state(CLIMB)
if state == CLIMB:
    if up:
        velocity.y = -climb_speed
        $AnimationPlayer.play("climb")
    elif down:
        velocity.y = climb_speed
        $AnimationPlayer.play("climb")
    else:
        velocity.y = 0
        $AnimationPlayer.stop()
if state == CLIMB and not is_on_ladder:
    change_state(IDLE)</pre>
			<p>Here, you have three new conditions to check. First, if the player is not in the <code>CLIMB</code> state but is on a ladder, then pressing up should make the player start climbing. Second, if the player is currently climbing, then the up and down inputs should make them move up and down the ladder, but <a id="_idIndexMarker346"/>stop the animation from playing if no action is pressed. Finally, if the player leaves the ladder while climbing, they leave the <code>CLIMB</code> state.</p>
			<p>You also need to make sure that gravity doesn’t pull the player downward while they’re on a ladder. Add a condition to the gravity code in <code>_physics_process()</code>:</p>
			<pre class="source-code">
if state != CLIMB:
    velocity.y += gravity * delta</pre>
			<p>Now, the player is ready to climb, which means you can add some ladders to your level.</p>
			<h3>Level setup</h3>
			<p>Add an <code>Area2D</code> node named <code>Ladders</code> to the <code>Level</code> scene, but<a id="_idIndexMarker347"/> don’t add a collision shape to it yet. Connect its <code>body_entered</code> and <code>body_exited</code> signals and set its collision <code>items</code> and <code>player</code>. This ensures that only the player can interact with the ladder. These signals are how you’ll let the player know they are or aren’t on a ladder:</p>
			<pre class="source-code">
func _on_ladders_body_entered(body):
    body.is_on_ladder = true
func _on_ladders_body_exited(body):
    body.is_on_ladder = false</pre>
			<p>Now, the level needs to look for any ladder tiles and add collision shapes to the <code>Ladders</code> area whenever it finds <a id="_idIndexMarker348"/>one. Add the following function to <code>level.gd</code> and call it in <code>_ready()</code>:</p>
			<pre class="source-code">
func create_ladders():
    var cells = $World.get_used_cells(0)
    for cell in cells:
        var data = $World.get_cell_tile_data(0, cell)
        if data.get_custom_data("special") == "ladder":
            var c = CollisionShape2D.new()
            $Ladders.add_child(c)
            c.position = $World.map_to_local(cell)
            var s = RectangleShape2D.new()
            s.size = Vector2(8, 16)
            c.shape = s</pre>
			<p>Note that the collision shapes you’re adding are only <code>8</code> pixels wide. If you make the shape the full width of the ladder tile, then the player will still look as though they’re climbing even when they’re hanging off the side, which looks a bit odd.</p>
			<p>Try it out – go to one of your level scenes and place some ladder tiles anywhere you’d like on your <code>World</code> tile map. Play the scene and try climbing the ladders.</p>
			<p>Note that if you’re at the top of a ladder and step on it, you’ll fall to the bottom rather than climb down (although pressing up as you fall will cause you to grab the ladder). If you prefer to automatically transition to the climbing state, you can add an additional falling check in <code>_physics_process()</code>.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Moving platforms</h2>
			<p>Moving platforms are<a id="_idIndexMarker349"/> a fun addition to your level design toolkit. In this section, you’ll make a moving platform that you can place anywhere on your level and set its movement and speed.</p>
			<p>Start with a new scene using a <code>Node2D</code> node and name it <code>MovingPlatform</code>. Save the scene and add <code>TileMap</code> as a child. Since your platform art is all in sprite sheets and they’ve already been sliced into tiles and had collisions added, this will make your platform easy to draw. Add <code>tiles_world.tres</code> as <strong class="bold">Tile Set</strong>. You’ll also need to check the <strong class="bold">Collision Animatable</strong> box, which will make sure the collisions work properly even while moving.</p>
			<p>Draw a few tiles into <code>TileMap</code>, but make sure to start at the origin, <code>(0, 0)</code>, so that things will line up cleanly. These tiles work well for a floating platform:</p>
			<div><div><img src="img/B19289_04_29.jpg" alt="Figure 4.28: Floating platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28: Floating platform</p>
			<p>Add a script to the root node and start with these variables:</p>
			<pre class="source-code">
@export var offset = Vector2(320, 0)
@export var duration = 10.0</pre>
			<p>These will allow you to set the movement amount and speed. <code>offset</code> is relative to the starting point, and since it’s a <code>Vector2</code> node, you can have platforms that move horizontally, vertically, or diagonally. <code>duration</code> is measured in seconds and represents how long the <em class="italic">complete</em> cycle will take.</p>
			<p>The platform will always be moving, so you can start the animation in <code>_ready()</code>. It will use a <code>tween</code> method to animate the position in two steps: from the start position to the offset position and vice versa:</p>
			<pre class="source-code">
func _ready():
    var tween = create_tween().set_process_mode(
        Tween.TWEEN_PROCESS_PHYSICS)
    tween.set_loops().set_parallel(false)
    tween.tween_property($TileMap, "position", offset,
        duration / 2.0).from_current()
    tween.tween_property($TileMap, "position",
        Vector2.ZERO, duration / 2.0)</pre>
			<p>Here are a few notes about tween usage:</p>
			<ul>
				<li>You need to set the process mode so that the movement will be synced to physics and the player will be able to collide properly with the platform (that is, stand on it).</li>
				<li><code>set_loops()</code> tells <code>tween</code> to repeat once finished.</li>
				<li><code>set_parallel(false)</code> tells <code>tween</code> to perform the two property tweens sequentially rather than at<a id="_idIndexMarker350"/> the same time.</li>
				<li>You can also experiment with other tween curves. Adding <code>tween.set_trans(Tween.TRANS_SINE)</code>, for example, will make the platform slow down at the ends of the movement for a more natural look. Try experimenting with the other transition types.</li>
			</ul>
			<p>Now, you can add instances of <code>MovingPlatform</code> to the level scene. To make sure things line up properly, make sure you turn on grid snapping:</p>
			<div><div><img src="img/B19289_04_30.jpg" alt="Figure 4.29: Enabling grid snapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29: Enabling grid snapping</p>
			<p>The default value is <code>(8, 8)</code>, but you can change it by clicking the three dots next to the icon and choosing <strong class="bold">Configure Snap</strong>.</p>
			<p>When you run the game now, you will have a lot more to interact with. The ladders and moving platforms give you a lot more possibilities for your level designs. But you don’t have to stop there! Considering everything you’ve done in this chapter, there are many other features that you could still add. The player animation includes a “crouching” animation – what if the enemies could throw things at the player that could be ducked under? Many platformer <a id="_idIndexMarker351"/>games include additional movement mechanics such as sliding down slopes, wall jumps, changing gravity, and many more. Choose one and see if you can add it.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Summary</h1>
			<p>In this chapter, you learned how to use the <code>CharacterBody2D</code> node to create arcade-style physics for player movement. This is a powerful node that can be used for a wide variety of game objects – not just platform characters.</p>
			<p>You learned about the <code>TileMap</code> node for level design – a powerful tool with even more features than you used in this project. An entire chapter could be written on all of the different things you can do with it. For more information, see the <em class="italic">Using TileMaps</em> page on the Godot documentation website: https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html.</p>
			<p><code>Camera2D</code> and <code>ParallaxBackground</code> are also key tools for any game where you want to move around in a world that’s bigger than the size of the screen. The camera node in particular will be a node that you’ll use in most 2D projects.</p>
			<p>You also made extensive use of what you learned in earlier projects to tie everything together. Hopefully, at this point, you have a good grasp of the scene system and how a Godot project is structured.</p>
			<p>Once again, before moving on, take a few moments to play your game and look through its various scenes and scripts to review how you built it. Review any sections of this chapter that you found particularly tricky. And most importantly, before moving on, try to make some changes to the project.</p>
			<p>In the next chapter, you’ll make the jump to 3D!</p>
		</div>
	</body></html>